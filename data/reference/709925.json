[
    {
        "link": "https://stackoverflow.com/questions/94037/convert-character-to-ascii-code-in-javascript",
        "document": "How can I convert a character to its ASCII code using JavaScript?\n\nHere is the documentation for : The method returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index. The UTF-16 code unit matches the Unicode code point for code points which can be represented in a single UTF-16 code unit. If the Unicode code point cannot be represented in a single UTF-16 code unit (because its value is greater than ) then the code unit returned will be the first part of a surrogate pair for the code point. If you want the entire code point value, use . If you need to support non-BMP Unicode characters like U+1F602 üòÇ, then don't use , as it will not return 128514 (or 0x1f602 in hexadecimal), it will give a result you don't expect: console.log(\"\\u{1f602}\".charCodeAt(0)); // prints 55357 , which is 0xd83d in hexadecimal\n\nIf you have only one char and not a string, you can use: It used to be significantly slower than , but I've tested it now and I do not see any difference anymore (executed 10 billions times with and without the 0). Tested for performance only in Chrome and Firefox.\n\nWhile the other answers are right, I prefer this way: I am using this for a small shortcut system: And you can even use it inside map() or other methods:\n\nExpanding on the comments by √Ålvaro Gonz√°lez and others, charCodeAt or codePointAt are mighty fine if you are working with the 128 original ASCII characters only (codes 0 to 127). Outside of this range, the code is dependent on the character set, and you need a charset conversion before calculating it if you want the result to make sense. Let's take the Euro sign as an example: returns , which is well outside the 0-127 range and is relative to the UTF-16 (or UTF-8) charset. I was porting a Visual Basic program, and noticed that it made use of the function to get the character code. Obviously from its point of view, it would return the character code in the Windows-1252 character set. To be sure to obtain the same number, I need to convert the string charset and then calculate the code. Pretty straightforward e.g. in Python: .\n\n To achieve the same in Javascript, however, I had to resort to buffers and a conversion library:\n\nAs others have pointed out, ASCII only covers 128 characters (including non-printing characters). Unicode includes ASCII as its first 128 characters for the purpose of backwards compatibility, but it also includes far more characters. To get only ASCII character codes as integers, you can do the following: function ascii_code (character) { // Get the decimal code let code = character.charCodeAt(0); // If the code is 0-127 (which are the ASCII codes, if (code < 128) { // Return the code obtained. return code; // If the code is 128 or greater (which are expanded Unicode characters), }else{ // Return -1 so the user knows this isn't an ASCII character. return -1; }; }; If you're looking for only the ASCII characters in a string (for say, slugifying a string), you could do something like this: function ascii_out (str) { // Takes a string and removes non-ASCII characters. // For each character in the string, for (let i=0; i < str.length; i++) { // If the character is outside the first 128 characters (which are the ASCII // characters), if (str.charCodeAt(i) > 127) { // Remove this character and all others like it. str = str.replace(new RegExp(str[i],\"g\"),''); // Decrement the index, since you just removed the character you were on. i--; }; }; return str };"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt",
        "document": "The method of values returns an integer between and representing the UTF-16 code unit at the given index. always indexes the string as a sequence of UTF-16 code units, so it may return lone surrogates. To get the full Unicode code point at the given index, use .\n\nCharacters in a string are indexed from left to right. The index of the first character is , and the index of the last character in a string called is . Unicode code points range from to ( ). always returns a value that is less than , because the higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, in order to get a full character with value greater than , it is necessary to retrieve not only , but also (as if manipulating a string with two characters), or to use instead. For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters.\n\nThe following example returns , the Unicode value for A. may return lone surrogates, which are not valid Unicode characters. const str = \"†Æ∑†Ææ\"; console.log(str.charCodeAt(0)); // 55362, or d842, which is not a valid Unicode character console.log(str.charCodeAt(1)); // 57271, or dfb7, which is not a valid Unicode character To get the full Unicode code point at the given index, use . Note: Avoid re-implementing using . The translation from UTF-16 surrogates to Unicode code points is complex, and may be more performant as it directly uses the internal representation of the string. Install a polyfill for if necessary. Below is a possible algorithm to convert a pair of UTF-16 code units into a Unicode code point, adapted from the Unicode FAQ:"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-convert-character-to-ascii-code-using-javascript",
        "document": ""
    },
    {
        "link": "https://codemia.io/knowledge-hub/path/convert_character_to_ascii_code_in_javascript",
        "document": "Enhance your system design skills with over 120 practice problems, detailed solutions, and hands-on exercises."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode",
        "document": "Because is a static method of , you always use it as , rather than as a method of a value you created.\n\nUnicode code points range from to ( ). always returns a value that is less than , because the higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, in order to produce a full character with value greater than , it is necessary to provide two code units (as if manipulating a string with two characters). For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters.\n\nBecause only works with 16-bit values (same as the escape sequence), a surrogate pair is required in order to return a supplementary character. For example, both and return code point \"Night with Stars\". While there is a mathematical relationship between the supplementary code point value (e.g. ) and both surrogate values that represent it (e.g., and ), it does require an extra step to either calculate or look up the surrogate pair values every time a supplementary code point is to be used. For this reason, it's more convenient to use , which allows for returning supplementary characters based on their actual code point value. For example, returns code point \"Night with Stars\"."
    },
    {
        "link": "https://w3schools.com/js/js_bitwise.asp",
        "document": "JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n\nBefore a bitwise operation is performed, JavaScript converts numbers to 32 bits signed integers.\n\nAfter the bitwise operation is performed, the result is converted back to 64 bits JavaScript numbers.\n\nThe examples above uses 4 bits unsigned binary numbers. Because of this ~ 5 returns 10. Since JavaScript uses 32 bits signed integers, it will not return 10. It will return -6. A signed integer uses the leftmost bit as the minus sign.\n\nWhen a bitwise AND is performed on a pair of bits, it returns 1 if both bits are 1.\n\nWhen a bitwise OR is performed on a pair of bits, it returns 1 if one of the bits is 1:\n\nWhen a bitwise XOR is performed on a pair of bits, it returns 1 if the bits are different:\n\nBitwise AND returns 1 only if both bits are 1:\n\nBitwise OR returns 1 if one of the bits is 1:\n\nBitwise XOR returns 1 if the bits are different:\n\nThis is a zero fill left shift. One or more zero bits are pushed in from the right, and the leftmost bits fall off:\n\nThis is a sign preserving right shift. Copies of the leftmost bit are pushed in from the left, and the rightmost bits fall off:\n\nThis is a zero fill right shift. One or more zero bits are pushed in from the left, and the rightmost bits fall off:\n\nBinary numbers with only one bit set are easy to understand:\n\nSetting a few more bits reveals the binary pattern:\n\nThis means that a negative number is the bitwise NOT of the number plus 1:"
    },
    {
        "link": "http://w3schools.com/Js/js_bitwise.asp",
        "document": "JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n\nBefore a bitwise operation is performed, JavaScript converts numbers to 32 bits signed integers.\n\nAfter the bitwise operation is performed, the result is converted back to 64 bits JavaScript numbers.\n\nThe examples above uses 4 bits unsigned binary numbers. Because of this ~ 5 returns 10. Since JavaScript uses 32 bits signed integers, it will not return 10. It will return -6. A signed integer uses the leftmost bit as the minus sign.\n\nWhen a bitwise AND is performed on a pair of bits, it returns 1 if both bits are 1.\n\nWhen a bitwise OR is performed on a pair of bits, it returns 1 if one of the bits is 1:\n\nWhen a bitwise XOR is performed on a pair of bits, it returns 1 if the bits are different:\n\nBitwise AND returns 1 only if both bits are 1:\n\nBitwise OR returns 1 if one of the bits is 1:\n\nBitwise XOR returns 1 if the bits are different:\n\nThis is a zero fill left shift. One or more zero bits are pushed in from the right, and the leftmost bits fall off:\n\nThis is a sign preserving right shift. Copies of the leftmost bit are pushed in from the left, and the rightmost bits fall off:\n\nThis is a zero fill right shift. One or more zero bits are pushed in from the left, and the rightmost bits fall off:\n\nBinary numbers with only one bit set are easy to understand:\n\nSetting a few more bits reveals the binary pattern:\n\nThis means that a negative number is the bitwise NOT of the number plus 1:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND",
        "document": "The operator is overloaded for two types of operands: number and BigInt. For numbers, the operator returns a 32-bit integer. For BigInts, the operator returns a BigInt. It first coerces both operands to numeric values and tests the types of them. It performs BigInt AND if both operands become BigInts; otherwise, it converts both operands to 32-bit integers and performs number bitwise AND. A is thrown if one operand becomes a BigInt but the other becomes a number.\n\nThe operator operates on the operands' bit representations in two's complement. Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise.\n\nThe truth table for the AND operation is:\n\nNumbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer:\n\nFor BigInts, there's no truncation. Conceptually, understand positive BigInts as having an infinite number of leading bits, and negative BigInts having an infinite number of leading bits.\n\nBitwise ANDing any number with returns converted to a 32-bit integer. Do not use to truncate numbers to integers; use instead."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-bitwise-operators",
        "document": "In JavaScript, a number is stored as a 64-bit floating-point number but bitwise operations are performed on a 32-bit binary number. To perform a bit-operation, JavaScript converts the number into a 32-bit binary number (signed) and performs the operation and converts back the result to a 64-bit number.\n\nIt is a binary operator i.e. accepts two operands. Bit-wise AND (&) returns 1 if both the bits are set ( i.e 1) and 0 in any other case.\n\nIt is a binary operator i.e. accepts two operands. Bit-wise OR ( | ) returns 1 if any of the operands is set (i.e. 1) and 0 in any other case.\n\nIt is a binary operator i.e. accepts two operands. Bit-wise XOR ( ^ ) returns 1 if both the operands are different and 0 in any other case.\n\nIt is a unary operator i.e. accepts single operands. Bit-wise NOT ( ~ ) flips the bits i.e 0 becomes 1 and 1 becomes 0.\n\nIt‚Äôs a binary operator i.e. it accepts two operands. The first operator specifies the number and the second operator specifies the number of bits to shift. Each bit is shifted towards the left and 0 bits are added from the right. The excess bits from the left are discarded.\n\nIt‚Äôs a binary operator i.e. it accepts two operands. The first operand specifies the number and the second operand specifies the number of bits to shift. Each bit is shifted towards the right, the overflowing bits are discarded. This is Sign Propagating as the bits are added from the left depending upon the sign of the number (i.e. 0 if positive and 1 if negative )\n\nIt‚Äôs a binary operator i.e. it accepts two operands. The first operand specifies the number and the second operand specifies the number of bits to shift. Each bit is shifted towards the right, the overflowing bits are discarded. 0 bit is added from the left so its zero fill right shift.\n\nHow does the & (AND) operator work?\n\nHow does the | (OR) operator work?\n\nHow does the ^ (XOR) operator work?\n\nHow does the ~ (NOT) operator work?\n\nHow does the << (Left Shift) operator work?\n\nHow does the >> (Sign-propagating Right Shift) operator work?\n\nHow does the >>> (Zero-fill Right Shift) operator work?\n\nWhat are some common uses of bitwise operators?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/using-bitwise-operators-in-javascript",
        "document": "Though bitwise operators in Javascript hardly get any attention, they are actually very powerful and have a wide variety of usage. They are considered for faster numerical calculations and conversions. We can leverage them to replace certain complex coding scenarios and make our code more readable.\n\nBy the end of this tutorial, you get a basic understanding of bitwise operators, what they are, and how to use them.\n\nBefore you begin this guide you‚Äôll need the following:\n‚Ä¢ Very basic understanding about what is binary.\n‚Ä¢ How the logical ‚Äúand‚Äù and ‚Äúor‚Äù operators work and the outcomes of using them.\n‚Ä¢ [How to use the Javascript developer console][https://www.digitalocean.com/community/tutorials/how-to-use-the-javascript-developer-console]\n‚Ä¢ [How to code in Javascript][https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript]\n\nAs bitwise operators work at binary level, it‚Äôs essential to understand what JavaScript provides for binary conversion. Believe me, it is much simpler than it sounds.\n\nWe can convert any number to a string using the function as shown below:\n\nThe function has one argument (called radix) which can be used to specify the base. The base determines the target conversion. You can pass ‚Äú2‚Äù to get binary, ‚Äú8‚Äù to get octal, and ‚Äú16‚Äù to get the hexadecimal value of the number being converted. By default it is 10 and thus returns the decimal value.\n\nAs we can see, the number 18 got converted into a binary string - 10010.\n\nThis covers the very basics of how binary conversion works in JavaScript. We can work with bitwise operators without actually knowing the binary conversion. However, we may not be able to understand how the result of the bitwise operator gets calculated. Let‚Äôs see this in action.\n\nFor this tutorial, let‚Äôs consider basic numbers for bitwise operations. The numbers we are going to use will be 1, 2, and 3. Here is the list of binary numbers for each of them.\n\nThe bitwise AND operator can be used using a symbol ‚Äú&‚Äù (note that we use double ‚Äú&‚Äù for logical AND operations among non-binary variables)\n\nHere is what ‚Äú&‚Äù returns for bits:\n\nThis is very similar to our logical AND operation - If both the conditions are true then return true otherwise return false. In this case, the true is replaced by 1 and 0 equals to false.\n\nJavaScript generates the resulting binary number by comparing each binary bit. The table below shows the bitwise AND between number 1 and 3.\n\nIf we convert the resulting string 001 to decimal then we will get ‚Äú1‚Äù as output. So, ‚Äú1‚Äù & ‚Äú3‚Äù results in ‚Äú1‚Äù. Internally, JavaScript recognizes the bitwise operator and converts 1 and 3 into binary format and applies bitwise AND for each bit and converts the resulting binary string to decimal number. You can quickly try this in your browser console by hitting F12 and typing:\n\nThe Bitwise OR uses single symbol ‚Äú|‚Äù.\n\nHere is what ‚Äú|‚Äù returns for bits:\n\nThis is similar to logical OR operation - where if any one condition is true then return true otherwise return false. In this case, the true is replaced by 1 and 0 equals to false.\n\nThe table below shows the Bitwise OR between number 1 and 3.\n\nIf we convert the resulting string 011 to decimal then we will get ‚Äú3‚Äù as output. So, ‚Äú1‚Äù | ‚Äú3‚Äù results in ‚Äú3‚Äù. Internally, JavaScript recognizes the bitwise operator and converts 1 and 3 into binary format and applies bitwise OR for each bit and converts the resulting binary string to decimal number.\n\nThe symbol for bitwise XOR is ‚Äú^‚Äù.\n\nHere is what ‚Äú^‚Äù returns for bits:\n\nThe rule for XOR (exclusive OR) is that if both bits are different then return ‚Äú1‚Äù else ‚Äú0‚Äù. The XOR between 1 and 3 would return 2. Here is the explanation:\n\nThe left side number of the shift operator is the actual number and the right side of the operator is the position. For example, ‚Äú5 << 2‚Äù tells Javascript to perform a shift left on number 5 for two positions. Here is how JavaScript actually performs the shift left operation.\n‚Ä¢ It converts the number to the binary equivalent. In our case, number 5 will be converted to binary form that is - 101.\n‚Ä¢ Adds two 00s to the right of the binary string. This will result in 10100 for number 5.\n‚Ä¢ Convert the binary string to a decimal number. In our case, it will be 20. So, will result in number 20.\n\nShift right operator will remove binary numbers from right. How many numbers will be removed? As you might have guessed, the number mentioned as the position.\n\nHere is an example. Let‚Äôs say we have 5 >> 2.\n‚Ä¢ JavaScript will convert 5 to binary equivalent. 101 in our case.\n‚Ä¢ Remove two numbers from the right side. This will result in 101.\n‚Ä¢ Convert the result into decimal. The result will be 1 in our case.\n\nBitwise operators sound very complex at the first, however, once we understand the basics, it is very simple. We can convert any number to binary using the \".toString(2)‚Äù method. The conversion will help to understand the output of the bitwise operator. All the bitwise operators work at the bit level after converting operands to binary format.\n‚Ä¢ Bitwise AND returns 1 if both the bits are 1 else 0.\n‚Ä¢ Bitwise OR returns 1 if at least one of the bits is 1 else 0.\n‚Ä¢ Bitwise XOR only returns 1 if both operands are different. Otherwise returns 0.\n‚Ä¢ Shift left adds 0s in the end mentioned in the second operand and shift right just removes bits mentioned as the second operands.\n\nHope this brief introduction helped to understand the bitwise operator and how its results are being calculated."
    },
    {
        "link": "https://stackoverflow.com/questions/39334494/converting-large-numbers-from-binary-to-decimal-and-back-in-javascript",
        "document": "I have a very large number represented as binary in JavaScript:\n\nWhen I convert it to decimal by use of l it gives me but when I try to convert it back to binary:\n\nit returns (which I think is related to how works by rounding value) when I was expecting to see my original binary representation of . Can you explain me such behavior? And how I can convert it back to original state in JavaScript?\n\nEDIT: This question is a result of my experiment where I was playing around with storing and transferring large amount of boolean data. The is a representation of a collection of boolean values which has to be shared between client, client worker and server."
    },
    {
        "link": "https://stackoverflow.com/questions/10258828/how-to-convert-binary-string-to-decimal",
        "document": "The function converts strings to numbers, and it takes a second argument specifying the base in which the string representation is:\n\nSee it in action."
    },
    {
        "link": "https://geeksforgeeks.org/binary-to-decimal-conversion-using-javascript",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt",
        "document": "The function converts its first argument to a string, parses that string, then returns an integer or .\n\nIf not , the return value will be the integer that is the first argument taken as a number in the specified . (For example, a of converts from a decimal number, converts from octal, from hexadecimal, and so on.)\n\nThe argument is converted to a number. If it's unprovided, or if the value becomes 0, or ( is coerced to ), JavaScript assumes the following:\n‚Ä¢ If the input , with leading whitespace and possible / signs removed, begins with or (a zero, followed by lowercase or uppercase X), is assumed to be and the rest of the string is parsed as a hexadecimal number.\n‚Ä¢ If the input begins with any other value, the radix is (decimal).\n\nNote: Other prefixes like , which are valid in number literals, are treated as normal digits by . does not treat strings beginning with a character as octal values either. The only prefix that recognizes is or for hexadecimal values ‚Äî everything else is parsed as a decimal value if is missing. or can be used instead to parse these prefixes.\n\nIf the radix is , allows the string to be optionally prefixed by or after the optional sign character ( / ).\n\nIf the radix value (coerced if necessary) is not in range [2, 36] (inclusive) returns .\n\nFor radices above , letters of the English alphabet indicate numerals greater than . For example, for hexadecimal numbers (base ), through are used. The letters are case-insensitive.\n\nunderstands exactly two signs: for positive, and for negative. It is done as an initial step in the parsing after whitespace is removed. If no signs are found, the algorithm moves to the following step; otherwise, it removes the sign and runs the number-parsing on the rest of the string.\n\nIf encounters a character in the input string that is not a valid numeral in the specified , it ignores it and all succeeding characters and returns the integer value parsed up to that point. For example, returns because is not a valid numeral in the binary number system. Likewise, although technically encodes an integer (and will be correctly parsed to the integer by ), returns , because is not a valid numeral in base 10. Because is not a numeral either, the return value will always be an integer.\n\nIf the first character cannot be converted to a number with the radix in use, returns . Leading whitespace is allowed.\n\nFor arithmetic purposes, the value is not a number in any radix. You can call the function to determine if the result of is . If is passed on to arithmetic operations, the operation result will also be .\n\nBecause large numbers use the character in their string representation (e.g. for 6.022 √ó 1023), using to truncate numbers will produce unexpected results when used on very large or very small numbers. should not be used as a substitute for .\n\nTo convert a number to its string literal in a particular radix, use .\n\nBecause returns a number, it may suffer from loss of precision if the integer represented by the string is outside the safe range. The function supports parsing integers of arbitrary length accurately, by returning a ."
    },
    {
        "link": "https://masteringjs.io/tutorials/tools/binary-to-decimal",
        "document": "A binary number is a number expressed in base-2, as opposed to conventional decimal numbers in base-10.\n\nWe also have a tool to convert decimal to binary.\n\nConverting binary numbers to decimal is easy. For example, creates a new variable that contains the number as a string . JavaScript has a method that takes a and parameter, and returns a number. Calling tells JavaScript to convert to a number containing the decimal representation of . If is not a string, it will be converted to one using the function.\n\nThe method also handles non-integers and negative numbers. For example:\n\nHow do you quickly convert to without a computer? It takes some practice to make it easy, but here's a few ways to convert a binary string to a decimal number. One method discussed is doubling, described below:\n‚Ä¢ Starting from the left, double your previous total and add the current digit.\n‚Ä¢ Double your current total and add the next leftmost digit.\n‚Ä¢ Repeat the previous step until you have gone through the entire string.\n\nBelow is a JavaScript function that implements the above procedure:\n\nHere's what the procedure looks like with 101010:"
    }
]