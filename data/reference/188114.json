[
    {
        "link": "https://discussions.unity.com/t/creating-a-camera-controller-for-isometric-view-positioning-the-camera/211973",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-to-do-a-camera-that-is-top-down-isometric/1686",
        "document": ""
    },
    {
        "link": "https://studica.com/blog/isometric-camera-unity?srsltid=AfmBOooJKR87Ev5dfyWPphjwdZuJ0Odm_Oy4a10Mwj3IwlyeXH5I5OKS",
        "document": "In this post, I will provide step-by-step instructions on how to create a simple isometric camera and character controller in Unity. By the end of this tutorial, you should have a simple 3D character that you can move around in an isometric scene using the WASD keys on your keyboard.\n\nWhat is an Isometric Game?\n\nAn isometric game is one that utilizes an isometric point of view for the camera. Some popular examples would be games like StarCraft, Diablo, Torchlight, Bastion, or Transistor. Essentially, the camera looks at the world with a 45-degree angle of rotation, from an overhead perspective.\n\nWhy Use an Isometric Camera?\n\nIn my opinion, there are mostly three reasons why you might use an isometric camera. The first reason is for the style. Having an isometric camera might be a stylistic choice for your game. Isometric perspective can make a game look 3D, even if it is 2D. In a way, it adds a sense of depth to your game. Maybe this pseudo-3D style is how you want to present your game.\n\nBecause isometric perspective creates an illusion of 3D, there is a developmental reason for using it. In general, it is faster and easier to create 2D assets for a game. 3D modeling is a more complex process that is also more hardware-intensive. Using an isometric perspective, you can create something that looks adequately 3D without having to create 3D models. This can save a developer a lot of time and money, especially in the indie game realm.\n\nThe other reason is related to gameplay. Maybe the game you have in mind requires your player to be able to see a lot of information on the screen at once. Overhead perspectives allow for this. This is a big reason why most real-time strategy games use an isometric or rotatable overhead perspective. It allows for the player to see all the enemies and allies on their screen at any given time. It gives them a lot of information about their current situation and allows them to make a more informed tactical decision. It makes it easier to select and move units on the map. Consider the idea of playing a real-time strategy game with a first-person perspective. It would be incredibly difficult for the player to select and move units around the map when they can only see what’s in front of them at any given time.\n\nConsider the above image of an older game called “Age of Kings”. You command an army of medieval warriors. With an isometric view, you’re able to select your units easily and send them around the map. Imagine trying to command all these units without an overhead perspective. It would be a nightmare.\n\nThe 45-degree rotation of the camera causes a bit of trouble for moving a character around the scene properly.\n\nConsider my MS Paint diagram below (player axis excludes y-axis):\n\nIn Unity, when we look at our scene with a 45-degree rotation on the camera’s y-axis, our world axis does not change accordingly. Instead, the world axis keeps the same rotation it always had. Now, look at the desired player axis. Ideally, we would want our D key on our keyboard to move our player directly to the right, based on our perspective as a player. Notice that the player’s desired X-Axis is 45-degrees different than the world X-axis. We want to create a controller that can account for this difference of rotation between the world axis and the player’s axis. Otherwise, if we were to not adjust for this difference, then telling our player to move right would make them follow the world axis, which would make them move up-right from our perspective. Let’s see how we can solve this problem.\n\nHow to Fix This:\n\nBefore proceeding, I want to give a shout out to a user from the Unity3D forums named EvilWarren who largely came up with this solution. I am going to assume that you already know the fundamentals of Unity. Go ahead and create a new Unity 3D project using the 3D settings.\n• Modify the terrain settings to that the terrain has a width and length of 50. To do this, click on the terrain and click on the gear icon on the terrain component in the inspector.\n• Delete the main camera from your hierarchy.\n• Create an empty game object and rename it to “CameraTarget”. Set the position to (0, 18, 0) and the rotation to (30, 45, 0). This rotation is what creates the isometric view.\n• Right-click on the “CameraTarget” game object in your hierarchy and choose “Camera” from the menu. This will be our new main camera. It must be a child of the CameraTarget object.\n• Change the tag of the new camera to the MainCamera tag.\n• Change the projection setting in the camera component to Orthographic. This will make our scene look more 2D instead of 3D. This setting is a stylistic choice. If you prefer the perspective look, then use it.\n• Change the size of the orthographic camera until you get the desired look you want. The size will change how much of the scene our camera can see.\n• Now we will create a simple player. Create a Cube Game Object\n• Before we can create a script, we need to setup our inputs. Go to Edit → Project Settings → Input\n• Change the size of the inputs to 20\n• Expand out the bottom two inputs and set them up according to the following screenshot:\n• Click on the Cube in your scene and add a new script component to it. Call the script CharController.\n• Replace the code in your script with the following code. The code is commented to help describe the logic.\n\n using System.Collections;\n\n using System.Collections.Generic;\n\n using UnityEngine; public class CharController : MonoBehaviour { \n\n Vector3 forward, right; // Keeps track of our relative forward and right vectors \n\n \n\n \n\n \n\n forward = Vector3.Normalize(forward); // make sure the length of vector is set to a max of 1.0 \n\n right = Quaternion.Euler(new Vector3(0, 90, 0)) * forward; // set the right-facing vector to be facing right relative to the camera's forward vector \n\n \n\n \n\n if(Input.anyKey) // only execute if a key is being pressed \n\n \n\n \n\n \n\n Vector3 direction = new Vector3(Input.GetAxis(\"HorizontalKey\"), 0, Input.GetAxis(\"VerticalKey\")); // setup a direction Vector based on keyboard input. GetAxis returns a value between -1.0 and 1.0. If the A key is pressed, GetAxis(HorizontalKey) will return -1.0. If D is pressed, it will return 1.0 \n\n Vector3 rightMovement = right * moveSpeed * Time.deltaTime * Input.GetAxis(\"HorizontalKey\"); // Our right movement is based on the right vector, movement speed, and our GetAxis command. We multiply by Time.deltaTime to make the movement smooth. \n\n Vector3 upMovement = forward * moveSpeed * Time.deltaTime * Input.GetAxis(\"VerticalKey\"); // Up movement uses the forward vector, movement speed, and the vertical axis inputs. Vector3 heading = Vector3.Normalize(rightMovement + upMovement); // This creates our new direction. By combining our right and forward movements and normalizing them, we create a new vector that points in the appropriate direction with a length no greater than 1.0 transform.forward = heading; // Sets forward direction of our game object to whatever direction we're moving in \n\n \n\n \n\n \n\n Vector3 heading = Vector3.Normalize(rightMovement + upMovement); // This creates our new direction. By combining our right and forward movements and normalizing them, we create a new vector that points in the appropriate direction with a length no greater than 1.0 transform.forward = heading; // Sets forward direction of our game object to whatever direction we're moving in \n\n \n\n }\n• At this point, your scene should work. Try running the game and use WASD to move your cube around the map. You will notice your cube rotate in the direction that you would expect the rotation to occur, based on your perspective of the scene.\n\nThe history of video games is littered with isometric games. It’s an incredibly common style and it’s important to understand how you can develop a game that has a permanent rotation that you must work with. This tutorial is a simple example that will hopefully help you understand how to move forward with your development. Maybe now you can finish making the gaming world’s next big Action-RPG! Be sure to check out Studica.com for academic discounts on software, electronics, robotics and more. Sign up for Studica’s email newsletter* for even greater savings!"
    },
    {
        "link": "https://reddit.com/r/MMORPG/comments/8hagyi/best_type_of_camera_view_for_a_game_type_open",
        "document": "WARNING: THIS PUBLICATION IS NOT FOR ANY REASON OR FORM OF \"SELF-PROMOTION\" IN ANY WAY. WE WANT TO BEGIN A SERIOUS DISCUSSION.\n\nMy team is making a game. As it says in the title, it is based on (Open World/SandBox ~ Hack / Slash ~ Dungeon-oriented) Our main concern at this moment is in which way of vision of the camera is oriented. since many know that this can make a big difference in the type of game, so I would like to know the opinion of all, since the community will be the one that will drive the vehicle we are building. Metaphorically speaking of games.\n\nExplanation of each type of view with examples.\n\n\"3D Third Person\" : The player's character is visible on the screen and the camera is free during movement and play. Examples: Wow, Guild Wars Etc ..\n\n\"3D First Person\" : The player experiences the action through the eyes of the protagonist. Examples: each shooting game. Like Counter Strike.\n\n\"2D & 3D Hybrid | Top-Down (Isomorphic)\" : Example: \"Diablo\" franchise. Path of exile, torchlight, Titan Quest, Grim Dawn Etc ..\n\nHybrid \"3D Third Person / First Person\" : Can switch between \"Third person\" and \"First person\". Examples : Skyrim.\n\n\"Always On The Shoulder\" - Allows you to turn the camera when it is still : Examples: God of war\n\n\"Camera Lock-On\" : Examples : The Legend of Zelda: Ocarina of Time.\n\n\"2½D or 2.5D\" : I do not think we do something like this. However, we are not closed to inclusions or tastes. we remember that we are looking for opinions and what the community wants more .\n\nFor more information about us. We are working in unity. we are a team composed of:\n\nWe want to say in advance thank you for reading our publication and that your opinion is very important to us. not only in this poll, but in any other game preference. If you have any comments, inform us.\n\nAlso, if you can share this survey, it would be wonderful. ^"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/1dmflfg/how_to_make_an_isometric_arpg",
        "document": "How to make an isometric arpg\n\nSorry, this post was deleted by the person who originally posted it."
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-Camera.html",
        "document": "Culling Mask \n\n Allows you to include or omit objects to be rendered by a Camera, by Layer. Includes or omits layers of objects to be rendered by the Camera. Assigns layers to your objects in the Inspector \n\n A Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info .\n\nCamera will render objects uniformly, with no sense of perspective. NOTE: Deferred rendering is not supported in Orthographic mode. Forward rendering \n\n A rendering path that renders each object in one or more passes, depending on lights that affect the object. Lights themselves are also treated differently by Forward Rendering, depending on their settings and intensity. More info is always used.\n\nReference to a Render Texture \n\n A special type of Texture that is created and updated at runtime. To use them, first create a new Render Texture and designate one of your Cameras to render into it. Then you can use the Render Texture in a Material just like a regular Texture. More info that will contain the output of the Camera view. Setting this reference will disable this Camera’s capability to render to the screen.\n\nOcclusion Culling \n\n A process that disables rendering GameObjects that are hidden (occluded) from the view of the camera. More info Enables Occlusion Culling for this camera. Occlusion Culling means that objects that are hidden behind other objects are not rendered, for example if they are behind walls. See Occlusion Culling for details."
    },
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.2/manual/camera-component-reference.html",
        "document": ""
    },
    {
        "link": "https://learn.unity.com/pathway/creative-core/unit/creative-core-cameras/tutorial/66fd9e15edbc2a06f73501d8?version=",
        "document": "\"Unity\", Unity logos, and other Unity trademarks are trademarks or registered trademarks of Unity Technologies or its affiliates in the U.S. and elsewhere ( more info here ). Other names or brands are trademarks of their respective owners."
    },
    {
        "link": "https://discussions.unity.com/t/where-is-unity_cameratoworld-documented/794950",
        "document": ""
    },
    {
        "link": "https://learn.unity.com/pathway/creative-core/unit/creative-core-cameras/tutorial/66fd9e15edbc2a06f73501d8",
        "document": "\"Unity\", Unity logos, and other Unity trademarks are trademarks or registered trademarks of Unity Technologies or its affiliates in the U.S. and elsewhere ( more info here ). Other names or brands are trademarks of their respective owners."
    },
    {
        "link": "https://discussions.unity.com/t/camera-follow-kind-of-script/859852",
        "document": ""
    },
    {
        "link": "https://gamedevbeginner.com/how-to-follow-the-player-with-a-camera-in-unity-with-or-without-cinemachine",
        "document": "Making a camera follow the player in Unity can be a relatively simple thing to do.\n\nHowever, because there are so many different ways of doing it, choosing the method that’s right for your project can be a little tricky.\n\nFor example, do you want a rigid camera, that tightly follows the position of the player as they move through a 2D world?\n\nOr do you want a smooth camera movement, that follows an object’s position in 3D, naturally and gradually over time?\n\nAnd how will you build your camera system?\n\nWill you use Cinemachine, Unity’s built-in suite of cinematic camera tools, or will you write it yourself using custom code?\n\nThere’s a lot to consider, but don’t worry.\n\nIn this article, you’ll learn the basic methods of creating a camera that follows the player in Unity, both with Cinemachine and without it, so that you can choose the option that’s right for your game.\n\nHere’s what you’ll learn on this page:\n• How to follow the player with a camera\n• How to follow an object with the camera smoothly\n• How to follow the player with a camera in 2D (using Cinemachine)\n• How to make a third-person camera follow the player in 3D\n• How to follow behind the player with a camera\n\nHow to follow the player with a camera\n\nGenerally speaking, there are two main ways to create a camera that follows the player in Unity.\n\nYou can build your own camera system manually which, while it can be tricky, gives you complete control over how your camera moves and how it follows the player.\n\nWhich can be great if you want to keep your camera system simple and lightweight.\n\nOr, you can use Cinemachine, which is Unity’s built-in suite of camera tools, to quickly build different types of camera system without using any code at all.\n\nCinemachine is an extremely powerful tool, providing a wide range of ready-made cameras that are highly customisable and are, typically, very easy to use.\n\nAs a result, it’s generally a good idea to decide if Cinemachine can offer the type of camera you want before trying to build one yourself as, otherwise, you may find yourself trying to build a feature or mechanic that already exists inside of Cinemachine as a ready-made option.\n\nSo what is Cinemachine, and should you be using it?\n\nWhat is Cinemachine and how does it work?\n\nCinemachine is a collection of camera tools in Unity that allows you to quickly and easily create different types of camera system, without having to code the logic of it yourself.\n\nIt works by connecting one or more virtual cameras to your existing main camera, allowing you to arrange multiple shots within a scene.\n\nIt’s sometimes associated with linear media, such as computer-animated video and in-game cutscenes, due to the wide range of compositional and framing options that allow you to create cinematic scenes inside of Unity.\n\nHowever, Cinemachine also provides extensive support for in-game camera controllers, with ready-made options for third-person cameras, orbital cameras and side-scrolling 2D cameras.\n\nAfter all, every game needs a camera and, while there are many different types of camera system that you could use in your game, most will fall into one of a few common camera types and many will require similar types of features.\n\nSuch as how to move, what to look at and camera-based effects, such as camera shake and sway.\n\nAs a result, if you’re building any type of complex camera controller, Cinemachine should absolutely be the first thing you try, as it provides ready-made solutions for common camera types and mechanics, potentially saving you a huge amount of time.\n• Find out more about Cinemachine\n\nHowever, if you’re not sure if you want to use Cinemachine yet, or if you’re not sure what type of camera system it is you’re trying to build, it can help to understand how following an object with the camera works first.\n\nWhich, whether you’re using Cinemachine or not, generally starts with choosing an object to follow.\n\nHow to make the camera follow an object\n\nTypically, making the camera follow another object, such as the player, involves specifying a target position for the camera to move to.\n\nThis could be a child object of a complex character, such as the player’s head, or a single object’s position, such as a 2D sprite.\n\nHowever, in all cases, you’ll typically need to add an offset to the target’s position, to keep the player in view.\n\nFor example, to follow a 2D object, you might offset it by two units vertically, placing the object in the lower half of the frame, and ten units back, to prevent it from clipping the camera.\n\nThe camera object can then be moved to the offset position, typically inside of Late Update, following the player as they move.\n\nPlacing the position change in Late Update prevents the camera from trying to move before the player does.\n\nThis is because the order of Update, or Fixed Update, function calls, where the target object’s movement is most likely to happen, is not guaranteed by default.\n\nMeaning that, unless you change the execution order of your scripts, the camera’s Update function could be called before the player’s, delaying its movement.\n\nPlacing the camera’s movement in Late Update schedules it after all Update functions have taken place and is typically how you’d stage logic that’s designed to happen after everything else during a frame.\n• How to use Late Update in Unity (and why it’s so useful)\n\nAlternatively, it’s possible to achieve the same effect by making the camera object a child of the player.\n\nThis causes the camera to be moved with the object in exactly the same way except that, unlike when moving the object using a script, the camera is moved with its parent.\n\nHowever, you may not want to move your camera by attaching it directly to the player.\n\nWhile setting the camera as a child of the player will make it follow the object exactly, this happens because the camera is, effectively, part of the player object.\n\nWhich, if you want the camera to move as if it’s stuck to the player, is fine.\n\nBut, if you want your camera to follow the player, instead of moving with them exactly then, chances are, you will want your camera to be able to ignore some of the player’s movements.\n\nFor example, when working in 2D, you may want to ignore the vertical movement of the camera, so that it follows the player along the x-axis only.\n\nIn this example, the camera copies the horizontal position of the object it’s following but uses its own local offset values for height and depth.\n\nThe same approach could be used to create an Isometric Camera that follows the player’s movement on the X and Z axes, but not the Y.\n\nThis can only work because the camera and its target are separate objects, meaning that the camera is able to move to a target position near to the player object, but without being directly influenced by its movements.\n\nThis also means that the camera is able to move at a different speed, which is useful if you want to create a camera that follows the player object smoothly.\n\nHow to follow an object with the camera smoothly\n\nIf you don’t want your camera to follow the player rigidly, as if it’s stuck to the player object, it’s possible to move a camera smoothly towards the player’s position instead.\n\nThis typically involves easing the movement of the camera towards its target, so that it moves with a delay, slowing as it gets closer.\n\nBut what’s the best way to do that?\n\nWhile there are a number of different ways to ease the movement of an object, some methods are better suited for camera movement than others.\n\nFor example, it’s possible to create a smooth camera movement using Lerp, which gradually adjusts the position of the object towards its target by moving it a percentage of its distance each time it’s called, slowing the object’s movement as it gets closer.\n\nAnd while this method does kind of work, and is an extremely common example of camera movement easing, it’s not really how Lerp is supposed to be used, as it will typically result in a camera movement that eases down constantly and that never quite reaches its target.\n• The right way to use Lerp in Unity\n\nSo what else could you do?\n\nAnother method to slow the movement of a camera is to use Move Towards, which can be useful for moving an object towards a position at a specific speed.\n\nHowever, this kind of movement isn’t eased, it’s only delayed, and only then if the player is able to move faster than the camera. Which also means that the player will be able to outrun the camera, which isn’t ideal.\n\nSo what’s the right way to do it?\n\nOne of the best methods for moving a camera smoothly towards a target is to use Smooth Damp, which eases the value of a Vector 3 towards a target value over an approximate period of time.\n\nThis works well for camera movement because it means that, even though the camera object is smoothly eased towards its target, the player won’t be able to outrun it, since the speed of movement is based on time, allowing the camera to move faster or slower to achieve the approximate movement duration.\n\nSo how does Smooth Damp work?\n\nHow to use Smooth Damp to smooth an object’s movement\n\nSmooth Damp is a mathematical function in Unity that eases a value, such as float, or in this case a Vector 3, towards a target smoothly, easing its movement at the beginning and end of its travel.\n\nIt works by setting the value that you want to smooth to the result of the Smooth Damp method, by passing in parameters for the current value, such as the object’s current position, the target it’s trying to reach, a local vector 3 value for the velocity of the movement, which is referenced using the ref keyword, and a smooth time value, which controls how quickly the value will change.\n\nThe ref keyword allows the function to use a local variable when it’s called, in this case a Vector 3 to store the velocity of the movement between frames.\n\nThis allows the function to ease the movement over time, despite being called on a frame-by-frame basis.\n\nWhile the Smooth Time parameter allows you to control how long the value change will take to complete, roughly, in seconds.\n\nSo, for example, passing in a value of 1 will mean that the camera will take roughly one second to move to a its new target position, assuming that the position it’s trying to reach doesn’t change before it gets there.\n\nIn practice, the amount of time that’s actually taken is typically longer than the value that’s passed in, but setting the smooth time value still allows you to control the overall speed of the smoothed movement, where a lower value, close to zero, will create a tighter camera, and a higher value, such as 1 or more seconds, will result in a much looser camera movement.\n\nThe benefit of this method is that it eases the camera towards the target smoothly, but because the function, by default, isn’t constrained by a maximum speed, the time that it takes to move to its target is appropriate for the speed of the object it’s following, meaning that you can’t outrun the camera, no matter how fast you go.\n\nWhich is why Smooth Damp is, generally, one of better methods for moving a camera towards a target object, smoothly.\n\nIf you want to write the code yourself that is.\n\nWhile setting up a simple camera can be simple to do yourself in a script, it’s possible to create a smooth following 2D camera just like this one without any code, using Cinemachine.\n\nHow to follow the player with a camera in 2D (using Cinemachine)\n\nOne of the biggest benefits of Cinemachine is that it can be used to create common camera types quickly and easily without writing any code.\n\nSo how does it work?\n\nTo use it, first, you’ll need to install Cinemachine using the Package Manager.\n\nSimply select Window > Package Manager and search for Cinemachine in the Unity Registry.\n\nOnce it’s installed, you’ll be able to use Cinemachine to create Virtual Cameras in your scene, which will work with your existing Main Camera, changing what it sees.\n\nThe idea is that each virtual camera acts as a different shot, allowing you to switch between different viewpoints easily and automatically.\n\nWhich can be great for linear media, such as videos and cutscenes, as it makes capturing a scene from multiple viewpoints easier to do.\n\nHowever, a virtual camera can also be a type of dynamic camera, such as one that follows the player for example.\n\nTo create a new virtual camera, select the Cinemachine menu item and click Create Virtual Camera.\n\nThis will create a new virtual camera in your scene and add a Cinemachine Brain component to your main camera, if there isn’t one there already.\n\nYou’ll then be able to adjust the virtual camera’s settings, to change what the main camera can see.\n\nEach camera accepts a Follow Target and a Look At Target which is the object in the scene that the camera will look at and move towards.\n\nExactly how it moves towards the follow target is defined by the camera’s Body Properties.\n\nA virtual camera’s Body properties decide how it will move in the scene in response to the object it’s following.\n\nOnce you’ve set a Follow Target, you’ll be able to set different movement options inside of the Body Properties section depending on which Body Profile you select.\n\nFor example, the Do Nothing profile, simply means that the camera will not move, while the Transposer profile moves the camera towards a target with a basic offset.\n\nThe Framing Transposer can be useful for creating a 2D side-scrolling camera that will follow the transform position of its target, typically from a fixed perspective.\n\nAdjusting the Damping settings, which is a set of sliding scale values between 0 and 20 for the X, Y and Z axes, allows you to set the duration of the camera’s movement, in a similar way to using the Smooth Time setting when using Smooth Damp, allowing you to create a smooth following camera, that works just like the manual smooth camera, relatively quickly.\n\nHowever, that’s not all that the Framing Transposer can do.\n\nIn some cases, just moving the camera towards the object may be all that you want, however there are a number of additional features that are common to 2D camera systems that can easily be recreated using Cinemachine and the Framing Transposer’s built-in settings.\n\nSuch as moving the camera as the player reaches the edge of the screen for example.\n\nHow to move a 2D camera at its edges\n\nIn some 2D games, it can be common for the camera to only move when the player gets closer to the edge of the screen meaning that, when they’re in the centre of the screen, they are able to move a limited distance, without the camera following them.\n\nIn code, this can be quite tricky to do as it typically involves defining bounds around the edges of the screen that push the camera in the player’s direction when entered.\n\nHowever, using Cinemachine, the same functionality can be pretty easy to recreate.\n\nWhen using the Framing Transposer body setting, two sets of bounds are automatically created, the Soft Zone, in which the camera will ease towards the player, and the Dead Zone, where the player is free to move without affecting the camera’s movement.\n\nOutside of the soft zone, the camera is forced to keep up with the player, essentially pushing the camera along to move with them.\n\nAlternatively, you can use an unlimited soft zone, which will always smooth the movement of the camera.\n\nYou can even adjust the height and width of each zone, so that the camera responds differently to horizontal and vertical movement.\n\nAs a result, if you want to create a 2D camera that is moved when the player approaches the edge of the screen, Cinemachine is generally the best way to do it.\n\nHowever, if you don’t want to use Cinemachine, it’s also possible to create the same camera edge-pushing effect, without it, using code.\n\nHow to create 2D camera bounds (without Cinemachine)\n\nCreating a 2D camera that moves when the player approaches the edge of the screen, but without using Cinemachine, can be quite tricky.\n\nTo do it, you’ll need to detect if the player is moving into the bounds of the screen edges and, if they are, adjust the position of the camera to follow them.\n\nA basic way to do this is to calculate the player’s position as it is on the screen, using the World to Screen Point function.\n\nThis converts a real-world position in units to a screen position in pixels.\n\nThe result can then be compared to margins that are created with the Viewport to Screen Point function, which allows you to convert a position on the viewport, expressed as a percentage, into a pixel position that can be compared to the player’s position, so that you can check if the player is close enough to a screen edge to move the camera.\n\nWhat this does is, if the player moves into the vertical or horizontal margins of the camera, which are expressed as float values, up to a maximum of 0.5 (half of the screen), the distance they moved since the last frame is added to the position of the camera target.\n\nMeaning that the player will push the target position up, down, left or right, depending on where there are on the screen.\n\nThe camera can then be smoothly moved towards the target position, using Smooth Damp, or it can be set to match its movement exactly by changing the camera’s position to match the player’s.\n\nWhile moving an object to a fixed offset position can be useful for following an object in 2D, deciding exactly where a camera should put itself around an object in 3D, can be a little harder to do.\n\nHow to make a third-person camera follow the player in 3D\n\nFollowing the player with a camera in 3D is similar to doing it in 2D, as it involves the same basic method of moving the camera towards a target position near the player.\n\nHowever, what’s different is that, because the camera is able to approach the player from all directions, you’ll need to decide exactly where around the player the target should be.\n\nOne method is to move the camera to a target point that’s within a certain distance of the player.\n\nThis works by calculating the direction between the player and camera as a unit vector, which is a directional vector with a length of one.\n\nThis represents a direction value starting from the player’s position and moving towards the camera.\n\nWhich, when multiplied by a distance value, pinpoints a target position in the world that’s a set distance from the player, but in whichever direction the camera happens to be.\n\nThis position can be used as the camera’s target, meaning that all you need to do is move the camera object towards the target position, using the same Smooth Damp function as when working in 2D.\n\nThis will smoothly move the camera to the nearest position that’s 3 units away from the player, while the Look At function will rotate the camera to face the player as it moves around it.\n\nThis method of moving a camera to a position somewhere around the player is extremely common in 3D platform games, where the player is able to move independently from the camera while it follows them around.\n\nHowever, using this method can get tricky when you also want to allow the player to rotate the camera around themselves manually, using the right thumbstick, or the mouse, for example.\n\nWhy can it be tricky?\n\nActually building the mechanism that rotates the camera around the player object isn’t necessarily difficult to do.\n\nFor example, it’s possible to use the Rotate Around function to move the camera around the object on a horizontal and vertical axis.\n• How to rotate the camera around a player object\n\nWhat can be tricky is switching between the two systems when the camera may have repositioned itself while moving.\n\nFor example, if you rotate the camera around the player object yourself, and then move to a new position that causes the camera to rotate around the object further, unless you keep track of the difference in rotation, the original manual rotation settings will still apply, causing any new change to pick up from a different point to the camera’s current location.\n\nAnd while it’s not an impossible problem to solve, blending different mechanics together like this, particularly when they’re based on very common camera features, can be much easier to do using Cinemachine instead.\n\nHow to rotate the camera around an object (using Cinemachine)\n\nCinemachine provides a number of ready-made camera options that can create a natural following camera that can also be rotated.\n\nSo how does it work?\n\nTo create a camera that simply follows the player around, using Cinemachine, select the Transposer body option with the Simple Follow binding mode.\n\nThis will create a simple following camera that moves towards the player, or any other target, with an optional offset and damping.\n\nThe result is similar to manually creating a camera that moves to a position near to the object it’s targeting, but not rigidly, meaning that the camera’s position around the object may change, depending on where it goes.\n\nHowever, this configuration doesn’t allow the player to rotate the camera around the object themselves.\n\nThe Orbital Transposer profile, combined with the same Simple Follow binding mode, creates a camera that can be rotated around the player horizontally, on the X-Axis.\n\nIt will still follow the player naturally, adjusting its position as they move around the world, but can also be rotated manually, picking up where the automatic camera left off.\n\nThe X-Axis settings allow you to change how fast the camera can orbit around its target, which input axis will be used to move it and whether or not the movement should be inverted.\n\nHowever, if you want to provide full orbital camera movement around an object, on both horizontal and vertical axes, you’ll need to use a different type of virtual camera to do it.\n\nThe Free Look Cinemachine camera can be used to provide XY control over a camera object.\n\nWhich, combined with the Simple Follow binding mode, creates a camera that automatically follows the player around, but that can also be moved manually, this time around the X and Y axes.\n\nThe Free Look camera settings provide controls to adjust the speed of both the X and Y axis inputs, as well as vertical recentering, allowing the camera to smoothly move back to a default position when the player isn’t manually controlling it.\n\nWhile the Orbits section allows you specify exactly where the camera will position itself when orbiting around the target object.\n\nIt does this by blending between three orbits, the Top Rig, Middle Rig and Bottom Rig.\n\nEssentially, each rig is an individual Orbital Transposer, with its own height and radius.\n\nAdjusting the size and position of these three orbits allows you to create a custom shape that the camera can follow to move around the player.\n\nHowever, while you might normally create a sphere, the orbits also allow you to create less traditional shapes instead.\n\nSuch as a wide bottom ring, which can be used to move the camera out and away from the player when the camera gets too low,\n\nThe Free Look camera allows the player to move the camera themselves when they want to, leaving it to loosely follow them around when they don’t.\n\nBut, what if you don’t want a loose camera?\n\nWhat if you want a 3D camera that follows more tightly, behind the player, for example?\n\nHow to follow behind the player with a camera\n\nMaking a camera follow behind the player typically involves setting a target that’s offset from the object’s local forward direction.\n\nSpecifically, the opposite of their forward direction, negative forward, multiplied by a distance value and offset by the camera’s height.\n\nThis will cause the camera to move to a position just behind the player, while still looking at them, which can be useful for creating a basic third-person camera that follows a player from a fixed rear position.\n\nHowever, there’s a problem with this method.\n\nCameras that are designed to follow behind a player, generally, act differently from a camera that simply follows the player’s position while looking at them.\n\nFor example, some third-person cameras, while following behind the player, look forward, aiming at a target point beyond their position, instead of directly at them, and sometimes at an offset to their horizontal position, such as over one of their shoulders.\n\nWhile there are many different ways you could do this, one method of creating this behaviour in code involves adding the vertical height and horizontal shoulder offsets to the position target and the look target and easing them with the same smooth time value.\n\nUsing the same offset for the camera’s movement and rotation target means that it looks straight ahead, past the player, from an offset position, instead of directly at the player, while still following just behind them."
    },
    {
        "link": "https://discussions.unity.com/t/make-camera-follow-different-gameobjects/787218",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/making-camera-follow-an-object/400211",
        "document": ""
    }
]