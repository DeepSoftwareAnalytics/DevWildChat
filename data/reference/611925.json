[
    {
        "link": "https://geeksforgeeks.org/connectivity-in-a-directed-graph",
        "document": "Given a directed graph, find out whether the graph is strongly connected or not. A directed graph is strongly connected if there is a path between any two pair of vertices. For example, following is a strongly connected graph.\n\n\n\nIt is easy for undirected graph, we can just do a BFS and DFS starting from any vertex. If BFS or DFS visits all vertices, then the given undirected graph is connected. This approach won’t work for a directed graph. For example, consider the following graph which is not strongly connected. If we start DFS (or BFS) from vertex 0, we can reach all vertices, but if we start from any other vertex, we cannot reach all vertices.\n\n\n\nHow to do for directed graph?\n\nA simple idea is to use a all pair shortest path algorithm like Floyd Warshall or find Transitive Closure of graph. Time complexity of this method would be O(v3).\n\nWe can also do DFS V times starting from every vertex. If any DFS, doesn’t visit all vertices, then graph is not strongly connected. This algorithm takes O(V*(V+E)) time which can be same as transitive closure for a dense graph.\n\nA better idea can be Strongly Connected Components (SCC) algorithm. We can find all SCCs in O(V+E) time. If number of SCCs is one, then graph is strongly connected. The algorithm for SCC does extra work as it finds all SCCs.\n\nThe idea is, if every node can be reached from a vertex v, and every node can reach v, then the graph is strongly connected. In step 2, we check if all vertices are reachable from v. In step 4, we check if all vertices can reach v (In reversed graph, if all vertices are reachable from v, then all vertices can reach v in original graph). \n\nFollowing is the implementation of above algorithm.\n\nImplementation:\n\nTime Complexity: Time complexity of above implementation is same as Depth First Search which is O(V+E) if the graph is represented using adjacency list representation.\n\nCan we improve further? \n\nThe above approach requires two traversals of graph. We can find whether a graph is strongly connected or not in one traversal using Tarjan’s Algorithm to find Strongly Connected Components.\n\nExercise: \n\nCan we use BFS instead of DFS in above algorithm? See this."
    },
    {
        "link": "https://geeksforgeeks.org/check-given-directed-graph-strongly-connected-set-2-kosaraju-using-bfs",
        "document": "Check if a given directed graph is strongly connected | Set 2 (Kosaraju using BFS)\n\nGiven a directed graph, find out whether the graph is strongly connected or not. A directed graph is strongly connected if there is a path between any two pairs of vertices. There are different methods to check the connectivity of directed graph but one of the optimized method is Kosaraju’s DFS based simple algorithm.\n\nKosaraju’s BFS based simple algorithm also work on the same principle as DFS based algorithm does.\n\nThe idea is again simple if every node can be reached from a vertex v, and every node can reach same vertex v, then the graph is strongly connected. In step 2, we check if all vertices are reachable from v. In step 5, we check if all vertices can reach v (In reversed graph, if all vertices are reachable from v, then all vertices can reach v in original graph).\n\nExample 1 : \n\nGiven a directed to check if it is strongly connected or not.\n• step 2: After reversing the given graph we got listed graph.\n• step 3: Again after starting with vertex 2 the BFS is 2 1 4 0 3\n• step 4: No vertex in both case (step 1 & step 3) remains unvisited.\n• step 5: So, given graph is strongly connected.\n\nGiven a directed to check if it is strongly connected or not.\n• step 2: After reversing the given graph we got listed graph.\n• step 3: Again after starting with vertex 2 the BFS is 2 1 0\n• step 4: vertex 0, 1 in original graph and 3, 4 in reverse graph remains unvisited.\n• step 5: So, given graph is not strongly connected.\n\nFollowing is the implementation of above algorithm.\n\nTime Complexity: Time complexity of above implementation is same as Breadth First Search which is O(V+E) if the graph is represented using adjacency matrix representation.\n\nCan we improve further? \n\nThe above approach requires two traversals of graph. We can find whether a graph is strongly connected or not in one traversal using Tarjan’s Algorithm to find Strongly Connected Components."
    },
    {
        "link": "https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.is_strongly_connected.html",
        "document": "A directed graph is strongly connected if and only if every vertex in the graph is reachable from every other vertex."
    },
    {
        "link": "https://stackoverflow.com/questions/546655/finding-all-cycles-in-a-directed-graph",
        "document": "For example, I want something like this:\n\nHow can I find (iterate over) ALL the cycles in a directed graph from/to a given node?\n\nI found this page in my search and since cycles are not same as strongly connected components, I kept on searching and finally, I found an efficient algorithm which lists all (elementary) cycles of a directed graph. It is from Donald B. Johnson and the paper can be found in the following link: A java implementation can be found in: A Mathematica demonstration of Johnson's algorithm can be found here, implementation can be downloaded from the right (\"Download author code\"). Note: Actually, there are many algorithms for this problem. Some of them are listed in this article: According to the article, Johnson's algorithm is the fastest one.\n\nDepth first search with backtracking should work here. Keep an array of boolean values to keep track of whether you visited a node before. If you run out of new nodes to go to (without hitting a node you have already been), then just backtrack and try a different branch. The DFS is easy to implement if you have an adjacency list to represent the graph. For example adj[A] = {B,C} indicates that B and C are the children of A. For example, pseudo-code below. \"start\" is the node you start from. dfs(adj,node,visited): if (visited[node]): if (node == start): \"found a path\" return; visited[node]=YES; for child in adj[node]: dfs(adj,child,visited) visited[node]=NO; Call the above function with the start node:\n\nFirst of all - you do not really want to try find literally all cycles because if there is 1 then there is an infinite number of those. For example A-B-A, A-B-A-B-A etc. Or it may be possible to join together 2 cycles into an 8-like cycle etc., etc... The meaningful approach is to look for all so called simple cycles - those that do not cross themselves except in the start/end point. Then if you wish you can generate combinations of simple cycles. One of the baseline algorithms for finding all simple cycles in a directed graph is this: Do a depth-first traversal of all simple paths (those that do not cross themselves) in the graph. Every time when the current node has a successor on the stack a simple cycle is discovered. It consists of the elements on the stack starting with the identified successor and ending with the top of the stack. Depth first traversal of all simple paths is similar to depth first search but you do not mark/record visited nodes other than those currently on the stack as stop points. The brute force algorithm above is terribly inefficient and in addition to that generates multiple copies of the cycles. It is however the starting point of multiple practical algorithms which apply various enhancements in order to improve performance and avoid cycle duplication. I was surprised to find out some time ago that these algorithms are not readily available in textbooks and on the web. So I did some research and implemented 4 such algorithms and 1 algorithm for cycles in undirected graphs in an open source Java library here : http://code.google.com/p/niographs/ . BTW, since I mentioned undirected graphs : The algorithm for those is different. Build a spanning tree and then every edge which is not part of the tree forms a simple cycle together with some edges in the tree. The cycles found this way form a so called cycle base. All simple cycles can then be found by combining 2 or more distinct base cycles. For more details see e.g. this : http://dspace.mit.edu/bitstream/handle/1721.1/68106/FTL_R_1982_07.pdf .\n\nThe DFS-based variants with back edges will find cycles indeed, but in many cases it will NOT be minimal cycles. In general DFS gives you the flag that there is a cycle but it is not good enough to actually find cycles. For example, imagine 5 different cycles sharing two edges. There is no simple way to identify cycles using just DFS (including backtracking variants). Johnson's algorithm is indeed gives all unique simple cycles and has good time and space complexity. But if you want to just find MINIMAL cycles (meaning that there may be more then one cycle going through any vertex and we are interested in finding minimal ones) AND your graph is not very large, you can try to use the simple method below. It is VERY simple but rather slow compared to Johnson's. So, one of the absolutely easiest way to find MINIMAL cycles is to use Floyd's algorithm to find minimal paths between all the vertices using adjacency matrix. This algorithm is nowhere near as optimal as Johnson's, but it is so simple and its inner loop is so tight that for smaller graphs (<=50-100 nodes) it absolutely makes sense to use it. Time complexity is O(n^3), space complexity O(n^2) if you use parent tracking and O(1) if you don't. First of all let's find the answer to the question if there is a cycle. The algorithm is dead-simple. Below is snippet in Scala. Originally this algorithm operates on weighted-edge graph to find all shortest paths between all pairs of nodes (hence the weights argument). For it to work correctly you need to provide 1 if there is a directed edge between the nodes or NO_EDGE otherwise. After algorithm executes, you can check the main diagonal, if there are values less then NO_EDGE than this node participates in a cycle of length equal to the value. Every other node of the same cycle will have the same value (on the main diagonal). To reconstruct the cycle itself we need to use slightly modified version of algorithm with parent tracking. Parents matrix initially should contain source vertex index in an edge cell if there is an edge between the vertices and -1 otherwise. After function returns, for each edge you will have reference to the parent node in the shortest path tree. And then it's easy to recover actual cycles. All in all we have the following program to find all minimal cycles val NO_EDGE = Integer.MAX_VALUE / 2; def shortestPathWithParentTracking( weights: Array[Array[Int]], parents: Array[Array[Int]]) = { for (k <- weights.indices; i <- weights.indices; j <- weights.indices) { val throughK = weights(i)(k) + weights(k)(j) if (throughK < weights(i)(j)) { parents(i)(j) = parents(i)(k) weights(i)(j) = throughK } } } def recoverCycles( cycleNodes: Seq[Int], parents: Array[Array[Int]]): Set[Seq[Int]] = { val res = new mutable.HashSet[Seq[Int]]() for (node <- cycleNodes) { var cycle = new mutable.ArrayBuffer[Int]() cycle += node var other = parents(node)(node) do { cycle += other other = parents(other)(node) } while(other != node) res += cycle.sorted } res.toSet } and a small main method just to test the result\n\nI was given this as an interview question once, I suspect this has happened to you and you are coming here for help. Break the problem into three questions and it becomes easier.\n• how do you determine the next valid route\n• how do you determine if a point has been used\n• how do you avoid crossing over the same point again Problem 1) Use the iterator pattern to provide a way of iterating route results. A good place to put the logic to get the next route is probably the \"moveNext\" of your iterator. To find a valid route, it depends on your data structure. For me it was a sql table full of valid route possibilities so I had to build a query to get the valid destinations given a source. Problem 2) Push each node as you find them into a collection as you get them, this means that you can see if you are \"doubling back\" over a point very easily by interrogating the collection you are building on the fly. Problem 3) If at any point you see you are doubling back, you can pop things off the collection and \"back up\". Then from that point try to \"move forward\" again. Hack: if you are using Sql Server 2008 there is are some new \"hierarchy\" things you can use to quickly solve this if you structure your data in a tree.\n\nIf what you want is to find all elementary circuits in a graph you can use the EC algorithm, by JAMES C. TIERNAN, found on a paper since 1970. The very original EC algorithm as I managed to implement it in php (hope there are no mistakes is shown below). It can find loops too if there are any. The circuits in this implementation (that tries to clone the original) are the non zero elements. Zero here stands for non-existence (null as we know it). Apart from that below follows an other implementation that gives the algorithm more independece, this means the nodes can start from anywhere even from negative numbers, e.g -4,-3,-2,.. etc. In both cases it is required that the nodes are sequential. You might need to study the original paper, James C. Tiernan Elementary Circuit Algorithm <?php echo \"<pre><br><br>\"; $G = array( 1=>array(1,2,3), 2=>array(1,2,3), 3=>array(1,2,3) ); define('N',key(array_slice($G, -1, 1, true))); $P = array(1=>0,2=>0,3=>0,4=>0,5=>0); $H = array(1=>$P, 2=>$P, 3=>$P, 4=>$P, 5=>$P ); $k = 1; $P[$k] = key($G); $Circ = array(); #[Path Extension] EC2_Path_Extension: foreach($G[$P[$k]] as $j => $child ){ if( $child>$P[1] and in_array($child, $P)===false and in_array($child, $H[$P[$k]])===false ){ $k++; $P[$k] = $child; goto EC2_Path_Extension; } } #[EC3 Circuit Confirmation] if( in_array($P[1], $G[$P[$k]])===true ){//if PATH[1] is not child of PATH[current] then don't have a cycle $Circ[] = $P; } #[EC4 Vertex Closure] if($k===1){ goto EC5_Advance_Initial_Vertex; } //afou den ksana theoreitai einai asfales na svisoume for( $m=1; $m<=N; $m++){//H[P[k], m] <- O, m = 1, 2, . . . , N if( $H[$P[$k-1]][$m]===0 ){ $H[$P[$k-1]][$m]=$P[$k]; break(1); } } for( $m=1; $m<=N; $m++ ){//H[P[k], m] <- O, m = 1, 2, . . . , N $H[$P[$k]][$m]=0; } $P[$k]=0; $k--; goto EC2_Path_Extension; #[EC5 Advance Initial Vertex] EC5_Advance_Initial_Vertex: if($P[1] === N){ goto EC6_Terminate; } $P[1]++; $k=1; $H=array( 1=>array(1=>0,2=>0,3=>0,4=>0,5=>0), 2=>array(1=>0,2=>0,3=>0,4=>0,5=>0), 3=>array(1=>0,2=>0,3=>0,4=>0,5=>0), 4=>array(1=>0,2=>0,3=>0,4=>0,5=>0), 5=>array(1=>0,2=>0,3=>0,4=>0,5=>0) ); goto EC2_Path_Extension; #[EC5 Advance Initial Vertex] EC6_Terminate: print_r($Circ); ?> then this is the other implementation, more independent of the graph, without goto and without array values, instead it uses array keys, the path, the graph and circuits are stored as array keys (use array values if you like, just change the required lines). The example graph start from -4 to show its independence. <?php $G = array( -4=>array(-4=>true,-3=>true,-2=>true), -3=>array(-4=>true,-3=>true,-2=>true), -2=>array(-4=>true,-3=>true,-2=>true) ); $C = array(); EC($G,$C); echo \"<pre>\"; print_r($C); function EC($G, &$C){ $CNST_not_closed = false; // this flag indicates no closure $CNST_closed = true; // this flag indicates closure // define the state where there is no closures for some node $tmp_first_node = key($G); // first node = first key $tmp_last_node = $tmp_first_node-1+count($G); // last node = last key $CNST_closure_reset = array(); for($k=$tmp_first_node; $k<=$tmp_last_node; $k++){ $CNST_closure_reset[$k] = $CNST_not_closed; } // define the state where there is no closure for all nodes for($k=$tmp_first_node; $k<=$tmp_last_node; $k++){ $H[$k] = $CNST_closure_reset; // Key in the closure arrays represent nodes } unset($tmp_first_node); unset($tmp_last_node); # Start algorithm foreach($G as $init_node => $children){#[Jump to initial node set] #[Initial Node Set] $P = array(); // declare at starup, remove the old $init_node from path on loop $P[$init_node]=true; // the first key in P is always the new initial node $k=$init_node; // update the current node // On loop H[old_init_node] is not cleared cause is never checked again do{#Path 1,3,7,4 jump here to extend father 7 do{#Path from 1,3,8,5 became 2,4,8,5,6 jump here to extend child 6 $new_expansion = false; foreach( $G[$k] as $child => $foo ){#Consider each child of 7 or 6 if( $child>$init_node and isset($P[$child])===false and $H[$k][$child]===$CNST_not_closed ){ $P[$child]=true; // add this child to the path $k = $child; // update the current node $new_expansion=true;// set the flag for expanding the child of k break(1); // we are done, one child at a time } } }while(($new_expansion===true));// Do while a new child has been added to the path # If the first node is child of the last we have a circuit if( isset($G[$k][$init_node])===true ){ $C[] = $P; // Leaving this out of closure will catch loops to } # Closure if($k>$init_node){ //if k>init_node then alwaya count(P)>1, so proceed to closure $new_expansion=true; // $new_expansion is never true, set true to expand father of k unset($P[$k]); // remove k from path end($P); $k_father = key($P); // get father of k $H[$k_father][$k]=$CNST_closed; // mark k as closed $H[$k] = $CNST_closure_reset; // reset k closure $k = $k_father; // update k } } while($new_expansion===true);//if we don't wnter the if block m has the old k$k_father_old = $k; // Advance Initial Vertex Context }//foreach initial }//function ?> I have analized and documented the EC but unfortunately the documentation is in Greek."
    },
    {
        "link": "https://igraph.org/python/doc/api/igraph.Graph.html",
        "document": "the adjacency matrix. Possible types are:\n• a numpy 2D array or matrix (will be converted to list of lists)\n• a scipy.sparse matrix (will be converted to a COO matrix, but not to a dense matrix) the mode to be used. Possible values are:\n• - the graph will be directed and a matrix element gives the number of edges between two vertex.\n• - undirected graph will be created and the number of edges between vertex and is\n• - like , but with\n• - like , but with\n• - undirected graph with the upper right triangle of the matrix (including the diagonal)\n• - undirected graph with the lower left triangle of the matrix (including the diagonal) Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a attribute afterwards. the vertex types as a boolean list. Anything that evaluates to will denote a vertex of the first kind, anything that evaluates to will denote a vertex of the second kind. the edges as a list of tuples. whether to create a directed graph. Bipartite networks are usually undirected, so the default is the graph with a binary vertex attribute named that stores the vertex classes. Generates a graph from one or two dataframes. pandas DataFrame containing edges and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex *names* rather than IDs unless is True and these are non-negative integers. Further columns may contain edge attributes. bool setting whether the graph is directed None (default) or pandas DataFrame containing vertex metadata. The first column of the DataFrame must contain the unique vertex *names*. If is True, the DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to . All other columns will be added as vertex attributes by column name. whether to interpret the first two columns of the argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of are not integers, an error is thrown. Vertex names in either the or arguments that are set to NaN (not a number) will be set to the string \"NA\". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate. This representation assumes that vertices and edges are encoded in two lists, each list containing a Python dict for each vertex and each edge, respectively. A distinguished element of the vertex dicts contain a vertex ID which is used in the edge dicts to refer to source and target vertices. All the remaining elements of the dict are considered vertex and edge attributes. Note that the implementation does not assume that the objects passed to this method are indeed lists of dicts, but they should be iterable and they should yield objects that behave as dicts. So, for instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration. the data source for the vertices or if there are no special attributes assigned to vertices and we should simply use the edge list of dicts to infer vertex names. the data source for the edges. whether the constructed graph will be directed the name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if is . the name of the attributes in the dicts in the edge data source that contain the source and target vertex names. whether to add the edges to the graph one by one, iteratively, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list. the graph that was constructed Vertex names will be converted to \"_nx_name\" attribute and the vertices will get new ids from 0 up (as standard in igraph). Generates a full bipartite graph (directed or undirected, with or without loops). the number of vertices of the first kind. the number of vertices of the second kind. if , then all vertices of the first kind are connected to the others; specifies the opposite direction, creates mutual edges. Ignored for undirected graphs. the graph with a binary vertex attribute named that stores the vertex classes. The algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes and . The number of vertices in the graph This should be if we want to use a torus instead of a square. defines the direction of edges in the graph. If , then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If , the opposite direction is used. creates mutual edges. Ignored for undirected graphs. defines what to do with non-zero entries in the matrix. If , non-zero entries will create an edge no matter what the value is. If , non-zero entries are rounded up to the nearest integer and this will be the number of multiple edges created. defines whether to create a weighted graph from the incidence matrix. If it is c{None} then an unweighted graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the weighted argument. If it is then a weighted graph is created and the name of the edge attribute will be ‘weight’. the graph with a binary vertex attribute named that stores the vertex classes. if the weighted and multiple are passed together. Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given). If m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p. the number of vertices of type 1. the number of vertices of type 2. the probability of edges. If given, must be missing. the number of edges. If given, must be missing. if the graph is directed, specifies how the edges will be generated. If it is , edges will be generated in both directions (from type 1 to type 2 and vice versa) independently. If it is edges will always point from type 1 to type 2. If it is , edges will always point from type 2 to type 1. This argument is ignored for undirected graphs. This method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method. The remaining arguments are passed to the reader method without any changes. the file containing the graph to be loaded the format of the file (if known in advance). means auto-detection. Possible values are: (NCOL format), (LGL format), (GraphDB format), , (GraphML and gzipped GraphML format), (GML format), , (Pajek format), (DIMACS format), , or (edge list), (adjacency matrix), (DL format used by UCINET), (Python pickled format), (gzipped Python pickled format) if the file format can't be identified and none was given. Constructs a graph based on an adjacency matrix from the given file. Additional positional and keyword arguments not mentioned here are passed intact to . the name of the file to be read or a file object the string that separates the matrix elements in a row. means an arbitrary sequence of whitespace characters. lines starting with this string are treated as comments. an edge attribute name where the edge weights are stored in the case of a weighted adjacency matrix. If , no weights are stored, values larger than 1 are considered as edge multiplicities. Reads a graph from a file conforming to the DIMACS minimum-cost flow file format. For the exact definition of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm. Restrictions compared to the official description of the format are as follows:\n• igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.\n• Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.\n• Node indices start from 1. Only a single source and target node is allowed. the name of the file or a Python file handle whether the generated graph should be directed. the generated graph. The indices of the source and target vertices are attached as graph attributes and , the edge capacities are stored in the edge attribute. the name of the file if the GraphML file contains multiple graphs, specified the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here. the name of the file, a stream to read from, or a string containing the pickled data. the name of the file or a stream to read from. This representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the list. The names of the vertices will be stored in the vertex attribute given by . The default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting to or . If you have even more edge attributes, add them to the end of each item in the list and also specify the corresponding edge attribute names in as a list. the data source for the edges. This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the vertex attribute (or another vertex attribute if is specified), even if all the vertex names in the list are in fact numbers. whether the constructed graph will be directed the name of the vertex attribute that will contain the vertex names. the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). means that only the source and target vertices will be extracted from each item. If you pass a string here, it will be wrapped in a list for convenience. alternative way to specify that the graph is weighted. If you set to and is not given, it will be assumed that is and igraph will parse the third element from each item into an edge weight. If you set to a string, it will be assumed that contains that string only, and igraph will store the edge weights in that attribute. the graph that was constructed the adjacency matrix. Possible types are:\n• a numpy 2D array or matrix (will be converted to list of lists)\n• a scipy.sparse matrix (will be converted to a COO matrix, but not to a dense matrix) the mode to be used. Possible values are:\n• - the graph will be directed and a matrix element gives the number of edges between two vertex.\n• - undirected graph will be created and the number of edges between vertex and is\n• - like , but with\n• - like , but with\n• - undirected graph with the upper right triangle of the matrix (including the diagonal)\n• - undirected graph with the lower left triangle of the matrix (including the diagonal) These values can also be given as strings without the prefix. the name of the edge attribute that stores the edge weights. whether to include loop edges. When , the diagonal of the adjacency matrix will be ignored. Copies the graph and extends the copy depending on the type of the other object given. if it is an integer, the copy is extended by the given number of vertices. If it is a string, the copy is extended by a single vertex whose attribute will be equal to the given string. If it is a tuple with two elements, the copy is extended by a single edge. If it is a list of tuples, the copy is extended by multiple edges. If it is a , a disjoint union is performed. the other graph to take the intersection with. Returns True if the graph has at least one vertex, False otherwise. This method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on. the number of vertices. Can be omitted, the default is zero. Note that if the edge list contains vertices with indexes larger than or equal to , then the number of vertices will be adjusted accordingly. the edge list where every list item is a pair of integers. If any of the integers is larger than , the number of vertices is adjusted accordingly. means no edges. whether the graph should be directed the attributes of the graph as a dictionary. the attributes of the vertices as a dictionary. Every dictionary value must be an iterable with exactly items. the attributes of the edges as a dictionary. Every dictionary value must be an iterable with exactly items where is the number of edges. Copies exact replicas of the original graph an arbitrary number of times. if it is an integer, multiplies the graph by creating the given number of identical copies and taking the disjoint union of them. the other graph to take the union with. Plots the graph to the given Cairo context in the given bounding box The visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):\n• Keyword arguments of this function (or of which is passed intact to .\n• Vertex or edge attributes, specified later in the list of keyword arguments. E.g., if the keyword attribute is not present, but there exists a vertex attribute named , the sizes of the vertices will be specified by that attribute. Besides the usual self-explanatory plotting parameters ( , , ), it accepts the following keyword arguments:\n• None : whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be or ; when omitted, is assumed for graphs with less than 10.000 edges and otherwise.\n• None : a subclass of which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of ). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.\n• None : whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is .\n• None : the layout to be used. If not an instance of , it will be passed to to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like ) or calculate the layout in advance and pass a object here.\n• None : the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.\n• None : whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:\n• : no groups will be highlighted\n• : only valid if the object plotted is a or . The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.\n• A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.\n• A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.\n• A or instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. In place of lists of vertex indices, you may also use instances. In place of color names, you may also use color indices into the current palette. as a color name will mean that the corresponding group is ignored.\n• None : size of the vertices. The corresponding vertex attribute is called . The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.\n• None : color of the vertices. The corresponding vertex attribute is , the default is red. Colors can be specified either by common X11 color names (see the source code of for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications ( ) or by integer color indices of the specified palette.\n• None : color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is , the default is black. See for the possible ways of specifying a color.\n• None : the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is . The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.\n• None : shape of the vertices. Alternatively it can be specified by the vertex attribute. Possibilities are: , {circle}, {triangle}, {triangle-down} or . See the source code of for a list of alternative shape names that are also accepted and mapped to these.\n• None : labels drawn next to the vertices. The corresponding vertex attribute is .\n• None : distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is .\n• None : color of the label. Corresponding vertex attribute: . See for color specification syntax.\n• None : font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: .\n• None : the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with . Corresponding vertex attribute: . The default is .\n• None : drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.\n• None : an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed ( , , and are accepted values).\n• None : color of the edges. The corresponding edge attribute is , the default is red. See for color specification syntax.\n• None : whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. is interpreted as 0.5, is interpreted as 0. The default is 0 which makes all the edges straight.\n• None : width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is , the default is 1.\n• None : arrow size of the edges. The corresponding edge attribute is , the default is 1.\n• None : width of the arrowhead on the edge. The corresponding edge attribute is , the default is 1.\n• None : drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.\n• None : an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed ( , , and are accepted values). Behind the scenes, this method constructs a instance and invokes its method with a verbosity of 1 and attribute printing turned off. See the documentation of for more details about the output. Removes the given object(s) from the graph if it is an integer, removes the vertex with the given ID from the graph (note that the remaining vertices will get re-indexed!). If it is a tuple, removes the given edge. If it is a graph, takes the difference of the two graphs. Accepts lists of integers or lists of tuples as well, but they can't be mixed! Also accepts and objects. Keyword arguments (except the source and target arguments) will be assigned to the edge as attributes. The performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single call is more efficient than multiple calls. the source vertex of the edge or its name. the target vertex of the edge or its name. the newly added edge as an object. Use if you don't need the object and want to avoid the overhead of creating it. Adds some edges to the graph. the list of edges to be added. Every edge is represented with a tuple containing the vertex IDs or names of the two endpoints. Vertices are enumerated from zero. dict of sequences, all of length equal to the number of edges to be added, containing the attributes of the new edges. Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that as a keyword argument is treated specially; if a graph has as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID. the newly added vertex as a object. Use if you don't need the object and want to avoid the overhead of creating t. Adds some vertices to the graph. Note that if is a sequence of strings, indicating the names of the new vertices, and attributes has a key , the two conflict. In that case the attribute will be applied. the number of vertices to be added, or the name of a single vertex to be added, or a sequence of strings, each corresponding to the name of a vertex to be added. Names will be assigned to the vertex attribute. dict of sequences, all of length equal to the number of vertices to be added, containing the attributes of the new vertices. If n is a string (so a single vertex is added), then the values of this dict are the attributes themselves, but if n=1 then they have to be lists of length 1. Returns all the cuts between the source and target vertices in a directed graph. This function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once. JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351--372, 1996. Returns all the mincuts between the source and target vertices in a directed graph. This function lists all minimum edge-cuts between a source and a target vertex. the edge capacities (weights). If , all edges have equal weight. May also be an attribute name. JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351--372, 1996. Returns a directed copy of this graph. Arguments are passed on to that is invoked on the copy. Returns an undirected copy of this graph. Arguments are passed on to that is invoked on the copy. Calculates the biconnected components of the graph. whether to return the articulation points as well a object describing the biconnected components, and optionally the list of articulation points as well Projects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting. an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to corresponds to vertices of the first kind, everything else to the second kind. if , then igraph keeps the multiplicity of the edges in the projection in an edge attribute called . E.g., if there is an A-C-B and an A-D-B triplet in the bipartite graph and there is no other X (apart from X=B and X=D) for which an A-X-B triplet would exist in the bipartite graph, the multiplicity of the A-B edge in the projection will be 2. this argument can be used to specify the order of the projections in the resulting list. If given and non-negative, then it is considered as a vertex ID; the projection containing the vertex will be the first one in the result. this argument can be used to specify which of the two projections should be returned if only one of them is needed. Passing 0 here means that only the first projection is returned, while 1 means that only the second projection is returned. (Note that we use 0 and 1 because Python indexing is zero-based). is equivalent to 0 and is equivalent to 1. Any other value means that both projections will be returned in a tuple. a tuple containing the two projected one-mode graphs if is not 1 or 2, or the projected one-mode graph specified by the argument if its value is 0, 1, or . Calculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves. an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to corresponds to vertices of the first kind, everything else to the second kind. a 4-tuple containing the number of vertices and edges in the first projection, followed by the number of vertices and edges in the second projection. Clears the graph, deleting all vertices, edges, and attributes. Calculates the (strong or weak) clusters (connected components) for a given graph. must be either or , depending on the clusters being sought. Optional, defaults to . Calculates the cohesive block structure of the graph. Cohesive blocking is a method of determining hierarchical subsets of graph vertices based on their structural cohesion (i.e. vertex connectivity). For a given graph G, a subset of its vertices S is said to be maximally k-cohesive if there is no superset of S with vertex connectivity greater than or equal to k. Cohesive blocking is a process through which, given a k-cohesive set of vertices, maximally l-cohesive subsets are recursively identified with l > k. Thus a hierarchy of vertex subsets is obtained in the end, with the entire graph G at its root. an instance of . See the documentation of for more information. Community structure based on the betweenness of the edges in the network. The idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram. the number of clusters we would like to see. This practically defines the \"level\" where we \"cut\" the dendrogram to get the membership vector of the vertices. If , the dendrogram is cut at the level which maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal). whether the directionality of the edges should be taken into account or not. name of an edge attribute or a list containing edge weights. a object, initally cut at the maximum modularity or at the desired number of clusters. Community structure based on the greedy optimization of modularity. This algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved. This algorithm is said to run almost in linear time on sparse graphs. edge attribute name or a list containing edge weights A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004). Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom. name of an edge attribute or a list containing edge weights. name of an vertex attribute or a list containing vertex weights. the number of attempts to partition the network. an appropriate object with an extra attribute called that stores the code length determined by the algorithm. M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). http://dx.doi.org/10.1073/pnas.0706851105, http://arxiv.org/abs/0707.0609. M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur. Phys. J. Special Topics 178, 13 (2009). http://dx.doi.org/10.1140/epjst/e2010-01179-1, http://arxiv.org/abs/0906.1405. Finds the community structure of the graph according to the label propagation method of Raghavan et al. Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus. Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure. Also note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end. name of an edge attribute or a list containing edge weights name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to where is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices. a list of booleans for each vertex. corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean. Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938. This is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network. the desired number of communities. If , the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one. name of an edge attribute or a list containing edge weights. an object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called is used. MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087 This function splits the network into two components according to the leading eigenvector of the modularity matrix and then recursively takes the given number of steps by splitting the communities as individual networks. This is not the correct way, however, see the reference for explanation. Consider using the correct method instead. the desired number of communities. If , the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one. whether the returned object should be a dendrogram instead of a single clustering. an appropriate or object. MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087 Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman. whether to use the Constant Potts Model (CPM) or modularity. Must be either or . edge weights to be used. Can be a sequence or iterable or even an edge attribute name. the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities. parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm. if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition. the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration). the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing. Community structure based on the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the adjacent edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices. This algorithm is said to run almost in linear time on sparse graphs. edge attribute name or a list containing edge weights if , the communities at each level are returned in a list. If , only the community structure with the best modularity is returned. a list of objects, one corresponding to each level (if is ), or a corresponding to the best modularity. VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476 Calculates the optimal modularity score of the graph and the corresponding community structure. This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph. the calculated membership vector and the corresponding modularity in a tuple. Finds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt. edge weights to be used. Can be a sequence or iterable or even an edge attribute name. integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated. whether to update the spins of the vertices in parallel (synchronously) or not specifies the null model of the simulation. Possible values are (a random graph with the same vertex degrees as the input graph) or (a random graph with the same number of edges) the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them. currently igraph contains two implementations of the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting to the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python. Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). http://arxiv.org/abs/0811.2329. The basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram. name of an edge attribute or a list containing edge weights Returns the number of automorphisms of the graph. This function simply calls with the graph itself. See for an explanation of the parameters. the number of automorphisms of the graph Calculates the degree distribution of the graph. the bin width of the histogram a histogram representing the degree distribution of the graph. Deletes some edges from the graph. The set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise the first positional argument is considered as follows:\n• a single integer - deletes the edge with the given ID\n• a list of integers - deletes the edges denoted by the given IDs\n• a list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed. has been replaced by - with no arguments - since igraph 0.8.3. Conducts a depth first search (DFS) on the graph. either or or , ignored for undirected graphs. a tuple with the following items:\n• The parent of every vertex in the DFS Creates the disjoint union of two (or more) graphs. graph or list of graphs to be united with the current one. Calculates the dyad census of the graph. Dyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from a to b and also from b to a), asymmetric (there is an edge from a to b or from b to a but not the other way round) and null (there is no connection between a and b). Holland, P.W. and Leinhardt, S. (1970). A Method for Detecting Structure in Sociometric Data. American Journal of Sociology, 70, 492-513. either (uses the lower triangle of the matrix) or (uses the upper triangle) or (uses both parts). Ignored for directed graphs. if , returns the ordinary adjacency matrix. When the name of a valid edge attribute is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given attribute where there is an edge. Multiple edges are not supported, the value written in the matrix in this case will be unpredictable. This parameter is ignored if eids is the default value written to the cells in the case of adjacency matrices with attributes. specifies whether the edge IDs should be returned in the adjacency matrix. Since zero is a valid edge ID, the cells in the matrix that correspond to unconnected vertex pairs will contain -1 instead of 0 if eids is . If eids is , the number of edges will be returned in the matrix for each vertex pair. Returns the adjacency matrix of a graph as a SciPy CSR matrix. if , returns the ordinary adjacency matrix. When the name of a valid edge attribute is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given attribute where there is an edge. Returns the adjacency list representation of the graph. The adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex. if , returns the successors of the vertex. If , returns the predecessors of the vertex. If , both the predecessors and the successors will be returned. Ignored for undirected graphs. Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph. A path is simple if its vertices are unique, i.e. no vertex is visited more than once. Note that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function. the source for the calculated paths a vertex selector describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a object. means all the vertices. maximum length of path that is considered. If negative, paths of all lengths are considered. the directionality of the paths. means to calculate incoming paths, means to calculate outgoing paths, means to calculate both ones. all of the simple paths from the given node to every other reachable node in the graph in a list. Note that in case of mode= , the vertices in a path are returned in reversed order! Returns all the automorphisms of the graph This function simply calls with the graph itself. See for an explanation of the parameters. a list of lists, each item containing a possible mapping of the graph vertices to itself according to the automorphism If you want to use source and target vertex IDs as index, you can do: The index will be a pandas.MultiIndex. You can use the option to keep the and columns. If you want to use vertex names in the source and target columns: a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names \"source\" and \"target\". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns. Returns the incidence matrix of a bipartite graph. The incidence matrix is an n times m matrix, where n and m are the number of vertices in the two vertex classes. an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to corresponds to vertices of the first kind, everything else to the second kind. the incidence matrix and two lists in a triplet. The first list defines the mapping between row indices of the matrix and the original vertex IDs. The second list is the same for the column indices. Returns the incidence list representation of the graph. The incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex. if , returns the successors of the vertex. If , returns the predecessors of the vertex. If , both the predecessors and the successors will be returned. Ignored for undirected graphs. If you want to use vertex names as index, you can do: a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices. Calculates the Gomory-Hu tree of an undirected graph with optional edge capacities. The Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values. The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree. the edge capacities (weights). If , all edges have equal weight. May also be an attribute name. the name of the edge attribute in the returned graph in which the flow values will be stored. See for possible arguments. Creates the intersection of two (or more) graphs. graph or list of graphs to be intersected with the current one. whether to use vertex names instead of ids. See for details. Returns whether the graph is named. A graph is named if and only if it has a vertex attribute. Returns whether the graph is weighted. A graph is weighted if and only if it has a edge attribute. Returns some k-cores of the graph. The method accepts an arbitrary number of arguments representing the desired indices of the k-cores to be returned. The arguments can also be lists or tuples. The result is a single object if an only integer argument was given, otherwise the result is a list of objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all k-cores in increasing order of k. Returns the layout of the graph according to a layout algorithm. Parameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters. Registered layout names understood by this method are: the layout to use. This can be one of the registered layout names or a callable which returns either a object or a list of lists containing the coordinates. If , uses the value of the configuration key. Chooses and runs a suitable layout function based on simple topological properties of the graph. This function tries to choose an appropriate layout function for the graph using the following rules:\n• If the graph has an attribute called , it will be used. It may either be a instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.\n• Otherwise, if the graph has vertex attributes called and , these will be used as coordinates in the layout. When a 3D layout is requested (by setting to 3), a vertex attribute named will also be needed.\n• Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see ).\n• Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see ).\n• If everything else above failed, the DrL layout algorithm will be used (see ). All the arguments of this function except are passed on to the chosen layout function (in case we have to call some layout function). specifies whether we would like to obtain a 2D or a 3D layout. This is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well. Each vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings. Dummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices. a vector specifying a non-negative integer layer index for each vertex, or the name of a numeric vertex attribute that contains the layer indices. If , a layering will be determined automatically. For undirected graphs, a spanning tree will be extracted and vertices will be assigned to layers using a breadth first search from the node with the largest degree. For directed graphs, cycles are broken by reversing the direction of edges in an approximate feedback arc set using the heuristic of Eades, Lin and Smyth, and then using longest path layering to place the vertices in layers. edge weights to be used. Can be a sequence or iterable or even an edge attribute name. minimum horizontal gap between vertices in the same layer. vertical gap between layers. The layer index will be multiplied by vgap to obtain the Y coordinate. maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings. specifies that the extended graph with the added dummy vertices should also be returned. When this is , the result will be a tuple containing the layout and the extended graph. The first |V| nodes of the extended graph will correspond to the nodes of the original graph, the remaining ones are dummy nodes. Plotting the extended graph with the returned layout and hidden dummy nodes will produce a layout that is similar to the original graph, but with the added edge bends. The extended graph also contains an edge attribute called which specifies the ID of the edge in the original graph from which the edge of the extended graph was created. the calculated layout, which may (and usually will) have more rows than the number of vertices; the remaining rows correspond to the dummy nodes introduced in the layering step. When is , it will also contain the extended graph. K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of hierarchical system structures. IEEE Systems, Man and Cybernetics 11(2):109-125, 1981. P Eades, X Lin and WF Smyth: A fast effective heuristic for the feedback arc set problem. Information Processing Letters 47:319-323, 1993. Returns a maximum flow between the given source and target vertices in a graph. A maximum flow from source to target is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:\n• For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the capacity argument)\n• For every vertex except the source and the target, the incoming flow is the same as the outgoing flow. The value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value. the edge capacities (weights). If , all edges have equal weight. May also be an attribute name. A maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible. vertex types in a list or the name of a vertex attribute holding vertex types. Types should be denoted by zeros and ones (or and ) for the two sides of the bipartite graph. If omitted, it defaults to , which is the default vertex type attribute for bipartite graphs. edge weights to be used. Can be a sequence or iterable or even an edge attribute name. a small real number used in equality tests in the weighted bipartite matching algorithm. Two real numbers are considered equal in the algorithm if their difference is smaller than this value. This is required to avoid the accumulation of numerical errors. If you pass here, igraph will try to determine an appropriate value automatically. Calculates the minimum cut between the given source and target vertices or within the whole graph. The minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below. the source vertex ID. If , the target must also be and the calculation will be done for the entire graph (i.e. all possible vertex pairs). the target vertex ID. If , the source must also be and the calculation will be done for the entire graph (i.e. all possible vertex pairs). the edge capacities (weights). If , all edges have equal weight. May also be an attribute name. Calculates the modularity score of the graph with respect to a given clustering. The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as Q = 1 ⁄ (2m)*sum(Aij − ki*kj ⁄ (2m)delta(ci, cj), i, j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, and Ci and are the types of the two vertices (i and j). delta(x, y) is one iff x = y, 0 otherwise. If edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges adjacent to vertex i, kj is the total weight of edges adjacent to vertex j and m is the total edge weight in the graph. optional edge weights or if all edges are weighed equally. Attribute names are also allowed. MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004. See for possible arguments. the indices of the vertices being queried. means all of the vertices. whether to consider directed paths. the damping factor. is the PageRank value for nodes with no incoming links. It is also the probability of resetting the random walk to a uniform distribution in each step. edge weights to be used. Can be a sequence or iterable or even an edge attribute name. an object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument. which implementation to use to solve the PageRank eigenproblem. Possible values are:\n• : use the PRPACK library. This is a new implementation in igraph 0.7\n• : use the ARPACK library. This implementation was used from version 0.5, until version 0.7.\n• : use a simple power method. This is the implementation that was used before igraph version 0.5. The number of iterations to use in the power method implementation. It is ignored in the other implementations The power method implementation will consider the calculation as complete if the difference of PageRank values between iterations change less than this value for every node. It is ignored by the other implementations. a list with the Google PageRank values of the specified vertices. Returns the path length histogram of the graph whether to consider directed paths. Ignored for undirected graphs. a object. The object will also have an attribute that stores the number of unconnected vertex pairs (where the second vertex can not be reached from the first one). The latter one will be of type long (and not a simple integer), since this can be very large. a vector containing weights for every edge in the graph. means that the graph is unweighted. whether to return the minimum spanning tree (when is ) or to return the IDs of the edges in the minimum spanning tree instead (when is ). The default is for historical reasons as this argument was introduced in igraph 0.6. the spanning tree as a object if is or the IDs of the edges that constitute the spanning tree if is . Calculates the minimum cut between the source and target vertices in a graph. the capacity of the edges. It must be a list or a valid attribute name or . In the latter case, every edge will have the same capacity. the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple Returns the summary of the graph. The output of this method is similar to the output of the method. If verbosity is zero, only the header line is returned (see for more details), otherwise the header line and the edge list is printed. Behind the scenes, this method constructs a object and invokes its method. if zero, only the header line is returned (see for more details), otherwise the header line and the full edge list is printed. the number of characters to use in one line. If , no limit will be enforced on the line lengths. the summary of the graph. Data types: graph-tool only accepts specific data types. See the following web page for a list: Note: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail. dictionary of graph attributes to transfer. Keys are attributes from the graph, values are data types (see below). means no graph attributes are transferred. dictionary of vertex attributes to transfer. Keys are attributes from the vertices, values are data types (see below). means no vertex attributes are transferred. dictionary of edge attributes to transfer. Keys are attributes from the edges, values are data types (see below). means no vertex attributes are transferred. specifies which NetworkX graph class to use when constructing the graph. means to let igraph infer the most appropriate class based on whether the graph is directed and whether it has multi-edges. Calculates the average of the vertex transitivities of the graph. In the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references). Note that this measure is different from the global transitivity measure (see ) as it simply takes the average local transitivity across the whole network. defines how to treat vertices with degree less than two. If or , these vertices will have zero transitivity. If or , these vertices will be excluded from the average. edge weights to be used. Can be a sequence or iterable or even an edge attribute name. Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416. Calculates the triad census of the graph. Davis, J.A. and Leinhardt, S. (1972). The Structure of Positive Interpersonal Relations in Small Groups. In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin. Creates the union of two (or more) graphs. graph or list of graphs to be united with the current one. whether to use vertex names instead of ids. See for details. This method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method. The remaining arguments are passed to the writer method without any changes. the file containing the graph to be saved the format of the file (if one wants to override the format determined from the filename extension, or the filename itself is a stream). means auto-detection. Possible values are: if the file format can't be identified and none was given. Writes the adjacency matrix of the graph to the given file All the remaining arguments not mentioned here are passed intact to . the name of the file to be written. the string that separates the matrix elements in a row the string that separates the rows of the matrix. Please note that igraph is able to read back the written adjacency matrix if and only if this is a single newline character Writes the graph in DIMACS format to the given file. the name of the file to be written or a Python file handle. the source vertex ID. If , igraph will try to infer it from the graph attribute. the target vertex ID. If , igraph will try to infer it from the graph attribute. the capacities of the edges in a list or the name of an edge attribute that holds the capacities. If there is no such edge attribute, every edge will have a capacity of 1. The library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like or from Unix command line) or the Python module. Uses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well. the name of the file to be written. the level of compression. 1 is fastest and produces the least compression, and 9 is slowest and produces the most compression. the name of the file or a stream to save to. If , saves the graph to a string and returns the string. pickle protocol version to be used. If -1, uses the highest protocol available if the graph was saved successfully to the given file, or a string if was . Saves the graph in Python pickled format, compressed with gzip. Saving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive. the name of the file or a stream to save to. pickle protocol version to be used. If -1, uses the highest protocol available if the graph was saved successfully to the given file. Saves the graph as an SVG (Scalable Vector Graphics) file The file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update. the name of the file or a Python file handle the layout of the graph. Can be either an explicitly specified layout (using a list of coordinate pairs) or the name of a layout algorithm (which should refer to a method in the object, but without the prefix. the vertex labels. Either it is the name of a vertex attribute to use, or a list explicitly specifying the labels. It can also be . the vertex colors. Either it is the name of a vertex attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file. the vertex shapes. Either it is the name of a vertex attribute to use, or a list explicitly specifying the shapes as integers. Shape 0 means hidden (nothing is drawn), shape 1 is a circle, shape 2 is a rectangle and shape 3 is a rectangle that automatically sizes to the inner text. the edge colors. Either it is the name of an edge attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file. the stroke widths of the edges. Either it is the name of an edge attribute to use, or a list explicitly specifying the stroke widths. The stroke width can be anything acceptable in an SVG file. font size. If it is a string, it is written into the SVG file as-is (so you can specify anything which is valid as the value of the style). If it is a number, it is interpreted as pixel size and converted to the proper attribute value accordingly. The edge sequence of the graph The vertex sequence of the graph Tries to identify the format of the graph stored in the file with the given filename. It identifies most file formats based on the extension of the file (and not on syntactic evaluation). The only exception is the adjacency matrix format and the edge list format: the first few lines of the file are evaluated to decide between the two. the name of the file or a file object whose attribute is set. the format of the file as a string. Internal function, should not be called directly. This method is for internal use only, it should not be called directly."
    },
    {
        "link": "https://datacamp.com/tutorial/depth-first-search-in-python",
        "document": "Level up your data science skills by creating visualizations using Matplotlib and manipulating DataFrames with pandas."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-for-depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a Boolean visited array. A graph can have more than one DFS traversal.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nPython Depth First Search Algorithm is used for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\nDFS Algorithm Time Complexity: O(V+E) where V is the number of vertices in the graph and E is the number of edges\n\nAuxiliary Space: O(V+E)\n\nPython Program for Depth First Search or DFS for a Graph – FAQs\n\nWhat is Depth First Search (DFS)?\n\nWhat is the difference between DFS and BFS?\n\nCan DFS be used for finding the shortest path?"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/pvqcim/depth_first_search_implementation_python_code",
        "document": "I've started to learn about graphs, and after watching a few videos about depth first search, I had a go at implementing a recursive and iterative dfs function. I was hoping to get some feedback and ideas for improvements on my code since I don't know any programmers irl. I know the print statements are a bit messy but I just decided to leave them in."
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://analyticsvidhya.com/blog/2024/06/depth-first-search-algorithm-in-python",
        "document": "Implementation of Depth First Search (DFS) Algorithm in Python\n\nIn depth-first search (DFS), all nodes are explored along some branch and backtracked. Think of it as being in a maze: DFS goes down one path until it reaches a dead-end before retracing its steps to take another, right? It is the same as going down, validating the tunnel, and so on for all tunnels.\n\nDFS is useful for:\n• Checking how different nodes are connected.\n\nWhile DFS dives deep, another method called Breadth-First Search (BFS) checks all neighbors at the current level before moving deeper. Both methods are important, but Depth First Search (DFS) helps you go as far as possible down one path before trying another.\n• DFS will exhaustively visit a single path before backtracking to a node with an unvisited path.\n• DFS-Recursive uses a call stack to manage traversal and goes deeper into each path.\n• Uses a separate stack to maintain the exploration; therefore, no recursion depth problem.\n• DFS’s time complexity is O(V+E)O(V + E)O(V+E), and its space complexity is O(V)O(V)O(V).\n• DFS is cool for many things. Some of the most common are pathfinding, cycle detection, topological sorting, and puzzle solving.\n• Difference between DFS and BFS BFS explores each level first and then goes to the next level, whereas DFS goes through one branch and then moves to the current.\n\nHow Does Depth First Search (DFS) Work?\n\nThe DFS algorithm involves visiting nodes as deeply as possible before backtracking. Here’s a step-by-step explanation:\n• Starting node: The search will start at the root node, in the case of a tree, or from an arbitrary node, in the case of the graph.\n• Explore: For each adjacent node, recursively visit the node if it has not been visited yet.\n• Backtrack: When a node with no unvisited adjacent nodes is reached, backtrack to the previous node and continue the process.\n\nAlso read: A Complete Python Tutorial to Learn Data Science from Scratch\n\nDFS—Depth First Search is a recursive algorithm. To implement it for a graph, we can either use recursion or implicit recursion using Stack.\n\nThe recursive implementation of DFS leverages the call stack to manage the traversal state. Here is a Python implementation:\n\nThe iterative implementation uses an explicit stack to manage the traversal. This can be useful to avoid potential issues with recursion depth in languages that limit the call stack size.\n\nThe code examples refer to the graph as an adjacency list. Each node is like a key, listing all the nodes directly connected to it. To avoid revisiting the same node, we have a set named visited, which stores the previous node.\n• Recursive DFS: The dfs_recursive function calls itself for each unvisited neighbor of the current node, diving deep into each path.\n• Iterative DFS: The dfs_iterative function uses a stack (a list where you add and remove items) to manage which nodes to visit next. This stack works like the call stack in the recursive method, helping track the order of visits.\n\nBoth methods ensure all parts of the graph are explored, but they do it differently.\n\nHere is the time and space complexity of DFS:\n• Time complexity: The time complexity of DFS is O(V + E), where V and E are the number of vertices and edges, respectively. In the worst case, each vertex and edge will be searched once.\n• Space Complexity: Space complexity would be O(V) since we need to keep track of visited nodes. In recursion, we would run a recursion stack, or we may push nodes into the stack in iterative.\n\nDepth First Search (DFS) has numerous applications in computer science and real-world problems:\n• Pathfinding: DFS would be useful for finding a path between two nodes in a graph.\n• Cycle Detection: It helps detect cycles in a graph and is useful in various domains, like dependency resolution.\n• Use cases for topological sorting: Scheduling the tasks so that each task depends on the others and must be performed in linear order.\n• Graph Traversal & Connected Components: DFS in an undirected graph to identify all connected components.\n• Maze and Puzzle Solving: Solve complex maze and puzzles by traversing every possible path.\n\nSuppose you have to find all the paths in a network of computers so that the data will be transmitted correctly. DFS is an algorithm that performs a depth-first search in a graph. It can be used to start from a particular computer and follow connections as far as they go, backtracking when no more connections can be followed.\n\nWhile DFS dives deep into a graph, BFS explores all neighbors of a node before moving to the next level. Each has its advantages:\n• DFS: Uses less memory and can find a path without exploring all nodes.\n• BFS: Guarantees finding the shortest path in an unweighted graph.\n\nDFS, or Depth-First Search, is a powerful utility for traversing graphs and using them in tree problems. DFS is useful when solving puzzles, finding your way in a maze, or organizing tasks. The two ways to use DFS are:\n• Recursive DFS: this uses function calls to track where you are coming from in the graph.\n• Iterative DFS: Using a stack to handle the steps.\n\nThe 2 methods guaranteed full coverage of the graph; every node was explored. Here is a list of how DFS can find paths, detect cycles, sort tasks, and connect components in a graph. Gaining knowledge about DFS will help you solve tough problems. After seeing the examples, you can explore DFS in your code.\n\nSo, are you looking for Python courses online? If yes, explore – Introduction to Python today!"
    }
]