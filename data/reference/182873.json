[
    {
        "link": "https://geeksforgeeks.org/normal-forms-in-dbms",
        "document": "Normal forms are the essential principles used to organize data efficiently and eliminate redundancy. They help to ensure that the database structure is logical, consistent and optimized for performance. By breaking down data into smaller, related tables and defining clear relationships between them, normal forms reduce duplication and improve data integrity. This process is crucial for creating databases that are easy to maintain, update, and query making them a fundamental concept for anyone working with databases.\n\nNormalization is the process of minimizing redundancy from a relation or set of relations. Redundancy in relation may cause insertion, deletion and update anomalies.\n\nNormalization is a systematic approach to organize data in a database to eliminate redundancy, avoid anomalies and ensure data consistency. The process involves breaking down large tables into smaller, well-structured ones and defining relationships between them. This not only reduces the chances of storing duplicate data but also improves the overall efficiency of the database.\n• None A relation in BCNF is also in 3NF , a relation in 3NF is also in 2NF and a relation in 2NF is also in 1NF.\n\nBy following a series of rules called normal forms (such as 1NF, 2NF, 3NF and BCNF) normalization ensures that the data is logically organized and maintains its integrity. For example, it prevents issues like inconsistent updates or deletion errors by ensuring that each piece of data has a single, clear location.\n• Purpose of Normal Forms \n\n To organize data efficiently, eliminate redundancy, and prevent anomalies during data operations like insertion, deletion and updates.\n• Types of Normal Forms\n\nFirst Normal Form (1NF): This is the most basic level of normalization. In 1NF, each table cell should contain only a single value, and each column should have a unique name. The first normal form helps to eliminate duplicate data and simplify queries. \n\nSecond Normal Form (2NF): 2NF eliminates redundant data by requiring that each non-key attribute be dependent on the primary key. This means that each column should be directly related to the primary key, and not to other columns. \n\nThird Normal Form (3NF): 3NF builds on 2NF by requiring that all non-key attributes are independent of each other. This means that each column should be directly related to the primary key, and not to any other columns in the same table. \n\nBoyce-Codd Normal Form (BCNF): BCNF is a stricter form of 3NF that ensures that each determinant in a table is a candidate key. In other words, BCNF ensures that each non-key attribute is dependent only on the candidate key. \n\nFourth Normal Form (4NF): 4NF is a further refinement of BCNF that ensures that a table does not contain any multi-valued dependencies. \n\nFifth Normal Form (5NF): 5NF is the highest level of normalization and involves decomposing a table into smaller tables to remove data redundancy and improve data integrity.\n• Dependency Elimination\n\n Normalization focuses on removing unnecessary dependencies like partial, transitive or multi-valued dependencies.\n\nNote: A design that has a lower normal form than another design has more redundancy.\n\nNormal forms reduce duplicate data, make data more consistent and improve how a database works. However, too much normalization can make the database design and queries more complicated. It’s important to find a balance between keeping the database organized and easy to use.\n• Reduced data redundancy: Normalization helps to eliminate duplicate data in tables, reducing the amount of storage space needed and improving database efficiency.\n• Improved data consistency: Normalization ensures that data is stored in a consistent and organized manner, reducing the risk of data inconsistencies and errors.\n• Simplified database design: Normalization provides guidelines for organizing tables and data relationships, making it easier to design and maintain a database.\n• Improved query performance: Normalized tables are typically easier to search and retrieve data from, resulting in faster query performance.\n• Easier database maintenance: Normalization reduces the complexity of a database by breaking it down into smaller, more manageable tables, making it easier to add, modify, and delete data.\n\nOverall, using normal forms in DBMS helps to improve data quality, increase database efficiency and simplify database design.\n\nFirst Normal Form (1NF) ensures that each column in a table contains single, indivisible values, and each row is unique. A table violates 1NF if it has composite or multi-valued attributes, such as multiple phone numbers in one cell. 1NF simplifies data, making it consistent and easy to manage.\n\nRead more about First Normal Form.\n\nA relation is in 2NF if it is in 1NF and any non-prime attribute (attributes which are not part of any candidate key) is not partially dependent on any proper subset of any candidate key of the table. In other words, we can say that, every non-prime attribute must be fully dependent on each candidate key. \n\nA functional dependency X->Y (where X and Y are set of attributes) is said to be in partial dependency, if Y can be determined by any proper subset of X.\n\nRead more about Second Normal Form.\n\nA relation is in Third Normal Form (3NF) if it is already in Second Normal Form (2NF) and does not have transitive dependencies for non-prime attributes.\n\nBelow mentioned is the basic condition that must be hold in the non-trivial functional dependency X -> Y:\n\nRead more about Third Normal Form.\n\nQuestion: Find the highest normal form of a relation R(A,B,C,D,E) with FD set as {BC->D, AC->BE, B->E}\n\nStep 1: As we can see, (AC)+ ={A,C,B,E,D} but none of its subset can determine all attribute of relation, So AC will be candidate key. A or C can’t be derived from any other attribute of the relation, so there will be only 1 candidate key {AC}.\n\nStep 2: Prime attributes are those attributes that are part of candidate key {A, C} in this example and others will be non-prime {B, D, E} in this example.\n\nStep 3: The relation R is in 1st normal form as a relational DBMS does not allow multi-valued or composite attribute. The relation is in 2nd normal form because BC->D is in 2nd normal form (BC is not a proper subset of candidate key AC) and AC->BE is in 2nd normal form (AC is candidate key) and B->E is in 2nd normal form (B is not a proper subset of candidate key AC).\n\nThe relation is not in 3rd normal form because in BC->D (neither BC is a super key nor D is a prime attribute) and in B->E (neither B is a super key nor E is a prime attribute) but to satisfy 3rd normal for, either LHS of an FD should be super key or RHS should be prime attribute. So the highest normal form of relation will be 2nd Normal form.\n\nBCNF (Boyce-Codd Normal Form) is a advanced version of Third Normal Form where one column depends on another, unless the first column is a candidate key (a column or combination of columns that can uniquely identify a row). The basic condition for any relation to be in BCNF is that it must be in Third Normal Form.\n\nIn simpler words, if any column in the table determines another column’s value, the determining column must be unique (a candidate key). BCNF fixes any issues left by 3NF\n\nWe have to focus on some basic rules that are for BCNF:\n\nFourth Normal Form contains no non-trivial multivalued dependency except candidate key. The basic condition with Fourth Normal Form is that the relation must be in BCNF.\n\nThe basic rules are mentioned below.\n\nFor more, refer to Fourth Normal Form in DBMS.\n\nFifth Normal Form is also called as Projected Normal Form. The basic conditions of Fifth Normal Form is mentioned below.\n\nFor more, refer to Fifth Normal Form in DBMS.\n• Data consistency: Normal forms ensure that data is consistent and does not contain any redundant information. This helps to prevent inconsistencies and errors in the database.\n• Data redundancy: Normal forms minimize data redundancy by organizing data into tables that contain only unique data. This reduces the amount of storage space required for the database and makes it easier to manage.\n• Response time: Normal forms can improve query performance by reducing the number of joins required to retrieve data. This helps to speed up query processing and improve overall system performance.\n• Database maintenance: Normal forms make it easier to maintain the database by reducing the amount of redundant data that needs to be updated, deleted, or modified. This helps to improve database management and reduce the risk of errors or inconsistencies.\n• Database design: Normal forms provide guidelines for designing databases that are efficient, flexible, and scalable. This helps to ensure that the database can be easily modified, updated, or expanded as needed.\n• None BCNF is free from redundancy caused by Functional Dependencies.\n• None If a relation is in BCNF, then 3NF is also satisfied.\n• None If all attributes of relation are prime attribute, then the relation is always in 3NF.\n• None A relation in a Relational Database is always and at least in 1NF form.\n• None Every Binary Relation ( a Relation with only 2 attributes ) is always in BCNF.\n• None If a Relation has only singleton candidate keys( i.e. every candidate key consists of only 1 attribute), then the Relation is always in 2NF( because no Partial functional dependency possible).\n• None Sometimes going for BCNF form may not preserve functional dependency. In that case go for BCNF only if the lost FD(s) is not required, else normalize till 3NF only.\n• None There are many more Normal forms that exist after BCNF, like 4NF and more. But in real world database systems it’s generally not required to go beyond BCNF.\n\nIn Conclusion, relational databases can be arranged according to a set of rules called normal forms in database administration (1NF, 2NF, 3NF, BCNF, 4NF, and 5NF), which reduce data redundancy and preserve data integrity. By resolving various kinds of data anomalies and dependencies, each subsequent normal form expands upon the one that came before it. The particular requirements and properties of the data being stored determine which normal form should be used; higher normal forms offer stricter data integrity but may also result in more complicated database structures.\n\nWhy is Normalization Important in DBMS?\n\nIs it possible to over-normalize the database?\n\nIs it necessary to normalize a database to Highest Normal Form like (BCNF or 4NF)?\n\nIs it possible for a relation in 2NF to have partial dependency?"
    },
    {
        "link": "https://geeksforgeeks.org/introduction-of-database-normalization",
        "document": "Normalization is an important process in database design that helps improve the database’s efficiency, consistency, and accuracy. It makes it easier to manage and maintain the data and ensures that the database is adaptable to changing business needs.\n• None Database normalization is the process of organizing the attributes of the database to reduce or eliminate data redundancy (having the same data but at different places).\n• None Data redundancy unnecessarily increases the size of the database as the same data is repeated in many places. Inconsistency problems also arise during insert, delete, and update operations.\n• None In the relational model, there exist standard methods to quantify how efficient a databases is. These methods are called and there are algorithms to covert a given database into normal forms.\n• None Normalization generally involves splitting a table into multiple ones which must be linked each time a query is made requiring data from the split tables.\n\nWhy do we need Normalization?\n\nThe primary objective for normalizing the relations is to eliminate the below anomalies. Failure to reduce anomalies results in data redundancy, which may threaten data integrity and cause additional issues as the database increases. Normalization consists of a set of procedures that assist you in developing an effective database structure.\n• Insertion Anomalies: Insertion anomalies occur when it is not possible to insert data into a database because the required fields are missing or because the data is incomplete. For example, if a database requires that every record has a primary key, but no value is provided for a particular record, it cannot be inserted into the database.\n• Deletion anomalies: Deletion anomalies occur when deleting a record from a database and can result in the unintentional loss of data. For example, if a database contains information about customers and orders, deleting a customer record may also delete all the orders associated with that customer.\n• Updation anomalies: Updation anomalies occur when modifying data in a database and can result in inconsistencies or errors. For example, if a database contains information about employees and their salaries, updating an employee’s salary in one record but not in all related records could lead to incorrect calculations and reporting.\n\nRead more about Anomalies in Relational Model.\n\nBefore Normalization: The table is prone to redundancy and anomalies (insertion, update, and deletion).\n\nAfter Normalization: The data is divided into logical tables to ensure consistency, avoid redundancy and remove anomalies making the database efficient and reliable.\n\nIn database normalization, we mainly put only tightly related information together. To find the closeness, we need to find which attributes are dependent on each other. To understand dependencies, we need to learn the below concepts.\n\nKeys are like unique identifiers in a table. For example, in a table of students, the student ID is a key because it uniquely identifies each student. Without keys, it would be hard to tell one record apart from another, especially if some information (like names) is the same. Keys ensure that data is not duplicated and that every record can be uniquely accessed.\n\nFunctional dependency helps define the relationships between data in a table. For example, if you know a student’s ID, you can find their name, age, and class. This relationship shows how one piece of data (like the student ID) determines other pieces of data in the same table. Functional dependency helps us understand these rules and connections, which are crucial for organizing data properly.\n\nOnce we figure out dependencies, we split tables to make sure that only closely related data is together in a table. When we split tables, we need to ensure that we do not loose information. For this, we need to learn the below concepts.\n• Elimination of Data Redundancy: One of the main features of normalization is to eliminate the data redundancy that can occur in a database. Data redundancy refers to the repetition of data in different parts of the database. Normalization helps in reducing or eliminating this redundancy, which can improve the efficiency and consistency of the database.\n• Ensuring Data Consistency: Normalization helps in ensuring that the data in the database is consistent and accurate. By eliminating redundancy, normalization helps in preventing inconsistencies and contradictions that can arise due to different versions of the same data.\n• Simplification of Data Management: Normalization simplifies the process of managing data in a database. By breaking down a complex data structure into simpler tables, normalization makes it easier to manage the data, update it, and retrieve it.\n• Improved Database Design: Normalization helps in improving the overall design of the database. By organizing the data in a structured and systematic way, normalization makes it easier to design and maintain the database. It also makes the database more flexible and adaptable to changing business needs.\n• Avoiding Update Anomalies: Normalization helps in avoiding update anomalies, which can occur when updating a single record in a table affects multiple records in other tables. Normalization ensures that each table contains only one type of data and that the relationships between the tables are clearly defined, which helps in avoiding such anomalies.\n• Standardization: Normalization helps in standardizing the data in the database. By organizing the data into tables and defining relationships between them, normalization helps in ensuring that the data is stored in a consistent and uniform manner.\n\nA relation is in first normal form if every attribute in that relation is single-valued attribute. A relation that is in First Normal Form and every non-primary-key attribute is fully functionally dependent on the primary key, then the relation is in Second Normal Form (2NF). A relation is in the third normal form, if there is no transitive dependency for non-prime attributes as well as it is in the second normal form. A relation is in 3NF if at least one of the following conditions holds in every non-trivial function dependency X –> Y.\n• None Y is a prime attribute (each element of Y is part of some candidate key). For BCNF the relation should satisfy the below conditions\n• None The relation should be in the 3rd Normal Form.\n• None X should be a super-key for every functional dependency (FD) X−>Y in a given relation. A relation R is in 4NF if and only if the following conditions are satisfied:\n• None The table should not have any Multi-valued Dependency. A relation R is in 5NF if and only if it satisfies the following conditions:\n• None R should be already in 4NF.\n• None It cannot be further non loss decomposed (join dependency).\n\nRead more about Normal Forms in DBMS.\n• None Normalization eliminates data redundancy and ensures that each piece of data is stored in only one place, reducing the risk of data inconsistency and making it easier to maintain data accuracy.\n• None By breaking down data into smaller, more specific tables, normalization helps ensure that each table stores only relevant data, which improves the overall data integrity of the database.\n• None Normalization simplifies the process of updating data, as it only needs to be changed in one place rather than in multiple places throughout the database.\n• None Normalization enables users to query the database using a variety of different criteria, as the data is organized into smaller, more specific tables that can be joined together as needed.\n• None Normalization can help ensure that data is consistent across different applications that use the same database, making it easier to integrate different applications and ensuring that all users have access to accurate and consistent data.\n• None Normalization can result in increased performance overhead due to the need for additional and the potential for slower query execution times.\n• None Normalization can result in the loss of data context, as data may be split across multiple tables and require additional joins to retrieve.\n• None Proper implementation of normalization requires expert knowledge of database design and the normalization process.\n• None Normalization can increase the complexity of a database design, especially if the data model is not well understood or if the normalization process is not carried out correctly.\n\nDatabase normalization is a key concept in organizing data efficiently within a database. By reducing redundancy, ensuring data consistency, and breaking data into well-structured tables, normalization enhances the accuracy, scalability, and maintainability of a database. It simplifies data updates, improves integrity, and supports flexible querying, making it an essential practice for designing reliable and efficient database systems.\n\nWhat role does database design play in normalization?"
    },
    {
        "link": "https://opentextbc.ca/dbdesign01/chapter/chapter-12-normalization",
        "document": "Normalization should be part of the database design process. However, it is difficult to separate the normalization process from the ER modelling process so the two techniques should be used concurrently.\n\nUse an entity relation diagram (ERD) to provide the big picture, or macro view, of an organization’s data requirements and operations. This is created through an iterative process that involves identifying relevant entities, their attributes and their relationships.\n\nNormalization procedure focuses on characteristics of specific entities and represents the micro view of entities within the ERD.\n\nNormalization is the branch of relational theory that provides design insights. It is the process of determining how much redundancy exists in a table. The goals of normalization are to:\n• Be able to characterize the level of redundancy in a relational schema\n• Provide mechanisms for transforming schemas in order to remove redundancy\n\nNormalization theory draws heavily on the theory of functional dependencies. Normalization theory defines six normal forms (NF). Each normal form involves a set of dependency properties that a schema must satisfy and each normal form gives guarantees about the presence and/or absence of update anomalies. This means that higher normal forms have less redundancy, and as a result, fewer update problems.\n\nAll the tables in any database can be in one of the normal forms we will discuss next. Ideally we only want minimal redundancy for PK to FK. Everything else should be derived from other tables. There are six normal forms, but we will only look at the first four, which are:\n\nIn the first normal form, only single values are permitted at the intersection of each row and column; hence, there are no repeating groups.\n\nTo normalize a relation that contains a repeating group, remove the repeating group and form two new relations.\n\nThe PK of the new relation is a combination of the PK of the original relation plus an attribute from the newly created relation for unique identification.\n\nWe will use the Student_Grade_Report table below, from a School database, as our example to explain the process for 1NF.\n• In the Student Grade Report table, the repeating group is the course information. A student can take many courses.\n• Remove the repeating group. In this case, it’s the course information for each student.\n• Identify the PK for your new table.\n• The PK must uniquely identify the attribute value (StudentNo and CourseNo).\n• After removing all the attributes related to the course and student, you are left with the student course table (StudentCourse).\n• The Student table (Student) is in first normal form with the repeating group removed.\n• The two new tables are shown below.\n• To add a new course, we need a student.\n• When course information needs to be updated, we may have inconsistencies.\n• To delete a student, we might also delete critical information about a course.\n\nFor the second normal form, the relation must first be in 1NF. The relation is automatically in 2NF if, and only if, the PK comprises a single attribute.\n\nIf the relation has a composite PK, then each non-key attribute must be fully dependent on the entire PK and not on a subset of the PK (i.e., there must be no partial dependency or augmentation).\n\nTo move to 2NF, a table must first be in 1NF.\n• The Student table is already in 2NF because it has a single-column PK.\n• When examining the Student Course table, we see that not all the attributes are fully dependent on the PK; specifically, all course information. The only attribute that is fully dependent is grade.\n• Identify the new table that contains the course information.\n• Identify the PK for the new table.\n• The three new tables are shown below.\n• When adding a new instructor, we need a course.\n• Updating course information could lead to inconsistencies for instructor information.\n• Deleting a course may also delete instructor information.\n\nTo be in third normal form, the relation must be in second normal form. Also all transitive dependencies must be removed; a non-key attribute may not be functionally dependent on another non-key attribute.\n• Eliminate all dependent attributes in transitive relationship(s) from each of the tables that have a transitive relationship.\n• Check new table(s) as well as table(s) modified to make sure that each table has a determinant and that no table contains inappropriate dependencies.\n• See the four new tables below.\n\nAt this stage, there should be no anomalies in third normal form. Let’s look at the dependency diagram (Figure 12.1) for this example. The first step is to remove repeating groups, as discussed above.\n\nTo recap the normalization process for the School database, review the dependencies shown in Figure 12.1.\n\nThe abbreviations used in Figure 12.1 are as follows:\n• None FD: full dependency (Note: FD typically stands for functional dependency. Using FD as an abbreviation for full dependency is only used in Figure 12.1.) \n\n\n\nWhen a table has more than one candidate key, anomalies may result even though the relation is in 3NF. Boyce-Codd normal form is a special case of 3NF. A relation is in BCNF if, and only if, every determinant is a candidate key.\n\nConsider the following table (St_Maj_Adv).\n\nThe semantic rules (business rules applied to the database) for this table are:\n• Each Student may major in several subjects.\n• For each Major, a given Student has only one Advisor.\n• Each Major has several Advisors.\n• Each Advisor only one Major.\n• Each Advisor several Students in one Major.\n\nThe functional dependencies for this table are listed below. The first one is a candidate key; the second is not.\n\nPK can be Student_id, Major or Student_id, Advisor.\n\nTo reduce the St_Maj_Adv relation to BCNF, you create two new tables:\n\nConsider the following table (Client_Interview).\n\nA relation is in BCNF if, and only if, every determinant is a candidate key. We need to create a table that incorporates the first three FDs (Client_Interview2 table) and another table (StaffRoom table) for the fourth FD.\n\nDuring the normalization process of database design, make sure that proposed entities meet required normal form before table structures are created. Many real-world databases have been improperly designed or burdened with anomalies if improperly modified during the course of time. You may be asked to redesign and modify existing databases. This can be a large undertaking if the tables are not properly normalized."
    },
    {
        "link": "https://monday.com/blog/project-management/functional-dependencies-2",
        "document": "Functional dependencies are a fundamental concept in database design, and are used to establish relationships between attributes in a database. They are used to ensure that the database is in a state of normalization, which helps to minimize data redundancy and improve data integrity.\n\nA functional dependency is a relationship between two sets of attributes in a database, where one set (the determinant) determines the values of the other set (the dependent). For example, in a database of employees, the employee ID number (determinant) would determine the employee’s name, address, and other personal information (dependent). This means that, given an employee ID number, we can determine the corresponding employee’s name and other personal information, but not vice versa.\n\nFunctional dependencies can also be represented using mathematical notation. For example, the functional dependency above can be represented as:\n\nIt’s important to note that functional dependencies only apply to the individual tuples in the table, and not to the table as a whole.\n\nWhat can functional dependencies be used for?\n\nThere are a few ways you could use functional dependencies in your database management.\n\nFor example, if a database contains a table with the attributes “employee ID” and “employee name”, and another table with the attributes “employee ID” and “employee address”, then there is a functional dependency between “employee ID” and “employee name” in the first table, and between “employee ID” and “employee address” in the second table.\n\nBy combining these two tables into one, with the attributes “employee ID”, “employee name”, and “employee address”, the data redundancy is eliminated.\n\nFor example, if a database contains a table with the attributes “employee ID” and “employee name”, and another table with the attributes “employee ID” and “employee address”, then there is a functional dependency between “employee ID” and “employee name” in the first table, and between “employee ID” and “employee address” in the second table. If the employee’s name is changed in the first table, but not in the second table, then the data is inconsistent.\n\nBy combining these two tables into one, with the attributes “employee ID”, “employee name”, and “employee address”, the data inconsistencies are eliminated.\n\nWhat are the different types of functional dependencies?\n\nThere are several types of functional dependencies, including full functional dependencies, partial functional dependencies, and transitive functional dependencies.\n\nA full functional dependency is a type of functional dependency where the dependent attributes are determined by the determinant attributes. For example, in the database of employees, the employee ID number fully determines the employee’s name, address, and other personal information.\n\nA partial dependency is a functional dependency where the dependent attributes are partially determined by the determinant attributes. For example, in a database of employees, the employee ID number may partially determine the employee’s address, but not the employee’s name or other personal information.\n\nA transitive functional dependency is a functional dependency where the dependent attributes are determined by a set of attributes that are not included in the determinant attributes. For example, in a database of employees, the employee ID number may determine the employee’s department, which in turn determines the employee’s salary.\n\nA trivial functional dependency in a relational database happens when an attribute or a set of attributes uniquely determines itself or a part of itself. For example, if A leads to A or A, B leads to A, these are trivial dependencies. These always hold true and help to identify more meaningful, non-trivial dependencies in database organization.\n\nA non-trivial functional dependency in a relational database occurs when an attribute or set of attributes uniquely determines another attribute or set that is not included in the original attributes. Simply put, if A determines B, and B is not part of A, this is a non-trivial dependency. These dependencies highlight important relationships between attributes and are essential for organizing and maintaining the integrity of a database.\n\nFunctional dependencies are a fundamental concept in database design, establishing relationships between attributes in a database. They ensure that the database is in a state of normalization, minimizing data redundancy and improving data integrity. Below are some common examples to illustrate how functional dependencies work:\n\nConsider a table in a database that stores employee information:\n\nEmployeeID → EmployeeName, EmployeeAddress, DepartmentID: The EmployeeID uniquely determines the EmployeeName, EmployeeAddress, and DepartmentID. Given the EmployeeID, you can find this corresponding information.\n\nConsider a product database that stores information about products and their categories:\n\nProductID → ProductName, CategoryID: The ProductID uniquely determines the ProductName and CategoryID.\n\nCategoryID → CategoryName: The CategoryID uniquely determines the CategoryName. For instance, a CategoryID of will always correspond to “Electronics”.\n\nConsider a university database that stores information about students and their enrolled courses:\n\nStudentID, CourseID → StudentName, CourseName: The combination of StudentID and CourseID uniquely determines the StudentName and CourseName. For example, StudentID and CourseID will determine Emma Brown and Database respectively.\n\nConsider a bookstore database that stores information about books and their authors:\n\nISBN → BookTitle, AuthorID: The ISBN uniquely determines the BookTitle and AuthorID.\n\nThese examples illustrate how functional dependencies can help to ensure that data is accurately represented and that redundant or inconsistent information is minimized in a relational database. Understanding and properly implementing functional dependencies is a crucial step in effective database design.\n\nFunctional dependencies are a crucial aspect of database design and are used to ensure that the database is in a state of normalization. They help to minimize data redundancy and improve data integrity. However, it’s important to note that functional dependencies are not the only factor to consider when designing a database. Other factors such as performance and scalability should also be taken into account.\n\nOne of the most common ways to represent functional dependencies is using the Armstrong’s Axioms. These are a set of rules that can be used to infer functional dependencies from a given set of functional dependencies. These rules include reflexivity, augmentation, and transitivity.\n\nReflexivity states that if X is a subset of Y, then Y → X.\n\nAugmentation states that if X → Y, then XZ → YZ for any attributes Z.\n\nTransitivity states that if X → Y and Y → Z, then X → Z.\n\nAnother way to represent functional dependencies is using the Normal Forms. Normal Forms are a set of rules that are used to determine the degree of normalization of a database. There are several Normal Forms, including First Normal Form (1NF), Second Normal Form (2NF), Third Normal Form (3NF), and so on.\n\nFirst Normal Form (1NF) requires that each table have a primary key, and that all data in the table is atomic (indivisible).\n\nSecond Normal Form (2NF) requires that the table is in 1NF, and that all non-primary key attributes are functionally dependent on the primary key.\n\nThird Normal Form (3NF) requires that the table is in 2NF, and that all non-primary key attributes are not functionally dependent on any non-primary key attributes.\n\nIt’s important to note that functional dependencies are not always easy to identify, and may require a thorough understanding of the data and the relationships between the data. Additionally, it’s not always possible to achieve higher Normal Forms, and trade-offs may need to be made between normalization and performance.\n\nFunctional dependencies are a crucial aspect of database design and are used to ensure that the database is in a state of normalization. They help to minimize data redundancy and improve data integrity. However, it’s important to note that functional dependencies are not the only factor to consider when designing a database. Other factors such as performance and scalability should also be taken into account. Start your trial with monday work management to power up automations, dashboards, and advanced database features."
    },
    {
        "link": "https://builtin.com/data-science/database-normalization",
        "document": "Database normalization is a structured set of steps for optimally designing a database model. Through database normalization, database administrators, data engineers and data architects can model and design a framework for storing an application’s data in such a way that the database layer of the application functions at maximum efficiency.\n\nIn this context, the data model refers to the set of relationships and conceptual entities specific to the business use case that the data represents. For example, in the case of retail banking data, this may include financial transactions and customer savings account information.\n\nSince most websites and software applications rely on the storage of data to operate efficiently, database normalization remains a crucial step in data management.\n\nIt’s worth noting there is also a sixth normal form (6NF). That said, 6NF is not yet standardized so I haven’t included it in this definition.\n\nWhy Do We Need Database Normalization?\n\nThe database normalization process is a critical step in our database management for many reasons. Database normalization helps us:\n\nDatabase anomalies are errors that occur when modifying data, such as inserting, updating or deleting specific data values or attributes. These changes can lead to incorrect or missing data. Normalizing the data can prevent the database from suffering from these problems during daily operations.\n\nFunctional dependencies are relationships between database attributes, which are the conceptual and physical entities the data represents. A customer’s attribute could be their phone number or home address.\n\nHere’s how it works: One attribute (A) is functionally dependent on another attribute (B) when, by knowing the value of B, you can uniquely determine the value of A. This process does not work in reverse. In other words, functional dependencies represent relationships between data. These are best organized or managed through normalization, a process that I’ll demonstrate below.\n\nIn database design, we want to avoid having many parts of the database (and its data) depend on several other parts of the database. In other words, we want to avoid a tightly coupled system.\n\nIn a tightly coupled system, one part of the system can break or stop functioning, thereby leading to many other parts breaking, which ultimately negatively affects database performance.\n\nNormalization helps database administrators achieve a loosely coupled system that’s more modular and less inter-dependent. This loose coupling helps with operational diagnostics and root-cause analysis of problems when they inevitably occur.\n\nMore Database 101 From Our ExpertsWhat Is a Relational Database?\n\nIn database management, redundancies mostly refer to having duplicate data in the system, which we can avoid through normalization. Avoiding duplicate data is important since it can save us the additional money and storage resources required to maintain it, in addition to the risk of having to update/maintain data consistency in multiple places instead of simplifying the data model.\n\nA positive side effect of all the above is the avoidance of bugs, system issues and ultimately even potential downtime of the software application. System downtime can happen due to failures at the database layer if the data is not properly normalized. This aspect directly connects the proper management and storage of application data in the back-end systems with the customer experience on the front end — and ultimately the market success of the company that owns the application.\n\nA normalized database also helps achieve efficiency gains. For example, your system may need to execute a smaller set of operations to model, serve and process the data for customers. A smaller set of operations due to well-normalized data also requires less computing power, thereby leading to cost savings on the software infrastructure (or stack) on which the database application runs. For this reason, database normalization is also directly tied to savings in operational costs.\n\nNow that we understand the benefits of normalization, let’s go through the steps for normalizing our databases. We refer to these as the normal forms.\n\nAt this step, our data is not yet normalized, so it’s full of redundancies and still in its raw form without any structure or modeling logic applied to it.\n• None Making sure each attribute of the data contains a single value instead of multiple values\n• None Identifying key attributes that we can use as the data’s unique identifiers (or primary keys)\n\nHow to Go From 0NF to 1NF\n\nLet’s look at an example of what it takes to move data from 0NF to 1NF using books as our sample data set.\n\nBelow you can see that the table represents data in zero normal form because each book stores multiple author information across different attributes (Author 1 and Author 2), which are repeating columns of the same data. In addition, there are columns such as Author Name that store multiple values, and this needs to be corrected.\n\nWe eliminate redundancies by splitting the data into a Books Table (and creating a Book ID identifier) and a Book-Author table. The Books Table now has a Book ID identifier, while the Book-Author Table stores all author ID information in one single column (the Author ID), plus additional author attributes (author’s name, gender and geographical location).\n\nWe only have one book in this example but the structure holds as we increase the number of books we store.\n• None Making sure the data starts in the first normal form\n• None Making sure all data is fully\n\nHow to Go From 1NF to 2NF\n\nThis data is not fully functionally dependent since, per the functional dependency definition we discussed above, we can’t uniquely determine the author’s name based on certain other attributes, such as Book ID.\n\nThis is because BookID has two separate authors, which means we need to correctly take the data to its second normal form.\n\nTo uniquely determine the value of one attribute from the value of its key, we split the data further and create the Authors table. With the data in this form, we are now able to:\n• None Uniquely identify an author in the Authors table by knowing its Author ID\n• None Uniquely identify a book in the Books table by knowing its Book ID\n• None Uniquely identify a Book-Author value by knowing its Book-Author ID from the Book-Author Table\n• None Making sure the data starts in the second normal form\n• None Making sure there are no transitive dependencies in the data. This means we need to ensure no other attribute (beyond the key identifiers or ID columns) can uniquely determine an attribute’s output\n\nHow to Go From 2NF to 3NF\n\nOnce we re-evaluate the data under the third normal form rules, we notice there’s a non-ID field (Province) that uniquely determines the value of the Country attribute. Therefore, the Country is functionally dependent on Province, a non-ID column.\n\nBy eliminating this dependency, we can get the data in the third normal form. To do this, we create a Province table with the Province values set as the Province ID and keep the Province ID in the Authors table. Finally, we link the data and avoid the transitive dependency we saw in the second normal form.\n• None Making sure the data is in the third normal form\n• None Eliminating all functional dependencies on attributes that are not the primary key (but that we could still potentially use as one)\n\nThe difference between this form and the third normal form is subtle. As in the third normal form, we’re primarily concerned with removing functional dependencies on non-key attributes, whereas here we are concerned with removing functional dependencies on potential key attributes.\n\nAt this point, our data is already extremely normalized so going beyond this point gets us into the realm of over-normalization, meaning normalizing to the point of introducing performance issues on the database since the data is overly separated and siloed.\n\nIn practice, these last two forms are not used. In theory, they are set to reduce the number of database anomalies even further. If you want to dig deeper into the theoretical details, here are a couple of helpful resources:\n\nIn common practice the first normal form through the Boyce-Codd normal form defines the set of steps most commonly used to achieve normalization benefits. The fourth and fifth forms are more rarely found in practice."
    },
    {
        "link": "https://opentextbc.ca/dbdesign01/chapter/chapter-12-normalization",
        "document": "Normalization should be part of the database design process. However, it is difficult to separate the normalization process from the ER modelling process so the two techniques should be used concurrently.\n\nUse an entity relation diagram (ERD) to provide the big picture, or macro view, of an organization’s data requirements and operations. This is created through an iterative process that involves identifying relevant entities, their attributes and their relationships.\n\nNormalization procedure focuses on characteristics of specific entities and represents the micro view of entities within the ERD.\n\nNormalization is the branch of relational theory that provides design insights. It is the process of determining how much redundancy exists in a table. The goals of normalization are to:\n• Be able to characterize the level of redundancy in a relational schema\n• Provide mechanisms for transforming schemas in order to remove redundancy\n\nNormalization theory draws heavily on the theory of functional dependencies. Normalization theory defines six normal forms (NF). Each normal form involves a set of dependency properties that a schema must satisfy and each normal form gives guarantees about the presence and/or absence of update anomalies. This means that higher normal forms have less redundancy, and as a result, fewer update problems.\n\nAll the tables in any database can be in one of the normal forms we will discuss next. Ideally we only want minimal redundancy for PK to FK. Everything else should be derived from other tables. There are six normal forms, but we will only look at the first four, which are:\n\nIn the first normal form, only single values are permitted at the intersection of each row and column; hence, there are no repeating groups.\n\nTo normalize a relation that contains a repeating group, remove the repeating group and form two new relations.\n\nThe PK of the new relation is a combination of the PK of the original relation plus an attribute from the newly created relation for unique identification.\n\nWe will use the Student_Grade_Report table below, from a School database, as our example to explain the process for 1NF.\n• In the Student Grade Report table, the repeating group is the course information. A student can take many courses.\n• Remove the repeating group. In this case, it’s the course information for each student.\n• Identify the PK for your new table.\n• The PK must uniquely identify the attribute value (StudentNo and CourseNo).\n• After removing all the attributes related to the course and student, you are left with the student course table (StudentCourse).\n• The Student table (Student) is in first normal form with the repeating group removed.\n• The two new tables are shown below.\n• To add a new course, we need a student.\n• When course information needs to be updated, we may have inconsistencies.\n• To delete a student, we might also delete critical information about a course.\n\nFor the second normal form, the relation must first be in 1NF. The relation is automatically in 2NF if, and only if, the PK comprises a single attribute.\n\nIf the relation has a composite PK, then each non-key attribute must be fully dependent on the entire PK and not on a subset of the PK (i.e., there must be no partial dependency or augmentation).\n\nTo move to 2NF, a table must first be in 1NF.\n• The Student table is already in 2NF because it has a single-column PK.\n• When examining the Student Course table, we see that not all the attributes are fully dependent on the PK; specifically, all course information. The only attribute that is fully dependent is grade.\n• Identify the new table that contains the course information.\n• Identify the PK for the new table.\n• The three new tables are shown below.\n• When adding a new instructor, we need a course.\n• Updating course information could lead to inconsistencies for instructor information.\n• Deleting a course may also delete instructor information.\n\nTo be in third normal form, the relation must be in second normal form. Also all transitive dependencies must be removed; a non-key attribute may not be functionally dependent on another non-key attribute.\n• Eliminate all dependent attributes in transitive relationship(s) from each of the tables that have a transitive relationship.\n• Check new table(s) as well as table(s) modified to make sure that each table has a determinant and that no table contains inappropriate dependencies.\n• See the four new tables below.\n\nAt this stage, there should be no anomalies in third normal form. Let’s look at the dependency diagram (Figure 12.1) for this example. The first step is to remove repeating groups, as discussed above.\n\nTo recap the normalization process for the School database, review the dependencies shown in Figure 12.1.\n\nThe abbreviations used in Figure 12.1 are as follows:\n• None FD: full dependency (Note: FD typically stands for functional dependency. Using FD as an abbreviation for full dependency is only used in Figure 12.1.) \n\n\n\nWhen a table has more than one candidate key, anomalies may result even though the relation is in 3NF. Boyce-Codd normal form is a special case of 3NF. A relation is in BCNF if, and only if, every determinant is a candidate key.\n\nConsider the following table (St_Maj_Adv).\n\nThe semantic rules (business rules applied to the database) for this table are:\n• Each Student may major in several subjects.\n• For each Major, a given Student has only one Advisor.\n• Each Major has several Advisors.\n• Each Advisor only one Major.\n• Each Advisor several Students in one Major.\n\nThe functional dependencies for this table are listed below. The first one is a candidate key; the second is not.\n\nPK can be Student_id, Major or Student_id, Advisor.\n\nTo reduce the St_Maj_Adv relation to BCNF, you create two new tables:\n\nConsider the following table (Client_Interview).\n\nA relation is in BCNF if, and only if, every determinant is a candidate key. We need to create a table that incorporates the first three FDs (Client_Interview2 table) and another table (StaffRoom table) for the fourth FD.\n\nDuring the normalization process of database design, make sure that proposed entities meet required normal form before table structures are created. Many real-world databases have been improperly designed or burdened with anomalies if improperly modified during the course of time. You may be asked to redesign and modify existing databases. This can be a large undertaking if the tables are not properly normalized."
    },
    {
        "link": "https://geeksforgeeks.org/normal-forms-in-dbms",
        "document": "Normal forms are the essential principles used to organize data efficiently and eliminate redundancy. They help to ensure that the database structure is logical, consistent and optimized for performance. By breaking down data into smaller, related tables and defining clear relationships between them, normal forms reduce duplication and improve data integrity. This process is crucial for creating databases that are easy to maintain, update, and query making them a fundamental concept for anyone working with databases.\n\nNormalization is the process of minimizing redundancy from a relation or set of relations. Redundancy in relation may cause insertion, deletion and update anomalies.\n\nNormalization is a systematic approach to organize data in a database to eliminate redundancy, avoid anomalies and ensure data consistency. The process involves breaking down large tables into smaller, well-structured ones and defining relationships between them. This not only reduces the chances of storing duplicate data but also improves the overall efficiency of the database.\n• None A relation in BCNF is also in 3NF , a relation in 3NF is also in 2NF and a relation in 2NF is also in 1NF.\n\nBy following a series of rules called normal forms (such as 1NF, 2NF, 3NF and BCNF) normalization ensures that the data is logically organized and maintains its integrity. For example, it prevents issues like inconsistent updates or deletion errors by ensuring that each piece of data has a single, clear location.\n• Purpose of Normal Forms \n\n To organize data efficiently, eliminate redundancy, and prevent anomalies during data operations like insertion, deletion and updates.\n• Types of Normal Forms\n\nFirst Normal Form (1NF): This is the most basic level of normalization. In 1NF, each table cell should contain only a single value, and each column should have a unique name. The first normal form helps to eliminate duplicate data and simplify queries. \n\nSecond Normal Form (2NF): 2NF eliminates redundant data by requiring that each non-key attribute be dependent on the primary key. This means that each column should be directly related to the primary key, and not to other columns. \n\nThird Normal Form (3NF): 3NF builds on 2NF by requiring that all non-key attributes are independent of each other. This means that each column should be directly related to the primary key, and not to any other columns in the same table. \n\nBoyce-Codd Normal Form (BCNF): BCNF is a stricter form of 3NF that ensures that each determinant in a table is a candidate key. In other words, BCNF ensures that each non-key attribute is dependent only on the candidate key. \n\nFourth Normal Form (4NF): 4NF is a further refinement of BCNF that ensures that a table does not contain any multi-valued dependencies. \n\nFifth Normal Form (5NF): 5NF is the highest level of normalization and involves decomposing a table into smaller tables to remove data redundancy and improve data integrity.\n• Dependency Elimination\n\n Normalization focuses on removing unnecessary dependencies like partial, transitive or multi-valued dependencies.\n\nNote: A design that has a lower normal form than another design has more redundancy.\n\nNormal forms reduce duplicate data, make data more consistent and improve how a database works. However, too much normalization can make the database design and queries more complicated. It’s important to find a balance between keeping the database organized and easy to use.\n• Reduced data redundancy: Normalization helps to eliminate duplicate data in tables, reducing the amount of storage space needed and improving database efficiency.\n• Improved data consistency: Normalization ensures that data is stored in a consistent and organized manner, reducing the risk of data inconsistencies and errors.\n• Simplified database design: Normalization provides guidelines for organizing tables and data relationships, making it easier to design and maintain a database.\n• Improved query performance: Normalized tables are typically easier to search and retrieve data from, resulting in faster query performance.\n• Easier database maintenance: Normalization reduces the complexity of a database by breaking it down into smaller, more manageable tables, making it easier to add, modify, and delete data.\n\nOverall, using normal forms in DBMS helps to improve data quality, increase database efficiency and simplify database design.\n\nFirst Normal Form (1NF) ensures that each column in a table contains single, indivisible values, and each row is unique. A table violates 1NF if it has composite or multi-valued attributes, such as multiple phone numbers in one cell. 1NF simplifies data, making it consistent and easy to manage.\n\nRead more about First Normal Form.\n\nA relation is in 2NF if it is in 1NF and any non-prime attribute (attributes which are not part of any candidate key) is not partially dependent on any proper subset of any candidate key of the table. In other words, we can say that, every non-prime attribute must be fully dependent on each candidate key. \n\nA functional dependency X->Y (where X and Y are set of attributes) is said to be in partial dependency, if Y can be determined by any proper subset of X.\n\nRead more about Second Normal Form.\n\nA relation is in Third Normal Form (3NF) if it is already in Second Normal Form (2NF) and does not have transitive dependencies for non-prime attributes.\n\nBelow mentioned is the basic condition that must be hold in the non-trivial functional dependency X -> Y:\n\nRead more about Third Normal Form.\n\nQuestion: Find the highest normal form of a relation R(A,B,C,D,E) with FD set as {BC->D, AC->BE, B->E}\n\nStep 1: As we can see, (AC)+ ={A,C,B,E,D} but none of its subset can determine all attribute of relation, So AC will be candidate key. A or C can’t be derived from any other attribute of the relation, so there will be only 1 candidate key {AC}.\n\nStep 2: Prime attributes are those attributes that are part of candidate key {A, C} in this example and others will be non-prime {B, D, E} in this example.\n\nStep 3: The relation R is in 1st normal form as a relational DBMS does not allow multi-valued or composite attribute. The relation is in 2nd normal form because BC->D is in 2nd normal form (BC is not a proper subset of candidate key AC) and AC->BE is in 2nd normal form (AC is candidate key) and B->E is in 2nd normal form (B is not a proper subset of candidate key AC).\n\nThe relation is not in 3rd normal form because in BC->D (neither BC is a super key nor D is a prime attribute) and in B->E (neither B is a super key nor E is a prime attribute) but to satisfy 3rd normal for, either LHS of an FD should be super key or RHS should be prime attribute. So the highest normal form of relation will be 2nd Normal form.\n\nBCNF (Boyce-Codd Normal Form) is a advanced version of Third Normal Form where one column depends on another, unless the first column is a candidate key (a column or combination of columns that can uniquely identify a row). The basic condition for any relation to be in BCNF is that it must be in Third Normal Form.\n\nIn simpler words, if any column in the table determines another column’s value, the determining column must be unique (a candidate key). BCNF fixes any issues left by 3NF\n\nWe have to focus on some basic rules that are for BCNF:\n\nFourth Normal Form contains no non-trivial multivalued dependency except candidate key. The basic condition with Fourth Normal Form is that the relation must be in BCNF.\n\nThe basic rules are mentioned below.\n\nFor more, refer to Fourth Normal Form in DBMS.\n\nFifth Normal Form is also called as Projected Normal Form. The basic conditions of Fifth Normal Form is mentioned below.\n\nFor more, refer to Fifth Normal Form in DBMS.\n• Data consistency: Normal forms ensure that data is consistent and does not contain any redundant information. This helps to prevent inconsistencies and errors in the database.\n• Data redundancy: Normal forms minimize data redundancy by organizing data into tables that contain only unique data. This reduces the amount of storage space required for the database and makes it easier to manage.\n• Response time: Normal forms can improve query performance by reducing the number of joins required to retrieve data. This helps to speed up query processing and improve overall system performance.\n• Database maintenance: Normal forms make it easier to maintain the database by reducing the amount of redundant data that needs to be updated, deleted, or modified. This helps to improve database management and reduce the risk of errors or inconsistencies.\n• Database design: Normal forms provide guidelines for designing databases that are efficient, flexible, and scalable. This helps to ensure that the database can be easily modified, updated, or expanded as needed.\n• None BCNF is free from redundancy caused by Functional Dependencies.\n• None If a relation is in BCNF, then 3NF is also satisfied.\n• None If all attributes of relation are prime attribute, then the relation is always in 3NF.\n• None A relation in a Relational Database is always and at least in 1NF form.\n• None Every Binary Relation ( a Relation with only 2 attributes ) is always in BCNF.\n• None If a Relation has only singleton candidate keys( i.e. every candidate key consists of only 1 attribute), then the Relation is always in 2NF( because no Partial functional dependency possible).\n• None Sometimes going for BCNF form may not preserve functional dependency. In that case go for BCNF only if the lost FD(s) is not required, else normalize till 3NF only.\n• None There are many more Normal forms that exist after BCNF, like 4NF and more. But in real world database systems it’s generally not required to go beyond BCNF.\n\nIn Conclusion, relational databases can be arranged according to a set of rules called normal forms in database administration (1NF, 2NF, 3NF, BCNF, 4NF, and 5NF), which reduce data redundancy and preserve data integrity. By resolving various kinds of data anomalies and dependencies, each subsequent normal form expands upon the one that came before it. The particular requirements and properties of the data being stored determine which normal form should be used; higher normal forms offer stricter data integrity but may also result in more complicated database structures.\n\nWhy is Normalization Important in DBMS?\n\nIs it possible to over-normalize the database?\n\nIs it necessary to normalize a database to Highest Normal Form like (BCNF or 4NF)?\n\nIs it possible for a relation in 2NF to have partial dependency?"
    },
    {
        "link": "https://nyu.edu/classes/jcf/CSCI-GA.2433-001_sp16/slides/session7/FunctionalDependenciesAndNormalizationExamples.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/normalization-process-in-dbms",
        "document": "Database Normalization is any systematic process of organizing a database schema such that no data redundancy occurs and there is least or no anomaly while performing any update operation on data. In other words, it means dividing a large table into smaller pieces such that data redundancy should be eliminated. The normalizing procedure depends on the functional dependencies among the attributes inside a table and uses several normal forms to guide the design process.\n\nThe Normalization Process Begins With the Following:\n• First Normal Form (1NF): Ensures that each column contains only atomic values that cannot be divided, and each record is unique.\n• Second Normal Form (2NF): Includes 1NF and removes subsets of data that would apply for more than one row and places that data in a separate table. It deals with a partial dependency example when a non-key attribute depends on part of a composite primary key.\n• Third Normal Form(3NF): This applies further normalization to the schema by removing transitive dependencies, which are where the non-key attributes depend on other non-key attributes.\n\nBesides these, BCNF is a stronger version of 3NF, developed by Raymond F. Boyce and Edgar F. Codd, which handles some more cases of redundancy not dealt with by 3NF. Further normal forms like Fourth Normal Form and Fifth Normal Form apply to the more complex scenarios for multi-valued dependencies and join dependencies, respectively. These are also less commonly applied.\n\nBoyce-Codd Normal Form, or BCNF for short, is an extension of the Third Normal Form, 3NF, in that it seeks to eliminate certain types of redundancy that the latter does not catch. In BCNF, for a table to be said to be in BCNF, it needs to have the following condition met: for any nontrivial functional dependency\n\nX needs to be a superkey. That is, for every functional dependency of the table, on the left of that dependency, an attribute or set of attributes should be a superkey of the table.\n\nThis requirement is stronger than that of 3NF, which only had a non-key attribute non-transitively dependent on a primary key. BCNF takes care of situations where, even for a table in 3NF, redundancy would still arise whenever there is added a dependency whose left-hand side is not a superkey, hence ensuring a higher level of normalization and, therefore, reduced redundancy.\n\nHere’s a table illustrating a BCNF violation with the given example:\n\nThe functional dependency Instructor → Room indicates that the Room is determined by the Instructor.\n\nHowever, Instructor is not a superkey of the table since it does not uniquely determine all attributes (it does not determine CourseID). This causes a violation of BCNF.\n\nTo convert this table into BCNF, we decompose it into two separate tables:\n• None In the CourseInstructor table, CourseID is a superkey, and it uniquely determines Instructor.\n• None In the InstructorRoom table, Instructor is a superkey, and it uniquely determines Room.\n\nThis decomposition satisfies BCNF since in both tables, every functional dependency has a superkey on its left side.\n\nNow, we are going to describe the process of Normalization by considering an Example. Let us look into that.\n\nIn this example, we will look into that how we can normalize the database with the help of different Normal Forms. We will look into each of the Normal Forms separately in this example.\n\nConsider the table 1 shown below:\n\nNow, we are re-structuring the table according to the 1st Normal Form.\n• None Each table should contain a single value.\n• None Each record needs to be unique.\n\nConsider the table 2 shown below:\n\nHere, People having the same name are from different institutes. So, we require Full Name and Institute to Identify a Row of the database. For this, we have to remove Partial Dependency.\n\nLet’s look at the 2nd Normal Form.\n• None The table should be in 1NF.\n• None Primary Key does not functionally dependent on any subset of Candidate Key.\n\nHere, the Id in Table 2 is Foreign Key to the Id in Table 1. Now, we have to remove Transitive Functional Dependency from our Table to Normalize our Database. A Transitive Functional Dependency basically tells us that there is an indirect relationship between functional dependency.\n\nNow, let us look at the 3rd Normal Form.\n• None The tables should be in 2NF.\n• None There will be no Transitive Dependency.\n\nFinally, Our Database is Normalized. From the above-mentioned example, we have reached our level of Normalization. In fact, there are also some higher forms or next levels of Normalization. Now, we are going to discuss them one by one.\n• Boyce-Codd Normal Form (BCNF): Sometimes, when the database is in the 3rd Normal Form, there exist some anomalies in DBMS, like when more than one Candidate Keys is present in the Database. This has to be removed under\n• 4th Normal Form: Whenever a Database contains multivalued and independent data in two or more tables, then the database is to be considered in the 4th Normal Form.\n• 5th Normal Form: Whenever a Database Table is not in 4NF, and we cannot divide it into smaller tables keeping our data safe with us, then our Database is in 5th Normal Form.\n\nThe relation should have no non-atomic attributes or nested relations. Form a name relation for each non-atomic attribute or nested relation. For relations where the primary key contains multiple attributes, no non-key attributes should be functionally dependent on a part of the primary key. Decompose and set up a new relation for each partial key with its dependent attributes. Make sure to keep a relationship with the original primary key and any attributes that are fully functionally dependent on it. The relation should not have a non-key attribute functionally determined by another non-key attribute (or by a set of non-key attributes) i.e., there should be no transitive dependency of a non-key attribute of the primary key. Decompose and set up a relation that includes the non-key attribute(s) that functionally determine(s) another non-key attribute (s). The relation should not have any attribute in Functional Dependency which is non-prime, the attribute that doesn’t occur in any candidate key. Make sure that the left side of every functional dependency is a candidate key. The relation should not have a multi-value dependency means it occurs when two attributes of a table are independent of each other but both depend on a third attribute. Decompose the table into two subtables. The relation should not have join dependency means if a table can be recreated by joining multiple tables and each of the tables has a subset of the attributes of the table, then the table is in Join Dependency. Decompose all the tables into as many as possible numbers in order to avoid dependency.\n\nThe process of normalization of databases will ensure that an efficient, organized, and consistent database is created by avoiding any redundancy and anomalies during the update of data. Databases can be modeled into normal forms starting from 1NF to BCNF and beyond in order to maintain the integrity of the data and improve the performance of the database. Each normal form takes care of specific redundancies and dependencies which finally result in a well-organized schema for accurate data management and retrieval.\n\nWhat is the purpose of First Normal Form?\n\nHow is 2NF different from 1NF?\n\nWhat is one of the most common problems avoided by 4NF?"
    },
    {
        "link": "https://stackoverflow.com/questions/4199444/functional-dependency-and-normalization",
        "document": "A functional dependency defines a functional relationship between attributes. For example: functionally determines (normally written as ). Another way of saying this is: There is exactly one Birth Date for any given instance of a person. Note that the converse may or may not be true. Many people may have been born on the same day. Given a we may find many sharing that date.\n\nSets of functional dependencies may be used to synthesize relations (tables). The definition of the first 3 normal forms, including Boyce Codd Normal Form (BCNF) is stated in terms of how a given set of relations represent functional dependencies. Fourth and fifth normal forms involve Multi-Valued dependencies (another kettle of fish).\n\nHere are a few free resources about Functional Dependencies, Normalization and database design. Be prepared to exercise your brain and math skills when studying this material.\n\nThe following are \"slide shows\" from various academic sites...\n\nThe following are academic papers. Heavier reading but well worth the effort.\n• The Application of Functional Dependency Theory to Relational Databases\n• A Simple Guide to Five Normal Forms in Relational Database\n\nIf you are seriously interested in this subject I suggest you put out the cash for a good book on the subject of Relational Database Design. For example: An Introduction to Database Systems by C.J. Date"
    }
]