[
    {
        "link": "https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/view-or-change-the-default-locations-for-data-and-log-files?view=sql-server-ver16",
        "document": "View or change the default locations for data and log files\n\nThe best practice for protecting your data files and log files is to ensure that they are protected by access control lists (ACLs). Set the ACLs on the directory root under which the files are created.\n\nThese instructions are for SQL Server on Windows only. To change the default locations for SQL Server on Linux, see Configure SQL Server on Linux with the mssql-conf tool.\n• None In Object Explorer, right-click on your server and select Properties.\n• None In the left panel on that Properties page, select the Database settings tab.\n• None In Database default locations, view the current default locations for new data files and new log files. To change a default location, enter a new default pathname in the Data or Log field, or select the browse button to find and select a pathname.\n• None After changing the default locations, you must stop and start the SQL Server service to complete the change.\n\nThe following example uses an extended stored procedure to modify the server registry. Serious problems might occur if you modify the registry incorrectly. These problems might require you to reinstall the operating system. Microsoft cannot guarantee that these problems can be resolved. Modify the registry at your own risk.\n• None From the Standard bar, select New Query.\n• None Copy and paste the following example into the query window. Replace the values with the new locations you wish to place your data and log files, and then select Execute. USE [master]; GO EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\Microsoft\\MSSQLServer\\MSSQLServer', N'BackupDirectory', REG_SZ, N'<path_to_database_backup_files>' GO EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\Microsoft\\MSSQLServer\\MSSQLServer', N'DefaultData', REG_SZ, N'<path_to_data_files>' GO EXEC xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\\Microsoft\\MSSQLServer\\MSSQLServer', N'DefaultLog', REG_SZ, N'<path_to_log_files>' GO\n• None After changing the default locations, you must stop and start the SQL Server service to complete the change."
    },
    {
        "link": "https://serverfault.com/questions/197526/what-is-the-default-location-for-a-db-in-sql-server-2008",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/13778034/how-do-i-change-database-default-locations-for-localdb-in-sql-server-managemen",
        "document": "Paths Cannot Be Changed in SQL Server LocalDB \"Automatic Instance\" Types\n\nIn case anyone in 2023 finds out they cannot change their default database file storage paths, this article is for you!\n\nThis error applies to Microsoft SQL Server not being able to allow you to change the default file folder location on your PC where the SQL Server Database Files are saved (database and logs files, and ).\n\nMost developers often need control over where local database files are saved. Most prefer to store them in a central location, another drive, or simply the main SQL Server database repository inside the , since that is where system data storage goes. One example of the problem of not being able to customize database file storage might be using Entity Framework Core, which runs \"migration\" scripts that create databases in SQL Server. When it does so, where those scripted databases get stored is heavily dependent on SQL Server's default file path settings. When the location of those EF code-first database files using LocalDB is locked down, developers are stuck with SQL files in multiple locations on their PC's.\n\nApparently, when Microsoft installs SQL Server / SQL Express on your device, it attempts to install a default instance of the server as a specialized type called a . They do this to get the user up and running fast with a \"LocalDB\" sql server instance, which is a one-time, \"light\", custom created server running as a public instance, complete with default settings which are (or developer) so he can get up and running fast. The automatic type has the advantage that its granted permissions to the user as administrator in SQL, as well as granting all applications on the user's device public access to the server instance. (You will notice that IIsExpress works this way using ApplicationPools as dummy Windows User Accounts, creating default accounts next to your User Account in Windows to run app pools in IIS.) These SQL Server LocalDB binaries do not run as a service but on-demand. But only one of the \"automatic\" types may be installed per version per device. The other SQL Server LocalDB type is the and is not as restricted as the automatic one, apparently.\n\nThe problem is, when they create this special LocalDB automatic instance, it locks down certain settings and applies certain permissions and settings that are unique just for this instance. This then limits what the user can do as far as customizations, one of which is the \"Database default locations\" in the Properties dialog box that appears when you right-click your sql server instance and choose properties.\n\nAnyone using the full SQL Server version, or who has created a new instance of LocalDB, deleting the old one, will not experience this issue, so most of those people are scratching their heads.\n\nBut for local developers, what this means is your Sql Server LocalDB databases running under this instance of the server will typically store their databases under a locked down path...either the path you chose on install or default to the user-friendly account paths under .\n\nWhen users attempt to change the path in the properties box for the instance, many users online the past 5-6 years have noticed a nasty that would appear when saving a default path. Microsoft doesn't bother to tell you, but that is intentional. They don't expect to allow you to save paths to the registry for the instance, and assume everyone is ok with the default path.\n\nYou can fix the key error by going into your registry and changing permission on the Microsoft SQL Server registry keys, assigning the \"Everyone\" group account to the registry node managing these keys. In the Registry, add Everyone group account to this node below then try and save a new default path in the properties box for your sql server localdb instance:\n\nThe location of the default database file path keys (2019) in the Registry in Windows for an instance of the localdb server of are located here:\n\nYou are then able to save the new default paths in SQL, and the error goes away. Saving your default path in the Properties box works now, and the new values appear in the registry.\n\nEven though you can change these paths, they will not stick, however, and reset back to the User Account Path, by default. Even if you save a new default sql path for your databases, when you create a new database it still reverts to the old path. Again, this applies ONLY for users who are running under the default \"Automatic\" LocalDB instance created on install of SQL Express.\n\nSo even after restarting SQL, restarting your PC, or restarting the SQL Service, those registry values will still not pull the registry keys into the SQL Server instance settings for Default file paths.\n\nAs proof, run these two scripts below in your SQL Server LocalDB instance. The first one returns the actual LocalDB default file paths SQL Server stores internally. The second script returns what is stored in your registry for the LocalDB default file path. If you saved new default path registry keys, they should be the same and shown in SQL Server instance properties, but they are different! That means Microsoft has decided not to allow you to change them for those running the \"automatic\" instance type of LocalDB on install. Below is the T-SQL to run to test this:\n\nWhy isnt SQL Server LocalDB pulling in the registry values?\n\nWhat this means again, is sorry you can't change these default paths. Your best bet is to simple \"detach\" your databases, copy the and files to your new prefered folder, then reattach. When you create new databases, the console allows you to change the database file path there, as well. There are also some elaborate SQL scripts you can run to set paths before saving files.\n\nBut just know this is by design."
    },
    {
        "link": "https://support.microsoft.com/en-us/topic/unable-to-change-the-default-physical-location-of-content-databases-on-sql-server-fd9db304-ef8e-1f06-c3e0-d11b9ef3f2cf",
        "document": "When we change the database default location in SQL server and create a new web application the content database will be saved to the previous location and will not use the settings changed on the SQL server.\n\nChanges will only take effect after you restart the SQL Server or SQL services. The connection from SharePoint to SQL has to be refreshed. When you save the location, it's saved as DefaultData and DefaultLog under HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Microsoft SQL Server\\MSSQL.1\\MSSQLServer\n\nThe Work around to resolve this issue is to restart the SQL server or SQL services 1. Open SQL Server Management Studio and connect to the SQL instance Where your SharePoint Databases will be hosted\n\n2. Right Click the Server name or the SQL instance and click Properties.\n\n3. Change Database Settings for \"Database Default Locations\" for both Data(*.MDF): and Log(*.LDF)\n\n4. Now to test Create a new Database it will get created in the new Database Defult location. But when you create content DB it will create the data files in the default location which you have previously. To aviod that restart teh SQL service or reboot the SQL Box."
    },
    {
        "link": "https://orangematter.solarwinds.com/2013/12/06/changing-default-database-file-locations-in-sql-server",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/databases/view-or-change-the-properties-of-a-database?view=sql-server-ver16",
        "document": "View or Change the Properties of a Database\n\nThis topic describes how to view or change the properties of a database in SQL Server by using SQL Server Management Studio or Transact-SQL. After you change a database property, the modification takes effect immediately.\n• None To view or change the properties of a database, using:\n• When AUTO_CLOSE is ON, some columns in the sys.databases catalog view and DATABASEPROPERTYEX function will return NULL because the database is unavailable to retrieve the data. To resolve this, open the database.\n\nRequires ALTER permission on the database to change the properties of a database. Requires at least membership in the Public database role to view the properties of a database.\n\nTo view or change the properties of a database\n• None In Object Explorer, connect to an instance of the SQL Server Database Engine, and then expand that instance.\n• None Expand Databases, right-click the database to view, and then click Properties.\n• None In the Database Properties dialog box, select a page to view the corresponding information. For example, select the Files page to view data and log file information.\n\nTransact-SQL provides a number of different methods for viewing the properties of a database and for changing the properties of a database. To view the properties of a database, you can use the DATABASEPROPERTYEX (Transact-SQL) function and the sys.databases (Transact-SQL) catalog view. To change the properties of a database, you can use the version of the ALTER DATABASE statement for your environment: ALTER DATABASE (Transact-SQL) or ALTER DATABASE (Azure SQL Database). To view database scoped properties, use the sys.database_scoped_configurations (Transact-SQL) catalog view and to alter database scoped properties, use the ALTER DATABASE SCOPED CONFIGURATION (Transact-SQL) statement.\n\nTo view a property of a database by using the DATABASEPROPERTYEX function\n• None Connect to the Database Engine and then connect to the database for which you wish to view its properties.\n• None From the Standard bar, click New Query.\n• None Copy and paste the following example into the query window and click Execute. This example uses the DATABASEPROPERTYEX system function to return the status of the AUTO_SHRINK database option in the database. A return value of 1 means that the option is set to ON, and a return value of 0 means that the option is set to OFF.\n\nTo view the properties of a database by querying sys.databases\n• None Connect to the Database Engine and then connect to the database for which you wish to view its properties..\n• None From the Standard bar, click New Query.\n• None Copy and paste the following example into the query window and click Execute. This example queries the sys.databases catalog view to view several properties of the database. This example returns the database ID number ( ), whether the database is read-only or read-write ( ), the collation for the database ( ), and the database compatibility level ( ). SELECT database_id, is_read_only, collation_name, compatibility_level FROM sys.databases WHERE name = 'AdventureWorks2022';\n\nTo view the properties of a database-scoped configuration by querying sys.databases_scoped_configuration\n• None Connect to the Database Engine and then connect to the database for which you wish to view its properties..\n• None From the Standard bar, click New Query.\n• None Copy and paste the following example into the query window and click Execute. This example queries the sys.database_scoped_configurations (Transact-SQL) catalog view to view several properties of the current database. SELECT configuration_id, name, value, value_for_secondary FROM sys.database_scoped_configurations; For more examples, see sys.database_scoped_configurations (Transact-SQL)\n\nTo change the properties of a SQL Server 2016 database using ALTER DATABASE\n• None From the Standard bar, click New Query.\n• None Copy and paste the following example into the query window. The example determines the state of snapshot isolation on the database, changes the state of the property, and then verifies the change. To determine the state of snapshot isolation, select the first statement and click Execute. To change the state of snapshot isolation, select the statement and click Execute. To verify the change, select the second statement, and click Execute. USE AdventureWorks2022; GO -- Check the state of the snapshot_isolation_framework -- in the database. SELECT name, snapshot_isolation_state, snapshot_isolation_state_desc AS description FROM sys.databases WHERE name = N'AdventureWorks2022'; GO USE master; GO ALTER DATABASE AdventureWorks2022 SET ALLOW_SNAPSHOT_ISOLATION ON; GO -- Check again. SELECT name, snapshot_isolation_state, snapshot_isolation_state_desc AS description FROM sys.databases WHERE name = N'AdventureWorks2022'; GO\n\nTo change the database-scoped properties using ALTER DATABASE SCOPED CONFIGURATION\n• None Connect to a database in your SQL Server instance.\n• None From the Standard bar, click New Query.\n• None Copy and paste the following example into the query window. The following example sets MAXDOP for a secondary database to the value for the primary database."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-files-and-filegroups?view=sql-server-ver16",
        "document": "At a minimum, every SQL Server database has two operating system files: a data file and a log file. Data files contain data and objects such as tables, indexes, stored procedures, and views. Log files contain the information that is required to recover all transactions in the database. Data files can be grouped together in filegroups for allocation and administration purposes.\n\nSQL Server databases have three types of files, as shown in the following table.\n\nFor example, a simple database named has one primary file that contains all data and objects and a log file that contains the transaction log information. A more complex database named can be created that includes one primary file and five secondary files. The data and objects within the database spread across all six files, and the four log files contain the transaction log information.\n\nBy default, the data and transaction logs are put on the same drive and path to handle single-disk systems. This choice might not be optimal for production environments. We recommend that you put data and log files on separate disks.\n\nSQL Server files have two file name types:\n• None The is the name used to refer to the physical file in all Transact-SQL statements. The logical file name must comply with the rules for SQL Server identifiers and must be unique among logical file names in the database.\n• None The is the name of the physical file including the directory path. It must follow the rules for the operating system file names.\n\nFor more information on the and argument, see ALTER DATABASE File and Filegroup Options (Transact-SQL).\n\nWhen multiple instances of SQL Server are running on a single computer, each instance receives a different default directory to hold the files for the databases created in the instance. For more information, see File Locations for Default and Named Instances of SQL Server.\n\nPages in a SQL Server data file are numbered sequentially, starting with zero (0) for the first page in the file. Each file in a database has a unique file ID number. To uniquely identify a page in a database, both the file ID and the page number are required. The following example shows the page numbers in a database that has a 4-MB primary data file and a 1-MB secondary data file.\n\nA file header page is the first page that contains information about the attributes of the file. Several of the other pages at the start of the file also contain system information, such as allocation maps. One of the system pages stored in both the primary data file and the first log file is a database boot page that contains information about the attributes of the database.\n\nSQL Server files can grow automatically from their originally specified size. When you define a file, you can specify a specific growth increment. Every time the file is filled, it increases its size by the growth increment. If there are multiple files in a filegroup, they won't autogrow until all the files are full.\n\nFor more information about pages and page types, see Pages and Extents Architecture Guide.\n\nEach file can also have a maximum size specified. If a maximum size isn't specified, the file can continue to grow until it has used all available space on the disk. This feature is especially useful when SQL Server is used as a database embedded in an application where the user doesn't have convenient access to a system administrator. The user can let the files autogrow as required to reduce the administrative burden of monitoring free space in the database and manually allocating additional space.\n\nFor more information on transaction log file management, see Manage the size of the transaction log file.\n\nThe form of file that is used by a database snapshot to store its copy-on-write data depends on whether the snapshot is created by a user or used internally:\n• A database snapshot that is created by a user stores its data in one or more sparse files. Sparse file technology is a feature of the NTFS file system. At first, a sparse file contains no user data, and disk space for user data hasn't been allocated to the sparse file. For general information about the use of sparse files in database snapshots and how database snapshots grow, see View the Size of the Sparse File of a Database Snapshot.\n• Database snapshots are used internally by certain DBCC commands. These commands include , , , and . An internal database snapshot uses sparse alternate data streams of the original database files. Like sparse files, alternate data streams are a feature of the NTFS file system. The use of sparse alternate data streams allows for multiple data allocations to be associated with a single file or folder without affecting the file size or volume statistics.\n• The primary filegroup contains the primary data file and any secondary files that aren't put into other filegroups.\n• User-defined filegroups can be created to group data files together for administrative, data allocation, and placement purposes.\n\nFor example: , , and , can be created on three disk drives, respectively, and assigned to the filegroup . A table can then be created specifically on the filegroup . Queries for data from the table will be spread across the three disks; it will improve performance. The same performance improvement can be accomplished by using a single file created on a RAID (redundant array of independent disks) stripe set. However, files and filegroups let you easily add new files to new disks.\n\nAll data files are stored in the filegroups listed in the following table.\n\nWhen objects are created in the database without specifying which filegroup they belong to, they are assigned to the default filegroup. At any time, exactly one filegroup is designated as the default filegroup. The files in the default filegroup must be large enough to hold any new objects not allocated to other filegroups.\n\nThe PRIMARY filegroup is the default filegroup unless it is changed by using the ALTER DATABASE statement. Allocation for the system objects and tables remains within the PRIMARY filegroup, not the new default filegroup.\n\nFor more information on memory-optimized filegroups, see Memory Optimized Filegroup.\n\nFor more information on FILESTREAM filegroups, see FILESTREAM and Create a FILESTREAM-Enabled Database.\n\nThe following example creates a database on an instance of SQL Server. The database has a primary data file, a user-defined filegroup, and a log file. The primary data file is in the primary filegroup and the user-defined filegroup has two secondary data files. An statement makes the user-defined filegroup the default. A table is then created specifying the user-defined filegroup. (This example uses a generic path to avoid specifying a version of SQL Server.)\n\nThe following illustration summarizes the results of the previous example (except for the Filestream data).\n\nFilegroups use a proportional fill strategy across all the files within each filegroup. As data is written to the filegroup, the SQL Server Database Engine writes an amount proportional to the free space in the file to each file within the filegroup, instead of writing all the data to the first file until full. It then writes to the next file. For example, if file has 100 MB free and file has 200 MB free, one extent is given from file , two extents from file , and so on. In this way, both files become full at about the same time, and simple striping is achieved.\n\nFor example, a filegroup is made up of three files, all set to automatically grow. When space in all the files in the filegroup is exhausted, only the first file is expanded. When the first file is full and no more data can be written to the filegroup, the second file is expanded. When the second file is full and no more data can be written to the filegroup, the third file is expanded. If the third file becomes full and no more data can be written to the filegroup, the first file is expanded again, and so on.\n\nThe following rules pertain to files and filegroups:\n• A file or filegroup cannot be used by more than one database. For example, file and , which contain data and objects from the sales database, can't be used by any other database.\n• A file can be a member of only one filegroup.\n• Transaction log files are never part of any filegroups.\n\nRecommendations when working with files and filegroups:\n• Most databases will work well with a single data file and a single transaction log file.\n• If you use multiple data files, create a second filegroup for the additional file and make that filegroup the default filegroup. In this way, the primary file will contain only system tables and objects.\n• To maximize performance, create files or filegroups on different available disks as possible. Put objects that compete heavily for space in different filegroups.\n• Use filegroups to enable placement of objects on specific physical disks.\n• Put different tables used in the same join queries in different filegroups. This step will improve performance, because of parallel disk I/O searching for joined data.\n• Put heavily accessed tables and the nonclustered indexes that belong to those tables on different filegroups. Using different filegroups will improve performance, because of parallel I/O if the files are located on different physical disks.\n• Don't put the transaction log file(s) on the same physical disk that has the other files and filegroups.\n• If you need to extend a volume or partition on which database files reside using tools like Diskpart, you should back up all system and user databases and stop SQL Server services first. Also, once disk volumes are extended successfully, you should consider running command to ensure the physical integrity of all databases residing on the volume.\n\nFor more information on transaction log file management recommendations, see Manage the size of the transaction log file.\n• Manage the size of the transaction log file"
    },
    {
        "link": "https://netwrix.com/how_to_view_sql_server_database_properties.html",
        "document": ""
    },
    {
        "link": "https://mssqltips.com/sqlservertip/2008/sql-server-2008-system-functions-to-monitor-the-instance-database-files-etc",
        "document": "SQL Server provides several system meta data functions which allow users to obtain property values of different SQL Server objects and securables. Although you can also use the SQL Server catalog views or Dynamic Management Views to obtain much of this information, in some circumstances the system meta data functions simplify the process. In this tip I am going to demonstrate some of the available system meta data functions and their usage in different scenarios.\n\nSQL Server provides several system meta data functions to obtain property values of different object types. Each system meta data function has a set of property list values you can query using the system meta functions, for example:\n\nIn this tip, I am going to outline the some examples for the frequently used system meta data functions and their associated properties. Let’s jump right in.\n\nThe SERVERPROPERTY system meta data function provides different properties for the SQL Server instance. For example, to find out the edition of installed SQL Server you use ‘Edition’ property, to check if the SQL Server is in single user mode you use the ‘IsSingleUser’ property. Likewise to check if the SQL Server environment is clustered, you use ‘IsClustered’ property. Below is a script with the various properties of the SERVERPROPERTY system meta data function. For a complete list of the properties, click here.\n\nThe DATABASEPROPERTY and DATABASEPROPERTYEX system meta data functions return similar information, the difference is DATABASEPROPERTY has been marked for deprecation and hence the recommendation is to use the DATABASEPROPERTYEX system meta data function. DATABASEPROPERTYEX system meta data function provides a number of properties for a specific database. For example, to find out the recovery model of the database you use the ‘Recovery’ property, to check if the database is in read/write mode you use the ‘Updateability’ property, to check if the database is in ONLINE, OFFLINE, RESTORING, RECOVERING, SUSPECT, EMERGENCY, etc. state you use ‘Status’ property. Below is a sample script, with this system meta data function with a number of different property options. For complete list of properties, click here.\n\nThe FILEGROUPPROPERTY system meta data function provides information on a specific file group in the current database. For example, to find out if the file group is the default filegroup you, along with file group name, use the ‘IsDefault’ property. To check if the file group is in read only mode you use the ‘IsReadOnly’ property. To determine if the file group is a user defined file group you use the ‘IsUserDefinedFG’ property.\n\nThe FILEPROPERTY system meta data function provides information on the specified file in the current database. For example, to find out if the file is the primary file you use the ‘IsPrimary’ property. To check if the file is in read only mode you use the ‘IsReadOnly’ property. To check the number of pages in the given file you use the ‘SpaceUsed’ property. Check out the two scripts below as an example for each of these system meta data functions. For complete list of properties for the file group click here and for the file click here.\n\nSESSIONPROPERTY system meta function provides different properties option to grab SET options information for the current session whereas the CONNECTIONPROPERTY system meta function provides the different property options to grab connection property for the current connection. For example, using the SESSIONPROPERTY system meta data function you can get the set options for ANSI_NULLS, ARITHABORT, QUOTED_IDENTIFIER etc using respective property name, likewise using the CONNECTIONPROPERTY system meta data function you can get the protocol type used in the connection, authentication, etc. using the respective property name. For complete list of properties for session click here and for connection click here.\n• Test these scripts out in your environment and compare them to the catalog views and dynamic management views.\n• Stay tuned for a second part to this tip."
    },
    {
        "link": "https://stackoverflow.com/questions/24962255/how-can-i-make-use-of-a-db-file-in-sql-server-2008",
        "document": "If this is a one time load, the easiest option would be using the SQL Server Import and Export wizard from SSMS. You'll need a Sqlite ODBC driver. The one here should work.\n\nAnother option is to create a linked server to SQLite database from SQL Server. See this article for instructions.\n\nHere are a couple of StackOverflow posts on loading data from Sqlite to SQL Server which might be helpful.\n• None Import data from SQLite to SQL Server with SqlBulkCopy class"
    }
]