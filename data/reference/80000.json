[
    {
        "link": "https://jetbrains.com/help/idea/class-diagram.html",
        "document": "This functionality relies on the Diagrams plugin, which is bundled and enabled in IntelliJ IDEA by default. If the relevant features are not available, make sure that you did not disable the plugin.\n• None Press to open settings and then select Plugins.\n• None Open the Installed tab, find the Diagrams plugin, and select the checkbox next to the plugin name.\n\nIntelliJ IDEA lets you generate a diagram on a package in your project. Such diagrams always reflect the structure of actual classes and methods in your application.\n\nYou can press on the element to view a list of diagram elements and navigate between them. To see the list of methods, fields, and other code elements, select the appropriate icon on the diagram toolbar located on top of the diagram editor. The lists are displayed based on the selected visibility level, which you can change. For example, to view protected methods, click on the diagram toolbar and select protected from the list. IntelliJ IDEA displays members with visibility not less than protected, such as public, package local, and protected ones. The protected methods are displayed with modifier icons next to them. You can click the icon to see class dependencies. IntelliJ IDEA follows the UML conventions in showing relationships between the classes. When you click through classes in the graph, IntelliJ IDEA greys out classes that do not reside in the same package. This might be helpful, when you generate a diagram on a package that contains inner packages. To save the diagram as a file, right-click the diagram editor and from the context menu, select Export Diagram | Export to File and then the file extension in which you want to save the diagram.\n\nWhen working with diagrams, use the context menu in the diagram editor to perform different tasks. You can view members of the class, add new, delete the existing ones, see implementations, check parent classes, perform basic refactoring, add notes, and so on. You can select the icon on the diagram toolbar to draw relationship links between elements in your graph. To delete the existing links, select the ones you don't need and press . IntelliJ IDEA will update the source code accordingly.\n• None Click Structure in the left toolbar. IntelliJ IDEA opens the Structure tool window that displays a map of your diagram with a small preview of the selected block and its neighbors. Use the context menu to zoom in and out, move canvas, change layout, and export part of the diagram into an image.\n• None In the search field that opens, start typing a name of the class you want to add. Then, select the desired class from the suggestion list. If you want to add a class that is out of the project scope, select the Include non-project items checkbox. Alternatively, select one or more elements in the Project tool window and drag them to the diagram.\n• None In the diagram editor, select a node element you want to delete.\n• None Right-click the element and from the context menu, select Delete . Alternatively, select Refactor | Safe Delete . In this case, IntelliJ IDEA checks for usages before applying the changes. You can quickly search for usages by pressing on a code element. You can perform some forward engineering while in the diagram editor.\n• None In the diagram editor, right-click anywhere and from the context menu, select Content | New. Then select a code element you want to create.\n• None Depending on your selection, IntelliJ IDEA opens the appropriate dialog where you specify the necessary information for creating the new element. IntelliJ IDEA adds the item to your diagram as well as to your project tree . You can view implementations and parent classes in your diagram. If IntelliJ IDEA finds more than one parent class or implementation, it displays a list of appropriate items. Select the one you need to see the connections between the parent and its children.\n• None In the diagram editor, select an item for which you want to see implementations or parent classes.\n• None Right-click the items and from the context menu, select the Show Implementations or Show Parents respectively.\n• None In the popup that opens, select items you need and press . To extend your selection up or down while in the popup, press or respectively. You can configure the diagram settings so that you have certain options available by default when you create a diagram.\n• None Press to open settings and then select Tools | Diagrams.\n• None In the right-hand pane, select the options that you want to see by default and click OK to apply your changes.\n\nThe Analyze Graph action group lets you analyze the graph in various ways such as perform auto clusterization, measure the node centrality, search cycles, filter path between two nodes, and so on. Most of the time, generated diagrams are big and complicated. Typically, you want to concentrate only on the specific part of the diagram. IntelliJ IDEA lets you filter paths between two diagram elements.\n• None In the diagram editor, select two nodes on which you want to focus and right-click one of them to open the context menu.\n• None From the context menu, select Analyze Graph | Focus On Paths Between Two Nodes. If you want to focus not only on just two nodes, but on how the selected node is connected with its neighbors, select the Focus on Node Neighborhood option from the context menu.\n• None In the dialog that opens, select additional options if needed and click Find. IntelliJ IDEA displays connections associated only with the selected nodes. You can use this action to identify the important nodes in the graph.\n• None In the diagram editor, right-click anywhere in the editor to open the context menu.\n• None In the dialog that opens, select additional options if needed and click Measure. The node \"importance\" is expressed via fractional value from 0.0 to 1.0 measurement, and the brightest node selection should be explored first."
    },
    {
        "link": "https://jetbrains.com/help/objc/class-diagram.html",
        "document": "This functionality relies on the Diagrams plugin, which is bundled and enabled in AppCode by default. If the relevant features aren't available, make sure that you didn't disable the plugin.\n• None Press to open the IDE settings and select Plugins.\n• None Open the Installed tab, find the Diagrams plugin, and select the checkbox next to the plugin name.\n\nAppCode lets you generate UML diagrams for Objective-C and Swift. The diagrams help you analyze the structure of your application by showing types, their connections, methods, and fields.\n\nYou can use the UML Class diagram to evaluate how your local code changes affect the application.\n• None From the context menu of the code editor, the Project tool window, or the Local Changes view, select Show Local Changes as UML, or press . The diagram opens in a popup. You can double-click a node to view changes in a Differences viewer. To view changes in revisions as a UML Class diagram, in the History tab of the Version Control tool window, select the desired revision and select Show Diff as UML from the context menu or press .\n\nTo see the list of methods, fields, and other code elements, select the appropriate icon on the diagram toolbar located on top of the diagram editor. The lists are displayed based on the selected visibility level, which you can change. To save the diagram as a file, right-click the diagram editor and from the context menu, select Export Diagram | Export to File and then the file extension in which you want to save the diagram.\n\nWhen working with diagrams, use the context menu in the diagram editor to perform different tasks. You can view members of a type, delete types, see implementations, check parent types, and so on.\n• None To select an element, click it in diagram.\n• None To select multiple adjacent elements, keep pressed and click the desired elements, or just drag a lasso around the elements to be selected.\n• None To select multiple non-adjacent elements, keep pressed and click the desired elements.\n• None To select a class member, double-click the class element, and then use the arrow keys, or the mouse pointer.\n• None In the diagram editor, select a node element you want to delete.\n• None Right-click the element and from the context menu, select Delete . You can configure the diagram settings so that you have certain options available by default when you create a diagram.\n• None In the right-hand pane, select the options that you want to see by default and click OK to apply your changes.\n\nThe Analyze Graph action group lets you analyze the graph in various ways such as perform auto clusterization, measure the node centrality, search cycles, filter path between two nodes, and so on. Most of the time, generated diagrams are big and complicated. Typically, you want to concentrate only on the specific part of the diagram. AppCode lets you filter paths between two diagram elements.\n• None In the diagram editor, select two nodes on which you want to focus and right-click one of them to open the context menu.\n• None From the context menu, select Analyze Graph | Focus On Paths Between Two Nodes. If you want to focus not only on just two nodes, but on how the selected node is connected with its neighbors, select the Focus on Node Neighborhood option from the context menu.\n• None In the dialog that opens, select additional options if needed and click Find. AppCode displays connections associated only with the selected nodes. You can use this action to identify the important nodes in the graph.\n• None In the diagram editor, right-click anywhere in the editor to open the context menu.\n• None In the dialog that opens, select additional options if needed and click Measure. The node \"importance\" is expressed via fractional value from 0.0 to 1.0 measurement and the brightest node selection should be explored first."
    },
    {
        "link": "https://stackoverflow.com/questions/67781159/clion-how-to-generate-class-diagrams-from-c-source-code",
        "document": "I have used Visual Studio successfully to generate class diagrams from C++ source code. But I'm finding it hard to do the same in CLION. I used Settings / Preferences | Tools | Diagrams as per the JetBrains documentation, but it throws this error CLION diagrams error. \"The current file or folder does not have any dependencies. Please try with another file or folder\". But my source code is indeed having many dependencies.\n\nHow to generate class diagrams (UML or non UML) from C++ source in CLION?"
    },
    {
        "link": "https://stackoverflow.com/questions/405953/generating-uml-from-c-code",
        "document": "Here are a few options:\n\nStep-by-Step Guide to Reverse Engineering Code into UML Diagrams with Microsoft Visio 2000 - http://msdn.microsoft.com/en-us/library/aa140255(office.10).aspx\n\nReverse engineering of the UML class diagram from C++ code in presence of weakly typed containers (2001) - http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.9064\n\nA list of other tools to look at - http://plg.uwaterloo.ca/~migod/uml.html"
    },
    {
        "link": "https://github.com/bkryza/clang-uml",
        "document": "is an automatic C++ to UML class, sequence, package and include diagram generator, driven by YAML configuration files. The main idea behind the project is to easily maintain up-to-date diagrams within a code-base or document legacy code. The configuration file or files for define the types and contents of each generated diagram.\n\nThe diagrams can be generated in the following formats:\n\ncurrently supports C++ up to version 20, as well as C and Objective-C.\n\nFull documentation can be found at clang-uml.github.io.\n\nTo see what can do, check out the diagrams generated for unit test cases here, examples in clang-uml-examples repository or my blog.\n• Class diagram generation\n• Other class relationships including associations, aggregations, dependencies and friendship - example\n• Template specialization and instantiation based on deduced context - example\n• Relationship inference from C++ containers and smart pointers - example\n• Diagram content filtering based on namespaces, elements and relationships - example\n• Optional package generation from namespaces (only PlantUML) - example\n• Optional package generation from subdirectories (only PlantUML) - example\n• Optional package generation from C++20 modules (only PlantUML) - example\n• Interactive links to online code or docs for classes, methods and class fields in SVG diagrams - example\n• Support for plain C99/C11 code (struct, units and their relationships) - example\n• Sequence diagram generation\n• Generation of sequence diagram from specific method or function - example\n• Generation of loop and conditional statements - example\n• Interactive links to online code to classes and call expressions - example\n• Support for CUDA Kernel and CUDA Device function calls - example\n• Package diagram generation\n• Generation of package diagram based on C++ namespaces - example\n• Generation of package diagram based on subdirectories - example\n• Generation of package diagram based on C++20 modules - example\n• Dependencies between packages based on symbols used in the code - example\n• Interactive links to online code to packages - example\n\nMore comprehensive documentation can be at clang-uml.github.io.\n\nInstallation instructions for , and can be found here.\n\nrequires an up-to-date compile_commands.json file, containing the list of commands used for compiling the source code or alternatively a list of compilation flags in a file called (see here.\n\nSee also here for instructions on how to generate using some of the existing C++ build systems.\n\nBy default, will assume that the configuration file and compilation database files are in the current directory, so if they are in the top level directory of a project, simply run:\n\nThe output path for diagrams, as well as alternative location of compilation database can be specified in configuration file or through command line parameters.\n\nFor other options see help:\n\nConfiguration files are written in YAML, and provide definition of diagrams which should be generated by . Basic example is as follows:\n\nSee here for detailed configuration file reference guide.\n\nTo see what can do, browse the test cases documentation here.\n\nIn order to see diagrams for the itself, based on its own config run the following:\n\nand open the SVG diagrams in folder.\n\nThe following C++ code:\n\nresults in the following diagram (via PlantUML):\n\nThe following C++ code:\n\nresults in the following diagram (via PlantUML):\n\nThe following C++ code:\n\nresults in the following diagram (via PlantUML):\n\nThe following C++ code structure:\n\nresults in the following diagram (via PlantUML) based on include directives in the code:\n\nFor typical code bases, a single diagram generated from an entire code or even a single namespace can be too big to be useful, e.g. as part of documentation. allows specifying content to be included and excluded from each diagram using simple YAML configuration:\n\nMore details on this can be found in the diagram filters documentation section.\n\nThe build-in test cases used for unit testing of the , can be browsed here.\n\nThis project relies on the following great tools:\n• Clang LibTooling - a C++ library for creating tools based on Clang\n• pugixml - XML parser for C++ with XPath support\n\nIf you would like to contribute to the project, please check out contributing guidelines."
    },
    {
        "link": "https://jetbrains.com/help/clion/clion-quick-start-guide.html",
        "document": "The quickest way to switch between the IDE's color schemes, code styles, keymaps, viewing modes, and look-and-feels (UI themes) is the Switch... pop-up. To invoke it, click View | Quick Switch Scheme or press : To explore all the customizable options, go to the dedicated pages in Settings . Pages under the Editor node of the Settings dialog help you adjust the editor’s behavior, from the most general settings (like Drag'n'Drop enabling and scroll configuration) to highlighting colors and code style options. Code styles are configurable for each language separately in the pages under the Editor | Code Style node. For C/C++, you can set one of the predefined code styles or provide your own, and configure the desired naming convention including the header guard template: In CLion, almost every action possible in the IDE is mapped to a keyboard shortcut. To view the default mapping, call Help | Keyboard Shortcuts PDF. You can customize the shortcuts in Settings| Keymap. Use one of the predefined keymaps (Visual Studio, Emacs, Eclipse, NetBeans, Xcode, and others) and tune it as required, or create your own keymap from scratch. There are also plugins that extend the list of available keymaps. For example, VS Code Keymap or Vim emulation (which includes the Vim keymap). Find more useful plugins for the CLion editor in Valuable non-bundled plugins.\n\nCompletion in CLion works as you type and gives a list of all available completions. To filter this list and see only the suggestions that match the expected type, use Smart completion : Completion, along with other code insight features, is available for CMake code as well. See Coding assistance in CMakeLists.txt. Even an empty class or a new C/C++ file contains boilerplate code, which CLion generates automatically. For example, when you add a new class, CLion creates a header with stub code and header guard already placed inside, and the corresponding source file that includes it. One of the most useful code generation features is create from usage. It helps you focus on the ideas as they come up and takes care of the routine. For example, when you call a function that is not yet implemented, there is no need to break the flow: press to generate stub code that you can come back to later. Create from usage works for variables and classes as well: To get the list of code generation options at any place in your code, press to invoke the Generate menu: These options can help you skip a lot of code writing. In addition to generating constructors/destructors, getters/setters, and various operators, you can quickly override and implement functions: Live templates are the tool to generate entire code constructs. Find the list of ready-to-use templates in Settings | Editor | Live Templates. To paste a template in your code, call Code | Insert Live Template or press , for example: To quickly surround your code with loops and conditional statements like , , , , call Code | Surround With or press : When you see a light bulb next to a symbol in your code, it means that CLion's code analysis has found a potential problem or a possible change to be made:\n• None indicates an error and lets you choose a quick fix for it,\n• None indicates that one or several intention actions are available. Click the light bulb icon (or press ) and choose the most suitable action or quick-fix: During on-the-fly code analysis, CLion highlights suspicious code and shows colored stripes in the right-hand gutter. You can hover over a stripe to view the problem description and click it to jump to the corresponding issue. The sign at the top of the gutter indicates the overall file status: CLion detects not only compilation errors but also code inefficiencies like unused variables or dead code. Also, it integrates a customizable set of Clang-tidy checks. To enable or disable inspections, configure their severity levels (whether an inspection should raise an error or just be shown as a warning) and set the scopes, go to Settings | Editor | Inspections. You can also run inspections on demand for the whole project or a custom scope, and view the results in a separate window. For this, call Code | Inspect Code or use Code | Analyze Code | Run Inspection by Name for a particular inspection. From the results tool window, you can batch-apply quick fixes for several issues at a time. Click Fix partially in the description tab: For more information, refer to the Static code analysis section. Refactorings help improve your code without adding new functionality, making it cleaner and easier to read and maintain. Use the Refactor section of the main menu or call Refactor This... to get the list of refactorings available at the current location:\n• None Change Signature adds, removes, or reorders function parameters, changes the return type, or updates the function name (affecting all usages);\n• None Pull Members Up/Down (Refactor | Pull Members Up / Push Members Down) safely moves class members to the base or subclass.\n\nTo search for anything in CLion, be it an item in your codebase, action, or UI element, press twice and start typing what you are looking for in the Search Everywhere dialog. Use the filter menu to narrow your search: To locate the usage of any code symbol, call Find Usages ( or Edit | Find | Find Usages). You can filter the results and jump back to the source code: For your code, CLion builds the hierarchies of types, call, imports, and functions. To view them, use the shortcuts given above or the commands in the Navigate menu. For example, type hierarchy helps you not only to navigate the code but also to discover what type relationships exist in the your codebase: To explore the structure of the currently opened file, call View | Tool windows | Structure or press : Also, use the left gutter icons to quickly jump to a declaration/definition or navigate through the class hierarchy ( / , / ). Quick Documentation popup (available on mousehover or via the shortcut) helps you get more information on a symbol at caret without leaving the current context. Depending on the element you invoke it for, the popup shows: Besides, you can instantly view the definition of a symbol at caret. Press to invoke the Quick Definition popup:\n\nIf you have only one or two files to compile and run, there is no need for you to get into project models: your files can be compiled and run/debug without it.\n• None In the editor, click the left gutter icon next to your program's entry point and select the action: For more information, refer to Run/debug single file. For each target in your project, CLion creates a run/debug configuration. It is a named setup which includes target, executable, arguments to pass to the program, and other options. Run/Debug configurations are generated from templates, such as CMake Application, Google Test, Remote GDB Debug, and so on. The templates are customizable: when you edit a template parameter, you change the default settings of all configurations that will be created from this template later. Edit Configurations dialog is accessible from the Run menu or the configuration switcher. Here you can manage the templates and add, delete, or edit your configurations. For example, you can customize the steps to be taken Before launch: call external tools (including the remote ones), use CMake install, or even run another configuration. To launch your program, select the desired configuration and use commands from the Run menu or press . Alternatively, invoke the Run Anything dialog by pressing twice and start typing the configuration name: Hold down to switch to Debug Anything. Build is included in many Run/Debug configuration templates as a default pre-launch step. However, you can also perform it separately by calling the desired action from the Build menu: Notice the Recompile option that compiles a selected file without building the whole project. With CLion, you can also build and run/debug on remote machines including embedded targets. See the sections on Remote development and Embedded development.\n\nSome vulnerabilities and bugs can only be revealed during the program's execution: memory leaks, uninitialized accesses, concurrency issues, undefined behavior, and others. To help you catch run-time problems, CLion integrates Valgrind Memcheck and Google Sanitizers. Also, you can analyze your application performance using the built-in CPU Profiler and measure code coverage. For these tools, CLion provides visualized output and handy features like the option to import/export analysis results. Settings for Valgrind, Sanitizers, and Profile are located under Settings | Build, Execution, Deployment | Dynamic Analysis Tools. For more information, refer to the section about Dynamic code analysis. Valgrind Memcheck in CLion works on Linux, macOS, and Windows via WSL. You need to install Valgrind, point CLion to the binary, set up the analysis flags, and then run the program using Run | Run Valgrind Memcheck or by pressing . Google Sanitizers are supported on Linux for certain versions of Clang and GCC. Take a look at our detailed guide on using Sanitizers in CLion. CLion’s profiler, available on Linux and macOS, collects performance data for both user and kernel code of your application. The profiler collects performance metrics and visualizes them in flame charts and statistic views. To run it, call Run | Profile or use the button. Code Coverage integration in CLion is based on llvm-cov/gcov tools and is available for CMake applications and tests. Coverage results show the percentage of files per folder and lines per file covered during a launch. To get coverage measurements, set the necessary compiler flags and call Run with Coverage or click .\n\nCLion supports Google Test, Boost.Test, Catch(2), CTest, and Doctest testing frameworks with the built-in test runner and dedicated Run/Debug configurations. For CMake targets linked with gtest or gmock, CLion creates Google Test configurations automatically. Running tests is similar to running a regular executable: CLion passes the specified test classes or methods to the test runner. Test runner shows the progress bar, output stream, and tree view of the running tests, and indicates their status and duration: You can rerun particular tests, all of them, or only the failed ones , export test results and open previous results from the history. Icons in the left gutter help you quickly run/debug tests and check the test status, success or failure :\n\n10. Keep it under version control CLion integrates with several version control systems: Git (or GitHub), Mercurial, Perforce, and Subversion. To manage the settings of a particular VCS, go to Settings | Version Control. Use the VCS Operations Popup ( or VCS | VCS Operations Popup) to call version control commands. The list of actions in this popup includes both the currently enabled VCS and local history. For example: You can find all the available VCS commands in the VCS section of the main menu. Also, some basic commands are accessible from the toolbar: CLion toolbar is customizable, see Quickly add actions to the toolbar In addition to full version control, you can go back and review changes step by step by browsing the local history. To view it for a file or folder, call File | Local History | Show Local History. Here you can revert changes and create patches:\n\nWe hope this brief overview of the CLion essentials will give you a quick start. To dig deeper, take a look at other articles and sections in the webhelp, for example:\n\nFor news and useful tips, check our twitter and CLion blog.\n\nFeel free to ask any questions on the community forum and don't hesitate to report problems in the CLion issue tracker."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/3vo0tu/visualizing_a_c_project",
        "document": "I've come across the code for an open source game written in C++ that I want work on. Unfortunately, there is little documentation and I'm new to working with c++ (although I'm a software developer.)\n\nDoes anyone know of any tools that I can use to map the relationships between files - or just visualize the project somehow? I noticed there's a visual studio project file in the source code, which I am looking into now, but I don't see any relationships in the file.\n\nAny help would be greatly appreciated."
    },
    {
        "link": "https://stackoverflow.com/questions/30100384/clion-debug-into-cpp-class",
        "document": "I want to debug a C++ programm with Clion, my debugger works when I put a breakpoint into the main's class but if I put a breakpoint into a class, gdb doesn't stop the running program when we have to enter into a function of this class from the main's class.\n\nI don't really know why :/ Is it a normal feature ?"
    },
    {
        "link": "https://app.studyraid.com/en/read/12310/397202/dependency-graph-visualization-tools",
        "document": "Dependency graphs represent relationships between software components. In C++, these components include classes, functions, variables, and namespaces. A node in the graph represents an entity, while an edge indicates a dependency (e.g., directives, method calls, or template instantiations).\n• Cycle Identification: Circular references create loops in the dependency graph, which visualization tools render as cyclic paths.\n• Strongly Connected Components: Subgraphs where every node is reachable from every other node.\n\nThis lesson provides the technical foundation to implement and interpret dependency graphs for cycle analysis in C++ projects. Use these tools proactively during code reviews and architectural design phases to maintain circular-dependency-free codebases."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/md0nxr/visual_studio_or_clion",
        "document": "Hello! At the moment I am using Code::Blocks and I don't know what IDE to install for C++. I am a student so I can take Clion for free"
    }
]