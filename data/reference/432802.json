[
    {
        "link": "https://github.com/hikari-py/hikari",
        "document": "An opinionated, static typed Discord microframework for Python3 and asyncio that supports Discord's v10 REST and Gateway APIs.\n\nBuilt on good intentions and the hope that it will be extendable and reusable, rather than an obstacle for future development.\n\nPython 3.9, 3.10, 3.11, 3.12 and 3.13 are currently supported.\n\nInstall hikari from PyPI with the following command:\n\nHikari provides two different default bot implementations to suit your needs:\n\nA is one which will connect to Discord through the gateway and receive events through there. A simple startup example could be the following:\n\nThis will only respond to messages created in guilds. You can use instead to only listen on DMs, or to listen to both DMs and guild-based messages. A full list of events can be found in the events docs.\n\nIf you wish to customize the intents being used in order to change which events your bot is notified about, then you can pass the kwarg to the constructor:\n\nThe above example would enable all intents, thus enabling events relating to member presences to be received (you'd need to whitelist your application first to be able to start the bot if you do this).\n\nEvents are determined by the type annotation on the event parameter, or alternatively as a type passed to the decorator, if you do not want to use type hints.\n\nA spawns an interaction server to which Discord will only send interaction events, which can be handled and responded to.\n\nAn example of a simple could be the following:\n\n# This function will handle the interactions received ( : . ): # Create an initial response to be able to take longer to respond . () . ( ) . ( ) # Note that this is not a nice way to manage this, as it is quite spammy # to do it every time the bot is started. You can either use a command handler # or only run this code in a script using `RESTApp` or add checks to not update # the commands if there were no changes ( : . ): . . () . . ( . , [ . . ( , ), ], ) . ( , , , ) . ( ) . ( . , ) . ()\n\nUnlike , registering listeners is done through , and it takes in an interaction type that the handler will take in.\n\nNote that a bit of a setup is required to get the above code to work. You will need to host the project to the World Wide Web (scary!) and then register the URL on the Discord application portal for your application under \"Interactions Endpoint URL\".\n\nA quick way you can get your bot onto the internet and reachable by Discord (for development environment only) is through a tool like ngrok or localhost.run. More information on how to use them can be found in their respective websites.\n\nBoth implementations take in helpful arguments such as customizing timeouts for requests and enabling a proxy, which are passed directly into the bot during initialization.\n\nAlso note that you could pass extra options to during development, for example:\n\nMany other helpful options exist for you to take advantage of if you wish. Links to the respective docs can be seen below:\n\nYou may only want to integrate with the REST API, for example if writing a web dashboard.\n\nThis is relatively simple to do:\n\nOptional features can be specified when installing hikari:\n\nYou may wish to use a command framework on top of hikari so that you can start writing a bot quickly without implementing your own command handler.\n\nHikari does not include a command framework by default, so you will want to pick a third party library to do it:\n• - a simple and easy to use command framework for hikari.\n• - a command handler for hikari that keeps your project neat and tidy.\n• - a bot framework with a focus on type-safety and correctness.\n\nThere are also third party libraries to help you manage components:\n• - A collection of utility classes and functions designed to expand Hikari.\n\nAs your application scales, you may need to adjust some things to keep it performing nicely.\n\nCPython provides two optimization flags that remove internal safety checks that are useful for development, and change other internal settings in the interpreter.\n• - no optimization - this is the default.\n• - first level optimization - features such as internal assertions will be disabled.\n• - second level optimization - more features (including all docstrings) will be removed from the loaded code at runtime.\n\nA minimum of first level of optimization is recommended when running bots in a production environment.\n\nIf you have a C compiler (Microsoft VC++ Redistributable 14.0 or newer, or a modern copy of GCC/G++, Clang, etc), it is recommended you install Hikari using . This will install with its available speedups, and which will provide you with a substantial performance boost.\n\nIf you use a UNIX-like system, you will get additional performance benefits from using a library called . This replaces the default event loop with one that uses internally. You can run and then amend your script to be something similar to the following example to utilise it in your application:\n\nEventually, we will start providing the option to use compiled components of this library over pure Python ones if it suits your use case. This should also enable further scalability of your application, should PEP 554 -- Multiple Interpreters in the Stdlib be accepted.\n\nCurrently, this functionality does not yet exist.\n\nTo familiarize yourself with the project, you should read our contributing manual.\n\nIf you wish to contribute something, you should first start by cloning the repository.\n\nThe first thing you should run is to install nox. This handles running predefined tasks and pipelines.\n\nOnce this is complete, you can run without any arguments to ensure everything builds and is correct.\n\nCheck out the issues tab on GitHub. If you are nervous, look for issues marked as \"good first issue\" for something easy to start with!\n\nFeel free to also join our Discord to directly ask questions to the maintainers! They will be glad to help you out and point you in the right direction."
    },
    {
        "link": "https://hikari-py.dev",
        "document": "This API is still in an alpha state, and is a work in progress! Features may change or undergo improvements before the design is finalized. Until then, why not join our Discord? Feel free to drop in to ask questions, get updates on progress, and be able to provide valuable contributions and feedback.\n\nTutorials, tips, and additional resources will come soon!"
    },
    {
        "link": "https://reddit.com/r/Python/comments/pzossa/build_a_discord_bot_with_python_hikari_tanjun",
        "document": "The official Python community for Reddit! Stay up to date with the latest news, packages, and meta information relating to the Python programming language. --- If you have questions or are new to Python use r/LearnPython"
    },
    {
        "link": "https://patchwork.systems/programming/hikari-discord-bot/index.html",
        "document": "Discord.py archived so it's time to find a new Discord Bot library for Python! We searched for a few weeks and reviewed multiple projects. By the end Hikari and Tanjun looked most promising to us.\n\nThis series will start from scratch and slowly build a Discord Bot all while teaching you the libraries!\n• Part 1: Introduction & Index [You are Here]\n\nAll of the code and snippets you see in this series are stored in the above Gitlab. All code is licensed under GPLv2.\n\nOur personal Discord Bot build in Hikari/Tanjun. Many components and plugins from this series were started here. More hikari and tanjun code examples at least! GPLv2.\n\nIf you need more help with Hikari, Tanjun or Lightbulb the support server is great! The devs and community are incredibly friendly."
    },
    {
        "link": "https://docs.hikari-py.dev",
        "document": "An opinionated, static typed Discord microframework for Python3 and asyncio that supports Discord's v10 REST and Gateway APIs.\n\nBuilt on good intentions and the hope that it will be extendable and reusable, rather than an obstacle for future development.\n\nPython 3.9, 3.10, 3.11, 3.12 and 3.13 are currently supported.\n\nInstall hikari from PyPI with the following command:\n\nHikari provides two different default bot implementations to suit your needs:\n\nA is one which will connect to Discord through the gateway and receive events through there. A simple startup example could be the following:\n\nThis will only respond to messages created in guilds. You can use instead to only listen on DMs, or to listen to both DMs and guild-based messages. A full list of events can be found in the events docs.\n\nIf you wish to customize the intents being used in order to change which events your bot is notified about, then you can pass the kwarg to the constructor:\n\nThe above example would enable all intents, thus enabling events relating to member presences to be received (you'd need to whitelist your application first to be able to start the bot if you do this).\n\nEvents are determined by the type annotation on the event parameter, or alternatively as a type passed to the decorator, if you do not want to use type hints.\n\nA spawns an interaction server to which Discord will only send interaction events, which can be handled and responded to.\n\nAn example of a simple could be the following:\n\n# This function will handle the interactions received # Create an initial response to be able to take longer to respond # Note that this is not a nice way to manage this, as it is quite spammy # to do it every time the bot is started. You can either use a command handler # or only run this code in a script using `RESTApp` or add checks to not update # the commands if there were no changes\n\nUnlike , registering listeners is done through , and it takes in an interaction type that the handler will take in.\n\nNote that a bit of a setup is required to get the above code to work. You will need to host the project to the World Wide Web (scary!) and then register the URL on the Discord application portal for your application under \"Interactions Endpoint URL\".\n\nA quick way you can get your bot onto the internet and reachable by Discord (for development environment only) is through a tool like ngrok or localhost.run. More information on how to use them can be found in their respective websites.\n\nBoth implementations take in helpful arguments such as customizing timeouts for requests and enabling a proxy, which are passed directly into the bot during initialization.\n\nAlso note that you could pass extra options to during development, for example:\n\nMany other helpful options exist for you to take advantage of if you wish. Links to the respective docs can be seen below:\n\nYou may only want to integrate with the REST API, for example if writing a web dashboard.\n\nThis is relatively simple to do:\n\nOptional features can be specified when installing hikari:\n\nYou may wish to use a command framework on top of hikari so that you can start writing a bot quickly without implementing your own command handler.\n\nHikari does not include a command framework by default, so you will want to pick a third party library to do it:\n• - a simple and easy to use command framework for hikari.\n• - a command handler for hikari that keeps your project neat and tidy.\n• - a bot framework with a focus on type-safety and correctness.\n\nThere are also third party libraries to help you manage components:\n• - A collection of utility classes and functions designed to expand Hikari.\n\nAs your application scales, you may need to adjust some things to keep it performing nicely.\n\nCPython provides two optimization flags that remove internal safety checks that are useful for development, and change other internal settings in the interpreter.\n• - no optimization - this is the default.\n• - first level optimization - features such as internal assertions will be disabled.\n• - second level optimization - more features (including all docstrings) will be removed from the loaded code at runtime.\n\nA minimum of first level of optimization is recommended when running bots in a production environment.\n\nIf you have a C compiler (Microsoft VC++ Redistributable 14.0 or newer, or a modern copy of GCC/G++, Clang, etc), it is recommended you install Hikari using . This will install with its available speedups, and which will provide you with a substantial performance boost.\n\nIf you use a UNIX-like system, you will get additional performance benefits from using a library called . This replaces the default event loop with one that uses internally. You can run and then amend your script to be something similar to the following example to utilise it in your application:\n\nEventually, we will start providing the option to use compiled components of this library over pure Python ones if it suits your use case. This should also enable further scalability of your application, should PEP 554 -- Multiple Interpreters in the Stdlib be accepted.\n\nCurrently, this functionality does not yet exist.\n\nTo familiarize yourself with the project, you should read our contributing manual.\n\nIf you wish to contribute something, you should first start by cloning the repository.\n\nThe first thing you should run is to install nox. This handles running predefined tasks and pipelines.\n\nOnce this is complete, you can run without any arguments to ensure everything builds and is correct.\n\nCheck out the issues tab on GitHub. If you are nervous, look for issues marked as \"good first issue\" for something easy to start with!\n\nFeel free to also join our Discord to directly ask questions to the maintainers! They will be glad to help you out and point you in the right direction."
    },
    {
        "link": "https://github.com/tandemdude/hikari-lightbulb",
        "document": "Lightbulb is designed to be an easy-to-use command handler library that integrates with the Discord API wrapper library for Python, Hikari.\n\nThis library aims to make it simple for you to make your own Discord bots and provide all the utilities and functions you need to help make this job easier.\n\nUse the package manager pip to install Lightbulb.\n\n. ( ) . ( ) # Ensure the client starts once the bot is run . ( . , . ) # Register the command with the client ( . , , , ): # Define the command's invocation method. This method must take the context as the first # argument (excluding self) which contains information about the command invocation. ( , : . ) : # Send a message to the channel the command was used in . ( ) # Note that this is blocking meaning no code after this line will run # until the bot is shut off . ()\n\nIf you find any bugs, issues, or unexpected behaviour while using the library, you should open an issue with details of the problem and how to reproduce if possible. Please also open an issue for any new features you would like to see added.\n\nPull requests are welcome. For major changes, please open an issue/discussion first to discuss what you would like to change.\n\nPlease try to ensure that documentation is updated if you add any features accessible through the public API.\n\nIf you use this library and like it, feel free to sign up to GitHub and star the project, it is greatly appreciated and lets me know that I'm going in the right direction!\n\nLightbulb now has a plugin for IntelliJ-based IDEs (IntelliJ, Pycharm, etc) to help improve the developer experience by providing autocompletion and type checking not yet supported by other tools. More features such as command boilerplate generation and further code inspections are planned.\n\nYou can install the plugin from the Jetbrains Marketplace within your IDE. View the plugin here."
    },
    {
        "link": "https://hikari-lightbulb.readthedocs.io",
        "document": "Lightbulb is a command handler library designed for use with Hikari\n\nIt aims to provide an easy to use interface for building commands with your bot.\n\nIf you need any help with this library or hikari at any point feel free to join the Discord Server\n\nIf you think you have found a bug or other problem with the library, or you would like to suggest a feature, you should submit an issue on the GitHub repository here. Before doing so you should make sure you are on the latest version of the library and check to see if an issue already exists for your bug or feature.\n\nAlso see Tanjun if you would prefer different command handler syntax. I recommend taking a look at both Lightbulb and Tanjun before choosing which one you wish to use for your bot."
    },
    {
        "link": "https://hikari-lightbulb.readthedocs.io/en/latest",
        "document": "Lightbulb is a command handler library designed for use with Hikari.\n\nIt aims to provide an easy-to-use interface for building commands with your bot.\n\nIf you need any help with this library or Hikari at any point feel free to join the Discord Server\n\nIf you think you have found a bug or other problem with the library, or you would like to suggest a feature, you should submit an issue on the GitHub repository here. Before doing so you should make sure you are on the latest version of the library and check to see if an issue already exists for your bug or feature."
    },
    {
        "link": "https://docs.hikari-py.dev/en/2.0.0.dev122",
        "document": "An opinionated, static typed Discord microframework for Python3 and asyncio that supports Discord’s v10 REST and Gateway APIs.\n\nBuilt on good intentions and the hope that it will be extendable and reusable, rather than an obstacle for future development.\n\nPython 3.8, 3.9, 3.10, 3.11 and 3.12 are currently supported.\n\nHikari provides two different default bot implementations to suit your needs: A is one which will connect to Discord through the gateway and receive events through there. A simple startup example could be the following: \"\"\"If a non-bot user mentions your bot, respond with 'Pong!'.\"\"\" # Do not respond to bots nor webhooks pinging us, only user accounts This will only respond to messages created in guilds. You can use instead to only listen on DMs, or to listen to both DMs and guild-based messages. A full list of events can be found in the events docs. If you wish to customize the intents being used in order to change which events your bot is notified about, then you can pass the kwarg to the constructor: # the default is to enable all unprivileged intents (all events that do not target the The above example would enable all intents, thus enabling events relating to member presences to be received (you’d need to whitelist your application first to be able to start the bot if you do this). Events are determined by the type annotation on the event parameter, or alternatively as a type passed to the decorator, if you do not want to use type hints. A spawns an interaction server to which Discord will only send interaction events, which can be handled and responded to. An example of a simple could be the following: # This function will handle the interactions received # Create an initial response to be able to take longer to respond # Note that this is not a nice way to manage this, as it is quite spammy # to do it every time the bot is started. You can either use a command handler # or only run this code in a script using `RESTApp` or add checks to not update # the commands if there were no changes Unlike , registering listeners is done through , and it takes in an interaction type that the handler will take in. Note that a bit of a setup is required to get the above code to work. You will need to host the project to the World Wide Web (scary!) and then register the URL on the Discord application portal for your application under “Interactions Endpoint URL”. A quick way you can get your bot onto the internet and reachable by Discord (for development environment only) is through a tool like ngrok or localhost.run. More information on how to use them can be found in their respective websites. Both implementations take in helpful arguments such as customizing timeouts for requests and enabling a proxy, which are passed directly into the bot during initialization. Also note that you could pass extra options to during development, for example: # Any OS interrupts get rethrown as errors. Many other helpful options exist for you to take advantage of if you wish. Links to the respective docs can be seen below:\n\nYou may only want to integrate with the REST API, for example if writing a web dashboard. This is relatively simple to do: # We acquire a client with a given token. This allows one REST app instance # with one internal connection pool to be reused.\n\nYou may wish to use a command framework on top of Hikari so that you can start writing a bot quickly without implementing your own command handler. Hikari does not include a command framework by default, so you will want to pick a third party library to do it:\n• None - a simple and easy to use command framework for Hikari.\n• None - a command handler for Hikari that keeps your project neat and tidy.\n\nAs your application scales, you may need to adjust some things to keep it performing nicely. CPython provides two optimization flags that remove internal safety checks that are useful for development, and change other internal settings in the interpreter.\n• None - no optimization - this is the default.\n• None - first level optimization - features such as internal assertions will be disabled.\n• None - second level optimization - more features (including all docstrings) will be removed from the loaded code at runtime. A minimum of first level of optimization is recommended when running bots in a production environment. If you have a C compiler (Microsoft VC++ Redistributable 14.0 or newer, or a modern copy of GCC/G++, Clang, etc), it is recommended you install Hikari using . This will install with its available speedups, and which will provide you with a substantial performance boost. If you use a UNIX-like system, you will get additional performance benefits from using a library called . This replaces the default event loop with one that uses internally. You can run and then amend your script to be something similar to the following example to utilise it in your application: Eventually, we will start providing the option to use compiled components of this library over pure Python ones if it suits your use case. This should also enable further scalability of your application, should PEP 554 – Multiple Interpreters in the Stdlib be accepted. Currently, this functionality does not yet exist."
    },
    {
        "link": "https://reddit.com/r/Discord_Bots/comments/t1ym6u/opinion_on_discord_python_wrappers_analysis",
        "document": "Let me start with this - I am no professional Discord bot developer.\n\nThis whole analysis is my personal opinion. I've spent one day putting this together. If you feel like I've done some library unjustice, please feel free to share your viewpoint. However, I would like to STRONGLY ASK, that if you are going to advocate for a library, also justify your opinion.\n\nI like using xyz, because a friend recommended it to me, and I had no problem using it for my needs (moderation bot).\n\nSo, I want you to be able to make your own opinion on this post. For that, I feel like I need to share, who I am, and my experience level.\n\nI am an Informatics University student. I have been using (and learning) Python (among other languages) for the past 5 or 6 years. I have worked on multiple programming projects, from algorithms, through machine learning and neural networks to data science, through automation, bots and tech art.\n\nI have used Discord.py for a few projects (nothing crazy, just trying it out mostly), which is why my opinion will likely favor similar libraries (or straight up forks).\n\nThese are the libraries I deemed have not enough activity to look into them. They might be good, I didn't check at all, but I think the lack of activity could be an issue - new features coming later (if ever), bug fixes taking longer, etc etc\n\nI couldn't be bothered to check the libraries and categorize them again, so instead I'll write why I've discarded each library.\n\nSmall - this library doesn't have many contributors, just a few people doing all the work. Again, it might be good, but if a library has multiple contributors, bugs are caught faster, and the main contributor is better curated.\n\nNo users, small (same as hata). When you include a with the libraries you are using, and you upload your project to GitHub, it will connect it to the libraries, and display: Used by: 123. Novus doesn't have any public users, and just 12 closed Pull requests - indicating no community engagement.\n\nMultiple reverts in the last couple of commits, ignoring GitHub checks (this has been an issue for the past month or so).\n\nEdit: this doesn't seem to be the case anymore (one month later), so good job!\n\nOtherwise, this seems like a solid library, has multiple contributors (if you subtract the 270 that were added by forking discord.py), it's currently used by 482 public repositories, pull requests are getting resolved.\n\npycord, the elephant in the room\n\nThis might be controversial, but I don't think it's the best option available. (I probably wouldn't have looked this much into it, but thanks to u/baby_blue_highs comment, I did). The early adaptation from the discord.py fork were done by a 16 year old. I'm not saying, you can't be a good developer at 16, you absolutely can be, but I don't think a 16-year old makes a good large project manager.\n\nThis experience comes from working on such a project under someone, that has the experience, and can teach you about it.\n\nMore issues with pycord - checks are wildly ignored. Looking through the commit history, at least half of them are not successful. Well then, why bother with adding automatic checks, if you ignore them?\n\nThis early developer also left the project a couple of months ago (doesn't sound like a good sign).\n\nAs I said multiple times, the libraries mentioned above could very well be solid and feature-rich, but they are showing some red flags. Once more, this analysis was done purely by looking through the public repository, and I didn't personally try any of the above-mentioned libraries.\n\nThe libraries that I am left with are:\n\nThese libraries seem to have strong solid core and good community support. Now, it's time to test, how good and friendly they are, if they have good documentation or examples, and activity on stackoverflow.\n\nNone of these libraries have designated stackoverflow tags, which is alarming at first, but I'll have to see for myself, as other tags might be used instead.\n\nTo determine, which of these libraries is solid and easy to use, I have decided to code a bot in each one of them. These tests are available at my repo.\n\nI am using Python 3.10 with pip, on windows 11.\n\nStarting with this library. Their guide page is great to setup a bot, and very clear link\n\nWhat I've noticed - sometimes, it takes longer to stop the bot with keyboard interrupt (^c). For this reason, I wanted to create a custom command, to stop the bot - so I could restart it quicker, but wasn't able to find a method for this.\n\nAfter a couple of restarts, I started getting per-route ratelimits, so I had to wait even longer.\n\nWhen I tried searching for this method (to stop the bot), I didn't get any direct answers (one link was leading to discord interactions (not this library), others to discord.py). This doesn't seem to be a problem though, as their API documentation is nice and clear link.\n\nTried implementing multiple rows of buttons, but wasn't really able to find anything documenting this (just that there is a limit of 5). I could possibly figure it out somehow, but it's definitely not that clear.\n\nTried implementing embeds, but I ran into some issues again. Could probably figure it out after quite some time, but again, not very beginner friendly.\n\nIt's possible to edit and remove messages, if you have their class. I assume you could get a message by ID somehow, but I'm not going to spend next couple of hours finding it.\n\nSame with the recurring events - the library uses library, so it should be possible.\n\nFeature rich library, solid documentation, but virtually no questions support. They have their own discord server link, where you can probably get answers, but I don't think this is the way to go (compared to stackoverflow).\n\nCan't believe I'd mention this as a feature, but the bot is immediatelly interrupted when when issuing ^c.\n\nThey have very nice examples, but I found that some if it doesn't work? Like the command, where it's supposed to check for a subcommand, but it doesn't really work for me.\n\nI found their button implementation a lot cleaner, than the interacions-py one. This one is using decorators instead of string linking the functions, which is a lot nicer.\n\nRecurring events can be added as well.\n\nOverall, I found this a lot easier for me to work with, but as I mentioned before, it might be because I've worked with Discord.py before.\n\nsorry, but I gave up after I didn't find an example for buttons (no, I am not watching a 3 hour tutorial). I still believe this is a strong library (based on what I've read on this or other subs, and the fact hikari made it to the \"finals\" of this analysis).\n\nEdit: thanks to u/JONxSLAYS, here are some button examples:\n\nGiven some time, I believe it would be either equivalent or stronger than the others.\n\nI'm going to try disnake. This decision is based on the fact, that it's the one I'm most familiar with, and I like their style the most.\n\nI'm going to try to improve the supporting side more, by creating new stackoverflow questions, if I stumble upon something I'll have to figure out. This should mean getting a dedicated tag , which should further improve debugging and problem solving.\n\nFeel free to comment and share your opinions, I'll just repeat what I've said at the beginning: I would like to STRONGLY ASK, that if you are going to advocate for a library, also justify your opinion."
    }
]