[
    {
        "link": "http://appium.io",
        "document": ""
    },
    {
        "link": "https://appium.io/docs/en/2.0",
        "document": "Welcome to the Appium documentation! Appium is an open-source project and ecosystem of related software, designed to facilitate UI automation of many app platforms, including mobile (iOS, Android, Tizen), browser (Chrome, Firefox, Safari), desktop (macOS, Windows), TV (Roku, tvOS, Android TV, Samsung), and more.\n\nIf you're new to Appium, it's recommended that you start off with the Introduction, then move on to the Quickstart. And you can always find Appium's code on GitHub at appium/appium.\n\nWhat is Appium for?\n\nAppium is used mostly in the field of software test automation, to help determine whether the functionality of a given app is working as expected. In contrast to other types of software testing, UI automation allows testers to write code that walks through user scenarios in the actual UI of an application, mimicking as closely as possible what happens in the real world while enabling the various benefits of automation, including speed, scale, and consistency.\n\nAppium aims to provide a set of tools that support this kind of automation in a standard way across any number of platforms. Most platforms come with tools that allow UI automation at some level, but these are usually platform-specific and require specialized knowledge and specific programming language experience and toolchains. Appium tries to unify all these automation technology under a single stable interface, accessible via most popular programming languages (you can write Appium scripts in Java, Python, Ruby, JS, and more).\n\nTo learn more about how Appium accomplishes this goal, and the various components involved, have a read through our Introduction.\n\nThis documentation is a great way to learn more about Appium:\n• Check out the Introduction first to make sure you understand all the concepts involved in Appium.\n• Go through the Quickstart to get set up and run a basic Android test.\n• Have a look at the various guides and references.\n• Using Appium for a real project means using an Appium driver for a specific platform, so you'll want to have a look at the Ecosystem page where we keep links to the drivers and plugins you might want to use; you can refer to those projects for specific information about using Appium for a given platform.\n\nYou can also check out a list of third-party Resources to explore Appium around the web.\n\nAppium is open source, available under an Apache 2.0 license. Appium's copyright is held by the OpenJS Foundation, and Appium receives contributions from many companies across several software industries, regardless of their competitive status. (3rd-party drivers and plugins are available under the licenses provided by their authors.)\n\nAs such, we welcome contributions! The project moves forward in relation to the investment of contributions of code, documentation, maintenance, and support from companies and volunteers. To learn more about contributing, check out our GitHub repo at appium/appium and read through our Contributing guides."
    },
    {
        "link": "https://lambdatest.com/appium",
        "document": "Master Mocha JS Testing with our detailed tutorial! Learn essential steps for performing Mocha JS testing on cloud testing and parallel test execution.\n\nThousands of apps are released and downloaded every day, be it web, hybrid, or native apps. Appium allows writing test scripts in multiple test automation languages like Java, Python, C#, Kotlin, Swift, etc. Appium makes testing simple because testers don’t have to modify the codes for testing on different OS and devices. The best thing about Appium is that it supports all kinds of apps so that you can run the tests on either iOS or Android on real devices. This tutorial on Appium will equip you with all the essential understanding to get started as a mobile app tester using Appium, including what Appium is, its architecture, working, and installation steps.\n\nDeveloped by Dan Cuellar and Jason Huggins, Appium is an automation testing framework for web, native, and hybrid applications. It is supported on different mobile operating systems like Android, iOS, and Windows. Appium has about 17.4K Star and 5.9K Fork on GitHub when writing this article. Appium is a cross-platform tool allowing you to write UI tests for platforms like Android, iOS, and Windows using the same API. As a result, it enables code reuse between Android, iOS, and Windows test scripts or suites. Like Selenium, Appium supports different programming languages like Java, JavaScript, Python, PHP, C#, etc. With the Appium framework, you can run app test automation for,\n• Native mobile apps: These apps are installed on the device and written using Android, iOS, and Windows SDKs.\n• Mobile web apps: The web apps are accessed in mobile web browsers like Chrome and Safari. You can also access mobile web applications using in-app browsers for Android and iOS.\n• Hybrid apps: These applications are built with a wrapper around a \"webview,\" a native control that allows interaction with web content. You can access hybrid apps from a physical device and a browser URL. Want to know more about Web, Hybrid, and Native apps? Take a look at the comparison of Web vs Hybrid vs Native Apps.\n\nCheck out this short video to learn what is Appium and why we need it!\n\nIt is no secret that the mobile industry is growing rapidly. According to Statista, around 257 billion mobile apps were downloaded worldwide in 2023. Organizations heavily rely on mobile automation testing to ensure faster application delivery. Appium is considered one of the best open-source mobile app test automation frameworks in the testing or QA community. In addition to Appium, many other open-source frameworks are also available for automating mobile testing. However, to communicate with native mobile apps, most of these automation frameworks require an additional agent to compile application codes. Unlike other frameworks, Appium enables communication between different apps and does not require your app to include any extra agents. Shown below are the pointers that keep Appium ahead of other mobile test automation frameworks-\n• Like Selenium Server, Appium works like a server and runs in the background.\n• It has a built-in UI Automator for inspecting mobile apps to get detailed information logs and reporting structures.\n• It can automate any mobile app built in different programming languages and frameworks.\n• It allows you full access to back-end APIs and databases from test scripts.\n• It syncs well with the TestNG testing framework.\n• It doesn’t require installation on mobile devices for mobile app testing.\n• It uses Selenium WebDriver JSON Protocol to work with native Android and iOS mobile applications.\n• Using Appium, you can test apps on Emulators and Simulators and real device cloud.\n• You can perform parallel testing of your Appium automation scripts with Xcode, UIAutomator, and UIAutomation. Check our guide on Appium Parallel Testing. Check out our guide on XCode to learn its features, how to install and use it.\n\nThis section of the Appium testing tutorial talks about the history of the Appium framework. In 2011, Dan Cuellar was the Test Manager at Zoosk when he encountered an issue. In the iOS product, the number of test passes was becoming excessive. He realized that automation was the solution to this problem. Dan examined the existing tool landscape. However, he wanted more than the existing options. Instead, he requested more time from his manager to see if he could find a better way. Then iOS Auto was developed. At the Selenium Conference 2012 in London, Dan demonstrated iOS Automation testing using Selenium syntax to show writing platform-agnostic tests that use distinct platform-specific page objects with a standardized interface. Jason Huggins, co-creator of Selenium, moderated the sessions. Jason approached Dan four months after the Selenium Conference. Jason convinced Dan to make his code available under an open-source license. Dan released the source code in C# on GitHub in August, followed by a new version in Python. Jason installed a web server in September and began implementing the WebDriver wire protocol over HTTP, allowing iOS Auto to be scripted from any Selenium WebDriver client library in any programming language. Jason decided to present the project at the Mobile Testing Summit in November, but he recommended that it be given a new name first. They chose AppleCart after considering several options. After reading Apple's copyright and trademark guidelines, Jason observed that the first term Apple would defend its rights against was \"AppleCart.\" Jason and Dan then chose the new name Appium - Selenium for Apps. At the 2013 Google Test Automation Conference, Appium made its debut in its current form. That same year, Appium was showcased in the United States, England, Poland, Portugal, and Australia at conferences and meetups. Appium became the first cross-platform automation framework when it added Android and Selendroid support in early 2013. Appium began to mature and expand significantly. Appium 1.0 was launched in May 2014, marking a turning point in the project's evolution. Appium received numerous honors and became the most popular open-source, cross-platform mobile automation framework. Appium received the 2014 InfoWorld Bossie award for the best open-source desktop and mobile software. Black Duck Software also named Appium an Open Source Rookie of the Year. Appium was redesigned from the ground up, utilizing a more contemporary version of the JavaScript language and rebuilding the architecture so that users and third-party developers can easily create their own Appium drivers. Post-Appium 2.0, notable additions include an expanded scope with a focus on universal API accessibility. Appium introduced a plugin system, empowering users to develop and share modules that modify its functionality. The plugin system enables diverse capabilities, such as interacting with screen regions based on template images. Appium's vision extends beyond automation, fostering an ecosystem where users can create, share, and enhance drivers and plugins. The platform's adaptability and openness make it a versatile choice for UI automation across various app platforms.\n\nHow to Install and Configure Appium? Appium is a lightweight Node.js package and can be installed easily. Installing Appium doesn't demand a lot of RAM or disk space. Still, there are a few prerequisites for installing Appium Server:\n• An operating system such as Linux, macOS, or Windows. You can install Appium's official releases in two different ways: by using NPM from the command line or by downloading Appium Desktop. Let’s explore these installations in detail. Download and install Appium globally with npm by executing the following command in your terminal or PowerShell: Next, verify the installed version of Appium by running the following command in your terminal: Note: If you are not able to see the installed Appium version with the above command then a possible error is that the Appium installation failed, try rerun the installation command or check prerequisites for errors. Appium Desktop is a graphical front end offered by Appium that brings some useful features like inspector tools. You may follow the below steps to download and install Appium Desktop:\n• Download the Appium Desktop from their GitHub repo.\n• Run the Installer for the OS you are using and complete the setup wizard.\n• Launch the installed Appium Desktop on your PC to start Appium Server automatically. For detailed instructions on Appium installation, please refer to the Appium installation guide. Install the Appium Driver and its Dependencies Appium offers mobile app automation on different platforms, including iOS, Android, and Windows. Each platform uses one or more ,\"drivers\" for native automation tools that are responsible for automating that platform. Starting from version 2.0, drivers for each platform are separated from the Appium server app and can be maintained independently with the appium driver command line interface. To get a list of all the available drivers for your OS, run the below command: To install, uninstall, or update an Appium driver we can use the respective commands as instructed below. appium driver install <plugin name> # To install a new driver from npm # To install a driver from a local folder (useful for developers) # To install a new driver from github appium driver list --installed # To update a driver (it must be already installed) appium driver update xcuitest # To uninstall a driver (it won't last forever, wouldn't it?) appium driver uninstall xcuitest Plugins are a very new concept that are only included in Appium 2.0. We can increase server features and functionality with plugins without having to modify the server code. Driver management is also applicable to plugins. Run the following command in your terminal or PowerShell to see a list of all the plugins that are compatible with your system: To install, update, or uninstall any plugin in your Appium you may use the respective commands as instructed below. appium plugin install <plugin-name> # To install a plugin from a local folder (useful for developers) # To install a new plugin from npm appium plugin list --installed # To update a plugins (it must be already installed) appium plugin update <plugin name> appium plugin uninstall <plugin name>\n\nAppium Doctor is a command-line development and testing tool for mobile apps. It is mainly used to test and diagnose issues related to installation and configuration of Appium on your system. Run the following command in your terminal terminal or PowerShell to install Appium Doctor on your system: Running Appium Doctor using the command terminal or PowerShell is straightforward. You can use the below command to run Appium Doctor. It will provide a list of all the issues and probable solutions for the installation and configurations of the Appium. You can specify the < plaftform name > as ios or android to get the details about the configurations for that selected platform as shown in the below output. Let’s have a look on how you can use these instructions to address and resolve the error. Here, you may notice a cross mark denoting some missing dependencies. In this case, you must install these missing dependencies to fix the errors. Let’s try to install the missing packages (mjpeg-consumer) with the below command. After installing the required missing dependency (mjpeg-consumer), you may run the appium-doctor –- < platform name > again to check if our solution has fixed the errors. Similarly, you can install all the missing packages and resolve all the errors.\n\nHow to Test an App Using Appium? In this tutorial, we'll guide you through testing an Android app using Appium, focusing on a practical example to assess the UI interface and functionality. The chosen scripting language for automation is Python. Some prerequisites to start with the example are:\n• Python version 3 or above must be installed on your system.\n• Appium is installed on the PC.\n• Android Studio to manage app installation and utilize ADB (Android Debug Bridge) for Android app testing.\n• Visual Studio Code as the integrated development environment (IDE) to write automation scripts for Appium testing.\n• If working with iOS devices, Xcode is essential and is only available on Mac. Run the below command in your terminal or PowerShell to install the Appium Client for Python (Appium-Python-Client). It will start the installation of the Appium Python Client library on your PC, as shown in the below console output. Next step is to connect the end device utilizing the ADB (Android Debug Bridge) provided by Android Studio (only required for Android app testing). You may connect an end device in two ways:\n• Connect a real Android device using the USB debugger. To enable this option on your Android device, navigate to developer options - > USB debugging and turn it ON. If you don't find the developer option on your settings page, enable it first by tapping the build number option numerous times (continuously till you see the “developer option turned on” toast) in the About Phone settings.\n• Connect an emulator (virtual Android device) by navigating to the device manager section in your Android Studio, as shown in the image below. Desired Capabilities are key and value pairs written in JSON format. Appium clients send these desired capabilities to the server to start an automation session. These capabilities tell the Appium drivers all the important configurational instructions for testing the app. You may generate suitable desired capabilities manually; however, there is an easy way to generate desired capabilities using an online Capabilities Generator provided by LambdaTest. For this example, you may use the following desired capabilities: In the above capability, deviceName, platformName, and platformVersion define the test execution environment. The app key indicates the APK file path. appPackage and appActivity specify the Android app's package and launcher activity. automationName denotes the automation tool or driver for app automation. These parameters collectively configure the test settings for Appium execution. Open the Appium desktop app, configure the host and port, and then start the Appium server on your PC, as shown in the image below. Next, click on the startServer button to start the Appium server on the selected host and port. Obtaining the ID of mobile app elements is challenging compared to web applications, where elements can be easily inspected through browsers. However, to interact with app components effectively, acquiring specific element IDs is essential. This is where we can leverage the power of Appium Inspector. In this example, we will use the web version of Appium Inspector to inspect the app to retrieve element IDs for effective interaction in this example. Here, we must enter the host where the Appium server is running (Remote Host), port number where the Appium server is running (Remote Port), and the Desired Capabilities in a JSON format, as shown in the above image. Next, click the \"Start Session\" button to instruct Appium to initiate a session based on your settings. The chosen app, a slot machine game, will be installed on the selected emulator or device, facilitating the testing process. Here, we can inspect elements similarly to web pages by hovering and clicking on their IDs. The hierarchy tree for the selected element becomes visible on the right panel for easy navigation. In this example, we will select the “Spin Now” button ID i.e. < com.slot.spin.game.play:id/playBtn > so that we can click on this button to start the game. The next and most crucial step is to write the automation script containing the steps for executing automated tests on the app. In our example, we will write a test script to click the “Spin Now” button to start the game using Python as a test automation language. # Host and Port where Appium is running desired_caps = { } driver = webdriver.Remote(appium_server_url, desired_caps) # Wait for the app to load (adjust the time as needed) # Locate the \"Spin now\" button by ID # Tap the \"Spin now\" button using TouchAction touch_action = TouchAction(driver) touch_action.tap(spin_now_button).perform() # Wait for a moment to see the game result # Quit the driver after the test driver.quit() In the above code, < webdriver.Remote > establishes a connection to the Appium server with specified capabilities. < driver.find_element(By.ID, '...') > locates an element on the mobile app using its ID. < TouchAction(driver) > allows touch gestures and < perform() > executes them. In the provided code, < touch_action.tap(spin_now_button) > performs a tap action to click the \"Spin now\" button (identified by its ID), interacting with the app. This sequence helps automate testing by mimicking user interactions with the Android app, making it a concise Appium test script. Now run this test script to test your first mobile app using Appium and Python. Note : Test on 3000+ real devices for Android and iOS, including the latest iPhone 15. Try LambdaTest Now!\n\nTesting mobile apps on local devices or emulators using the Appium framework has a limitation: we can only use a few devices available locally. A cloud-based mobile automation testing tool can solve this problem by offering a vast collection of real device emulators on the cloud, helping organizations to ensure maximum test coverage and develop a more robust mobile app. Using a cloud-based mobile testing platform is the best way to leverage Appium automation and get the desired results seamlessly without worrying about the lengthy installation and setup for Appium, its related drivers, plugins, emulators, etc. LambdaTest is an AI-native test orchestration and execution platform that lets you run manual and automated tests at scale on over 3000 real devices, browsers, and OS combinations. Before running the actual Appium test on LambdaTest, follow a few simple steps to get your LambdaTest credentials:\n• Create an account on LambdaTest and complete all the required processes.\n• Go to the dashboard by clicking the dashboard icon on the top right corner or Follow this LambdaTest Dashboard.\n• Get your credentials from the profile icon located in the top right corner, and then select the profile option. It will redirect you to the profile screen. Select Password & Security here; you can find your Username and Access Key and save it for future use. Once you have these credentials, you may modify your automation test script to use LambdaTest by just changing the appium_server_url (to lambdatest remote url) value and desired capabilities. Provided below is the code with required modifications. desired_caps = { } username = <YOUR LAMBDATEST USERNAME> access_key = <YOUR LAMBDATEST ACCESS KEY> driver = webdriver.Remote(appium_server_url, desired_caps) # Wait for the app to load (adjust the time as needed) # Locate the \"Spin now\" button by ID spin_now_button = driver.find_element( # Tap the \"Spin now\" button using TouchAction touch_action = TouchAction(driver) touch_action.tap(spin_now_button).perform() # Wait for a moment to see the game result # Quit the driver after the test driver.quit() Updated desired capabilities are as follows: This is the only change that you need to make in your automation script, and you are ready to start cloud based automation testing by changing the desired capabilities based on your requirements.\n\nLambdaTest offers comprehensive learning resources for mastering Appium, the popular mobile automation framework. Whether you're a beginner or an experienced tester, LambdaTest provides valuable tutorials, guides, and documentation to enhance your skills. Listed below are some top learning resources you must visit to master Appium: Earn your certification in Appium fundamentals with this comprehensive course. Learn essential concepts, best practices, and hands-on techniques to become proficient in mobile test automation using Appium. Access a wealth of knowledge and insights on Appium through informative blog posts. Stay updated on the latest trends, tips, and tutorials to enhance your understanding and skills in mobile test automation. Explore dedicated learning hubs tailored to Appium enthusiasts. Dive deep into tutorials, guides, and resources curated to help you master Appium and excel in mobile test automation. Subscribe to LambdaTest's YouTube channel for exclusive video tutorials, webinars, and demos on Appium. Gain practical insights, tips, and tricks from industry experts to optimize your mobile testing efforts using Appium. In conclusion, this comprehensive tutorial on Appium has provided valuable insights into the world of mobile app testing. Appium stands out as a powerful and versatile automated testing tool, supporting web, native, and hybrid applications across different operating systems like Android, iOS, and Windows. As a cross-platform tool, Appium allows testers to write UI tests once and run them on various devices and OS versions, streamlining the testing process. The tutorial covered essential aspects of Appium, including its architecture, working principles on Android and iOS, and the installation steps. Appium's server-client architecture, built-in UI Automator, and support for multiple programming languages contribute to its popularity among mobile app testers. The tutorial also emphasized Appium's ability to automate native, mobile web, and hybrid apps without requiring additional agents, making it a preferred choice for many organizations."
    },
    {
        "link": "https://appium.io/docs/en/2.11/quickstart/install",
        "document": "Appium can be installed globally using :\n\nAppium can be started using the command line:\n\nThis launches the Appium server process, which loads all the installed Appium drivers, and begins waiting for new session requests from client connections (such as test automation scripts). Since the server process is independent from its clients, it must be explicitly launched before attempting to start a new session.\n\nWhen the server is launched, the console log will list all the valid URLs that clients can use to connect to this server:\n\nOnce a client requests a new session, the Appium server process will start logging all details about this session until its termination. Keep this in mind - if you ever encounter issues with Appium tests, you can always check the server log for more details.\n\nSo what's next? Even though Appium is installed and running, it does not come bundled with any drivers, which means it cannot automate anything yet. We will therefore set up automation for Android - continue to Installing the UiAutomator2 Driver."
    },
    {
        "link": "https://appium.io/docs/en/2.2/quickstart",
        "document": "Let's get up and running with Appium! To successfully use this quickstart, it's recommended that you first have read the Introduction, so that you understand the concepts involved in running Appium and writing Appium scripts.\n\nThe basic plan for this quickstart is as follows:\n• Install an Appium driver and its dependencies (we'll be using the UiAutomator2 driver for these examples)\n• Install an Appium client library in your language or choice (this guide contains options for JavaScript, Python, and Java, though Appium clients also exist in other language).\n\nBefore getting started, make sure your system satisfies the requirements for running the Appium server. Additional requirements will be discussed in conjunction with installing the UiAutomator2 driver. The guide also assumes you have basic command line proficiency on your platform, for example being able to run commands, set and persist environment variables, etc...\n\nNow you're ready to get started! So head on over to Installing Appium."
    },
    {
        "link": "https://appium.io/docs/en/2.0/guides/grid",
        "document": "The relay feature in Grid 4 allows you to proxy Appium requests to an Appium server instance. Here is an example walkthrough of how you would connect two different Appium instances to a Selenium Grid.\n\nEach Appium instance should have a config file that can be easily updated. It should contain any information which needs to be unique to that particular server (e.g., ports its drivers should use that others should not). We are going to have 2 Appium servers, so we will need 2 config files:\n\nIn the above YAML config file, we specify the Appium server port, the driver used, and parameters for the driver that will be sent in as default capabilities. Our goal is to ensure that any other drivers running on this host will not compete with system ports or other resources. The second config file could look like the following, where we simply adjust a few ports to prevent clashes:\n\nWe will be launching one Grid \"node\" per Appium server, to manage relaying commands and determining capacity and online status, etc... So we should have one config file per Grid node as well. Each node config should include the address of the Appium server it will target, as well as a list of capability \"configs\" it should accept to relay a session request to Appium. Here is what the config could look like for the two nodes:\n\nNote that each node config also specifies a different port itself for the node to run on.\n\nThe Grid nodes aren't enough--you'll also want a Grid \"hub\" that acts as a load balancer and manager for all the nodes. So in the end we'll have 5 processes running at once: 2 Appium servers, 2 Grid nodes, and 1 Grid hub. It's best to run each of these in a separate terminal window to avoid confusion of logs. Here is how you'd start each process:\n\nOnce you wait a few moments for the nodes to detect their Appium servers, and to register with the hub, you'll be able to send all your Appium traffic via the single hub endpoint (defaulting to ).\n\nAnd of course, you're able to link up Appium servers and nodes running on different machines in your network to form a larger grid.\n\nIt is possible to register your Appium server with a local Selenium Grid 3 (setup docs) instance by using the server argument.\n\nIn the referenced config file you have to define the , and capabilities and based on these parameters the grid will re-direct your test to the right device. You will also need to configure your host details and the Selenium Grid details. For a full list of all parameters and descriptions see here.\n\nOnce you start the Appium server it will register with the grid, and you will see your device on the grid console page:\n\nIf , , and are not given, the config will be auto updated to point to .\n\nIf your Appium server is running on a different machine to your Selenium Grid server, make sure you use an external name/IP address in your and configuration; and will prevent Selenium Grid from connecting correctly."
    },
    {
        "link": "https://headspin.io/blog/using-appium-with-selenium-grid",
        "document": "During the development of your test suite, it's helpful to run tests one at a time, and on one target platform at a time. But when it comes to a production CI environment, you're definitely going to want to run your tests in parallel, with as high a concurrency as you can manage. We've already looked at how to run your Appium tests in parallel, and it involves setting up specific capabilities in your test to make sure that, for each test, Appium can instantiate an appropriate driver without stepping on the toes of the drivers running other tests.\n\nThis approach only scales so far, however. There's a limit to how many real or virtual devices you can run on one machine. What if you want to run 100 Appium tests in parallel? You're likely not going to be able to do that all with one Appium server. Or what if you're running a web test, and would like to make sure your testing works on desktop browsers as well as mobile devices? For that you'll need to mix in Selenium. Either way, you're eventually going to run into a situation where you need multiple automation servers running, which adds a lot of complexity to your test script. Now your test script needs to know the host and port of each server, which servers host which devices or browsers, and how to make sure it doesn't start too many tests on one server and overload its capacity. Essentially, you're dealing with an execution model that looks like this:\n\n(In this example, we're trying to run a web test in parallel across Safari on iOS, Chrome on Android, and Chrome on Desktop).\n\nThankfully, there's a way to mitigate all this complexity, by using a special-purpose load balancer called Selenium Grid. Selenium Grid is basically a proxy server that speaks the WebDriver protocol, and manages connections to a pool of WebDriver servers. It wasn't designed specifically to work with Appium, but because Appium also speaks the WebDriver protocol (and because we taught Appium how to register with Selenium Grid), it's the best tool for DIY Appium clusters.\n• You start a Selenium server running in \"hub\" mode on a certain host and port of your choosing.\n• Now, you can start any number of other Selenium or Appium servers in \"node\" mode. You can start them anywhere you like, as long as they have network access to the grid server (the \"hub\").\n• Each node is started with a special \"node config\" that describes the kinds of automation capabilities it supports.\n• Now, when your test needs to start a session, you ensure it targets the grid server, and the grid server will decide which node to use for the session. You don't need to know or care about where the nodes are located. As long as your test specifies capabilities which the hub can match to a free node, your test will run.\n\nIn other words, I've been describing a model that looks more like this:\n\nBeyond the simplicity of needing to know only about one test server, the Selenium Grid model is particularly nice for Appium, because Appium drivers also require a number of system resources (unique ports, etc...). On the Grid model, you can start each Appium server independently, with a predefined set of ports or the like, using the --default-capabilities flag. So, for example, I could start a set of Appium servers like this, also using the --nodeconfig flag to tell Appium it should connect with Selenium Grid:\n\nNow each of these Appium servers will be registered with the Selenium Grid, and each server has declared which wdaLocalPort it needs; now my test script doesn't have to know or care about this! It becomes an ops step, which makes much more sense.\n\nThe magic pretty much all happens in the \"node config\" file, which is defined as JSON. There are a lot of nodeconfig options to choose from, but here's an example of the config I'll be using for the Safari-on-iOS node in this guide:\n\nLet's take a look at some of the important configuration keys:\n• capabilities: the set of capabilities supported by this node. Can be a list. In this case, the node is only supporting one type of device. Note that in addition to the capabilities you're used to seeing, you can specify how many of a particular capability set the node should be allowed to start, via maxInstances.\n• proxy: the proxy logic to be used for communicating with this node. You can write a custom proxy if desired.\n• maxSession: the total number of sessions this node can run. This is useful in combination with maxInstances. For example, let's say we can run a total of 5 iPhone 8s and 5 iPhone 6s on this node, but the system gets overloaded when running more than 8 sessions at a time, of any kind. Then we'd set maxInstances to 5 for each device type, but maxSession to 8, so that we never try to run the theoretical max of 10.\n• hubHost, hubPort, and hubProtocol: the connection details for the Grid hub server\n\nThat's basically all you need to know about how Selenium Grid works with Appium. So let's dive into a working example. What we want to end up with is parallel execution of one web test, across Safari on iOS, Chrome on Android, and Chrome on Desktop (just like in the diagrams above).\n• Make sure you've downloaded the latest Selenium server (I'm on 3.141.59 for this guide).\n• Make sure you've got the latest Chromedriver, so that Chrome desktop automation works (I'm on 2.45).\n• Make sure you've got an Android emulator up and running with the latest version of the Chrome browser on it (I'm using v71).\n• Open up 4 separate terminal windows (we're going to run the Grid hub server in one, and the 3 nodes in the others). Here's what to run in the 4 windows (in all cases, replace the paths with appropriate paths for your system):\n\nHere are the contents of the nodeconfig JSON files (in addition to nodeconfig-ios.json, which is above). (You can also download them from the Appium Pro repo on GitHub).\n\nThis is all the setup we need! In a real production CI environment, you'd probably have this all automated and potentially registering lots more nodes across many different physical or virtual servers. Anyway, once you've got everything up and running, you should see messages in the Selenium Grid console to the effect that several nodes have checked in:\n\nBecause our test project is Gradle-based, our best option for running in parallel is to use maxParallelForks (as described in here, along with instructions for Maven-based projects). Here's how I've updated my build.gradle to that end:\n\nThis will cause Gradle to create a new thread for each test class. Unfortunately, a consequence is that for real parallelism, we need to have separate test classes, not just separate methods within one test. For that reason, this example includes 4 Java files: one as a base test class for shared code, and 3 platform-specific classes, so that they can be run in parallel. Here's the base class:\n\nAs you can see, it contains the actual test logic we want to execute, which attempts a login on The Internet and checks that the login fails. The only real item of interest here is that we have saved a reference to the Grid hub server, running on the default port 4444. This is what each test class will use to connect to the Grid hub.\n\nAnd here are the three platform-specific classes:\n\nThe only responsibility for these classes is to get the right capabilities set up, instantiate a driver with them, and kick off the actual test. With each of these classes set up in their own files appropriately, I can now use a gradle command to run my test suite in parallel:\n\n(The * helps me select all the test classes I care about for this example, and not other ones).\n\nAt this point, all three tests are started simultaneously, and Selenium Grid forwards each session to the appropriate node. The result is that all the tests execute at the same time (though on my machine, the Chrome Desktop test ends much faster than the other two)!\n\nSelenium Grid, and distributed parallel testing in general, is a deep topic, and this guide could only cover the basic cases. But what we've shown is enough to use to get a test grid of basically any size up and running, potentially even mixing and matching mobile and desktop testing as well.\n\nWhat you'll no doubt find as you get into setting up your own Grid is that, fabulous as Selenium Grid itself may be, there's an awful lot of maintenance associated with running the various nodes! That's one reason that there are, nowadays, a number of options for running your Appium tests in parallel in the cloud, and it's important to try solutions like these out before going all-in on an in-house Grid setup, so you can do appropriate cost-benefit analysis for your team."
    },
    {
        "link": "https://medium.com/@thananjayan1988/appium-node-configuration-for-selenium-grid-4-394d8dd6c06e",
        "document": "On mobile test automation, when it comes to parallel execution, set up the infrastructure for mobile and different OS, centralized maintenance are all tedious task. We can leverage these with help Grid + Appium setup. From Appium 2.X version the drivers needs to installed separately for each OS and Device combo.\n\nNote: I strongly recommend to use the Appium Device Farm plugin if your project is going to do the monitor device’s, session management, device interaction etc...\n\nUnified Infrastructure — Appium integrated with Selenium Grid allows you to manage all test execution — web, mobile, and desktop applications — from a single centralized setup\n\nEase of Scaling — Multiple Appium nodes can be added to the grid, enabling simultaneous testing on multiple devices.\n\nParallel Testing: Appium with Selenium Grid supports running multiple tests simultaneously on different devices or emulators, reducing overall test execution time.\n\nDynamic Allocation: The grid allocates available Appium nodes dynamically to incoming test requests.\n\nSimplified Maintenance: Centralized updates to the grid are reflected across all nodes, making it easier to manage.\n\nUsing Selenium Grid we could maintain and monitor all Appium server instance in a single place with their configuration details. In this article we are going to see the setup for how grid relay feature of grid proxy the request to Appium server instance.\n\nInstall the globally using the command\n\nBefore start the appium server instance, make sure to install the necessary drivers globally, let’s configure file for each OS combination.\n\nSave the below content as for server configuration.\n\nAnd for the other server details as\n\nNow start these server separately by running these command\n\nIf you check the server status in browser and\n\nNow it’s time to add these server instance to of selenium grid using file.\n\nIn below file, We are configuring the node having combination of chrome browser for web and device for native app in platform.\n\nNow run the node setup with the above file\n\nFor node 2 add the instance for with different device\n\nRun this node in different port\n\nOn successful registration we can see these node in grid UI.\n\nIntegrating Appium with Selenium Grid is a strategic move for teams seeking to maximize test coverage, efficiency, and resource utilization while maintaining flexibility in their testing workflows.\n\nIf you read and like this blog, then give a 👏👏👏"
    },
    {
        "link": "https://browserstack.com/guide/set-up-appium-grid",
        "document": "Mobile App Testing ensures the delivery of mobile applications that serve, delight, and retain users through their high-end UX and cross platform compatibility. However, in the fast-growing digital market, users expect a new version of every app, laden with advanced features, every few weeks. To meet that demand, automation testing has become indispensable in software development pipelines. It has helped software development and testing professionals deliver high-end mobile apps within tight deadlines.\n\nLike all aspects of development and testing, mobile testing requires the right tools and frameworks. Appium is one of the most widely used frameworks for automated mobile app testing of native and hybrid apps. It is built to facilitate fast and accurate results and thus is an important part of any mobile tester’s toolkit.\n\nThis article will explore how to set up Appium Grid to perform automated app testing.\n\nAppium is an open-source automation testing framework for apps supported by platforms like iOS, Android, macOS, and Windows. Similar to Selenium, it enables the tester to write test scripts in different programming languages such as JavaScript, Java, Ruby, Python, PHP, and C#, which can be used for both Android and iOS platforms.\n\nAppium Grid is a proxy server that allows the tester to run parallel tests on multiple devices simultaneously. This is done by connecting the Appium Server with the Selenium Grid, which makes a hub with multiple nodes – each having a different device-browser combination to perform cross-platform testing. Hub and Nodes form the basic Appium Grid Structure, with the Hub serving as the central server entity, and Nodes being the individual devices on which the tests are run simultaneously.\n\nHere, one server acts as the Hub, which accepts the access requests from the Webdriver Client. This is done by routing commands to remote web browser instances on each of the nodes.\n\nThe Hub conducts concurrent execution of tests on multiple machines, managing different browsers centrally, instead of conducting different tests for each of them. The Selenium Grid makes cross browser testing easy as a single test can be carried on multiple machines and browsers simultaneously. Naturally, this streamlines the process of analyzing and comparing the results. This reduces test session time, thus generating faster results.\n\nThe Nodes are remote devices that consist of a native OS, and remote Appium Servers. It receives requests from the Hub in the form of JSON test commands and executes them using Appium.\n\n\n\nListed below are the prerequisites for setting up the Appium Grid and starting with the cross browser testing on multiple browser-device combinations (both Android and iOS) simultaneously:\n• Procure a Mac computer with macOS 10.11 or 10.12, and an iOS device with iOS 9.3 or higher.\n• Install Java and set up the environment variables.\n• Install Appium Desktop and download the Appium Jars for Eclipse.\n• Install Homebrew (for managing missing packages). The first command below downloads the script to the local machine, while the second command runs the installation.\n\nThe Hub is the central point in the Appium Grid, where Selenium Grid is used to route the JSON test commands to the nodes. It receives test requests from the client and routes it to the required Nodes.\n\nOnce the Selenium Grid is installed as mentioned in the prerequisites, set up the Hub (launching Selenium Grid) – open the command prompt, and navigate to the directory, where the Selenium Server Standalone jar file has been downloaded.\n\nStart the Hub by passing the -role hub flag to the Selenium Standalone Server by entering the following command:\n\nThis would start the hub automatically using port 4444 by default.\n\nOne can change the default port by adding an optional parameter -port when running the command.\n\nOne doesn’t have to specify the host name as it can be determined automatically. However, if the tester is using a VPN network, specifying the host becomes necessary.\n\nTo view the status of the hub, open a browser window and navigate to http://localhost:4444/grid/console\n\nStep 2: Configure Appium Node JSON file and connect it to the Selenium Grid Hub\n\nTo set up Nodes for the Appium Grid, configure the JSON files for each of the node devices, such as done below for Device 1 (iOS 12, iPhone 8 Plus):\n\nThis JSON file will help connect the Hub and Nodes and act as a bridge in routing the relevant test to the required device at the Node.\n\nSimilarly, configure the JSON Files for other nodes (devices) to build the Appium Grid.\n\nThen run the driver node by using the following command. Make sure that the port parameter mentioned here is the same as that on the Node Config JSON file.\n\nNote that the default port for Appium Client and server is 4723, while that of the Appium server and testing device is 4724. However, one can specify the port number to avoid confusion.\n\nStep 3: Initialize the Mobile Drivers for Node Devices using Appium\n\nSet the Desired Capabilities for Device 1 (iOS 12)using the following code This would be the first node for the Appium Grid:\n\nSimilarly, one can set the Desired Capabilities for other devices too (including Android devices) that would be used as Nodes in the Appium Grid.\n\nThe initialization of Node devices will help in allocating relevant tests to the targeted Node Device upon matching the Capabilities.\n\nBy performing the three steps above, testers can set up the Appium Grid, which would help them perform parallel testing on multiple devices by connecting the Appium Servers of the individual devices with a central Hub (Selenium Grid). The multiple device-browser combinations at the nodes will help in performing Cross Device Testing for the test scenarios.\n\nOnce the Appium Grid has been set up, testers will need access to real mobile devices to run their mobile tests. BrowserStack enables this by providing a real device cloud of thousands of mobile devices (both iOS and Android) for automated testing via Appium.\n\nAdditionally, there are in-built debugging tools to help the testers identify and resolve bugs without any hassles. BrowserStack thus facilitates Cross Platform Testing to verify an app’s compatibility with multiple devices and operating systems. It also facilitates parallel testing, thus accelerating test execution, test results and eventually, enabling significantly faster delivery of perfectly optimized apps."
    },
    {
        "link": "https://stackoverflow.com/questions/33636847/selenium-grid-necessary-with-appium-using-real-devices",
        "document": "One of the things that my team has been talking about is hooking up our appium tests (that are ran through physical devices) to the grid. I dont see what this could accomplish.. Due to the fact that you can not run more than one test at a time per appium server (I may be wrong.. I have tried making them not run parallel, and instead one at a time but it did not work for me). We have several test classes, say 10 in a suite, so does that mean I need 10 devices?\n\nI guess my main concern is that I am thinking about this all wrong.. Anyone who has experience with syncing up their appium tests to their grid, either physical or emulated devices, please let me know how it works and what can be accomplished. Thanks!"
    },
    {
        "link": "http://appium.io",
        "document": ""
    },
    {
        "link": "https://github.com/appium/java-client",
        "document": "This is the Java language bindings for writing Appium Tests that conform to WebDriver Protocol\n\nSince v9 the client only supports Java 11 and above. Follow the v8 to v9 Migration Guide to streamline the migration process.\n\nSince version 8 Appium Java Client had several major changes, which might require to update your client code. Make sure to follow the v7 to v8 Migration Guide to streamline the migration process.\n\nAdd the following to pom.xml:\n\nAdd the following to build.gradle:\n\nJava client project is available to use even before it is officially published to Maven Central. Refer jitpack.io\n\nAdd the following to pom.xml:\n\nAdd the JitPack repository to your build file. Add it to your root build.gradle at the end of repositories:\n\nSelenium client does not follow Semantic Versioning, so breaking changes might be introduced even in patches, which requires the Appium team to update the Java client in response.\n\nAppium Java Client declares Selenium dependencies using an open version range which is handled differently by different build tools. Sometimes users may want to pin used Selenium dependencies for various reasons. Follow the Transitive Dependencies Management article for more information about establishing a fixed Selenium version for your Java test framework.\n\nAppium java client has dedicated classes to support the following Appium drivers:\n\nTo automate other platforms that are not listed above you could use AppiumDriver or its custom derivatives.\n\nAppium java client is built on top of Selenium and implements the same interfaces that the foundation RemoteWebDriver does. However, Selenium lib is mostly focused on web browser automation while Appium is universal and covers a wide range of possible platforms, e.g. mobile and desktop operating systems, IOT devices, etc. Thus, the foundation class in this package extends with additional features, and makes it more flexible, so it is not so strictly focused on web-browser related operations.\n\nAppium java client provides a dedicated class to control Appium server execution. The class is AppiumDriverLocalService. It allows to run and verify the Appium server locally from your test framework code and provides several convenient shortcuts. The service could be used as below:\n\nYou could customize the service behavior, for example, provide custom command line arguments or change paths to server executables using AppiumServiceBuilder\n\nCheck the corresponding driver's READMEs to know the list of capabilities and features it supports.\n\nYou can find many more code examples by checking client's unit and integration tests.\n\nAppium Java client uses reflective access to private members of other modules to ensure proper functionality of several features, like the Page Object model. If you get a runtime exception and is present in the stack trace and your Java runtime is at version 16 or higher, then consider the following Oracle's tutorial and/or checking existing issues for possible solutions. The idea there would be to explicitly allow access for particular modules using command line arguments.\n\nAnother possible, but weakly advised solution, would be to downgrade Java to version 15 or lower.\n\nSuch issues are usually the case when the Appium server is started directly from your framework code rather than run separately by a script or manually. Depending on the way the server process is started it may or may not inherit the currently active shell environment. That is why you may still receive errors about the variables' presence even though these variables are defined for your command line interpreter. Again, there is no universal solution to that, as there are many ways to spin up a new server process. Consider checking the Appium Environment Troubleshooting document for more information on how to debug and fix process environment issues.\n\nVisit CHANGELOG.md to see the full list of changes between versions."
    },
    {
        "link": "https://lambdatest.com/appium",
        "document": "Master Mocha JS Testing with our detailed tutorial! Learn essential steps for performing Mocha JS testing on cloud testing and parallel test execution.\n\nThousands of apps are released and downloaded every day, be it web, hybrid, or native apps. Appium allows writing test scripts in multiple test automation languages like Java, Python, C#, Kotlin, Swift, etc. Appium makes testing simple because testers don’t have to modify the codes for testing on different OS and devices. The best thing about Appium is that it supports all kinds of apps so that you can run the tests on either iOS or Android on real devices. This tutorial on Appium will equip you with all the essential understanding to get started as a mobile app tester using Appium, including what Appium is, its architecture, working, and installation steps.\n\nDeveloped by Dan Cuellar and Jason Huggins, Appium is an automation testing framework for web, native, and hybrid applications. It is supported on different mobile operating systems like Android, iOS, and Windows. Appium has about 17.4K Star and 5.9K Fork on GitHub when writing this article. Appium is a cross-platform tool allowing you to write UI tests for platforms like Android, iOS, and Windows using the same API. As a result, it enables code reuse between Android, iOS, and Windows test scripts or suites. Like Selenium, Appium supports different programming languages like Java, JavaScript, Python, PHP, C#, etc. With the Appium framework, you can run app test automation for,\n• Native mobile apps: These apps are installed on the device and written using Android, iOS, and Windows SDKs.\n• Mobile web apps: The web apps are accessed in mobile web browsers like Chrome and Safari. You can also access mobile web applications using in-app browsers for Android and iOS.\n• Hybrid apps: These applications are built with a wrapper around a \"webview,\" a native control that allows interaction with web content. You can access hybrid apps from a physical device and a browser URL. Want to know more about Web, Hybrid, and Native apps? Take a look at the comparison of Web vs Hybrid vs Native Apps.\n\nCheck out this short video to learn what is Appium and why we need it!\n\nIt is no secret that the mobile industry is growing rapidly. According to Statista, around 257 billion mobile apps were downloaded worldwide in 2023. Organizations heavily rely on mobile automation testing to ensure faster application delivery. Appium is considered one of the best open-source mobile app test automation frameworks in the testing or QA community. In addition to Appium, many other open-source frameworks are also available for automating mobile testing. However, to communicate with native mobile apps, most of these automation frameworks require an additional agent to compile application codes. Unlike other frameworks, Appium enables communication between different apps and does not require your app to include any extra agents. Shown below are the pointers that keep Appium ahead of other mobile test automation frameworks-\n• Like Selenium Server, Appium works like a server and runs in the background.\n• It has a built-in UI Automator for inspecting mobile apps to get detailed information logs and reporting structures.\n• It can automate any mobile app built in different programming languages and frameworks.\n• It allows you full access to back-end APIs and databases from test scripts.\n• It syncs well with the TestNG testing framework.\n• It doesn’t require installation on mobile devices for mobile app testing.\n• It uses Selenium WebDriver JSON Protocol to work with native Android and iOS mobile applications.\n• Using Appium, you can test apps on Emulators and Simulators and real device cloud.\n• You can perform parallel testing of your Appium automation scripts with Xcode, UIAutomator, and UIAutomation. Check our guide on Appium Parallel Testing. Check out our guide on XCode to learn its features, how to install and use it.\n\nThis section of the Appium testing tutorial talks about the history of the Appium framework. In 2011, Dan Cuellar was the Test Manager at Zoosk when he encountered an issue. In the iOS product, the number of test passes was becoming excessive. He realized that automation was the solution to this problem. Dan examined the existing tool landscape. However, he wanted more than the existing options. Instead, he requested more time from his manager to see if he could find a better way. Then iOS Auto was developed. At the Selenium Conference 2012 in London, Dan demonstrated iOS Automation testing using Selenium syntax to show writing platform-agnostic tests that use distinct platform-specific page objects with a standardized interface. Jason Huggins, co-creator of Selenium, moderated the sessions. Jason approached Dan four months after the Selenium Conference. Jason convinced Dan to make his code available under an open-source license. Dan released the source code in C# on GitHub in August, followed by a new version in Python. Jason installed a web server in September and began implementing the WebDriver wire protocol over HTTP, allowing iOS Auto to be scripted from any Selenium WebDriver client library in any programming language. Jason decided to present the project at the Mobile Testing Summit in November, but he recommended that it be given a new name first. They chose AppleCart after considering several options. After reading Apple's copyright and trademark guidelines, Jason observed that the first term Apple would defend its rights against was \"AppleCart.\" Jason and Dan then chose the new name Appium - Selenium for Apps. At the 2013 Google Test Automation Conference, Appium made its debut in its current form. That same year, Appium was showcased in the United States, England, Poland, Portugal, and Australia at conferences and meetups. Appium became the first cross-platform automation framework when it added Android and Selendroid support in early 2013. Appium began to mature and expand significantly. Appium 1.0 was launched in May 2014, marking a turning point in the project's evolution. Appium received numerous honors and became the most popular open-source, cross-platform mobile automation framework. Appium received the 2014 InfoWorld Bossie award for the best open-source desktop and mobile software. Black Duck Software also named Appium an Open Source Rookie of the Year. Appium was redesigned from the ground up, utilizing a more contemporary version of the JavaScript language and rebuilding the architecture so that users and third-party developers can easily create their own Appium drivers. Post-Appium 2.0, notable additions include an expanded scope with a focus on universal API accessibility. Appium introduced a plugin system, empowering users to develop and share modules that modify its functionality. The plugin system enables diverse capabilities, such as interacting with screen regions based on template images. Appium's vision extends beyond automation, fostering an ecosystem where users can create, share, and enhance drivers and plugins. The platform's adaptability and openness make it a versatile choice for UI automation across various app platforms.\n\nHow to Install and Configure Appium? Appium is a lightweight Node.js package and can be installed easily. Installing Appium doesn't demand a lot of RAM or disk space. Still, there are a few prerequisites for installing Appium Server:\n• An operating system such as Linux, macOS, or Windows. You can install Appium's official releases in two different ways: by using NPM from the command line or by downloading Appium Desktop. Let’s explore these installations in detail. Download and install Appium globally with npm by executing the following command in your terminal or PowerShell: Next, verify the installed version of Appium by running the following command in your terminal: Note: If you are not able to see the installed Appium version with the above command then a possible error is that the Appium installation failed, try rerun the installation command or check prerequisites for errors. Appium Desktop is a graphical front end offered by Appium that brings some useful features like inspector tools. You may follow the below steps to download and install Appium Desktop:\n• Download the Appium Desktop from their GitHub repo.\n• Run the Installer for the OS you are using and complete the setup wizard.\n• Launch the installed Appium Desktop on your PC to start Appium Server automatically. For detailed instructions on Appium installation, please refer to the Appium installation guide. Install the Appium Driver and its Dependencies Appium offers mobile app automation on different platforms, including iOS, Android, and Windows. Each platform uses one or more ,\"drivers\" for native automation tools that are responsible for automating that platform. Starting from version 2.0, drivers for each platform are separated from the Appium server app and can be maintained independently with the appium driver command line interface. To get a list of all the available drivers for your OS, run the below command: To install, uninstall, or update an Appium driver we can use the respective commands as instructed below. appium driver install <plugin name> # To install a new driver from npm # To install a driver from a local folder (useful for developers) # To install a new driver from github appium driver list --installed # To update a driver (it must be already installed) appium driver update xcuitest # To uninstall a driver (it won't last forever, wouldn't it?) appium driver uninstall xcuitest Plugins are a very new concept that are only included in Appium 2.0. We can increase server features and functionality with plugins without having to modify the server code. Driver management is also applicable to plugins. Run the following command in your terminal or PowerShell to see a list of all the plugins that are compatible with your system: To install, update, or uninstall any plugin in your Appium you may use the respective commands as instructed below. appium plugin install <plugin-name> # To install a plugin from a local folder (useful for developers) # To install a new plugin from npm appium plugin list --installed # To update a plugins (it must be already installed) appium plugin update <plugin name> appium plugin uninstall <plugin name>\n\nAppium Doctor is a command-line development and testing tool for mobile apps. It is mainly used to test and diagnose issues related to installation and configuration of Appium on your system. Run the following command in your terminal terminal or PowerShell to install Appium Doctor on your system: Running Appium Doctor using the command terminal or PowerShell is straightforward. You can use the below command to run Appium Doctor. It will provide a list of all the issues and probable solutions for the installation and configurations of the Appium. You can specify the < plaftform name > as ios or android to get the details about the configurations for that selected platform as shown in the below output. Let’s have a look on how you can use these instructions to address and resolve the error. Here, you may notice a cross mark denoting some missing dependencies. In this case, you must install these missing dependencies to fix the errors. Let’s try to install the missing packages (mjpeg-consumer) with the below command. After installing the required missing dependency (mjpeg-consumer), you may run the appium-doctor –- < platform name > again to check if our solution has fixed the errors. Similarly, you can install all the missing packages and resolve all the errors.\n\nHow to Test an App Using Appium? In this tutorial, we'll guide you through testing an Android app using Appium, focusing on a practical example to assess the UI interface and functionality. The chosen scripting language for automation is Python. Some prerequisites to start with the example are:\n• Python version 3 or above must be installed on your system.\n• Appium is installed on the PC.\n• Android Studio to manage app installation and utilize ADB (Android Debug Bridge) for Android app testing.\n• Visual Studio Code as the integrated development environment (IDE) to write automation scripts for Appium testing.\n• If working with iOS devices, Xcode is essential and is only available on Mac. Run the below command in your terminal or PowerShell to install the Appium Client for Python (Appium-Python-Client). It will start the installation of the Appium Python Client library on your PC, as shown in the below console output. Next step is to connect the end device utilizing the ADB (Android Debug Bridge) provided by Android Studio (only required for Android app testing). You may connect an end device in two ways:\n• Connect a real Android device using the USB debugger. To enable this option on your Android device, navigate to developer options - > USB debugging and turn it ON. If you don't find the developer option on your settings page, enable it first by tapping the build number option numerous times (continuously till you see the “developer option turned on” toast) in the About Phone settings.\n• Connect an emulator (virtual Android device) by navigating to the device manager section in your Android Studio, as shown in the image below. Desired Capabilities are key and value pairs written in JSON format. Appium clients send these desired capabilities to the server to start an automation session. These capabilities tell the Appium drivers all the important configurational instructions for testing the app. You may generate suitable desired capabilities manually; however, there is an easy way to generate desired capabilities using an online Capabilities Generator provided by LambdaTest. For this example, you may use the following desired capabilities: In the above capability, deviceName, platformName, and platformVersion define the test execution environment. The app key indicates the APK file path. appPackage and appActivity specify the Android app's package and launcher activity. automationName denotes the automation tool or driver for app automation. These parameters collectively configure the test settings for Appium execution. Open the Appium desktop app, configure the host and port, and then start the Appium server on your PC, as shown in the image below. Next, click on the startServer button to start the Appium server on the selected host and port. Obtaining the ID of mobile app elements is challenging compared to web applications, where elements can be easily inspected through browsers. However, to interact with app components effectively, acquiring specific element IDs is essential. This is where we can leverage the power of Appium Inspector. In this example, we will use the web version of Appium Inspector to inspect the app to retrieve element IDs for effective interaction in this example. Here, we must enter the host where the Appium server is running (Remote Host), port number where the Appium server is running (Remote Port), and the Desired Capabilities in a JSON format, as shown in the above image. Next, click the \"Start Session\" button to instruct Appium to initiate a session based on your settings. The chosen app, a slot machine game, will be installed on the selected emulator or device, facilitating the testing process. Here, we can inspect elements similarly to web pages by hovering and clicking on their IDs. The hierarchy tree for the selected element becomes visible on the right panel for easy navigation. In this example, we will select the “Spin Now” button ID i.e. < com.slot.spin.game.play:id/playBtn > so that we can click on this button to start the game. The next and most crucial step is to write the automation script containing the steps for executing automated tests on the app. In our example, we will write a test script to click the “Spin Now” button to start the game using Python as a test automation language. # Host and Port where Appium is running desired_caps = { } driver = webdriver.Remote(appium_server_url, desired_caps) # Wait for the app to load (adjust the time as needed) # Locate the \"Spin now\" button by ID # Tap the \"Spin now\" button using TouchAction touch_action = TouchAction(driver) touch_action.tap(spin_now_button).perform() # Wait for a moment to see the game result # Quit the driver after the test driver.quit() In the above code, < webdriver.Remote > establishes a connection to the Appium server with specified capabilities. < driver.find_element(By.ID, '...') > locates an element on the mobile app using its ID. < TouchAction(driver) > allows touch gestures and < perform() > executes them. In the provided code, < touch_action.tap(spin_now_button) > performs a tap action to click the \"Spin now\" button (identified by its ID), interacting with the app. This sequence helps automate testing by mimicking user interactions with the Android app, making it a concise Appium test script. Now run this test script to test your first mobile app using Appium and Python. Note : Test on 3000+ real devices for Android and iOS, including the latest iPhone 15. Try LambdaTest Now!\n\nTesting mobile apps on local devices or emulators using the Appium framework has a limitation: we can only use a few devices available locally. A cloud-based mobile automation testing tool can solve this problem by offering a vast collection of real device emulators on the cloud, helping organizations to ensure maximum test coverage and develop a more robust mobile app. Using a cloud-based mobile testing platform is the best way to leverage Appium automation and get the desired results seamlessly without worrying about the lengthy installation and setup for Appium, its related drivers, plugins, emulators, etc. LambdaTest is an AI-native test orchestration and execution platform that lets you run manual and automated tests at scale on over 3000 real devices, browsers, and OS combinations. Before running the actual Appium test on LambdaTest, follow a few simple steps to get your LambdaTest credentials:\n• Create an account on LambdaTest and complete all the required processes.\n• Go to the dashboard by clicking the dashboard icon on the top right corner or Follow this LambdaTest Dashboard.\n• Get your credentials from the profile icon located in the top right corner, and then select the profile option. It will redirect you to the profile screen. Select Password & Security here; you can find your Username and Access Key and save it for future use. Once you have these credentials, you may modify your automation test script to use LambdaTest by just changing the appium_server_url (to lambdatest remote url) value and desired capabilities. Provided below is the code with required modifications. desired_caps = { } username = <YOUR LAMBDATEST USERNAME> access_key = <YOUR LAMBDATEST ACCESS KEY> driver = webdriver.Remote(appium_server_url, desired_caps) # Wait for the app to load (adjust the time as needed) # Locate the \"Spin now\" button by ID spin_now_button = driver.find_element( # Tap the \"Spin now\" button using TouchAction touch_action = TouchAction(driver) touch_action.tap(spin_now_button).perform() # Wait for a moment to see the game result # Quit the driver after the test driver.quit() Updated desired capabilities are as follows: This is the only change that you need to make in your automation script, and you are ready to start cloud based automation testing by changing the desired capabilities based on your requirements.\n\nLambdaTest offers comprehensive learning resources for mastering Appium, the popular mobile automation framework. Whether you're a beginner or an experienced tester, LambdaTest provides valuable tutorials, guides, and documentation to enhance your skills. Listed below are some top learning resources you must visit to master Appium: Earn your certification in Appium fundamentals with this comprehensive course. Learn essential concepts, best practices, and hands-on techniques to become proficient in mobile test automation using Appium. Access a wealth of knowledge and insights on Appium through informative blog posts. Stay updated on the latest trends, tips, and tutorials to enhance your understanding and skills in mobile test automation. Explore dedicated learning hubs tailored to Appium enthusiasts. Dive deep into tutorials, guides, and resources curated to help you master Appium and excel in mobile test automation. Subscribe to LambdaTest's YouTube channel for exclusive video tutorials, webinars, and demos on Appium. Gain practical insights, tips, and tricks from industry experts to optimize your mobile testing efforts using Appium. In conclusion, this comprehensive tutorial on Appium has provided valuable insights into the world of mobile app testing. Appium stands out as a powerful and versatile automated testing tool, supporting web, native, and hybrid applications across different operating systems like Android, iOS, and Windows. As a cross-platform tool, Appium allows testers to write UI tests once and run them on various devices and OS versions, streamlining the testing process. The tutorial covered essential aspects of Appium, including its architecture, working principles on Android and iOS, and the installation steps. Appium's server-client architecture, built-in UI Automator, and support for multiple programming languages contribute to its popularity among mobile app testers. The tutorial also emphasized Appium's ability to automate native, mobile web, and hybrid apps without requiring additional agents, making it a preferred choice for many organizations."
    },
    {
        "link": "https://medium.com/@jignect/appium-with-java-a-comprehensive-guide-0fe6520cf697",
        "document": "Ensuring high quality mobile apps is very important. Appium is a free tool that can automate testing these apps, which saves time and money. This guide will teach you everything you need to know about Appium to get started testing your own mobile apps. You’ll learn how Appium works, how to set it up, and how to write your first test. By the end, you’ll be able to test mobile apps faster and make sure they are excellent!\n• What is an AVD\n• How to set up an AVD\n• How to start an emulator from the command line\n\nAppium is an open-source automation mobile testing tool. It is used to test native and hybrid mobile applications. Appium is similar to the Selenium Webdriver testing tool, making it easy to learn for those familiar with Selenium.\n• Open source: Appium is free to use and modify, which makes it a great option for individual developers and small businesses. There is a large and active community of Appium users who contribute to the project and provide support.\n• Platform Independence: Appium does not depend on the mobile device’s operating system. You write your tests once, and Appium acts as the translator. It takes your instructions and converts them to the specific way each phone understands them (like UIAutomator for Android and UIAutomation for iPhone).\n• Built-in inspector for element identification: Appium has a built-in inspector that can help you identify the elements on your app’s screen. This is useful for writing your test scripts.\n• No app modification required: You don’t need to modify the source code of your app to use Appium. This makes it a great option for testing off-the-shelf apps or apps that you don’t have the source code for.\n• Integration with continuous integration (CI) tools: Appium can be integrated with CI tools like Jenkins, which allows you to automate your mobile app testing process. This can help you to catch bugs early and improve the quality of your apps.\n• Language Support: Appium supports multiple programming languages such as Java, PHP, C, C#, Python, JavaScript with node.js, Ruby, etc.\n• Selenium Integration: Selenium serves as the backend of Appium, providing control over Selenium’s functionality for testing requirements.\n• Parallel execution of tests: Appium can be used to run your tests in parallel, which can save you time.\n• Installation of Appium Server: When Appium is installed, a server is set up on the user’s machine that exposes the REST API.\n• Command Execution: The server receives command and connection requests from the client and executes these commands on mobile devices such as iOS or Android.\n• Response Mechanism: After executing the commands, Appium responds with HTTP responses to the client.\n• Mobile Test Automation Framework: To carry out these requests, Appium utilizes a mobile test automation framework to interact with the user interface of the application\n\nWhile writing this blog, we have used these versions of the libraries and applications:\n\nWe’ve already covered how to download and install Java Development Kit (JDK) and IntelliJ IDE in a previous blog post on Java with Selenium!\n\nTo interact with mobile devices and execute automation scripts, installing the Appium server on your system is essential.It’s crucial to have Node.js and npm (Node Package Manager) installed because Appium is built on Node.js\n\nBelow are the steps for install Appium on Windows From the terminal using Node.js :\n• The first step is to verify whether Node.js is already installed in the system.\n\nTo do so, open the terminal and run the command: node -v\n• If Node.js is already installed in the system, it’ll return the Node version, else it throws an error stating — ‘node is not recognized’, which means Node.js is not installed in the system.\n• To install Node.js, visit the official site.\n• Once the installation is complete, restart the terminal and run the command -> node -v again. It will return the Node version.\n• Run the command npm install -g appium which will install Appium from NPM.\n• The command above will download and install Appium. Once done, verify the Appium installation on macOS or Windows by running the command below:\n• You can access Appium from the command line by running the appium command. For example, if you get an output that starts with a line like this: (Appium) Welcome to Appium v2.0.0, then the Appium server is up and running. You can quit the server by pressing CTRL-C.\n• Along with appium server , we would need to install appium driver:\n• Run the command appium driver install uiautomator2 which will install Appium driver for android.\n• Run the command appium driver install xcuitest which will install Appium driver for iOS.\n• Once done, verify the Appium driver installation by running the command:\n\nFor anyone who wants to test their Android apps, having Android Studio installed is a big plus. It’s the official development environment from Google and comes with all the tools you need, including the built-in AVD Manager for creating and managing Android emulators to test your apps on. You can download Android Studio directly from the official website.\n\nFor installing Software Development Kit (SDK) on your machine,\n• Once Android Studio is installed, Open it.\n• In SDK Platforms, choose the Android version you want for your emulator and Install it.\n• Deselect “Hide obsolete packages” and install “Android SDK Tools (obsolete)”. This creates a “Tools” folder in your SDK directory (usually C:\\Users\\..\\AppData\\Local\\Android\\Sdk\\tools).\n\nYou need to set up ANDROID_HOME variable path in environment variable for that follow below steps:\n• Right click on ‘This pc’ and select properties, click on ‘Advance system setting’\n• In System properties click on ‘Environment variables’ then in system variables click on ‘new’\n• Now add “ANDROID_HOME” in variable name, and “C:\\Users\\..\\AppData\\Local\\Android\\Sdk” (Your system’s SDK path) in variable value,\n• Now double click on ‘path’ variable and add these paths after clicking on ‘New’ button and add below path and then click on ‘OK’\n• Path setup in MAC : Run below commands in terminal\n\nWhat is an AVD?\n\nAn AVD stands for Android Virtual Device. It’s basically a software program that mimics an actual Android phone, tablet, or other device. You can think of it as a simulated Android system running on your computer. AVDs are created and managed through the Android Virtual Device Manager, a tool included with Android Studio.\n\nHere’s why AVDs are useful:\n• Test Apps: Developers use AVDs to test their Android applications before releasing them to the public. This lets them see how the app behaves on different screen sizes, operating systems, and hardware configurations.\n• Simulate Different Devices: Since AVDs are configurable, you can create them to match a wide range of Android devices. This is helpful for making sure your app works well on a variety of phones and tablets.\n• Safe Environment: Testing with AVDs is safer than using a physical device. If something goes wrong during testing, it won’t harm your real phone.\n\nHow to set up an AVD:\n• Open the Device Manager and click on + icon >\n• ‘System Image’ window will appear > Select the system image for a particular API level, and then click Next.\n• ‘Verify Configuration’ window will appear > Change the AVD properties as needed, and then click Finish\n• The new AVD appears in the Virtual tab of the Device Manager and the target device menu.\n\nHow to start an emulator from the command line\n• emulator -list-avds : You can use this command to list all of the AVDs that are installed on your computer.\n• emulator -help : You can use this command to get more information about the emulator command.\n• emulator -verbose : You can use this command to start the emulator in verbose mode, which will provide more information about the startup process.\n• emulator -no-window : You can use this command to start the emulator without displaying a window. This can be useful if you want to run the emulator in the background.\n• appium driver update uiautomator2 : You can use this command to update appium driver.\n• appium driver uninstall uiautomator2 : You can use this command to uninstall appium driver.\n• Appium-doctor is a test environment that identifies and fixes common configuration issues before starting Appium. It’s a node module that can be used to check if all the prerequisites for installing Appium are met. To install it, you can use the below command.\n• appium driver doctor <driver_name> : To check if machine is setup properly to run on Android devices\n\nTo identify individual elements, Know exactly where each element sits on the screen, making automation script creation a breeze ,Let Appium Inspector help you write automation scripts faster by generating code snippets based on your interactions with the app.\n• Download Appium Desktop for your specific operating system from the official website.\n• Once the installation is complete, open Appium Inspector.Appium GUI window would look like this.\n• In the “Desired Capabilities” section, enter the capabilities required to connect to the device. Note: The values for “deviceName”, “appPackage”, and “appActivity” may vary depending on the device and the application you are testing. For other desired capabilities for your emulator, you can refer to official doc.\n• To add the first capability, type “appium:automationName” in the Name field and “UiAutomator2” in the Value field. Your screen would now look like this (note that the JSON Representation block would automatically show the capability that you have added just now).\n• Now click on the ‘+’ icon, so that a new blank row gets displayed.\n• Add the second capability (appium:appPackage) in this row.\n• Keep on adding new rows till you add all the necessary capabilities. Your screen should now look like below image.\n• At the bottom of the screen, where you entered all the Desired Capabilities, click on the ‘Save As…’ button.\n• You would see a popup asking for the name of the Capability set ,enter any name you wish to use and click on Save button. The capability set would get saved.\n• Click on Saved Capabilities Sets tab. You will see that the capability set you saved just now is displayed.\n• First of all make sure that you’ve started Android Emulator and Appium server.\n• To start Appium Desktop Inspector, click on the Start Session button.\n• Appium window would display the screenshot of the General Store app together with its Object Hierarchy Dump.\n• You can also notice that the General Store app has been opened on your mobile emulator as well.\n• Appium Desktop Inspector utilises various methods to identify mobile app elements. This can include the following:\n\nWe can build a Maven project in IntelliJ by doing the following:\n• In New Project Popup window, provide a project name\n\nAfter create a project with Maven build system, pom.xml file will automatically generated under project structure and the file will look like as below:\n\nIn order to create our first test case, we would need the following dependency\n• Add below Appium Java Client dependency in pom.xml file. Take the latest dependencies from maven repository official site.\n• Start the appium server as explained above.\n• Start the emulator and appium inspector as explained above.\n• In IntelliJ, Open the folder src/main/java and create a new java class file within it and write our first test as shown below:\n• Get Ready: We tell the test what kind of device to use (Android), how to control the app (UiAutomator2), and where to find the app we want to test in terms of desired capabilities..\n• Desired Capabilities : Which is a concept explained earlier in this blog..It is a type of key-value combination information, which tells the Appium about our device. These capabilities are essential for establishing a connection with the emulator or physical device during test automation.\n• Connect and Launch: We connect to the Appium server and use it to open the app on the device. We also set a short wait time in case the app takes a moment to load.\n• Play the User: The code acts like a user by finding buttons, text fields, and other elements on the screen. It then enters text, clicks buttons, and scrolls through lists just like a real person would.\n• Check the Work: Finally, the code makes sure everything works as planned. It grabs the title of the first product on the list and compares it to what we expect (like “Air Jordan 4 Retro”). If they don’t match, it means something went wrong, and the test fails.\n\nBelow is a screenshot of the application page for which we wrote the above test script using appium with java.\n\nOnce the code is written, you can execute/run it by right clicking on the test and clicking on ‘Run’. It will launch the mobile app on the connected device or emulator and perform the actions specified in the test script. Once the execution is complete you can see the execution logs in the console as shown below\n\nAppium, a popular tool for mobile app automation, offers several advantages despite its limitations. One advantage is its cross-platform capability, allowing developers to write tests in a single language (like Java, Python, or JavaScript) and run them on multiple platforms like Android and iOS. This saves time and effort in writing separate tests for each platform. However, Appium also has some shortcomings. One limitation is its complexity in setup and configuration, especially for beginners. It requires installing various dependencies and setting up the environment correctly, which can be challenging. Additionally, Appium’s documentation and community support, while extensive, may sometimes lack clarity or timely solutions to specific issues, leading to potential roadblocks in the automation process.\n\nAppium and Java together create a powerful solution for automating mobile app testing, saving time and resources throughout the development process. This allows you to deliver high-quality apps. This guide has equipped you to begin your journey by setting up your environment and writing your first tests. But this is just the start! As you explore further, Appium can integrate with other tools and test different app types, allowing you to build a robust testing process. By embracing Appium and Java, you can automate repetitive tasks, find bugs early on, and deliver exceptional mobile apps with confidence. So start your Appium and Java testing adventure today!\n\nKeep practicing and exploring to master these powerful tools further with Jignect.\n\nWitness how our meticulous approach and cutting-edge solutions elevated quality and performance to new heights. Begin your journey into the world of software testing excellence. To know more refer to Tools & Technologies & QA Services.\n\nIf you would like to learn more about the awesome services we provide, be sure to reach out."
    },
    {
        "link": "https://appium.io/docs/en/2.0",
        "document": "Welcome to the Appium documentation! Appium is an open-source project and ecosystem of related software, designed to facilitate UI automation of many app platforms, including mobile (iOS, Android, Tizen), browser (Chrome, Firefox, Safari), desktop (macOS, Windows), TV (Roku, tvOS, Android TV, Samsung), and more.\n\nIf you're new to Appium, it's recommended that you start off with the Introduction, then move on to the Quickstart. And you can always find Appium's code on GitHub at appium/appium.\n\nWhat is Appium for?\n\nAppium is used mostly in the field of software test automation, to help determine whether the functionality of a given app is working as expected. In contrast to other types of software testing, UI automation allows testers to write code that walks through user scenarios in the actual UI of an application, mimicking as closely as possible what happens in the real world while enabling the various benefits of automation, including speed, scale, and consistency.\n\nAppium aims to provide a set of tools that support this kind of automation in a standard way across any number of platforms. Most platforms come with tools that allow UI automation at some level, but these are usually platform-specific and require specialized knowledge and specific programming language experience and toolchains. Appium tries to unify all these automation technology under a single stable interface, accessible via most popular programming languages (you can write Appium scripts in Java, Python, Ruby, JS, and more).\n\nTo learn more about how Appium accomplishes this goal, and the various components involved, have a read through our Introduction.\n\nThis documentation is a great way to learn more about Appium:\n• Check out the Introduction first to make sure you understand all the concepts involved in Appium.\n• Go through the Quickstart to get set up and run a basic Android test.\n• Have a look at the various guides and references.\n• Using Appium for a real project means using an Appium driver for a specific platform, so you'll want to have a look at the Ecosystem page where we keep links to the drivers and plugins you might want to use; you can refer to those projects for specific information about using Appium for a given platform.\n\nYou can also check out a list of third-party Resources to explore Appium around the web.\n\nAppium is open source, available under an Apache 2.0 license. Appium's copyright is held by the OpenJS Foundation, and Appium receives contributions from many companies across several software industries, regardless of their competitive status. (3rd-party drivers and plugins are available under the licenses provided by their authors.)\n\nAs such, we welcome contributions! The project moves forward in relation to the investment of contributions of code, documentation, maintenance, and support from companies and volunteers. To learn more about contributing, check out our GitHub repo at appium/appium and read through our Contributing guides."
    }
]