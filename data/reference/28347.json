[
    {
        "link": "https://phoenixnap.com/kb/bash-heredoc",
        "document": "A here document (HereDoc) is a section of code that acts as a separate file. A HereDoc is a multiline string or a file literal for sending input streams to other commands and programs.\n\nHereDocs are especially useful when redirecting multiple commands at once, which helps make Bash scripts neater and easier to understand.\n\nThis article teaches you the basics of using HereDoc notation and some typical use cases.\n• Access to the command line/terminal as a sudo user.\n\nThe syntax for writing a HereDoc is:\n\nIt consists of the following elements:\n• is optional. Works for any command that accepts redirection.\n• is the redirection operator for forwarding a HereDoc to the .\n• in the first line defines a HereDoc delimiter token. , , and are most common, but any multicharacter word that won't appear in the body works. Omit single quotes on the first line to allow command and variable expansion.\n• The in the last line indicates the end of a HereDoc. Use the same word from the first line without the leading whitespaces.\n\nThe HereDoc itself contains any number of lines with strings, variables, commands, and other inputs.\n\nThis section showcases how to use the HereDoc notation in various situations. The most common use case is with the cat command.\n\nOpen the terminal and enter the following text, pressing Enter after each line:\n\nThe command reads the HereDoc and writes the contents to the terminal.\n\nA HereDoc accepts the use of variables and reads them.\n\nTo see how this works, create two variables in the terminal:\n\nPass the HereDoc to a command to print the two variables along with an environment variable:\n\nAll the variables expand, and their respective values print to the terminal.\n\nHereDocs accept command substitution. Run the following code in the terminal line by line to see the results:\n\nEncompass each command in to evaluate a statement and fetch the results. Omitting treats the text as a string.\n\nAdd single or double quotes to the first delimiter to ignore variable and command expansion in a HereDoc.\n\nAdding quotes to the delimiter treats the contents as a HereDoc literal.\n\nUse piping or redirecting to forward the command results to another command. For example, create a Bash script and add the following contents to pipe a command:\n\nAlternatively, use redirect notation to achieve the same result:\n\nRun the Bash script to see the results.\n\nIn both cases, the output from the and a HereDoc command pipes (or redirects) to the command. As a result, the script decodes the message from the HereDoc.\n\nHereDoc allows writing multiline documents through one command.\n\nTo create a file and save the HereDoc contents, use the following format:\n\nIf the document does not exist, the command creates it. Check the file contents to confirm:\n\nAdd a dash ( ) after redirection to suppress leading tabs. For example, create and run the following script:\n\nWithout tab suppression, the message prints to the console with indentation. Adding the dash removes the tab indent and outputs the message without the leading spaces.\n\nWhen working with a HereDoc inside statements and loops, keep in mind the following behavior:\n• Code inside statements and loops is indented. Add a dash after the redirect operator to print messages from a HereDoc without indentation.\n• The ending delimiter cannot have spaces or indentations before it.\n\nTry the following example code to see how to use a HereDoc inside an if statement:\n\nThe dash ensures the indents don't show up when the program runs. The ending delimiter is not indented, and adding spaces causes an error.\n\nA HereDoc with the null command ( ) creates the effect of block comments in Bash scripts.\n\nUsing HereDoc notation as a block comment is unconventional. In general, Bash does not support block commenting.\n\nUsing quotation marks on the delimiter is equivalent in this case.\n\nAdd parameters to a function by forwarding information through a HereDoc. For example, create a function to read lines and add information through the HereDoc:\n\nThe function stores the information provided by the HereDoc into variables.\n\nRun the script to print the variable values to the terminal.\n\nA HereDoc is convenient for executing multiple commands on a remote machine. Pass a HereDoc to the SSH connection to run multiple commands.\n\nThe command prints the local and remote users to the console.\n\nSFTP helps transfer data securely via the SSH protocol. Forward a HereDoc to run multiple SFTP commands automatically:\n\nThe code uploads a sample file to the remote machine.\n\nAfter going through the examples in this guide, you know how to use HereDoc notation in various situations. HereDoc helps pass multiple commands at once as input for different commands.\n\nNext, learn about advanced text processing with the AWK command."
    },
    {
        "link": "https://stackoverflow.com/questions/7046381/multiline-syntax-for-piping-a-heredoc-is-this-portable",
        "document": "Yes, the POSIX standard allows this. According to the 2008 version:\n\nThe here-document shall be treated as a single word that begins after the next and continues until there is a line containing only the delimiter and a , with no characters in between. Then the next here-document starts, if there is one.\n\nAnd includes this example of multiple \"here-documents\" in the same line:\n\nSo there is no problem doing redirections or pipes. Your example is similar to something like this:\n\nAnd the shell grammar (further down on the linked page) includes these definitions:\n\nSo a pipe symbol can be followed by an end-of-line and still be considered part of a pipeline."
    },
    {
        "link": "https://unix.stackexchange.com/questions/478261/here-documents-as-multiple-lines-command-within-the-bash",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/15421331/reading-a-bash-variable-from-a-multiline-here-document",
        "document": "I think the problem is that is seeing end-of-file before it sees an ASCII NUL character. However, if that were true, the following should exit with 0:\n\nIn lieu of a real fix, I can offer the following hack. Since it prevents any command from actually returning 0, it shouldn't break your login script:\n\nstill exits 1, but this merely causes the shell to execute the command, which is guaranteed to exit 0."
    },
    {
        "link": "https://tldp.org/LDP/abs/html/here-docs.html",
        "document": "A limit string delineates (frames) the command list. The special symbol << precedes the limit string. This has the effect of redirecting the output of a command block into the of the program or command. It is similar to , where contains\n\n#!/bin/bash # Noninteractive use of 'vi' to edit a file. # Emulates 'sed'. E_BADARGS=85 if [ -z \"$1\" ] then echo \"Usage: `basename $0` filename\" exit $E_BADARGS fi TARGETFILE=$1 # Insert 2 lines in file, then save. #--------Begin here document-----------# vi $TARGETFILE <<x23LimitStringx23 i This is line 1 of the example file. This is line 2 of the example file. ^[ ZZ x23LimitStringx23 #----------End here document-----------# # Note that ^[ above is a literal escape #+ typed by Control-V <Esc>. # Bram Moolenaar points out that this may not work with 'vim' #+ because of possible problems with terminal interaction. exit\n\n#!/bin/bash # 'echo' is fine for printing single line messages, #+ but somewhat problematic for for message blocks. # A 'cat' here document overcomes this limitation. cat <<End-of-message ------------------------------------- This is line 1 of the message. This is line 2 of the message. This is line 3 of the message. This is line 4 of the message. This is the last line of the message. ------------------------------------- End-of-message # Replacing line 7, above, with #+ cat > $Newfile <<End-of-message #+ ^^^^^^^^^^ #+ writes the output to the file $Newfile, rather than to stdout. exit 0 #-------------------------------------------- # Code below disabled, due to \"exit 0\" above. # S.C. points out that the following also works. echo \"------------------------------------- This is line 1 of the message. This is line 2 of the message. This is line 3 of the message. This is line 4 of the message. This is the last line of the message. -------------------------------------\" # However, text may not include double quotes unless they are escaped.\n\n#!/bin/bash # Same as previous example, but... # The - option to a here document <<- #+ suppresses leading tabs in the body of the document, #+ but *not* spaces. cat <<-ENDOFMESSAGE This is line 1 of the message. This is line 2 of the message. This is line 3 of the message. This is line 4 of the message. This is the last line of the message. ENDOFMESSAGE # The output of the script will be flush left. # Leading tab in each line will not show. # Above 5 lines of \"message\" prefaced by a tab, not spaces. # Spaces not affected by <<- . # Note that this option has no effect on *embedded* tabs. exit 0\n\n#!/bin/bash # generate-script.sh # Based on an idea by Albert Reiner. OUTFILE=generated.sh # Name of the file to generate. # ----------------------------------------------------------- # 'Here document containing the body of the generated script. ( cat <<'EOF' #!/bin/bash echo \"This is a generated shell script.\" # Note that since we are inside a subshell, #+ we can't access variables in the \"outside\" script. echo \"Generated file will be named: $OUTFILE\" # Above line will not work as normally expected #+ because parameter expansion has been disabled. # Instead, the result is literal output. a=7 b=3 let \"c = $a * $b\" echo \"c = $c\" exit 0 EOF ) > $OUTFILE # ----------------------------------------------------------- # Quoting the 'limit string' prevents variable expansion #+ within the body of the above 'here document.' # This permits outputting literal strings in the output file. if [ -f \"$OUTFILE\" ] then chmod 755 $OUTFILE # Make the generated file executable. else echo \"Problem in creating file: \\\"$OUTFILE\\\"\" fi # This method also works for generating #+ C programs, Perl programs, Python programs, Makefiles, #+ and the like. exit 0\n\nIt is possible to set a variable from the output of a here document. This is actually a devious form of command substitution.\n\n#!/bin/bash # commentblock.sh : <<COMMENTBLOCK echo \"This line will not echo.\" This is a comment line missing the \"#\" prefix. This is another comment line missing the \"#\" prefix. &*@!!++= The above line will cause no error message, because the Bash interpreter will ignore it. COMMENTBLOCK echo \"Exit value of above \\\"COMMENTBLOCK\\\" is $?.\" # 0 # No error shown. echo # The above technique also comes in useful for commenting out #+ a block of working code for debugging purposes. # This saves having to put a \"#\" at the beginning of each line, #+ then having to go back and delete each \"#\" later. # Note that the use of of colon, above, is optional. echo \"Just before commented-out code block.\" # The lines of code between the double-dashed lines will not execute. # =================================================================== : <<DEBUGXXX for file in * do cat \"$file\" done DEBUGXXX # =================================================================== echo \"Just after commented-out code block.\" exit 0 ###################################################################### # Note, however, that if a bracketed variable is contained within #+ the commented-out code block, #+ then this could cause problems. # for example: #/!/bin/bash : <<COMMENTBLOCK echo \"This line will not echo.\" &*@!!++= ${foo_bar_bazz?} $(rm -rf /tmp/foobar/) $(touch my_build_directory/cups/Makefile) COMMENTBLOCK $ sh commented-bad.sh commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set # The remedy for this is to strong-quote the 'COMMENTBLOCK' in line 49, above. : <<'COMMENTBLOCK' # Thank you, Kurt Pfeifle, for pointing this out."
    },
    {
        "link": "https://stackoverflow.com/questions/17189237/how-can-i-write-and-append-using-echo-command-to-a-file",
        "document": "If you want to have quotes, then you must escape them using the backslash character.\n\nThe same holds true if you i.e. also want to write the itself, as it may cause side effects. So you have to use\n\nAnother option would be to use The `'' instead of quotes.\n\nHowever in this case variable substition doesn't work, so if you want to use variables you have to put them outside."
    },
    {
        "link": "https://phoenixnap.com/kb/bash-append-to-file",
        "document": "Bash is one of the most versatile shell scripting languages that provides users with many data manipulation features. It is versatile and offers a convenient way to append content to files without overwriting old data.\n\nAppending to files is especially useful when working with log or configuration files, where you want to preserve the file history and add new information.\n\nIn this tutorial, you will learn various techniques for appending content to files using Bash.\n\nAppend to File in Bash With >> Redirection Operator\n\nOne of the ways to append text to a file in Bash is to use the redirection operator.\n\nThe redirection operator is used in command-line interfaces and shell scripting to control the input and output of commands. Use the operator to redirect a command's output to the end of the specified file. If the file doesn't exist, the system creates it.\n\nThe difference between the and operators is that the operator overwrites any existing contents of the specified file with the command's output. The operator only appends the output without overwriting anything.\n\nWe will test the redirection using the echo command that prints text to standard output. We can redirect that output to append it to a file.\n\nReplace with the file you want to append to. For example:\n\nCheck if the content is in the file using the cat command:\n\nThe output shows that the specified content has been appended to the file.\n\nAnother command that prints text to standard output is printf. The command allows you to format and print text or variables with more control over the output and formatting. That way, you can produce complex outputs and specify the formatting.\n\nThe command utilizes the output of the command and appends it to the specified file, as in the command output.\n\nIf you want to append multiple lines of output to a file, use a Here document (HereDoc). HereDocs are useful when redirecting multiple commands at once.\n\nFor example, pass the contents using the command and append it to a file:\n\nThe command reads the HereDoc and writes the contents to standard output, which is then redirected to the specified file.\n\nAppend to File in Bash With tee Command\n\nThe Linux tee command is a command-line utility that reads from the standard input and writes to both standard output and one or more files at the same time. Use the command with the ( ) option to append the output to a file instead of overwriting it by default.\n\nFor example, use the command to print something to standard output and pipe the output to the command:\n\nThe advantage of using the command instead of the redirection operator is that allows you to simultaneously append text to multiple files and write to files owned by other users if used with .\n\nTo append text to multiple files, specify the files as arguments:\n\nThe command appends the content to all the specified files.\n\nThis tutorial showed how to append text to a file or multiple files in Bash using several methods. Appending to a file in Bash is a straightforward process that can be accomplished using the redirect operator ( ) or the command without overwriting previous content.\n\nNext, learn about Bash math operations, or take a look at our Bash HereDoc tutorial with useful examples."
    },
    {
        "link": "https://superuser.com/questions/154936/echo-text-with-new-line-in-bash",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://unix.stackexchange.com/questions/77277/how-to-append-multiple-lines-to-a-file",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://linuxize.com/post/bash-append-to-file",
        "document": "When working with Bash, there might be times when you need to append text to a file. Fortunately, there are multiple ways to accomplish this task. This article explains some of them.\n\nTo append text to a file, you need to have write permissions to it. Otherwise, you will receive a permission denied error.\n\nAppend to a File using the Redirection Operator ( ) #\n\nRedirection allows you to capture the output from a command and send it as input to another command or file. The redirection operator appends the output to a given file.\n\nThere are a number of commands that you can use to print text to the standard output and redirect it to the file. The two most commonly used commands for this purpose are and .\n\nTo append text to a file, run the command that prints the text and specify the name of the file after the redirection operator:\n\nWhen used with the option, the command interprets the backslash-escaped characters such as newline :\n\nTo produce more complex output, you can use the command, which allows you to specify the formatting of the output:\n\nAnother way to append text to a file is to use the Here document (Heredoc). It is a type of redirection that allows you to pass multiple lines of input to a command.\n\nFor instance, you can pass the content to the command and append it to a file:\n\nYou can append the output of any command to a file. Here is an example with the command:\n\nWhen appending to a file using a redirection, be careful not to use the operator to overwrite an important existing file.\n\nAppend to a File using the Command #\n\nis a Linux command-line utility that reads from the standard input and writes to both standard output and one or more files at the same time.\n\nBy default, the command overwrites the specified file. To append the output to the file use with the ( ) option:\n\nIf you don’t want to write to the standard output, redirect it to :\n\nThe advantage of using the command over the operator is that allows you to simultaneously append text to multiple files and write to files owned by other users in conjunction with .\n\nTo append text to a file that you don’t have write permissions to, prepend before as shown below:\n\nreceives the output of the command, elevates the sudo permissions, and writes to the file.\n\nTo append text to more than one file, specify the files as arguments to the command:\n\nIf you’re working with Linux and need to add some text to an existing file, you have a couple of options. One way is to use the redirection operator, which will append the text to the end of the file without overwriting any existing content. Another option is to use the command, which not only appends the text to the file, but also displays it on the screen as it’s being added.\n\nIf you have any questions or feedback, feel free to leave a comment."
    }
]