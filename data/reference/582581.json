[
    {
        "link": "https://geeksforgeeks.org/enum-in-java",
        "document": "In Java,Enumerations or Java Enum serve the purpose of representing a group of named constants in a programming language. Java Enums are used when we know all possible values at compile time, such as choices on a menu, rounding modes, command-line flags, etc.\n\nWhat is Enumeration or Enum in Java?\n\nA Java enumeration is a class type. Although we don’t need to instantiate an enum using new, it has the same capabilities as other classes. This fact makes Java enumeration a very powerful tool. Just like classes, you can give them constructors, add instance variables and methods, and even implement interfaces.\n\nOne thing to keep in mind is that, unlike classes, enumerations neither inherit other classes nor can get extended(i.e become superclass). We can also add variables, methods, and constructors to it. The main objective of an enum is to define our own data types(Enumerated Data Types).\n\nEnum declaration can be done outside a class or inside a class but not inside a method.\n• None The first line inside the enum should be a of constants and then other things like methods, variables, and constructors.\n• None , it is recommended that we name constant with all capital letters\n\nThere are certain properties followed by Enum as mentioned below:\n• Class Type: Every enum is internally implemented using the\n• Enum Constants: Each enum constant represents an object of type enum.\n• Switch Statements: Enum types can be used in switch statements.\n• Implicit Modifiers: . Since it is static, it can be accessed using the enum name. Since it is final, enums cannot be extended.\n\nBelow is the implementation of the above properties:\n\nEnums can have a function, allowing them to be invoked directly from the command line.\n\nBelow is the implementation of the above property:\n\nThe above program will not run on online compiler. To run this program, save it as and use the command to compile and execute.\n\nWe can iterate over the Enum using the method, which returns an array of enum constants.\n\nBelow is the implementation of the loop through Enum:\n\nEnums can be used in switch statements to handle different cases based on the enum constants.\n• java.lang.Enum class . As a class can only extend one parent in Java, an enum cannot extend anything else.\n• None Enums can contain constructors, which are called separately for each enum constant at the time of enum class loading.\n• None We can’t create enum objects explicitly and hence we can’t invoke the enum constructor directly.\n\nEnums can have both concrete and abstract methods. If an enum class has an abstract method, each enum constant must implement it.\n\nWhen combined with classes, enum can serve as powerful tool for organising program.\n\nThe EnumTest class in above code is created with member of type Day. It has constructor which takes Day enum as an argument and assigns it.\n\nThe class has method tellItLikeItIs(), which prints message based on value of day.\n\nThe main method includes objects of EnumTest using different Day enum values and calling tellItLikeItIs() method on each.\n• None Create an enum for each day of a week\n\n3. Implement the abstract method in each enum\n\n4. Create a class called EnumTest with an instance variable day that we had just created.\n\n5. Create a main method in which create the object and call the method.\n\nNow combine all above code :\n\nCan we create the instance of Enum by the new keyword?\n\nCan we have an abstract method in the Enum?\n\nWhat is the purpose of the values() method in the enum?\n\nWhat is the purpose of the valueOf() method in the enum?\n\nWhat is the purpose of the ordinal() method in the enum?\n\nWrite a program in Java to describe the use of values(), valueOf(), and ordinal() methods in the enum.\n\nNext Article on enum: Enum with Customized Value in Java"
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAn enum type is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.\n\nBecause they are constants, the names of an enum type's fields are in uppercase letters.\n\nIn the Java programming language, you define an enum type by using the keyword. For example, you would specify a days-of-the-week enum type as:\n\nYou should use enum types any time you need to represent a fixed set of constants. That includes natural enum types such as the planets in our solar system and data sets where you know all possible values at compile timefor example, the choices on a menu, command line flags, and so on.\n\nHere is some code that shows you how to use the enum defined above:\n\nJava programming language enum types are much more powerful than their counterparts in other languages. The declaration defines a class (called an enum type). The enum class body can include methods and other fields. The compiler automatically adds some special methods when it creates an enum. For example, they have a static method that returns an array containing all of the values of the enum in the order they are declared. This method is commonly used in combination with the for-each construct to iterate over the values of an enum type. For example, this code from the class example below iterates over all the planets in the solar system.\n\nIn the following example, is an enum type that represents the planets in the solar system. They are defined with constant mass and radius properties.\n\nEach enum constant is declared with values for the mass and radius parameters. These values are passed to the constructor when the constant is created. Java requires that the constants be defined first, prior to any fields or methods. Also, when there are fields and methods, the list of enum constants must end with a semicolon.\n\nNote: The constructor for an enum type must be package-private or private access. It automatically creates the constants that are defined at the beginning of the enum body. You cannot invoke an enum constructor yourself.\n\nIn addition to its properties and constructor, has methods that allow you to retrieve the surface gravity and weight of an object on each planet. Here is a sample program that takes your weight on earth (in any unit) and calculates and prints your weight on all of the planets (in the same unit):\n\nIf you run from the command line with an argument of 175, you get this output:"
    },
    {
        "link": "https://w3schools.com/java/java_enums.asp",
        "document": "An is a special \"class\" that represents a group of constants (unchangeable variables, like variables).\n\nTo create an , use the keyword (instead of class or interface), and separate the constants with a comma. Note that they should be in uppercase letters:\n\nYou can also have an inside a class:\n\nEnums are often used in statements to check for corresponding values:\n\nThe enum type has a method, which returns an array of all enum constants. This method is useful when you want to loop through the constants of an enum:"
    },
    {
        "link": "https://simplilearn.com/tutorials/java-tutorial/enum-in-java",
        "document": ""
    },
    {
        "link": "https://freecodecamp.org/news/java-enum-enumeration-in-java-example",
        "document": "An enumeration (enum for short) in Java is a special data type which contains a set of predefined constants.\n\nYou'll usually use an when dealing with values that aren't required to change, like days of the week, seasons of the year, colors, and so on.\n\nIn this article, we'll see how to create an and how to assign its value other variables. We'll also see how to use an in statements or loop through its values.\n\nHow to Create an Enum in Java\n\nTo create an , we use the keyword, similar to how you'd create a class using the keyword.\n\nIn the code above, we created an called . You may notice that the values of this are all written in uppercase – this is just a general convention. You will not get an error if the values are lowercase.\n\nEach value in an is separated by a comma.\n\nNext, we're going to create a new variable and assign one of the values of our to it.\n\nThis is similar to initializing any other variable. In the code above, we initialized a variable and assigned one of the values of an to it using the dot syntax: .\n\nNote that we can create our inside the class and the code will still work. That is:\n\nIf we want to get the index number of any of the values, we would have to use the method. Here is an example:\n\nfrom the code above returns 0.\n\nHow to Use an Enum in a Switch Statement\n\nIn this section, we'll se how we can use an in a statement.\n\nHere is an example:\n\nThis is a very basic example of how we can use an in a statement. We would get \"The color is yellow\" printed to the console because that is the only that matches the statement's condition.\n\nHow to Loop Through the Values of an Enum\n\nin Java has a method that returns an array of the values of an . We're going to use a for-each loop to iterate through and print the values of our .\n\nHere's how we can do that:\n\nIn this article, we got to know what an is in Java, how to create it, and how to assign its values to other variables.\n\nWe also saw how to use use the type with a statement and how we can loop through the values of an ."
    },
    {
        "link": "https://docs.python.org/3/howto/enum.html",
        "document": "An is a set of symbolic names bound to unique values. They are similar to global variables, but they offer a more useful , grouping, type-safety, and a few other features.\n\nThey are most useful when you have a variable that can take one of a limited selection of values. For example, the days of the week:\n\nOr perhaps the RGB primary colors:\n\nAs you can see, creating an is as simple as writing a class that inherits from itself.\n\nDepending on the nature of the enum a member’s value may or may not be important, but either way that value can be used to get the corresponding member:\n\nAs you can see, the of a member shows the enum name, the member name, and the value. The of a member shows only the enum name and member name:\n\nThe type of an enumeration member is the enum it belongs to:\n\nEnum members have an attribute that contains just their :\n\nLikewise, they have an attribute for their :\n\nUnlike many languages that treat enumerations solely as name/value pairs, Python Enums can have behavior added. For example, has two methods for returning the weekday: and . The difference is that one of them counts from 0-6 and the other from 1-7. Rather than keep track of that ourselves we can add a method to the enum to extract the day from the instance and return the matching enum member:\n\nThe complete enum now looks like this:\n\nNow we can find out what today is! Observe:\n\nOf course, if you’re reading this on some other day, you’ll see that day instead.\n\nThis enum is great if our variable only needs one day, but what if we need several? Maybe we’re writing a function to plot chores during a week, and don’t want to use a – we could use a different type of :\n\nWe’ve changed two things: we’re inherited from , and the values are all powers of 2.\n\nJust like the original enum above, we can have a single selection:\n\nBut also allows us to combine several members into a single variable:\n\nYou can even iterate over a variable:\n\nOkay, let’s get some chores set up:\n\nAnd a function to display the chores for a given day:\n\nIn cases where the actual values of the members do not matter, you can save yourself some work and use for the values:\n\nMost of the examples above use integers for enumeration values. Using integers is short and handy (and provided by default by the Functional API), but not strictly enforced. In the vast majority of use-cases, one doesn’t care what the actual value of an enumeration is. But if the value is important, enumerations can have arbitrary values. Enumerations are Python classes, and can have methods and special methods as usual. If we have this enumeration: # self is the member here # cls here is the enumeration The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods ( , , etc.), descriptors (methods are also descriptors), and variable names listed in . Note: if your enumeration defines and/or , any value(s) given to the enum member will be passed into those methods. See Planet for an example. The method, if defined, is used during creation of the Enum members; it is then replaced by Enum’s which is used after class creation for lookup of existing members. See When to use __new__() vs. __init__() for more details.\n\nThe class is callable, providing the following functional API: The semantics of this API resemble . The first argument of the call to is the name of the enumeration. The second argument is the source of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the parameter to specify a different starting value). A new class derived from is returned. In other words, the above assignment to is equivalent to: The reason for defaulting to as the starting number and not is that is in a boolean sense, but by default enum members all evaluate to . Pickling enums created with the functional API can be tricky as frame stack implementation details are used to try and figure out which module the enumeration is being created in (e.g. it will fail if you use a utility function in a separate module, and also may not work on IronPython or Jython). The solution is to specify the module name explicitly as follows: If is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled. The new pickle protocol 4 also, in some circumstances, relies on being set to the location where pickle will be able to find the class. For example, if the class was made available in class SomeData in the global scope:\n• None value: What the new enum class will record as its name.\n• None names: The enum members. This can be a whitespace- or comma-separated string (values will start at 1 unless otherwise specified): or an iterator of (name, value) pairs:\n• None module: name of module where new enum class can be found.\n• None qualname: where in module new enum class can be found.\n• None type: type to mix in to new enum class.\n• None start: number to start counting at if only names are passed in. Changed in version 3.5: The start parameter was added.\n\nThe first variation of that is provided is also a subclass of . Members of an can be compared to integers; by extension, integer enumerations of different types can also be compared to each other: However, they still can’t be compared to standard enumerations: values behave like integers in other ways you’d expect: The second variation of that is provided is also a subclass of . Members of a can be compared to strings; by extension, string enumerations of different types can also be compared to each other. The next variation of provided, , is also based on . The difference being members can be combined using the bitwise operators (&, |, ^, ~) and the result is still an member, if possible. Like , members are also integers and can be used wherever an is used. Any operation on an member besides the bit-wise operations will lose the membership. Bit-wise operations that result in invalid values will lose the membership. See for details. It is also possible to name the combinations: Named combinations are considered aliases. Aliases do not show up during iteration, but can be returned from by-value lookups. Another important difference between and is that if no flags are set (the value is 0), its boolean evaluation is : Because members are also subclasses of they can be combined with them (but may lose membership: The negation operator, , always returns an member with a positive value: members can also be iterated over: The last variation is . Like , members can be combined using the bitwise operators (&, |, ^, ~). Unlike , they cannot be combined with, nor compared against, any other enumeration, nor . While it is possible to specify the values directly it is recommended to use as the value and let select an appropriate value. Like , if a combination of members results in no flags being set, the boolean evaluation is : Individual flags should have values that are powers of two (1, 2, 4, 8, …), while combinations of flags will not: Giving a name to the “no flags set” condition does not change its boolean value: members can also be iterated over: For the majority of new code, and are strongly recommended, since and break some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). and should be used only in cases where and will not do; for example, when integer constants are replaced with enumerations, or for interoperability with other systems. While is part of the module, it would be very simple to implement independently: # or Enum instead of ReprEnum This demonstrates how similar derived enumerations can be defined; for example a that mixes in instead of .\n• None When subclassing , mix-in types must appear before the class itself in the sequence of bases, as in the example above.\n• None Mix-in types must be subclassable. For example, and are not subclassable and will throw an error during Enum creation if used as the mix-in type.\n• None While can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. above. This restriction does not apply to mix-ins which only add methods and don’t specify another type.\n• None When another data type is mixed in, the attribute is not the same as the enum member itself, although it is equivalent and will compare equal.\n• None A is a mixin that defines , or a\n• None %-style formatting: and call the class’s and respectively; other codes (such as or for IntEnum) treat the enum member as its mixed-in type.\n• None Formatted string literals, , and will use the enum’s method. Because , , and are designed to be drop-in replacements for existing constants, their method has been reset to their data types’ method.\n\nWhen to use vs. ¶ must be used whenever you want to customize the actual value of the member. Any other modifications may go in either or , with being preferred. For example, if you want to pass several items to the constructor, but only want one of them to be the value: Coordinate with binary codes that can be indexed by the int code. Do not call , as the lookup-only is the one that is found; instead, use the data type directly. is a read-only ordered mapping of : items. It is only available on the class. , if specified, must create and return the enum members; it is also a very good idea to set the member’s appropriately. Once all the members are created it is no longer used.\n• None – name of the member\n• None – value of the member; can be set in\n• None – a lookup function used when a value is not found; may be overridden\n• None – a list of names, either as a or a , that will not be transformed into members, and will be removed from the final class\n• None – used to get an appropriate value for an enum member; may be overridden\n• None – adds a new name as an alias to an existing member.\n• None – adds a new value as an alias to an existing member. See MultiValueEnum for an example. For standard classes the next value chosen is the highest value seen incremented by one. For classes the next value chosen will be the next highest power-of-two. Changed in version 3.13: Prior versions would use the last seen value instead of the highest value. To help keep Python 2 / Python 3 code in sync an attribute can be provided. It will be checked against the actual order of the enumeration and raise an error if the two do not match: In Python 2 code the attribute is necessary as definition order is lost before it can be recorded. Private names are not converted to enum members, but remain normal attributes. Enum members are instances of their enum class, and are normally accessed as . In certain situations, such as writing custom enum behavior, being able to access one member directly from another is useful, and is supported; however, in order to avoid name clashes between member names and attributes/methods from mixed-in classes, upper-case names are strongly recommended. Creating members that are mixed with other data types¶ When subclassing other data types, such as or , with an , all values after the are passed to that data type’s constructor. For example: Boolean value of classes and members¶ Enum classes that are mixed with non- types (such as , , etc.) are evaluated according to the mixed-in type’s rules; otherwise, all members evaluate as . To make your own enum’s boolean evaluation depend on the member’s value add the following to your class: If you give your enum subclass extra methods, like the Planet class below, those methods will show up in a of the member, but not of the class: Iterating over a combination of members will only return the members that are comprised of a single bit: Using the following snippet for our examples:\n• None only canonical flags are returned during iteration:\n• None negating a flag or flag set returns a new flag/flag set with the corresponding positive integer value:\n• None names of pseudo-flags are constructed from their members’ names:\n• None multi-bit flags, aka aliases, can be returned from operations:\n• None membership / containment checking: zero-valued flags are always considered to be contained: otherwise, only if all bits of one flag are in the other flag will True be returned: There is a new boundary mechanism that controls how out-of-range / invalid bits are handled: , , , and :\n• None STRICT –> raises an exception when presented with invalid values\n• None EJECT –> lose Flag status and become a normal int with the given value\n• None KEEP –> keep the extra bits\n• None extra bits do not show up in iteration\n• None extra bits do show up in repr() and str() The default for Flag is , the default for is , and the default for is (see for an example of when is needed).\n\nWhile , , , , and are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one’s own. In many use-cases, one doesn’t care what the actual value of an enumeration is. There are several ways to define this type of simple enumeration:\n• None use instances of for the value\n• None use instances of as the value\n• None use a descriptive string as the value\n• None use a tuple as the value and a custom to replace the tuple with an value Using any of these methods signifies to the user that these values are not important, and also enables one to add, remove, or reorder members without having to renumber the remaining members. Using would look like: Using would look like: This is also a good example of why you might want to write your own : Using a string as the value would look like: Using an auto-numbering would look like: To make a more general purpose , add to the signature: # this is the only change from above Then when you inherit from you can write your own to handle any extra arguments: # New color, no Pantone code yet! The method, if defined, is used during creation of the Enum members; it is then replaced by Enum’s which is used after class creation for lookup of existing members. Do not call , as the lookup-only is the one that is found; instead, use the data type directly – e.g.: An ordered enumeration that is not based on and so maintains the normal invariants (such as not being comparable to other enumerations): Raises an error if a duplicate member value is found instead of creating an alias: This is a useful example for subclassing Enum to add or change other behaviors as well as disallowing aliases. If the only desired change is disallowing aliases, the decorator can be used instead. Supports having more than one value per member: If or is defined, the value of the enum member will be passed to those methods: An example to show the attribute in use:"
    },
    {
        "link": "https://geeksforgeeks.org/enum-in-python",
        "document": "What are Enums and Why are they useful?\n\nEnumerations or Enums is a set of symbolic names bound to unique values. It can be iterated over to return its canonical members in definition order. It provides a way to create more readable and self-documenting code by using meaningful names instead of arbitrary values.\n• None Enums can be displayed as string\n• None Enums can be checked for their types using type()\n• name ” keyword is used to display the name of the enum member.\n\nWhat are the Advantages of Enum\n\nSome of the advantages of using enums include:\n• Ease of maintenance: Enums centralize the definition of name values which makes it easier to upgrade or extend the set of values as per our requirements.\n• Readability and Self-Documentation: Enums provide meaningful names to values, making the code more human-readable and self-explanatory.\n• Type safety Enums provide some level of type safety, ensuring that only valid values can be used.\n• Reduced risk of errors : Enums help prevent the use of incorrect or inconsistent values in your code, reducing the risk of bugs and errors.\n\nThis code defines an enumeration class with four members: SPRING, SUMMER, AUTUMN, and WINTER. It showcases key properties of the enum, such as accessing an enum member, its name, and value. Additionally, it demonstrates how to obtain a list of all enum members. The output reflects the name, value, type, and a list of all enum members.\n\nEnum members can be accessed in two ways:\n• By value :- In this method, the value of enum member is passed.\n• By name :- In this method, the name of the enum member is passed.\n\nA separate value or name can also be accessed using the “name” or “value” keyword.\n\nThe code defines an enumeration class ‘ with four members. It showcases how to access enum members by value and name. It demonstrates that you can obtain an enum member by specifying its value or name, and then access its name or value accordingly. This code provides examples for both value-based and name-based enum member access.\n\niterable . They can be iterated using loops\n\nIn this example, we will use for loop to print all the members of the Enum class.\n\nThe code defines an enumeration class ‘ with four members. It iterates through the enum members and prints their values and names. The output displays each enum member’s value and its fully-qualified name, providing a way to work with and display enum values.\n\nIn this example, we will show how users can hash the Enum class that can be used in dictionaries or sets.\n\nThis code uses the ‘ module to define an enumeration class ‘ with three members: dog, cat, and lion. It then creates a dictionary and assigns values to it based on enum members. Finally, it checks if the dictionary matches a specific key-value pair.\n\nEnumerations support two types of comparisons, that are:\n• Identity :- These are checked using keywords “ is is not\n\nThis code defines an enumeration class using the module with three members: dog, cat, and lion. It then performs comparisons between enum members to check for equality and inequality.\n\nWhen should I use enum in Python?\n\nWhat are the two types of enumeration?\n\nWhy use enum instead of class in Python?\n\nHow to convert enum members to strings in Python?\n\nCan we use enums as keys in dictionaries in Python?"
    },
    {
        "link": "https://realpython.com/python-enum",
        "document": "Python’s module offers a way to create enumerations, a data type allowing you to group related constants. You can define an enumeration using the class, either by subclassing it or using its functional API. This tutorial will guide you through the process of creating and using Python enums, comparing them to simple constants, and exploring specialized types like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• An enum in Python groups related constants in a single data type using the class.\n• You create enumerations by subclassing or using the module’s functional API.\n• Using over simple constants provides structure, prevents reassignment, and enhances code readability.\n• , , , and differ in their support for integer operations and bitwise flags.\n• Enums can work with data types like integers or strings, boosting their flexibility.\n\nTo follow along with this tutorial, you should be familiar with object-oriented programming and inheritance in Python.\n\nGetting to Know Enumerations in Python Several programming languages, including Java and C++, have a native enumeration or enum data type as part of their syntax. This data type allows you to create sets of named constants, which are considered members of the containing enum. You can access the members through the enumeration itself. Enumerations come in handy when you need to define an immutable and discrete set of similar or related constant values that may or may not have semantic meaning in your code. Days of the week, months and seasons of the year, Earth’s cardinal directions, a program’s status codes, HTTP status codes, colors in a traffic light, and pricing plans of a web service are all great examples of enumerations in programming. In general, you can use an enum whenever you have a variable that can take one of a limited set of possible values. Python doesn’t have an enum data type as part of its syntax. Fortunately, Python 3.4 added the module to the standard library. This module provides the class for supporting general-purpose enumerations in Python. Enumerations were introduced by PEP 435, which defines them as follows: An enumeration is a set of symbolic names bound to unique, constant values. Within an enumeration, the values can be compared by identity, and the enumeration itself can be iterated over. (Source) Before this addition to the standard library, you could create something similar to an enumeration by defining a sequence of similar or related constants. To this end, Python developers often used the following idiom: Even though this idiom works, it doesn’t scale well when you’re trying to group a large number of related constants. Another inconvenience is that the first constant will have a value of , which is falsy in Python. This can be an issue in certain situations, especially those involving Boolean tests. Note: If you’re using a Python version before 3.4, then you can create enumerations by installing the enum34 library, which is a backport of the standard-library . The aenum third-party library could be an option for you as well. In most cases, enumerations can help you avoid the drawbacks of the above idiom. They’ll also help you produce more organized, readable, and robust code. Enumerations have several benefits, some of which relate to ease of coding:\n• Allowing for conveniently grouping related constants in a sort of namespace\n• Allowing for additional behavior with custom methods that operate on either enum members or the enum itself\n• Enabling direct iteration over members, including their names and values\n• Mitigating spelling mistakes when using the members of an enumeration They also make your code robust by providing the following benefits:\n• Ensuring constant values that can’t be changed during the code’s execution\n• Guaranteeing type safety by differentiating the same value shared across several enums\n• Improving readability and maintainability by using descriptive names instead of mysterious values or magic numbers\n• Facilitating debugging by taking advantage of readable names instead of values with no explicit meaning\n• Providing a single source of truth and consistency throughout the code Now that you know the basics of enumerations in programming and in Python, you can start creating your own enum types by using Python’s class.\n\nPython’s module provides the class, which allows you to create enumeration types. To create your own enumerations, you can either subclass or use its functional API. Both options will let you define a set of related constants as enum members. In the following sections, you’ll learn how to create enumerations in your code using the class. You’ll also learn how to set automatically generated values for your enums and how to create enumerations containing alias and unique values. To kick things off, you’ll start by learning how to create an enumeration by subclassing . The module defines a general-purpose enumeration type with iteration and comparison capabilities. You can use this type to create sets of named constants that you can use to replace literals of common data types, such as numbers and strings. A classic example of when you should use an enumeration is when you need to create a set of enumerated constants representing the days of the week. Each day will have a symbolic name and a numeric value between and , inclusive. Here’s how you can create this enumeration by using as your superclass or parent class: Your class is a subclass of . So, you can call an enumeration, or just an enum. , , and the like are enumeration members, also known as enum members, or just members. Each member must have a value, which needs to be constant. Because enumeration members must be constants, Python doesn’t allow you to assign new values to enum members at runtime: If you try to change the value of an enum member, then you get an . Unlike member names, the name containing the enumeration itself isn’t a constant but a variable. So, it’s possible to rebind this name at any moment during your program’s execution, but you should avoid doing that. In the example above, you’ve reassigned , which now holds a string rather than the original enumeration. By doing this, you’ve lost the reference to the enum itself. Often, the values mapped to members are consecutive integer numbers. However, they can be of any type, including user-defined types. In this example, the value of is , the value of is , and so on. Note: You may have noticed that the members of are capitalized. Here’s why: Because Enums are used to represent constants we recommend using UPPER_CASE names for enum members… (Source) You can think of enumerations as collections of constants. Like lists, tuples, or dictionaries, Python enumerations are also iterable. That’s why you can use to turn an enumeration into a of enumeration members. The members of a Python enumeration are instances of the container enumeration itself: You shouldn’t confuse a custom enum class like with its members: , , and so on. In this example, the enum type is a hub for enumeration members, which happen to be of type . You can also use the idiom based on to build enumerations: In this example, you use with the and arguments. The argument allows you to provide the number that starts the range, while the argument defines the number at which the range will stop generating numbers. Even though you use the syntax to create enumerations, they’re special classes that differ from normal Python classes. Unlike regular classes, enums:\n• Can’t be subclassed unless the base enum has no members\n• Are iterable, returning their members in a sequence\n• Provide hashable members that can be used as dictionary keys\n• Support the square bracket syntax, call syntax, and dot notation to access members You should keep in mind all these subtle differences when you start creating and working with your own enumerations in Python. Often, the members of an enumeration take consecutive integer values. However, in Python, the values of members can be of any type, including user-defined types. For example, here’s an enumeration of school grades that uses non-consecutive numeric values in descending order: This example shows that Python enums are pretty flexible and allow you to use any meaningful value for their members. You can set the member values according to the intent of your code. You can also use string values for your enumeration members. Here’s an example of a enumeration that you can use in an online store: In this example, the value associated with each size holds a description that can help you and other developers understand the meaning of your code. You can also create enumerations of Boolean values. In this case, the members of your enumeration will have only two values: These two examples show how you can use enumerations to add extra context to your code. In the first example, anyone reading your code will know that the code emulates a switch object with two possible states. This additional information highly improves your code’s readability. You can also define an enumeration with heterogeneous values: However, this practice makes your code inconsistent from a type safety perspective. Therefore, it’s not recommended practice. Ideally, it would help if you had values of the same data type, which is consistent with the idea of grouping similar, related constants in enumerations. Finally, you can also create empty enumerations: \"\"\"Empty enumeration for such and such purposes.\"\"\" In this example, represents an empty enumeration because it doesn’t define any member constants. Note that you can use the statement, the literal ( ), or a class-level docstring to create empty enumerations. This last approach can help you improve the readability of your code by providing extra context in the docstring. Now, why would you need to define an empty enumeration anyway? Empty enumerations can come in handy when you need to build a hierarchy of enum classes to reuse functionality through inheritance. Consider the following example: In this example, you create as an enumeration with no members. You can only subclass a custom enumeration if it doesn’t have members, so qualifies. The class inherits from your empty enumeration, which means that you can access the method. This method converts the value of a given member into a list. The class provides a functional API that you can use to create enumerations without using the usual class syntax. You’ll just need to call with appropriate arguments like you’d do with a function or any other callable. This functional API resembles the way in which the factory function works. In the case of , the functional signature has the following form: From this signature, you can conclude that needs two positional arguments, and . It can also take up to four optional and keyword-only arguments. These arguments are , , , and . Here’s a table that summarizes the content and meaning of each argument in the signature of : Holds a string with the name of the new enumeration class Provides names for the enumeration members Takes the name of the module that defines the enumeration class Holds the location of the module that defines the enumeration class Holds a class to be used as the first mixin class Takes the starting value from the enumeration values will begin To provide the argument, you can use the following objects:\n• A string containing member names separated either with spaces or commas The and arguments play an important role when you need to pickle and unpickle your enumerations. If isn’t set, then Python will attempt to find the module. If it fails, then the class will not be picklable. Similarly, if isn’t set, then Python will set it to the global scope, which may cause your enumerations to fail unpickling in some situations. The argument is required when you want to provide a mixin class for your enumeration. Using a mixin class can provide your custom enum with new functionality, such as extended comparison capabilities, as you’ll learn in the section about mixing enumerations with other data types. Finally, the argument provides a way to customize the initial value of your enumerations. This argument defaults to rather than to . The reason for this default value is that is false in a Boolean sense, but enum members evaluate to . Therefore, starting from would seem surprising and confusing. Most of the time, you’ll just use the first two arguments to when creating your enumerations. Here’s an example of creating an enumeration of common HTTP methods: This call to returns a new enumeration called . To provide the member names, you use a list of strings. Each string represents an HTTP method. Note that the member values are automatically set to consecutive integer numbers starting from . You can change this initial value using the argument. Note that defining the above enumerations with the class syntax will produce the same result: Here, you use the class syntax to define the enum. This example is completely equivalent to the previous one, as you can conclude from the output of . Using either the class syntax or the functional API to create your enumeration is your decision and will mostly depend on your taste and concrete conditions. However, if you want to create enumerations dynamically, then the functional API can be your only option. Consider the following example, where you create an enum with user-provided members: This example is a little bit extreme because creating any object from your user’s input is quite a risky practice, considering that you can’t predict what the user will input. However, the example is intended to show that the functional API is the way to go when you need to create enumerations dynamically. Finally, if you need to set custom values for your enum members, then you can use an iterable of name-value pairs as your argument. In the example below, you use a list of name-value tuples to initialize all the enumeration members: Providing a list of name-value tuples like you did above makes it possible to create the enumeration with custom values for the members. In this example, if you didn’t want to use a list of name-value tuples, then you could also use a dictionary that maps names to values. Python’s module provides a convenient function called that allows you to set automatic values for your enum members. This function’s default behavior is to assign consecutive integer values to members. You need to call once for each automatic value that you need. You can also combine with concrete values, just like you did with and in this example. By default, assigns consecutive integer numbers to each target member starting from . You can tweak this default behavior by overriding the method, which uses under the hood to generate the automatic values. Here’s an example of how to do this: In this example, you create an enumeration of Earth’s cardinal directions in which values are automatically set to strings containing the first character of each member’s name. Note that you must provide your overridden version of before defining any members. That’s because the members will be built by calling the method. You can create enumerations in which two or more members have the same constant value. The redundant members are known as aliases and can be useful in some situations. For example, say that you have an enum containing a set of operating systems (OS), like in the following code: Linux distributions are considered independent operating systems. So, Ubuntu and Debian are both independent systems with different goals and target audiences. However, they share a common kernel called Linux. The above enumeration maps operating systems to their corresponding kernels. This relationship turns into an alias of , which may be useful when you have code that’s kernel-related along with code that’s specific to a given Linux distribution. An important piece of behavior to note in the above example is that when you iterate over the enumeration directly, aliases aren’t considered. If you ever need to iterate over all the members, including aliases, then you need to use . You’ll learn more about iteration and the attribute in the section about iterating through enumerations. You also have the option to completely forbid aliases in your enumerations. To do this, you can use the decorator from the module: In this example, you decorate with . If any member value is duplicated, then you get a . Here, the exception message points out that and share the same value, which isn’t allowed.\n\nUp to this point, you’ve learned what enumerations are, when to use them, and what benefits you get from using them in your code. You’ve also leaned how to create enumerations in Python using the class either as a superclass or as a callable. Now it’s time for you to start digging into how Python’s enumerations work and how you can use them in your code. When it comes to using enumerations in your code, accessing their members is a fundamental operation to perform. You’ll have three different ways to access enumeration members in Python. For example, say that you need to access the member of the enum below. In this situation, you can do something like this: The first highlighted line in this example shows how you can access an enum member using the dot notation, which is pretty intuitive and readable. The second highlighted line accesses the target member by calling the enumeration with the member’s value as an argument. Note: It’s important to note that calling an enumeration with a member’s value as an argument can make you feel like you’re instantiating the enumeration. However, enumerations can’t be instantiated, as you already know: Trying to create an instance of an existing enumeration isn’t allowed, so you get a if you attempt to do it. Therefore, you must not confuse instantiating with accessing members through an enumeration call. Finally, the third highlighted line shows how you can use a dictionary-like notation or subscript notation to access a member using the member’s name as the target key. Python’s enumerations offer great flexibility for you to access members. The dot notation is arguably the most commonly used approach in Python code. However, the other two approaches can be helpful as well. So, use the notation that fulfills your specific needs, conventions, and style. Using the and Attributes The members of a Python enumeration are instances of their containing class. During the enum class parsing, each member is automatically provided with a attribute that holds the member’s name as a string. Members also get a attribute that stores the value assigned to the member itself in the class definition. You can access and as you’d do with a regular attribute, using the dot notation. Consider the following example, which simulates a semaphore, more commonly known as a traffic light: The and attributes of an enum member give you direct access to the member’s name as a string and to the member’s value, respectively. These attributes come in handy when you’re iterating through your enumerations, which you’ll explore in the next section. A remarkable feature of Python enumerations compared to regular classes is that enumerations are iterable by default. Because they’re iterable, you can use them in loops and with other tools that accept and process iterables. Python’s enumerations support direct iteration over members in the definition order: In this example, you use a loop to iterate over the members of . Note that members are produced in the same order as they were defined in the class definition. When you’re iterating over an enumeration, you can access the and attributes as you go: This kind of iteration technique looks pretty similar to iterating over a dictionary. So, if you’re familiar with dictionary iteration, then looping over enumerations using this technique will be a straightforward task with many potential use cases. Alternatively, enumerations have a special attribute called that you can also use for iterating over their members. This attribute holds a dictionary that maps names to members. The difference between iterating over this dictionary and over the enumeration directly is that the dictionary gives you access to all members of the enumeration, including all the aliases that you may have. Here are some examples of using to iterate through your enumeration: You can use the special attribute for detailed programmatic access to the members of a Python enumeration. Because holds a regular dictionary, you can use all the iteration techniques that apply to this built-in data type. Some of these techniques include using dictionary methods like , , and . Using Enumerations in and Statements Chained … statements and the relatively new … statement are common and arguably natural places where you can use enumerations. Both constructs allow you to take different courses of action depending on certain conditions. For example, say that you have a piece of code that handles a semaphore, or traffic light, in a traffic control application. You must perform different actions depending on the current light of the semaphore. In this situation, you can use an enumeration to represent the semaphore and its lights. Then you can use a chain of … statements to decide on the action to run: \"Light will change to red, be careful!\" Light will change to red, be careful! The chain of … statements in your function checks the value of the current light to decide on the action to take. Note that the calls to in are just placeholders. In real code, you’d replace them with more complex operations. If you’re using Python 3.10 or greater, then you can quickly turn the above chain of … statements into an equivalent … statement: \"Light will change to red, be careful!\" Light will change to red, be careful! This new implementation of is equivalent to the previous implementation that uses … statements. Using either technique is a matter of taste and style. Both techniques work well and are comparable in terms of readability. However, note that if you need to guarantee backward compatibility with Python versions lower than 3.10, then you must use chained … statements. Finally, note that even though enumerations seem to play well with … and … statements, you must keep in mind that these statements don’t scale well. If you add new members to your target enumeration, then you’ll need to update the handling function to consider these new members. Being able to use enumerations in … statements and … statements suggests that enumeration members can be compared. By default, enums support two types of comparison operators:\n• Identity, using the and operators\n• Equality, using the and operators The identity comparison relies on the fact that each enum member is a singleton instance of its enumeration class. This characteristic allows for fast and cheap identity comparison of members using the and operators. Consider the following examples, which compare different combinations of enum members: Every enum member has its own identity, which is different from the identity of its sibling members. This rule doesn’t apply to member aliases, because they’re just references to existing members and share the same identity. This is why comparing and returns in your final example. Note: To get the identity of a given object in Python, you can use the built-in function with the object as an argument. Identity checks between members of different enumerations always return : The reason for this falsy result is that members of different enums are independent instances with their own identities, so any identity check on them returns . The equality operators and also work between enumeration members: Python’s enumerations support both operators, and , by delegating to the and operators, respectively. As you already learned, enum members always have a concrete value that can be a number, a string, or any other object. Because of this, running equality comparisons between enum members and common objects can be tempting. However, this kind of comparison doesn’t work as expected because the actual comparison is based on object identity: Even though the member values are equal to the integers in each example, these comparisons return . This is because regular enum members compare by object identity rather than by value. In the example above, you’re comparing enum members to integer numbers, which is like comparing apples and oranges. They’ll never compare equally, because they have different identities. Note: Later, you’ll learn about which are special enumerations that can be compared to integers. Finally, another comparison-related feature of enumerations is that you can perform membership tests on them using the and operators: Python’s enumerations support the and operators by default. Using these operators, you can check if a given member is present in a given enumeration. By default, Python’s enums don’t support comparison operators like , , , and . That’s why you can’t sort the members of an enumeration using the built-in function directly, like in the example below: : '<' not supported between instances of 'Season' and 'Season' When you use an enumeration as an argument to , you get a because enums don’t support the operator. However, there’s a way to successfully sort enumerations by their members’ names and values using the argument in the call. In the first example, you use a function that takes an enumeration member as an argument and returns its attribute. With this technique, you can sort the input enumeration by its values. In the second example, the function takes an enum member and returns its attribute. This way, you can sort the enumeration by the names of its members.\n\nIn the previous sections, you’ve learned how to create and use enumerations in your Python code. Up to this point, you’ve worked with default enumerations. This means that you’ve used Python’s enumerations with their standard features and behaviors only. Sometimes, you may need to provide your enumerations with custom behavior. To do this, you can add methods to your enums and implement the required functionality. You can also use mixin classes. In the following sections, you’ll learn how to take advantage of both techniques to customize your enumerations. You can provide your enumerations with new functionality by adding new methods to your enumeration classes as you’d do with any regular Python class. Enumerations are classes with special features. Like regular classes, enumerations can have methods and special methods. Consider the following example, adapted from the Python documentation: In this example, you have a enumeration with three members. Regular methods like are bound to instances of their containing enum, which are the enum members. So, you must call regular methods on enum members rather than on the enum class itself. Note: Remember that Python’s enumerations can’t be instantiated. The members of an enumeration are the enumeration’s allowed instances. So, the parameter represents the current member. Similarly, the special method operates on members, providing a nicely printable representation of each member. Finally, the method is a class method, which operates on the class or enumeration itself. Class methods like this one provide access to all the enum members from inside the class. You can also take advantage of this ability to contain additional behavior when you need to implement the strategy pattern. For example, say you need a class that allows you to use two strategies for sorting a list of numbers in ascending and descending order. In this case, you can use an enumeration like the following: Each member of represents a sorting strategy. The method makes the members of callable. Inside , you use the built-in function to sort the input values in ascending or descending order, depending on the called member. Note: The above example is intended to be a demonstrative example of using an enum to implement the strategy design pattern. In practice, it’s unnecessary to create this enum with the sole purpose of wrapping the function. Instead, you may use and its argument directly and avoid overengineering your solution. When you call , the input numbers are sorted in ascending order. In contrast, when you call , the numbers get sorted in descending order. That’s it! You’ve used an enumeration to quickly implement the strategy design pattern. Python supports multiple inheritance as part of its object-oriented features. This means that in Python, you can inherit multiple classes when creating class hierarchies. Multiple inheritance comes in handy when you want to reuse functionality from several classes at the same time. A common practice in object-oriented programming is to use what’s known as mixin classes. These classes provide functionality that other classes can use. In Python, you can add mixin classes to the list of parents of a given class to automatically get the mixin functionality. For example, say that you want an enumeration that supports integer comparison. In this case, you can use the built-in type as a mixin when defining your enum: In this example, your class inherits from and . Inheriting from the type enables direct comparison between members through the , , , and comparison operators. It also enables comparisons between members and integer numbers. Finally, note that when you use a data type as a mixin, the member’s attribute isn’t the same as the member itself, although it’s equivalent and will compare as such. That’s why you can compare the members of with integer numbers directly. Note: Using integer enum member values is a pretty common practice. That’s why the module provides an to create enumerations with integer values directly. You’ll learn more about this class in the section called Exploring Other Enumeration Classes. The above example shows that creating enumerations with mixin classes is often of great help when you need to reuse a given piece of functionality. If you decide to use this technique in some of your enums, then you’ll have to stick to the following signature: This signature implies that you can have one or more mixin classes, at most one data type class, and the parent enum class, in that order. Consider the following examples: : new enumerations should be created as : The class shows that in the sequence of bases, you must place as many mixin classes as you need—but only one data type—before . shows that if you put in any position other than the last, then you’ll get a with information about the correct signature to use. Meanwhile, confirms that your list of mixin classes must have at most one concrete data type, such as or . Keep in mind that if you use a concrete data type in your list of mixin classes, then the member values have to match the type of this specific data type.\n\nApart from , the module provides a few additional classes that allow you to create enumerations with specific behaviors. You’ll have the class for creating enumerated constants that are also subclasses of , which implies that all members will have all the features of an integer number. You’ll also find more specialized classes, like and . Both classes will allow you to create enumerated sets of constants that you can combine using the bitwise operators. In the following section, you’ll explore these classes and how they work in Python. Integer enumerations are so common that the module exports a dedicated class called that was specifically created to cover this use case. If you need the members of your enumerations to behave like integer numbers, then you should inherit from rather than from . Subclassing is equivalent to using multiple inheritance with as the mixin class: Now inherits directly from instead of from and . Like the previous version of , this new version has full comparison capabilities and supports all the comparison operators. You can also use the class members in integer operations directly. will automatically attempt to convert any value of a different data type to an integer number. If this conversion isn’t possible, then you’ll get a : In the first example, automatically converts the string into an integer value. In the second example, because the string doesn’t hold a valid numeric value, you get a , and the conversion fails. In the current stable Python version, 3.10, the module doesn’t include a class. However, this class is another example of a popular use case of enumerations. For this reason, Python 3.11 will include a type with direct support for common string operations. In the meantime, you can simulate the behavior of a class by creating a mixin class with and as parent classes. You can use as the base class for enumerations that should support the bitwise operators. Performing bitwise operations on members of an subclass will return an object that’s also a member of the underlying enum. Here’s an example of a enumeration that lets you manage different user roles in a single combined object: In this code snippet, you create an enumeration that holds a set of user roles in a given application. The members of this enumeration hold integer values that you can combine using the bitwise OR operator ( ). For example, the user named John has both and roles. Note that the object stored in is a member of your enumeration. Note: You should keep in mind that individual members of enums based on , also known as flags, should take values that are powers of two (1, 2, 4, 8, …). However, this isn’t a requirement for combinations of flags, like . In the above example, you defined as a combination of roles. Its value results from applying the bitwise OR operator to the complete list of previous roles in the enumeration. also supports integer operations, such as arithmetic and comparison operations. However, these types of operations return integers rather than member objects: members are also subclasses of . That’s why you can use them in expressions that involve integer numbers. In these situations, the resulting value will be an integer rather than an enum member. Finally, you’ll also find the class available in . This class works similarly to and has some additional restrictions: The main difference between and is that the latter doesn’t inherit from . Therefore, integer operations aren’t supported. When you try to use a member of in an integer operation, you get a . Just like members of enums, the members of enums should have values that are powers of two. Again, this doesn’t apply to combinations of flags, like in the example above.\n\nPython’s enumerations can help you improve your code’s readability and organization. You can use them to group similar constants that you can then use in your code to replace strings, numbers, and other values with readable and meaningful names. In the following sections, you’ll code a couple of practical examples that deal with common enum use cases. These examples will help you decide when your code could benefit from using enumerations. Enumerations are great when you need to replace sets of related magic numbers, such as HTTP status codes, computer ports, and exit codes. With an enumeration, you can group these numeric constants and assign them readable and descriptive names that you can use and reuse in your code later. Say that you have the following function as part of an application that retrieves and processes HTTP content directly from the web: Your function takes an HTTP object as an argument. Then it gets the status code from using the method. The … statement sequentially compares the current status code with some standard status codes provided as magic numbers in your example. If a match occurs, then the code block in the matched runs. If no match occurs, then the default runs. Note that the default is the one that uses an underscore ( ) as a match criterion. The rest of the code connects to a sample web page, performs a request, retrieves the response object, and processes it using your function. The clause closes the active connection to avoid resource leaks. Even though this code works, it can be challenging to read and understand for people unfamiliar with HTTP status codes and their corresponding meanings. To fix these issues and make your code more readable and maintainable, you can use an enumeration to group the HTTP status codes and give them descriptive names: This code adds a new enumeration called to your application. This enum groups the target HTTP status codes and gives them readable names. It also makes them strictly constant, which makes your app more reliable. Inside , you use human-readable and descriptive names that provide context and content information. Now anyone reading your code will immediately know that the match criteria are HTTP status codes. They’ll also spot the meaning of each target code quickly. Another interesting use case of enumerations is when you use them for re-creating the different possible states of a given system. If your system can be in exactly one of a finite number of states at any given time, then your system works as a state machine. Enumerations are useful when you need to implement this common design pattern. As an example of how to use an enum to implement the state machine pattern, you create a minimal disk player simulator. To start, go ahead and create a file with the following content: Here, you define the class. This class groups all the possible states of your disk player: , , , and . Now you can code the player class, which would look something like this: \"can't pause when not playing\" \"can't stop when not playing or paused\" The class implements all the possible actions that your player can execute, including inserting and ejecting the disk, playing, pausing, and stopping the player. Note how each method in checks and updates the player’s current state by taking advantage of your enumeration. To complete your example, you’ll use the traditional idiom to wrap up a few lines of code that’ll allow you to try out the class: In this code snippet, you first define an variable, which holds the sequence of methods that you’ll call from in order to try out the class. Then you create an instance of your disk player class. Finally, you start a loop to iterate over the list of actions and run every action through the instance. That’s it! Your disk player simulator is ready for a test. To run it, go ahead and execute the following command at your command line: This command’s output shows that your app has gone through all the possible states. Of course, this example is minimal and doesn’t consider all the potential scenarios. It’s a demonstrative example of how you could use an enumeration to implement the state machine pattern in your code."
    },
    {
        "link": "https://docs.python.org/3/library/enum.html",
        "document": "\n• None is a set of symbolic names (members) bound to unique values\n• None can be iterated over to return its canonical (i.e. non-alias) members in definition order\n• None uses call syntax to return members by value\n• None uses index syntax to return members by name\n\nEnumerations are created either by using syntax, or by using function-call syntax:\n\nEven though we can use syntax to create Enums, Enums are not normal Python classes. See How are Enums different? for more details.\n\nEnumType is the metaclass for enum enumerations. It is possible to subclass EnumType – see Subclassing EnumType for details. is responsible for setting the correct , , , and methods on the final enum, as well as creating the enum members, properly handling duplicates, providing iteration over the enum class, etc. This method is called in two different ways:\n• None to look up an existing member:\n• None to use the enum to create a new enum (only if the existing enum does not have any members): The name of the new Enum to create. The names/values of the members for the new Enum. The name of the module the new Enum is created in. The actual location in the module where this Enum can be found. A mix-in type for the new Enum. The first integer value for the Enum (used by ). How to handle out-of-range values from bit operations ( only). Returns if member belongs to the : Changed in version 3.12: Before Python 3.12, a is raised if a non-Enum-member is used in a containment check. Returns and the names of the members in cls: Returns the Enum member in cls matching name, or raises a : Returns each member in cls in definition order: Returns the number of member in cls: Returns a mapping of every enum name to its member, including aliases Returns each member in cls in reverse definition order: Adds a new name as an alias to an existing member. Raises a if the name is already assigned to a different member. Adds a new value as an alias to an existing member. Raises a if the value is already linked with a different member. Added in version 3.11: Before 3.11 was called , which is still available as an alias. Enum is the base class for all enum enumerations. The name used to define the member: The value given to the member: Value of the member, can be set in . Member values can be anything: , , etc. If the exact value is unimportant you may use instances and an appropriate value will be chosen for you. See for the details. While mutable/unhashable values, such as , or a mutable , can be used, they will have a quadratic performance impact during creation relative to the total number of mutable/unhashable values in the enum. Value of the member, can be set in . No longer used, kept for backward compatibility. (class attribute, removed during class creation). is only used during creation and is removed from the enumeration once creation is complete. is a list of names that will not become members, and whose names will also be removed from the completed enumeration. See TimePeriod for an example. Returns and any public methods defined on self.__class__: The name of the member being defined (e.g. ‘RED’). The start value for the Enum; the default is 1. The number of members currently defined, not including this one. A staticmethod that is used to determine the next value returned by : By default, does nothing. If multiple values are given in the member assignment, those values become separate arguments to ; e.g. would be called as A classmethod that is used to further configure subsequent subclasses. By default, does nothing. A classmethod for looking up values not found in cls. By default it does nothing, but can be overridden to implement custom search behavior: By default, doesn’t exist. If specified, either in the enum class definition or in a mixin class (such as ), all values given in the member assignment will be passed; e.g. results in the call and a value of for the member. When writing a custom , do not use – call the appropriate instead. Returns the string used for repr() calls. By default, returns the Enum name, member name, and value, but can be overridden: Returns the string used for str() calls. By default, returns the Enum name and member name, but can be overridden: Returns the string used for format() and f-string calls. By default, returns return value, but can be overridden: Using with results in integers of increasing value, starting with . IntEnum is the same as , but its members are also integers and can be used anywhere that an integer can be used. If any integer operation is performed with an IntEnum member, the resulting value loses its enumeration status. Using with results in integers of increasing value, starting with . Changed in version 3.11: is now to better support the replacement of existing constants use-case. was already for that same reason. is the same as , but its members are also strings and can be used in most of the same places that a string can be used. The result of any string operation performed on or with a StrEnum member is not part of the enumeration. There are places in the stdlib that check for an exact instead of a subclass (i.e. instead of ), and in those locations you will need to use . Using with results in the lower-cased member name as the value. is to better support the replacement of existing constants use-case. is likewise for that same reason. is the same as , but its members support the bitwise operators (AND), (OR), (XOR), and (INVERT); the results of those operations are (aliases of) members of the enumeration. Returns True if value is in self: Returns True if any members in flag, False otherwise: Returns all the flags in type(self) that are not in self: Function used to format any remaining unnamed numeric values. Default is the value’s repr; common choices are and . Using with results in integers that are powers of two, starting with . Changed in version 3.11: The repr() of zero-valued flags has changed. It is now:: is the same as , but its members are also integers and can be used anywhere that an integer can be used. If any integer operation is performed with an IntFlag member, the result is not an IntFlag: If a operation is performed with an IntFlag member and:\n• None the result is a valid IntFlag: an IntFlag is returned\n• None the result is not a valid IntFlag: the result depends on the setting The of unnamed zero-valued flags has changed. It is now: Using with results in integers that are powers of two, starting with . Changed in version 3.11: is now to better support the replacement of existing constants use-case. was already for that same reason. Inversion of an now returns a positive value that is the union of all flags not in the given flag, rather than a negative value. This matches the existing behavior. uses the of , but the of the mixed-in data type: Inherit from to keep the / of the mixed-in data type instead of using the -default . EnumCheck contains the options used by the decorator to ensure various constraints; failed constraints result in a . Ensure that each value has only one name: Ensure that there are no missing values between the lowest-valued member and the highest-valued member: Ensure that any flag groups/masks contain only named flags – useful when values are specified instead of being generated by : : invalid Flag 'Color': aliases WHITE and NEON are missing combined values of 0x18 [use enum.show_flag_values(value) for details] CONTINUOUS and NAMED_FLAGS are designed to work with integer-valued members. controls how out-of-range values are handled in and its subclasses. Out-of-range values cause a to be raised. This is the default for : Out-of-range values lose their membership and revert to . Out-of-range values are kept, and the membership is kept. This is the default for : EnumDict is a subclass of that is used as the namespace for defining enum classes (see Preparing the class namespace). It is exposed to allow subclasses of with advanced behavior like having multiple values per member. It should be called with the name of the enum class being created, otherwise private names and internal classes will not be handled correctly. Note that only the interface ( and ) is overridden. It may be possible to bypass the checks using other operations like . is a read-only ordered mapping of : items. It is only available on the class. , if specified, must create and return the enum members; it is also a very good idea to set the member’s appropriately. Once all the members are created it is no longer used.\n• None – adds a new name as an alias to an existing member.\n• None – adds a new value as an alias to an existing member.\n• None – name of the member\n• None – value of the member; can be set in\n• None – a lookup function used when a value is not found; may be overridden\n• None – a list of names, either as a or a , that will not be transformed into members, and will be removed from the final class\n• None – no longer used, kept for backward compatibility (class attribute, removed during class creation)\n• None – used to get an appropriate value for an enum member; may be overridden For standard classes the next value chosen is the highest value seen incremented by one. For classes the next value chosen will be the next highest power-of-two.\n• None While names are generally reserved for the further development of the class and can not be used, some are explicitly allowed:\n• None (e.g. ), as used in IPython’s rich display\n\nauto can be used in place of a value. If used, the Enum machinery will call an ’s to get an appropriate value. For and that appropriate value will be the last value plus one; for and it will be the first power-of-two greater than the highest value; for it will be the lower-cased version of the member’s name. Care must be taken if mixing auto() with manually specified values. auto instances are only resolved when at the top level of an assignment:\n• None will work (auto() is replaced with );\n• None will work (auto is replaced with , so is used to create the enum member;\n• None will not work ( is used to create the enum member) Changed in version 3.11.1: In prior versions, had to be the only thing on the assignment line to work properly. can be overridden to customize the values used by auto. in 3.13 the default will always return the highest member value incremented by 1, and will fail if any member is an incompatible type. A decorator similar to the built-in property, but specifically for enumerations. It allows member attributes to have the same names as members themselves. the property and the member must be defined in separate classes; for example, the value and name attributes are defined in the Enum class, and Enum subclasses can define members with the names and . A decorator specifically for enumerations. It searches an enumeration’s , gathering any aliases it finds; if any are found is raised with the details: : duplicate values found in <enum 'Mistake'>: FOUR -> THREE A decorator specifically for enumerations. Members from are used to specify which constraints should be checked on the decorated enumeration. A decorator for use in enums: its target will become a member. A decorator for use in enums: its target will not become a member. A decorator to change the and of an enum to show its members as belonging to the module instead of its class. Should only be used when the enum members are exported to the module global namespace (see for an example). Return a list of all power-of-two integers contained in a flag value."
    },
    {
        "link": "https://medium.com/@jaberi.mohamedhabib/understanding-enums-and-classes-in-python-db4a7dbf32e0",
        "document": "Python, a versatile and powerful programming language, provides developers with various tools for structuring their code and organizing data. Two fundamental concepts in Python, enums, and classes, play distinct roles in enhancing code clarity and maintainability.\n\nEnums, short for enumerations, are a way to represent a set of named constant values in Python. They allow you to create a more readable and self-explanatory code by associating meaningful names with specific values.\n\nIn Python, the module provides the class, which makes it easy to define enumerations. Here's a simple example:\n\nIn this example, is an enumeration class with members , , and , each associated with a unique value.\n• Readability: Enums improve code readability by replacing magic numbers or strings with meaningful names.\n• Iteration: Enumerations can be iterated over, making them useful for loops and comprehensions.\n\nClasses in Python are a fundamental part of object-oriented programming (OOP). They allow you to define custom data types, known as objects, which can encapsulate data and behavior.\n\nHere’s a simple example of a class in Python:\n\nIn this example, is a class with attributes and and a method .\n• Encapsulation: Classes allow you to encapsulate data and behavior into a single unit, promoting code organization and modularity.\n• Inheritance: Python supports inheritance, allowing you to create new classes based on existing ones, fostering code reuse.\n• Polymorphism: OOP principles like polymorphism enable you to use a common interface for different types of objects.\n\nWhile enums and classes serve different purposes, they can complement each other. For instance, you might use an enum to represent the possible states of an attribute within a class.\n\nIn this example, is an enum representing possible colors of a traffic light, and is a class utilizing this enum to display a message based on its color.\n\nUnderstanding the roles of enums and classes in Python is essential for writing clean, maintainable, and organized code. Enums offer a way to represent named constant values, while classes provide a mechanism for defining custom objects with attributes and behavior. Knowing how to use both effectively will contribute to your success as a Python developer."
    }
]