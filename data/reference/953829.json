[
    {
        "link": "https://books.sonatype.com/mvnref-book/reference/running-sect-options.html",
        "document": "To define a property use the following option on the command line: This is the option most frequently used to customized the behavior of Maven plugins. Some examples of using the command line argument: Properties defined on the command line are also available as properties to be used in a Maven POM or Maven Plugin. Form more information about referencing Maven properties, see Chapter 9, Properties and Resource Filtering. Properties can also be used to activate build profiles. For more information about Maven build profiles, see Chapter 5, Build Profiles.\n\nTo display Maven version information, use one of the following options on the command line: Both of these options produce the same version information output, but the -v option will terminate the Maven process after printing out the version. You would use the -V option if you wanted to have the Maven version information present at the beginning of your build’s output. This can come in handy if you are running Maven in a continuous build environment and you need to know what version of Maven was used for a particular build.\n\nIf you ever need to use Maven without having access to a network, you should use the following option to prevent any attempt to check for updates to plugins or dependencies over a network: When running with the offline option enabled, Maven will not attempt to connect to a remote repository to retrieve artifacts.\n\nThe following options control how Maven reacts to a build failure in the middle of a multi-module project build: Only fail the build afterwards; allow all non-impacted builds to continue Stop at first failure in reactorized builds NEVER fail the build, regardless of project result The and options are useful options for multi-module builds that are running within a continuous integration tool like Hudson. The option is very useful for developers running interactive builds who want to have rapid feedback during the development cycle.\n\nIf you want to control Maven’s logging level, you can use one of the following three command line options: The option only prints a message to the output if there is an error or a problem. The option will print an overwhelming amount of debugging log messages to the output. This option is primarily used by Maven developers and by Maven plugin developers to diagnose problems with Maven code during development. This option is also very useful if you are attempting to diagnose a difficult problem with a dependency or a classpath. The option will come in handy if you are a Maven developer, or if you need to diagnose an error in a Maven plugin. If you are reporting an unexpected problem with Maven or a Maven plugin, you will want to pass both the and options to your Maven process.\n\nTo run Maven in batch mode use the following option: Batch mode is essential if you need to run Maven in a non-interactive, continuous integration environment. When running in non-interactive mode, Maven will never stop to accept input from the user. Instead, it will use sensible default values when it requires input.\n\nThe following command line options affect the way that Maven will interact with remote repositories and how it verifies downloaded artifacts: Forces a check for updated releases and snapshots on remote repositories If you are concerned about security, you will want to run Maven with the option. Maven repositories maintain an MD5 and SHA1 checksum for every artifact stored in a repository. Maven is configured to warn the end-user if an artifact’s checksum doesn’t match the downloaded artifact. Passing in the option will cause Maven to fail the build if it encounters an artifact with a bad checksum. The option is useful if you want to make sure that Maven is checking for the latest versions of all SNAPSHOT dependencies."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/maven-commands-options-cheat-sheet",
        "document": "Maven is one of the most popular project and dependency management tools for Java applications. Maven provides a lot of commands and options to help you in your day to day tasks.\n\nThis cheat sheet uses a sample Maven project to demonstrate some useful Maven commands. It was originally written for OpenJDK 13.0.1 and Maven 3.6.3. These commands have been verified with OpenJDK 19.0.1 and Maven 3.8.7.\n\nThis command cleans the Maven project by deleting the target directory:\n\nExample of the output:\n\nThis command compiles the Java source classes of the Maven project:\n\nExample of the output:\n\nThis command compiles the test classes of the Maven project:\n\nExample of the output:\n\nThis command builds the Maven project and packages it into a , , etc.:\n\nExample of the output:\n\nThe output shows the location of the file just before the message. Notice the goal executes , , and goals before packaging the build.\n\nThis command builds the Maven project and installs the project files ( , , , etc.) to the local repository:\n\nExample of the output:\n\nThis command deploys the artifact to the remote repository:\n\nThe remote repository should be configured properly in the project file tag. The server entries in the Maven file are used to provide authentication details.\n\nThis command validates the Maven project to ensure that everything is correct and all the necessary information is available:\n\nThis command generates the dependency tree of the Maven project:\n\nExample of the output:\n\nThis command analyzes the maven project to identify the unused declared and used undeclared dependencies:\n\nExample of the output:\n\nIt’s useful in reducing the build size by identifying the unused dependencies and removing them from the file.\n\nThis command generates skeleton Maven projects of different types, such as , web application, Maven site, etc:\n\nExample of the output:\n\nThis command generates a site for the project:\n\nYou will notice a directory in the directory after executing this command.\n\nThere will be multiple HTML files inside the directory that provide information related to the project.\n\nThis command runs the test cases of the project:\n\nExample of the output:\n\nThis command compiles the source Java classes of the project:\n\nExample of the output:\n\nIt is similar to the previous command, but runs the entire Maven lifecycle up to .\n\nThis command builds the project, runs all the test cases and run any checks on the results of the integration tests to ensure quality criteria are met:\n\nMaven provides a lot of command-line options to alter the Maven build process:\n\nThis command-line option prints the Maven usage and all the available options:\n\nExample of the output:\n\nThis command-line option builds a project from a different location:\n\nProvide the file location to build the project. It’s useful when you have to run a Maven build from a script.\n\nThis command-line option runs the Maven build in offline mode:\n\nIt’s useful when you have all the required s downloaded in the local repository and you don’t want Maven to look for any s in the remote repository.\n\nThis command-line option runs the Maven build in quiet mode, so that only the test case results and errors are displayed:\n\nThis command-line option prints the Maven version and runs the build in debug mode, so that all messages are displayed:\n\nExample of the output:\n\nExample of the output:\n\nThis command-line option prints the Maven version and then continues with the build:\n\nThis command-line option applies the system property to skip the unit test cases from the build cycle:\n\nYou can also skip the test cases execution:\n\nThis command-line option tells Maven to run parallel builds using the specified thread count:\n\nIt’s useful in multiple module projects where modules can be built in parallel. It can reduce the build time of the project."
    },
    {
        "link": "https://maven.apache.org/guides/introduction/introduction-to-profiles.html",
        "document": "\n• What are the different types of profile? Where is each defined?\n• How can a profile be triggered? How does this vary according to the type of profile being used?\n• Which areas of a POM can be customized by each type of profile? Why?\n• How can I tell which profiles are in effect during a build?\n\nApache Maven goes to great lengths to ensure that builds are portable. Among other things, this means allowing build configuration inside the POM, avoiding all filesystem references (in inheritance, dependencies, and other places), and leaning much more heavily on the local repository to store the metadata needed to make this possible.\n\nHowever, sometimes portability is not entirely possible. Under certain conditions, plugins may need to be configured with local filesystem paths. Under other circumstances, a slightly different dependency set will be required, and the project's artifact name may need to be adjusted slightly. And at still other times, you may even need to include a whole plugin in the build lifecycle depending on the detected build environment.\n\nTo address these circumstances, Maven supports build profiles. Profiles are specified using a subset of the elements available in the POM itself (plus one extra section), and are triggered in any of a variety of ways. They modify the POM at build time, and are meant to be used in complementary sets to give equivalent-but-different parameters for a set of target environments (providing, for example, the path of the appserver root in the development, testing, and production environments). As such, profiles can easily lead to differing build results from different members of your team. However, used properly, profiles can be used while still preserving project portability. This will also minimize the use of option of maven which allows user to create another POM with different parameters or configuration to build which makes it more maintainable since it is running with one POM only.\n\nHow can a profile be triggered? How does this vary according to the type of profile being used? A profile can be activated in several ways: Refer to the sections below for details. Profiles can be explicitly specified using the command line flag. This flag is followed by a comma-delimited list of profile IDs to use. The profile(s) specified in the option are activated in addition to any profiles which are activated by their activation configuration or the section in . From Maven 4 onward, Maven will refuse to activate or deactivate a profile that cannot be resolved. To prevent this, prefix the profile identifier with an , marking it as optional: Profiles can be activated in the Maven settings, via the section. This section takes a list of elements, each containing a profile-id inside. Profiles listed in the tag would be activated by default every time a project use it. Profiles can also be active by default using a configuration like the following in a POM: This profile will automatically be active for all builds unless another profile in the same POM is activated using one of the previously described methods. All profiles that are active by default are automatically deactivated when a profile in the POM is activated on the command line or through its activation config. Profiles can be automatically triggered based on the detected state of the build environment. These triggers are specified via an section in the profile itself. Currently, this detection is limited to JDK version matching, operating system matching or the presence/the value of a system property. The implicit profile activation always only refers to the container profile (and not to profiles in other modules with the same id). Here are some examples. The following configuration will trigger the profile when the JDK's version starts with \"1.4\" (eg. \"1.4.0_08\", \"1.4.2_07\", \"1.4\"), in particular it won't be active for newer versions like \"1.8\" or \"11\": Ranges can also be used. Range values must start with either or . Otherwise, the value is interpreted as a prefix. The following honours versions 1.3, 1.4 and 1.5. Note: an upper bound such as is likely not to include most releases of 1.5, since they will have an additional \"patch\" release such as that is not taken into consideration in the above range. This next one will activate based on the detected operating system. See the Maven Enforcer Plugin for more details about OS values. The values are interpreted as Strings and are matched against the Java System properties , , and the family being derived from those. Each value can be prefixed with to negate the matching. The values match if they are (not) equal to the actual String value (case insensitive). All given OS conditions must match for the profile to be considered for activation. Since Maven 3.9.7 the value for may be prefixed with . In that case regular pattern matching is applied for the version matching and applied against the lower case value. The actual OS values which need to match the given values are emitted when executing . The profile below will be activated when the system property \"debug\" is specified with any value: The following profile will be activated when the system property \"debug\" is not defined at all: The following profile will be activated when the system property \"debug\" is defined with no value, or is defined with the value \"true\". To activate this you would type one of those on the command line: The following profile will be activated when the system property \"debug\" is not defined, or is defined with a value which is not \"true\". To activate this you would type one of those on the command line: The next example will trigger the profile when the system property \"environment\" is specified with the value \"test\": To activate this you would type this on the command line: Profiles in the POM can also be activated based on properties from active profiles from the . Note: Environment variables like are available as properties of the form . Further note that environment variable names are normalized to all upper-case on Windows. Since Maven 3.9.0 one can also evaluate the POM's packaging value by referencing property . This is only useful where the profile activation is defined in a common parent POM which is reused among multiple Maven projects. The next example will trigger the profile when a project with packaging is built: This example will trigger the profile when the generated file is missing. The tags and can be interpolated. Supported variables are system properties like and environment variables like . Please note that properties and values defined in the POM itself are not available for interpolation here, e.g. the above example activator cannot use but needs to hard-code the path . Different implicit activation types can be combined in one profile. The profile is then only active if all conditions are met (since Maven 3.2.2, MNG-4565). Using the same type more than once in the same profile is not supported (MNG-5909, MNG-3328). One or more profiles can be deactivated using the command line by prefixing their identifier with either the character '!' or '-' as shown below. Note that needs to be escaped with or quoted in Bash, ZSH and other shells as it has a special meaning. Also there is a known bug with command line option values starting with (CLI-309), therefore it is recommended to use it with the syntax . This can be used to deactivate profiles marked as activeByDefault or profiles that would otherwise be activated through their activation config.\n\nWhich areas of a POM can be customized by each type of profile? Why? Now that we've talked about where to specify profiles, and how to activate them, it will be useful to talk about what you can specify in a profile. As with the other aspects of profile configuration, this answer is not straightforward. Depending on where you choose to configure your profile, you will have access to varying POM configuration options. Profiles specified in external files (i.e in or ) are not portable in the strictest sense. Anything that seems to stand a high chance of changing the result of the build is restricted to the inline profiles in the POM. Things like repository lists could simply be a proprietary repository of approved artifacts, and won't change the outcome of the build. Therefore, you will only be able to modify the and sections, plus an extra section. The section allows you to specify free-form key-value pairs which will be included in the interpolation process for the POM. This allows you to specify a plugin configuration in the form of . On the other hand, if your profiles can be reasonably specified inside the POM, you have many more options. The trade-off, of course, is that you can only modify that project and its sub-modules. Since these profiles are specified inline, and therefore have a better chance of preserving portability, it's reasonable to say you can add more information to them without the risk of that information being unavailable to other users. Profiles specified in the POM can modify the following POM elements:\n• a subset of the element, which consists of: We don't allow modification of some POM elements outside of POM-profiles because these runtime modifications will not be distributed when the POM is deployed to the repository system, making that person's build of that project completely unique from others. While you can do this to some extent with the options given for external profiles, the danger is limited. Another reason is that this POM info is sometimes being reused from the parent POM. External files such as and also do not support elements outside the POM-profiles. Let us take this scenario for elaboration. When the effective POM is deployed to a remote repository, any person can pickup its info out of the repository and use it to build a Maven project directly. Now, imagine that if we can set profiles in dependencies, which is very important to a build, or in any other elements outside POM-profiles in then most probably we cannot expect someone else to use that POM from the repository and be able to build it. And we have to also think about how to share the with others. Note that too many files to configure are very confusing and very hard to maintain. Bottom line is that since this is build data, it should be in the POM.\n\nWe've already mentioned the fact that adding profiles to your build has the potential to break portability for your project. We've even gone so far as to highlight circumstances where profiles are likely to break project portability. However, it's worth reiterating those points as part of a more coherent discussion about some pitfalls to avoid when using profiles. There are two main problem areas to keep in mind when using profiles. First are external properties, usually used in plugin configurations. These pose the risk of breaking portability in your project. The other, more subtle area is the incomplete specification of a natural set of profiles. External property definition concerns any property value defined outside the but not defined in a corresponding profile inside it. The most obvious usage of properties in the POM is in plugin configuration. While it is certainly possible to break project portability without properties, these critters can have subtle effects that cause builds to fail. For example, specifying appserver paths in a profile that is specified in the may cause your integration test plugin to fail when another user on the team attempts to build without a similar . Consider the following snippet for a web application project: Now, in your local , you have: When you build the integration-test lifecycle phase, your integration tests pass, since the path you've provided allows the test plugin to install and test this web application. However, when your colleague attempts to build to integration-test, his build fails spectacularly, complaining that it cannot resolve the plugin configuration parameter , or worse, that the value of that parameter - literally - is invalid (if it warns you at all). Congratulations, your project is now non-portable. Inlining this profile in your can help alleviate this, with the obvious drawback that each project hierarchy (allowing for the effects of inheritance) now have to specify this information. Since Maven provides good support for project inheritance, it's possible to stick this sort of configuration in the section of a team-level POM or similar, and simply inherit the paths. Another, less attractive answer might be standardization of development environments. However, this will tend to compromise the productivity gain that Maven is capable of providing. In addition to the above portability-breaker, it's easy to fail to cover all cases with your profiles. When you do this, you're usually leaving one of your target environments high and dry. Let's take the example snippet from above one more time: Now, consider the following profile, which would be specified inline in the : This profile looks quite similar to the one from the last example, with a few important exceptions: it's plainly geared toward a development environment, a new profile named is added and it has an activation section that will trigger its inclusion when the system properties contain \"env=dev\" for a profile named and \"env=dev-2\" for a profile named . So, executing: will result in a successful build, applying the properties given by profile named . And when we execute it will result in a successful build applying the properties given by the profile named . However, executing: will not do a successful build. Why? Because, the resulting non-interpolated literal value of will not be a valid path for deploying and testing your web application. We haven't considered the case for the production environment when writing our profiles. The \"production\" environment (env=production), along with \"test\" and possibly even \"local\" constitute a natural set of target environments for which we may want to build the integration-test lifecycle phase. The incomplete specification of this natural set means we have effectively limited our valid target environments to the development environment. Your teammates - and probably your manager - will not see the humor in this. When you construct profiles to handle cases such as these, be sure to address the entire set of target permutations. As a quick aside, it's possible for user-specific profiles to act in a similar way. This means that profiles for handling different environments which are keyed to the user can act up when the team adds a new developer. While I suppose this could act as useful training for the newbie, it just wouldn't be nice to throw them to the wolves in this way. Again, be sure to think of the whole set of profiles.\n\nHow can I tell which profiles are in effect during a build? Determining active profiles will help the user to know what particular profiles has been executed during a build. We can use the Maven Help Plugin to tell what profiles are in effect during a build. Let us have some small samples that will help us to understand more on the active-profiles goal of that plugin. From the last example of profiles in the , you'll notice that there are two profiles named and which has been given different values for properties. If we go ahead and execute: The result will be a bulleted list of the id of the profile with an activation property of \"env=dev\" together with the source where it was declared. See sample below. The following profiles are active: - appserverConfig-dev (source: pom) Now if we have a profile declared in (refer to the sample of profile in ) and that have been set to be an active profile and execute: The result should be something like this The following profiles are active: - appserverConfig (source: settings.xml) Even though we don't have an activation property, a profile has been listed as active. Why? Like we mentioned before, a profile that has been set as an active profile in the is automatically activated. Now if we have something like a profile in the that has been set as an active profile and also triggered a profile in the POM. Which profile do you think will have an effect on the build? This will list the activated profiles: The following profiles are active: - appserverConfig-dev (source: pom) - appserverConfig (source: settings.xml) Even though it listed the two active profiles, we are not sure which one of them has been applied. To see the effect on the build execute: This will print the effective POM for this build configuration out to the console. Take note that profiles in the takes higher priority than profiles in the POM. So the profile that has been applied here is not . If you want to redirect the output from the plugin to a file called , use the command-line option .\n\nBy now you've noticed that profiles are a natural way of addressing the problem of different build configuration requirements for different target environments. Above, we discussed the concept of a \"natural set\" of profiles to address this situation, and the importance of considering the whole set of profiles that will be required. However, the question of how to organize and manage the evolution of that set is non-trivial as well. Just as a good developer strives to write self-documenting code, it's important that your profile id's give a hint to their intended use. One good way to do this is to use the common system property trigger as part of the name for the profile. This might result in names like env-dev, env-test, and env-prod for profiles that are triggered by the system property env. Such a system leaves a highly intuitive hint on how to activate a build targeted at a particular environment. Thus, to activate a build for the test environment, you need to activate env-test by issuing: The right command-line option can be had by simply substituting \"=\" for \"-\" in the profile id."
    },
    {
        "link": "https://stackoverflow.com/questions/33553068/what-are-all-of-the-maven-command-line-options",
        "document": "Text version to make it easy to copy/paste Maven CLI Options Reference\n\nIf you want to skip tests you can add the following to the command line.\n\ncompiles the tests, but skips running them\n\nskips compiling the tests and does not run them"
    },
    {
        "link": "https://jrebel.com/blog/maven-cheat-sheet",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/32368976/ways-to-make-maven-build-faster",
        "document": "Note: First thing is AFAIK, No other in built options available in maven apart from the all answers here.\n\nRunning maven build with Multiple threads works for me to speed up the builds. For example :\n\nBelow are the variants from wiki\n\nHow Execution is evaluated(See Parallel builds in Maven 3)?\n\nEach node in the graph represents a module in a multi-module build, the \"levels\" simply indicate the distance to the first module in the internal reactor dependency graph. Maven calculates this graph based on declared inter-module dependencies for a multi-module build. Note that the parent maven project is also a dependency, which explains why there is a single node on top of most project graphs. Dependencies outside the reactor do not influence this graph.\n\nFinally if you want to skip test execution you can also use as well.\n\nCaution : Some of your plugins may not be compatible for multithreaded builder, it may work. but it will give below warning message. you may need to see plugin documentation for multithreading support."
    },
    {
        "link": "https://blog.frankel.ch/faster-maven-builds/1",
        "document": "Builds require a few properties, chief among them reproducibility. I would consider speed to be low on the order of priorities. However, it’s also one of the most limiting factors to your release cycle: if your build takes T, you cannot release faster than each T. Hence, you’ll probably want to speed up your builds after you’ve reached a certain maturity level to enable more frequent releases.\n\nI want to detail some techniques you can leverage to make your Maven builds faster in this post. The following post will focus on how to do the same inside of Docker.\n\nBy default, Maven uses a single thread. In the age of multicores, this is just waste. It’s possible to run parallel builds using multiple threads by setting an absolute number or a number relative to the number of available cores. For more information, please check the relevant documentation. The more submodules that are not dependent on each other you have, i.e., Maven can build them in parallel, the better you’ll achieve with this technique. It fits our codebase very well. We are going to use as many threads as there are available cores. The relevant command is . When the command starts, you should see the following message in the console: Using the MultiThreadedBuilder implementation with a thread count of X The numbers are much better but with a higher variance.\n\nParallelization is an excellent technique. We can do the same regarding test execution. By default, the Maven Surefire plugin runs tests sequentially, but it’s possible to configure it to run tests in parallel. Please refer to the documentation for the whole set of options. This approach is excellent if you’ve got a large number of units in each module. Note that your tests need to be independent of one another. We will manually set the number of threads: Configure Surefire to run both classes and methods in parallel It seems that the cost of thread synchronization offsets the potential gain of running parallel tests.\n\nMaven itself is a Java-based application. It means each run starts a new . A JVM first interprets the bytecode and then analyze the workload and compiles the bytecode to native code accordingly: it means peak performance, but only after a (long) while. It’s great for long-running processes, not so much for command-line applications. We will likely not reach the peak performance point in the context of builds since they are relatively short-lived, but we are still paying for the analysis cost. We can configure Maven to forego it by configuring the adequate JVM parameters. Several ways of configuring the JVM are available. The most straightforward way is to create a dedicated configuration file in a subfolder in the project’s folder.\n\nThe Maven daemon is a recent addition to the Maven ecosystem. It draws its inspiration from the Gradle daemon: Gradle runs on the Java Virtual Machine (JVM) and uses several supporting libraries that require a non-trivial initialization time. As a result, it can sometimes seem a little slow to start. The solution to this problem is the Gradle Daemon: a long-lived background process that executes your builds much more quickly than would otherwise be the case. We accomplish this by avoiding the expensive bootstrapping process and leveraging caching by keeping data about your project in memory. The Gradle team recognized early that a command-line tool was not the best usage of the JVM. To fix that, one keeps a JVM background process, the daemon, always up. It acts as a server while the itself plays the role of the client. As an additional benefit, such a long-running process loads classes only once (if they didn’t change between runs). Once you have installed the software, you can run the daemon with the command instead of the standard one. Here are the results with : Note that the daemon uses multiple threads by default, with .\n\nWe’ve seen several ways to speed up the build. What if we used them in conjunction? Let’s first try with every technique we’ve seen so far in the same run: Configure the JVM parameters as above via the file - no need to set any option The command returns the following results: Thinking about it, the Maven daemon is a long-running process. For that reason, it stands to reason to let the JVM analyze and compile the bytecode to native code. We can thus remove the file and re-run the above command. Results are: Now we can display the consolidated results:\n\nIn this post, we have seen several ways to speed up your Maven build. Here’s the summary: When the build contains multiple modules that are independent of each other When the project contains multiple tests When the project contains dependencies and you don’t need to update them When you want to go the extra mile I’d advise every user to start using the Maven daemon and continue optimizing if necessary and depending on your project. In the next post, we will focus on speeding your Maven builds in-container."
    },
    {
        "link": "https://baeldung.com/maven-fast-build",
        "document": "In this tutorial, we’ll learn how to speed up our Maven builds. We’ll present various techniques to optimize the build time and comment on their advantages and drawbacks.\n\nBefore any optimization attempt, let’s recall that using the correct Maven phase could save us a lot of time. Why run a full install and pollute our local repository when we only need to compile the code?\n\nOn the other hand, in a multi-module project, it’s possible to rebuild only the changed modules and those that depend on them. For instance, if we make changes only in module1 and module2, we can run:\n\nBy default, the Maven build runs sequentially in a single thread. However, nowadays, all computers have multiple cores. Let’s take advantage of this to use the -T option and build our modules in parallel:\n• -T 1C means Maven will use one thread per available core.\n• -T 4 would force Maven to use four threads.\n\nLast but not least, Maven Reactor ensures that all modules that depend on each other will run sequentially.\n\nTests are a crucial part of software development. Nevertheless, running them less takes a lot of time.\n\nBy default, the Surefire plugin runs unit tests sequentially. However, we can configure it to run them in parallel. For instance, to run all test suites in parallel and use one thread per available core, we’d run:\n\nHowever, if we don’t have a lot of unit tests in our project, the overhead cost of parallelization could negate the speed gain.\n\nSometimes we don’t need to run the tests in our local environment. The Maven -DskipTests option skips the test execution while still compiling the test folder:\n\nIn a highly-tested project, skipping tests when we don’t need them can save us time!\n\nAdditionally, we can skip the test execution and not even compile them by using the -Dmaven.test.skip=true option:\n\nThis method reduces the total build time even more.\n\nBy default, HotSpot JVM uses tiered compilation: it uses both the client and server compilers to optimize Java bytecode. This functioning optimizes long-lived processes on a server. However, a build is a succession of short-lived processes. Thus, let’s use the following JVM parameters:\n• -XX:TieredStopAtLevel=1: the JVM will use the client compiler only\n\nWe can have Maven use these options by creating a .mvn/jvm.config file with the following content:\n\nMaven uses caching and incremental build techniques to avoid recompiling unchanged code. Thus, the more new code Maven needs to compile, the more efficient this technique is.\n\nMaven makes several round trips to the server during a build, for instance, for dependency resolution and plugin download. In particular, it will check for new snapshot updates every time. We can avoid that by going into offline mode:\n\nWe can’t use offline mode when we need to update some dependencies.\n\nIf the previous techniques don’t help us to bring back the build time to something acceptable, we can troubleshoot our build thanks to a profiler. First, let’s create a new Maven project. Then, we’ll follow the instructions on the GitHub of the Maven Profiler project to install it. Lastly, we need to add the dependency in our pom.xml:\n\nWe can now use it to get more insight into our build timings by launching the command:\n\nOnce the build is complete, we can find the report as an HTML text inside the .profiler folder. Let’s have a look at it:\n\nAs we can see, the profiler lists all plugin executions and records the time they take. The second section lists the downloaded artifacts. This information can help us identify the plugins that take a long time to run while providing little to no value in the target environment.\n\nOnce we identify a bottleneck, we can use Maven profiles to skip them on demand and save time. For example, executing integration tests is generally very long. Moreover, running them every time in a local environment isn’t useful.\n\nLet’s add the failsafe plugin configuration in our pom.xml:\n\nWe can now add a profile for skipping them:\n\nThanks to overriding the configuration, with the skipITs profile activated, the integration tests are now skipped:\n\nThe Maven daemon aims to improve Maven builds’ velocity. The daemon is a long-lived background process that remains active even after the build is completed. It reduces build overhead by keeping essential components in memory, enabling faster project builds by avoiding repeated startup and initialization processes. To install it, follow the instructions on the project’s GitHub page. Let’s now use it to launch the build:\n\nIf the daemon needs to start, the build time is slightly higher. Last but not least, we can combine the previous techniques with the Maven daemon. For instance, we can build via the daemon and skip the tests:\n\nNevertheless, let’s point out that since the Maven daemon is a long-lived process, setting up the JVM parameters as we did previously would probably do more harm than good. Let’s take a look at key Maven daemon commands:\n\nWe can use the ––status command to list all the currently running Maven daemons. Here’s what the output looks like after running the below command:\n\nThe output provides information like Process ID, Address, Status, Resident set size (RSS), Last activity, and Java home:\n\nThis output allows us to monitor the current state of all running Maven daemons and their resource usage.\n\nThe ––stop command allows us to terminate all running Maven daemons. This is useful when we want to free up system resources. Here’s an example of what the output will look like:\n\nThe command stops all Maven daemons and displays the number of daemons that were terminated in the output:\n\nIn this article, we showcased various techniques to reduce the build time with Maven. In a nutshell, we should decide to start using the Maven daemon. Then, let’s remember to skip tests when we don’t need to run them. We can also profile the build and use Maven profiles to exclude time-consuming low-value tasks. If none of this is enough, we can try other techniques described in the article."
    },
    {
        "link": "https://gradle.com/blog/five-ways-to-speed-up-your-apache-maven-builds",
        "document": "If you’re a regular Apache Maven™ user, you know that build times can quickly add up, eating into your development time and slowing down your feedback loop—whether you’re waiting for a local build to finish or watching a pull request inch towards merge, every minute counts.\n\nIn this post, I’ll discuss five low-effort strategies for accelerating your Maven builds, showing a real-life example that brings a 1.5-minute build down to 7.5 seconds. These tips will help you return to what you love most—writing code!\n\nI’ll use the Apache SCIMple project as a representative Maven project to demonstrate these techniques. SCIMple boasts around 20,000 lines of Java code, multiple modules, and a full suite of unit and integration tests.\n\nFeel free to follow along with SCIMple by cloning the branch:\n\nNote: This branch is intentionally unoptimized to showcase the impact of our speed-up techniques.\n\nThe only way to know if something is improved or… simply what needs to be improved is to measure it, so before discussing optimizations, let’s measure the baseline build time. To do this, we could manually parse console logs, but a Build Scan® is more efficient and it will record the history of the changes.\n\nA Build Scan offers a treasure trove of information about your build, including dependency download times, plugin usage, and system details. You can also easily share these insights with your team—every line in a Build Scan has a shareable URL, so your teammates can navigate directly to the data you want to discuss.\n\nTo get started, add the Develocity Maven Extension to your project and run a standard build:\n\nThis build took about 1.5 minutes; that’s the starting point. If you work on a large project, it probably takes much longer, but if I used a 20-minute build for this blog post, you probably wouldn’t want to follow along!\n\nRemember, you run through these same steps with any Maven build. After the build is complete, you’ll see a link to a Build Scan in the console output:\n\nOpen it up and look at the timeline view. I always look at the timeline first because it’s particularly helpful for identifying bottlenecks.\n\nI can glance at the timeline to see which bars are the longest. If I want to see which goals take the longest, then I group by type, and I can see that SpotBugs takes the longest to run, followed by the integration tests (Failsafe), unit tests (Surefire), PMD, and then compilation.\n\nI love SpotBugs, and its Find Security Bugs integration. SpotBugs has a great IntelliJ plugin, and since I started using it, it’s taught me a lot about writing better and more secure code. I highly recommend it!\n\nThat said, I don’t want the SpotBugs Maven Plugin slowing me down. I’m not always interested in the plugin’s results for local builds (I get that data as I type in my IDE). Most of the time, with local builds, I just want to see if my tests pass. The same goes for other static analysis tools like PMD or other linters. These goals can be split out of the default build by using profiles.\n\nFirst up are Maven profiles. A profile allows you to segment off parts of your build and they can be activated conditionally or manually on the command line using a argument.\n\nLet’s move our static analysis tools (like SpotBugs and PMD) into a dedicated profile. This way, they run only when needed (e.g., in CI or before creating a pull request), significantly reducing our default build time.\n\nTo create a profile, add the following to your POM:\n\nIf I run again, I can see the build now takes about a minute!\n\nWe can do more, though!\n\nI’ll open up the new Build Scan, go back to the timeline, and Group by type again:\n\nThis looks better: now most of the time is spent running tests, and we can optimize that too!\n\nSimilar to running the modules of the build in parallel, tests can be run in parallel, too. There is a lot of potential to speed up your builds this way. The Maven Surefire Plugin (and Failsafe Plugins) provide a lot of options to run your build in parallel. It offers so many, it might be overwhelming, so I’ll narrow it down to two options to explore.\n\nYou can run tests sequentially on multiple JVMs using the option; this represents the number of JVMs that will be used concurrently to run your tests. Forking multiple JVMs is an excellent option if your test code depends on the state of static fields, singletons, or other JVM-wide settings like setting system properties.\n\nAlternatively, you can concurrently run tests in a single JVM using multiple threads. When running tests on multiple threads, you can configure the level of granularity at which the tests should run in parallel. You can also run multiple test classes at the same time and have the individual methods run sequentially or concurrently.\n\nYou can also combine the forking and threaded options, forking multiple JVMs, each running tests with multiple threads.\n\nOkay, so let’s break this down:\n• Use if you have tests that depend on JVM-wide state (static fields, singletons, setting system properties, etc.)\n• Run your tests on multiple threads if you have been practicing good test isolation practices (your tests don’t hard code file paths or ports, or don’t depend on external infrastructure that is not orchestrated through your tests (e.g., Testcontainers)\n\nIf you use JUnit 5, I’d recommend configuring the parallel run options through JUnit properties; otherwise, use Surefire’s parallel and threadCount parameters.\n\nNOTE: JUnit 5 also has annotations to mark tests as NOT thread-safe. If not all of your tests can run in parallel, you can run those offenders separately using the Isolated or the ResourceLock annotations.\n\nYou can also run your tests remotely with Develocity’s Test Distribution feature, which stops your laptop or CI agent from being the bottleneck for your tests.\n\nTo enable parallel testing for Apache SCIMple, you can set the JUnit 5 properties in both the Surefire and Failsafe plugins, similar to this:\n\nNOTE: At the time of this writing, Quarkus does not support the above configuration. The Apache SCIMple Quarkus tests are each annotated with , forcing those tests to run sequentially.\n\nRe-running the build again ( ) reduces the build time to 46 seconds! We are really making a dent in the build time!\n\nYour machine likely has multiple cores; mine has 10, but by default, Maven will only build one module at a time. Let’s change that!\n\nThis instructs Maven to build multiple sub-modules at once to 1.5 times the number of cores (C) your machine has; on a 10-core machine, Maven would build up to 15 sub-modules at once, unlocking a substantial performance boost.\n\nRerunning the build: , we can see the build is down to 31 seconds!\n\nBetter, but let’s keep going!\n\nThe goal may not seem like a significant bottleneck, but in large projects, skipping it when building uber-jars or large war files can save precious seconds.\n\nIf you frequently use the flag to resume failed builds, you might need to run to leverage changes in your project.\n\nDuring a Maven build, plugin goals are run during phases of the build; the primary phases are , , , , , , and . So, to skip running the , you just need to run the previous phase: .\n\nIf we run the Apache SCIMple build with , only a few milliseconds will be saved. However, your mileage will vary here; you might save more time with a slower hard drive or file system. And remember, “installing” will copy files from your directory to your local Maven repository ( ), which will also take up disk space.\n\n5. Say goodbye to clean (sometimes)\n\nWhile may seem harmless, it forces every goal to run from scratch, negating any benefits for plugins that support incremental changes. In most cases, you can safely skip the clean and shave off for a few more seconds.\n\n Important Considerations:\n• Some third-party plugins may not handle non-clean builds gracefully.\n• You’ll need to run to populate the build cache, which we’ll discuss next.\n\nOn my laptop, skipping the clean by running shaved a couple of seconds from the build. Again, the results may vary depending on the size of your project, the plugins you are using, and the type of hard drive/file system used.\n\nThe Develocity Maven Extension also offers a build cache that reuses the output of previously run goals. This can drastically reduce build times, especially when you haven’t made code changes.\n\nIf you have been following along with the post, you will need to re-enable build caching:\n\nSubsequent builds will be lightning-fast; let’s put that to the test and run the build again\n\nAs you make changes and re-run builds, the full build will not be cached, but using a build cache coupled with the above tips will make your builds much faster!\n\nIf you want to learn more about build caching, sign up for the free Maven Build Cache Deep Dive course at DPE University.\n\nLearn more about speeding up Maven builds\n\nUsing a combination of the techniques above, the Apache SCIMple build was reduced from roughly a minute and a half to eight seconds. Expect to save even more time on larger projects! Try out these steps on your favorite project, and let us know your results.\n\n In addition to the above tips, there are a handful of other things you may want to look into:\n• Inspect your CI build configurations – It’s common for projects to run multiple Maven invocations sequentially. Instead, you can combine them into a single Maven execution or run each command in parallel.\n• Use the Maven Daemon – The Maven Daemon keeps a Maven process running in the background; each time you start a build, a super fast natively compiled GraalVM binary sends a message to the Maven Daemon to run your requested build. And it automatically runs your build in parallel.\n• Keep Maven up to date – Maven has made many performance improvements over the years. Keep the Maven version and plugins updated!\n• Run individual tests in your IDE – I’ve seen many cases where you could edit your code in an IDE, but you had to run a full Maven build to get the tests to run correctly. This adds toil to development, and that toil is increased when you want to debug one of your tests. Ideally, it should be a single click to run the test you are working on.\n• Cache your dependencies on CI – Enable caching of your dependencies on your CI server. By default, your CI server may start with a clean directory, so each build needs to download all your dependencies and plugins. Caching may speed this up!\n\nNOTE: If you’re caching your local Maven repository, be sure to take the advice above about using instead of . (You don’t want to pollute the repository with old build output.)\n\n These tips are just the first steps towards faster, more efficient Maven builds. But the journey doesn’t stop here! Make sure you continue to monitor your builds to avoid build time regressions. To learn more, check out these related resources:\n• Build Rot: The Hidden Technical Debt in Maven and Gradle Builds\n• Maven Dependency Hell: Five Tips to Get Out\n\nFor more great content, follow us on Twitter and LinkedIn or subscribe to our YouTube channel."
    },
    {
        "link": "https://stackoverflow.com/questions/57363957/how-to-run-maven-build-multithreaded-all-the-time-by-default",
        "document": "I want to spare the time typing a -T3 on the command line as I want all the maven builds I will ever do to run multithreaded.\n\nMaven 3.3.9 I googled but didn't find anything promising, only the suggestion to add an environment variable for command line opts and append that to every maven call on commandline.\n\nThis way, every time, still a manual step is required (entering the environment variable's name) to do a parallel build.\n\nI'd like to configure that globally in the mvn settings.xml file."
    }
]