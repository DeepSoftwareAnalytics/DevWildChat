[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.RotateAround.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close Switch to Manual\n\nRotates the transform about passing through in world coordinates by degrees.\n\nThis modifies both the position and the rotation of the transform."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-correctly-use-rotatearound/889598",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/rotate-around-moving-object/878392",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/59339022/this-unity-script-makes-a-gameobject-rotate-around-an-object-how",
        "document": "is the vector direction from to target. is a function that derives a from a vector you'd like your object to face towards. Spherically interpolates rotation between two rotations meaning it rotates from a given rotation to another smoothly.\n\nNow to the explanation.\n\nIt revolves around the target because of the without it your object will just rotate to face the target (because of the ) on its own axis with no movement. In the the third parameter (3 * Time.deltaTime) means move the object forward along its z axis 3 units/second therefore it revoles because it's constantly trying to move 3 units/second on the z axis but the keeps pulling it in making it rotate towards the target so moves it and keeps rotating it back to target which results in orbiting.\n\nAnd you can't just use because\n• You won't be able to configure which way your object faces it'll just revolve around a target. You can use it in combination with but that'll result in some jittery effects while on the code above Spherically interpolates rotation which basically means smoother rotation and less jittery.\n• You won't be able to specify rotation radius with\n\nThe object runs away because in the third parameter (3 * Time.deltaTime) means move the object forward along its z axis 3 units/second while -3 means move it backward therefore it runs away But if you look closer it's still facing the target. Instead of moving back on the Z axis it moves back along the direction facing the target because of the and functions.\n\nI hope this explained it well if you have any more questions/need more clafication just reply and I'll get back to you."
    },
    {
        "link": "https://gamedevbeginner.com/how-to-rotate-in-unity-complete-beginners-guide",
        "document": "Rotating an object in Unity can be very straightforward.\n\nJust as there are many different ways to move an object, there are many different ways to rotate one too.\n\nWhich means that knowing the right method to use, in order to get the effect that you want, can be a little confusing at first.\n\nBut don’t worry, because in this in-depth guide I’ll show you all of the different methods for rotating an object in Unity, and the best time to use each of them, step by step.\n\nHow to rotate an object in Unity\n\nThere are a lot of different ways to rotate an object in Unity.\n\nSome methods are simple, some are more complex.\n\nWhile others work best for certain tasks.\n\nWhile there are a lot of different options available to you, many of them work in similar ways.\n\nWhich means that once you’re used to the basics of rotating an object in Unity, you’ll find it easier to use some of the more advanced rotation features that Unity offers.\n\nSo what is the basic method?\n\nRotation in Unity typically works by specifying an amount of rotation in degrees around the X, Y or Z axis of an object.\n\nIn the Inspector, you’ll see an object’s rotation as a Vector 3 value:\n\nIn the same way that a game object’s position in the world can be set using its Transform component…\n\nAn object’s rotation can also be set directly via its Transform,\n\nIn this example, I’ve set the rotation of the object to 10 degrees around the Y Axis.\n\nNotice, however, that I didn’t set the rotation property directly like I might do when setting an object’s position, for example.\n\nWhy did I do it like that?\n\nBehind the scenes, Unity calculates rotation using Quaternions, meaning that the rotation property of an object is not actually a Vector 3, it’s a Quaternion.\n\nThe rotation value you see in the Inspector is the real Quaternion rotation converted to a Vector 3 value, an Euler Angle, which is rotation expressed as an XYZ value for pitch, yaw and roll.\n\nSo, when using Transform.eulerAngles, you’re essentially setting and reading a converted value.\n\nThis means that if you want to set the rotation property directly, you’ll need to use a Quaternion value instead.\n\nOr, instead of working in Quaternions, you can convert a Vector 3 Euler Angle rotation into a Quaternion.\n\nThe Euler Angles property is a convenient way to set and read an object’s rotation in a format that’s easier to read and work with than Quaternions.\n\nSetting the rotation of an object directly via its rotation property can be very straightforward.\n\nWhile this works well for setting an absolute rotation, one time, it’s not as useful for adding rotation to an object.\n\nFor example, to rotate an object by a set amount of degrees from its current orientation to a new one.\n\nFor that, you’ll need the Rotate function.\n\nHow to Rotate an object in Unity using the Rotate function\n\nWhile setting the Euler Angles property of an object changes its absolute rotation, there will often be times when you want to add an amount of rotation to an object instead.\n\nYou might want to turn an object around by 90 degrees, or spin it on the spot, for example.\n\nSo how can you?\n\nHow to rotate an object by 90 degrees\n\nIt’s possible to add an amount of rotation to an object instead of setting its rotation value directly, in the same way that it’s possible to move an object by adding a vector to it, or by using the Translate function.\n\nThe easiest way to do this is by using the Rotate function.\n\nInstead of setting the rotation directly, like before, the Rotate function adds 90 degrees to the Y-Axis every time it’s called.\n\nThis can be useful for turning an object, changing its relative orientation or, if you apply an amount of rotation every frame, making it spin.\n\nHow to make an object spin\n\nIt’s possible to make an object spin on the spot by adding rotation to it every frame, scaling the rotation amount by delta time.\n\nMultiplying the rotation amount by Time.deltaTime (which is the duration of the last frame) makes sure that the rotation is smooth and consistent, even if the framerate of the game changes.\n\nEven if you’re a beginner, you may have already multiplied values by Delta Time before in Unity, as it’s usually required for any kind of function that occurs over time, such as movement, rotation or lerping. This is to make sure that, even if the framerate changes, the amount of movement over time remains the same.\n\nIn this case, it changes the amount of rotation from 20 degrees per frame to 20 degrees per second.\n\nWhich looks like this:\n\nAn object’s rotation in Unity can be relative to the world or it can be local, where the rotation amount is relative to the rotation of its parent object.\n\nBoth an object’s local rotation and its absolute world rotation can be read as properties of the object’s transform.\n\nA lot of the time, the local and world rotation of an object will be the same.\n\nThis is because, either the object that’s being rotated doesn’t have a parent object or because that parent object doesn’t have any rotation applied to it, in which case there’s no difference between the two values.\n\nFor example, if you rotate a child object by 90 degrees but don’t apply any rotation to the parent object, then the world rotation and the local rotation of the child object will both be the same.\n\nThis makes sense, because the child object has an amount of rotation applied to it which, when added to the parent’s rotation of zero, matches the object’s real rotation in the world.\n\nHowever, if you only apply rotation to an object’s parent then the local rotation value for the child object will be different.\n\nWhile the world rotation will match the parent, the local rotation will be zero, as no rotation is being applied by the child object’s transform.\n\nPut simply, the world rotation value is the absolute rotation relative to world space. In this example, it’s the rotation of the parent object plus any locally applied rotation, if there is any. While the local rotation value is just the extra rotation added by that object’s Transform component.\n\nSo, which one should you use?\n\nWhen working with rotation directly, for example when setting the rotation of an object via its Euler Angle property, you’ll have the option to set either its world rotation or its local rotation.\n\nBy default, when setting rotation directly, you’re setting the object’s world rotation:\n\nSetting the world rotation of a child object will rotate it into that position absolutely.\n\nThis means that if the object has a parent with any rotation, the local rotation of the child will not be set to the new rotation value as you might expect. Instead, it will be set to a value that is equal to the difference between the parent’s rotation and the world rotation.\n\nBasically, the local rotation will be set to whatever it needs to be in order to achieve the absolute world rotation you specified.\n\nFor example, if you set a child object to a world rotation of 50 degrees around an axis, and the object’s parent is already rotated by 10 degrees, the child object’s rotation will be set to 40 degrees, not the 50 you passed in.\n\nThe rotation of the object will technically be correct, you’ll get exactly what you asked for, but you may get some confusing results if you apply world rotation to child objects in this way.\n\nSo if you find that, when setting the rotation of an object via scripting, the Inspector values and the rotation don’t match, it might be because you’re setting the world rotation of a child object.\n\nIf, however, you only want to apply rotation locally, you can do that by using the local rotation value:\n\nA lot of the time, this won’t make any difference.\n\nWhen the object you rotate doesn’t have a parent, or if the parent isn’t rotated, using either method will produce the same effect.\n\nHowever, there may be times when you’d like to position an object one way and rotate it another.\n\nFor example, if you want to spin an object that’s already rotated, like this titled chair:\n\nOne of the easiest ways to achieve this, and other rotation effects like it, is to simply nest the object inside another empty game object.\n\nThe child object can then be tilted to any local rotation you like, while the parent container can be automatically rotated on a flat Y-Axis in world space.\n\nSeparating the orientation of an object from its rotation like this can be useful for making rotation simpler to manage and easier to control.\n\nAlternatively, if you don’t want to nest objects together, many of Unity’s built-in rotation functions, such as Transform Rotate can be overridden to operate in local or world space, recreating this effect, without the need for additional game objects.\n\nHow to rotate an object around a point in Unity\n\nRotating an object in Unity around one of its axes can be very simple.\n\nFor example, spinning a cube or turning an object upside-down can be very straightforward.\n\nAs you start to rotate more complex objects, you may begin to notice that the position of the pivot point around which an object rotates is just as important as the rotation itself.\n\nFor example, if you build a basic door out of some primitive shapes, and then try to rotate it by 90 degrees to open it, you’ll quickly notice that something is wrong.\n\nIn this example, I’ve built a door out of primitive objects, which means that the pivot point for the parent object, the main part of the door in my case, is in the centre.\n\nThis means that, when I rotate the object on its Y-Axis, it rotates around its centre.\n\nWhich, as I’m sure you’ve noticed, is not how most doors work.\n\nSo what can I do about it?\n\nTo fix it, I need to change the pivot point of the 3D object.\n\nHow to move the pivot point of a 3d object\n\nUsually, when working with 3D objects that have been created using other tools, the pivot point of the object is set when the object is created.\n\nFor example, if I purchase a door model from the Asset Store, chances are that the pivot point will be in the correct place, on the door’s hinge.\n\nI didn’t do that so, instead, I need to move the pivot point to a different position that allows me to rotate the door in the way I want.\n\nLuckily it’s an easy problem to solve, by adding the game object you want to rotate as a child of another object that can act as a pivot point.\n• Place the object you want to rotate in position\n• Next, create a new game object, the pivot, and place it at the pivot point of the rotation. Keep it separate while you’re positioning it.\n• Finally, in the hierarchy, drag the object you want to rotate on to the pivot object, making it a child of the pivot\n\nThen, instead of rotating the object directly, simply rotate the pivot.\n\nThe same technique can be used to centre an object’s pivot point if, for whatever reason, it’s not already in the middle of your object.\n\nYou could even nest the root object (now the pivot) in another object that doesn’t rotate, and manage the local rotation of the pivot using a script.\n\nCreating a parent object is an easy way to move the pivot point of an object.\n\nHowever, it’s also possible to rotate an object around a point, without creating a parent object pivot, using Rotate Around.\n\nHow to use Rotate Around in Unity\n\nRotate Around works in a similar way to the parent object pivot method.\n\nHowever, instead of creating a pivot point object and rotating it, the Rotate Around function takes a Vector 3 position, in world space, an axis to rotate around, and an angle in degrees.\n\nThis means that you can use Rotate Around to rotate an object either around a fixed point in world space,\n\nOr around another object entirely,\n\nWhen using Rotate Around, the first argument, the Vector 3 point, is the pivot of the rotation while the 2nd Vector 3, the axis, decides which direction rotation will be applied.\n\nThis is important, as it determines which route around the point the object will rotate.\n\nFinally, the float value, the angle, is the amount of rotation that will be applied in degrees.\n\nJust like the Rotate function, Rotate Around is only applied once when it’s called, which means if you want to create continuous rotation, you’ll need to call Rotate Around in Update, multiplying the angle value by Delta Time.\n\nRotate Around can be used to create rotation around other objects and points without using the parent object method, which can be useful for rotating an object around another, without needing to rotate both of them.\n\nFor example, I could use Rotate Around to create a basic orbit where the planet rotates around the sun and the planet’s moon rotates around the planet.\n\nIn this example, the moon is a child of the planet, which means that the moon’s position is being affected by the rotation of the planet.\n\nWhile Rotate Around can be very useful and straightforward, there are a couple of drawbacks to using this method.\n\nFor example, if you use Rotate Around to move one object around another, and the object that’s being orbited moves, it’s going to affect the path of rotation.\n\nAnd, while it’s possible to adjust the position of the object to avoid this, there’s another problem.\n\nWhen using the Rotate Around function, the rotating object turns towards the point it’s rotating around.\n\nIn fact, it can be very useful, such as when rotating a camera around an object.\n\nHowever, if you’re making an object orbit another, like in this example, it isn’t really how planetary orbits work.\n\nPlanets tend to spin around their own axis, while their position orbits around the sun.\n\nSo how can you rotate one object around another, without turning the object towards its point of orbit?\n\nHow can you rotate an object’s position around a point, without rotating the object itself?\n\nHow to rotate a vector in Unity\n\nA vector is a geometric value that defines a direction and length (which is the magnitude of the vector).\n\nIf you’ve worked with any kind of movement from one position to another, or done anything with Raycasts in Unity, then you will have used vectors before. Put simply, they describe direction and distance using Vector 3 values.\n\nHowever… did you know that you can also rotate a vector by multiplying it by a Quaternion?\n\nThis works by multiplying the Quaternion rotation by the vector you want to rotate.\n\nThe resulting vector, which has now been rotated, can be used to calculate where the rotated object should be in relation to the object it’s orbiting.\n\nWhich means that, using vectors, it’s possible to rotate the position of one object around another in Unity, without actually rotating the object itself.\n\nLet’s say that I want to orbit one object, a planet, around another, the sun, at a radius of 10 units and at a speed of 30 degrees per second.\n\nIn this case, all I want to do is define a direction and a radius, which will be the distance from the sun that the planet should orbit.\n\nFor that, I can multiply Vector3.forward, which is shorthand for (0,0,1) by 10, the radius.\n\nThat will give me a vector of (0,0,10).\n\nI can then rotate the vector with an angle value, which I can add to every frame at 30 degrees per second, to create a circular orbit.\n\nWhat’s happening here is that I’m taking a basic forward vector and rotating it from its starting point every frame by the angle value.\n\nIn this case, I’m rotating around the Y-Axis, but I could also have entered different values to produce different results.\n\nNote, however, that the order of multiplication matters. When Multiplying a vector by a Quaternion the Quaternion must go on the left, otherwise, this won’t work (it won’t even compile).\n\nFinally, because the vector that I’ve created and rotated isn’t attached to anything (it basically describes a vector from the centre of the world), I’ve set it as an offset to the position of the orbited object, the Sun.\n\nThe result is a rotation of a vector between two virtual points, not objects, that calculates where one object should be in relation to another, creating a path of rotation. The orbiting object behaves as if it’s nested, however rotating the sun has no effect on the planet and it’s possible to rotate the planet independently of its orbit around the sun.\n\nIn this example, I only rotated around the global Y-Axis, which is useful for creating an easy orbit.\n\nHowever, if I wanted to, I could also set the rotation to match a specific direction-based axis.\n\nFor example, imagine that the planet is 10 units away but is also several units higher than the sun and I wanted to create a rotation based on that existing direction.\n\nIt’s possible to get a direction vector between two objects in Unity by subtracting their positions.\n\nI can then calculate a plane of rotation based on the starting direction and distance of the object from its point of orbit.\n\nIn this example, I’m measuring the direction and the distance of the object in Start, which gives me my orbit direction and radius.\n\nI’m also normalising the vector, which limits its magnitude to 1. This basically limits the vector to directional information only, and while you don’t need to do this, I’m doing it so that I can multiply the direction vector by the radius variable, allowing me to change it later.\n\nOnce I have a direction vector, instead of rotating it around the world’s Y-Axis, which would cause the planet to orbit somewhere above the sun, I’m creating a new Quaternion angle using the Quaternion Look Rotation function instead. Look Rotation basically turns a direction vector into a Quaternion angle.\n\nThen, to get the combined angle, I can multiply the Quaternion direction angle (which is the amount of tilt) by the angle of rotation (the angle float variable) to combine the two angles.\n\nI’m still using the basic forward vector as a starting point, however now, instead of only multiplying it by the angle of rotation, I’m also rotating it by the angle of direction as well.\n\nThis is useful for creating automatic planet orbits as now, all I need to do is position the object relative to the point or object I want it to orbit, and the script will calculate a trajectory around that object.\n\nAnd if I want to change the axis of the orbit, I can do so by simply entering the angle into the X-Axis or the Z-axis instead.\n\nThis method is great for creating a path of rotation around a single axis.\n\nHowever, there will often be times when you don’t want to just rotate one way around an object.\n\nFor example, what if you want to freely rotate a camera around the player using the mouse, or the keyboard, or using controller thumbsticks?\n\nHow can you pass input axes into a rotation function, to give the player control of the camera?\n\nHow to rotate the camera around an object in Unity\n\nBeing able to freely rotate the camera around an object with the mouse or other controls is a very common mechanic in many games; For example, to control the position of the camera around a player in 3rd-person.\n\nIn the previous example, moving a planet around the sun, I moved one object around another on a single plane of rotation, around the Y-Axis.\n\nRotating a camera around an object works in a similar way except, instead of a single fixed path, the player is able to freely move the camera around the object using two axes from the combined vertical and horizontal movements of the mouse, a controller thumbstick or keyboard keys.\n\nSo how do you do it?\n\nOne of the easiest ways to rotate the camera around an object is by using the Rotate Around function.\n\nThe Rotate Around function rotates an object around another point, relative to its distance, while turning the object to face the pivot.\n\nThis makes it ideal for creating a mouse orbit camera, as it keeps the camera looking at the object.\n\nThis works, first, by moving the camera so that it faces the target object, but set back by a distance that’s equal to the radius variable.\n\nNotice that I’m using the forward vector of the camera object that this script is attached to, not Vector3.forward, which is the world forward, to keep the camera in position.\n\nThen, using the Rotate Around function, the horizontal input of the mouse (its X-Axis) rotates around the target object around the Y-Axis, which moves the camera left and right around the player.\n\nWhile the vertical movement of the mouse moves the camera relative to its own X-Axis, moving it up and down.\n\nUsing Rotate Around, the object that’s being rotated will turn towards the point that it’s rotating around. For this particular use case, this is ideal, as it means that the camera will look towards the object it’s rotating around automatically, providing a simple method of rotating a camera around an object.\n\nIt works well and it’s straightforward.\n\nHowever, it is also possible to rotate the camera around an object without using the Rotate Around function.\n\nHere’s how to do that…\n\nHow to rotate the camera around an object without using Rotate Around\n\nWhile the Rotate Around function is a straightforward way to rotate the camera around an object, it’s not the only method.\n\nJust as it was possible to orbit an object around a single axis by rotating a direction vector, the same method can be used to create 360 spherical rotation around a player or object.\n\nThe benefit of using this method over Rotate Around is that the rotation is entirely position based. Neither the object or the pivot point will be rotated as a result, which can be useful if, for whatever reason, you want to move an object around another with the mouse, but don’t want the object itself to rotate.\n\nLike before it works by defining a basic vector, such as the forward vector, and then rotating it into position using inputs from the mouse.\n\nIn this example, the X and Y movements of the mouse are added to two angle variables, angle X and angle Y.\n\nTo limit vertical movement, the Y angle is clamped at 89 degrees in both directions, to stop the camera from going over the top of the player and round again.\n\nThe X angle is also checked to see if it has moved past 360 degrees, or has moved below 0 degrees, in order to keep the value within a normal range.\n\nThis check isn’t strictly necessary, as the rotation function will work just fine without it, however keeping the value within a typical rotation range prevents a potential, although highly unlikely, problem of reaching the limit of the value type, as well as making the value easy to understand at a glance.\n\nFinally, a forward vector, multiplied by a distance that’s equal to the radius, is rotated by the two angles, and the position of the camera is then moved to match.\n\nBecause this method of moving a camera around an object doesn’t affect the object’s rotation, I’ve used the Transform Look At function, which turns an object to face the direction of a Transform.\n\nIn this case, the Look At function is helpful for making sure that the camera is actually facing the player way when it’s rotated.\n\nHowever, it’s not the only option for turning one object towards another…\n\nHow to rotate an object towards another\n\nThere are several methods available for rotating one object towards another.\n\nWhich one you use depends on how you want the object to rotate towards its target.\n\nHow to use Look At\n\nTransform Look At, which instantly snaps an object’s rotation to face the transform of another object, is probably the easiest method of rotating an object towards a specific point.\n\nIt takes a single Transform parameter, or a world position as a Vector 3, and will turn the object towards the target as soon as it’s called.\n\nLook At is great as a quick and easy way to snap an object’s rotation towards another object or towards another point in the world.\n\nHowever, because it’s a function of an object’s Transform, it automatically rotates towards the object when you call it.\n\nAnd while this can be extremely useful, there may be times when you want to calculate the rotation value required to look at an object, without actually looking at it.\n\nThe Quaternion Look Rotation function can help you do that.\n\nHow to use Look Rotation\n\nLook Rotation basically turns a direction vector into a rotation value.\n\nThis can be useful for calculating the rotation value towards an object or point, but without actually turning the object to point at it.\n\nFor example, I could calculate the direction vector of two points by subtracting their positions.\n\nI could then pass that direction vector into the Look Rotation function to get a matching Quaternion rotation value.\n\nI now have the rotation required to look at an object as a Quaternion value.\n\nWhy would I want to do this?\n\nWhy wouldn’t I just use Look At to turn the object to its target?\n\nWhile Look At can be used to instantly turn an object to face another object or point, depending on what you’re trying to do, you may not want the rotation to happen immediately.\n\nInstead, you might want the object to rotate towards the direction of its target slowly and smoothly.\n\nFollowing the direction of the target, instead of snapping to it.\n\nAnd for that, Look Rotation can be used to give you a target value for an object to smoothly rotate towards.\n\nSo, now that you have a target, how can you smoothly rotate an object?\n\nHow to slowly rotate towards another object\n\nMany examples of smoothly rotating an object towards another tend to use Lerp, which stands for linear interpolation, or Slerp, meaning spherical interpolation, to achieve this kind of eased movement.\n\nHowever… this isn’t actually what interpolation functions such as Lerp and Slerp are used for.\n\nLerp and Slerp are typically used to carry out a single movement over a period of time, such as a rotation from one fixed position to another, or a movement between two points.\n• More info: The right way to use Lerp in Unity (with examples)\n\nHowever, continuous movement, such as an arrow following the direction of a target, isn’t really what Lerp or Slerp are designed to do.\n\nIf using interpolation functions in this way gets you results that you like, then go ahead!\n\nBut… for continuously following the direction of a target, there’s a better function to use, Rotate Towards.\n\nHow to use Rotate Towards\n\nRotate Towards is a Quaternion function that works in a similar way to Move Towards, which you may have used before to move an object closer to a target.\n\nIt looks like this:\n\nIn the same way that Move Towards moves an object towards a target position a little bit each frame, Rotate Towards turns an object towards a target rotation each frame, without overshooting when it gets there.\n\nThe result is a smoothed movement towards a target rotation.\n\nThe target rotation is the direction vector of the object you want to rotate towards, which can be worked out by subtracting the target’s position from the object’s position.\n\nThe Look Rotation function then turns the direction vector into a Quaternion rotation.\n\nHow fast Rotate Towards works depends on the Max Degrees Delta of the function, which limits how much the object can rotate in a single step.\n\nPassing a degree value that’s multiplied by Delta Time into the Max Degrees Delta parameter sets the speed of the rotation in degrees per second.\n\nThe Rotate Toward function is ideal for continuous movement, as it’s always rotating towards a target at a specific speed.\n\nHowever, if you want to perform a single rotation movement over a fixed amount of time, for example, to rotate an object 90 degrees over two seconds, then Lerp and Slerp can help you to do exactly that.\n\nHow to rotate an object over time (Lerp & Slerp)\n\nWhile Rotate Towards continuously rotates an object towards a target at a set speed, you can use Lerp or Slerp to rotate an object by a fixed amount over a set period of time.\n\nThis works by taking a start rotation, such as the object’s own rotation at the start of the movement, a target rotation, which is where you want the object to end up, and a time value.\n\nThe time value, when calculated as time elapsed divided by duration, defines where the object should be during the movement. So, for example, at the halfway point (when time elapsed divided by duration equals 0.5) the rotation will be in the middle between the start and target rotations.\n\nThen, once the movement has finished and the time has elapsed, the object is snapped into its final rotation.\n\nSo when might you use this?\n\nQuaternion Lerp and Slerp are useful for rotating an object to a new rotation over a fixed amount of time.\n\nFor example, rotating an object around 90 degrees taking half a second,\n\nBecause the rotation movement has a start, an end, and is carried out over a number of frames, it works best when placed in a Coroutine.\n• More info: Coroutines in Unity, how and when to use them\n\nYou may have also noticed that, in this example, I used Quaternion Slerp, not Lerp.\n\nWhile the two functions are easily interchangeable, as both accept the same parameters, there is a slight difference between the two methods.\n\nQuaternion Lerp and Slerp are best used for smoothly moving an object from one rotation to another.\n\nHowever, like all of the previous examples in this guide, they work by setting the rotation of the object directly, basically emulating smooth movement with calculated values.\n\nBut what if you don’t want to directly set the orientation of the object?\n\nWhat if, instead of rotating an object in a measured way, you actually want to spin it round with energy?\n\nWhile rotation, just like movement, can be calculated and applied exactly, it’s also possible to apply rotation to a Rigidbody as a physical force.\n\nHow to Rotate a Rigidbody with the mouse\n\nPhysics-based rotation, which is created using angular force and drag, can be a great way to create natural object rotation.\n\nIt works by applying an amount of force, which causes an object to rotate, after which angular drag slows the object down bringing it to a stop.\n\nThis can be used for all kinds of mechanics; Spinning an inventory object by clicking and dragging the mouse, for example.\n\nSo how can you use it?\n\nHow to use the Add Torque function\n\nThe Add Torque function adds an amount of rotational force to a Rigidbody, taking a Vector 3 value to define the direction of the rotation in world space:\n\nSo how can you use it?\n\nLet’s say I want to create a floating object that can be spun around by clicking and dragging the mouse, similar to how you might view and rotate an item in a game.\n\nFor this to work, I’ll need to attach a Rigidbody to the object I want to spin.\n\nI’ve turned off the Rigidbody’s gravity so that the object doesn’t fall out of the air, and I’ve given the object 5 units of angular drag so that it will stop fairly quickly after being rotated.\n\nThen, to rotate the object using the mouse, all I need to do is pass in the Horizontal and Vertical axes of the mouse input into the Add Torque function whenever the mouse button is down.\n\nWhen the mouse button is held down, I’m storing the directional movement values of the mouse in float variables and multiplying them by a strength value.\n\nThen, in the Add Torque function, I’m applying the vertical mouse value to create rotational force around the X-Axis, while the horizontal mouse value creates force around the Y-Axis.\n\nThe end result is smooth, natural rotation, that’s applied when clicking and dragging the mouse.\n\nYou’ll notice that I’ve split the functionality of this script across both the Update and Fixed Update calls, connecting the two indirectly using variables.\n\nThis is because, while the physics-based Add Torque function should be in Fixed Update, so that the application of force is in sync with the physics steps of the game, the input checks, which are framerate dependent, need to be in Update to work properly.\n\nSplitting the functions like this prevents the different frequencies of Update and Fixed Update from affecting each other.\n\nHow to create an FPS camera in Unity\n\nIn the same way that it’s possible to use the mouse’s X and Y delta to apply force to a rigidbody object, you can also use the mouse’s input values to apply rotation to a camera object.\n\nThis allows you to tilt the camera up and down, around the X-Axis, or horizontally, around the Y-Axis, to turn.\n\nIt works by starting the camera at an X rotation of zero, meaning that it’s looking straight ahead, not up or down, and then simply adding or subtracting the input values of the mouse to a local Vector 3 value, the Look value.\n\nThe X value can then be clamped to a minimum and maximum degree of rotation, to prevent the player from looking too far up or down.\n\nFinally, the Look value can be translated into a rotation using the Euler Angles property.\n\nKeeping track of the rotation in a local Vector 3 is important, as it prevents you from having to check if the object is looking too far up or down using the converted Quaternion value.\n\nThis is because converting a Quaternion to an Euler can produce different results that, while not incorrect, could make it difficult to keep an object’s rotation within a set range.\n\nInstead, keeping track of the input rotation before it’s even applied to the object makes it easy to control.\n\nHow to Rotate objects in 2D\n\nA lot of the techniques used for rotating objects in 3D in Unity also apply when rotating in 2D.\n\nThis is because, generally speaking, normal game objects in Unity are the same in both 2D and 3D, with the only difference being that the forward vector, Z, usually represents depth in 2D.\n\nBecause of this, in order to get the results you want, it helps to be mindful of which axis an object is being rotated around.\n\nLuckily, however, most rotation functions in Unity allow you to specify which way is considered to be up, allowing you to change the orientation of the rotation if you need to.\n\nSuch as the Look At function which, in this example is set to face the player in 2D, with the forward axis set as up.\n\nHowever, in some cases, when working with 2D objects, even changing the orientation of the rotation may not get you the results you want. In which case you may find it easier to simply rotate around the object’s Z-Axis using a single float value.\n• How to rotate a 2D object to look at the mouse\n\nWhich is, in fact, exactly how rotation works with 2D Rigidbody objects.\n\nHow to rotate a Rigidbody in 2D\n\nWhile many objects rotate in similar ways in both 3D and 2D there are some specific differences when applying physics in 2D.\n\nThe 2D and 3D physics engines in Unity are separate. Which means that rotating a physics-based object in 2D can actually be much simpler than it is in 3D.\n\nThis is because true 2D rotation only occurs around a single axis. As a result, Rigidbody rotation is stored, and can be applied, using a single float value, which represents the amount of rotation in degrees clockwise or counter-clockwise."
    },
    {
        "link": "https://onewheelstudio.com/blog/2022/1/14/strategy-game-camera-unitys-new-input-system",
        "document": "The goal here is to build a camera controller that could be used in a wide variety of strategy games. And to do it using Unity’s “New” Input System.\n• None Dragging the world with the mouse\n• None Moving when the mouse is near the screen edge Since I’ll be using the New Input System, you’ll want to be familiar with that before diving too deep into this camera controller. Check either the video or the written blog post. If you’re just here for the code or want to copy and paste, you can get the code along with the Input Action Asset on GitHub.\n\nAdmittedly I don’t love the next function. It feels a bit clumsy, but since I’m not using a rigidbody and I want the camera to smoothly speed up and slow down I need a way to calculate and track the velocity (in the horizontal plane). So thus the Update Velocity function. Nothing too special in the function other than once again squashing the y dimension of the velocity to zero. After calculating the velocity we update the value of the last position for the next frame. This ensures we are calculating the velocity for the frame and not from the start. The next function is the poorly named Get Keyboard Movement function. This function polls the Camera Movement action to then set the target position. In order to translate the input into the motion we want we need to be a bit careful. We’ll take the x component of the input and multiply it by the Camera Right function and add that to the y component of the input multiplied by the Camera Forward function. This ensures that the movement is in the horizontal plane and relative to the camera. We then normalize the resulting vector to keep a uniform length so that the speed will be constant even if multiple keys are pressed (up and right for example).\n\nWith horizontal and rotational motion working it would be nice to move the camera up and down to let the player see more or less of the world. For controlling the “zooming” we’ll be using the mouse scroll wheel. This motion, I found to be one of the more complicated as there were several bits I wanted to include. I wanted there to be a min and max height for the camera - this keeps the player from zooming too far out or zooming down to nothingness - also while going up and down it feels a bit more natural if the camera gets closer or farther away from what it’s looking at. This zoom motion is another good use of events so we need need to make a couple of additions to the OnEnable and OnDisable. Just like we did with the rotation we need to subscribe and unsubscribe to the performed event for the zoom camera action. We also need to set the value of zoom height equal to the local y position of the camera - this gives an initial value and prevents the camera from doing wacky things. Then inside the Zoom Camera function, we’ll cache a reference to the y component of the scroll wheel input and divide by 100 - this scales the value to something more useful (in my opinion)."
    },
    {
        "link": "https://discussions.unity.com/t/manage-camera-snapping-cinemachine-new-input-system-for-touch-input/1553247",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/151vaqw/best_way_to_use_unity_new_input_system_with",
        "document": "I apologize in advance if my question/examples are unclear, English is not my main language !\n\nBasically I'm using Unity new input system but I would like to know how could I use it with multiples scripts. Most tutorial only show one example or one script at a time with the PlayerInput that Unity provides, but what if I want to separate my code to keep it clean ?\n\nExample : I got my PlayerMovement script that need the movement input and I got an \"Interactor\" (That interact with interactable objects) and maybe a PlayerView script etc.. etc..\n\nWhat would be the best way to get the input for each of thoses scripts ?\n\nFor the moment I'm using : InputActionReference and InputActionProperty but is there \"cleaner\" way to do ?"
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-InputManager.html",
        "document": "The Input Manager window allows you to define input axes and their associated actions for your Project. To access it, from Unity’s main menu, go to Edit > Project Settings, then select Input Manager from the navigation on the right.\n\nThe Input Manager uses the following types of controls:\n• Key refers to any key on a physical keyboard, such as W, Shift, or the space bar.\n• Button refers to any button on a physical controller (for example, gamepads), such as the X button on a remote control.\n• A virtual axis (plural: axes) is mapped to a control, such as a button or a key. When the user activates the control, the axis receives a value in the range of [–1..1]. You can use this value in your scripts \n\n A piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info .\n\nThe Physical keys option allows you to map key codes to the physical keyboard layout, rather than to the language-specific layout that may vary between users in different regions.\n\nFor example, on some keyboards the first row of letters reads “QWERTY”, and on others it reads “AZERTY”. This means if you scripted specific controls to use the well known “WASD” keys for movement, they would not be in the correct physical arrangement (like the arrow-key arrangement) on an AZERTY-layout keyboard.\n\nWith Physical Keys enabled, Unity uses a generic ANSI/ISO “Qwerty” layout to represent the physical location of the keys regardless of the user’s actual layout. This means if you specify the “Q” key, it will always be the left-most letter on the first row of letter keys, even if the user’s keyboard has a different letter in that position.\n\nNote, you should not read key input for in-game text input, because this will not allow users to enter non-Latin characters. Instead, use .\n\nEvery Project you create has a number of input axes created by default. These axes enable you to use keyboard, mouse, and joystick input in your Project straight away.\n\nTo see more about these axes, open the Input Manager window, and click the arrow next to any axis name to expand its properties.\n\nEach input axis has the following properties:\n• Between –1 and 1 for joystick and keyboard input. The neutral position for these axes is 0. Some types of controls, such as buttons on a keyboard, aren’t sensitive to input intensity, so they can’t produce values other than –1, 0, or 1.\n• Mouse delta (how much the mouse has moved during the last frame) for mouse input. The values for mouse input axes can be larger than 1 or smaller than –1 when the user moves the mouse quickly.\n\nTo add a virtual axis, increase the number in the Size field. This creates a new axis at the bottom of the list. The new axis copies the properties of the previous axis in the list.\n\nTo remove a virtual axis, you can either:\n• Decrease the number in the Size field. This removes the last axis in the list.\n• Right-click any axis, and select Delete Array Element.\n\n Note: You can’t undo this action.\n\nTo copy a virtual axis, right-click it and select Duplicate Array Element.\n\nTo map a key or button to an axis, enter its name in the Positive Button or Negative Button property in the Input Manager.\n\nMouse buttons are named and so on.\n\nYou can also query input for a specific key or button with and the naming conventions specified above. For example:\n\nAnother way to access keys is to use the enumeration.\n\nTo access virtual axes from scripts, you can use the axis name.\n\nFor example, to query the current value of the Horizontal axis and store it in a variable, you can use like this:\n\nFor axes that describe an event rather than a movement (for example, firing a weapon in a game), use instead.\n\nIf two or more axes have the same name, the query returns the axis with the largest absolute value. This makes it possible to assign more than one input device to an axis name.\n\nFor example, you can create two axes named Horizontal and assign one to keyboard input and the other to joystick input. If the user is using the joystick, input comes from the joystick and keyboard input is null. Otherwise, input comes from the keyboard and joystick input is null. This enables you to write a single script that covers input from multiple controllers.\n\nYou can use input from the Horizontal and Vertical axes and the method to move a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary in XZ space (forward, back, left, or right). Add the following code to the method on a script attached to the GameObject you want to move:\n\nrepresents the time that passed since the last frame. Multiplying the variable by ensures that the GameObject moves at a constant speed every frame."
    },
    {
        "link": "https://discussions.unity.com/t/best-practices-getting-started-tutorials/787435",
        "document": ""
    }
]