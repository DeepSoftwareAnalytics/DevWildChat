[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/input-keyboard/validation?view=netdesktop-9.0",
        "document": "When users enter data into your application, you may want to verify that the data is valid before your application uses it. You may require that certain text fields not be zero-length, that a field formatted as a telephone number, or that a string doesn't contain invalid characters. Windows Forms provides several ways for you to validate input in your application.\n\nIf you need to require users to enter data in a well-defined format, such as a telephone number or a part number, you can accomplish this quickly and with minimal code by using the MaskedTextBox control. A mask is a string made up of characters from a masking language that specifies which characters can be entered at any given position in the text box. The control displays a set of prompts to the user. If the user types an incorrect entry, for example, the user types a letter when a digit is required, the control will automatically reject the input.\n\nThe masking language that is used by MaskedTextBox is flexible. It allows you to specify required characters, optional characters, literal characters, such as hyphens and parentheses, currency characters, and date separators. The control also works well when bound to a data source. The Format event on a data binding can be used to reformat incoming data to comply with the mask, and the Parse event can be used to reformat outgoing data to comply with the specifications of the data field.\n\nIf you want full programmatic control over validation, or need complex validation checks, you should use the validation events that are built into most Windows Forms controls. Each control that accepts free-form user input has a Validating event that will occur whenever the control requires data validation. In the Validating event-handling method, you can validate user input in several ways. For example, if you have a text box that must contain a postal code, you can do the validation in the following ways:\n• None If the postal code must belong to a specific group of zip codes, you can do a string comparison on the input to validate the data entered by the user. For example, if the postal code must be in the set , then you can use a string comparison to validate the data.\n• None If the postal code must be in a specific form, you can use regular expressions to validate the data entered by the user. For example, to validate the form or , you can use the regular expression . To validate the form , you can use the regular expression . For more information about regular expressions, see .NET Regular Expressions and Regular Expression Examples.\n• None If the postal code must be a valid United States Zip code, you could call a Zip code Web service to validate the data entered by the user.\n\nThe Validating event is supplied an object of type CancelEventArgs. If you determine that the control's data isn't valid, cancel the Validating event by setting this object's Cancel property to . If you don't set the Cancel property, Windows Forms will assume that validation succeeded for that control and raise the Validated event.\n\nFor a code example that validates an email address in a TextBox, see the Validating event reference.\n\nValidation is useful when you have bound your controls to a data source, such as a database table. By using validation, you can make sure that your control's data satisfies the format required by the data source, and that it doesn't contain any special characters such as quotation marks and back slashes that might be unsafe.\n\nWhen you use data binding, the data in your control is synchronized with the data source during execution of the Validating event. If you cancel the Validating event, the data won't be synchronized with the data source.\n\nSo when does a control's data get validated? This is up to you, the developer. You can use either implicit or explicit validation, depending on the needs of your application.\n\nThe implicit validation approach validates data as the user enters it. Validate the data by reading the keys as they're pressed, or more commonly whenever the user takes the input focus away from the control. This approach is useful when you want to give the user immediate feedback about the data as they're working.\n\nIf you want to use implicit validation for a control, you must set that control's AutoValidate property to EnablePreventFocusChange or EnableAllowFocusChange. If you cancel the Validating event, the behavior of the control will be determined by what value you assigned to AutoValidate. If you assigned EnablePreventFocusChange, canceling the event will cause the Validated event not to occur. Input focus will remain on the current control until the user changes the data to a valid format. If you assigned EnableAllowFocusChange, the Validated event won't occur when you cancel the event, but focus will still change to the next control.\n\nAssigning Disable to the AutoValidate property prevents implicit validation altogether. To validate your controls, you'll have to use explicit validation.\n\nThe explicit validation approach validates data at one time. You can validate the data in response to a user action, such as clicking a Save button or a Next link. When the user action occurs, you can trigger explicit validation in one of the following ways:\n• Call Validate to validate the last control to have lost focus.\n• Call ValidateChildren to validate all child controls in a form or container control.\n• Call a custom method to validate the data in the controls manually.\n\nDifferent Windows Forms controls have different defaults for their AutoValidate property. The following table shows the most common controls and their defaults.\n\nWhen a control maintains focus because the data it contains is invalid, it's impossible to close the parent form in one of the usual ways:\n\nHowever, in some cases, you might want to let the user close the form regardless of whether the values in the controls are valid. You can override validation and close a form that still contains invalid data by creating a handler for the form's FormClosing event. In the event, set the Cancel property to . This forces the form to close. For more information and an example, see Form.FormClosing."
    },
    {
        "link": "https://stackoverflow.com/questions/8915151/c-sharp-validating-input-for-textbox-on-winforms",
        "document": "There are many ways to validate your TextBox. You can do this on every keystroke, at a later time, or on the event.\n\nThe event gets fired if your TextBox looses focus. When the user clicks on a other Control, for example. If your set the TextBox doesn't lose the focus.\n\nMSDN - Control.Validating Event When you change the focus by using the keyboard (TAB, SHIFT+TAB, and so on), by calling the Select or SelectNextControl methods, or by setting the ContainerControl.ActiveControl property to the current form, focus events occur in the following order When you change the focus by using the mouse or by calling the Focus method, focus events occur in the following order:\n\nYou can use the to visualize that your TextBox is not valid. Check out Using Error Provider Control in Windows Forms and C#\n• Using Error Provider Control in Windows Forms and C#"
    },
    {
        "link": "https://stackoverflow.com/questions/15430488/is-there-a-best-practice-way-to-validate-user-input",
        "document": "Subjectively, I think it would be better to provide instant feedback that the value the user entered is invalid. That way, they can immediately go back and fix it.\n\nI mean, think about it. The approach you propose would literally give them a giant list of problems at the end, which is not very user-friendly. Besides, how are they going to remember all of those problems to be able to go back and fix them one at a time? (Hint: they're not.)\n\nInstead, I recommend using the class to display any errors right next to the appropriate control. I talked a little bit more about this approach in my answer here and here.\n\nOf course, you'll still need to make sure upon final submission (clicking the OK/Submit button) that all the input is valid, but then that's just a simple case of checking for the presence of any errors.\n\nYes, the idea here is encapsulation. The Form class should only know about form stuff. It shouldn't be required to know what kind of input is/is not valid for all of your different controls.\n\nInstead, this validation logic should be placed elsewhere, such as in a class that stores your data. That class would expose public properties to get and set the data, and inside of the setter method, it would verify the data.\n\nThat means that all your Form has to do is call a setter method on your data class. The Form needs to know nothing about how to validate the data, or even what the data means, because the data class handles all of that.\n\nIf this is indeed the case, you will need to provide a constructor for the class that accepts as parameters all of the data it needs. The body of the constructor will then validate the specified data and throw an exception if any of it is invalid. The exception will prevent the class from being created, ensuring that no instance of a class that contains invalid data ever exists.\n\nSuch a class would probably not have setter methods at all—only getters.\n\nHowever, this is kind of an unusual requirement in the world of C# (however common it may be in C++). Generally, placing your validation code inside of the setters works just fine.\n\nWhy would that change anything? You still handle the validation inside of the private setters. If validation fails, you throw an exception. Because the constructor doesn't handle the exception, it continues bubbling up out of that method to the code that attempted to instantiate the object. If that code wants to handle the exception (e.g., to display an error message to the user), it can do so.\n\nGranted, throwing an exception in the case of invalid input is not necessarily a \"best practice\". The reason is that exceptions should generally be reserved for unexpected conditions, and users screwing up and providing you with invalid data is, well, to be expected. However:\n• This is the only option you have for data validation inside of a constructor, because constructors can't return values.\n• The cost of exception handling is basically negligible in UI code since modern computers can process exceptions faster than users can perceive on-screen changes."
    },
    {
        "link": "https://medium.com/developer-rants/form-validation-in-windows-forms-with-c-b0b07284d962",
        "document": "Looks like we are turning into a C# blog. I promise I will continue the AI series later.\n\nForm validation is a somewhat complicated business on every platform, as it’s the first line of defense against the worst thing ever happened to software: users. Windows Forms offers a fairly straightforward way to ensure those meatbags won’t yank the controls like the stupid apes they are.\n\nStep 1: Tell your project about your intents\n\nTo enable form validations, right click on your project in Solution Explorer, and select Add… > Reference.\n\nThe Reference Manager apparars. Find and check , then click OK.\n\nStep 2: Define the form as a class\n\nRight click your project again, and now select Add… > Class. Name your new class, and define each form field as a public value. For example, here is form data for a simple user registration form.\n\nBy , we can now add simple constraints to each value, using modifiers. This class is a highly versatile data validation library, and it’s certainly beyond the scope of this article to explain every bit of it. However, let’s delve on a few details for a moment.\n\nFor example, the modifier is a reference to the object. In the above example, there are no arguments for either use, but you can actually add some:\n\nMost validators accept arguments. For further details, refer to the documentation.\n\nStep 3: Build your application\n\nThis is necessary for the next step.\n\nStep 4: Create a data source\n\nGo to your form, where the validation will take place. Click the Data sources tab on the left edge of the screen, and then click the Add new data source button.\n\nThe Data Source Configuration Wizard appears. Under the Where will the application get data from? question, click Object, then click Next >.\n\nOn the next list, open your project, and find the object you just created. Check the checkbox next to its name, and then click Finish.\n\nStep 5: Create form controls\n\nThe data source appears on the sidebar. Open it, and you’ll see the fields you just defined.\n\nClicking a dropdown next to a field’s name reveals a list of UI controls that can be used to input this value: , and others. If you aren’t satisfied with the options, click Customize… and you can configure which controls should be offered for various data types. You may need it because, for example, Visual Studio doesn’t think you may need a for numeric values.\n\nAfter selecting which field should use what UI component, just grab and drag each one to your form designer. Visual Studio will automatically generate the appropriate form element, complete with labels. They will be configured to the constraints you set (i.e. the range of numeric values).\n\nIf you wish to use existing form elements, you can pull a data source field over them to bind them to one. For example, grab in the list, drag it into the Designer, and drop it on a text field or combo box. It doesn’t matter if the control already has a property, the form binding won’t override it.\n\nStep 6: Adding form buttons\n\nA typical form always has a Submit button, and optionally, a Reset button. Let’s bring our form in some shape with these.\n\nFirst of all, our form needs to receive its default values. This is done in a single line, preferably in the form’s event:\n\nThis is also how you reset your form. You can bind the Reset button’s event to this method, if nothing else is going to happen here.\n\nBut wait a minute, where did this come from?\n\nIt’s the name of the instance of our data source in . Go to Form Designer, and you’ll see it on the bottom of the window. That’s where elements with no visual representation always appear.\n\nThe Submit button is a bit more complicated, because this is where validation will take place.\n\nFirst, we prepare the validation mechanism with the method. This causes every pending change to be applied to the underlying data source (exact words from the documentation).\n\nSecond, we create a variable, , to retrieve the current content of the form. Then we create as a validation context, and to retrieve potential validation errors.\n\nThird, we try to validate the object with . As a result, the list gets filled up (if there are any errors), and we show a with each error. While this may not be the best way to show them, it’s perfect for a simple demonstration.\n\nCongratulations, your validation now works! Barely, though.\n\nStep 8: Let’s take it up a (tiny) notch!\n\nYou might want to use your own error messages. You might want different error messages for different errors. Let’s go back to our class, and add some. For example, the field may have several validators. Let’s add custom error messages to each!\n\nYou might want to enable or disable the Submit button depending on whether there are any errors. This can be done by looking at :\n\nNaturally, if you want this, you need to run the validation every time any of the form controls change."
    },
    {
        "link": "https://pearsonitcertification.com/articles/article.aspx?p=98149&seqNum=4",
        "document": "To make your application as robust as possible, the best solution to invalid or incorrect user input is to prevent the entry of \"bad\" data as often as possible. Validating user input before hand provides a better solution than very complex error-handling code that might add a great deal of resource overhead to your program. Four basic techniques are used to validate user input:\n• None Restricting the available values by using the proper type of control, configured with a specific list of allowed values. Controls such as RadioButton, ListBox, ComboBox, and CheckBox are often used for this type of validation. Configuring properties of the controls allows additional restriction of user input, such as controlling the case or length of TextBox input.\n• None Restricting data entry through controls by enabling or disabling them based on the state of other controls. As an example of this technique, a set of controls allowing the entry of address information might remain disabled until a valid CustomerID has been selected in another control.\n• None Capturing and evaluating user keystrokes and allowing only acceptable values to be recognized. This might be used to prevent the entry of symbol or alphabetic characters within a control that should hold only numeric characters.\n• None Evaluating a control's data as a whole and warning the user of incorrect or unacceptable values. This is often used to warn a user when attempting to change focus from the control or save the form.\n\nRestriction of allowable values within a control was discussed at greater length in Chapter 2, \"Controls on Forms.\" In addition to simply restricting input to a selection from a list of values, control properties can be configured to further limit possible input values. Of note are the CharacterCasing and MaxLength properties used in text input controls such as the TextBox.\n\nThe CharacterCasing property of a TextBox control can be used to change all input alphabetic characters to a particular case. The options for the CharacterCasing property are Normal (the default, which does not change the case of input characters), Upper (changes all the characters to uppercase), and Lower (changes all the characters to lowercase).\n\nThe MaxLength property of a TextBox or ComboBox is used to restrict the maximum number of characters the user can input into the control. A value of 0 (the default) specifies no specific limit for the number of characters that can be entered by the user. This property does not restrict the length of values that can be set programmatically.\n\nManipulating access properties such as the Enabled or ReadOnly properties can restrict data entry access within a control. When a control's Enabled value is set to false, it cannot receive focus. If the ReadOnly property of a TextBox control is set to true, it can still receive focus, allowing users to scroll through its contents while preventing changes.\n\nWhen a user presses a key, three events are fired in order:\n\nThe KeyPress event can be used to intercept input keyboard characters and perform validation tasks through the use of the KeyPressEventArgs class before the KeyUp event is handled. Table 3.4 details some important properties of the KeyPressEventArgs class.\n\nThe KeyPress event fires only for keys that generate character values, excluding function, control, and cursor-movement keys. To respond to the excluded keys, you must use the KeyDown and KeyUp events instead. These use the properties of the KeyEventArgs class, detailed in Table 3.5.\n\nValidation also can be performed to include the entire value entered within a control by configuring validation code to run before focus is lost or the form is closed. When a user enters or leaves a field, the following events occur in order:\n\nThe Validating event is the ideal place to store the validating logic for a field; we discuss the Validating event in the next section.\n\nThe Validating event is ideal for input value validation. You can write code to check the values presented and display an error message to the user or prevent the loss of focus from the current control until the value has been corrected.\n\nThe Focus method of the control can be used to redirect focus to the same control programmatically. Alternatively, the Cancel property of the CancelEventArgs object can be set to true, to prevent the transfer of focus from the current control.\n\nThe Validated event occurs after validation has occurred. It can be used to perform actions based on the validated values, such as enabling or disabling other controls, as discussed previously in this section.\n\nWhen using the Validating event to retain the focus in a control until you receive a valid input value, you can prevent the user from being able to obtain help on what constituted a valid input value by clicking another control such as the Help button in the toolbar. This is a result of the default setting (true) of the CausesValidation property of the Button control.\n\nIf you set the CausesValidation property of the Help button control to false, the control can act without triggering the Validating event in the control with current focus.\n\nThe ErrorProvider component provided within the Visual Studio .NET toolbox allows the display of error validation messages. A small icon includes a message that appears as a ToolTip when the user hovers the cursor over the displayed icon. Table 3.6 details the most important members of the ErrorProvider class.\n\nSpecifies the rate at which the error icon flashes. Specifies a value indicating when the error icon flashes. Specifies the parent control of the ErrorProvider control. Returns the error description string for the specified control. Specifies an icon to display next to the parent control. The icon is displayed only when an error-description string (SetError) has been set for the parent control. Sets the error-description string for the specified control. Specifies the location at which to place an error icon in relation to the control. Specifies the amount of extra space to leave between the specified control and its error icon.\n\nThis component offers many advantages over opening separate message boxes for each possible error, which can confuse users and complicate the desktop. The ErrorProvider component provides a simple user-friendly display that rapidly draws a user's attention to the control failing input validation. Figure 3.2 shows a form that includes an ErrorProvider component.\n\nFigure 3.2 A form displaying an example of the ErrorProvider component.\n\nThe following code shows how the ErrorProvider component can be used together with the Validating event to display errors during validation:\n\nIn this section, we discussed various techniques that can be used for user input validation. You also learned how the ErrorProvider component can be used to point to errors when the user enters input data on a Windows Form."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-9.0",
        "document": "The following code example creates an OpenFileDialog, sets several properties to define the file extension filter and dialog behavior, and displays the dialog box using the CommonDialog.ShowDialog method. The example requires a form with a Button placed on it and a reference to the System.IO namespace added to it.\n\nThis class allows you to check whether a file exists and to open it. The ShowReadOnly property determines whether a read-only check box appears in the dialog box. The ReadOnlyChecked property indicates whether the read-only check box is checked.\n\nMost of the core functionality for this class is found in the FileDialog class.\n\nOn a right-to-left operating system, setting the containing form's RightToLeft property to RightToLeft.Yes localizes the dialog's File Name, Open, and Cancel buttons. If the property is not set to RightToLeft.Yes, English text is used instead.\n\nIf you want to give the user the ability to select a folder instead of a file, use FolderBrowserDialog instead.\n\nInitializes an instance of the OpenFileDialog class. Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. (Inherited from FileDialog) Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. (Inherited from FileDialog) Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. (Inherited from FileDialog) Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . (Inherited from FileDialog) Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. (Inherited from FileDialog) Gets or sets the default file name extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). (Inherited from FileDialog) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. (Inherited from FileDialog) Gets the file names of all selected files in the dialog box. (Inherited from FileDialog) Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. (Inherited from FileDialog) Gets or sets the index of the filter currently selected in the file dialog box. (Inherited from FileDialog) Gets or sets the initial directory displayed by the file dialog box. (Inherited from FileDialog) Gets the Win32 instance handle for the application. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box allows multiple files to be selected. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). (Inherited from FileDialog) Gets values to initialize the FileDialog. (Inherited from FileDialog) Gets or sets a value indicating whether the read-only check box is selected. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. (Inherited from FileDialog) Gets the file name and extension for the file selected in the dialog box. The file name does not include the path. Gets an array of file names and extensions for all the selected files in the dialog box. The file names do not include the path. Gets or sets a value indicating whether the dialog box allows selection of read-only files. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box displays hidden and system files. (Inherited from FileDialog) Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box shows a preview for selected files. Gets or sets a value indicating whether the dialog box contains a read-only check box. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. (Inherited from FileDialog) Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. (Inherited from FileDialog) Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. (Inherited from FileDialog) Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Opens the file selected by the user, with read-only permission. The file is specified by the FileName property. Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. (Inherited from FileDialog) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. (Inherited from FileDialog) Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)\n• How to: Read Text from a File"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/filedialog-class?view=netframeworkdesktop-4.8",
        "document": "The Windows Forms FileDialog class is the common base class for the OpenFileDialog and SaveFileDialog components. You can make changes to the FileDialog class that affect the appearance and behavior of these dialog boxes, depending on the version of Windows the application is running on.\n\nHow To: Opt Out of File Dialog Box Automatic Upgrade\n\n Describes how to opt out of a style automatic upgrade to a file dialog box.\n\nHow To: Add a Custom Place to a File Dialog Box\n\n Describes how to add a custom file location to a file dialog box.\n\nKnown Folder GUIDs for File Dialog Custom Places\n\n List the folder names and their associated GUIDs."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog?view=windowsdesktop-9.0",
        "document": "The following code example uses the OpenFileDialog implementation of FileDialog and illustrates creating, setting of properties, and showing the dialog box. The example uses the ShowDialog method to display the dialog box and return the DialogResult. The example requires a form with a Button placed on it and the System.IO namespace added to it.\n\nFileDialog is an abstract class that contains common behavior for the OpenFileDialog and SaveFileDialog classes. It is not intended to be used directly but contains common behavior for those two classes. You cannot create an instance of FileDialog. Although the class is declared public, you cannot inherit from it, as it contains internal abstract methods. To create a dialog box to select or save a file, use OpenFileDialog or SaveFileDialog.\n\nFileDialog is a modal dialog box; therefore, when shown, it blocks the rest of the application until the user has chosen a file. When a dialog box is displayed modally, no input (keyboard or mouse click) can occur except to objects on the dialog box. The program must hide or close the dialog box (usually in response to some user action) before input to the calling program can occur.\n\nIf you want to enable users to select a folder instead of a file, use the FolderBrowserDialog.\n\nDepending upon the type of application, how data associated with the application is stored, and the reason for accessing the file system, there are many possible ways in which you can create a directory path. The following table shows the techniques for creating paths dynamically.\n\nNotice that a full path may be built up using one or more of the described techniques. For example, the GetFolderPath method might be used to obtain the path to the MyDocuments folder, then an application setting may be used to add a relative subdirectory portion.\n\nThe System.IO.Path class contains static members to assist in manipulating absolute and relative path strings, whereas the System.IO.File and System.IO.Directory classes have static members that actually manipulate files and directories, respectively.\n\nGets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. Gets or sets the default file name extension. Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. Gets the file names of all selected files in the dialog box. Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. Gets or sets the index of the filter currently selected in the file dialog box. Gets or sets the initial directory displayed by the file dialog box. Gets the Win32 instance handle for the application. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). Gets values to initialize the FileDialog. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. Gets or sets a value indicating whether the dialog box displays hidden and system files. Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)"
    },
    {
        "link": "https://github.com/dotnet/docs-desktop/blob/main/dotnet-desktop-guide/framework/winforms/controls/how-to-save-files-using-the-savefiledialog-component.md",
        "document": "Display the Save File dialog box and call a method to save the file selected by the user.\n\nUse the xref:System.Windows.Forms.SaveFileDialog component's xref:System.Windows.Forms.SaveFileDialog.OpenFile%2A method to save the file. This method gives you a xref:System.IO.Stream object you can write to.\n\nThe example below uses the xref:System.Windows.Forms.DialogResult property to get the name of the file, and the xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A method to save the file. The xref:System.Windows.Forms.SaveFileDialog.OpenFile%2A method gives you a stream to write the file to.\n\nIn the example below, there is a xref:System.Windows.Forms.Button control with an image assigned to it. When you click the button, a xref:System.Windows.Forms.SaveFileDialog component is instantiated with a filter that allows files of type .gif, .jpeg, and .bmp. If a file of this type is selected in the Save File dialog box, the button's image is saved.\n\nThe example assumes your form has a xref:System.Windows.Forms.Button control with its xref:System.Windows.Forms.ButtonBase.Image%2A property set to a file of type .gif, .jpeg, or .bmp.\n\n[!NOTE] The xref:System.Windows.Forms.FileDialog class's xref:System.Windows.Forms.FileDialog.FilterIndex%2A property (which, due to inheritance, is part of the xref:System.Windows.Forms.SaveFileDialog class) uses a one-based index. This is important if you are writing code to save data in a specific format (for example, saving a file in plain text versus binary format). This property is featured in the example below.\n\n' Displays a SaveFileDialog so the user can save the Image ' If the file name is not an empty string open it for saving. ' Saves the Image via a FileStream created by the OpenFile method. ' Saves the Image in the appropriate ImageFormat based upon the ' NOTE that the FilterIndex property is one-based.\n\n// Displays a SaveFileDialog so the user can save the Image // If the file name is not an empty string open it for saving. // Saves the Image via a FileStream created by the OpenFile method. // Saves the Image in the appropriate ImageFormat based upon the // NOTE that the FilterIndex property is one-based.\n\nSystem::Void (System::Object ^ sender, System::EventArgs ^ e) { Displays a SaveFileDialog so the user can save the Image SaveFileDialog ^ saveFileDialog1 = (); saveFileDialog1-> = ; saveFileDialog1-> = ; saveFileDialog1-> (); If the file name is not an empty string, open it for saving. (saveFileDialog1-> != ) { Saves the Image through a FileStream created by System::IO::FileStream ^ fs = safe_cast\\<System::IO::FileStream*>( saveFileDialog1-> ()); Saves the Image in the appropriate ImageFormat based on the file type selected in the dialog box. Note that the FilterIndex property is one based. (saveFileDialog1-> ) { : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Jpeg); ; : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Bmp); ; : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Gif); ; } fs-> (); } }\n\n(Visual C# and Visual C++) Place the following code in the form's constructor to register the event handler.\n\nFor more information about writing file streams, see xref:System.IO.FileStream.BeginWrite%2A and xref:System.IO.FileStream.Write%2A."
    },
    {
        "link": "https://stackoverflow.com/questions/4950948/openfiledialog-in-asp-net",
        "document": "How can I run sth like OpenFileDialog? In ASP.NET there's no this control.\n\nYes, there's option to use\n\nbut there's default name disabled to modifications.\n\nbut it doesn't work...or I'm doing sth wrong.\n\nIs there other possibility to do this?"
    },
    {
        "link": "https://stackoverflow.com/questions/4079191/winform-applications-event-handler",
        "document": "The reason that your code doesn't compile is that implicit conversions do not exist between different delegate-types, even when the signatures are 'compatible'.\n\nTry either of these:\n\nAs an aside, unless the intention is to learn how to use delegates, I suggest you don't create your own delegate-type when one that comes with the framework will do the job."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-add-an-event-handler?view=netdesktop-9.0",
        "document": "Events for controls (and for forms) are generally set through the Visual Studio Visual Designer for Windows Forms. Setting an event through the Visual Designer is known as handling an event at design-time. You can also handle events dynamically in code, known as handling events at run-time. An event created at run-time allows you to connect event handlers dynamically based on what your app is currently doing.\n\nIn Visual Studio, use the Visual Designer to manage handlers for control events. The Visual Designer will generate the handler code and add it to the event for you.\n\nUse the Properties pane to add or set the handler of an event:\n• None Open the Visual Designer of the form containing the control to change.\n• None Change the Properties pane mode to Events by pressing the events button ( ).\n• None Find the event you want to add a handler to, for example, the Click event:\n• None Do one of the following:\n• None Double-click the event to generate a new handler, it's blank if no handler is assigned. If it's not blank, this action opens the code for the form and navigates to the existing handler.\n• None Use the selection box ( ) to choose an existing handler. The selection box will list all methods that have a compatible method signature for the event handler.\n\nTo remove an event handler, you can't just delete handler code that is in the form's code-behind file, it's still referenced by the event. Use the Properties pane to remove the handler of an event:\n• None Open the Visual Designer of the form containing the control to change.\n• None Change the Properties pane mode to Events by pressing the events button ( ).\n• None Find the event containing the handler you want to remove, for example, the Click event:\n• None Right-click on the event and choose Reset.\n\nYou typically add event handlers to controls at design-time through the Visual Designer. You can, though, create controls at run-time, which requires you to add event handlers in code. Adding handlers in code also gives you the chance to add multiple handlers to the same event.\n\nThe following example shows how to create a control and add an event handler. This control is created in the event handler a different button. When Button1 is pressed. The code moves and sizes a new button. The new button's event is handled by the method. To get the new button to appear, it's added to the form's collection. There's also code to remove the event's handler, this is discussed in the Remove the handler section.\n\nTo run this code, do the following to a form with the Visual Studio Visual Designer:\n• Add a new button to the form and name it Button1.\n• Change the Properties pane mode to Events by pressing the event button ( ).\n• Double-click the Click event to generate a handler. This action opens the code window and generates a blank method.\n• Replace the method code with the previous code above.\n\nFor more information about C# events, see Events (C#) For more information about Visual Basic events, see Events (Visual Basic)\n\nThe Add a handler section used some code to demonstrate adding a handler. That code also contained a call to remove a handler:\n\nThis syntax can be used to remove any event handler from any event.\n\nFor more information about C# events, see Events (C#) For more information about Visual Basic events, see Events (Visual Basic)\n\nHow to use multiple events with the same handler\n\nWith the Visual Studio Visual Designer's Properties pane, you can select the same handler already in use by a different event. Follow the directions in the Set the handler section to select an existing handler instead of creating a new one.\n\nIn C#, the handler is attached to a control's event in the form's designer code, which changed through the Visual Designer. For more information about C# events, see Events (C#)\n\nIn Visual Basic, the handler is attached to a control's event in the form's code-behind file, where the event handler code is declared. Multiple keywords can be added to the event handler code to use it with multiple events. The Visual Designer will generate the keyword for you and add it to the event handler. However, you can easily do this yourself to any control's event and event handler, as long as the signature of the handler method matches the event. For more information about Visual Basic events, see Events (Visual Basic)\n\nThis code demonstrates how the same method can be used as a handler for two different events:"
    },
    {
        "link": "https://stackoverflow.com/questions/69138731/handle-menu-event-in-c-sharp-mvp",
        "document": "You have an issue with the order of your commands.\n\nWhen you write this:\n\nYou are saying \"any handers attached to should be copied to \". There are no attached handlers at the time. You are copying nothing.\n\nThen you call which attaches to the event delegate.\n\nIf you swap the order it works:\n\nHowever, this isn't the right way to attach events. You shouldn't need to care if someone has attached or handler.\n\nThat's the correct way.\n\nThe calls if there is a subscriber, but if there isn't it does nothing.\n\nI've also had a play with your code. This is closer to how I would do MVP:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.menuitem.drawitem?view=netframework-4.8.1",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example demonstrates how to handle the DrawItem event. This example draws a menu item using a Brush and a Font, and then draws a Rectangle around the menu item. The drawing is performed through the Graphics object, which is passed to the event handler in the DrawItemEventArgs parameter. This example requires that you have initialized the OwnerDraw property for the item to . For the C# example, add the following code in the form's constructor, after , to hook up the event:\n\nThe DrawItemEventArgs argument passed to a DrawItem event handler provides a Graphics object that enables you to perform drawing and other graphical operations on the surface of the menu item. You can use this event handler to create custom menus that meet the needs of your application. For more information about handling events, see Handling and Raising Events."
    },
    {
        "link": "https://developerfusion.com/samplechapter/1770/introduction-to-windows-forms/6",
        "document": ""
    }
]