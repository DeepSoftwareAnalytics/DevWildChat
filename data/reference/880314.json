[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://aiogram.dev",
        "document": ""
    },
    {
        "link": "https://docs.aiogram.dev/_/downloads/en/v2.25.1/pdf",
        "document": ""
    },
    {
        "link": "https://restack.io/p/aiogram-tutorial-answer-best-telegram-bot-frameworks-for-ai-cat-ai",
        "document": "Before you start setting up Aiogram, ensure your development environment meets the following requirements:\n• Python 3.8+: Download and install Python from Python's official website.\n• Preferred IDE: Use Visual Studio Code or PyCharm for a better development experience.\n\nHomebrew is a package manager for MacOS that simplifies the installation of software. To install Homebrew, run the following command in your terminal:\n\nPyEnv allows you to easily switch between multiple versions of Python. Install it using Homebrew:\n\nNow, install Python 3.10 (or any version 3.8+):\n\nPoetry is a dependency management tool for Python. Install it with:\n\nFollow the prompts to set up your project details. After initialization, install the dependencies:\n\nTo install Aiogram, use the following command within your Poetry environment:\n\nOnce Aiogram is installed, you can create a simple bot to test your setup. Here’s a basic example:\n\nReplace with your actual bot token. Run the script to start your bot and test if it responds to the command. This confirms that your Aiogram setup is successful and you are ready to develop your bot further."
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.18.0/changelog.html",
        "document": "\n• None Checked compatibility with Python 3.13 (added to the CI/CD processes), so now aiogram is totally compatible with it. Dropped compatibility with Python 3.8 due to this version being EOL. In some cases you will need to have the installed compiler (Rust or C++) to install some of the dependencies to compile packages from source on command.\n• None If you are using Windows, you will need to have the Visual Studio installed.\n• None If you are using Linux, you will need to have the package installed.\n• None If you are using macOS, you will need to have the Xcode installed. When developers of this dependencies will release new versions with precompiled wheels for Windows, Linux and macOS, this action will not be necessary anymore until the next version of the Python interpreter.\n• Integrated the attribute into various message manipulation methods, ensuring consistent data handling. This update eliminates the need to pass the as a parameter, instead directly accessing it from the instance attributes. #1586\n• None Add function to all built-in storage implementations, and #1431\n• None Enhanced the inheritance of handlers and actions in Scenes. Refactored to eliminate the copying of previously connected handlers and actions from parent scenes. Now, handlers are dynamically rebuilt based on the current class, properly utilizing class inheritance and enabling handler overrides. That’s mean that you can now override handlers and actions in the child scene, instead of copying and duplicating them. #1583\n• \n• None Added the class and the field in the class , allowing bots to send and receive inline buttons that copy arbitrary text.\n• None Added the parameter to the methods , , , , , , , , , , , , , , , , , and .\n• None Added the class for transactions related to paid broadcasted messages.\n• None Introduced the ability to add media to existing text messages using the method .\n• None Added support for hashtag and cashtag entities with a specified chat username that opens a search for the relevant tag within the specified chat.\n• None Fix PytestDeprecationWarning thrown by pytest-asyncio when running the tests #1584\n• From now UUID will have 32 bytes length instead of 36 bytes (with no separators) in the callback data representation. #1602\n• None Added possibility to use custom events in routers (If router does not support custom event it does not break and passes it to included routers). #1147\n• The strategy can be changed in dispatcher: If you have implemented you own storages you should extend record key generation with new one attribute -\n• None Added a tool to make text formatting flexible and easy. More details on the corresponding documentation page #1172\n• None Made list to revolve automatically in start_polling method if not set explicitly. #1178\n• None Change type of result in InlineQueryResult enum for and to more correct according to documentation. Change regexp for entities parsing to more correct ( ). #1146\n• None Fixed signature of startup/shutdown events to include the as the handler arguments. #1155\n• None Fixed the serialization error associated with nested subtypes like InputMedia, ChatMember, etc. The previously generated code resulted in an invalid schema under pydantic v2, which has stricter type parsing. Hence, subtypes without the specification of all subtype unions were generating an empty object. This has been rectified now. #1213\n• None Removed text filter in due to is planned to remove this filter few versions ago.\n• Note that this issue has breaking changes described in the Bot API changelog, this changes is not breaking in the API but breaking inside aiogram because Beta stage is not finished.\n• Note that arguments switch_pm_parameter and switch_pm_text was deprecated and should be changed to button argument as described in API docs.\n• Be careful, not all libraries is already updated to using V2\n• None Added global defaults and in addition to to the Bot instance, reworked internal request builder mechanism. #1142\n• None Replaced ContextVar’s with a new feature called Validation Context in Pydantic to improve the clarity, usability, and versatility of handling the Bot instance within method shortcuts. Breaking: The ‘bot’ argument now is required in\n\nThis update will break backward compability with Python 3.6 and works only with Python 3.7+: - contextvars (PEP-567); - New syntax for annotations (PEP-563). Changes: - Used contextvars instead of ; - Implemented filters factory; - Implemented new filters mechanism; - Allowed to customize command prefix in CommandsFilter; - Implemented mechanism of passing results from filters (as dicts) as kwargs in handlers (like fixtures in pytest); - Implemented states group feature; - Implemented FSM storage’s proxy; - Changed files uploading mechanism; - Implemented pipe for uploading files from URL; - Implemented I18n Middleware; - Errors handlers now should accept only two arguments (current update and exception); - Used instead of for Socks4/5 proxy; - types.ContentType was divided to and ; - Allowed to use rapidjson instead of ujson/json; - method in bot and dispatcher objects was renamed to ; Full changelog - You can read more details about this release in migration FAQ: https://aiogram.readthedocs.io/en/latest/migration_1_to_2.html"
    },
    {
        "link": "https://sqldocs.org/sqlite-database/aiosqlite-python",
        "document": "SQLite is one of the most widely used database engines in the world. Its lightweight, file-based architecture makes it perfect for embedded databases in desktop and mobile applications. However, Python’s standard SQLite library blocks the event loop while executing queries, hurting performance in asynchronous programs.\n\nEnter AioSQLite – an elegant asynchronous library interacting with SQLite from Python’s asyncio event loop without blocking. Let’s learn how AioSQLite makes SQLite fully non-blocking and explore some real-world use cases through examples.\n\nAioSQLite is an asynchronous, non-blocking SQLite driver for Python. It allows you to access SQLite databases from asyncio coroutines without blocking the main event loop thread.\n\nHere are some key things to know about AioSQLite:\n• It provides an async version of the SQLite Python API, replicating nearly all the features of\n• Uses a background thread per connection to talk to SQLite without blocking asyncio event loop\n• Lets you access SQLite using async/await instead of callbacks\n\nInstalling AioSQLite is as simple as:\n\nThat’s it! Now, let’s look at how to use it.\n\nThe API for AioSQLite mirrors , but with async methods instead of synchronous ones.\n\nFor example, here is how to connect to an SQLite database file, insert data, and query it:\n\nThere are a few key things to notice here:\n• Executing SQL happens via , using\n• Getting query results uses an async cursor that returns rows via\n\nThis allows the database code to run non-blockingly within an asyncio event loop.\n\nA key feature of AioSQLite is the use of async context managers to manage connections and cursors automatically:\n\nThis takes care of opening and closing connections for you.\n\nAioSQLite replicates most other advanced features of too:\n\nThe API supports nearly everything you can do in standard SQLite.\n\nHere is an example of using AioSQLite with a real-world data analytics database containing user analytics events:\n\nThis allows storing analytic event data from users in SQLite by leveraging AioSQLite’s non-blocking API!\n\nHere are some of the major benefits you get from using AioSQLite:\n• Avoid callback hell by using instead\n• Replicates nearly all functionality of module\n• Enables real-time analytics, streaming, and more use cases by removing SQLite blocking behavior\n\nIf you need to use SQLite from an asyncio app, AioSQLite is currently the best way to go about it while avoiding bottlenecks.\n\nAs you can see, AioSQLite retains nearly all the underlying SQLite functionality while adding async capabilities.\n\nAioSQLite brings the simplicity and ubiquity of SQLite to the world of asyncio and Python async programming. With its async API using , context managers, non-blocking behavior, and Python 3.7+ support, AioSQLite is the go-to choice for accessing SQLite from an asyncio application.\n\nWhether you need real-time analytics, streaming processing, or just a simple offline data store, AioSQLite takes the blocking factor out of SQLite. This lets you build highly concurrent database-backed programs without the headaches of callback hell or stalling the event loop.\n\nIf you found this useful, be sure to check out the AioSQLite documentation to learn more!"
    },
    {
        "link": "https://aiosqlite.omnilib.dev",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions. Connection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://github.com/omnilib/aiosqlite",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://stackoverflow.com/questions/67277025/how-to-avoid-making-new-connections-in-aiosqlite",
        "document": "I was using till now for my discord bot. In that case I could simply make a global variable of database connection and use it everywhere in the code.\n\nBut now in the case of I can't create a global variable because is a coroutine and I can only use it inside an async function.\n\nThe problem is that I call that function often and making new connections over and over again, Is it a good practice? Won't it cause database issues? How can I store a connection and use it everywhere"
    },
    {
        "link": "https://github.com/omnilib/aiosqlite/blob/main/README.rst",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    }
]