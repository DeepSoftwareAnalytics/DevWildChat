[
    {
        "link": "https://docs.python.org/3/library/re.html",
        "document": "This module provides regular expression matching operations similar to those found in Perl.\n\nBoth patterns and strings to be searched can be Unicode strings ( ) as well as 8-bit strings ( ). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a bytes pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.\n\nRegular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write as the pattern string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a and in the future this will become a . This behaviour will happen even if it is a valid escape sequence for a regular expression.\n\nThe solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with . So is a two-character string containing and , while is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.\n\nIt is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.\n\nA regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows. For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like , , or , are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so matches the string . (In the rest of this section, we’ll write RE’s in , usually without quotes, and strings to be matched .) Some characters, like or , are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers ( , , , , etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix , and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression matches any multiple of six characters. (Dot.) In the default mode, this matches any character except a newline. If the flag has been specified, this matches any character including a newline. matches any character regardless of flags. (Caret.) Matches the start of the string, and in mode also matches immediately after each newline. Matches the end of the string or just before the newline at the end of the string, and in mode also matches before a newline. matches both ‘foo’ and ‘foobar’, while the regular expression matches only ‘foo’. More interestingly, searching for in matches ‘foo2’ normally, but ‘foo1’ in mode; searching for a single in will find two (empty) matches: one just before the newline, and one at the end of the string. Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. Causes the resulting RE to match 1 or more repetitions of the preceding RE. will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. will match either ‘a’ or ‘ab’. The , , and quantifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE is matched against , it will match the entire string, and not just . Adding after the quantifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE will match only . Like the , , and quantifiers, those where is appended also match as many times as possible. However, unlike the true greedy quantifiers, these do not allow back-tracking when the expression following it fails to match. These are known as possessive quantifiers. For example, will match because the will match all 4 s, but, when the final is encountered, the expression is backtracked so that in the end the ends up matching 3 s total, and the fourth is matched by the final . However, when is used to match , the will match all 4 , but when the final fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. , and are equivalent to , and correspondingly. Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, will match exactly six characters, but not five. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, will match from 3 to 5 characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, will match or a thousand characters followed by a , but not . The comma may not be omitted or the modifier would be confused with the previously described form. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous quantifier. For example, on the 6-character string , will match 5 characters, while will only match 3 characters. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible without establishing any backtracking points. This is the possessive version of the quantifier above. For example, on the 6-character string , attempt to match 5 characters, then, requiring 2 more s, will need more characters than available and thus fail, while will match with capturing 5, then 4 s by backtracking and then the final 2 s are matched by the final in the pattern. is equivalent to . Either escapes special characters (permitting you to match characters like , , and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. Used to indicate a set of characters. In a set:\n• None Characters can be listed individually, e.g. will match , , or .\n• None Ranges of characters can be indicated by giving two characters and separating them by a , for example will match any lowercase ASCII letter, will match all the two-digits numbers from to , and will match any hexadecimal digit. If is escaped (e.g. ) or if it’s placed as the first or last character (e.g. or ), it will match a literal .\n• None Special characters lose their special meaning inside sets. For example, will match any of the literal characters , , , or .\n• None Character classes such as or (defined below) are also accepted inside a set, although the characters they match depend on the flags used.\n• None Characters that are not within a range can be matched by complementing the set. If the first character of the set is , all the characters that are not in the set will be matched. For example, will match any character except , and will match any character except . has no special meaning if it’s not the first character in the set.\n• None To match a literal inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both and will match a right bracket, as well as left bracket, braces, and parentheses.\n• None Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change a will be raised in ambiguous cases for the time being. That includes sets starting with a literal or containing literal character sequences , , , and . To avoid a warning escape them with a backslash. Changed in version 3.7: is raised if a character set contains constructs that will change semantically in the future. , where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the operator is never greedy. To match a literal , use , or enclose it inside a character class, as in . Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the special sequence, described below. To match the literals or , use or , or enclose them inside a character class: , . This is an extension notation (a following a is not meaningful otherwise). The first character after the determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; is the only exception to this rule. Following are the currently supported extensions. (One or more letters from the set , , , , , , .) The group matches the empty string; the letters set the corresponding flags for the entire regular expression: (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the function. Flags should be used first in the expression string. Changed in version 3.11: This construction can only be used at the start of the expression. A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (Zero or more letters from the set , , , , , , , optionally followed by followed by one or more letters from the , , , .) The letters set or remove the corresponding flags for the part of the expression: The letters , and are mutually exclusive when used as inline flags, so they can’t be combined or follow . Instead, when one of them appears in an inline group, it overrides the matching mode in the enclosing group. In Unicode patterns switches to ASCII-only matching, and switches to Unicode matching (default). In bytes patterns switches to locale dependent matching, and switches to ASCII-only matching (default). This override is only in effect for the narrow inline group, and the original matching mode is restored outside of the group. Changed in version 3.7: The letters , and also can be used in a group. Attempts to match as if it was a separate regular expression, and if successful, continues to match the rest of the pattern following it. If the subsequent pattern fails to match, the stack can only be unwound to a point before the because once exited, the expression, known as an atomic group, has thrown away all stack points within itself. Thus, would never match anything because first the would match all characters possible, then, having nothing left to match, the final would fail to match. Since there are no stack points saved in the Atomic Group, and there is no stack point before it, the entire expression would thus fail to match. Similar to regular parentheses, but the substring matched by the group is accessible via the symbolic group name name. Group names must be valid Python identifiers, and in patterns they can only contain bytes in the ASCII range. Each group name must be defined only once within a regular expression. A symbolic group is also a numbered group, just as if the group were not named. Named groups can be referenced in three contexts. If the pattern is (i.e. matching a string quoted with either single or double quotes): in the same pattern itself in a string passed to the repl argument of Changed in version 3.12: In patterns, group name can only contain bytes in the ASCII range ( - ). A backreference to a named group; it matches whatever text was matched by the earlier group named name. A comment; the contents of the parentheses are simply ignored. Matches if matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, will match only if it’s followed by . Matches if doesn’t match next. This is a negative lookahead assertion. For example, will match only if it’s not followed by . Matches if the current position in the string is preceded by a match for that ends at the current position. This is called a positive lookbehind assertion. will find a match in , since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that or are allowed, but and are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the function rather than the function: This example looks for a word following a hyphen: Changed in version 3.5: Added support for group references of fixed length. Matches if the current position in the string is not preceded by a match for . This is called a negative lookbehind assertion. Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. Will try to match with if the group with given id or name exists, and with if it doesn’t. is optional and can be omitted. For example, is a poor email matching pattern, which will match with as well as , but not with nor . Changed in version 3.12: Group id can only contain ASCII digits. In patterns, group name can only contain bytes in the ASCII range ( - ). The special sequences consist of and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, matches the character . Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, matches or , but not (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the and of a character class, all numeric escapes are treated as characters. Matches only at the start of the string. Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, is defined as the boundary between a and a character (or vice versa), or between and the beginning or end of the string. This means that matches , , , and but not or . The default word characters in Unicode (str) patterns are Unicode alphanumerics and the underscore, but this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Inside a character range, represents the backspace character, for compatibility with Python’s string literals. Matches the empty string, but only when it is not at the beginning or end of a word. This means that matches , , , but not , , or . is the opposite of , so word characters in Unicode (str) patterns are Unicode alphanumerics or the underscore, although this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Note that does not match an empty string, which differs from RE implementations in other programming languages such as Perl. This behavior is kept for compatibility reasons. Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes , and also many other digit characters. Matches if the flag is used. Matches any decimal digit in the ASCII character set; this is equivalent to . Matches any character which is not a decimal digit. This is the opposite of . Matches if the flag is used. Matches Unicode whitespace characters (as defined by ). This includes , and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages. Matches if the flag is used. Matches characters considered whitespace in the ASCII character set; this is equivalent to . Matches any character which is not a whitespace character. This is the opposite of . Matches if the flag is used. Matches Unicode word characters; this includes all Unicode alphanumeric characters (as defined by ), as well as the underscore ( ). Matches if the flag is used. Matches characters considered alphanumeric in the ASCII character set; this is equivalent to . If the flag is used, matches characters considered alphanumeric in the current locale and the underscore. Matches any character which is not a word character. This is the opposite of . By default, matches non-underscore ( ) characters for which returns . Matches if the flag is used. If the flag is used, matches characters which are neither alphanumeric in the current locale nor the underscore. Matches only at the end of the string. Most of the escape sequences supported by Python string literals are also accepted by the regular expression parser: , , and escape sequences are only recognized in Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length. Changed in version 3.3: The and escape sequences have been added. Changed in version 3.6: Unknown escapes consisting of and an ASCII letter now are errors. Changed in version 3.8: The escape sequence has been added. As in string literals, it expands to the named Unicode character (e.g. ).\n\nThe module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions. Most non-trivial applications always use the compiled form. Changed in version 3.6: Flag constants are now instances of , which is a subclass of . An class containing the regex options listed below. Make , , , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode (str) patterns, and is ignored for bytes patterns. The flag still exists for backward compatibility, but is redundant in Python 3 since matches are Unicode by default for patterns, and Unicode matching isn’t allowed for bytes patterns. and the inline flag are similarly redundant. Perform case-insensitive matching; expressions like will also match lowercase letters. Full Unicode matching (such as matching ) also works unless the flag is used to disable non-ASCII matches. The current locale does not change the effect of this flag unless the flag is also used. Note that when the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). If the flag is used, only letters ‘a’ to ‘z’ and ‘A’ to ‘Z’ are matched. Make , , , and case-insensitive matching dependent on the current locale. This flag can be used only with bytes patterns. This flag is discouraged; consider Unicode matching instead. The locale mechanism is very unreliable as it only handles one “culture” at a time and only works with 8-bit locales. Unicode matching is enabled by default for Unicode (str) patterns and it is able to handle different locales and languages. Changed in version 3.6: can be used only with bytes patterns and is not compatible with . Changed in version 3.7: Compiled regular expression objects with the flag no longer depend on the locale at compile time. Only the locale at matching time affects the result of matching. When specified, the pattern character matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character matches at the end of the string and at the end of each line (immediately preceding each newline). By default, matches only at the beginning of the string, and only at the end of the string and immediately before the newline (if any) at the end of the string. Indicates no flag being applied, the value is . This flag may be used as a default value for a function keyword argument or as a base value that will be conditionally ORed with other flags. Example of use as a default value: Make the special character match any character at all, including a newline; without this flag, will match anything except a newline. In Python 3, Unicode characters are matched by default for patterns. This flag is therefore redundant with no effect and is only kept for backward compatibility. See to restrict matching to ASCII characters instead. This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like , or . For example, and are not allowed. When a line contains a that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: Compile a regular expression pattern into a regular expression object, which can be used for matching using its , and other methods, described below. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). but using and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program. The compiled versions of the most recent patterns passed to and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn’t worry about compiling regular expressions. Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding . Return if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. Note that even in mode, will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use instead (see also search() vs. match()). The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If the whole string matches the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. Deprecated since version 3.13: Passing maxsplit and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Return all non-overlapping matches of pattern in string, as a list of strings or tuples. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return an iterator yielding objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by group 6 in the pattern. For example: If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single argument, and returns the replacement string. For example: The pattern may be a string or a . The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so returns . In string-type repl arguments, in addition to the character escapes and backreferences described above, will use the substring matched by the group named , as defined by the syntax. uses the corresponding group number; is therefore equivalent to , but isn’t ambiguous in a replacement such as . would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character . The backreference substitutes in the entire substring matched by the RE. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of and an ASCII letter now are errors. Empty matches for the pattern are replaced when adjacent to a previous non-empty match. Changed in version 3.12: Group id can only contain ASCII digits. In replacement strings, group name can only contain bytes in the ASCII range ( - ). Deprecated since version 3.13: Passing count and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Perform the same operation as , but return a tuple . The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: This function must not be used for the replacement string in and , only backslashes should be escaped. For example: Changed in version 3.3: The character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, , , , , , , , , , , , , and are no longer escaped. Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The instance has the following additional attributes: The index in pattern where compilation failed (may be ). The line corresponding to pos (may be ). The column corresponding to pos (may be ). Changed in version 3.13: was originally named ; the latter is kept as an alias for backward compatibility.\n\nMatch objects always have a boolean value of . Since and return when there is no match, you can test whether there was a match with a simple statement: Changed in version 3.9: supports to indicate a Unicode (str) or bytes match. See Generic Alias Type. Return the string obtained by doing backslash substitution on the template string template, as done by the method. Escapes such as are converted to the appropriate characters, and numeric backreferences ( , ) and named backreferences ( , ) are replaced by the contents of the corresponding group. The backreference will be replaced by the entire match. Changed in version 3.5: Unmatched groups are replaced with an empty string. Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is . If a group is contained in a part of the pattern that matched multiple times, the last match is returned. If the regular expression uses the syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an exception is raised. Named groups can also be referred to by their index: If a group matches multiple times, only the last match is accessible: # Returns only the last match. This is identical to . This allows easier access to an individual group from a match: Named groups are supported as well: Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to . If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to unless the default argument is given: # Second group defaults to None. # Now, the second group defaults to '0'. Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to . For example: Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to ) is Note that will equal if group matched a null string. For example, after , is 1, is 2, and are both 2, and raises an exception. An example that will remove remove_this from email addresses: For a match m, return the 2-tuple . Note that if group did not contribute to the match, this is . group defaults to zero, the entire match. The value of pos which was passed to the or method of a regex object. This is the index into the string at which the RE engine started looking for a match. The value of endpos which was passed to the or method of a regex object. This is the index into the string beyond which the RE engine will not go. The integer index of the last matched capturing group, or if no group was matched at all. For example, the expressions , , and will have if applied to the string , while the expression will have , if applied to the same string. The name of the last matched capturing group, or if the group didn’t have a name, or if no group was matched at all. The regular expression object whose or method produced this match instance. The string passed to or . Changed in version 3.7: Added support of and . Match objects are considered atomic.\n\nIn this example, we’ll use the following helper function to display match objects a little more gracefully: Suppose you are writing a poker program where a player’s hand is represented as a 5-character string with each character representing a card, “a” for ace, “k” for king, “q” for queen, “j” for jack, “t” for 10, and “2” through “9” representing the card with that value. To see if a given string is a valid hand, one could do the following: That last hand, , contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such: To find out what card the pair consists of, one could use the method of the match object in the following manner: # Error because re.match() returns None, which doesn't have a group() method: File , line , in : Python does not currently have an equivalent to . Regular expressions are generally more powerful, though also more verbose, than format strings. The table below offers some more-or-less equivalent mappings between format tokens and regular expressions. To extract the filename and numbers from a string like you would use a format like The equivalent regular expression would be\n• None checks for a match only at the beginning of the string\n• None checks for a match anywhere in the string (this is what Perl does by default)\n• None checks for entire string to be a match Regular expressions beginning with can be used with to restrict the match at the beginning of the string: Note however that in mode only matches at the beginning of the string, whereas using with a regular expression beginning with will match at the beginning of each line. splits a string into a list delimited by the passed pattern. The method is invaluable for converting textual data into data structures that can be easily read and modified by Python as demonstrated in the following example that creates a phonebook. First, here is the input. Normally it may come from a file, here we are using triple-quoted string syntax The entries are separated by one or more newlines. Now we convert the string into a list with each nonempty line having its own entry: Finally, split each entry into a list with first name, last name, telephone number, and address. We use the parameter of because the address has spaces, our splitting pattern, in it: The pattern matches the colon after the last name, so that it does not occur in the result list. With a of , we could separate the house number from the street name: replaces every occurrence of a pattern with a string or the result of a function. This example demonstrates using with a function to “munge” text, or randomize the order of all the characters in each word of a sentence except for the first and last characters: matches all occurrences of a pattern, not just the first one as does. For example, if a writer wanted to find all of the adverbs in some text, they might use in the following manner: \"He was carefully disguised but captured quickly by police.\" Finding all Adverbs and their Positions¶ If one wants more information about all matches of a pattern than the matched text, is useful as it provides objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use in the following manner: \"He was carefully disguised but captured quickly by police.\" Raw string notation ( ) keeps regular expressions sane. Without it, every backslash ( ) in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means . Without raw string notation, one must use , making the following lines of code functionally identical: A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: The tokenizer produces the following output: Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. The third edition of the book no longer covers Python at all, but the first edition covered writing good regular expression patterns in great detail."
    },
    {
        "link": "https://codecademy.com/resources/docs/python/regex/sub",
        "document": "The function replaces matching substrings with a new string for all occurrences, or a specified number.\n• : The replacement argument. This can either be a string or a function.\n• : An integer specifying the number of occurrences to replace. The default is to replace all matches.\n• : Specifies additional options such as , , , etc.\n\nThe following example replaces all occurrences of “BI” with “business intelligence”:\n\n'''The analytics firm uses a range of BI tools to visualize data. Their internal data science team suggests bi tools may be their most valuable resource.'''\n\nThis will print the following where “bi” is replaced with “business intelligence”:"
    },
    {
        "link": "https://docs.python.org/3/howto/regex.html",
        "document": "Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways. Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals. The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.\n\nWe’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters. For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers. Most letters and characters will simply match themselves. For example, the regular expression will match the string exactly. (You can enable a case-insensitive mode that would let this RE match or as well; more about this later.) There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do. Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO. The first metacharacters we’ll look at are and . They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a . For example, will match any of the characters , , or ; this is the same as , which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be . Metacharacters (except ) are not active inside classes. For example, will match any of the characters , , , or ; is usually a metacharacter, but inside a character class it’s stripped of its special nature. You can match the characters not listed within the class by complementing the set. This is indicated by including a as the first character of the class. For example, will match any character except . If the caret appears elsewhere in a character class, it does not have special meaning. For example: will match either a or a . Perhaps the most important metacharacter is the backslash, . As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a or , you can precede them with a backslash to remove their special meaning: or . Some of the special sequences beginning with represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace. Let’s take an example: matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class . If the regex pattern is a string, will match all the characters marked as letters in the Unicode database provided by the module. You can use the more restricted definition of in a string pattern by supplying the flag when compiling the regular expression. The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database. Matches any decimal digit; this is equivalent to the class . Matches any non-digit character; this is equivalent to the class . Matches any whitespace character; this is equivalent to the class . Matches any non-whitespace character; this is equivalent to the class . Matches any alphanumeric character; this is equivalent to the class . Matches any non-alphanumeric character; this is equivalent to the class . These sequences can be included inside a character class. For example, is a character class that will match any whitespace character, or or . The final metacharacter in this section is . It matches anything except a newline character, and there’s an alternate mode ( ) where it will match even a newline. is often used where you want to match “any character”. Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times. The first metacharacter for repeating things that we’ll look at is . doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once. For example, will match (0 characters), (1 ), (3 characters), and so forth. Repetitions such as are greedy; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions. A step-by-step example will make this more obvious. Let’s consider the expression . This matches the letter , zero or more letters from the class , and finally ends with a . Now imagine matching this RE against the string . The engine matches , going as far as it can, which is to the end of the string. The engine tries to match , but the current position is at the end of the string, so it fails. Back up, so that matches one less character. Try again, but the current position is at the last character, which is a . Back up again, so that is only matching . Try again. This time the character at the current position is , so it succeeds. The end of the RE has now been reached, and it has matched . This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for , and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all. Another repeating metacharacter is , which matches one or more times. Pay careful attention to the difference between and ; matches zero or more times, so whatever’s being repeated may not be present at all, while requires at least one occurrence. To use a similar example, will match (1 ), (3 s), but won’t match . There are two more repeating operators or quantifiers. The question mark character, , matches either once or zero times; you can think of it as marking something as being optional. For example, matches either or . The most complicated quantifier is , where m and n are decimal integers. This quantifier means there must be at least m repetitions, and at most n. For example, will match , , and . It won’t match , which has no slashes, or , which has four. You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity. The simplest case matches the preceding item exactly m times. For example, will only match . Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. is the same as , is equivalent to , and is the same as . It’s better to use , , or when you can, simply because they’re shorter and easier to read.\n\nNow that we’ve looked at some simple regular expressions, how do we actually use them in Python? The module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them. Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions. also accepts an optional flags argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do: The RE is passed to as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the module is simply a C extension module included with Python, just like the or modules. Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section. As stated earlier, regular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals. Let’s say you want to write a RE that matches the string , which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string . The resulting string that must be passed to must be . However, to express this as a Python string literal, both backslashes must be escaped again. In short, to match a literal backslash, one has to write as the RE string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand. The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with , so is a two-character string containing and , while is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation. In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a and will eventually become a , which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used. Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the docs for a complete listing. Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator. and return if no match can be found. If they’re successful, a match object instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more. You can learn about this by interactively experimenting with the module. This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the module, and compile a RE: Now, you can try matching various strings against the RE . An empty string shouldn’t match at all, since means ‘one or more repetitions’. should return in this case, which will cause the interpreter to print no output. You can explicitly print the result of to make this clear. Now, let’s try it on a string that it should match, such as . In this case, will return a match object, so you should store the result in a variable for later use. Now you can query the match object for information about the matching string. Match object instances also have several methods and attributes; the most important ones are: Return the string matched by the RE Return the starting position of the match Return the ending position of the match Return a tuple containing the (start, end) positions of the match Trying these methods will soon clarify their meaning: returns the substring that was matched by the RE. and return the starting and ending index of the match. returns both start and end indexes in a single tuple. Since the method only checks if the RE matches at the start of a string, will always be zero. However, the method of patterns scans through the string, so the match may not start at zero in that case. In actual programs, the most common style is to store the match object in a variable, and then check if it was . This usually looks like: Two pattern methods return all of the matches for a pattern. returns a list of matching strings: The prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a and will eventually become a . See The Backslash Plague. has to create the entire list before it can be returned as the result. The method returns a sequence of match object instances as an iterator: You don’t have to create a pattern object and call its methods; the module also provides top-level functions called , , , , and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either or a match object instance. Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again. Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache. Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the module under two names, a long name such as and a short, one-letter form such as . (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of is , for example.) Multiple flags can be specified by bitwise OR-ing them; sets both the and flags, for example. Here’s a table of the available flags, followed by a more detailed explanation of each one. Makes several escapes like , , and match only on ASCII characters with the respective property. Enable verbose REs, which can be organized more cleanly and understandably. Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, will match lowercase letters, too. Full Unicode matching also works unless the flag is used to disable non-ASCII matches. When the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). will match , , , or (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the flag. Make , , , and case-insensitive matching dependent on the current locale instead of the Unicode database. Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write to match words, but only matches the character class in bytes patterns; it won’t match bytes corresponding to or . If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to should also be considered a letter. Setting the flag when compiling a regular expression will cause the resulting compiled object to use these C functions for ; this is slower, but also enables to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Usually matches only at the beginning of the string, and matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). Makes the special character match any character at all, including a newline; without this flag, will match anything except a newline. Make , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a that’s neither in a character class or preceded by an unescaped backslash. For example, here’s a RE that uses ; see how much easier it is to read? Without the verbose setting, the RE would look like this: In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using .\n\nSo far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched. There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section. Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, is an assertion that the current position is located at a word boundary; the position isn’t changed by the at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times. Alternation, or the “or” operator. If A and B are regular expressions, will match any string that matches either A or B. has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. will match either or , not , a or an , and . To match a literal , use , or enclose it inside a character class, as in . Matches at the beginning of lines. Unless the flag has been set, this will only match at the beginning of the string. In mode, this also matches immediately after each newline within the string. For example, if you wish to match the word only at the beginning of a line, the RE to use is . Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character. To match a literal , use or enclose it inside a character class, as in . Matches only at the start of the string. When not in mode, and are effectively the same. In mode, they’re different: still matches only at the beginning of the string, but may match at any location inside the string that follows a newline character. Matches only at the end of the string. Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. The following example matches only when it’s a complete word; it won’t match when it’s contained inside another word. There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the in front of the RE string. Second, inside a character class, where there’s no use for this assertion, represents the backspace character, for compatibility with Python’s string literals. Another zero-width assertion, this is the opposite of , only matching when the current position is not at a word boundary. Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a , like this: This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the , metacharacters. and have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , , , or . For example, will match zero or more repetitions of . Groups indicated with , also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to , , , and . Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. The method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. For example, the following RE detects doubled words in a string. 'Paris in the the spring' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first. Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with without making Perl’s regular expressions confusingly different from standard REs. If they chose as a new metacharacter, for example, old expressions would be assuming that was a regular character and wouldn’t have escaped it by writing or . The solution chosen by the Perl developers was to use as the extension syntax. immediately after a parenthesis was a syntax error because the would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the indicate what extension is being used, so is one thing (a positive lookahead assertion) and is something else (a non-capturing group containing the subexpression ). Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a , you know that it’s an extension that’s specific to Python. Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs. Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: , where you can replace the with any other regular expression. Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as , and nest it within other groups (capturing or non-capturing). is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other. A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name. The syntax for a named group is one of the Python-specific extensions: . name is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The match object methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways: Additionally, you can retrieve named groups as a dictionary with : Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the module: It’s obviously much easier to retrieve , instead of having to remember to retrieve group 9. The syntax for backreferences in an expression such as refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: indicates that the contents of the group called name should again be matched at the current point. The regular expression for finding doubled words, can also be written as : 'Paris in the the spring' Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: Positive lookahead assertion. This succeeds if the contained regular expression, represented here by , successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string. To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a . For example, in , is the base name, and is the filename’s extension. The pattern to match this is quite simple: Notice that the needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing ; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches and and and . Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not ? Some incorrect attempts: The first attempt above tries to exclude by requiring that the first character of the extension is not a . This is wrong, because the pattern also doesn’t match . The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t ; the second character isn’t ; or the third character isn’t . This accepts and rejects , but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as . We’ll complicate the pattern again in an effort to fix it. In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as . The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both and as extensions, the pattern would get even more complicated and confusing. A negative lookahead cuts through all this confusion: The negative lookahead means: if the expression doesn’t match at this point, try the rest of the pattern; if does match, the whole pattern will fail. The trailing is required to ensure that something like , where the extension only starts with , will be allowed. The makes sure that the pattern works when there are multiple dots in the filename. Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either or :\n\nUp to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods: Split the string into a list, splitting it wherever the RE matches Find all substrings where the RE matches, and replace them with a different string Does the same thing as , but returns the new string and the number of replacements The method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the method of strings but provides much more generality in the delimiters that you can split by; string only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level function, too. Split string by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are performed. You can limit the number of splits made, by passing a value for maxsplit. When maxsplit is nonzero, at most maxsplit splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters. 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', ''] 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test, short and sweet, of split().'] Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls: The module-level function adds the RE to be used as the first argument, but is otherwise the same. Another common task is to find all the matches for a pattern, and replace them with a different string. The method takes a replacement value, which can be either a string or a function, and the string to be processed. Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in string by the replacement replacement. If the pattern isn’t found, string is returned unchanged. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. The default value of 0 means to replace all occurrences. Here’s a simple example of using the method. It replaces colour names with the word : The method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed: Empty matches are replaced only when they’re not adjacent to a previous empty match. If replacement is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. This example matches the word followed by a string enclosed in , , and changes to : There’s also a syntax for referring to named groups as defined by the syntax. will use the substring matched by the group named , and uses the corresponding group number. is therefore equivalent to , but isn’t ambiguous in a replacement string such as . ( would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character .) The following substitutions are all equivalent, but use all three variations of the replacement string. replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it. In the following example, the replacement function translates decimals into hexadecimal: When using the module-level function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. returns .\n\nRegular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls. Sometimes using the module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any features such as the flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine. One example might be replacing a single fixed string with another one; for example, you might replace with . seems like the function to use for this, but consider the method. Note that will also replace inside words, turning into , but the naive RE would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be , in order to require that have a word boundary on either side. This takes the job beyond ’s abilities.) Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like , but is capable of doing both tasks and will be faster than any regular expression operation can be. In short, before turning to the module, consider whether your problem can be solved with a faster and simpler string method. The function only checks if the RE matches at the beginning of the string while will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, will only report a successful match which will start at 0; if the match wouldn’t start at zero, will not report it. On the other hand, will scan forward through the string, reporting the first match it finds. Sometimes you’ll be tempted to keep using , and just add to the front of your RE. Resist this temptation and use instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with must match starting with a . The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a is found. Adding defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use instead. When repeating a regular expression, as in , the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of . The RE matches the in , and the consumes the rest of the string. There’s still more left in the RE, though, and the can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the . The final match extends from the in to the in , which isn’t what you want. In this case, the solution is to use the non-greedy quantifiers , , , or , which match as little text as possible. In the above example, the is tried immediately after the first matches, and when it fails, the engine advances a character at a time, retrying the at every step. This produces just the right result: By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly. The flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as is equivalent to the less readable , but will still match the characters , , or a space. In addition, you can also put comments inside a RE; comments extend from a character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly: (?P<value>.*?) # The header's value -- *? used to This is far more readable than:"
    },
    {
        "link": "https://geeksforgeeks.org/re-sub-python-regex",
        "document": "re.sub() method in Python parts of a string that match a given regular expression pattern with a new substring. This method provides a powerful way to modify strings by replacing specific patterns, which is useful in many real-life tasks like text processing or data cleaning.\n• pattern : The regular expression pattern we want to match.\n• repl: The string that will replace each match.\n• string : The string where replacements will be made.\n• None The return type of re.sub() is a string.\n\nIf regular expression has capture groups(defined by parentheses()), we can use the groups in the replacement string using \\1,\\3,etc., or by using replacement function.\n• None This code uses re.sub() to find all matches of a name followed by an age (e.g., \"John 25\") in the string and swaps the order, placing the age first followed by the name.\n• None The replacement string \\2 years old, \\1 uses the second capture group (age) and the first capture group (name) to format the output.\n\nTo limit the number of replacements in re.sub(), use the count parameter. By default, count=0, meaning all occurrences are replaced. Specifying a positive integer limits the number of replacements to that value.\n• None to replace only the first occurrence , as specified by the\n• None are left unchanged in the result."
    },
    {
        "link": "https://note.nkmk.me/en/python-str-replace-translate-re-sub",
        "document": "In Python, you can replace strings using the and methods, or the regular expression functions, and . You can also replace substrings at specified positions using slicing.\n\nYou can also remove a substring by replacing it with an empty string ( ).\n\nFor extracting substrings or finding their positions, see the following articles.\n• Search for a string in Python (Check if a substring is included/Get a substring position)\n\nThere are also methods to convert between uppercase and lowercase letters.\n• Uppercase and lowercase strings in Python (conversion and checking)\n\nIf you want to replace the contents of a text file, read the file as a string, process it, and save it again.\n• Read, write, and create files in Python (with and open())\n\nUse the method to replace substrings.\n\nSpecify the old string for the first argument and the new string for the second argument.\n\nYou can remove by specifying as the empty string .\n\nSpecify the maximum count of replacements:\n\nYou can set the maximum count of replacements with the third argument, . If is given, only the first occurrences are replaced.\n\nTo replace different strings with the same value, use regular expressions as described below.\n\nThere is no direct method to replace different strings with different values, but you can apply repeatedly.\n\nis called sequentially, so if the first contains a subsequent , it will also be replaced.\n\nTo replace individual characters, you can use the method, explained later in this article.\n\nSwapping two strings by replacing them sequentially, as described above, may not work.\n\nFirst, you should replace the target string with a temporary one.\n\nYou can define a function for this swapping operation as follows:\n\nNote that the function fails if the original string includes . To avoid this, check if is in the original string and, if so, choose a different value. In the example above, is simply set to an arbitrary string.\n\nTo swap individual characters, you can use the method, explained later in this article.\n\nIf the string contains only one type of newline character, you can specify it as the first argument in .\n\nBe careful if (LF, used in Unix OS including Mac) and (CR + LF, used in Windows) are mixed. Since is part of , the order of replacement may affect the result.\n\nYou can use to split a string with various newline characters, and to combine a list of strings. This method is safer and recommended, especially when the types of newline characters included are unknown.\n\nFor more information on handling line breaks in strings, see the following article:\n\nUse the method to replace multiple different characters. You can create the translation table required for using .\n\nSpecify a dictionary in , using the old character as the key and the new string as the value.\n\nThe old character must be a single character. The new string can be one or more characters, or , which removes the corresponding old character.\n\nThe first argument is a string of concatenated old characters. The second is a string of concatenated new characters. The third, which is optional, is a string of characters to be deleted.\n\nIn this case, the lengths of the first and second arguments should be the same.\n\nYou can swap characters with .\n\nIf you want to replace substrings using a regular expression (regex), use the function from the module.\n\nIn , the first argument is the regex pattern, the second is the new string, and the third is the string to be processed.\n\nAs with , you can specify the maximum count of replacements in the fourth argument, .\n\nYou can use to create a regex pattern object and call the method. This is more efficient if using the same regex pattern repeatedly.\n\nFor more information on the module, see the following article.\n• Regular expressions with the re module in Python\n\nReplace different substrings with the same string\n\nThe following two points are useful to keep in mind, even if you are unfamiliar with regex.\n\nEnclose characters with to create a pattern matching any character within those brackets. You can use this pattern to replace different characters with the same string.\n\nUsing the delimiter allows you to match any of the specified patterns. You can include special regex characters within each pattern or use plain strings. This functionality enables you to replace different substrings with the same string.\n\nIf you enclose part of the pattern in , you can refer to that matching part in the replacement string.\n\nIn a regular string ( or ), backslashes must be escaped like , but in a raw string ( or ), you can simply write .\n\nYou can specify a function, which takes a match object as its argument, as the second argument of . This allows for more complex operations.\n\nYou can also use a lambda expression.\n\nFor more information on regular expression match objects, see the following article.\n• How to use regex match objects in Python\n\nGet the count of replaced parts\n\nreturns a tuple of the replaced string and the number of parts replaced.\n\nThe usage of is the same as . You can use the part grouped by or specify the maximum number of replacements.\n\nThere is no built-in method to replace a substring at the specified position. You can achieve this by splitting the string using slicing, then concatenating the parts with another string.\n\nYou can obtain the string's length (number of characters) with .\n• Get the length of a string (number of characters) in Python\n\nThe original and replacement strings don't need to have the same number of characters, as this method simply concatenates a different string between the sliced parts.\n\nAdditionally, you can create a new string by inserting a different string at any position within the original string.\n\nSee the following article for more details on slicing.\n• How to slice a list, string, tuple in Python"
    },
    {
        "link": "https://docs.python.org/3/library/re.html",
        "document": "This module provides regular expression matching operations similar to those found in Perl.\n\nBoth patterns and strings to be searched can be Unicode strings ( ) as well as 8-bit strings ( ). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a bytes pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.\n\nRegular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write as the pattern string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a and in the future this will become a . This behaviour will happen even if it is a valid escape sequence for a regular expression.\n\nThe solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with . So is a two-character string containing and , while is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.\n\nIt is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.\n\nA regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows. For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like , , or , are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so matches the string . (In the rest of this section, we’ll write RE’s in , usually without quotes, and strings to be matched .) Some characters, like or , are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers ( , , , , etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix , and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression matches any multiple of six characters. (Dot.) In the default mode, this matches any character except a newline. If the flag has been specified, this matches any character including a newline. matches any character regardless of flags. (Caret.) Matches the start of the string, and in mode also matches immediately after each newline. Matches the end of the string or just before the newline at the end of the string, and in mode also matches before a newline. matches both ‘foo’ and ‘foobar’, while the regular expression matches only ‘foo’. More interestingly, searching for in matches ‘foo2’ normally, but ‘foo1’ in mode; searching for a single in will find two (empty) matches: one just before the newline, and one at the end of the string. Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. Causes the resulting RE to match 1 or more repetitions of the preceding RE. will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. will match either ‘a’ or ‘ab’. The , , and quantifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE is matched against , it will match the entire string, and not just . Adding after the quantifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE will match only . Like the , , and quantifiers, those where is appended also match as many times as possible. However, unlike the true greedy quantifiers, these do not allow back-tracking when the expression following it fails to match. These are known as possessive quantifiers. For example, will match because the will match all 4 s, but, when the final is encountered, the expression is backtracked so that in the end the ends up matching 3 s total, and the fourth is matched by the final . However, when is used to match , the will match all 4 , but when the final fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. , and are equivalent to , and correspondingly. Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, will match exactly six characters, but not five. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, will match from 3 to 5 characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, will match or a thousand characters followed by a , but not . The comma may not be omitted or the modifier would be confused with the previously described form. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous quantifier. For example, on the 6-character string , will match 5 characters, while will only match 3 characters. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible without establishing any backtracking points. This is the possessive version of the quantifier above. For example, on the 6-character string , attempt to match 5 characters, then, requiring 2 more s, will need more characters than available and thus fail, while will match with capturing 5, then 4 s by backtracking and then the final 2 s are matched by the final in the pattern. is equivalent to . Either escapes special characters (permitting you to match characters like , , and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. Used to indicate a set of characters. In a set:\n• None Characters can be listed individually, e.g. will match , , or .\n• None Ranges of characters can be indicated by giving two characters and separating them by a , for example will match any lowercase ASCII letter, will match all the two-digits numbers from to , and will match any hexadecimal digit. If is escaped (e.g. ) or if it’s placed as the first or last character (e.g. or ), it will match a literal .\n• None Special characters lose their special meaning inside sets. For example, will match any of the literal characters , , , or .\n• None Character classes such as or (defined below) are also accepted inside a set, although the characters they match depend on the flags used.\n• None Characters that are not within a range can be matched by complementing the set. If the first character of the set is , all the characters that are not in the set will be matched. For example, will match any character except , and will match any character except . has no special meaning if it’s not the first character in the set.\n• None To match a literal inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both and will match a right bracket, as well as left bracket, braces, and parentheses.\n• None Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change a will be raised in ambiguous cases for the time being. That includes sets starting with a literal or containing literal character sequences , , , and . To avoid a warning escape them with a backslash. Changed in version 3.7: is raised if a character set contains constructs that will change semantically in the future. , where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the operator is never greedy. To match a literal , use , or enclose it inside a character class, as in . Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the special sequence, described below. To match the literals or , use or , or enclose them inside a character class: , . This is an extension notation (a following a is not meaningful otherwise). The first character after the determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; is the only exception to this rule. Following are the currently supported extensions. (One or more letters from the set , , , , , , .) The group matches the empty string; the letters set the corresponding flags for the entire regular expression: (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the function. Flags should be used first in the expression string. Changed in version 3.11: This construction can only be used at the start of the expression. A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (Zero or more letters from the set , , , , , , , optionally followed by followed by one or more letters from the , , , .) The letters set or remove the corresponding flags for the part of the expression: The letters , and are mutually exclusive when used as inline flags, so they can’t be combined or follow . Instead, when one of them appears in an inline group, it overrides the matching mode in the enclosing group. In Unicode patterns switches to ASCII-only matching, and switches to Unicode matching (default). In bytes patterns switches to locale dependent matching, and switches to ASCII-only matching (default). This override is only in effect for the narrow inline group, and the original matching mode is restored outside of the group. Changed in version 3.7: The letters , and also can be used in a group. Attempts to match as if it was a separate regular expression, and if successful, continues to match the rest of the pattern following it. If the subsequent pattern fails to match, the stack can only be unwound to a point before the because once exited, the expression, known as an atomic group, has thrown away all stack points within itself. Thus, would never match anything because first the would match all characters possible, then, having nothing left to match, the final would fail to match. Since there are no stack points saved in the Atomic Group, and there is no stack point before it, the entire expression would thus fail to match. Similar to regular parentheses, but the substring matched by the group is accessible via the symbolic group name name. Group names must be valid Python identifiers, and in patterns they can only contain bytes in the ASCII range. Each group name must be defined only once within a regular expression. A symbolic group is also a numbered group, just as if the group were not named. Named groups can be referenced in three contexts. If the pattern is (i.e. matching a string quoted with either single or double quotes): in the same pattern itself in a string passed to the repl argument of Changed in version 3.12: In patterns, group name can only contain bytes in the ASCII range ( - ). A backreference to a named group; it matches whatever text was matched by the earlier group named name. A comment; the contents of the parentheses are simply ignored. Matches if matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, will match only if it’s followed by . Matches if doesn’t match next. This is a negative lookahead assertion. For example, will match only if it’s not followed by . Matches if the current position in the string is preceded by a match for that ends at the current position. This is called a positive lookbehind assertion. will find a match in , since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that or are allowed, but and are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the function rather than the function: This example looks for a word following a hyphen: Changed in version 3.5: Added support for group references of fixed length. Matches if the current position in the string is not preceded by a match for . This is called a negative lookbehind assertion. Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. Will try to match with if the group with given id or name exists, and with if it doesn’t. is optional and can be omitted. For example, is a poor email matching pattern, which will match with as well as , but not with nor . Changed in version 3.12: Group id can only contain ASCII digits. In patterns, group name can only contain bytes in the ASCII range ( - ). The special sequences consist of and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, matches the character . Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, matches or , but not (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the and of a character class, all numeric escapes are treated as characters. Matches only at the start of the string. Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, is defined as the boundary between a and a character (or vice versa), or between and the beginning or end of the string. This means that matches , , , and but not or . The default word characters in Unicode (str) patterns are Unicode alphanumerics and the underscore, but this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Inside a character range, represents the backspace character, for compatibility with Python’s string literals. Matches the empty string, but only when it is not at the beginning or end of a word. This means that matches , , , but not , , or . is the opposite of , so word characters in Unicode (str) patterns are Unicode alphanumerics or the underscore, although this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Note that does not match an empty string, which differs from RE implementations in other programming languages such as Perl. This behavior is kept for compatibility reasons. Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes , and also many other digit characters. Matches if the flag is used. Matches any decimal digit in the ASCII character set; this is equivalent to . Matches any character which is not a decimal digit. This is the opposite of . Matches if the flag is used. Matches Unicode whitespace characters (as defined by ). This includes , and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages. Matches if the flag is used. Matches characters considered whitespace in the ASCII character set; this is equivalent to . Matches any character which is not a whitespace character. This is the opposite of . Matches if the flag is used. Matches Unicode word characters; this includes all Unicode alphanumeric characters (as defined by ), as well as the underscore ( ). Matches if the flag is used. Matches characters considered alphanumeric in the ASCII character set; this is equivalent to . If the flag is used, matches characters considered alphanumeric in the current locale and the underscore. Matches any character which is not a word character. This is the opposite of . By default, matches non-underscore ( ) characters for which returns . Matches if the flag is used. If the flag is used, matches characters which are neither alphanumeric in the current locale nor the underscore. Matches only at the end of the string. Most of the escape sequences supported by Python string literals are also accepted by the regular expression parser: , , and escape sequences are only recognized in Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length. Changed in version 3.3: The and escape sequences have been added. Changed in version 3.6: Unknown escapes consisting of and an ASCII letter now are errors. Changed in version 3.8: The escape sequence has been added. As in string literals, it expands to the named Unicode character (e.g. ).\n\nThe module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions. Most non-trivial applications always use the compiled form. Changed in version 3.6: Flag constants are now instances of , which is a subclass of . An class containing the regex options listed below. Make , , , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode (str) patterns, and is ignored for bytes patterns. The flag still exists for backward compatibility, but is redundant in Python 3 since matches are Unicode by default for patterns, and Unicode matching isn’t allowed for bytes patterns. and the inline flag are similarly redundant. Perform case-insensitive matching; expressions like will also match lowercase letters. Full Unicode matching (such as matching ) also works unless the flag is used to disable non-ASCII matches. The current locale does not change the effect of this flag unless the flag is also used. Note that when the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). If the flag is used, only letters ‘a’ to ‘z’ and ‘A’ to ‘Z’ are matched. Make , , , and case-insensitive matching dependent on the current locale. This flag can be used only with bytes patterns. This flag is discouraged; consider Unicode matching instead. The locale mechanism is very unreliable as it only handles one “culture” at a time and only works with 8-bit locales. Unicode matching is enabled by default for Unicode (str) patterns and it is able to handle different locales and languages. Changed in version 3.6: can be used only with bytes patterns and is not compatible with . Changed in version 3.7: Compiled regular expression objects with the flag no longer depend on the locale at compile time. Only the locale at matching time affects the result of matching. When specified, the pattern character matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character matches at the end of the string and at the end of each line (immediately preceding each newline). By default, matches only at the beginning of the string, and only at the end of the string and immediately before the newline (if any) at the end of the string. Indicates no flag being applied, the value is . This flag may be used as a default value for a function keyword argument or as a base value that will be conditionally ORed with other flags. Example of use as a default value: Make the special character match any character at all, including a newline; without this flag, will match anything except a newline. In Python 3, Unicode characters are matched by default for patterns. This flag is therefore redundant with no effect and is only kept for backward compatibility. See to restrict matching to ASCII characters instead. This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like , or . For example, and are not allowed. When a line contains a that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: Compile a regular expression pattern into a regular expression object, which can be used for matching using its , and other methods, described below. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). but using and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program. The compiled versions of the most recent patterns passed to and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn’t worry about compiling regular expressions. Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding . Return if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. Note that even in mode, will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use instead (see also search() vs. match()). The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If the whole string matches the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. Deprecated since version 3.13: Passing maxsplit and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Return all non-overlapping matches of pattern in string, as a list of strings or tuples. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return an iterator yielding objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by group 6 in the pattern. For example: If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single argument, and returns the replacement string. For example: The pattern may be a string or a . The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so returns . In string-type repl arguments, in addition to the character escapes and backreferences described above, will use the substring matched by the group named , as defined by the syntax. uses the corresponding group number; is therefore equivalent to , but isn’t ambiguous in a replacement such as . would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character . The backreference substitutes in the entire substring matched by the RE. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of and an ASCII letter now are errors. Empty matches for the pattern are replaced when adjacent to a previous non-empty match. Changed in version 3.12: Group id can only contain ASCII digits. In replacement strings, group name can only contain bytes in the ASCII range ( - ). Deprecated since version 3.13: Passing count and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Perform the same operation as , but return a tuple . The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: This function must not be used for the replacement string in and , only backslashes should be escaped. For example: Changed in version 3.3: The character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, , , , , , , , , , , , , and are no longer escaped. Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The instance has the following additional attributes: The index in pattern where compilation failed (may be ). The line corresponding to pos (may be ). The column corresponding to pos (may be ). Changed in version 3.13: was originally named ; the latter is kept as an alias for backward compatibility.\n\nMatch objects always have a boolean value of . Since and return when there is no match, you can test whether there was a match with a simple statement: Changed in version 3.9: supports to indicate a Unicode (str) or bytes match. See Generic Alias Type. Return the string obtained by doing backslash substitution on the template string template, as done by the method. Escapes such as are converted to the appropriate characters, and numeric backreferences ( , ) and named backreferences ( , ) are replaced by the contents of the corresponding group. The backreference will be replaced by the entire match. Changed in version 3.5: Unmatched groups are replaced with an empty string. Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is . If a group is contained in a part of the pattern that matched multiple times, the last match is returned. If the regular expression uses the syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an exception is raised. Named groups can also be referred to by their index: If a group matches multiple times, only the last match is accessible: # Returns only the last match. This is identical to . This allows easier access to an individual group from a match: Named groups are supported as well: Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to . If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to unless the default argument is given: # Second group defaults to None. # Now, the second group defaults to '0'. Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to . For example: Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to ) is Note that will equal if group matched a null string. For example, after , is 1, is 2, and are both 2, and raises an exception. An example that will remove remove_this from email addresses: For a match m, return the 2-tuple . Note that if group did not contribute to the match, this is . group defaults to zero, the entire match. The value of pos which was passed to the or method of a regex object. This is the index into the string at which the RE engine started looking for a match. The value of endpos which was passed to the or method of a regex object. This is the index into the string beyond which the RE engine will not go. The integer index of the last matched capturing group, or if no group was matched at all. For example, the expressions , , and will have if applied to the string , while the expression will have , if applied to the same string. The name of the last matched capturing group, or if the group didn’t have a name, or if no group was matched at all. The regular expression object whose or method produced this match instance. The string passed to or . Changed in version 3.7: Added support of and . Match objects are considered atomic.\n\nIn this example, we’ll use the following helper function to display match objects a little more gracefully: Suppose you are writing a poker program where a player’s hand is represented as a 5-character string with each character representing a card, “a” for ace, “k” for king, “q” for queen, “j” for jack, “t” for 10, and “2” through “9” representing the card with that value. To see if a given string is a valid hand, one could do the following: That last hand, , contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such: To find out what card the pair consists of, one could use the method of the match object in the following manner: # Error because re.match() returns None, which doesn't have a group() method: File , line , in : Python does not currently have an equivalent to . Regular expressions are generally more powerful, though also more verbose, than format strings. The table below offers some more-or-less equivalent mappings between format tokens and regular expressions. To extract the filename and numbers from a string like you would use a format like The equivalent regular expression would be\n• None checks for a match only at the beginning of the string\n• None checks for a match anywhere in the string (this is what Perl does by default)\n• None checks for entire string to be a match Regular expressions beginning with can be used with to restrict the match at the beginning of the string: Note however that in mode only matches at the beginning of the string, whereas using with a regular expression beginning with will match at the beginning of each line. splits a string into a list delimited by the passed pattern. The method is invaluable for converting textual data into data structures that can be easily read and modified by Python as demonstrated in the following example that creates a phonebook. First, here is the input. Normally it may come from a file, here we are using triple-quoted string syntax The entries are separated by one or more newlines. Now we convert the string into a list with each nonempty line having its own entry: Finally, split each entry into a list with first name, last name, telephone number, and address. We use the parameter of because the address has spaces, our splitting pattern, in it: The pattern matches the colon after the last name, so that it does not occur in the result list. With a of , we could separate the house number from the street name: replaces every occurrence of a pattern with a string or the result of a function. This example demonstrates using with a function to “munge” text, or randomize the order of all the characters in each word of a sentence except for the first and last characters: matches all occurrences of a pattern, not just the first one as does. For example, if a writer wanted to find all of the adverbs in some text, they might use in the following manner: \"He was carefully disguised but captured quickly by police.\" Finding all Adverbs and their Positions¶ If one wants more information about all matches of a pattern than the matched text, is useful as it provides objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use in the following manner: \"He was carefully disguised but captured quickly by police.\" Raw string notation ( ) keeps regular expressions sane. Without it, every backslash ( ) in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means . Without raw string notation, one must use , making the following lines of code functionally identical: A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: The tokenizer produces the following output: Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. The third edition of the book no longer covers Python at all, but the first edition covered writing good regular expression patterns in great detail."
    },
    {
        "link": "https://docs.python.org/3/howto/regex.html",
        "document": "Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways. Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals. The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.\n\nWe’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters. For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers. Most letters and characters will simply match themselves. For example, the regular expression will match the string exactly. (You can enable a case-insensitive mode that would let this RE match or as well; more about this later.) There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do. Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO. The first metacharacters we’ll look at are and . They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a . For example, will match any of the characters , , or ; this is the same as , which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be . Metacharacters (except ) are not active inside classes. For example, will match any of the characters , , , or ; is usually a metacharacter, but inside a character class it’s stripped of its special nature. You can match the characters not listed within the class by complementing the set. This is indicated by including a as the first character of the class. For example, will match any character except . If the caret appears elsewhere in a character class, it does not have special meaning. For example: will match either a or a . Perhaps the most important metacharacter is the backslash, . As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a or , you can precede them with a backslash to remove their special meaning: or . Some of the special sequences beginning with represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace. Let’s take an example: matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class . If the regex pattern is a string, will match all the characters marked as letters in the Unicode database provided by the module. You can use the more restricted definition of in a string pattern by supplying the flag when compiling the regular expression. The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database. Matches any decimal digit; this is equivalent to the class . Matches any non-digit character; this is equivalent to the class . Matches any whitespace character; this is equivalent to the class . Matches any non-whitespace character; this is equivalent to the class . Matches any alphanumeric character; this is equivalent to the class . Matches any non-alphanumeric character; this is equivalent to the class . These sequences can be included inside a character class. For example, is a character class that will match any whitespace character, or or . The final metacharacter in this section is . It matches anything except a newline character, and there’s an alternate mode ( ) where it will match even a newline. is often used where you want to match “any character”. Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times. The first metacharacter for repeating things that we’ll look at is . doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once. For example, will match (0 characters), (1 ), (3 characters), and so forth. Repetitions such as are greedy; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions. A step-by-step example will make this more obvious. Let’s consider the expression . This matches the letter , zero or more letters from the class , and finally ends with a . Now imagine matching this RE against the string . The engine matches , going as far as it can, which is to the end of the string. The engine tries to match , but the current position is at the end of the string, so it fails. Back up, so that matches one less character. Try again, but the current position is at the last character, which is a . Back up again, so that is only matching . Try again. This time the character at the current position is , so it succeeds. The end of the RE has now been reached, and it has matched . This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for , and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all. Another repeating metacharacter is , which matches one or more times. Pay careful attention to the difference between and ; matches zero or more times, so whatever’s being repeated may not be present at all, while requires at least one occurrence. To use a similar example, will match (1 ), (3 s), but won’t match . There are two more repeating operators or quantifiers. The question mark character, , matches either once or zero times; you can think of it as marking something as being optional. For example, matches either or . The most complicated quantifier is , where m and n are decimal integers. This quantifier means there must be at least m repetitions, and at most n. For example, will match , , and . It won’t match , which has no slashes, or , which has four. You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity. The simplest case matches the preceding item exactly m times. For example, will only match . Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. is the same as , is equivalent to , and is the same as . It’s better to use , , or when you can, simply because they’re shorter and easier to read.\n\nNow that we’ve looked at some simple regular expressions, how do we actually use them in Python? The module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them. Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions. also accepts an optional flags argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do: The RE is passed to as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the module is simply a C extension module included with Python, just like the or modules. Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section. As stated earlier, regular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals. Let’s say you want to write a RE that matches the string , which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string . The resulting string that must be passed to must be . However, to express this as a Python string literal, both backslashes must be escaped again. In short, to match a literal backslash, one has to write as the RE string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand. The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with , so is a two-character string containing and , while is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation. In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a and will eventually become a , which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used. Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the docs for a complete listing. Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator. and return if no match can be found. If they’re successful, a match object instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more. You can learn about this by interactively experimenting with the module. This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the module, and compile a RE: Now, you can try matching various strings against the RE . An empty string shouldn’t match at all, since means ‘one or more repetitions’. should return in this case, which will cause the interpreter to print no output. You can explicitly print the result of to make this clear. Now, let’s try it on a string that it should match, such as . In this case, will return a match object, so you should store the result in a variable for later use. Now you can query the match object for information about the matching string. Match object instances also have several methods and attributes; the most important ones are: Return the string matched by the RE Return the starting position of the match Return the ending position of the match Return a tuple containing the (start, end) positions of the match Trying these methods will soon clarify their meaning: returns the substring that was matched by the RE. and return the starting and ending index of the match. returns both start and end indexes in a single tuple. Since the method only checks if the RE matches at the start of a string, will always be zero. However, the method of patterns scans through the string, so the match may not start at zero in that case. In actual programs, the most common style is to store the match object in a variable, and then check if it was . This usually looks like: Two pattern methods return all of the matches for a pattern. returns a list of matching strings: The prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a and will eventually become a . See The Backslash Plague. has to create the entire list before it can be returned as the result. The method returns a sequence of match object instances as an iterator: You don’t have to create a pattern object and call its methods; the module also provides top-level functions called , , , , and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either or a match object instance. Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again. Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache. Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the module under two names, a long name such as and a short, one-letter form such as . (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of is , for example.) Multiple flags can be specified by bitwise OR-ing them; sets both the and flags, for example. Here’s a table of the available flags, followed by a more detailed explanation of each one. Makes several escapes like , , and match only on ASCII characters with the respective property. Enable verbose REs, which can be organized more cleanly and understandably. Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, will match lowercase letters, too. Full Unicode matching also works unless the flag is used to disable non-ASCII matches. When the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). will match , , , or (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the flag. Make , , , and case-insensitive matching dependent on the current locale instead of the Unicode database. Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write to match words, but only matches the character class in bytes patterns; it won’t match bytes corresponding to or . If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to should also be considered a letter. Setting the flag when compiling a regular expression will cause the resulting compiled object to use these C functions for ; this is slower, but also enables to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Usually matches only at the beginning of the string, and matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). Makes the special character match any character at all, including a newline; without this flag, will match anything except a newline. Make , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a that’s neither in a character class or preceded by an unescaped backslash. For example, here’s a RE that uses ; see how much easier it is to read? Without the verbose setting, the RE would look like this: In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using .\n\nSo far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched. There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section. Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, is an assertion that the current position is located at a word boundary; the position isn’t changed by the at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times. Alternation, or the “or” operator. If A and B are regular expressions, will match any string that matches either A or B. has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. will match either or , not , a or an , and . To match a literal , use , or enclose it inside a character class, as in . Matches at the beginning of lines. Unless the flag has been set, this will only match at the beginning of the string. In mode, this also matches immediately after each newline within the string. For example, if you wish to match the word only at the beginning of a line, the RE to use is . Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character. To match a literal , use or enclose it inside a character class, as in . Matches only at the start of the string. When not in mode, and are effectively the same. In mode, they’re different: still matches only at the beginning of the string, but may match at any location inside the string that follows a newline character. Matches only at the end of the string. Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. The following example matches only when it’s a complete word; it won’t match when it’s contained inside another word. There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the in front of the RE string. Second, inside a character class, where there’s no use for this assertion, represents the backspace character, for compatibility with Python’s string literals. Another zero-width assertion, this is the opposite of , only matching when the current position is not at a word boundary. Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a , like this: This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the , metacharacters. and have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , , , or . For example, will match zero or more repetitions of . Groups indicated with , also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to , , , and . Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. The method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. For example, the following RE detects doubled words in a string. 'Paris in the the spring' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first. Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with without making Perl’s regular expressions confusingly different from standard REs. If they chose as a new metacharacter, for example, old expressions would be assuming that was a regular character and wouldn’t have escaped it by writing or . The solution chosen by the Perl developers was to use as the extension syntax. immediately after a parenthesis was a syntax error because the would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the indicate what extension is being used, so is one thing (a positive lookahead assertion) and is something else (a non-capturing group containing the subexpression ). Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a , you know that it’s an extension that’s specific to Python. Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs. Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: , where you can replace the with any other regular expression. Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as , and nest it within other groups (capturing or non-capturing). is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other. A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name. The syntax for a named group is one of the Python-specific extensions: . name is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The match object methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways: Additionally, you can retrieve named groups as a dictionary with : Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the module: It’s obviously much easier to retrieve , instead of having to remember to retrieve group 9. The syntax for backreferences in an expression such as refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: indicates that the contents of the group called name should again be matched at the current point. The regular expression for finding doubled words, can also be written as : 'Paris in the the spring' Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: Positive lookahead assertion. This succeeds if the contained regular expression, represented here by , successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string. To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a . For example, in , is the base name, and is the filename’s extension. The pattern to match this is quite simple: Notice that the needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing ; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches and and and . Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not ? Some incorrect attempts: The first attempt above tries to exclude by requiring that the first character of the extension is not a . This is wrong, because the pattern also doesn’t match . The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t ; the second character isn’t ; or the third character isn’t . This accepts and rejects , but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as . We’ll complicate the pattern again in an effort to fix it. In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as . The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both and as extensions, the pattern would get even more complicated and confusing. A negative lookahead cuts through all this confusion: The negative lookahead means: if the expression doesn’t match at this point, try the rest of the pattern; if does match, the whole pattern will fail. The trailing is required to ensure that something like , where the extension only starts with , will be allowed. The makes sure that the pattern works when there are multiple dots in the filename. Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either or :\n\nUp to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods: Split the string into a list, splitting it wherever the RE matches Find all substrings where the RE matches, and replace them with a different string Does the same thing as , but returns the new string and the number of replacements The method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the method of strings but provides much more generality in the delimiters that you can split by; string only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level function, too. Split string by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are performed. You can limit the number of splits made, by passing a value for maxsplit. When maxsplit is nonzero, at most maxsplit splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters. 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', ''] 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test, short and sweet, of split().'] Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls: The module-level function adds the RE to be used as the first argument, but is otherwise the same. Another common task is to find all the matches for a pattern, and replace them with a different string. The method takes a replacement value, which can be either a string or a function, and the string to be processed. Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in string by the replacement replacement. If the pattern isn’t found, string is returned unchanged. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. The default value of 0 means to replace all occurrences. Here’s a simple example of using the method. It replaces colour names with the word : The method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed: Empty matches are replaced only when they’re not adjacent to a previous empty match. If replacement is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. This example matches the word followed by a string enclosed in , , and changes to : There’s also a syntax for referring to named groups as defined by the syntax. will use the substring matched by the group named , and uses the corresponding group number. is therefore equivalent to , but isn’t ambiguous in a replacement string such as . ( would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character .) The following substitutions are all equivalent, but use all three variations of the replacement string. replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it. In the following example, the replacement function translates decimals into hexadecimal: When using the module-level function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. returns .\n\nRegular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls. Sometimes using the module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any features such as the flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine. One example might be replacing a single fixed string with another one; for example, you might replace with . seems like the function to use for this, but consider the method. Note that will also replace inside words, turning into , but the naive RE would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be , in order to require that have a word boundary on either side. This takes the job beyond ’s abilities.) Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like , but is capable of doing both tasks and will be faster than any regular expression operation can be. In short, before turning to the module, consider whether your problem can be solved with a faster and simpler string method. The function only checks if the RE matches at the beginning of the string while will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, will only report a successful match which will start at 0; if the match wouldn’t start at zero, will not report it. On the other hand, will scan forward through the string, reporting the first match it finds. Sometimes you’ll be tempted to keep using , and just add to the front of your RE. Resist this temptation and use instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with must match starting with a . The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a is found. Adding defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use instead. When repeating a regular expression, as in , the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of . The RE matches the in , and the consumes the rest of the string. There’s still more left in the RE, though, and the can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the . The final match extends from the in to the in , which isn’t what you want. In this case, the solution is to use the non-greedy quantifiers , , , or , which match as little text as possible. In the above example, the is tried immediately after the first matches, and when it fails, the engine advances a character at a time, retrying the at every step. This produces just the right result: By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly. The flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as is equivalent to the less readable , but will still match the characters , , or a space. In addition, you can also put comments inside a RE; comments extend from a character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly: (?P<value>.*?) # The header's value -- *? used to This is far more readable than:"
    },
    {
        "link": "https://medium.com/pythons-gurus/mastering-regular-expressions-in-python-fa1020f7ea78",
        "document": "Python’s built-in module provides support for regular expressions. This module offers a set of functions and methods that allow you to work with regex patterns efficiently. Let's explore the key components of the module:\n\nImporting the module: \n\nTo use regular expressions in Python, you first need to import the module:\n• : Scans through the string looking for the first location where the pattern produces a match.\n• : Determines if the pattern matches at the beginning of the string.\n• : Returns all non-overlapping matches of the pattern in the string as a list.\n• : Returns an iterator yielding match objects for all non-overlapping matches.\n• : Replaces all occurrences of the pattern in the string with repl.\n• : Splits the string by the occurrences of the pattern.\n• : Compiles a regex pattern into a regex object for efficiency when using the same pattern multiple times.\n\nLet’s look at a simple example to demonstrate the usage of :\n\nIn this example:\n• We define a text string and a pattern to search for.\n• We use to find the first occurrence of the pattern in the text.\n• If a match is found, we print the matched text and its position.\n\nThis is just a basic example. As we progress through the article, we’ll explore more complex patterns and usage scenarios.\n\nBasic pattern matching is the foundation of regular expressions. In this section, we’ll explore how to create and use simple patterns to match text.\n\nThe simplest form of a regex pattern is a literal match. It searches for an exact sequence of characters:\n• The before the string denotes a raw string, which treats backslashes as literal characters (useful for regular expressions).\n\nCharacter classes allow you to match any one of a set of characters:\n• The square brackets in the regular expression indicate that we’re looking for any one of the specified lowercase vowels: ‘a’, ‘e’, ‘i’, ‘o’, or ‘u’.\n• When you use square brackets, the regular expression engine matches any character that appears inside those brackets.\n• So, if you put other characters, numbers, or special characters inside the brackets, they won’t match. Only the specified vowels will be considered.\n• The order of the characters inside the brackets doesn’t matter; the engine looks for any occurrence of those characters.\n\nYou can specify a range of characters using a hyphen within a character class:\n• The pattern specifies a character class that matches any single lowercase letter between ‘a’ and ‘m’ (inclusive).\n\nYou can negate a character class to match any character not in the set:\n• This pattern matches any character except ‘a’, ‘e’, ‘i’, ‘o’,or 'u’\n• Note that there is another use of the caret symbol.\n\n^ matches the start of a string, and $ matches the end:\n\nThe dot (.) matches any character except a newline:\n• The dot ( ) serves as a powerful wildcard in regular expressions. It represents any single character (except for newline characters by default).\n• will match any string that has an ‘a’, followed by any character, and then a ‘b’.\n• If you want to match a literal dot character, you need to escape it with a backslash: .\n• To make the dot match newline characters as well, you can use the flag or within the regex.\n• Keep in mind that the dot does not match line breaks unless explicitly specified.\n\n\\b matches a word boundary (the position between a word character and a non-word character):\n• A word boundary ( ) is a zero-width assertion that defines a position between a word character ( ) and a non-word character ( ).\n• It matches at the beginning or end of a word (where a word character transitions to a non-word character or vice versa).\n\nThese basic patterns form the building blocks of more complex regular expressions. As you become more comfortable with these concepts, you’ll be able to create more sophisticated patterns to match a wide variety of text structures.\n\nSpecial characters and metacharacters in regular expressions allow you to create more complex and flexible patterns. These characters have special meanings within regex and can significantly enhance your pattern matching capabilities.\n\nThe pipe symbol (|) acts like an OR operator, matching either the expression before or after it:\n\nQuantifiers specify how many instances of a character, group, or character class must be present for a match:\n\nThese allow you to match a group only if it’s followed by or preceded by another group, without including the other group in the match:\n\nThese special characters and metacharacters greatly expand the power and flexibility of regular expressions, allowing you to create sophisticated patterns for complex text matching and manipulation tasks.\n\nGrouping and capturing are powerful features in regular expressions that allow you to extract specific parts of a match and apply operations to parts of a pattern.\n\nParentheses () are used to group parts of a regex pattern together. This is useful for applying quantifiers to a group or creating logical sections in your pattern:\n• This pattern aims to match the sequence of characters “ha” exactly three times consecutively.\n• specifies that the preceding capturing group should occur exactly three times.\n• The function searches for all occurrences of the specified pattern in the given .\n• In this case, it looks for three consecutive occurrences of “ha.”\n• The output of is a list containing the matched substrings.\n• For the given , the output is , indicating that the pattern “ha” appears three times consecutively.\n\nWhen you use parentheses for grouping, you also create a capturing group. The content matched by each group can be retrieved separately:\n• This pattern aims to match specific components in a string:\n• captures one or more word characters (letters, digits, or underscores).\n• matches any whitespace character (such as space, tab, or newline).\n• The function searches for the first occurrence of the specified pattern in the given .\n• If a match is found, it returns a match object.\n• The full name is extracted from the first two word characters: .\n• The email address is extracted from the third capturing group: .\n\nYou can assign names to your capturing groups using the syntax . This makes it easier to retrieve captured values by name instead of position:\n• This pattern aims to match specific components in a string:\n• captures one or more word characters (letters, digits, or underscores) as the first name.\n• matches any whitespace character (such as space, tab, or newline).\n• captures one or more word characters as the last name.\n• The function searches for the first occurrence of the specified pattern in the given .\n• If a match is found, it returns a match object.\n• The first name is extracted from the first capturing group: .\n• The last name is extracted from the second capturing group: .\n• The email address is extracted from the third capturing group: .\n\nSometimes you might want to group parts of a pattern without creating a capturing group. You can do this with the syntax :\n• This pattern uses a non-capturing group to match either “red” or “blue.”\n• The function searches for all occurrences of the specified pattern in the given .\n• It looks for either “red” or “blue” in the text.\n• The output of is a list containing the matched substrings.\n• For the given , the output is , indicating that both colors were found."
    },
    {
        "link": "http://automatetheboringstuff.com/chapter7",
        "document": "You may be familiar with searching for text by pressing CTRL-F and typing in the words you’re looking for. Regular expressions go one step further: They allow you to specify a pattern of text to search for. You may not know a business’s exact phone number, but if you live in the United States or Canada, you know it will be three digits, followed by a hyphen, and then four more digits (and optionally, a three-digit area code at the start). This is how you, as a human, know a phone number when you see it: 415-555-1234 is a phone number, but 4,155,551,234 is not.\n\nRegular expressions are helpful, but not many non-programmers know about them even though most modern text editors and word processors, such as Microsoft Word or OpenOffice, have find and find-and-replace features that can search based on regular expressions. Regular expressions are huge time-savers, not just for software users but also for programmers. In fact, tech writer Cory Doctorow argues that even before teaching programming, we should be teaching regular expressions:\n\nIn this chapter, you’ll start by writing a program to find text patterns without using regular expressions and then see how to use regular expressions to make the code much less bloated. I’ll show you basic matching with regular expressions and then move on to some more powerful features, such as string substitution and creating your own character classes. Finally, at the end of the chapter, you’ll write a program that can automatically extract phone numbers and email addresses from a block of text.\n\nSay you want to find a phone number in a string. You know the pattern: three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here’s an example: 415-555-4242. Let’s use a function named to check whether a string matches this pattern, returning either or . Open a new file editor window and enter the following code; then save the file as isPhoneNumber.py: def isPhoneNumber(text): ❶ if len(text) != 12: return False for i in range(0, 3): ❷ if not text[i].isdecimal(): return False ❸ if text[3] != '-': return False for i in range(4, 7): ❹ if not text[i].isdecimal(): return False ❺ if text[7] != '-': return False for i in range(8, 12): ❻ if not text[i].isdecimal(): return False ❼ return True print('415-555-4242 is a phone number:') print(isPhoneNumber('415-555-4242')) print('Moshi moshi is a phone number:') print(isPhoneNumber('Moshi moshi')) When this program is run, the output looks like this: The function has code that does several checks to see whether the string in is a valid phone number. If any of these checks fail, the function returns . First the code checks that the string is exactly 12 characters ❶. Then it checks that the area code (that is, the first three characters in ) consists of only numeric characters ❷. The rest of the function checks that the string follows the pattern of a phone number: The number must have the first hyphen after the area code ❸, three more numeric characters ❹, then another hyphen ❺, and finally four more numbers ❻. If the program execution manages to get past all the checks, it returns ❼. Calling with the argument will return . Calling with will return ; the first test fails because is not 12 characters long. You would have to add even more code to find this pattern of text in a larger string. Replace the last four function calls in isPhoneNumber.py with the following: message = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.' for i in range(len(message)): ❶ chunk = message[i:i+12] ❷ if isPhoneNumber(chunk): print('Phone number found: ' + chunk) print('Done') When this program is run, the output will look like this: On each iteration of the loop, a new chunk of 12 characters from is assigned to the variable ❶. For example, on the first iteration, is , and is assigned (that is, the string ). On the next iteration, is , and is assigned (the string 'all me at 41' ). You pass to to see whether it matches the phone number pattern ❷, and if so, you print the chunk. Continue to loop through , and eventually the 12 characters in will be a phone number. The loop goes through the entire string, testing each 12-character piece and printing any it finds that satisfies . Once we’re done going through , we print . While the string in is short in this example, it could be millions of characters long and the program would still run in less than a second. A similar program that finds phone numbers using regular expressions would also run in less than a second, but regular expressions make it quicker to write these programs.\n\nThe previous phone number–finding program works, but it uses a lot of code to do something limited: The function is 17 lines but can find only one pattern of phone numbers. What about a phone number formatted like 415.555.4242 or (415) 555-4242? What if the phone number had an extension, like 415-555-4242 x99? The function would fail to validate them. You could add yet more code for these additional patterns, but there is an easier way. Regular expressions, called regexes for short, are descriptions for a pattern of text. For example, a in a regex stands for a digit character—that is, any single numeral 0 to 9. The regex is used by Python to match the same text the previous function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the regex. But regular expressions can be much more sophisticated. For example, adding a in curly brackets ( ) after a pattern is like saying, “Match this pattern three times.” So the slightly shorter regex also matches the correct phone number format. All the regex functions in Python are in the module. Enter the following into the interactive shell to import this module: Most of the examples that follow in this chapter will require the module, so remember to import it at the beginning of any script you write or any time you restart IDLE. Otherwise, you’ll get a NameError: name 're' is not defined error message. Passing a string value representing your regular expression to returns a pattern object (or simply, a object). To create a object that matches the phone number pattern, enter the following into the interactive shell. (Remember that means “a digit character” and is the regular expression for the correct phone number pattern.) Now the variable contains a object. Remember that escape characters in Python use the backslash (\\). The string value represents a single newline character, not a backslash followed by a lowercase n. You need to enter the escape character to print a single backslash. So is the string that represents a backslash followed by a lowercase n. However, by putting an before the first quote of the string value, you can mark the string as a raw string, which does not escape characters. Since regular expressions frequently use backslashes in them, it is convenient to pass raw strings to the function instead of typing extra backslashes. Typing is much easier than typing . A object’s method searches the string it is passed for any matches to the regex. The method will return if the regex pattern is not found in the string. If the pattern is found, the method returns a object. objects have a method that will return the actual matched text from the searched string. (I’ll explain groups shortly.) For example, enter the following into the interactive shell: The variable name is just a generic name to use for objects. This example might seem complicated at first, but it is much shorter than the earlier isPhoneNumber.py program and does the same thing. Here, we pass our desired pattern to and store the resulting object in . Then we call on and pass the string we want to search for a match. The result of the search gets stored in the variable . In this example, we know that our pattern will be found in the string, so we know that a object will be returned. Knowing that contains a object and not the null value , we can call on to return the match. Writing inside our print statement displays the whole match, . While there are several steps to using regular expressions in Python, each step is fairly simple.\n• Create a object with the function. (Remember to use a raw string.)\n• Pass the string you want to search into the object’s method. This returns a object.\n• Call the object’s method to return a string of the actual matched text. While I encourage you to enter the example code into the interactive shell, you should also make use of web-based regular expression testers, which can show you exactly how a regex matches a piece of text that you enter. I recommend the tester at http://regexpal.com/.\n\nNow that you know the basic steps for creating and finding regular expression objects with Python, you’re ready to try some of their more powerful pattern-matching capabilities. Say you want to separate the area code from the rest of the phone number. Adding parentheses will create groups in the regex: . Then you can use the match object method to grab the matching text from just one group. The first set of parentheses in a regex string will be group . The second set will be group . By passing the integer or to the match object method, you can grab different parts of the matched text. Passing or nothing to the method will return the entire matched text. Enter the following into the interactive shell: If you would like to retrieve all the groups at once, use the method—note the plural form for the name. Since returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable, as in the previous line. Parentheses have a special meaning in regular expressions, but what do you do if you need to match a parenthesis in your text? For instance, maybe the phone numbers you are trying to match have the area code set in parentheses. In this case, you need to escape the and characters with a backslash. Enter the following into the interactive shell: The and escape characters in the raw string passed to will match actual parenthesis characters. The character is called a pipe. You can use it anywhere you want to match one of many expressions. For example, the regular expression will match either or . When both Batman and Tina Fey occur in the searched string, the first occurrence of matching text will be returned as the object. Enter the following into the interactive shell: You can find all matching occurrences with the method that’s discussed in The findall() Method. You can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings , , , and . Since all these strings start with , it would be nice if you could specify that prefix only once. This can be done with parentheses. Enter the following into the interactive shell: The method call returns the full matched text , while returns just the part of the matched text inside the first parentheses group, . By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match. If you need to match an actual pipe character, escape it with a backslash, like . Sometimes there is a pattern that you want to match only optionally. That is, the regex should find a match whether or not that bit of text is there. The character flags the group that precedes it as an optional part of the pattern. For example, enter the following into the interactive shell: The part of the regular expression means that the pattern is an optional group. The regex will match text that has zero instances or one instance of wo in it. This is why the regex matches both and . Using the earlier phone number example, you can make the regex look for phone numbers that do or do not have an area code. Enter the following into the interactive shell: You can think of the as saying, “Match zero or one of the group preceding this question mark.” If you need to match an actual question mark character, escape it with . Matching Zero or More with the Star The (called the star or asterisk) means “match zero or more”—the group that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. Let’s look at the Batman example again. For , the part of the regex matches zero instances of in the string; for , the matches one instance of ; and for , matches four instances of . If you need to match an actual star character, prefix the star in the regular expression with a backslash, . Matching One or More with the Plus While means “match zero or more,” the (or plus) means “match one or more.” Unlike the star, which does not require its group to appear in the matched string, the group preceding a plus must appear at least once. It is not optional. Enter the following into the interactive shell, and compare it with the star regexes in the previous section: The regex will not match the string because at least one is required by the plus sign. If you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: . If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex will match the string , but it will not match , since the latter has only two repeats of the group. Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex will match , , and . You can also leave out the first or second number in the curly brackets to leave the minimum or maximum unbounded. For example, will match three or more instances of the group, while will match zero to five instances. Curly brackets can help make your regular expressions shorter. These two regular expressions match identical patterns: And these two regular expressions also match identical patterns: Enter the following into the interactive shell: Here, matches but not . Since it doesn’t match , returns .\n\nThe (or dot) character in a regular expression is called a wildcard and will match any character except for a newline. For example, enter the following into the interactive shell: >>> >>> atRegex.findall('The cat in the hat sat on the flat mat.') ['cat', 'hat', 'sat', 'lat', 'mat'] Remember that the dot character will match just one character, which is why the match for the text in the previous example matched only . To match an actual dot, escape the dot with a backslash: . Sometimes you will want to match everything and anything. For example, say you want to match the string , followed by any and all text, followed by , and then followed by anything again. You can use the dot-star ( ) to stand in for that “anything.” Remember that the dot character means “any single character except the newline,” and the star character means “zero or more of the preceding character.” Enter the following into the interactive shell: >>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') >>> mo = nameRegex.search('First Name: Al Last Name: Sweigart') >>> 'Al' >>> 'Sweigart' The dot-star uses greedy mode: It will always try to match as much text as possible. To match any and all text in a nongreedy fashion, use the dot, star, and question mark ( ). Like with curly brackets, the question mark tells Python to match in a nongreedy way. Enter the following into the interactive shell to see the difference between the greedy and nongreedy versions: >>> >>> >>> '<To serve man>' >>> >>> >>> '<To serve man> for dinner.>' Both regexes roughly translate to “Match an opening angle bracket, followed by anything, followed by a closing angle bracket.” But the string has two possible matches for the closing angle bracket. In the nongreedy version of the regex, Python matches the shortest possible string: . In the greedy version, Python matches the longest possible string: . The dot-star will match everything except a newline. By passing as the second argument to , you can make the dot character match all characters, including the newline character. Enter the following into the interactive shell: >>> >>> 'Serve the public trust.' >>> >>> 'Serve the public trust.\n\nProtect the innocent.\n\nUphold the law.' The regex , which did not have passed to the call that created it, will match everything only up to the first newline character, whereas , which did have passed to , matches everything. This is why the call matches the full string, including its newline characters.\n\nSay you have the boring task of finding every phone number and email address in a long web page or document. If you manually scroll through the page, you might end up searching for a long time. But if you had a program that could search the text in your clipboard for phone numbers and email addresses, you could simply press CTRL-A to select all the text, press CTRL-C to copy it to the clipboard, and then run your program. It could replace the text on the clipboard with just the phone numbers and email addresses it finds. Whenever you’re tackling a new project, it can be tempting to dive right into writing code. But more often than not, it’s best to take a step back and consider the bigger picture. I recommend first drawing up a high-level plan for what your program needs to do. Don’t think about the actual code yet—you can worry about that later. Right now, stick to broad strokes. For example, your phone and email address extractor will need to do the following:\n• Get the text off the clipboard.\n• Find all phone numbers and email addresses in the text.\n• Paste them onto the clipboard. Now you can start thinking about how this might work in code. The code will need to do the following:\n• Use the module to copy and paste strings.\n• Create two regexes, one for matching phone numbers and the other for matching email addresses.\n• Find all matches, not just the first match, of both regexes.\n• Neatly format the matched strings into a single string to paste.\n• Display some kind of message if no matches were found in the text. This list is like a road map for the project. As you write the code, you can focus on each of these steps separately. Each step is fairly manageable and expressed in terms of things you already know how to do in Python. First, you have to create a regular expression to search for phone numbers. Create a new file, enter the following, and save it as phoneAndEmail.py: #! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))? # area code (\\s|-|\\.)? # separator (\\d{3}) # first 3 digits (\\s|-|\\.) # separator (\\d{4}) # last 4 digits (\\s*(ext|x|ext.)\\s*(\\d{2,5}))? # extension )''', re.VERBOSE) # TODO: Create email regex. # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard. The comments are just a skeleton for the program. They’ll be replaced as you write the actual code. The phone number begins with an optional area code, so the area code group is followed with a question mark. Since the area code can be just three digits (that is, ) or three digits within parentheses (that is, ), you should have a pipe joining those parts. You can add the regex comment to this part of the multiline string to help you remember what is supposed to match. The phone number separator character can be a space ( ), hyphen ( ), or period ( ), so these parts should also be joined by pipes. The next few parts of the regular expression are straightforward: three digits, followed by another separator, followed by four digits. The last part is an optional extension made up of any number of spaces followed by , , or , followed by two to five digits. You will also need a regular expression that can match email addresses. Make your program look like the following: #! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( ❶ ❷ ❸ # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard. The username part of the email address ❶ is one or more characters that can be any of the following: lowercase and uppercase letters, numbers, a dot, an underscore, a percent sign, a plus sign, or a hyphen. You can put all of these into a character class: . The domain and username are separated by an @ symbol ❷. The domain name ❸ has a slightly less permissive character class with only letters, numbers, periods, and hyphens: . And last will be the “dot-com” part (technically known as the top-level domain), which can really be dot-anything. This is between two and four characters. The format for email addresses has a lot of weird rules. This regular expression won’t match every possible valid email address, but it’ll match almost any typical email address you’ll encounter. Step 3: Find All Matches in the Clipboard Text Now that you have specified the regular expressions for phone numbers and email addresses, you can let Python’s module do the hard work of finding all the matches on the clipboard. The function will get a string value of the text on the clipboard, and the regex method will return a list of tuples. Make your program look like the following: #! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( ❶ ❷ ❸ # TODO: Copy results to the clipboard. There is one tuple for each match, and each tuple contains strings for each group in the regular expression. Remember that group matches the entire regular expression, so the group at index of the tuple is the one you are interested in. As you can see at ❶, you’ll store the matches in a list variable named . It starts off as an empty list, and a couple loops. For the email addresses, you append group of each match ❸. For the matched phone numbers, you don’t want to just append group . While the program detects phone numbers in several formats, you want the phone number appended to be in a single, standard format. The variable contains a string built from groups , , , and of the matched text ❷. (These groups are the area code, first three digits, last four digits, and extension.) Step 4: Join the Matches into a String for the Clipboard Now that you have the email addresses and phone numbers as a list of strings in , you want to put them on the clipboard. The function takes only a single string value, not a list of strings, so you call the method on . To make it easier to see that the program is working, let’s print any matches you find to the terminal. And if no phone numbers or email addresses were found, the program should tell the user this. Make your program look like the following: #! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. for groups in emailRegex.findall(text): matches.append(groups[0]) For an example, open your web browser to the No Starch Press contact page at http://www.nostarch.com/contactus.htm, press CTRL-A to select all the text on the page, and press CTRL-C to copy it to the clipboard. When you run this program, the output will look something like this: Identifying patterns of text (and possibly substituting them with the method) has many different potential applications.\n• Find website URLs that begin with http:// or https://.\n• Clean up dates in different date formats (such as 3/14/2015, 03-14-2015, and 2015/3/14) by replacing them with dates in a single, standard format.\n• Remove sensitive information such as Social Security or credit card numbers.\n• Find common typos such as multiple spaces between words, accidentally accidentally repeated words, or multiple exclamation marks at the end of sentences. Those are annoying!!"
    },
    {
        "link": "https://developers.google.com/edu/python/regular-expressions",
        "document": "Regular expressions are a powerful language for matching text patterns. This page gives a basic introduction to regular expressions themselves sufficient for our Python exercises and shows how regular expressions work in Python. The Python \"re\" module provides regular expression support.\n\nIn Python a regular expression search is typically written as:\n\nThe re.search() method takes a regular expression pattern and a string and searches for that pattern within the string. If the search is successful, search() returns a match object or None otherwise. Therefore, the search is usually immediately followed by an if-statement to test if the search succeeded, as shown in the following example which searches for the pattern 'word:' followed by a 3 letter word (details below):\n\nThe code stores the search result in a variable named \"match\". Then the if-statement tests the match -- if true the search succeeded and match.group() is the matching text (e.g. 'word:cat'). Otherwise if the match is false (None to be more specific), then the search did not succeed, and there is no matching text.\n\nThe 'r' at the start of the pattern string designates a python \"raw\" string which passes through backslashes without change which is very handy for regular expressions (Java needs this feature badly!). I recommend that you always write pattern strings with the 'r' just as a habit.\n\nThe power of regular expressions is that they can specify patterns, not just fixed characters. Here are the most basic patterns which match single chars:\n• a, X, 9, < -- ordinary characters just match themselves exactly. The meta-characters which do not match themselves because they have special meanings are: . ^ $ * + ? { [ ] \\ | ( ) (details below)\n• \\w -- (lowercase w) matches a \"word\" character: a letter or digit or underbar [a-zA-Z0-9_]. Note that although \"word\" is the mnemonic for this, it only matches a single word char, not a whole word. \\W (upper case W) matches any non-word character.\n• \\d -- decimal digit [0-9] (some older regex utilities do not support \\d, but they all support \\w and \\s)\n• ^ = start, $ = end -- match the start or end of the string\n• \\ -- inhibit the \"specialness\" of a character. So, for example, use \\. to match a period or \\\\ to match a slash. If you are unsure if a character has special meaning, such as '@', you can try putting a slash in front of it, \\@. If its not a valid escape sequence, like \\c, your python program will halt with an error.\n\nJoke: what do you call a pig with three eyes? piiig!\n\nThe basic rules of regular expression search for a pattern within a string are:\n• The search proceeds through the string from start to end, stopping at the first match found\n• All of the pattern must be matched, but not all of the string\n• If is successful, match is not None and in particular match.group() is the matching text\n\nThings get more interesting when you use + and * to specify repetition in the pattern\n• + -- 1 or more occurrences of the pattern to its left, e.g. 'i+' = one or more i's\n• * -- 0 or more occurrences of the pattern to its left\n• ? -- match 0 or 1 occurrences of the pattern to its left\n\nFirst the search finds the leftmost match for the pattern, and second it tries to use up as much of the string as possible -- i.e. + and * go as far as possible (the + and * are said to be \"greedy\").\n\nSuppose you want to find the email address inside the string 'xyz alice-b@google.com purple monkey'. We'll use this as a running example to demonstrate more regular expression features. Here's an attempt using the pattern r'\\w+@\\w+':\n\nThe search does not get the whole email address in this case because the \\w does not match the '-' or '.' in the address. We'll fix this using the regular expression features below.\n\nSquare brackets can be used to indicate a set of chars, so [abc] matches 'a' or 'b' or 'c'. The codes \\w, \\s etc. work inside square brackets too with the one exception that dot (.) just means a literal dot. For the emails problem, the square brackets are an easy way to add '.' and '-' to the set of chars which can appear around the @ with the pattern r'[\\w.-]+@[\\w.-]+' to get the whole email address:\n\n(More square-bracket features) You can also use a dash to indicate a range, so [a-z] matches all lowercase letters. To use a dash without indicating a range, put the dash last, e.g. [abc-]. An up-hat (^) at the start of a square-bracket set inverts it, so [^ab] means any char except 'a' or 'b'.\n\nThe \"group\" feature of a regular expression allows you to pick out parts of the matching text. Suppose for the emails problem that we want to extract the username and host separately. To do this, add parentheses ( ) around the username and host in the pattern, like this: r'([\\w.-]+)@([\\w.-]+)'. In this case, the parentheses do not change what the pattern will match, instead they establish logical \"groups\" inside of the match text. On a successful search, match.group(1) is the match text corresponding to the 1st left parentheses, and match.group(2) is the text corresponding to the 2nd left parentheses. The plain match.group() is still the whole match text as usual.\n\nA common workflow with regular expressions is that you write a pattern for the thing you are looking for, adding parentheses groups to extract the parts you want.\n\nfindall() is probably the single most powerful function in the re module. Above we used re.search() to find the first match for a pattern. findall() finds *all* the matches and returns them as a list of strings, with each string representing one match.\n\nFor files, you may be in the habit of writing a loop to iterate over the lines of the file, and you could then call findall() on each line. Instead, let findall() do the iteration for you -- much better! Just feed the whole file text into findall() and let it return a list of all the matches in a single step (recall that f.read() returns the whole text of a file in a single string):\n\nThe parentheses ( ) group mechanism can be combined with findall(). If the pattern includes 2 or more parentheses groups, then instead of returning a list of strings, findall() returns a list of *tuples*. Each tuple represents one match of the pattern, and inside the tuple is the group(1), group(2) .. data. So if 2 parentheses groups are added to the email pattern, then findall() returns a list of tuples, each length 2 containing the username and host, e.g. ('alice', 'google.com').\n\nOnce you have the list of tuples, you can loop over it to do some computation for each tuple. If the pattern includes no parentheses, then findall() returns a list of found strings as in earlier examples. If the pattern includes a single set of parentheses, then findall() returns a list of strings corresponding to that single group. (Obscure optional feature: Sometimes you have paren ( ) groupings in the pattern, but which you do not want to extract. In that case, write the parens with a ?: at the start, e.g. (?: ) and that left paren will not count as a group result.)\n\nRegular expression patterns pack a lot of meaning into just a few characters , but they are so dense, you can spend a lot of time debugging your patterns. Set up your runtime so you can run a pattern and print what it matches easily, for example by running it on a small test text and printing the result of findall(). If the pattern matches nothing, try weakening the pattern, removing parts of it so you get too many matches. When it's matching nothing, you can't make any progress since there's nothing concrete to look at. Once it's matching too much, then you can work on tightening it up incrementally to hit just what you want.\n\nThe re functions take options to modify the behavior of the pattern match. The option flag is added as an extra argument to the search() or findall() etc., e.g. re.search(pat, str, re.IGNORECASE).\n• IGNORECASE -- ignore upper/lowercase differences for matching, so 'a' matches both 'a' and 'A'.\n• DOTALL -- allow dot (.) to match newline -- normally it matches anything but newline. This can trip you up -- you think .* matches everything, but by default it does not go past the end of a line. Note that \\s (whitespace) includes newlines, so if you want to match a run of whitespace that may include a newline, you can just use \\s*\n• MULTILINE -- Within a string made of many lines, allow ^ and $ to match the start and end of each line. Normally ^/$ would just match the start and end of the whole string.\n\nThis is optional section which shows a more advanced regular expression technique not needed for the exercises.\n\nSuppose you have text with tags in it: <b>foo</b> and <i>so on</i>\n\nSuppose you are trying to match each tag with the pattern '(<.*>)' -- what does it match first?\n\nThe result is a little surprising, but the greedy aspect of the .* causes it to match the whole '<b>foo</b> and <i>so on</i>' as one big match. The problem is that the .* goes as far as is it can, instead of stopping at the first > (aka it is \"greedy\").\n\nThere is an extension to regular expression where you add a ? at the end, such as .*? or .+?, changing them to be non-greedy. Now they stop as soon as they can. So the pattern '(<.*?>)' will get just '<b>' as the first match, and '</b>' as the second match, and so on getting each <..> pair in turn. The style is typically that you use a .*? immediately followed by some concrete marker (> in this case) to which the .*? run is forced to extend.\n\nThe *? extension originated in Perl, and regular expressions that include Perl's extensions are known as Perl Compatible Regular Expressions -- pcre. Python includes pcre support. Many command line utils etc. have a flag where they accept pcre patterns.\n\nAn older but widely used technique to code this idea of \"all of these chars except stopping at X\" uses the square-bracket style. For the above you could write the pattern, but instead of .* to get all the chars, use [^>]* which skips over all characters which are not > (the leading ^ \"inverts\" the square bracket set, so it matches any char not in the brackets).\n\nThe re.sub(pat, replacement, str) function searches for all the instances of pattern in the given string, and replaces them. The replacement string can include '\\1', '\\2' which refer to the text from group(1), group(2), and so on from the original matching text.\n\nHere's an example which searches for all the email addresses, and changes them to keep the user (\\1) but have yo-yo-dyne.com as the host.\n\nTo practice regular expressions, see the Baby Names Exercise."
    }
]