[
    {
        "link": "https://stackoverflow.com/questions/18723596/no-exception-while-type-casting-with-a-null-in-java",
        "document": "As others have written, you can cast null to everything. Normally, you wouldn't need that, you can write:\n\nwithout putting the cast there.\n\nBut there are occasions where such casts make sense:\n\na) if you want to make sure that a specific method is called, like:\n\nthen it would make a difference if you type\n\nb) if you intend to use your IDE to generate code; for example I am typically writing unit tests like:\n\nI am doing TDD; this means that the class \"MyClassUnderTest\" probably doesn't exist yet. By writing down that code, I can then use my IDE to first generate the new class; and to then generate a constructor accepting a \"Whatever\" argument \"out of the box\" - the IDE can figure from my test that the constructor should take exactly one argument of type Whatever."
    },
    {
        "link": "https://coderanch.com/t/373254/java/Type-Casting-null-object",
        "document": "this forum made possible by our volunteer staff, including ..."
    },
    {
        "link": "https://geeksforgeeks.org/null-pointer-exception-in-java",
        "document": "A NullPointerException in Java is a RuntimeException. In Java, a special null value can be assigned to an object reference. NullPointerException is thrown when a program attempts to use an object reference that has the null value.\n\nExplanation: In the above example, the string reference “s” is null. When the program tries to call the length() method, it throws a NullPointerException because there is no actual object.\n• None Taking the length of null, as if it were an array.\n• None Accessing or modifying the slots of null objects, as if it were an array.\n• None Throwing null, as if it were a Throwable value.\n• None When you try to synchronize over a null object.\n\nNeed of Null Value\n\nThe null value serves as a placeholder and it indicates that no value is assigned to a reference variable. Common applications include:\n• Linked Data Structures : It represents the end of a list or tree branch.\n• Design Patterns : This is used in patterns like the\n\nHow to Avoid the NullPointerException?\n\nTo avoid the NullPointerException, we must ensure that all the objects are initialized properly, before we use them. When we declare a reference variable, we must verify that object is not null, before we request a method or a field from the objects.\n\nA very common case problem involves the comparison between a String variable and a literal. The literal may be a String or an element of an Enum. Instead of invoking the method from the null object, consider invoking it from the literal.\n\n\n\nWe can avoid NullPointerException by calling equals on literal rather than object.\n\nNote: Always invoke equals on the literal to avoid calling a method on a null reference.\n\nBefore executing the body of the new method, we should first check its arguments for null values and continue with execution of the method, only when the arguments are properly checked. Otherwise, it will throw an IllegalArgumentException and notify the calling method that something is wrong with the passed arguments.\n\nThe ternary operator can be used to avoid NullPointerException. First, the Boolean expression is evaluated. If the expression is true then, the value1 is returned, otherwise, the value2 is returned. We can use the ternary operator for handling null pointers.\n\nExplanation: The ternary operator helps check for null and avoid operations on null references.\n\nWhat is NullPointerException in Java?\n\nHow to handle a Null Pointer Exception in Java?"
    },
    {
        "link": "https://stackoverflow.com/questions/38596346/java-handling-nullpointerexception-in-java-when-function-has-to-return-some-va",
        "document": "Here is my code:\n\nHow do I handle the when I have to return something of type E?I am testing my code using JUtil. I am a beginner and am finding this part tough to understand, please help.\n\nEDIT : I am testing this function using JUtil function whose (partial)code is given below :\n\nhere emptylist is an Empty List object created from a personally created LinkedList Class. How do I solve for this (//test empty list, get should throw an exception) as in this case the foremost mentioned get function returns NullPointerException? Please help me.\n\nAfter running \"New Code\", these are the results and errors are on the bottom left panel :"
    },
    {
        "link": "https://seagence.com/blog/java-null-pointer-exception-how-to-avoid-and-fix",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/18723596/no-exception-while-type-casting-with-a-null-in-java",
        "document": "As others have written, you can cast null to everything. Normally, you wouldn't need that, you can write:\n\nwithout putting the cast there.\n\nBut there are occasions where such casts make sense:\n\na) if you want to make sure that a specific method is called, like:\n\nthen it would make a difference if you type\n\nb) if you intend to use your IDE to generate code; for example I am typically writing unit tests like:\n\nI am doing TDD; this means that the class \"MyClassUnderTest\" probably doesn't exist yet. By writing down that code, I can then use my IDE to first generate the new class; and to then generate a constructor accepting a \"Whatever\" argument \"out of the box\" - the IDE can figure from my test that the constructor should take exactly one argument of type Whatever."
    },
    {
        "link": "https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html",
        "document": "Every expression written in the Java programming language has a type that can be deduced from the structure of the expression and the types of the literals, variables, and methods mentioned in the expression. It is possible, however, to write an expression in a context where the type of the expression is not appropriate. In some cases, this leads to an error at compile time. In other cases, the context may be able to accept a type that is related to the type of the expression; as a convenience, rather than requiring the programmer to indicate a type conversion explicitly, the Java programming language performs an implicit conversion from the type of the expression to a type acceptable for its surrounding context.\n\nA specific conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.\n\nIn every conversion context, only certain specific conversions are permitted. For convenience of description, the specific conversions that are possible in the Java programming language are grouped into several broad categories:\n\nThere are five conversion contexts in which conversion of expressions may occur. Each context allows conversions in some of the categories named above but not others. The term \"conversion\" is also used to describe the process of choosing a specific conversion for such a context. For example, we say that an expression that is an actual argument in a method invocation is subject to \"method invocation conversion,\" meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the method invocation argument context.\n\nOne conversion context is the operand of a numeric operator such as or . The conversion process for such operands is called numeric promotion. Promotion is special in that, in the case of binary operators, the conversion chosen for one operand may depend in part on the type of the other operand expression.\n\nThis chapter first describes the eleven categories of conversions (§5.1), including the special conversions to allowed for the string concatenation operator (§15.18.1). Then the five conversion contexts are described:\n\nSpecific type conversions in the Java programming language are divided into 13 categories. A conversion from a type to that same type is permitted for any type. This may seem trivial, but it has two practical consequences. First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion. Second, it implies that it is permitted for a program to include redundant cast operators for the sake of clarity. 19 specific conversions on primitive types are called the widening primitive conversions: A widening primitive conversion does not lose information about the overall magnitude of a numeric value. A widening primitive conversion from an integral type to another integral type, or from to in a expression (§15.4), does not lose any information at all; the numeric value is preserved exactly. A widening primitive conversion from to that is not may lose information about the overall magnitude of the converted value. A widening conversion of an or a value to , or of a value to , may result in loss of precision - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode (§4.2.4). A widening conversion of a signed integer value to an integral type T simply sign-extends the two's-complement representation of the integer value to fill the wider format. A widening conversion of a to an integral type T zero-extends the representation of the value to fill the wider format. Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (§11.1.1). thus indicating that information was lost during the conversion from type to type because values of type are not precise to nine significant digits. \n\n 22 specific conversions on primitive types are called the narrowing primitive conversions: A narrowing primitive conversion may lose information about the overall magnitude of a numeric value and may also lose precision and range. A narrowing primitive conversion from to is governed by the IEEE 754 rounding rules (§4.2.4). This conversion can lose precision, but also lose range, resulting in a zero from a nonzero and a infinity from a finite . A NaN is converted to a NaN and a infinity is converted to the same-signed infinity. A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value. A narrowing conversion of a to an integral type T likewise simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values. A narrowing conversion of a floating-point number to an integral type T takes two steps:\n• In the first step, the floating-point number is converted either to a , if T is , or to an , if T is , , , or , as follows:\n• If the floating-point number is NaN (§4.2.3), the result of the first step of the conversion is an or .\n• Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value , rounding toward zero using IEEE 754 round-toward-zero mode (§4.2.3). Then there are two cases:\n• If T is , and this integer value can be represented as a , then the result of the first step is the value .\n• Otherwise, if this integer value can be represented as an , then the result of the first step is the value .\n• Otherwise, one of the following two cases must be true:\n• The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type or .\n• The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type or .\n• \n• If T is or , the result of the conversion is the result of the first step.\n• If T is , , or , the result of the conversion is the result of a narrowing conversion to type T (§5.1.3) of the result of the first step. The results for , , and are unsurprising, producing the minimum and maximum representable values of the type. The results for and lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum . The minimum is, in hexadecimal, , and the maximum int is . This explains the results, which are the low 16 bits of these values, namely, and ; it explains the char results, which also are the low 16 bits of these values, namely, and ; and it explains the byte results, which are the low 8 bits of these values, namely, and . \n\n Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception (§11.1.1). class Test { public static void main(String[] args) { // A narrowing of int to short loses high bits: System.out.println(\"(short)0x12345678==0x\" + Integer.toHexString((short)0x12345678)); // An int value too big for byte changes sign and magnitude: System.out.println(\"(byte)255==\" + (byte)255); // A float value too big to fit gives largest int value: System.out.println(\"(int)1e20f==\" + (int)1e20f); // A NaN converted to int yields zero: System.out.println(\"(int)NaN==\" + (int)Float.NaN); // A double value too large for float yields infinity: System.out.println(\"(float)-1e100==\" + (float)-1e100); // A double value too small for float underflows to zero: System.out.println(\"(float)1e-50==\" + (float)1e-50); } } \n\n The following conversion combines both widening and narrowing primitive conversions: First, the is converted to an via widening primitive conversion (§5.1.2), and then the resulting is converted to a by narrowing primitive conversion (§5.1.3). A widening reference conversion exists from any reference type S to any reference type T, provided S is a subtype (§4.10) of T. Widening reference conversions never require a special action at run time and therefore never throw an exception at run time. They consist simply in regarding a reference as having some other type in a manner that can be proved correct at compile time. Six kinds of conversions are called the narrowing reference conversions:\n• From any reference type S to any reference type T, provided that S is a proper supertype of T (§4.10). An important special case is that there is a narrowing reference conversion from the class type to any other reference type (§4.12.4).\n• From any class type C to any non-parameterized interface type K, provided that C is not and does not implement K.\n• From any interface type J to any non-parameterized class type C that is not .\n• From any interface type J to any non-parameterized interface type K, provided that J is not a subinterface of K.\n• From the interface types and to any array type T .\n• From any array type SC to any array type TC , provided that SC and TC are reference types and there is a narrowing reference conversion from SC to TC. Such conversions require a test at run time to find out whether the actual reference value is a legitimate value of the new type. If not, then a is thrown. Boxing conversion converts expressions of primitive type to corresponding expressions of reference type. Specifically, the following nine conversions are called the boxing conversions:\n• From the null type to the null type This rule is necessary because the conditional operator (§15.25) applies boxing conversion to the types of its operands, and uses the result in further calculations. At run time, boxing conversion proceeds as follows:\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type then:\n• If is not NaN, then boxing conversion converts into a reference of class and type , such that evaluates to\n• Otherwise, boxing conversion converts into a reference of class and type such that evaluates to\n• If is a value of type , then:\n• If is not NaN, boxing conversion converts into a reference of class and type , such that evaluates to\n• Otherwise, boxing conversion converts into a reference of class and type such that evaluates to\n• If is a value of any other type, boxing conversion is equivalent to an identity conversion (§5.1.1). If the value being boxed is , , a , or a in the range to , or an or number between and (inclusive), then let and be the results of any two boxing conversions of . It is always the case that . Ideally, boxing a given primitive value , would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rules above are a pragmatic compromise. The final clause above requires that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, this formulation disallows any assumptions about the identity of the boxed values on the programmer's part. This would allow (but not require) sharing of some or all of these references. This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all and values, as well as and values in the range of -32K to +32K. A boxing conversion may result in an if a new instance of one of the wrapper classes ( , , , , , , , or ) needs to be allocated and insufficient storage is available. Unboxing conversion converts expressions of reference type to corresponding expressions of primitive type. Specifically, the following eight conversions are called the unboxing conversions: At run time, unboxing conversion proceeds as follows:\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into A type is said to be convertible to a numeric type if it is a numeric type (§4.2), or it is a reference type that may be converted to a numeric type by unboxing conversion. A type is said to be convertible to an integral type if it is an integral type, or it is a reference type that may be converted to an integral type by unboxing conversion. Let G name a generic type declaration with n type parameters. There is an unchecked conversion from the raw class or interface type (§4.8) G to any parameterized type of the form G T ,...,T . There is an unchecked conversion from the raw array type G to any array type type of the form G T ,...,T . Use of an unchecked conversion causes a compile-time unchecked warning unless G ... is a parameterized type in which all type arguments are unbounded wildcards (§4.5.1), or the unchecked warning is suppressed by the annotation (§9.6.3.5). Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification). In such circumstances (most notably, clients of the Collections Framework in ), legacy code uses raw types (e.g. instead of ). Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters. Such calls cannot be shown to be statically safe under the type system using generics. Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries. This in turn, would discourage library vendors from taking advantage of genericity. To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers. While the conversion is unsound, it is tolerated as a concession to practicality. An unchecked warning is issued in such cases. Let G name a generic type declaration (§8.1.2, §9.1.2) with n type parameters A ,...,A with corresponding bounds U ,...,U . There exists a capture conversion from a parameterized type G T ,...,T (§4.5) to a parameterized type G S ,...,S , where, for 1 ≤ i ≤ n :\n• If T is a wildcard type argument (§4.5.1) of the form , then S is a fresh type variable whose upper bound is U and whose lower bound is the null type (§4.1).\n• If T is a wildcard type argument of the form B , then S is a fresh type variable whose upper bound is glb(B , U ) and whose lower bound is the null type. It is a compile-time error if, for any two classes (not interfaces) V and V , V is not a subclass of V or vice versa.\n• If T is a wildcard type argument of the form B , then S is a fresh type variable whose upper bound is U and whose lower bound is B . Capture conversion on any type other than a parameterized type (§4.5) acts as an identity conversion (§5.1.1). Capture conversion never requires a special action at run time and therefore never throws an exception at run time. Capture conversion is designed to make wildcards more useful. To understand the motivation, let's begin by looking at the method : The method reverses the list provided as a parameter. It works for any type of list, and so the use of the wildcard type as the type of the formal parameter is entirely appropriate. Now consider how one would implement : The implementation needs to copy the list, extract elements from the copy, and insert them into the original. To do this in a type-safe manner, we need to give a name, , to the element type of the incoming list. We do this in the private service method . This requires us to pass the incoming argument list, of type , as an argument to . In general, is a list of unknown type. It is not a subtype of , for any type T. Allowing such a subtype relation would be unsound. Given the method: the following code would undermine the type system: List<String> ls = new ArrayList<String>(); List<?> l = ls; Collections.fill(l, new Object()); // not legal - but assume it was! String s = ls.get(0); // ClassCastException - ls contains // Objects, not Strings. So, without some special dispensation, we can see that the call from to would be disallowed. If this were the case, the author of would be forced to write its signature as: This is undesirable, as it exposes implementation information to the caller. Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded. The call from to is in fact harmless, but it cannot be justified on the basis of a general subtyping relation between and . The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one). If we can capture this unknown type in a type variable , we can infer to be . That is the essence of capture conversion. The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc. Mathematically sophisticated readers will want to relate capture conversion to established type theory. Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as Types and Programming Languages by Benjamin Pierce, and then revisit this section. Here then is a brief summary of the relationship of capture conversion to established type theoretical notions. Wildcard types are a restricted form of existential types. Capture conversion corresponds loosely to an opening of a value of existential type. A capture conversion of an expression can be thought of as an of in a scope that comprises the top level expression that encloses . The classical operation on existentials requires that the captured type variable must not escape the opened expression. The that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope. The advantage of this scheme is that there is no need for a operation, as defined in the paper On Variance-Based Subtyping for Parametric Types by Atsushi Igarashi and Mirko Viroli, in the proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002). For a formal account of wildcards, see Wild FJ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005). Any type may be converted to type by string conversion. A value of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression (§15.9):\n• If T is , then use .\n• If T is , then use .\n• If T is , , or , then use .\n• If T is , then use .\n• If T is , then use .\n• If T is , then use . This reference value is then converted to type by string conversion. Now only reference values need to be considered:\n• If the reference is , it is converted to the string \" \" (four ASCII characters , , , ).\n• Otherwise, the conversion is performed as if by an invocation of the method of the referenced object with no arguments; but if the result of invoking the method is , then the string \" \" is used instead. The method is defined by the primordial class (§4.3.2). Many classes override it, notably , , , , , , and . See §5.4 for details of the string conversion context. Any conversion that is not explicitly allowed is forbidden. Value set conversion is the process of mapping a floating-point value from one value set to another without changing its type. Within an expression that is not FP-strict (§15.4), value set conversion provides choices to an implementation of the Java programming language:\n• If the value is an element of the float-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the float value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign).\n• If the value is an element of the double-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the double value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign). Within an FP-strict expression (§15.4), value set conversion does not provide any choices; every implementation must behave in the same way:\n• If the value is of type and is not an element of the float value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow or underflow.\n• If the value is of type and is not an element of the double value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow. Within an FP-strict expression, mapping values from the float-extended-exponent value set or double-extended-exponent value set is necessary only when a method is invoked whose declaration is not FP-strict and the implementation has chosen to represent the result of the method invocation as an element of an extended-exponent value set. Whether in FP-strict code or code that is not FP-strict, value set conversion always leaves unchanged any value whose type is neither nor .\n\nAssignment conversion occurs when the value of an expression is assigned (§15.26) to a variable: the type of the expression must be converted to the type of the variable. Assignment contexts allow the use of one of the following:\n• an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion. If, after the conversions listed above have been applied, the resulting type is a raw type (§4.8), unchecked conversion (§5.1.9) may then be applied. It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation. An example of such an illegal chain would be: The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion. However, this is not a valid assignment conversion, because the chain contains two parameterized types, and , that are not subtypes. In addition, if the expression is a constant expression (§15.28) of type , , , or :\n• A narrowing primitive conversion may be used if the type of the variable is , , or , and the value of the constant expression is representable in the type of the variable.\n• A narrowing primitive conversion followed by a boxing conversion may be used if the type of the variable is:\n• and the value of the constant expression is representable in the type .\n• and the value of the constant expression is representable in the type .\n• and the value of the constant expression is representable in the type . The compile-time narrowing of constants means that code such as: is allowed. Without the narrowing, the fact that the integer literal has type would mean that a cast to would be required: byte theAnswer = (byte)42; // cast is permitted but not required A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type. If the type of the expression cannot be converted to the type of the variable by a conversion permitted in an assignment context, then a compile-time error occurs. If the type of an expression can be converted to the type of a variable by assignment conversion, we say the expression (or its value) is assignable to the variable or, equivalently, that the type of the expression is assignment compatible with the type of the variable. If the type of the variable is or , then value set conversion (§5.1.13) is applied to the value v that is the result of the type conversion:\n• If v is of type and is an element of the float-extended-exponent value set, then the implementation must map v to the nearest element of the float value set. This conversion may result in overflow or underflow.\n• If v is of type and is an element of the double-extended-exponent value set, then the implementation must map v to the nearest element of the double value set. This conversion may result in overflow or underflow. The only exceptions that an assignment conversion may cause are:\n• A if, after the type conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (§4.6) of the type of the variable. This circumstance can only arise as a result of heap pollution (§4.12.2). In practice, implementations need only perform casts when accessing a field or method of an object of parametized type, when the erased type of the field, or the erased result type of the method differ from their unerased type.\n• An as a result of a boxing conversion.\n• A as a result of an unboxing conversion on a null reference.\n• An in special cases involving array elements or field access (§10.5, §15.26.1). class Test { public static void main(String[] args) { short s = 12; // narrow 12 to short float f = s; // widen short to float System.out.println(\"f=\" + f); char c = '\\u0123'; long l = c; // widen char to long System.out.println(\"l=0x\" + Long.toString(l,16)); f = 1.23f; double d = f; // widen float to double System.out.println(\"d=\" + d); } } The following program, however, produces compile-time errors: class Test { public static void main(String[] args) { short s = 123; char c = s; // error: would require cast s = c; // error: would require cast } } because not all values are values, and neither are all values values. \n\n class Point { int x, y; } class Point3D extends Point { int z; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { // Assignments to variables of class type: Point p = new Point(); p = new Point3D(); // OK because Point3D is a subclass of Point Point3D p3d = p; // Error: will require a cast because a Point // might not be a Point3D (even though it is, // dynamically, in this example.) // Assignments to variables of type Object: Object o = p; // OK: any object to Object int[] a = new int[3]; Object o2 = a; // OK: an array to Object // Assignments to variables of interface type: ColoredPoint cp = new ColoredPoint(); Colorable c = cp; // OK: ColoredPoint implements Colorable // Assignments to variables of array type: byte[] b = new byte[4]; a = b; // Error: these are not arrays of the same primitive type Point3D[] p3da = new Point3D[3]; Point[] pa = p3da; // OK: since we can assign a Point3D to a Point p3da = pa; // Error: (cast needed) since a Point // can't be assigned to a Point3D } } The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments. This example should be compared to the preceding one. class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); // Okay because ColoredPoint is a subclass of Point: p = cp; // Okay because ColoredPoint implements Colorable: Colorable c = cp; // The following cause compile-time errors because // we cannot be sure they will succeed, depending on // the run-time type of p; a run-time check will be // necessary for the needed narrowing conversion and // must be indicated by including a cast: cp = p; // p might be neither a ColoredPoint // nor a subclass of ColoredPoint c = p; // p might not implement Colorable } } \n\n class Point { int x, y; } class ColoredPoint extends Point { int color; } class Test { public static void main(String[] args) { long[] veclong = new long[100]; Object o = veclong; // okay Long l = veclong; // compile-time error short[] vecshort = veclong; // compile-time error Point[] pvec = new Point[100]; ColoredPoint[] cpvec = new ColoredPoint[100]; pvec = cpvec; // okay pvec[0] = new Point(); // okay at compile time, // but would throw an // exception at run time cpvec = pvec; // compile-time error } }\n• The value of cannot be assigned to a variable, because is a class type other than . An array can be assigned only to a variable of a compatible array type, or to a variable of type , or .\n• The value of cannot be assigned to , because they are arrays of primitive type, and and are not the same primitive type.\n• The value of can be assigned to , because any reference that could be the value of an expression of type can be the value of a variable of type . The subsequent assignment of the new to a component of then would throw an (if the program were otherwise corrected so that it could be compiled), because a array cannot have an instance of as the value of a component.\n• The value of cannot be assigned to , because not every reference that could be the value of an expression of type can correctly be the value of a variable of type . If the value of at run time were a reference to an instance of , and the assignment to were allowed, a simple reference to a component of , say, , could return a , and a is not a . Thus to allow such an assignment would allow a violation of the type system. A cast may be used (§5.5, §15.16) to ensure that references a : cpvec = (ColoredPoint[])pvec; // OK, but may throw an // exception at run time \n\n\n\nMethod invocation conversion is applied to each argument value in a method or constructor invocation (§8.8.7.1, §15.9, §15.12): the type of the argument expression must be converted to the type of the corresponding parameter. Method invocation contexts allow the use of one of the following:\n• an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion. If, after the conversions listed above have been applied, the resulting type is a raw type (§4.8), an unchecked conversion (§5.1.9) may then be applied. It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation. A value of the null type (the null reference is the only such value) may be converted to any reference type. If the type of the expression cannot be converted to the type of the parameter by a conversion permitted in a method invocation context, then a compile-time error occurs. If the type of an argument expression is either or , then value set conversion (§5.1.13) is applied after the type conversion:\n• If an argument value of type is an element of the float-extended-exponent value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow or underflow.\n• If an argument value of type is an element of the double-extended-exponent value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow. The only exceptions that an method invocation conversion may cause are:\n• A if, after the type conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (§4.6) of the corresponding formal parameter type. This circumstance can only arise as a result of heap pollution (§4.12.2).\n• An as a result of a boxing conversion.\n• A as a result of an unboxing conversion on a null reference. Method invocation conversions specifically do not include the implicit narrowing of integer constants which is part of assignment conversion (§5.2). The designers of the Java programming language felt that including these implicit narrowing conversions would add additional complexity to the overloaded method matching resolution process (§15.12.2). causes a compile-time error because the integer literals and have type , so neither method matches under the rules of (§15.12.2). A language that included implicit narrowing of integer constants would need additional rules to resolve cases like this example.\n\nCasting conversion is applied to the operand of a cast operator (§15.16): the type of the operand expression must be converted to the type explicitly named by the cast operator. Casting contexts allow the use of one of:\n• a widening reference conversion (§5.1.5) optionally followed by either an unboxing conversion (§5.1.8) or an unchecked conversion (§5.1.9)\n• a narrowing reference conversion (§5.1.6) optionally followed by either an unboxing conversion (§5.1.8) or an unchecked conversion (§5.1.9)\n• an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion (§5.1.2). Value set conversion (§5.1.13) is applied after the type conversion. The compile-time legality of a casting conversion is as follows:\n• An expression of a primitive type may undergo casting conversion to another primitive type, by an identity conversion (if the types are the same), or by a widening primitive conversion, or by a narrowing primitive conversion, or by a widening and narrowing primitive conversion.\n• An expression of a primitive type may undergo casting conversion to a reference type without error, by boxing conversion.\n• An expression of a reference type may undergo casting conversion to a primitive type without error, by unboxing conversion.\n• An expression of a reference type may undergo casting conversion to another reference type if no compile-time error occurs given the rules in §5.5.1. The following tables enumerate which conversions are used in certain casting conversions. Each conversion is signified by a symbol: In the tables, a comma between symbols indicates that a casting conversion uses one conversion followed by another. The type means any reference type other than the eight wrapper classes , , , , , , , . \n\n \n\n Given a compile-time reference type S (source) and a compile-time reference type T (target), a casting conversion exists from S to T if no compile-time errors occur due to the following rules.\n• If T is a class type, then either |S| |T|, or |T| |S|. Otherwise, a compile-time error occurs. Furthermore, if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types (§4.5), and that the erasures of X and Y are the same, a compile-time error occurs.\n• If T is an interface type:\n• If S is not a class (§8.1.1), then, if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types, and that the erasures of X and Y are the same, a compile-time error occurs. Otherwise, the cast is always legal at compile time (because even if S does not implement T, a subclass of S might).\n• If S is a class (§8.1.1), then S must implement T, or a compile-time error occurs.\n• If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.\n• If T is an array type, then S must be the class , or a compile-time error occurs. If S is an interface type:\n• If T is an array type, then S must be the type or (the only interfaces implemented by arrays), or a compile-time error occurs.\n• If T is a type that is not (§8.1.1), then if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types, and that the erasures of X and Y are the same, a compile-time error occurs. Otherwise, the cast is always legal at compile time (because even if T does not implement S, a subclass of T might).\n• If T is a type that is , then:\n• If S is not a parameterized type or a raw type, then T must implement S, or a compile-time error occurs.\n• Otherwise, S is either a parameterized type that is an invocation of some generic type declaration G, or a raw type corresponding to a generic type declaration G. Then there must exist a supertype X of T, such that X is an invocation of G, or a compile-time error occurs. Furthermore, if S and X are provably distinct parameterized types then a compile-time error occurs. If S is a type variable, then this algorithm is applied recursively, using the upper bound of S in place of S. If S is an intersection type A ... A , then it is a compile-time error if there exists an A (1 ≤ i ≤ n) such that S cannot be cast to A by this algorithm. That is, the success of the cast is determined by the most restrictive component of the intersection type. If S is an array type SC , that is, an array of components of type SC:\n• If T is a class type, then if T is not , then a compile-time error occurs (because is the only class type to which arrays can be assigned).\n• If T is an interface type, then a compile-time error occurs unless T is the type or the type (the only interfaces implemented by arrays).\n• If T is a type variable, then:\n• If the upper bound of T is or or , or a type variable that S could undergo casting conversion to, then the cast is legal (though unchecked).\n• If the upper bound of T is an array type TC , then a compile-time error occurs unless the type SC can undergo casting conversion to TC .\n• If T is an array type TC , that is, an array of components of type TC, then a compile-time error occurs unless one of the following is true:\n• TC and SC are the same primitive type.\n• TC and SC are reference types and type SC can undergo casting conversion to TC. class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } final class EndPoint extends Point {} class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); Colorable c; // The following may cause errors at run time because // we cannot be sure they will succeed; this possibility // is suggested by the casts: cp = (ColoredPoint)p; // p might not reference an // object which is a ColoredPoint // or a subclass of ColoredPoint c = (Colorable)p; // p might not be Colorable // The following are incorrect at compile time because // they can never succeed as explained in the text: Long l = (Long)p; // compile-time error #1 EndPoint e = new EndPoint(); c = (Colorable)e; // compile-time error #2 } } Here, the first compile-time error occurs because the class types and are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail. The second compile-time error occurs because a variable of type can never reference a value that implements the interface . This is because is a type, and a variable of a type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable must be exactly the type , and type does not implement . \n\n class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } public String toString() { return \"(\"+x+\",\"+y+\")\"; } } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; ColoredPoint(int x, int y, int color) { super(x, y); setColor(color); } public void setColor(int color) { this.color = color; } public String toString() { return super.toString() + \"@\" + color; } } class Test { public static void main(String[] args) { Point[] pa = new ColoredPoint[4]; pa[0] = new ColoredPoint(2, 2, 12); pa[1] = new ColoredPoint(4, 5, 24); ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.print(\"cpa: {\"); for (int i = 0; i < cpa.length; i++) System.out.print((i == 0 ? \" \" : \", \") + cpa[i]); System.out.println(\" }\"); } } This program compiles without errors and produces the output: \n\n A cast from a type S to a type T is statically known to be correct if and only if S T (§4.10). A cast from a type S to a parameterized type (§4.5) T is unchecked unless at least one of the following conditions holds:\n• All of the type arguments (§4.5.1) of T are unbounded wildcards\n• T S and S has no subtype X other than T where the type arguments of X are not contained in the type arguments of T. A cast from a type S to a type variable T is unchecked unless S T. An unchecked cast from S to T is completely unchecked if the cast from |S| to |T| is statically known to be correct. Otherwise, it is partially unchecked. An unchecked cast causes a compile-time unchecked warning, unless suppressed by the annotation (§9.6.3.5). A cast is checked if it is not statically known to be correct and it is not unchecked. If a cast to a reference type is not a compile-time error, there are several cases:\n• The cast is statically known to be correct. No run-time action is performed for such a cast.\n• No run-time action is performed for such a cast.\n• Such a cast requires a run-time validity check. The check is performed as if the cast had been a checked cast between |S| and |T|, as described below.\n• Such a cast requires a run-time validity check. If the value at run time is , then the cast is allowed. Otherwise, let R be the class of the object referred to by the run-time reference value, and let T be the erasure (§4.6) of the type named in the cast operator. A cast conversion must check, at run time, that the class R is assignment compatible with the type T, via the algorithm in §5.5.3. Note that R cannot be an interface when these rules are first applied for any given cast, but R may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type. Here is the algorithm to check whether the run-time type R of an object is assignment compatible with the type T which is the erasure (§4.6) of the type named in the cast operator. If a run-time exception is thrown, it is a . If R is an ordinary class (not an array class):\n• If T is a class type, then R must be either the same class (§4.3.4) as T or a subclass of T, or a run-time exception is thrown.\n• If T is an interface type, then R must implement (§8.1.5) interface T, or a run-time exception is thrown.\n• If T is an array type, then a run-time exception is thrown.\n• If T is a class type, then T must be (§4.3.2), or a run-time exception is thrown.\n• If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a run-time exception is thrown.\n• If T is an array type, then a run-time exception is thrown. If R is a class representing an array type RC , that is, an array of components of type RC:\n• If T is a class type, then T must be (§4.3.2), or a run-time exception is thrown.\n• If T is an interface type, then a run-time exception is thrown unless T is the type or the type (the only interfaces implemented by arrays). This case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type .\n• If T is an array type TC , that is, an array of components of type TC, then a run-time exception is thrown unless one of the following is true:\n• TC and RC are the same primitive type.\n• TC and RC are reference types and type RC can be cast to TC by a recursive application of these run-time rules for casting. class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { Point[] pa = new Point[100]; // The following line will throw a ClassCastException: ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.println(cpa[0]); int[] shortvec = new int[2]; Object o = shortvec; // The following line will throw a ClassCastException: Colorable c = (Colorable)o; c.setColor(0); } } This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible. \n\n\n\nNumeric promotion is applied to the operands of an arithmetic operator. Numeric promotion contexts allow the use of: Numeric promotions are used to convert the operands of a numeric operator to a common type so that an operation can be performed. The two kinds of numeric promotion are unary numeric promotion (§5.6.1) and binary numeric promotion (§5.6.2). Some operators apply unary numeric promotion to a single operand, which must produce a value of a numeric type:\n• If the operand is of compile-time type , , , or , it is subjected to unboxing conversion (§5.1.8). The result is then promoted to a value of type by a widening primitive conversion (§5.1.2) or an identity conversion (§5.1.1).\n• Otherwise, if the operand is of compile-time type , , or , it is subjected to unboxing conversion (§5.1.8).\n• Otherwise, if the operand is of compile-time type , , or , it is promoted to a value of type by a widening primitive conversion (§5.1.2).\n• Otherwise, a unary numeric operand remains as is and is not converted. In any case, value set conversion (§5.1.13) is then applied. Unary numeric promotion is performed on expressions in the following situations:\n• Each dimension expression in an array creation expression (§15.10)\n• The index expression in an array access expression (§15.13)\n• The operand of a unary plus operator (§15.15.3)\n• Each operand, separately, of a shift operator , , or (§15.19). A shift distance (right operand) does not promote the value being shifted (left operand) to . class Test { public static void main(String[] args) { byte b = 2; int a[] = new int[b]; // dimension expression promotion char c = '\\u0001'; a[c] = 1; // index expression promotion a[0] = -c; // unary - promotion System.out.println(\"a: \" + a[0] + \",\" + a[1]); b = -1; int i = ~b; // bitwise complement promotion System.out.println(\"~0x\" + Integer.toHexString(b) + \"==0x\" + Integer.toHexString(i)); i = b << 4L; // shift promotion (left operand) System.out.println(\"0x\" + Integer.toHexString(b) + \"<<4L==0x\" + Integer.toHexString(i)); } } \n\n When an operator applies binary numeric promotion to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:\n• If any operand is of a reference type, it is subjected to unboxing conversion (§5.1.8).\n• Widening primitive conversion (§5.1.2) is applied to convert either or both operands as specified by the following rules:\n• If either operand is of type , the other is converted to .\n• Otherwise, if either operand is of type , the other is converted to .\n• Otherwise, if either operand is of type , the other is converted to .\n• Otherwise, both operands are converted to type . After the type conversion, if any, value set conversion (§5.1.13) is applied to each operand. Binary numeric promotion is performed on the operands of certain operators:\n• The addition and subtraction operators for numeric types and (§15.18.2)\n• In certain cases, the conditional operator (§15.25) class Test { public static void main(String[] args) { int i = 0; float f = 1.0f; double d = 2.0; // First int*float is promoted to float*float, then // float==double is promoted to double==double: if (i * f == d) System.out.println(\"oops\"); // A char&byte is promoted to int&int: byte b = 0x1f; char c = 'G'; int control = c & b; System.out.println(Integer.toHexString(control)); // Here int:float is promoted to float:float: f = (b==0) ? i : 4.0f; System.out.println(1.0/f); } } The example converts the ASCII character to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The is the numeric value of this control character."
    },
    {
        "link": "https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html",
        "document": "Every expression written in the Java programming language either produces no result (§15.1) or has a type that can be deduced at compile time (§15.3). When an expression appears in most contexts, it must be compatible with a type expected in that context; this type is called the target type. For convenience, compatibility of an expression with its surrounding context is facilitated in two ways:\n\nIf neither strategy is able to produce the appropriate type, a compile-time error occurs.\n\nThe rules determining whether an expression is a poly expression, and if so, its type and compatibility in a particular context, vary depending on the kind of context and the form of the expression. In addition to influencing the type of the expression, the target type may in some cases influence the run time behavior of the expression in order to produce a value of the appropriate type.\n\nSimilarly, the rules determining whether a target type allows an implicit conversion vary depending on the kind of context, the type of the expression, and, in one special case, the value of a constant expression (§15.28). A conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.\n\nThe conversions possible in the Java programming language are grouped into several broad categories:\n\nThere are six kinds of conversion contexts in which poly expressions may be influenced by context or implicit conversions may occur. Each kind of context has different rules for poly expression typing and allows conversions in some of the categories above but not others. The contexts are:\n\nThe term \"conversion\" is also used to describe, without being specific, any conversions allowed in a particular context. For example, we say that an expression that is the initializer of a local variable is subject to \"assignment conversion\", meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the assignment context.\n\nSpecific type conversions in the Java programming language are divided into 13 categories. A conversion from a type to that same type is permitted for any type. This may seem trivial, but it has two practical consequences. First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion. Second, it implies that it is permitted for a program to include redundant cast operators for the sake of clarity. 19 specific conversions on primitive types are called the widening primitive conversions: A widening primitive conversion does not lose information about the overall magnitude of a numeric value in the following cases, where the numeric value is preserved exactly:\n• from an integral type to another integral type\n• from , , or to a floating point type\n• from to in a expression (§15.4) A widening primitive conversion from to that is not may lose information about the overall magnitude of the converted value. A widening primitive conversion from to , or from to , or from to , may result in loss of precision - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode (§4.2.4). A widening conversion of a signed integer value to an integral type T simply sign-extends the two's-complement representation of the integer value to fill the wider format. A widening conversion of a to an integral type T zero-extends the representation of the value to fill the wider format. Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (§11.1.1). thus indicating that information was lost during the conversion from type to type because values of type are not precise to nine significant digits. \n\n 22 specific conversions on primitive types are called the narrowing primitive conversions: A narrowing primitive conversion may lose information about the overall magnitude of a numeric value and may also lose precision and range. A narrowing primitive conversion from to is governed by the IEEE 754 rounding rules (§4.2.4). This conversion can lose precision, but also lose range, resulting in a zero from a nonzero and a infinity from a finite . A NaN is converted to a NaN and a infinity is converted to the same-signed infinity. A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value. A narrowing conversion of a to an integral type T likewise simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values. A narrowing conversion of a floating-point number to an integral type T takes two steps:\n• In the first step, the floating-point number is converted either to a , if T is , or to an , if T is , , , or , as follows:\n• If the floating-point number is NaN (§4.2.3), the result of the first step of the conversion is an or .\n• Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value , rounding toward zero using IEEE 754 round-toward-zero mode (§4.2.3). Then there are two cases:\n• If T is , and this integer value can be represented as a , then the result of the first step is the value .\n• Otherwise, if this integer value can be represented as an , then the result of the first step is the value .\n• Otherwise, one of the following two cases must be true:\n• The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type or .\n• The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type or .\n• \n• If T is or , the result of the conversion is the result of the first step.\n• If T is , , or , the result of the conversion is the result of a narrowing conversion to type T (§5.1.3) of the result of the first step. Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception (§11.1.1). The results for , , and are unsurprising, producing the minimum and maximum representable values of the type. The results for and lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum . The minimum is, in hexadecimal, , and the maximum int is . This explains the results, which are the low 16 bits of these values, namely, and ; it explains the char results, which also are the low 16 bits of these values, namely, and ; and it explains the byte results, which are the low 8 bits of these values, namely, and . \n\n class Test { public static void main(String[] args) { // A narrowing of int to short loses high bits: System.out.println(\"(short)0x12345678==0x\" + Integer.toHexString((short)0x12345678)); // An int value too big for byte changes sign and magnitude: System.out.println(\"(byte)255==\" + (byte)255); // A float value too big to fit gives largest int value: System.out.println(\"(int)1e20f==\" + (int)1e20f); // A NaN converted to int yields zero: System.out.println(\"(int)NaN==\" + (int)Float.NaN); // A double value too large for float yields infinity: System.out.println(\"(float)-1e100==\" + (float)-1e100); // A double value too small for float underflows to zero: System.out.println(\"(float)1e-50==\" + (float)1e-50); } } \n\n The following conversion combines both widening and narrowing primitive conversions: First, the is converted to an via widening primitive conversion (§5.1.2), and then the resulting is converted to a by narrowing primitive conversion (§5.1.3). A widening reference conversion exists from any reference type S to any reference type T, provided S is a subtype of T (§4.10). Widening reference conversions never require a special action at run time and therefore never throw an exception at run time. They consist simply in regarding a reference as having some other type in a manner that can be proved correct at compile time. The null type is not a reference type (§4.1), and so a widening reference conversion does not exist from the null type to a reference type. However, many conversion contexts explicitly allow the null type to be converted to a reference type. A narrowing reference conversion treats expressions of a reference type S as expressions of a different reference type T, where S is not a subtype of T. The supported pairs of types are defined in §5.1.6.1. Unlike widening reference conversion, the types need not be directly related. However, there are restrictions that prohibit conversion between certain pairs of types when it can be statically proven that no value can be of both types. A narrowing reference conversion may require a test at run time to validate that a value of type S is a legitimate value of type T. However, due to the lack of parameterized type information at run time, some conversions cannot be fully validated by a run time test; they are flagged at compile time (§5.1.6.2). For conversions that can be fully validated by a run time test, and for certain conversions that involve parameterized type information but can still be partially validated at run time, a is thrown if the test fails (§5.1.6.3). A narrowing reference conversion exists from reference type S to reference type T if all of the following are true:\n• S is not a subtype of T (§4.10)\n• If there exists a parameterized type X that is a supertype of T, and a parameterized type Y that is a supertype of S, such that the erasures of X and Y are the same, then X and Y are not provably distinct (§4.5). Using types from the package as an example, no narrowing reference conversion exists from to , or vice versa, because the type arguments and are provably distinct. For the same reason, no narrowing reference conversion exists from to , or vice versa. The rejection of provably distinct types is a simple static gate to prevent \"stupid\" narrowing reference conversions.\n• One of the following cases applies:\n• S and T are class types, and either |S| |T| or |T| |S|.\n• S is a class type, T is an interface type, and S does not name a class (§8.1.1).\n• S is a class type, T is an interface type, and S names a class that implements the interface named by T.\n• S is an interface type, T is a class type, and T does not name a class.\n• S is an interface type, T is a class type, and T names a class that implements the interface named by S.\n• S is the class type or the interface type or (the only interfaces implemented by arrays (§10.8)), and T is an array type.\n• S is an array type SC , that is, an array of components of type SC; T is an array type TC , that is, an array of components of type TC; and a narrowing reference conversion exists from SC to TC.\n• S is a type variable, and a narrowing reference conversion exists from the upper bound of S to T.\n• T is a type variable, and either a widening reference conversion or a narrowing reference conversion exists from S to the upper bound of T.\n• S is an intersection type S ... S , and for all i (1 ≤ i ≤ n), either a widening reference conversion or a narrowing reference conversion exists from S to T.\n• T is an intersection type T ... T , and for all i (1 ≤ i ≤ n), either a widening reference conversion or a narrowing reference conversion exists from S to T . A narrowing reference conversion is either checked or unchecked. These terms refer to the ability of the Java Virtual Machine to validate, or not, the type correctness of the conversion. If a narrowing reference conversion is unchecked, then the Java Virtual Machine will not be able to fully validate its type correctness, possibly leading to heap pollution (§4.12.2). To flag this to the programmer, an unchecked narrowing reference conversion causes a compile-time unchecked warning, unless suppressed by (§9.6.4.5). In contrast, if a narrowing reference conversion is not unchecked, then it is checked; the Java Virtual Machine will be able to fully validate its type correctness, so no warning is given at compile time. The unchecked narrowing reference conversions are as follows:\n• A narrowing reference conversion from a type S to a parameterized class or interface type T is unchecked, unless at least one of the following is true:\n• All of the type arguments of T are unbounded wildcards.\n• T S, and S has no subtype X other than T where the type arguments of X are not contained in the type arguments of T.\n• A narrowing reference conversion from a type S to a type variable T is unchecked.\n• A narrowing reference conversion from a type S to an intersection type T ... T is unchecked if there exists a T (1 ≤ i ≤ n) such that S is not a subtype of T and a narrowing reference conversion from S to T is unchecked. All checked narrowing reference conversions require a validity check at run time. Primarily, these conversions are to class and interface types that are not parameterized. Some unchecked narrowing reference conversions require a validity check at run time. This depends on whether the unchecked narrowing reference conversion is completely unchecked or partially unchecked. A partially unchecked narrowing reference conversion requires a validity check at run time, while a completely unchecked narrowing reference conversion does not. These terms refer to the compatibility of the types involved in the conversion when viewed as raw types. If the conversion is conceptually an \"upcast\", then the conversion is completely unchecked; no run time test is needed because the conversion is legal in the non-generic type system of the Java Virtual Machine. In contrast, if the conversion is conceptually a \"downcast\", then the conversion is partially unchecked; even in the non-generic type system of the Java Virtual Machine, a run time check is needed to test the compatibility of the (raw) types involved in the conversion. Using types from the package as an example, a conversion from to is completely unchecked, because the (raw) type is a subtype of the (raw) type in the Java Virtual Machine. In contrast, a conversion from to is partially unchecked, because the (raw) type is not a subtype of the (raw) type in the Java Virtual Machine. The categorization of an unchecked narrowing reference conversion is as follows:\n• An unchecked narrowing reference conversion from S to a non-intersection type T is completely unchecked if |S| |T|. Otherwise, it is partially unchecked.\n• An unchecked narrowing reference conversion from S to an intersection type T ... T is completely unchecked if, for all i (1 ≤ i ≤ n), either S T or a narrowing reference conversion from S to T is completely unchecked. Otherwise, it is partially unchecked. The run time validity check for a checked or partially unchecked narrowing reference conversion is as follows:\n• If the value at run time is , then the conversion is allowed.\n• Otherwise, let R be the class of the object referred to by the value, and let T be the erasure (§4.6) of the type being converted to. Then:\n• If R is an ordinary class (not an array class):\n• If T is a class type, then R must be either the same class as T (§4.3.4) or a subclass of T, or a is thrown.\n• If T is an interface type, then R must implement interface T (§8.1.5), or a is thrown.\n• If T is an array type, then a is thrown.\n• Note that R cannot be an interface when these rules are first applied for any given conversion, but R may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type.\n• If T is a class type, then T must be (§4.3.2), or a is thrown.\n• If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a is thrown.\n• If T is an array type, then a is thrown.\n• If R is a class representing an array type RC , that is, an array of components of type RC:\n• If T is a class type, then T must be (§4.3.2), or a is thrown.\n• If T is an interface type, then T must be the type or (the only interfaces implemented by arrays), or a is thrown.\n• If T is an array type TC , that is, an array of components of type TC, then a is thrown unless either TC and RC are the same primitive type, or TC and RC are reference types and are allowed by a recursive application of these run-time rules. If the conversion is to an intersection type T ... T , then for all i (1 ≤ i ≤ n), any run-time check required for a conversion from S to T is also required for the conversion to the intersection type. Boxing conversion treats expressions of a primitive type as expressions of a corresponding reference type. Specifically, the following nine conversions are called the boxing conversions:\n• From the null type to the null type This rule is necessary because the conditional operator (§15.25) applies boxing conversion to the types of its operands, and uses the result in further calculations. At run time, boxing conversion proceeds as follows:\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type , then boxing conversion converts into a reference of class and type , such that\n• If is a value of type then:\n• If is not NaN, then boxing conversion converts into a reference of class and type , such that evaluates to\n• Otherwise, boxing conversion converts into a reference of class and type such that evaluates to\n• If is a value of type , then:\n• If is not NaN, boxing conversion converts into a reference of class and type , such that evaluates to\n• Otherwise, boxing conversion converts into a reference of class and type such that evaluates to\n• If is a value of any other type, boxing conversion is equivalent to an identity conversion (§5.1.1). If the value being boxed is the result of evaluating a constant expression (§15.28) of type , , , , or , and the result is , , a character in the range to inclusive, or an integer in the range to inclusive, then let and be the results of any two boxing conversions of . It is always the case that . Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rule above is a pragmatic compromise, requiring that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, the rule disallows any assumptions about the identity of the boxed values on the programmer's part. This allows (but does not require) sharing of some or all of these references. This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all and values, as well as and values in the range of -32K to +32K. A boxing conversion may result in an if a new instance of one of the wrapper classes ( , , , , , , , or ) needs to be allocated and insufficient storage is available. Unboxing conversion treats expressions of a reference type as expressions of a corresponding primitive type. Specifically, the following eight conversions are called the unboxing conversions: At run time, unboxing conversion proceeds as follows:\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into\n• If is a reference of type , unboxing conversion converts into\n• If is a reference of type , then unboxing conversion converts into A type is said to be convertible to a numeric type if it is a numeric type (§4.2), or it is a reference type that may be converted to a numeric type by unboxing conversion. A type is said to be convertible to an integral type if it is an integral type, or it is a reference type that may be converted to an integral type by unboxing conversion. Let G name a generic type declaration with n type parameters. There is an unchecked conversion from the raw class or interface type (§4.8) G to any parameterized type of the form G T ,...,T . There is an unchecked conversion from the raw array type G k to any array type of the form G T ,...,T k. (The notation k indicates an array type of k dimensions.) Use of an unchecked conversion causes a compile-time unchecked warning unless all type arguments T (1 ≤ i ≤ n) are unbounded wildcards (§4.5.1), or the warning is suppressed by (§9.6.4.5). Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification). In such circumstances (most notably, clients of the Collections Framework in ), legacy code uses raw types (e.g. instead of ). Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters. Such calls cannot be shown to be statically safe under the type system using generics. Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries. This in turn, would discourage library vendors from taking advantage of genericity. To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers. While the conversion is unsound, it is tolerated as a concession to practicality. An unchecked warning is issued in such cases. Let G name a generic type declaration (§8.1.2, §9.1.2) with n type parameters A ,...,A with corresponding bounds U ,...,U . There exists a capture conversion from a parameterized type G T ,...,T (§4.5) to a parameterized type G S ,...,S , where, for 1 ≤ i ≤ n :\n• If T is a wildcard type argument (§4.5.1) of the form , then S is a fresh type variable whose upper bound is U and whose lower bound is the null type (§4.1).\n• If T is a wildcard type argument of the form B , then S is a fresh type variable whose upper bound is glb(B , U ) and whose lower bound is the null type. It is a compile-time error if, for any two classes (not interfaces) V and V , V is not a subclass of V or vice versa.\n• If T is a wildcard type argument of the form B , then S is a fresh type variable whose upper bound is U and whose lower bound is B . Capture conversion on any type other than a parameterized type (§4.5) acts as an identity conversion (§5.1.1). Capture conversion never requires a special action at run time and therefore never throws an exception at run time. Capture conversion is designed to make wildcards more useful. To understand the motivation, let's begin by looking at the method : The method reverses the list provided as a parameter. It works for any type of list, and so the use of the wildcard type as the type of the formal parameter is entirely appropriate. Now consider how one would implement : The implementation needs to copy the list, extract elements from the copy, and insert them into the original. To do this in a type-safe manner, we need to give a name, , to the element type of the incoming list. We do this in the private service method . This requires us to pass the incoming argument list, of type , as an argument to . In general, is a list of unknown type. It is not a subtype of , for any type T. Allowing such a subtype relation would be unsound. Given the method: the following code would undermine the type system: List<String> ls = new ArrayList<String>(); List<?> l = ls; Collections.fill(l, new Object()); // not legal - but assume it was! String s = ls.get(0); // ClassCastException - ls contains // Objects, not Strings. So, without some special dispensation, we can see that the call from to would be disallowed. If this were the case, the author of would be forced to write its signature as: This is undesirable, as it exposes implementation information to the caller. Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded. The call from to is in fact harmless, but it cannot be justified on the basis of a general subtyping relation between and . The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one). If we can capture this unknown type in a type variable , we can infer to be . That is the essence of capture conversion. The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc. Mathematically sophisticated readers will want to relate capture conversion to established type theory. Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as Types and Programming Languages by Benjamin Pierce, and then revisit this section. Here then is a brief summary of the relationship of capture conversion to established type theoretical notions. Wildcard types are a restricted form of existential types. Capture conversion corresponds loosely to an opening of a value of existential type. A capture conversion of an expression can be thought of as an of in a scope that comprises the top level expression that encloses . The classical operation on existentials requires that the captured type variable must not escape the opened expression. The that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope. The advantage of this scheme is that there is no need for a operation, as defined in the paper On Variance-Based Subtyping for Parametric Types by Atsushi Igarashi and Mirko Viroli, in the proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002). For a formal account of wildcards, see Wild FJ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005). Any type may be converted to type by string conversion. A value of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression (§15.9):\n• If T is , then use .\n• If T is , then use .\n• If T is , , or , then use .\n• If T is , then use .\n• If T is , then use .\n• If T is , then use . This reference value is then converted to type by string conversion. Now only reference values need to be considered:\n• If the reference is , it is converted to the string \" \" (four ASCII characters , , , ).\n• Otherwise, the conversion is performed as if by an invocation of the method of the referenced object with no arguments; but if the result of invoking the method is , then the string \" \" is used instead. The method is defined by the primordial class (§4.3.2). Many classes override it, notably , , , , , , and . Any conversion that is not explicitly allowed is forbidden. Value set conversion is the process of mapping a floating-point value from one value set to another without changing its type. Within an expression that is not FP-strict (§15.4), value set conversion provides choices to an implementation of the Java programming language:\n• If the value is an element of the float-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the float value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign).\n• If the value is an element of the double-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the double value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign). Within an FP-strict expression (§15.4), value set conversion does not provide any choices; every implementation must behave in the same way:\n• If the value is of type and is not an element of the float value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow or underflow.\n• If the value is of type and is not an element of the double value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow. Within an FP-strict expression, mapping values from the float-extended-exponent value set or double-extended-exponent value set is necessary only when a method is invoked whose declaration is not FP-strict and the implementation has chosen to represent the result of the method invocation as an element of an extended-exponent value set. Whether in FP-strict code or code that is not FP-strict, value set conversion always leaves unchanged any value whose type is neither nor .\n\nAssignment contexts allow the value of an expression to be assigned (§15.26) to a variable; the type of the expression must be converted to the type of the variable. Assignment contexts allow the use of one of the following:\n• a widening reference conversion followed by an unboxing conversion\n• a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion\n• an unboxing conversion followed by a widening primitive conversion If, after the conversions listed above have been applied, the resulting type is a raw type (§4.8), an unchecked conversion (§5.1.9) may then be applied. In addition, if the expression is a constant expression (§15.28) of type , , , or :\n• A narrowing primitive conversion may be used if the variable is of type , , or , and the value of the constant expression is representable in the type of the variable.\n• A narrowing primitive conversion followed by a boxing conversion may be used if the variable is of type , , or , and the value of the constant expression is representable in the type , , or respectively. The compile-time narrowing of constant expressions means that code such as: is allowed. Without the narrowing, the fact that the integer literal has type would mean that a cast to would be required: byte theAnswer = (byte)42; // cast is permitted but not required Finally, a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type. It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation (§4.10). An example of such an illegal chain would be: The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion. However, this is not a valid assignment conversion, because the chain contains two parameterized types, and , that are not subtypes. If the type of an expression can be converted to the type of a variable by assignment conversion, we say the expression (or its value) is assignable to the variable or, equivalently, that the type of the expression is assignment compatible with the type of the variable. If the type of the variable is or , then value set conversion (§5.1.13) is applied to the value that is the result of the conversion(s):\n• If is of type and is an element of the float-extended-exponent value set, then the implementation must map to the nearest element of the float value set. This conversion may result in overflow or underflow.\n• If is of type and is an element of the double-extended-exponent value set, then the implementation must map to the nearest element of the double value set. This conversion may result in overflow or underflow. The only exceptions that may arise from conversions in an assignment context are:\n• A if, after the conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure (§4.6) of the type of the variable. This circumstance can only arise as a result of heap pollution (§4.12.2). In practice, implementations need only perform casts when accessing a field or method of an object of parameterized type when the erased type of the field, or the erased return type of the method, differ from its unerased type.\n• An as a result of a boxing conversion.\n• A as a result of an unboxing conversion on a null reference.\n• An in special cases involving array elements or field access (§10.5, §15.26.1). class Test { public static void main(String[] args) { short s = 12; // narrow 12 to short float f = s; // widen short to float System.out.println(\"f=\" + f); char c = '\\u0123'; long l = c; // widen char to long System.out.println(\"l=0x\" + Long.toString(l,16)); f = 1.23f; double d = f; // widen float to double System.out.println(\"d=\" + d); } } The following program, however, produces compile-time errors: class Test { public static void main(String[] args) { short s = 123; char c = s; // error: would require cast s = c; // error: would require cast } } because not all values are values, and neither are all values values. \n\n class Point { int x, y; } class Point3D extends Point { int z; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { // Assignments to variables of class type: Point p = new Point(); p = new Point3D(); // OK because Point3D is a subclass of Point Point3D p3d = p; // Error: will require a cast because a Point // might not be a Point3D (even though it is, // dynamically, in this example.) // Assignments to variables of type Object: Object o = p; // OK: any object to Object int[] a = new int[3]; Object o2 = a; // OK: an array to Object // Assignments to variables of interface type: ColoredPoint cp = new ColoredPoint(); Colorable c = cp; // OK: ColoredPoint implements Colorable // Assignments to variables of array type: byte[] b = new byte[4]; a = b; // Error: these are not arrays of the same primitive type Point3D[] p3da = new Point3D[3]; Point[] pa = p3da; // OK: since we can assign a Point3D to a Point p3da = pa; // Error: (cast needed) since a Point // can't be assigned to a Point3D } } The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments. This example should be compared to the preceding one. class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); // Okay because ColoredPoint is a subclass of Point: p = cp; // Okay because ColoredPoint implements Colorable: Colorable c = cp; // The following cause compile-time errors because // we cannot be sure they will succeed, depending on // the run-time type of p; a run-time check will be // necessary for the needed narrowing conversion and // must be indicated by including a cast: cp = p; // p might be neither a ColoredPoint // nor a subclass of ColoredPoint c = p; // p might not implement Colorable } } \n\n class Point { int x, y; } class ColoredPoint extends Point { int color; } class Test { public static void main(String[] args) { long[] veclong = new long[100]; Object o = veclong; // okay Long l = veclong; // compile-time error short[] vecshort = veclong; // compile-time error Point[] pvec = new Point[100]; ColoredPoint[] cpvec = new ColoredPoint[100]; pvec = cpvec; // okay pvec[0] = new Point(); // okay at compile time, // but would throw an // exception at run time cpvec = pvec; // compile-time error } }\n• The value of cannot be assigned to a variable, because is a class type other than . An array can be assigned only to a variable of a compatible array type, or to a variable of type , or .\n• The value of cannot be assigned to , because they are arrays of primitive type, and and are not the same primitive type.\n• The value of can be assigned to , because any reference that could be the value of an expression of type can be the value of a variable of type . The subsequent assignment of the new to a component of then would throw an (if the program were otherwise corrected so that it could be compiled), because a array cannot have an instance of as the value of a component.\n• The value of cannot be assigned to , because not every reference that could be the value of an expression of type can correctly be the value of a variable of type . If the value of at run time were a reference to an instance of , and the assignment to were allowed, a simple reference to a component of , say, , could return a , and a is not a . Thus to allow such an assignment would allow a violation of the type system. A cast may be used (§5.5, §15.16) to ensure that references a : cpvec = (ColoredPoint[])pvec; // OK, but may throw an // exception at run time \n\n\n\nCasting contexts allow the operand of a cast expression (§15.16) to be converted to the type explicitly named by the cast operator. Compared to assignment contexts and invocation contexts, casting contexts allow the use of more of the conversions defined in §5.1, and allow more combinations of those conversions. If the expression is of a primitive type, then a casting context allows the use of one of the following: If the expression is of a reference type, then a casting context allows the use of one of the following:\n• a widening reference conversion followed by an unboxing conversion\n• a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion\n• a narrowing reference conversion followed by an unboxing conversion\n• an unboxing conversion followed by a widening primitive conversion If the expression has the null type, then the expression may be cast to any reference type. If a casting context makes use of a narrowing reference conversion that is checked or partially unchecked (§5.1.6.2, §5.1.6.3), then a run time check will be performed on the class of the expression's value, possibly causing a . Otherwise, no run time check is performed. Value set conversion (§5.1.13) is applied after the type conversion. The following tables enumerate which conversions are used in certain casting contexts. Each conversion is signified by a symbol: In the tables, a comma between symbols indicates that a casting context uses one conversion followed by another. The type means any reference type other than the eight wrapper classes , , , , , , , . \n\n \n\n class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } final class EndPoint extends Point {} class Test { public static void main(String[] args) { Point p = new Point(); ColoredPoint cp = new ColoredPoint(); Colorable c; // The following may cause errors at run time because // we cannot be sure they will succeed; this possibility // is suggested by the casts: cp = (ColoredPoint)p; // p might not reference an // object which is a ColoredPoint // or a subclass of ColoredPoint c = (Colorable)p; // p might not be Colorable // The following are incorrect at compile time because // they can never succeed as explained in the text: Long l = (Long)p; // compile-time error #1 EndPoint e = new EndPoint(); c = (Colorable)e; // compile-time error #2 } } Here, the first compile-time error occurs because the class types and are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail. The second compile-time error occurs because a variable of type can never reference a value that implements the interface . This is because is a type, and a variable of a type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable must be exactly the type , and type does not implement . \n\n class Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } public String toString() { return \"(\"+x+\",\"+y+\")\"; } } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; ColoredPoint(int x, int y, int color) { super(x, y); setColor(color); } public void setColor(int color) { this.color = color; } public String toString() { return super.toString() + \"@\" + color; } } class Test { public static void main(String[] args) { Point[] pa = new ColoredPoint[4]; pa[0] = new ColoredPoint(2, 2, 12); pa[1] = new ColoredPoint(4, 5, 24); ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.print(\"cpa: {\"); for (int i = 0; i < cpa.length; i++) System.out.print((i == 0 ? \" \" : \", \") + cpa[i]); System.out.println(\" }\"); } } This program compiles without errors and produces the output: \n\n class Point { int x, y; } interface Colorable { void setColor(int color); } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } } class Test { public static void main(String[] args) { Point[] pa = new Point[100]; // The following line will throw a ClassCastException: ColoredPoint[] cpa = (ColoredPoint[])pa; System.out.println(cpa[0]); int[] shortvec = new int[2]; Object o = shortvec; // The following line will throw a ClassCastException: Colorable c = (Colorable)o; c.setColor(0); } } This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible. \n\n\n\nNumeric contexts apply to the operands of an arithmetic operator. Numeric contexts allow the use of:\n• a widening reference conversion (§5.1.5) followed by an unboxing conversion\n• a widening reference conversion followed by an unboxing conversion, then followed by a widening primitive conversion\n• an unboxing conversion followed by a widening primitive conversion A numeric promotion is a process by which, given an arithmetic operator and its argument expressions, the arguments are converted to an inferred target type T. T is chosen during promotion such that each argument expression can be converted to T and the arithmetic operation is defined for values of type T. The two kinds of numeric promotion are unary numeric promotion (§5.6.1) and binary numeric promotion (§5.6.2). Some operators apply unary numeric promotion to a single operand, which must produce a value of a numeric type:\n• If the operand is of compile-time type , , , or , it is subjected to unboxing conversion (§5.1.8). The result is then promoted to a value of type by a widening primitive conversion (§5.1.2) or an identity conversion (§5.1.1).\n• Otherwise, if the operand is of compile-time type , , or , it is subjected to unboxing conversion (§5.1.8).\n• Otherwise, if the operand is of compile-time type , , or , it is promoted to a value of type by a widening primitive conversion (§5.1.2).\n• Otherwise, a unary numeric operand remains as is and is not converted. After the conversion(s), if any, value set conversion (§5.1.13) is then applied. Unary numeric promotion is performed on expressions in the following situations:\n• Each dimension expression in an array creation expression (§15.10.1)\n• The index expression in an array access expression (§15.10.3)\n• The operand of a unary plus operator (§15.15.3)\n• Each operand, separately, of a shift operator , , or (§15.19). A shift distance (right operand) does not promote the value being shifted (left operand) to . class Test { public static void main(String[] args) { byte b = 2; int a[] = new int[b]; // dimension expression promotion char c = '\\u0001'; a[c] = 1; // index expression promotion a[0] = -c; // unary - promotion System.out.println(\"a: \" + a[0] + \",\" + a[1]); b = -1; int i = ~b; // bitwise complement promotion System.out.println(\"~0x\" + Integer.toHexString(b) + \"==0x\" + Integer.toHexString(i)); i = b << 4L; // shift promotion (left operand) System.out.println(\"0x\" + Integer.toHexString(b) + \"<<4L==0x\" + Integer.toHexString(i)); } } \n\n When an operator applies binary numeric promotion to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:\n• If any operand is of a reference type, it is subjected to unboxing conversion (§5.1.8).\n• Widening primitive conversion (§5.1.2) is applied to convert either or both operands as specified by the following rules:\n• If either operand is of type , the other is converted to .\n• Otherwise, if either operand is of type , the other is converted to .\n• Otherwise, if either operand is of type , the other is converted to .\n• Otherwise, both operands are converted to type . After the conversion(s), if any, value set conversion (§5.1.13) is then applied to each operand. Binary numeric promotion is performed on the operands of certain operators:\n• The addition and subtraction operators for numeric types and (§15.18.2)\n• In certain cases, the conditional operator (§15.25) class Test { public static void main(String[] args) { int i = 0; float f = 1.0f; double d = 2.0; // First int*float is promoted to float*float, then // float==double is promoted to double==double: if (i * f == d) System.out.println(\"oops\"); // A char&byte is promoted to int&int: byte b = 0x1f; char c = 'G'; int control = c & b; System.out.println(Integer.toHexString(control)); // Here int:float is promoted to float:float: f = (b==0) ? i : 4.0f; System.out.println(1.0/f); } } The example converts the ASCII character to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The is the numeric value of this control character."
    },
    {
        "link": "https://stackoverflow.com/questions/3881/illegalargumentexception-or-nullpointerexception-for-a-null-parameter",
        "document": "I have a simple setter method for a property and null is not appropriate for this particular property. I have always been torn in this situation: should I throw an IllegalArgumentException , or a NullPointerException ? From the javadocs, both seem appropriate. Is there some kind of an understood standard? Or is this just one of those things that you should do whatever you prefer and both are really correct?\n\nWant to improve this question? Update the question so it can be answered with facts and citations by editing this post .\n\nYou should be using (IAE), not (NPE) for the following reasons: First, the NPE JavaDoc explicitly lists the cases where NPE is appropriate. Notice that all of them are thrown by the runtime when is used inappropriately. In contrast, the IAE JavaDoc couldn't be more clear: \"Thrown to indicate that a method has been passed an illegal or inappropriate argument.\" Yup, that's you! Second, when you see an NPE in a stack trace, what do you assume? Probably that someone dereferenced a . When you see IAE, you assume the caller of the method at the top of the stack passed in an illegal value. Again, the latter assumption is true, the former is misleading. Third, since IAE is clearly designed for validating parameters, you have to assume it as the default choice of exception, so why would you choose NPE instead? Certainly not for different behavior -- do you really expect calling code to catch NPE's separately from IAE and do something different as a result? Are you trying to communicate a more specific error message? But you can do that in the exception message text anyway, as you should for all other incorrect parameters. Fourth, all other incorrect parameter data will be IAE, so why not be consistent? Why is it that an illegal is so special that it deserves a separate exception from all other types of illegal arguments? Finally, I accept the argument given by other answers that parts of the Java API use NPE in this manner. However, the Java API is inconsistent with everything from exception types to naming conventions, so I think just blindly copying (your favorite part of) the Java API isn't a good enough argument to trump these other considerations.\n\nI was all in favour of throwing for null parameters, until today, when I noticed the method in Java 7. With that method, instead of doing: if (param == null) { throw new IllegalArgumentException(\"param cannot be null.\"); } and it will throw a if the parameter you pass it is . Given that that method is right bang in the middle of I take its existence to be a pretty strong indication that throwing is \"the Java way of doing things\". I think I'm decided at any rate. Note that the arguments about hard debugging are bogus because you can of course provide a message to saying what was null and why it shouldn't be null. Just like with . One added advantage of is that, in highly performance critical code, you could dispense with an explicit check for null (and a with a friendly error message), and just rely on the you'll get automatically when you call a method on the null parameter. Provided you call a method quickly (i.e. fail fast), then you have essentially the same effect, just not quite as user friendly for the developer. Most times it's probably better to check explicitly and throw with a useful message to indicate which parameter was null, but it's nice to have the option of changing that if performance dictates without breaking the published contract of the method/constructor.\n\nActually, the question of throwing IllegalArgumentException or NullPointerException is in my humble view only a \"holy war\" for a minority with an incomlete understanding of exception handling in Java. In general, the rules are simple, and as follows:\n• argument constraint violations must be indicated as fast as possible (-> fast fail), in order to avoid illegal states which are much harder to debug\n• in case of an invalid null pointer for whatever reason, throw NullPointerException\n• in case of an illegal array/collection index, throw ArrayIndexOutOfBounds\n• in case of an illegal argument that is not covered by the above, and for which you don't have another more specific exception type, throw IllegalArgumentException as a wastebasket\n• on the other hand, in case of a constraint violation WITHIN A FIELD that could not be avoided by fast fail for some valid reason, catch and rethrow as IllegalStateException or a more specific checked exception. Never let pass the original NullPointerException, ArrayIndexOutOfBounds, etc in this case! There are at least three very good reasons against the case of mapping all kinds of argument constraint violations to IllegalArgumentException, with the third probably being so severe as to mark the practice bad style: (1) A programmer cannot a safely assume that all cases of argument constraint violations result in IllegalArgumentException, because the large majority of standard classes use this exception rather as a wastebasket if there is no more specific kind of exception available. Trying to map all cases of argument constraint violations to IllegalArgumentException in your API only leads to programmer frustration using your classes, as the standard libraries mostly follow different rules that violate yours, and most of your API users will use them as well! (2) Mapping the exceptions actually results in a different kind of anomaly, caused by single inheritance: All Java exceptions are classes, and therefore support single inheritance only. Therefore, there is no way to create an exception that is truly say both a NullPointerException and an IllegalArgumentException, as subclasses can only inherit from one or the other. Throwing an IllegalArgumentException in case of a null argument therefore makes it harder for API users to distinguish between problems whenever a program tries to programmatically correct the problem, for example by feeding default values into a call repeat! (3) Mapping actually creates the danger of bug masking: In order to map argument constraint violations into IllegalArgumentException, you'll need to code an outer try-catch within every method that has any constrained arguments. However, simply catching RuntimeException in this catch block is out of the question, because that risks mapping documented RuntimeExceptions thrown by libery methods used within yours into IllegalArgumentException, even if they are no caused by argument constraint violations. So you need to be very specific, but even that effort doesn't protect you from the case that you accidentally map an undocumented runtime exception of another API (i.e. a bug) into an IllegalArgumentException of your API. Even the most careful mapping therefore risks masking programming errors of other library makers as argument constraint violations of your method's users, which is simply hillareous behavior! With the standard practice on the other hand, the rules stay simple, and exception causes stay unmasked and specific. For the method caller, the rules are easy as well: - if you encounter a documented runtime exception of any kind because you passed an illegal value, either repeat the call with a default (for this specific exceptions are neccessary), or correct your code - if on the other hand you enccounter a runtime exception that is not documented to happen for a given set of arguments, file a bug report to the method's makers to ensure that either their code or their documentation is fixed.\n\nAs a subjective question this should be closed, but as it's still open: This is part of the internal policy used at my previous place of employment and it worked really well. This is all from memory so I can't remember the exact wording. It's worth noting that they did not use checked exceptions, but that is beyond the scope of the question. The unchecked exceptions they did use fell into 3 main categories. NullPointerException: Do not throw intentionally. NPEs are to be thrown only by the VM when dereferencing a null reference. All possible effort is to be made to ensure that these are never thrown. @Nullable and @NotNull should be used in conjunction with code analysis tools to find these errors. IllegalArgumentException: Thrown when an argument to a function does not conform to the public documentation, such that the error can be identified and described in terms of the arguments passed in. The OP's situation would fall into this category. IllegalStateException: Thrown when a function is called and its arguments are either unexpected at the time they are passed or incompatible with the state of the object the method is a member of. For example, there were two internal versions of the IndexOutOfBoundsException used in things that had a length. One a sub-class of IllegalStateException, used if the index was larger than the length. The other a subclass of IllegalArgumentException, used if the index was negative. This was because you could add more items to the object and the argument would be valid, while a negative number is never valid. As I said, this system works really well, and it took someone to explain why the distinction is there: \"Depending on the type of error it is quite straightforward for you to figure out what to do. Even if you can't actually figure out what went wrong you can figure out where to catch that error and create additional debugging information.\" NullPointerException: Handle the Null case or put in an assertion so that the NPE is not thrown. If you put in an assertion is just one of the other two types. If possible, continue debugging as if the assertion was there in the first place. IllegalArgumentException: you have something wrong at your call site. If the values being passed in are from another function, find out why you are receiving an incorrect value. If you are passing in one of your arguments propagate the error checks up the call stack until you find the function that is not returning what you expect. IllegalStateException: You have not called your functions in the correct order. If you are using one of your arguments, check them and throw an IllegalArgumentException describing the issue. You can then propagate the cheeks up against the stack until you find the issue. Anyway, his point was that you can only copy the IllegalArgumentAssertions up the stack. There is no way for you to propagate the IllegalStateExceptions or NullPointerExceptions up the stack because they had something to do with your function."
    },
    {
        "link": "https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors",
        "document": "Programs must not catch . A exception thrown at runtime indicates the existence of an underlying pointer dereference that must be fixed in the application code (see EXP01-J. Do not use a null in a case where an object is required for more information). Handling the underlying null pointer dereference by catching the rather than fixing the underlying problem is inappropriate for several reasons. First, catching adds significantly more performance overhead than simply adding the necessary null checks [Bloch 2008]. Second, when multiple expressions in a block are capable of throwing a , it is difficult or impossible to determine which expression is responsible for the exception because the block handles any thrown from any location in the block. Third, programs rarely remain in an expected and usable state after a has been thrown. Attempts to continue execution after first catching and logging (or worse, suppressing) the exception rarely succeed.\n\nLikewise, programs must not catch , , or . Few, if any, methods are capable of handling all possible runtime exceptions. When a method catches , it may receive exceptions unanticipated by the designer, including and . Many clauses simply log or ignore the enclosed exceptional condition and attempt to resume normal execution; this practice often violates ERR00-J. Do not suppress or ignore checked exceptions. Runtime exceptions often indicate bugs in the program that should be fixed by the developer and often cause control flow vulnerabilities.\n\nThis noncompliant code example defines an method that takes a argument and returns true if the given string is a valid name. A valid name is defined as two capitalized words separated by one or more spaces. Rather than checking to see whether the given string is null, the method catches and returns false.\n\nThis compliant solution explicitly checks the argument for rather than catching :\n\nThis compliant solution omits an explicit check for a null reference and permits a to be thrown:\n\nOmitting the null check means that the program fails more quickly than if the program had returned false and lets an invoking method discover the null value. A method that throws a without a null check must provide a precondition that the argument being passed to it is not null.\n\nThis noncompliant code example is derived from the logging service Null Object design pattern described by Henney [Henney 2003]. The logging service is composed of two classes: one that prints the triggering activity's details to a disk file using the class and another that prints to the console using the class. An interface, , defines a method that is implemented by the respective log classes. Method selection occurs polymorphically at runtime. The logging infrastructure is subsequently used by a class.\n\nEach object must support the possibility that a object may be because clients may choose not to perform logging. This noncompliant code example eliminates null checks by using a block that ignores .\n\nThis design choice suppresses genuine occurrences of in violation of ERR00-J. Do not suppress or ignore checked exceptions. It also violates the design principle that exceptions should be used only for exceptional conditions because ignoring a null object is part of the ordinary operation of a server.\n\nThe Null Object design pattern provides an alternative to the use of explicit null checks in code. It reduces the need for explicit null checks through the use of an explicit, safe null object rather than a null reference.\n\nThis compliant solution modifies the no-argument constructor of class to use the do-nothing behavior provided by an additional class, ; it leaves the other classes unchanged.\n\nDeclaring the reference final ensures that its value is assigned during initialization.\n\nAn acceptable alternative implementation uses accessor methods to control all interaction with the reference to the current log. The accessor method to set a log ensures use of the null object in place of a null reference. The accessor method to get a log ensures that any retrieved instance is either an actual logger or a null object (but never a null reference). Instances of the null object are immutable and are inherently thread-safe.\n\nSome system designs require returning a value from a method rather than implementing do-nothing behavior. One acceptable approach is use of an exceptional value object that throws an exception before the method returns [Cunningham 1995]. This approach can be a useful alternative to returning .\n\nIn distributed environments, the null object must be passed by copy to ensure that remote systems avoid the overhead of a remote call argument evaluation on every access to the null object. Null object code for distributed environments must also implement the interface.\n\nCode that uses this pattern must be clearly documented to ensure that security-critical messages are never discarded because the pattern has been misapplied.\n\nThis noncompliant code example assumes that the original version of the method was declared to throw only . However, the caller catches the more general type to report arithmetic problems rather than catching the specific exception type. This practice is risky because future changes to the method signature could add more exceptions to the list of potential exceptions the caller must handle. In this example, a revision of the method can throw in addition to . However, the compiler will not diagnose the lack of a corresponding handler because the invoking method already catches as a result of catching . Consequently, the recovery process might be inappropriate for the specific exception type that is thrown. Furthermore, the developer has failed to anticipate that catching also catches unchecked exceptions.\n\nThis noncompliant code example attempts to solve the problem by specifically catching . However, it continues to catch and consequently catches both unanticipated checked exceptions and unanticipated runtime exceptions.\n\nNote that is a custom exception type that extends .\n\nThis compliant solution catches only the specific anticipated exceptions ( and ). All other exceptions are permitted to propagate up the call stack.\n\nThe class is documented in ERR00-J. Do not suppress or ignore checked exceptions.\n\nJava SE 7 allows a single block to catch multiple exceptions of different types, which prevents redundant code. This compliant solution catches the specific anticipated exceptions ( and ) and handles them with one catch clause. All other exceptions are permitted to propagate to the next clause of a statement on the stack.\n\nERR08-J-EX0: A block may catch all exceptions to process them before rethrowing them (filtering sensitive information from exceptions before the call stack leaves a trust boundary, for example). Refer to ERR01-J. Do not allow exceptions to expose sensitive information and weaknesses CWE 7 and CWE 388 for more information. In such cases, a block should catch rather than or .\n\nThis code sample catches all exceptions and wraps them in a custom before rethrowing them:\n\nException wrapping is a common technique to safely handle unknown exceptions. For another example, see ERR06-J. Do not throw undeclared checked exceptions.\n\nERR08-J-EX1: Task processing threads such as worker threads in a thread pool or the Swing event dispatch thread are permitted to catch when they call untrusted code through an abstraction such as the interface [Goetz 2006, p. 161].\n\nERR08-J-EX2: Systems that require substantial fault tolerance or graceful degradation are permitted to catch and log general exceptions such as at appropriate levels of abstraction. For example:\n• A real-time control system that catches and logs all exceptions at the outermost layer, followed by warm-starting the system so that real-time control can continue. Such approaches are clearly justified when program termination would have safety-critical or mission-critical consequences.\n• A system that catches all exceptions that propagate out of each major subsystem, logs the exceptions for later debugging, and subsequently shuts down the failing subsystem (perhaps replacing it with a much simpler, limited-functionality version) while continuing other services.\n\nCatching may mask an underlying null dereference, degrade application performance, and result in code that is hard to understand and maintain. Likewise, catching , , or may unintentionally trap other exception types and prevent them from being handled properly."
    }
]