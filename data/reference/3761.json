[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nIn this guide, we'll take a look at how to use to issue HTTP requests in order to exchange data between the website and a server. Examples of both common and more obscure use cases for are included. After the transaction completes, the object will contain useful information such as the response body and the HTTP status of the result.\n\nA request made via can fetch the data in one of two ways, asynchronously or synchronously. The type of request is dictated by the optional argument (the third argument) that is set on the method. If this argument is or not specified, the is processed asynchronously, otherwise the process is handled synchronously. A detailed discussion and demonstrations of these two types of requests can be found on the synchronous and asynchronous requests page. You can't use synchronous requests outside web workers as it freezes the main interface. Note: The constructor isn't limited to only XML documents. It starts with \"XML\" because when it was created the main format that was originally used for asynchronous data exchange was XML.\n\nAlthough is most commonly used to send and receive textual data, it can be used to send and receive binary content. There are several well tested methods for coercing the response of an into sending binary data. These involve utilizing the method on the object and is a workable solution. However, more modern techniques are available, since the attribute now supports a number of additional content types, which makes sending and receiving binary data much easier. For example, consider this snippet, which uses the of to fetch the remote content into a object, which stores the raw binary data. For more examples check out the Sending and Receiving Binary Data page.\n\nprovides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth. Support for DOM event monitoring of transfers follows the specification for progress events: these events implement the interface. The actual events you can monitor to determine the state of an ongoing transfer are: The amount of data that has been retrieved has changed. The transfer is complete; all data is now in the const req = new XMLHttpRequest(); req.addEventListener(\"progress\", updateProgress); req.addEventListener(\"load\", transferComplete); req.addEventListener(\"error\", transferFailed); req.addEventListener(\"abort\", transferCanceled); req.open(); // … // progress on transfers from the server to the client (downloads) function updateProgress(event) { if (event.lengthComputable) { const percentComplete = (event.loaded / event.total) * 100; // … } else { // Unable to compute progress information since the total size is unknown } } function transferComplete(evt) { console.log(\"The transfer is complete.\"); } function transferFailed(evt) { console.log(\"An error occurred while transferring the file.\"); } function transferCanceled(evt) { console.log(\"The transfer has been canceled by the user.\"); } We add event listeners for the various events that are sent while performing a data transfer using . Note: You need to add the event listeners before calling on the request. Otherwise the events will not fire. The progress event handler, specified by the function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event's and fields. However, if the field is false, the total length is not known and will be zero. Progress events exist for both download and upload transfers. The download events are fired on the object itself, as shown in the above sample. The upload events are fired on the object, as shown below: Note: Progress events are not available for the protocol. Progress events come in for every chunk of data received, including the last chunk in cases in which the last packet is received and the connection closed before the progress event is fired. In this case, the progress event is automatically fired when the load event occurs for that packet. This lets you now reliably monitor progress by only watching the \"progress\" event. One can also detect all three load-ending conditions ( , , or ) using the event: req.addEventListener(\"loadend\", loadEnd); function loadEnd(e) { console.log( \"The transfer finished (although we don't know if it succeeded or not).\", ); } Note there is no way to be certain, from the information received by the event, as to which condition caused the operation to terminate; however, you can use this to handle tasks that need to be performed in all end-of-transfer scenarios.\n\nIf you conclude with an XMLHttpRequest receiving and , this means the request was not allowed to be performed. It was . A likely cause for this is when the origin (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently . This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in other words, ) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's event which is set once the terminated window has its event triggered."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nNote: This feature is available in Web Workers, except for Service Workers. (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. Despite its name, can be used to retrieve any type of data, not just XML. If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the interface. For full-duplex communication, WebSockets may be a better choice.\n\nAborts the request if it has already been sent. Returns all the response headers, separated by CRLF, as a string, or if no response has been received. Returns the string containing the text of the specified header, or if either the response has not yet been received or the header doesn't exist in the response. Overrides the MIME type returned by the server. Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. Indicates that you want the request's response to be able to register an attribution source or trigger event. Sets the value of an HTTP request header. You must call after , but before ."
    },
    {
        "link": "https://javascript.info/xmlhttprequest",
        "document": "is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there’s another, more modern method , that somewhat deprecates .\n\nIn modern web-development is used for three reasons:\n• Historical reasons: we need to support existing scripts with .\n• We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).\n• We need something that can’t do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with . Otherwise, please head on to Fetch.\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet’s see the asynchronous first, as it’s used in the majority of cases.\n\nTo do the request, we need 3 steps:\n• The constructor has no arguments.\n• Initialize it, usually right after : This method specifies the main parameters of the request:\n• – the URL to request, a string, can be URL object.\n• – if explicitly set to , then the request is synchronous, we’ll cover that a bit later.\n• , – login and password for basic HTTP auth (if required). Please note that call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of .\n• This method opens the connection and sends the request to server. The optional parameter contains the request body. Some request methods like do not have a body. And some of them like use to send the data to the server. We’ll see examples of that later.\n• These three events are the most widely used:\n• – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.\n• – when the request couldn’t be made, e.g. network down or invalid URL.\n• – triggers periodically while the response is being downloaded, reports how much has been downloaded. xhr.onload = function() { alert(`Loaded: ${xhr.status} ${xhr.response}`); }; xhr.onerror = function() { // only triggers if the request couldn't be made at all alert(`Network Error`); }; xhr.onprogress = function(event) { // triggers periodically // event.loaded - how many bytes downloaded // event.lengthComputable = true if the server sent Content-Length header // event.total - total number of bytes (if lengthComputable) alert(`Received ${event.loaded} of ${event.total}`); };\n\nHere’s a full example. The code below loads the URL at from the server and prints the progress:\n\nOnce the server has responded, we can receive the result in the following properties:\n\nWe can also specify a timeout using the corresponding property:\n\nIf the request does not succeed within the given time, it gets canceled and event triggers.\n\nWe can use property to set the response format:\n• – get as (for binary data, see chapter ArrayBuffer, binary arrays),\n• – get as (for binary data, see chapter Blob),\n• – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\nFor example, let’s get the response as JSON:\n\nchanges between states as it progresses. The current state is accessible as .\n\nAll states, as in the specification:\n\nAn object travels them in the order → → → → … → → . State repeats every time a data packet is received over the network.\n\nWe can track them using event:\n\nYou can find listeners in really old code, it’s there for historical reasons, as there was a time when there were no and other events. Nowadays, handlers deprecate it.\n\nWe can terminate the request at any time. The call to does that:\n\nThat triggers event, and becomes .\n\nIf in the method the third parameter is set to , the request is made synchronously.\n\nIn other words, JavaScript execution pauses at and resumes when the response is received. Somewhat like or commands.\n\nHere’s the rewritten example, the 3rd parameter of is :\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nMany advanced capabilities of , like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.\n\nallows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\nTo make a POST request, we can use the built-in FormData object.\n\nWe create it, optionally fill from a form, more fields if needed, and then:\n• to submit the form to the server.\n\nThe form is sent with encoding.\n\nOr, if we like JSON more, then and send as a string.\n\nJust don’t forget to set the header , many server-side frameworks automatically decode JSON with it:\n\nThe method is pretty omnivore. It can send almost any , including and objects.\n\nThe event triggers only on the downloading stage.\n\nThat is: if we something, first uploads our data (the request body), then downloads the response.\n\nIf we’re uploading something big, then we’re surely more interested in tracking the upload progress. But doesn’t help here.\n\nThere’s another object, without methods, exclusively to track upload events: .\n\nIt generates events, similar to , but triggers them solely on uploading:\n• – upload timed out (if property is set).\n• – upload finished with either success or error.\n\ncan make cross-origin requests, using the same CORS policy as fetch.\n\nJust like , it doesn’t send cookies and HTTP-authorization to another origin by default. To enable them, set to :\n\nSee the chapter Fetch: Cross-Origin Requests for details about cross-origin headers.\n\nTypical code of the GET-request with :\n\nThere are actually more events, the modern specification lists them (in the lifecycle order):\n• – a data packet of the response has arrived, the whole response body at the moment is in .\n• – the request was canceled by the call .\n• – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.\n• – the request was canceled due to timeout (only happens if it was set).\n\nThe , , , and events are mutually exclusive. Only one of them may happen.\n\nThe most used events are load completion ( ), load failure ( ), or we can use a single handler and check the properties of the request object to see what happened.\n\nWe’ve already seen another event: . Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on object."
    },
    {
        "link": "https://apidog.com/blog/xmlhttprequest-post",
        "document": "In the world of modern web development, asynchronous data exchange between the client and server is a crucial aspect of building dynamic and responsive applications. One of the fundamental tools that enable this functionality is the XMLHttpRequest object, specifically its POST method. While the XMLHttpRequest API may seem dated in the era of more modern APIs like Fetch and Axios, understanding its core principles is still essential for any JavaScript developer.\n\nThe XMLHttpRequest POST method allows you to send data asynchronously to a server without refreshing the entire web page. This approach enhances the user experience by providing a smoother and more efficient flow of information, ultimately leading to a better overall application performance.\n\n\n\nBefore diving into the code, let's review the basic setup process for an XMLHttpRequest POST request:\n• Define the request method (POST) and the URL endpoint.\n• Set up the request headers, if necessary.\n• Define the function to handle the server response.\n• Send the request with the data payload.\n\nIn the example above, we create a new XMLHttpRequest instance, define the POST method and the URL endpoint, set the appropriate request headers, and handle the server response in the event handler. Finally, we send the request with the data payload in JSON format using the method.\n\n\n\nWhile sending the request is crucial, properly handling the server response is equally important. The event handler allows you to monitor the progression of the request and take appropriate actions based on the and properties.\n\nIn the example above, we check the to ensure the request has completed ( ), and then examine the property to determine the success or failure of the request. A status code of 200 typically indicates a successful response, while other status codes may indicate various error conditions.\n\n\n\nWhile the previous examples focused on sending JSON data, XMLHttpRequest also allows you to send form data seamlessly. This is particularly useful when working with traditional HTML forms or when dealing with file uploads.\n\nIn this example, we create a instance and append the form fields using the method. We can even include file uploads by appending the object from an element. Finally, we send the object directly using the method.\n\nApidog is an all-in-one collaborative API development platform that provides a comprehensive toolkit for designing, debugging, testing, publishing, and mocking APIs. Apidog enables you to automatically create XMLHttpRequest code for making HTTP requests.\n\nHere's the process for using Apidog to generate XMLHttpRequest code:\n\nStep 2: Enter the URL of the API endpoint you want to send a request to,input any headers or query string parameters you wish to include with the request, then click on the \"Design\" to switch to the design interface of Apidog.\n\nStep 4: Copy the generated code and paste it into your project.\n\nApidog offers several advanced features that further enhance its ability to test HTTP requests. These features allow you to customize your requests and handle more complex scenarios effortlessly.\n\nStep 2: Find or manually input the API details for the POST request you want to make.\n\nStep 3: Fill in the required parameters and any data you want to include in the request body.\n\nAs you can see, XMLHttpRequest POST is more than just a technical tool – it's a game-changer that opens up a world of possibilities for web developers. Whether you're building dynamic user interfaces, integrating with powerful APIs, or creating the next generation of immersive web experiences, XMLHttpRequest POST is your secret weapon."
    },
    {
        "link": "https://stackoverflow.com/questions/18592679/xmlhttprequest-to-post-html-form",
        "document": "I have an HTML form like so.\n\nI may have many of these forms on a page.\n\nHow do I submit this form asynchronously and not get redirected or refresh the page? I know how to use . The issue I have is retrieving the data from the HTML in javascript to then put into a post request string. Here is the method I'm currently using for my zXMLHttpRequest`'s.\n\nSo for example, say the javascript method was called when the form's submit button was clicked, how do I access the form's values from this method to then add it to the ?\n\nTrying to implement a solution from an answer below I have modified my form like so.\n\nHowever, on clicking the button, it's still trying to redirect me (to where I'm unsure) and my method isn't called?"
    },
    {
        "link": "https://stackoverflow.com/questions/48969495/in-javascript-how-do-i-should-i-use-async-await-with-xmlhttprequest",
        "document": "Full disclosure: I'd qualify myself as having intermediate JavaScript knowledge. So this is slightly above my experience level at this time.\n\nI've got a Google Chrome Extension that does an AJAX request for a local as soon as a page loads. After I get the response back from the request I use the returned code in several functions later on in my code. Most of the time I get the response back before my code that needs it runs. But sometimes I don't and everything breaks.\n\nNow, I assume I could just throw all of the relevant code inside of the below. But that seems really inefficient? I have a lot of moving parts that rely on the response and it seems bad to put them all in there.\n\nI've perused several articles related to async/await and I'm having trouble grasping the concept. I'm also not 100% positive I'm looking at this the right way. Should I even be considering using async/await?\n\nHere is the code for my AJAX request.\n\nLet's say I've got a bunch of functions that need to fire afterwards later on in my code. Right now they just look like:\n\nWhat's the best way to approach this? FYI, the API isn't an option.\n\nHere's a high level view of how my code is structured."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nIn this guide, we'll take a look at how to use to issue HTTP requests in order to exchange data between the website and a server. Examples of both common and more obscure use cases for are included. After the transaction completes, the object will contain useful information such as the response body and the HTTP status of the result.\n\nA request made via can fetch the data in one of two ways, asynchronously or synchronously. The type of request is dictated by the optional argument (the third argument) that is set on the method. If this argument is or not specified, the is processed asynchronously, otherwise the process is handled synchronously. A detailed discussion and demonstrations of these two types of requests can be found on the synchronous and asynchronous requests page. You can't use synchronous requests outside web workers as it freezes the main interface. Note: The constructor isn't limited to only XML documents. It starts with \"XML\" because when it was created the main format that was originally used for asynchronous data exchange was XML.\n\nAlthough is most commonly used to send and receive textual data, it can be used to send and receive binary content. There are several well tested methods for coercing the response of an into sending binary data. These involve utilizing the method on the object and is a workable solution. However, more modern techniques are available, since the attribute now supports a number of additional content types, which makes sending and receiving binary data much easier. For example, consider this snippet, which uses the of to fetch the remote content into a object, which stores the raw binary data. For more examples check out the Sending and Receiving Binary Data page.\n\nprovides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth. Support for DOM event monitoring of transfers follows the specification for progress events: these events implement the interface. The actual events you can monitor to determine the state of an ongoing transfer are: The amount of data that has been retrieved has changed. The transfer is complete; all data is now in the const req = new XMLHttpRequest(); req.addEventListener(\"progress\", updateProgress); req.addEventListener(\"load\", transferComplete); req.addEventListener(\"error\", transferFailed); req.addEventListener(\"abort\", transferCanceled); req.open(); // … // progress on transfers from the server to the client (downloads) function updateProgress(event) { if (event.lengthComputable) { const percentComplete = (event.loaded / event.total) * 100; // … } else { // Unable to compute progress information since the total size is unknown } } function transferComplete(evt) { console.log(\"The transfer is complete.\"); } function transferFailed(evt) { console.log(\"An error occurred while transferring the file.\"); } function transferCanceled(evt) { console.log(\"The transfer has been canceled by the user.\"); } We add event listeners for the various events that are sent while performing a data transfer using . Note: You need to add the event listeners before calling on the request. Otherwise the events will not fire. The progress event handler, specified by the function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event's and fields. However, if the field is false, the total length is not known and will be zero. Progress events exist for both download and upload transfers. The download events are fired on the object itself, as shown in the above sample. The upload events are fired on the object, as shown below: Note: Progress events are not available for the protocol. Progress events come in for every chunk of data received, including the last chunk in cases in which the last packet is received and the connection closed before the progress event is fired. In this case, the progress event is automatically fired when the load event occurs for that packet. This lets you now reliably monitor progress by only watching the \"progress\" event. One can also detect all three load-ending conditions ( , , or ) using the event: req.addEventListener(\"loadend\", loadEnd); function loadEnd(e) { console.log( \"The transfer finished (although we don't know if it succeeded or not).\", ); } Note there is no way to be certain, from the information received by the event, as to which condition caused the operation to terminate; however, you can use this to handle tasks that need to be performed in all end-of-transfer scenarios.\n\nIf you conclude with an XMLHttpRequest receiving and , this means the request was not allowed to be performed. It was . A likely cause for this is when the origin (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently . This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in other words, ) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's event which is set once the terminated window has its event triggered."
    },
    {
        "link": "https://javascript.info/xmlhttprequest",
        "document": "is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there’s another, more modern method , that somewhat deprecates .\n\nIn modern web-development is used for three reasons:\n• Historical reasons: we need to support existing scripts with .\n• We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).\n• We need something that can’t do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with . Otherwise, please head on to Fetch.\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet’s see the asynchronous first, as it’s used in the majority of cases.\n\nTo do the request, we need 3 steps:\n• The constructor has no arguments.\n• Initialize it, usually right after : This method specifies the main parameters of the request:\n• – the URL to request, a string, can be URL object.\n• – if explicitly set to , then the request is synchronous, we’ll cover that a bit later.\n• , – login and password for basic HTTP auth (if required). Please note that call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of .\n• This method opens the connection and sends the request to server. The optional parameter contains the request body. Some request methods like do not have a body. And some of them like use to send the data to the server. We’ll see examples of that later.\n• These three events are the most widely used:\n• – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.\n• – when the request couldn’t be made, e.g. network down or invalid URL.\n• – triggers periodically while the response is being downloaded, reports how much has been downloaded. xhr.onload = function() { alert(`Loaded: ${xhr.status} ${xhr.response}`); }; xhr.onerror = function() { // only triggers if the request couldn't be made at all alert(`Network Error`); }; xhr.onprogress = function(event) { // triggers periodically // event.loaded - how many bytes downloaded // event.lengthComputable = true if the server sent Content-Length header // event.total - total number of bytes (if lengthComputable) alert(`Received ${event.loaded} of ${event.total}`); };\n\nHere’s a full example. The code below loads the URL at from the server and prints the progress:\n\nOnce the server has responded, we can receive the result in the following properties:\n\nWe can also specify a timeout using the corresponding property:\n\nIf the request does not succeed within the given time, it gets canceled and event triggers.\n\nWe can use property to set the response format:\n• – get as (for binary data, see chapter ArrayBuffer, binary arrays),\n• – get as (for binary data, see chapter Blob),\n• – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\nFor example, let’s get the response as JSON:\n\nchanges between states as it progresses. The current state is accessible as .\n\nAll states, as in the specification:\n\nAn object travels them in the order → → → → … → → . State repeats every time a data packet is received over the network.\n\nWe can track them using event:\n\nYou can find listeners in really old code, it’s there for historical reasons, as there was a time when there were no and other events. Nowadays, handlers deprecate it.\n\nWe can terminate the request at any time. The call to does that:\n\nThat triggers event, and becomes .\n\nIf in the method the third parameter is set to , the request is made synchronously.\n\nIn other words, JavaScript execution pauses at and resumes when the response is received. Somewhat like or commands.\n\nHere’s the rewritten example, the 3rd parameter of is :\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nMany advanced capabilities of , like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.\n\nallows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\nTo make a POST request, we can use the built-in FormData object.\n\nWe create it, optionally fill from a form, more fields if needed, and then:\n• to submit the form to the server.\n\nThe form is sent with encoding.\n\nOr, if we like JSON more, then and send as a string.\n\nJust don’t forget to set the header , many server-side frameworks automatically decode JSON with it:\n\nThe method is pretty omnivore. It can send almost any , including and objects.\n\nThe event triggers only on the downloading stage.\n\nThat is: if we something, first uploads our data (the request body), then downloads the response.\n\nIf we’re uploading something big, then we’re surely more interested in tracking the upload progress. But doesn’t help here.\n\nThere’s another object, without methods, exclusively to track upload events: .\n\nIt generates events, similar to , but triggers them solely on uploading:\n• – upload timed out (if property is set).\n• – upload finished with either success or error.\n\ncan make cross-origin requests, using the same CORS policy as fetch.\n\nJust like , it doesn’t send cookies and HTTP-authorization to another origin by default. To enable them, set to :\n\nSee the chapter Fetch: Cross-Origin Requests for details about cross-origin headers.\n\nTypical code of the GET-request with :\n\nThere are actually more events, the modern specification lists them (in the lifecycle order):\n• – a data packet of the response has arrived, the whole response body at the moment is in .\n• – the request was canceled by the call .\n• – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.\n• – the request was canceled due to timeout (only happens if it was set).\n\nThe , , , and events are mutually exclusive. Only one of them may happen.\n\nThe most used events are load completion ( ), load failure ( ), or we can use a single handler and check the properties of the request object to see what happened.\n\nWe’ve already seen another event: . Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on object."
    },
    {
        "link": "https://stackoverflow.com/questions/33921118/what-is-best-practice-for-asynchronous-javascript-error-handling",
        "document": "Best practice is to use to and ES7 with ES6 , instead of callbacks.\n\nOtherwise 1st option is more common IMO."
    },
    {
        "link": "https://medium.com/@chandantechie/10-best-practices-for-writing-asynchronous-javascript-like-a-pro-2cb3a14587ba",
        "document": "Here are 10 best practices for writing asynchronous JavaScript along with explanations and coding examples:\n• Problem: Traditional callbacks can lead to “callback hell,” making code difficult to read and maintain.\n• Promises: Provide a cleaner way to handle asynchronous operations with .then() and .catch() methods.\n• Async/Await: Syntactic sugar on top of Promises, offering a more synchronous-like feel.\n• Problem: The older XMLHttpRequest (XHR) API is more verbose.\n• Solution: Use the fetch API, providing a more concise and Promise-based approach.\n• Solution: Use .catch() with Promises or try…catch with async/await to manage errors.\n\n4. Consider Using Async Iterators for Stream Processing:\n• Problem: Large data sets might overwhelm the browser if processed at once.\n• Solution: Employ async iterators (like those returned by response.body.getReader()) to handle data in chunks.\n• Problem: Long-running operations might become obsolete if the user navigates away.\n• Solution: Utilize the AbortController API to create a signal for cancellation.\n• Solution: Debounce: Delay an operation until a certain amount of time has passed since the last event.\n• Problem: Complex logic with multiple asynchronous operations can become challenging to manage.\n• Solution: Generators (functions with yield) can be used to pause and resume execution, making code more readable.\n• Problem: You might want to perform multiple asynchronous operations concurrently.\n• Solution: While async/await is sequential by nature, use Promise.all() or async.parallel (from external libraries) to run operations in parallel.\n• Solution: Observables (e.g., from RxJS) provide a powerful way to handle data streams with operators for transformation and manipulation.\n• Problem: Asynchronous code can be tricky to test due to its non-blocking nature.\n• Solution: Utilize libraries like Jest or Mocha with mocking capabilities to test different scenarios, including error handling and edge cases.\n\nBy following these best practices, you’ll be well on your way to writing clean, maintainable, and efficient asynchronous JavaScript code!"
    }
]