[
    {
        "link": "https://python-binance.readthedocs.io/en/latest/binance.html",
        "document": ""
    },
    {
        "link": "https://github.com/sammchardy/python-binance/issues/533",
        "document": "Just wondering if there is a plan to implement this feature from the binance-official-api:\n\n Cancel All Open Orders on a Symbol (TRADE) - Cancels all active orders on a symbol. This includes OCO orders.\n\nThis would be a really useful feature and save working with Order ID's. Thanks for your hard work."
    },
    {
        "link": "https://python-binance.readthedocs.io/en/latest/account.html",
        "document": "Binance has a number of rules around symbol pair orders with validation on minimum price, quantity and total order value.\n\nRead more about their specifics in the Filters section of the official API.\n\nRead Understanding Binance Order Filters for more information about price and quantity filters on Binance.\n\nIt can be helpful to format the output using formatting\n\nOr if you have the tickSize or stepSize then use the helper to round to step size"
    },
    {
        "link": "https://medium.lucit.tech/create-and-cancel-orders-via-websocket-on-binance-7f828831404",
        "document": "In Python, LUCIT¬¥s UNICORN Binance WebSocket API already supports the new features to send API requests to Binance via websocket and I will show you how to use it. To do this, we will go through the following steps:\n‚Ä¢ Send requests and handle the responses\n\n- Global async function\n\n- Global callback function\n\n- Stream specific async function\n\n- Stream specific callback function\n\n- Request specific callback function\n\n- Save answer in variable\n\n- Using the `stream_buffer`\n\n- Multiple API Streams\n\nTo be able to trade on Binance you need a user account. If you don‚Äôt have one yet, you can sign up via my referral link. With this we both get 100 USDT cashback vouchers for a 50 USD deposit.\n\nHow to create an API Key/Secret pair you can read in detail here.\n\nYou need a UNICORN Binance Suite license, which you can get in the LUCIT Online Shop. Please also read this article for relevant background on the UBS license.\n\nMinimum requirement is a working Python 3.7+ installation. To use the UNICORN Binance WebSocket API in your Python script, you need to install it on the command line using one of the two commands:\n\nThis is the default way and should always work. It contains the plain source code and optimized Cython and PyPy Wheels:\n\n$ pip install unicorn-binance-websocket-api\n\nThis is only possible within an Anaconda environment.\n\n$ conda install -c conda-forge unicorn-binance-websocket-api\n\nFirst we import `unicorn_binance_websocket_api`, define the callback function ‚Äòhandle_socket_message()` to print the received data and then store an instance of ‚ÄòBinanceWebSocketApiManager()‚Äô in the variable ‚Äòubwa‚Äô.\n\nIf you want to connect ‚ÄòBinanceWebSocketApiManager()‚Äô to the testnet, you need to pass the string ‚Äòbinance.com-testnet‚Äò to the `exchange` parameter.\n\nWith `process_stream_data=handle_socket_message` we pass ‚ÄòBinanceWebSocketApiManager()‚Äô a global callback function, to this function all received responses of the API are passed by default.\n\nBy default, all API requests return a string with a JSON structure. To automatically convert the JSON structure to a Python dictionary, we configure `output_default=‚Äùdict‚Äù`.\n\nNext we create the API stream, for this it is important to set the parameter `api` to `True`, otherwise a connection to another websocket endpoint would be established, where the API requests would not work. Please make sure that you use a valid API key/secret pair and consider the IP whitelist restrictions when testing!\n\nNow all the prerequisites are met for us to send and process requests to the Binance API.\n\nUsing the `ubwa.api` object we can now send requests to the Binance API, e.g. a connection test with the `ubwa.api.spot.ping()` method.\n\nThere are several ways to handle the API requests:\n\nWhen receiving the response from Binance, the function `handle_socket_message()` is executed which we passed when initiating ‚ÄòBinanceWebSocketApiManager()‚Äô, and this is where you can hook your code.\n\nIn our example, we simply output the received data:\n\nI will use the example with `ubwa.api.spot.ping()` to introduce the other methods how you can receive and process the received data.\n\nWhen receiving the response from Binance, the function `handle_socket_message()` is executed which we passed when initiating ‚ÄòBinanceWebSocketApiManager()‚Äô, and this is where you can hook your code.\n\nIn our example, we simply output the received data:\n\nIt is possible to pass a callback function to `ubwa.create_stream()` as well. Then, for receiving responses from this stream, the stream specific callback function is used instead of the global callback function we passed to ‚ÄòBinanceWebSocketApiManager()‚Äô.\n\nNow we can run ping again and this time we would use the callback function `handle_stream_message()` instaed of `handle_socket_message()`.\n\nSince not all types of data are treated the same way, there is also the possibility to process responses of a specific request with a specific callback function.\n\nThere is also the possibility to let the called function wait until the response to the request has arrived and then store it directly into a variable. The disadvantage of this method is that the function becomes blocking, whereby several requests can only be processed sequentially.\n\nA completely different approach than the callback functions is the `stream_buffer`. This is the standard way of ‚ÄòBinanceWebSocketApiManager()‚Äô to process received data, here all received data is stored in a `deque()` stack and can be used as FIFO as well as LIFO stack to read the received data in a loop.\n\nThe main advantage of this solution is the desynchronization between receiving and processing the new data.\n\nWhat does this mean? UBWA receives the new data in an AsyncIO event loop and processes them asynchronously. This means that the data is not received and processed sequentially, but that the callback functions within the event loop are started in parallel for each data record received, which can easily push your system to its limits during peak load times, e.g. if you receive more data faster than you can store in your database over a longer period for speed reasons.\n\nBecause each received record is simply stored in the `stream_buffer`, the processing is immediately finished for UBWA. You can easily access the new data in the `stream_buffer` in another thread or better another process and adjust the processing time to your circumstances. Additionally the `stream_buffer` can be monitored by you and offers further options.\n\nAs already mentioned the `stream_buffer` is the standard method of UBWA and is simply overwritten by setting the callback functions. So if you want to use it, do not pass a callback function in the class initialization of ‚ÄòBinanceWebSocketApiManager()‚Äô or anywhere else.\n\nOne way to use callback functions everywhere and still use the `stream_buffer` in a special situation is to explicitly pass `ubwa.add_to_stream_buffer` as callback function.\n\nOf course it is also possible to use different `stream_buffer`, how to do that is described in the wiki.\n\nI now choose a simple example with only one global `stream_buffer`. If you have now simply omitted passing the callback functions, the global `stream_buffer` is activated by default and your stream will write its data there.\n\nHereby you get access to the oldest record in the stack:\n\nFor example, if you have problems with your database, you can catch the exception of the database connection in a `try` block and use `ubwa.add_to_stream_buffer()` in the `except` block to save the record back into the `stream_buffer` and simply retrieve it later. Unfortunately, this messes up the chronological sorting! ü§®\n\nIf there is more than one API stream (with `api=True`), the methods must be told which stream to use. The `stream_id` is used to uniquely identify the streams and is returned by `ubwa.create_stream()`, alternatively you can also work with a `stream_label`. For this to work, a `stream_label` must also be defined when creating the stream with `ubwa.create_stream()`.\n\nEach API request has its own list of accepted and mandatory parameters, gives different responses, and is subject to different request limits. To understand what is happening in the background, it is always advisable to also study the official documentation of Unicorn Binance WebSocket API and the Binance Websocket API. Therefore, for each function I have added a link to the corresponding places.\n\nIf you cancel an order that is a part of an OCO pair, the entire OCO is canceled.\n\nIf you cancel an order that is a part of an OCO pair, the entire OCO is canceled.\n\n`ubwa.api.spot.create_order()` automatically creates a `client_order_id` and returns it. This way you can always uniquely identify the order in further steps.\n\nThere are many other functions to send requests to the Binance API.\n\nIf you find bugs or have suggestions for improving the API implementation, you can open an issue via GitHub.\n\nFor more information please read the documentation for unicorn-binance-websocket-api."
    },
    {
        "link": "https://docs.binance.us",
        "document": "Welcome to the Binance.US API Documentation!\n‚Ä¢ Do not disclose your API Key to anyone to avoid asset losses. It is recommended to bind IP for API Key to increase your account security.\n‚Ä¢ Be aware that your API Key may be disclosed by authorizing it to a third-party platform.\n‚Ä¢ You will not be able to create an API if KYC is not completed.\n‚Ä¢ Learn more about API key best practices and safety tips.\n\nBinance.US currently offers three API key types: Exchange API Keys, Custodial Solution API Keys, and Credit Line API Keys. Please read on for more information on the differences and instructions on how to set up your key type.\n‚Ä¢ Private API keys for the majority of API users to interact with Binance.US API endpoints.\n‚Ä¢ Provides access to markets and real-time trading services on Binance.US via a third-party site or application.\n‚Ä¢ None Log into Binance.US with your account details\n‚Ä¢ None Enter a name for your API key for reference.\n‚Ä¢ None Click ‚ÄòCreate.‚Äô Enter your 2FA code to confirm when prompted\n‚Ä¢ Private API keys only available to users who have entered into a Custody Exchange Network agreement between a participating custody partner and Binance.US.\n‚Ä¢ Provides access to Custodial Solution related API endpoints only. To access other types of API endpoints, please generate other corresponding API keys.\n\nAfter entering into a Custody Exchange Network agreement between a participating custody partner and Binance.US, users can create a Custodial Solution API key:\n‚Ä¢ None Log into Binance.US with your account details\n‚Ä¢ None Select ‚ÄòCustodial Solution API‚Äô‚Äô and give your API key a label for reference\n‚Ä¢ None Click ‚ÄòCreate.‚Äô Enter your 2FA code to confirm when prompted\n‚Ä¢ Private API keys only available to institutional users who have signed a credit line agreement with Binance.US.\n‚Ä¢ Provides access to Credit Line related API endpoints only. To access other types of API endpoints, please generate other corresponding API keys.\n\nAfter signing a credit line agreement with Binance.US, users can create a Credit Line API key:\n‚Ä¢ None Log into Binance.US with your account details\n‚Ä¢ None Select ‚ÄòCredit Line API‚Äô and give your API key a label for reference\n‚Ä¢ None Click ‚ÄòCreate.‚Äô Enter your 2FA code to confirm when prompted\n‚Ä¢ Each endpoint has a security type that determines how you will interact with it. This is stated next to the NAME of the endpoint.\n‚Ä¢ If no security type is stated, assume the security type is NONE.\n‚Ä¢ API-keys are passed into the REST API via the header.\n‚Ä¢ API-keys can be configured to only access certain types of secure endpoints. For example, one API-key could be used for TRADE only, while another API-key can access everything except for TRADE routes.\n‚Ä¢ By default, API keys can access all secure routes.\n‚Ä¢ A endpoint also requires a parameter and to be sent, which should be the millisecond timestamp of when the request was created and sent.\n‚Ä¢ An additional parameter, , may be sent to specify the number of milliseconds after the that the request is valid for. If is not sent, it defaults to 5,000.\n‚Ä¢ The exact timing authentication logic can be viewed in the code sample on the right panel (or below on a mobile device).\n\nSerious trading is about timing. Networks can be unstable and unreliable, which can lead to requests taking varying amounts of time to reach the servers. With , you can specify that the request must be processed within a certain number of milliseconds or be rejected by the server.\n‚Ä¢ endpoints require an additional parameter: , to be sent in the or .\n‚Ä¢ Endpoints use signatures. The is a keyed operation. Use your as the key and as the value for the HMAC operation.\n‚Ä¢ The is not case sensitive.\n‚Ä¢ is defined as the concatenated with the .\n\nHere is a step-by-step example of how to send a valid signed payload from the Linux command line using , , and .\n\nErrors consist of two parts: an error code and a message. Codes are universal, but messages can vary. Here is the error JSON payload:\n‚Ä¢ HTTP return codes are used for malformed requests; the issue is on the sender's side.\n‚Ä¢ HTTP return code is used when the WAF (Web Application Firewall) Limit has been violated.\n‚Ä¢ HTTP return code is used when a cancelReplace order partially succeeds. (i.e. if the cancellation of the order fails but the new order placement succeeds.)\n‚Ä¢ HTTP return code is used when breaking a request rate limit.\n‚Ä¢ HTTP return code is used when an IP has been auto-banned for continuing to send requests after receiving codes.\n‚Ä¢ HTTP return codes are used for internal errors; the issue is on Binance's side. It is important to NOT treat this as a failure operation; the execution status is UNKNOWN and could have been a success.\n‚Ä¢ An unknown error occurred while processing the request.\n‚Ä¢ Internal error; unable to process your request. Please try again.\n‚Ä¢ You are not authorized to execute this request.\n‚Ä¢ Too much request weight used; current limit is %s request weight per %s. Please use WebSocket Streams for live updates to avoid polling the API.\n‚Ä¢ Way too much request weight used; IP banned until %s. Please use WebSocket Streams for live updates to avoid bans.\n‚Ä¢ An unexpected response was received from the message bus. Execution status is unknown.\n‚Ä¢ Timeout waiting for a response from the backend server. Send status unknown; execution status unknown.\n‚Ä¢ Spot server is currently overloaded with other requests. Please try again in a few minutes.\n‚Ä¢ Too many new orders.\n‚Ä¢ Too many new orders; current limit is %s orders per %s.\n‚Ä¢ This service is no longer available.\n‚Ä¢ This operation is not supported.\n‚Ä¢ Timestamp for this request is outside of the recvWindow.\n‚Ä¢ Timestamp for this request was 1000ms ahead of the server's time.\n‚Ä¢ Signature for this request is not valid.\n‚Ä¢ Illegal characters found in parameter '%s'; the legal range is '%s'.\n‚Ä¢ Too many parameters sent for this endpoint.\n‚Ä¢ Too many parameters; expected '%s' and received '%s'.\n‚Ä¢ A mandatory parameter was not sent, was empty/null, or was malformed.\n‚Ä¢ Mandatory parameter '%s' was not sent, was empty/null, or was malformed.\n‚Ä¢ Param '%s' or '%s' must be sent, but both were empty/null.\n‚Ä¢ An unknown parameter was sent.\n‚Ä¢ Not all sent parameters were read.\n‚Ä¢ Not all sent parameters were read; read '%s' parameter(s) but was sent '%s'.\n‚Ä¢ A parameter was sent when not required.\n‚Ä¢ Parameter '%s' sent when not required.\n‚Ä¢ Precision is over the maximum defined for this asset.\n‚Ä¢ No orders on the book for this symbol.\n‚Ä¢ TimeInForce parameter sent when not required.\n‚Ä¢ This listenKey does not exist.\n‚Ä¢ More than %s hours between startTime and endTime.\n‚Ä¢ Data sent for p arameter '%s' is not valid.\n‚Ä¢ JSON sent for parameter '%s' is not valid\n‚Ä¢ has to be either or .\n‚Ä¢ No trading window could be found for the symbol. Try ticker/24hrs instead.\n‚Ä¢ This code is sent when either the cancellation of the order failed or the new order placement failed but not both.\n‚Ä¢ This code is sent when both the cancellation of the order failed and the new order placement failed.\n‚Ä¢ Order was canceled or expired with no executed qty over 90 days ago and has been archived.\n\nThis code is sent when an error has been returned by the matching engine. The following messages will indicate the specific error:\n‚Ä¢ Spot WebSocket APIs are now available for Binance US.\n‚Ä¢ WebSocket API allows placing orders, canceling orders, etc. through a WebSocket connection.\n‚Ä¢ WebSocket API is a separate service from WebSocket Market Data streams. i.e., placing orders and listening to market data requires two separate WebSocket connections.\n‚Ä¢ WebSocket API is subject to the same Filter and Rate Limit rules as REST API.\n‚Ä¢ WebSocket API and REST API are functionally equivalent: they provide the same features, accept the same parameters, return the same status and error codes.\n‚Ä¢ The full documentation can be found here.\n‚Ä¢ Trading parameters for 3 trading pairs have been updated. Click here to learn more.\n‚Ä¢ Improved error messages for certain issues for easier troubleshooting.\n‚Ä¢ Fixed error message for querying archived orders(status or where == 0 in the last 90 days):\n‚Ä¢ Now error message: \"msg\": \"Order was canceled or expired with no executed qty over 90 days ago and has been archived.\"\n‚Ä¢ None Behavior for API requests with and :\n‚Ä¢ Previously some requests failed if the == .\n‚Ä¢ Now, all API requests that accept and allow the parameters to be equal. This applies to the following requests:\n‚Ä¢ \n‚Ä¢ Previous behavior: Reverse market orders would have the status even if the order was not fully filled.\n‚Ä¢ New behavior: If the reverse market order did not fully fill due to low liquidity, the order status will be , and only if completely filled.\n‚Ä¢ Changes to and :\n‚Ä¢ New optional parameter that determines whether the cancel will succeed if the order status is or .\n‚Ä¢ If the order cancellation fails due to , error will be: \"msg\": \"Order was not canceled due to cancel restrictions.\"\n‚Ä¢ Added a new endpoint to get all orders\n\nTrading parameters for 153 trading pairs have been updated. Click here to learn more.\n‚Ä¢ New API Key Type (Credit Line): Added a new API Key type (Credit Line) and instructions for generating this key type in ‚ÄòGet API Keys.‚Äô\n\nThe changes to the system will take place on January 31, 2023.\n\n\n\nAdditional details on the functionality of STP is explained in the STP FAQ document.\n‚Ä¢ None Self-Trade Prevention (aka STP) has been added to the system. STP is a measure to prevent users from trading against their own account or other accounts that share the same (such as parent and sub-accounts which belong to the same entity). The default and allowed modes of STP are as follows, and can be confirmed using : \"defaultSelfTradePreventionMode\": \"EXPIRE_MAKER\", //If selfTradePreventionMode not provided, this will be the value passed to the engine \n\n \"allowedSelfTradePreventionModes\": [//What the allowed modes of\n‚Ä¢ None New order status: - This means that the order expired due to STP being triggered.\n‚Ä¢ \n‚Ä¢ - This queries the orders that expired due to STP being triggered.\n‚Ä¢ None New optional parameter has been added to the following endpoints:\n‚Ä¢ None New responses that will appear for all order placement endpoints if there was a prevented match (i.e. if an order could have matched with an order of the same account, or the accounts are in the same ):\n‚Ä¢ - This will only appear if account is configured to a and if there was a prevented match.\n‚Ä¢ - Only appears if there was a prevented match\n‚Ä¢ An array with the following fields:\n‚Ä¢ - This will only appear if set is or .\n‚Ä¢ - This will only appear if set is or .\n‚Ä¢ None New fields and that can appear in the order query endpoints if the order had expired due to STP :\n‚Ä¢ None New field will appear in the response.\n‚Ä¢ New fields for (These fields will only appear if the order has expired due to STP)\n‚Ä¢ ‚ÄôWithdraw Fiat (via SEN or SIGNET)‚Äô updated to support signet.\n‚Ä¢ ‚ÄôGet All OTC Trade Orders‚Äô and ‚ÄòGet All OCBS Trade Orders‚Äô parameters updated. 90-day limit removed from both.\n‚Ä¢ !bookTicker removed.\n‚Ä¢ Multiple streams can be subscribed to over one connection. (E.g. wss://stream.binance.us:9443/stream?streams=btcusdt@bookTicker/bnbbtc@bookTicker)\n‚Ä¢ New error code -1135 occurs if a parameter requiring a JSON object is invalid.\n‚Ä¢ New error code -1108 occurs if a value sent to a parameter is too large.\n‚Ä¢ Changes to GET /api/v3/aggTrades\n‚Ä¢ startTime and endTime can now be used individually and the 1-hour limit has been removed.\n‚Ä¢ Changes to GET /api/v3/myTrades\n‚Ä¢ Bug fixed: The combination of symbol + orderId no longer returns all trades beyond the 500 default limit.\n‚Ä¢ Sending an unsupported combination of optional parameters now responds with generic error: { ‚Äúcode‚Äù: -1128, ‚Äúmsg‚Äù: ‚ÄúCombination of optional parameters invalid.‚Äù }.\n‚Ä¢ defaultSelfTradePreventionMode and allowedSelfTradePreventionModes fields will appear in GET /api/v3/exchangeInfo\n‚Ä¢ selfTradePreventionMode field will appear in the response for several order endpoints.\n‚Ä¢ requireSelfTradePrevention field will appear in the response for GET /api/v3/account\n‚Ä¢ workingTime field indicating when the order started working on the order book, will appear in several order endpoints.\n‚Ä¢ trailingTime field will appear in order types: (TAKE_PROFIT, TAKE_PROFIT_LIMIT, STOP_LOSS, STOP_LOSS_LIMIT if trailingDelta parameter was provided), for several order endpoints.\n‚Ä¢ commissionRates field will appear in the GET /api/v3/acccount response.\n‚Ä¢ eventType executionReport has new fields:\n‚Ä¢ D - trailing_time (Appears if the trailing stop order is active)\n‚Ä¢ W - workingTime (Appears if the order is working on the order book)\n‚Ä¢ Staking Endpoints: Added four new staking-focused endpoints, including:\n‚Ä¢ Unstake Asset: Unstake an asset that is currently staking.\n‚Ä¢ Get Staking Asset Information: Information on staking asset(s) including reward asset received, APR, APY, unstaking period (hrs.), minimum and maximum staking amounts, and whether auto restaking is enabled.\n‚Ä¢ Get Staking History: History of staking transactions for an asset in a given time period, including transaction amount, type, and initiation time.\n‚Ä¢ Revised Error Messages: Updated several API error messages related to staking for increased clarity.\n‚Ä¢ New API Key Type (Custodial Solution): Added a new API Key type (Custodial Solution) and instructions for generating this key type in 'Get API Keys.'\n‚Ä¢ Added Custodial Solution API & Endpoints: Added 'Custodial Solution Endpoints' section for new Custodial Solution API. Contains four endpoint categories and 18 endpoints in total:\n‚Ä¢ Enabled trailing stop order: Updated three endpoints: POST /api/v3/order, POST /api/v3/order/test, POST /api/v3/order/oco, and added one new filter: TRAILING_DELTA, to support trailing stop orders. This type of stop order activates based on the percentage of a price change in the market using the new parameter: trailingDelta. This can be used with STOP_LOSS_LIMIT, or TAKE_PROFIT_LIMIT.\n‚Ä¢ Enabled replace order: Added one endpoint to cancel an existing order and place a new order with the same symbol.\n‚Ä¢ Scheduled changes: The All Book Tickers stream (!bookTicker) is set to be removed in late November 2022. Please use the Individual Book Ticker Streams instead. (<symbol>@bookTicker). Multiple <symbol>@bookTicker streams can be subscribed to over one connection. For example: wss://stream.binance.us:9443/stream?streams=btcusdt@bookTicker/bnbbtc@bookTicker\n‚Ä¢ Market Data: Added a new optional parameter type in two endpoints: GET /api/v3/ticker and GET /api/v3/ticker/24hr. Also removed Individual Symbol Ticker Streams as it duplicates with Ticker Order Book Stream, supported new candlestick chart interval: 1s.\n‚Ä¢ Get Asset Distribution History endpoint: Updated this endpoint to also query the rebate distribution record.\n‚Ä¢ Get Exchange Information endpoint: Added a service line permission parameter to display all symbols with the permission matching the value provided.\n‚Ä¢ User data endpoints: Added two endpoints to get trading fees and trading volume for the past 30 days.\n‚Ä¢ Convert dust to BNB endpoints: Added three endpoints to convert dust to BNB and query the conversion history and convertible assets.\n‚Ä¢ Staking endpoints: Added two endpoints to get staking balance and staking reward history.\n‚Ä¢ Market data endpoints: Added one endpoint to get price change data within a requested time window and updated four endpoints to support more parameter options.\n‚Ä¢ Market data streams: Added two ticker streams with 1h and 4h windows, individual symbol ticker streams, and all market ticker streams.\n‚Ä¢ Filters: Added three filters (percent price by side, notional, exchange maximum number iceberg orders) and updated the rules of price filters.\n‚Ä¢ Usability improvements: Fixed some language errors and improved the content.\n‚Ä¢ User data endpoints: Migrated seven endpoints from WAPI to SAPI to improve performance and added five endpoints for status query and crypto withdrawals.\n‚Ä¢ Wallet endpoints: Added two endpoints to get sub-account deposit addresses and history.\n‚Ä¢ OTC endpoints: Added one OTC endpoint for users to query all OTC order details.\n‚Ä¢ Referral endpoints: Added one referral endpoint for users to get referral rewards history.\n‚Ä¢ Usability improvements: Made several improvements to content and readability.\n‚Ä¢ Miscellaneous updates: Temporarily removed the Get User Maker/Taker Rates endpoint. The endpoint will return in a future update.\n‚Ä¢ Updated five wallet endpoints related to crypto withdrawals and deposits.\n‚Ä¢ Added new OTC trade endpoints which support larger buy and sell order quotes, placements, and queries, as well as crypto-to-crypto conversion (e.g. KSHIB/SHIB).\n\nHave questions about our APIs? Contact customer support here.\n\nAll endpoints return either a JSON object or array.\n\nData is returned in ascending order: oldest first, newest last.\n\nAll times for the fields of staking, referrals, airdrops, etc. are in milliseconds.\n‚Ä¢ For endpoints, parameters must be sent as a .\n‚Ä¢ For , , and endpoints, the parameters may be sent as a or in the with content type . You may mix parameters between both the and if you wish to do so.\n‚Ä¢ Parameters may be sent in any order.\n‚Ä¢ If a parameter is sent in both the and , the parameter will be used.\n‚Ä¢ The API system is asynchronous, so some delay in the response is normal.\n‚Ä¢ Each endpoint has a data source indicating where the data is being retrieved, and thus which endpoints have the most up-to-date response.\n\nThese are the three sources ordered from the most up-to-date response to the one with potential delays in updates:\n‚Ä¢ Matching Engine - the data is from the matching engine\n‚Ä¢ Memory - the data is from a server's local or external memory\n‚Ä¢ Database - the data is taken directly from a database\n\nSome endpoints can have more than one data source(e.g. Memory => Database). This means that the endpoint will check the first data source. If it cannot find the value it's looking for it will check the next one etc.\n\nThese terms will be used throughout the documentation, so it is recommended that you read them to enhance your understanding of the API (especially for new users).\n‚Ä¢ refers to the asset that is the of a symbol; for the symbol BTCUSDT, BTC would be the\n‚Ä¢ refers to the asset that is the of a symbol; for the symbol BTCUSDT, USDT would be the .\n‚Ä¢ The following are values for headers:\n‚Ä¢ The array contains objects related to the exchange's , , and rate limits. These are further defined in the section under .\n‚Ä¢ A 429 will be returned when either rate limit is violated.\n‚Ä¢ Each route has a that determines the number of requests each endpoint counts for. Heavier endpoints and endpoints that do operations on multiple symbols will have a heavier .\n‚Ä¢ REST API and WebSocket API are subject to the same Rate Limit rules.\n‚Ä¢ Every request will contain an header which has the currently used weight for the IP of all request rate limiters defined.\n‚Ä¢ Every successful order will contain an header which has the current order count for the IP of all order rate limiters defined. Rejected/unsuccessful orders are not guaranteed to have a header in the response.\n‚Ä¢ None When a 429 is received, it's your obligation as an API user/trader to back off and not spam the API.\n‚Ä¢ None Repeatedly violating rate limits and/or failing to back off after receiving 429s will result in an automated IP ban (HTTP status 418).\n‚Ä¢ None IP bans are tracked and scale in duration for repeat offenders, from 2 minutes to 3 days.\n‚Ä¢ None A header is sent with a 418 or 429 response and will give the number of seconds required to wait to prevent a ban (for a 418) or until the ban is over (for a 429).\n‚Ä¢ None The limits on the API are based on the IPs, not the API keys.\n‚Ä¢ Every successful order response will contain an header which has the current order count for the account for all order rate limiters defined.\n‚Ä¢ Rejected/unsuccessful orders are not guaranteed to have a header in the response.\n‚Ä¢ The order rate limit is counted against each account.\n\nUse this endpoint to test connectivity to the exchange.\n\nUse this endpoint to get the exchange‚Äôs server time.\n\nUse this endpoint to fetch whether the system status is normal or under maintenance.\n\nUse this endpoint to get the current exchange trading rules and trading pair information.\n\nThere are 4 possible options:\n‚Ä¢ If the value provided to or do not exist, the endpoint will throw an error saying the symbol is invalid.\n‚Ä¢ If parameter not provided, the default values will be .\n\nUse this endpoint to get the recent trades. Please note the maximum limit is 1,000 trades.\n\nUse this endpoint to get older trades. Please note the maximum limit is 1,000 trades.\n\nUse this endpoint to get compressed, aggregate trades. Trades that fill at the same time, from the same order, with the same price, will have the quantity aggregated. Please note the maximum limit is 1,000 trades.\n‚Ä¢ If fromId, startTime, and endTime are not sent, the most recent aggregate trades will be returned.\n\nUse this endpoint to get order book depth (prices and quantities of bids and asks).\n\nUse this endpoint to get Kline/candlestick bars for a token symbol. Klines are uniquely identified by their open time. Please note the maximum limit is 1,000 bars.\n‚Ä¢ If startTime and endTime are not sent, the most recent klines are returned.\n\nUse this endpoint to get the live ticker price.\n\nUse this endpoint to get the current average price for a symbol.\n\nUse this endpoint to get the best available order book price.\n\nUse this endpoint to get price change data for the past 24hrs.\n‚Ä¢ If the symbol is not sent, tickers for all symbols will be returned in an array.\n\nUse this endpoint to get the price change data within a requested window of time.\n\nNote: reverts to the start of the minute (e.g. 09:17:00 UTC, instead of 09:17:47:99). is the current time of the request (including seconds and milliseconds). Therefore, the effective window can be up to 59999ms (59 seconds) longer than the specified .\n\nE.g. If the is 1641287867099 (January 04, 2022 09:17:47:099 UTC), and the is 1d. the will be: 1641201420000 (January 3, 2022, 09:17:00 UTC).\n\n2 for each requested symbol regardless of .\n\nThe weight for this request will cap at 100 once the number of in the request is more than 50.\n\nUse this endpoint to get current account information.\n\nUse this endpoint to fetch account status details.\n\nUse this endpoint to fetch account API trading status details.\n\nUse this endpoint to query asset distribution records, including Market Maker Rebate, MM Streaks Rebate, API Partner Rebate and airdrop, etc.\n\nUse this endpoint to get your current maker & taker fee rates for spot trading based on your VIP level or manual fee adjustment. Discount for using BNB to pay fees (25% off) is not factored in.\n\nUse this endpoint to get total trade volume for the past 30 days, calculated on a rolling basis every day at 0:00 AM (UTC).\n\nUse this endpoint to get your sub-account list.\n\nUse this endpoint to fetch sub-account asset transfer history.\n\nUse this endpoint to execute an asset transfer between the master account and a sub-account.\n\nUse this endpoint to fetch sub-account assets.\n\nUse this endpoint to get the total value of assets in the master account in USD.\n\nUse this endpoint to get a status list of sub-accounts.\n\nGet the current trade order count rate limits for all time intervals.\n\nUse this endpoint to place a new trade order.\n‚Ä¢ Any or type order can be made an iceberg order by sending an .\n‚Ä¢ Any order with an MUST have set to .\n‚Ä¢ orders using will not break filter rules; the order will execute a with a notional value as close as possible to .\n\nTrigger order price rules against market price for both MARKET and LIMIT versions:\n\nUse this endpoint to test new order creation and signature/recvWindow long. The endpoint creates and validates a new order but does not send it into the matching engine.\n\nUse this endpoint to check a trade order's status.\n‚Ä¢ Either or must be sent.\n‚Ä¢ For some historical orders will be < 0, meaning the data is not available at this time.\n\nUse this endpoint to get all open trade orders for a token symbol. Do not access this without a token symbol as this would return all pair data.\n\nWeight: 3 for a single symbol; 40 when the symbol parameter is omitted\n‚Ä¢ If the symbol is not sent, orders for all symbols will be returned in an array.\n\nUse this endpoint to cancel an active trade order.\n\nEither or must be sent.\n‚Ä¢ None If the value is not any of the supported values, the error will be:\n‚Ä¢ None If the order did not pass the conditions for , the error will be: { \"code\": -2011, \"msg\": \"Order was not canceled due to cancel restrictions.\" }\n\nUse this endpoint to cancels all active trade orders on a token symbol (this includes OCO orders).\n\nUse this endpoint to get trade data for a specific account and token symbol.\n‚Ä¢ If is set, it will get orders >= than . Otherwise most recent orders are returned.\n‚Ä¢ The time between and can't be longer than 24 hours.\n‚Ä¢ These are the supported combinations of optional parameters:\n\nCancels an existing order and places a new order on the same symbol.\n\nFilters and Order Count are evaluated before the processing of the cancellation and order placement occurs.\n\nA new order that was not attempted (i.e. when ), will still increase the order count by 1.\n\nSimilar to POST , additional mandatory parameters are determined by type.\n\nResponse format varies depending on whether the processing of the message succeeded, partially succeeded, or failed.\n\nDisplays the list of orders that were expired because of STP. These are the combinations supported:\n\nGet all account orders: active, canceled, or filled.\n‚Ä¢ If is set, it will get orders >= that . Otherwise most recent orders are returned.\n‚Ä¢ For some historical orders will be < 0, meaning the data is not available at this time.\n‚Ä¢ If and/or provided, is not required.\n\nUse this endpoint to place a new OCO(one-cancels-the-other) order.\n‚Ä¢ Quantity Restrictions:\n‚Ä¢ Both legs must have the same quantity.\n‚Ä¢ quantities however do not have to be the same\n‚Ä¢ Order Rate Limit\n‚Ä¢ counts as 2 orders against the order rate limit.\n\nUse this endpoint to retrieve a specific OCO order based on provided optional parameters.\n\nUse this endpoint to retrieve all OCO orders based on provided optional parameters. Please note the maximum limit is 1,000 orders.\n\nUse this endpoint to query open OCO orders.\n\nUse this endpoint to cancel an entire order list.\n‚Ä¢ Canceling an individual leg will cancel the entire OCO\n\nUse this endpoint to get a list of supported coin pairs.\n\nUse this endpoint to request a quote for a from-to coin pair.\n\nUse this endpoint to place an order using an acquired quote.\n\nUse this endpoint to query OTC trade order details.\n\nUse this endpoint to query OTC trade orders by condition.\n\nUse this endpoint to query all OCBS orders by condition.\n\nUse this endpoint to fetch the details of all crypto assets including fees, withdrawal limits, and network status.\n\nUse this endpoint to submit a USD withdraw request via BITGO\n\nUse this endpoint to submit a crypto withdrawal request.\n\nUse this endpoint to fetch your crypto withdrawal history.\n\nUse this endpoint to fetch your fiat (USD) withdrawal history.\n‚Ä¢ Please pay attention to the default value of startTime and endTime.\n‚Ä¢ If both startTime and endTime are sent, the duration between startTime and endTime must be greater than 0 day and less than 90 days.\n\nUse this endpoint to fetch a deposit address for a particular crypto asset.\n\nUse this endpoint to fetch your crypto deposit history.\n\nUse this endpoint to fetch your fiat (USD) deposit history.\n‚Ä¢ Please pay attention to the default value of startTime and endTime.\n‚Ä¢ If both startTime and endTime are sent, the duration between startTime and endTime must be greater than 0 day and less than 90 days.\n\nUse this endpoint to fetch a sub-account‚Äôs deposit address.\n\nUse this endpoint to fetch sub-account deposit history.\n\nUse this endpoint to convert dust assets to BNB/BTC/ETH/USDT.\n\nUse this endpoint to get dust conversion history.\n\nGet Assets That Can Be Converted\n\nUse this endpoint to get your dust assets that can be converted.\n\nUse this endpoint to get the user‚Äôs referral reward history.\n\nUse this endpoint to get staking information for a supported asset (or assets)\n\nUse this endpoint to stake a supported asset.\n\nUse this endpoint to unstake a staked asset.\n\nUse this endpoint to get the staking balance for an asset(or assets).\n\nUse this endpoint to get the staking history of an asset (or assets) within a given time range.\n\nUse this endpoint to get the staking rewards history for an asset(or assets) within a given time range.\n\nUse this endpoint to get balance information for Binance.US exchange wallet and Binance.US custodial sub-account.\n\nUse this endpoint to get a list of assets supported with custodial solutions including eligibility for transfer (from custodial partner) and settlement (to custodial partner).\n\nUse this endpoint to request an asset transfer from your Binance.US exchange wallet to your Binance.US custodial sub-account.\n\nUse this endpoint to request an asset transfer from a custodial partner account to the Binance.US custodial sub-account.\n\nUse this endpoint to undo a previous transfer from your custodial partner.\n\nUse this endpoint to check a Binance.US exchange wallet transfer status.\n\nUse this endpoint to check the status of a transfer from a custodial partner account, including ExpressTrade transfer, Custodian transfer and Undo Transfer.\n\nUse this endpoint to place a new trade order.\n\nUse this endpoint to place a new OCO(one-cancels-the-other) order.\n\nOther Info: Price Restrictions: SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price Quantity Restrictions: Both legs must have the same quantity. ICEBERG quantities however do not have to be the same Order Rate Limit OCO counts as 2 orders against the order rate limit.\n\nUse this endpoint to get all open trade orders for a token symbol. Do not access this without a token symbol as this would return all pair data.\n\nUse this endpoint to check a trade order's status.\n\nUse this endpoint to check an order's status as well as past orders.\n\nIf the symbol is not sent, orders for all symbols will be returned in an array.\n\nUse this endpoint to get past trade data.\n\nNotes: If fromId is set, it will get orders >= than fromId. Otherwise most recent orders are returned.\n\nUse this endpoint to cancel an active trade order.\n\nUse this endpoint to cancel all active trade orders on a token symbol (this includes OCO orders).\n\nUse this endpoint to cancel an entire order list.\n\nUse this endpoint to get current settlement settings (status, schedule and next trigger time).\n\nUse this endpoint to check your settlement history.\n\nUse this endpoint to get current credit line account information.\n\nUse this endpoint to get your margin call and liquidation alert history.\n\nUse this endpoint to get your transfer history.\n\nUse this endpoint to transfer assets in or out of credit line account.\n\nUse this endpoint to check if the user is eligible for rebate or not.\n\nUse this endpoint to query the user's rebate history.\n\nFilters define trading rules for a symbol or an exchange.\n\nFilters come in two forms: and .\n\nThe defines the rules for a symbol. There are three parts:\n‚Ä¢ defines the intervals that a / can be increased/decreased by; disabled on == 0.\n\nAny of the above variables can be set to 0, which disables that rule in the . In order to pass the , the following must be true for / of the enabled rules:\n\nThe filter defines valid range for a price based on the average of the previous trades. is the number of minutes the average price is calculated over. 0 means the last price is used.\n\nIn order to pass the , the following must be true for :\n\nThe filter defines the valid range for the price based on the average of the previous trades. is the number of minutes the average price is calculated over. 0 means the last price is used. There is a different range depending on whether the order is placed on the BUY side or the SELL side.\n\nBuy orders will succeed on this filter if:\n\nSell orders will succeed on this filter if:\n\nThe filter defines the (aka \"lots\" in auction terms) rules for a symbol. There are three parts:\n‚Ä¢ defines the intervals that a / can be increased/decreased by.\n\nIn order to pass the , the following must be true for / :\n\nThe filter defines the acceptable notional range allowed for an order on a symbol.\n‚Ä¢ determines whether the minNotional will be applied to orders.\n‚Ä¢ determines whether the maxNotional will be applied to orders.\n\nIn order to pass this filter, the notional amount ( * ) has to meet the following conditions:\n\nFor orders, the average price used over the last minutes will be used for calculation. If the is 0, then the last price will be used.\n\nThe filter defines the minimum notional value allowed for an order on a symbol. An order's notional value is the * .\n\ndetermines whether or not the filter will also be applied to orders. Since orders have no price, the average price is used over the last minutes. is the number of minutes the average price is calculated over. 0 means the last price is used.\n\nThe filter defines the maximum parts an iceberg order can have. The number of is defined as .\n\nThe filter defines the (aka \"lots\" in auction terms) rules for orders on a symbol. There are three parts:\n‚Ä¢ defines the intervals that a can be increased/decreased by.\n\nIn order to pass the , the following must be true for :\n\nThe filter defines the maximum number of orders an account is allowed to have open on a symbol. Note that both \"algo\" orders and normal orders are counted for this filter.\n\nThe filter defines the maximum number of \"algo\" orders an account is allowed to have open on a symbol. \"Algo\" orders are , , , and orders.\n\nThe filter defines the maximum number of orders an account is allowed to have open on a symbol. An order is any order where the is > 0.\n\nThe filter defines the allowed maximum position an account can have on the base asset of a symbol. An account's position is defined as the sum of the account's:\n‚Ä¢ Sum of the qty of all open BUY orders\n\norders will be rejected if the account's position is greater than the maximum position allowed.\n\nThe filter defines the minimum and maximum value for the parameter .\n\nIn order for a to pass this filter, the following must be true:\n\nThe filter defines the maximum number of orders an account is allowed to have open on the exchange. Note that both \"algo\" orders and normal orders are counted for this filter.\n\nThe filter defines the maximum number of \"algo\" orders an account is allowed to have open on the exchange. \"Algo\" orders are , , , and orders.\n\nThe filter defines the maximum number of iceberg orders an account is allowed to have open on the exchange.\n‚Ä¢ The base endpoint is:\n‚Ä¢ If you experience issues with the standard 443 port, alternative port 9443 is also available.\n‚Ä¢ A single connection to the API is only valid for 24 hours; expect to be disconnected after the 24-hour mark.\n‚Ä¢ WebSocket server will send a ping frame every 3 minutes.\n‚Ä¢ If the server does not receive a pong frame response within 10 minutes, you will be disconnected.\n‚Ä¢ Unsolicited pong frames are allowed and will prevent disconnection.\n‚Ä¢ Lists are returned in chronological order, unless noted otherwise.\n‚Ä¢ All timestamps are in milliseconds in UTC, unless noted otherwise.\n‚Ä¢ All field names and values are case-sensitive, unless noted otherwise.\n\nRequests must be sent as JSON in text frames, one request per frame.\n‚Ä¢ Request is truly arbitrary. You can use UUIDs, sequential IDs, current timestamp, etc. The server does not interpret in any way, simply echoing it back in the response.\n\nYou can freely reuse IDs within a session. However, be careful to not send more than one request at a time with the same ID, since otherwise it might be impossible to tell the responses apart.\n‚Ä¢ None Request method names may be prefixed with explicit version: e.g., .\n‚Ä¢ None The order of is not significant.\n\nResponses are returned as JSON in text frames, one response per frame.\n\nStatus codes in the field are the same as in HTTP.\n\nHere are some common status codes that you might encounter:\n‚Ä¢ status codes indicate invalid requests; the issue is on your side.\n‚Ä¢ ‚Äì your request failed, see for the reason.\n‚Ä¢ ‚Äì you have been blocked by the Web Application Firewall.\n‚Ä¢ ‚Äì your request partially failed but also partially succeeded, see for details.\n‚Ä¢ ‚Äì you have been auto-banned for repeated violation of rate limits.\n‚Ä¢ ‚Äì you have exceeded the API request rate limit, please slow down.\n‚Ä¢ status codes indicate internal errors; the issue is on Binance US' side.\n‚Ä¢ Important: If a response contains 5xx status code, it does not necessarily mean that your request has failed. Execution status is unknown and the request might have actually succeeded. Please use query methods to confirm the status. You might also want to establish a new WebSocket connection for that.\n\nSee Error codes for a list of error codes and messages.\n‚Ä¢ Every method has a security type which determines how to call it.\n‚Ä¢ Security type is stated below Data Source. For example, Place new order (WebSocket).\n‚Ä¢ If no security type is stated, the security type is NONE.\n‚Ä¢ Secure methods require a valid API key to be specified and authenticated.\n‚Ä¢ API keys can be created on the API Management page of your Binance.US account.\n‚Ä¢ Both API key and secret key are sensitive. Never share them with anyone. If you notice unusual activity in your account, immediately revoke all the keys and contact Binance.US support.\n‚Ä¢ API keys can be configured to allow access only to certain types of secure methods.\n‚Ä¢ For example, you can have an API key with permission for trading, while using a separate API key with permission to monitor your order status.\n‚Ä¢ By default, an API key cannot . You need to enable trading in API Management first.\n‚Ä¢ and requests are also known as requests.\n‚Ä¢ The signature is computed using HMAC-SHA-256 algorithm. See computation example below.\n‚Ä¢ requests also require a parameter which should be the current millisecond timestamp.\n‚Ä¢ An additional optional parameter, , specifies for how long the request stays valid.\n‚Ä¢ If is not sent, it defaults to 5000 milliseconds.\n\nSerious trading is about timing. Networks can be unstable and unreliable, which can lead to requests taking varying amounts of time to reach the servers. With , you can specify that the request must be processed within a certain number of milliseconds or be rejected by the server.\n\nIt is recommended to use a small of 5000 or less!\n\nHere is a step-by-step guide on how to sign requests.\n\nWARNING: DO NOT SHARE YOUR API KEY AND SECRET KEY WITH ANYONE.\n\nThe example keys are provided here only for illustrative purposes.\n\nAs you can see, the parameter is currently missing.\n\nTake all request except for the , sort them by name in alphabetical order:\n‚Ä¢ Interpret as ASCII data, using it as a key for HMAC-SHA-256.\n\nNote that , , and the payload are case-sensitive, while resulting signature value is case-insensitive.\n\nYou can cross-check your signature algorithm implementation with OpenSSL.\n\nFinally, complete the request by adding the parameter with the signature string.\n‚Ä¢ None The API system is asynchronous. Some delay in the response is normal and expected.\n‚Ä¢ None Each method has a data source indicating where the data is coming from, and thus how up-to-date it is.\n‚Ä¢ Some methods have more than one data source (e.g., Memory => Database).\n\nThis means that the API will look for the latest data in that order: first in the cache, then in the database.\n\nThese terms will be used throughout the documentation, so it is recommended especially for new users to read to help their understanding of the API.\n‚Ä¢ refers to the asset that is the of a symbol. For the symbol BTCUSDT, BTC would be the .\n‚Ä¢ refers to the asset that is the of a symbol. For the symbol BTCUSDT, USDT would be the .\n‚Ä¢ Current API rate limits can be queried using the request.\n‚Ä¢ There are multiple rate limit types across multiple intervals.\n‚Ä¢ Responses can indicate current rate limit status in the optional field.\n‚Ä¢ Requests fail with status when rate limits are violated.\n‚Ä¢ REST API and WebSocket API are subject to the same Rate Limit rules.\n\nThe array describes all currently active rate limits affected by the request.\n\nFor example, a interval starts every minute. Request submitted at 00:01:23.456 counts towards the 00:01:00 minute's limit. Once the 00:02:00 minute starts, the count will reset to zero again.\n\nOther intervals behave in a similar manner. For example, rate limit resets at 00:00 UTC every day, and interval resets at 00, 10, 20... seconds of each minute.\n\nAPIs have multiple rate-limiting intervals. If you exhaust a shorter interval but the longer interval still allows requests, you will have to wait for the shorter interval to expire and reset. If you exhaust a longer interval, you will have to wait for that interval to reset, even if shorter rate limit count is zero.\n\nfield is included with every response by default.\n\nHowever, rate limit information can be quite bulky. If you are not interested in detailed rate limit status of every request, the field can be omitted from responses to reduce their size.\n\nUse parameter to control whether to include fields in response to individual requests.\n\nIf you wish to omit from all responses by default, use parameter in the query string instead:\n\nThis will make all requests made through this connection behave as if you have passed .\n\nIf you want to see rate limits for a particular request, you need to explicitly pass the parameter.\n\nNote: Your requests are still rate limited if you hide the field in responses.\n‚Ä¢ Every request has a certain weight, added to your limit as you perform requests.\n‚Ä¢ Most requests cost 1 unit of weight, heavier requests acting on multiple symbols cost more.\n‚Ä¢ Current weight usage is indicated by the rate limit type.\n‚Ä¢ Use the request to keep track of the current weight limits.\n‚Ä¢ Weight is accumulated per IP address and is shared by all connections from that address.\n‚Ä¢ If you go over the weight limit, requests fail with status .\n‚Ä¢ This status code indicates you should back off and stop spamming the API.\n‚Ä¢ Rate-limited responses include a field, indicating when you can retry the request.\n‚Ä¢ Repeatedly violating rate limits and/or failing to back off after receiving 429s will result in an automated IP ban and you will be disconnected.\n‚Ä¢ field indicates the timestamp when the ban will be lifted.\n‚Ä¢ IP bans are tracked and scale in duration for repeat offenders, from 2 minutes to 3 days.\n\nSuccessful response indicating that in 1 minute you have used 70 weight out of your 1200 limit.\n\nFailed response indicating that you are banned and the ban will last until epoch .\n‚Ä¢ Every request to place an order counts towards your order limit.\n‚Ä¢ Rejected or unsuccessful orders might or might not update the count.\n‚Ä¢ Use the request to keep track of the current order rate limits.\n‚Ä¢ Order rate limit is maintained per account and is shared by all API keys of the account.\n‚Ä¢ If you go over the order rate limit, requests fail with status .\n‚Ä¢ This status code indicates you should back off and stop spamming the API.\n‚Ä¢ Rate-limited responses include a field, indicating when you can retry the request.\n\nSuccessful response indicating that you have placed 12 orders in 10 seconds, and 4043 orders in the past 24 hours.\n\nNote: You can use regular WebSocket ping frames to test connectivity as well, WebSocket API will respond with pong frames as soon as possible. request along with is a safe way to test request-response handling in your application.\n\nTest connectivity to the WebSocket API and get the current server time.\n‚Ä¢ None Only one of , , parameters can be specified.\n‚Ä¢ None accepts either a list of permissions, or a single permission name: .\n\nIf you need to continuously monitor order book updates, please consider using WebSocket Streams:\n\nYou can use request together with streams to maintain a local order book.\n\nIf you need access to real-time trading activity, please consider using WebSocket Streams:\n‚Ä¢ If is not specified, the most recent trades are returned.\n\nAn aggregate trade (aggtrade) represents one or more individual trades. Trades that fill at the same time, from the same taker order, with the same price ‚Äì those trades are collected into an aggregate trade with total quantity of the individual trades.\n\nIf you need access to real-time trading activity, please consider using WebSocket Streams:\n‚Ä¢ If is specified, return aggtrades with aggregate trade ID >= .\n\nUse and to page through all aggtrades.\n‚Ä¢ If and/or are specified, aggtrades are filtered by execution time ( ).\n\ncannot be used together with and .\n‚Ä¢ If no condition is specified, the most recent aggregate trades are returned.\n\nKlines are uniquely identified by their open & close time.\n\nIf you need access to real-time kline updates, please consider using WebSocket Streams:\n‚Ä¢ If , are not specified, the most recent klines are returned.\n\nIf you need to continuously monitor trading statistics, please consider using WebSocket Streams:\n\nIf you need different window sizes, use the request.\n\nWeight: Adjusted based on the number of requested symbols:\n‚Ä¢ None and cannot be used together.\n‚Ä¢ None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nThis request is similar to , but statistics are computed on demand using the arbitrary window you specify.\n\nNote: Window size precision is limited to 1 minute. While the is the current time of the request, always start on a minute boundary. As such, the effective window might be up to 59999 ms wider than the requested .\n\nFor example, a request for might result in the following window:\n\nTime of the request ‚Äì ‚Äì is 1660184865291 (August 11, 2022 02:27:45.291). Requested window size should put the 7 days before that ‚Äì August 4, 02:27:45.291 ‚Äì but due to limited precision it ends up a bit earlier: 1659580020000 (August 4, 2022 02:27:00), exactly at the start of a minute.\n\nIf you need to continuously monitor trading statistics, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n‚Ä¢ None Either or must be specified.\n‚Ä¢ None Maximum number of symbols in one request: 100.\n‚Ä¢ None Window size units cannot be combined. E.g., is not supported.\n\nGet the latest market price for a symbol.\n\nIf you need access to real-time price updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n‚Ä¢ None and cannot be used together.\n‚Ä¢ None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nGet the current best price and quantity on the order book.\n\nIf you need access to real-time order book ticker updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n‚Ä¢ None and cannot be used together.\n‚Ä¢ None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nCertain parameters (*) become mandatory based on the order :\n\nAvailable options, setting how long the order should be active before expiration:\n‚Ä¢ specifies value for the order.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n‚Ä¢ Any or order can be made into an iceberg order by specifying the .\n\nAn order with an must have set to .\n‚Ä¢ \n‚Ä¢ must be above market price: ,\n‚Ä¢ must be below market price: ,\n\nThe order will execute a quantity that has notional value as close as possible to requested .\n\nValidates new order parameters and verifies your signature but does not send the order into the matching engine.\n\nSame as for .\n‚Ä¢ None If both and parameters are specified, only is used and is ignored.\n‚Ä¢ None For some historical orders the response field may be negative, meaning the data is not available at this time.\n‚Ä¢ None If both and parameters are specified, only is used and is ignored.\n‚Ä¢ None will replace of the canceled order, freeing it up for new orders.\n‚Ä¢ None If you cancel an order that is a part of an OCO pair, the entire OCO is canceled.\n\nCancel an existing order and immediately place a new order instead of the canceled one.\n\nSimilar to the request, additional mandatory parameters (*) are determined by the new order .\n‚Ä¢ ‚Äì if cancellation request fails, new order placement will not be attempted\n‚Ä¢ ‚Äì new order placement will be attempted even if the cancel request fails\n‚Ä¢ None If both and parameters are specified, only is used and is ignored.\n‚Ä¢ None will replace of the canceled order, freeing it up for new orders.\n‚Ä¢ None specifies value for the placed order.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n\nThe new order can reuse old of the canceled order.\n‚Ä¢ This cancel-replace operation is not transactional.\n\nIf one operation succeeds but the other one fails, the successful operation is still executed.\n\nFor example, in mode, if the new order placement fails, the old order is still canceled.\n‚Ä¢ None Filters and order count limits are evaluated before cancellation and order placement occurs.\n‚Ä¢ None If new order placement is not attempted, your order count is still incremented.\n‚Ä¢ None Like , if you cancel a leg of an OCO, the entire OCO is canceled.\n\nIf you need to continuously monitor order status updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n\nStatus reports for open orders are identical to .\n\nNote that some fields are optional and included only for orders that set them.\n\nOpen orders are always returned as a flat list. If all symbols are requested, use the field to tell which symbol the orders belong to.\n\nCancellation reports for orders and OCOs have the same format as in .\n\nSend in a new one-cancels-the-other (OCO) pair: + / orders (called legs), where activation of one order immediately cancels the other.\n\nA new OCO with the same is accepted only when the previous one is filled or completely expired.\n\nis distinct from of individual orders.\n‚Ä¢ and specify values for both legs of the OCO.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n‚Ä¢ Both legs have the same .\n\nHowever, you can set different iceberg quantity for individual legs.\n\nIf is used, must be .\n‚Ä¢ None applies only to the / leg of the OCO.\n‚Ä¢ None OCO counts as 2 orders against the order rate limit.\n\nResponse format for is selected using the parameter. The following example is for response type. See for more examples.\n\nFor execution status of individual orders, use .\n‚Ä¢ None refers to of the OCO itself.\n‚Ä¢ None If both and parameters are specified, only is used and is ignored.\n‚Ä¢ None If both and parameters are specified, only is used and is ignored.\n‚Ä¢ None Canceling an individual leg with will cancel the entire OCO as well.\n\nIf you need to continuously monitor order status updates, please consider using WebSocket Streams:\n\nQuery information about all your orders ‚Äì active, canceled, filled ‚Äì filtered by time range.\n‚Ä¢ If and/or are specified, is ignored.\n\nOrders are filtered by of the last execution status update.\n‚Ä¢ None If is specified, return orders with order ID >= .\n‚Ä¢ None If no condition is specified, the most recent orders are returned.\n‚Ä¢ None For some historical orders the response field may be negative, meaning the data is not available at this time.\n\nStatus reports for orders are identical to .\n\nNote that some fields are optional and included only for orders that set them.\n\nQuery information about all your OCOs, filtered by time range.\n‚Ä¢ If and/or are specified, is ignored.\n\nOCOs are filtered by of the last OCO execution status update.\n‚Ä¢ None If is specified, return OCOs with order list ID >= .\n‚Ä¢ None If no condition is specified, the most recent OCOs are returned.\n\nStatus reports for OCOs are identical to .\n\nQuery information about all your trades, filtered by time range.\n‚Ä¢ None If is specified, return trades with trade ID >= .\n‚Ä¢ None If and/or are specified, trades are filtered by execution time ( ).\n\ncannot be used together with and .\n‚Ä¢ If is specified, only trades related to that order are returned.\n\nand cannot be used together with .\n‚Ä¢ If no condition is specified, the most recent trades are returned.\n\nDisplays the list of orders that were expired due to STP.\n\nThese are the combinations supported:\n\nNote: The user data can ONLY be retrieved by a separate Websocket connection via the User Data Streams url (i.e. ).\n\nNote: the stream will close in 60 minutes unless requests are sent regularly.\n\nSubscribe to the received listen key on WebSocket Stream afterwards.\n\nPing a user data stream to keep it alive.\n\nUser data streams close automatically after 60 minutes, even if you're listening to them on WebSocket Streams. In order to keep the stream open, you have to regularly send pings using the request.\n\nIt is recommended to send a ping once every 30 minutes.\n‚Ä¢ Streams can be accessed either in a single raw stream or in a combined stream\n‚Ä¢ Combined stream events are wrapped as follows: {\"stream\":\"<streamName>\",\"data\":<rawPayload>}\n‚Ä¢ All symbols for streams are in lowercase\n‚Ä¢ A single connection to stream.binance.us is only valid for 24-hours; expect to be disconnected at the 24 hour mark\n‚Ä¢ The WebSocket server will send a every 3 minutes. If the WebSocket server does not receive a back from the connection within a 10-minute period, the connection will be disconnected. Unsolicited are allowed.\n‚Ä¢ WebSocket connections have a limit of 5 incoming messages per second. A message is considered:\n‚Ä¢ A connection that goes beyond the limit will be disconnected; IPs that are repeatedly disconnected may be banned.\n‚Ä¢ A single connection can listen to a maximum of 1024 streams.\n‚Ä¢ The following data can be sent through the WebSocket instance in order to subscribe/unsubscribe from streams. Examples can be seen below.\n‚Ä¢ The used in the JSON payloads is an unsigned INT used as an identifier to uniquely identify the messages going back and forth.\n‚Ä¢ In the response, if the received is which means the request sent was a success for non-query requests (e.g., subscribing/unsubscribing).\n\nCurrently, the only property that can be set is whether stream payloads are enabled or not. The combined property is set to when connecting using (\"raw streams\") and when connecting using .\n‚Ä¢ Streams can be accessed either in a single raw stream or in a combined stream\n‚Ä¢ Combined stream events are wrapped as follows: {\"stream\":\"<streamName>\",\"data\":<rawPayload>}\n‚Ä¢ All symbols for streams are lowercase\n‚Ä¢ A single connection to stream.binance.us is only valid for 24-hours; expect to be disconnected at the 24 hour mark\n‚Ä¢ The WebSocket server will send a every 3 minutes. If the WebSocket server does not receive a back from the connection within a 10-minute period, the connection will be disconnected. Unsolicited are allowed.\n\nThe Aggregate Trade Streams push trade information that is aggregated for a single taker order.\n\nThe Trade Streams push raw trade information; each trade has a unique buyer and seller.\n\nThe Kline/Candlestick Stream pushes updates to the current klines/candlestick every second.\n\nNote: This stream is different from the stream. The open time always starts at the beginning of the minute, while the closing time is the current time of the update. As such, the effective window might be up to 59999ms wider than .\n\n24hr rolling window ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.\n\nRolling window ticker statistics for all market symbols, computed over multiple windows. Note that only tickers that have changed will be present in the array.\n\n24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.\n\n24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.\n\n24hr rolling window mini-ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.\n\nPushes any update to the best bid or asks price or quantity in real-time for a specified symbol.\n\nTop <levels> bids and asks, pushed every second. Valid <levels> are 5, 10, or 20.\n\nOrder book price and quantity depth updates are used to manage an order book locally.\n‚Ä¢ Buffer the events you receive from the stream\n‚Ä¢ Drop any event where is <= in the snapshot\n‚Ä¢ The first processed should have <= +1 AND >= +1\n‚Ä¢ While listening to the stream, each new event's should be equal to the previous event's +1\n‚Ä¢ The data in each event is the absolute quantity for a price level\n‚Ä¢ If the quantity is 0, remove the price level\n‚Ä¢ Receiving an event that removes a price level that is not in your local order book is normal\n‚Ä¢ A User Data Stream is valid for 60 minutes after creation.\n‚Ä¢ Doing a on a will extend its validity for 60 minutes.\n‚Ä¢ Doing a on a will close the stream and invalidate the .\n‚Ä¢ Doing a on an account with an active will return the currently active and extend its validity for 60 minutes.\n‚Ä¢ User Data Streams are accessed at /ws/<listenKey> or /stream?streams=<listenKey>\n‚Ä¢ A single connection to stream.binance.us is only valid for 24 hours; expect to be disconnected at the 24-hour mark\n\nStart a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active , that will be returned and its validity will be extended for 60 minutes.\n\nKeepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.\n\nThe event is sent any time an account balance has changed and contains the assets that were possibly changed by the event that generated the balance change.\n\nOrders are updated with the event.\n\nCheck the REST API Documentation and below for relevant enum definitions.\n\nAverage price can be found by doing divided by .\n‚Ä¢ NEW - The order has been accepted into the engine\n‚Ä¢ CANCELED - The order has been canceled by the user\n‚Ä¢ REPLACED - This is currently unused\n‚Ä¢ REJECTED - The order has been rejected and was not processed (this is never pushed into the User Data Stream)\n‚Ä¢ TRADE - Part of the order or all of the order's quantity has been filled\n‚Ä¢ EXPIRED - The order was canceled according to the order type's rules (e.g., LIMIT FOK orders with no fill, LIMIT IOC or MARKET orders that partially fill) or by the exchange, (e.g., orders canceled during liquidation, orders canceled during maintenance)\n‚Ä¢ TRADE_PREVENTION - The order has expired due to STP.\n\nBalance Update occurs during deposits or withdrawals from the account."
    },
    {
        "link": "https://stackoverflow.com/questions/73356995/how-to-properly-handle-multiple-connection-error-exceptions-on-python3-related",
        "document": "I'm coding a little cryptocurrency tracker using the package version (the last version as of today)\n\nMy problem appears at some specific part of the process which is the login to the Binance server through the using the api and secret keys. Here's the code for that:\n\nNote: As long as the user has an stable internet connection, no exception is raised, allowing the tracker to work as expected\n\nBut, if the user were not even connected to the internet (without obviously noticing it), the following exceptions would be thrown after executing the code above:\n\nSo, in essence, there are 4 exceptions that need to be handled:\n\nAt first I tried the following code based on this approach because I thought that as was always the very first exception raised, I supposed that by correctly handling it, the rest of the exceptions would not be raised:\n\nUnfortunately, my approach didn't handle anything and ended up throwing exactly the same output described above, with the same exceptions raised in the same order.\n\nHowever, this other one DID WORK!:\n\nSo guys, I came here to know if there's a better way than just setting to handle the 4 exceptions raised? You know, it doesn't look very to me, and also doesn't let me know exactly what's happening behind and how to explain the user why such thing is happening, so may you help me out here?"
    },
    {
        "link": "https://discuss.python.org/t/help-needed-binance-trading-bot-list-index-out-of-range-and-precision-maths-aint-happening-errors/61441",
        "document": "I‚Äôve been working on a Binance trading bot in Python, but I‚Äôve hit a couple of persistent errors that I can‚Äôt seem to resolve. The bot is designed to trade BTC/USDT based on signals generated by some basic TA indicators. However, I‚Äôm running into the following issues:\n‚Ä¢ ‚ÄúList Index Out of Range‚Äù Error: This error usually occurs when the bot tries to place an order after detecting a buy/sell signal. I suspect it might be related to how I‚Äôm handling the order response or processing positions, but I‚Äôm not entirely sure.\n‚Ä¢ ‚ÄúPrecision Maths Ain‚Äôt Happening‚Äù Error: This seems to be related to the precision when placing orders. I‚Äôve tried using to manage precision, but it hasn‚Äôt resolved the issue.\n\nHere‚Äôs a snippet of the main part of the code:\n‚Ä¢ Double-checking the precision calculation for quantities and prices.\n‚Ä¢ Using and other methods to handle precision.\n‚Ä¢ Adding debug prints to trace where things go wrong.\n‚Ä¢ Has anyone encountered these types of errors before when working with the Binance API?\n‚Ä¢ Could this be related to how I‚Äôm fetching and processing the exchange info for precision?\n‚Ä¢ Are there any better ways to structure the bot‚Äôs logic to avoid these issues?\n\nAny help or insights would be greatly appreciated! I‚Äôm happy to provide more details if needed.\n\nAdditional Context:\n\n I‚Äôm using the library for technical analysis, for data handling, and for the API client. The bot is supposed to operate with leverage and place limit and OCO orders.\n\nFeel free to post this on a relevant\n\n subreddit like r/algorithmictrading or r/cryptoprogramming where developers familiar with trading bots and the Binance API might be able to offer assistance."
    },
    {
        "link": "https://github.com/sammchardy/python-binance/issues/261",
        "document": "One of the errors I keep running into is this:\n\nbinance.exceptions.BinanceAPIException: APIError(code=-1000): An unknown error occured while processing the request.\n\nI was just wondering if there is a way to pass this in a try statement? Here is what I use to pass timeout errors.\n\nAre there any except functions like \" except Timeout\" for the other error codes that I could use?"
    },
    {
        "link": "https://stackoverflow.com/questions/69032153/python-binance-market-order-issues",
        "document": "Below I will explain my issue of incorrectly sending orders to Binance via my algorithm which I would be grateful for any help on.\n\nI have created a model to send market buy and market sell orders to Binance based on my models output. I have a dataframe column named action, with the latest (bottom of the column) value being used as a signal to send orders to Binance. The action column can either take the form of 1 (buy order) -1 (sell order) or 0 (do nothing). It is a impossibility that the action column can have two 1's or two -1's back to back. There will always be a buy order followed by a sell order (possibly separated by 'do nothing orders'). I have checked the action column in the dataframe and can confirm that there are never any instances where this rule is broken.\n\nThe issue I have is that when I run my program in a loop I often get scenarios where the program will (try to) send multiple buy orders back to back without a sell order splitting the orders up, or vice versa where the program sends multiple sell orders back to back without a buy order separating them out. Based on the values in the action column this is not possible, so I suspect my amateur Python abilities have failed me in a likely obvious way to more tenured programmers.\n\nI would be very grateful for any suggestions as to how I could resolve this issue and ensure that my market orders are being sent to the exchange as per the models logic.\n\nMy initial thoughts of what my issue could be (which I haven't yet been able to conclude fully)are;\n‚Ä¢ Poor structure regarding my if statement\n‚Ä¢ Incorrectly assigning \"action\" which I pass through my if statement\n‚Ä¢ Something more Binance specific in regards to sending orders to the exchange\n\nOnce again I would be very grateful for any help or suggestions as I have been stuck on this question for a considerable amount of time! Cheers!"
    },
    {
        "link": "https://github.com/sammchardy/python-binance/issues/1308",
        "document": "I'm encountering an issue when placing orders using the Binance Futures API in Python. I'm trying to place an order using the python-binance library, but I keep receiving the error 'APIError(code=-4003): Quantity less than zero.' I have calculated the order quantity based on the current price and the amount I want to trade. I have also rounded the quantity before placing the order, but I still receive the error. I believe my code adheres to the Binance API documentation, but the error persists. Here's the error:\n\n 'Calculated quantity for ETHUSDT: 0.0109421162052741\n\n Error executing ETHUSDT BUY order: APIError(code=-4003): Quantity less than zero.'\n\nCould anyone please help me understand what might be causing this issue and suggest a solution? Thank you in advance for your assistance! Find below the code snippet\n\nasync def create_market_order(symbol, side, quantity):\n\n try:\n\n quantity = round(quantity)\n\n order = await client.futures_create_order(\n\n symbol=symbol,\n\n side=side,\n\n type=ORDER_TYPE_MARKET,\n\n quantity=quantity,\n\n newClientOrderId=f'hma_scalping_strategy_{int(time.time())}'\n\n )\n\n print(f\"{symbol} order {side} executed at {order['avgPrice']}\")\n\n except BinanceAPIException as e:\n\n print(f\"Error executing {symbol} {side} order: {e}\")"
    }
]