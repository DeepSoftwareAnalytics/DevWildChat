[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a element. It is used for drawing shapes, text, images, and other objects. The interface's properties and methods are described in the reference section of this page. The Canvas tutorial has more explanation, examples, and resources, as well. For , there is an equivalent interface that provides the rendering context. The offscreen rendering context inherits most of the same properties and methods as the and is described in more detail in the reference page.\n\nTo get a instance, you must first have an HTML element to work with: To get the canvas' 2D rendering context, call on the element, supplying as the argument: With the context in hand, you can draw anything you like. This code draws a house: The resulting drawing looks like this:\n\nThe following methods can be used to manipulate paths of objects. Starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path. Causes the point of the pen to move back to the start of the current sub-path. It tries to draw a straight line from the current point to the start. If the shape has already been closed or has only one point, this function does nothing. Moves the starting point of a new sub-path to the (x, y) coordinates. Connects the last point in the current sub-path to the specified (x, y) coordinates with a straight line. Adds an arc to the current path with the given control points and radius, connected to the previous point by a straight line. Adds an elliptical arc to the current path. Creates a path for a rectangle at position (x, y) with a size that is determined by width and height. Creates a path for a rounded rectangle with a specified position, width, height, and corner radii.\n\nObjects in the rendering context have a current transformation matrix and methods to manipulate it. The transformation matrix is applied when creating the current default path, painting text, shapes and objects. The methods listed below remain for historical and compatibility reasons as objects are used in most parts of the API nowadays and will be used in the future instead. Retrieves the current transformation matrix being applied to the context. Adds a rotation to the transformation matrix. The angle argument represents a clockwise rotation angle and is expressed in radians. Adds a scaling transformation to the canvas units by x horizontally and by y vertically. Adds a translation transformation by moving the canvas and its origin x horizontally and y vertically on the grid. Multiplies the current transformation matrix with the matrix described by its arguments. Resets the current transform to the identity matrix, and then invokes the method with the same arguments. Resets the current transform by the identity matrix.\n\nThe rendering context contains a variety of drawing style states (attributes for line styles, fill styles, shadow styles, text styles). The following methods help you to work with that state: Saves the current drawing style state using a stack so you can revert any change you make to it using . Restores the drawing style state to the last element on the 'state stack' saved by . A read-only back-reference to the . Might be if it is not associated with a element. Returns an object containing the context attributes used by the browser. Context attributes can be requested when using to create the 2D context. Resets the rendering context, including the backing buffer, the drawing state stack, path, and styles. Returns if the rendering context was lost."
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://docs.tizen.org/application/web/guides/w3c/graphics/canvas",
        "document": "The HTML5 canvas allows you to use graphics on the screen, and draw and manage various shapes. The HTML Canvas 2D Context API (in mobile, wearable, and TV applications) defines a special canvas element that expresses images or shapes with JavaScript.\n\nThe main features of the Canvas Element API include the following:\n• To draw and manage shapes, you must insert a <canvas> element in the HTML page.\n• You can use images on the canvas by using the applicable method of the HTML Canvas 2D Context API.\n• With the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles, circles, and lines to a canvas. You can also draw and mask objects on the canvas.\n• You can use a canvas to create text or lines other than images and shapes.\n\nFor all canvas objects (images, shapes, text, and lines), you can define colors (the and attributes), shadows (the and attributes), and gradation (the method). You can also use the transformation methods, such as , , , and , to implement, for example, transparency or shape gradient transformations.\n\nIn mobile applications only, in HTML5, the Scalable Vector Graphics (SVG) 2 API provides similar features as the canvas. Their difference is that SVG expresses graphics using vectors, while the canvas is based on pixels. To express complex graphics, use the canvas, and to express graphics with a liberal expansion or reduction, use SVG.\n\nTo create a canvas in your application, follow these steps:\n• The canvas assigns the region (canvas context) where images are drawn with JavaScript: If no and attributes are inserted, the default value is .\n• To check the information on the image connected to the canvas, use the method to restore the URL of the image used on the canvas. To create a blob object of the image file, use the method.\n• Use the interface (in mobile, wearable, and TV applications) to connect to the canvas and get the canvas context: The interface has various methods and attributes for expressing images and shapes.\n• To manage the work stack of the canvas, use the following methods:\n• : Pushes the current state onto the stack.\n• : Pops the top state on the stack, restoring the context to that state.\n\nThere is a need to separately check whether the canvas 2D context can be used by using the method:\n\nFor the complete source code related to this use case, see the following files:\n\nUse images on the canvas\n\nTo use images on the canvas, use the method of the HTML Canvas 2D Context API. The method receives information, such as the image URL and position, and where it is indicated, and then creates the image on the canvas. The created image is pixel-based.\n\nTo use images on a canvas, follow these steps:\n• Use the method to express an image on the canvas. When you define the URL of the image to be imported and its coordinates, the original image is imported as it is. You can hide certain parts of the image by assigning its size accordingly:\n• When the image is connected to the canvas, extract the color value through the method. Re-input the transformed values with the method:\n• Use the interface to transform the selected object, for example, its size, angle, or position. By connecting to the image used on the canvas, you can also rotate it: The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following files:\n\nWith the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles ( ), circles ( and ), and lines ( and ), to a canvas. You can define the position and size of the shapes, and also merge shapes with other shape objects.\n\nTo create and draw shapes on a canvas, follow these steps:\n• Use the method to create a rectangle. Use the canvas context to assign the rectangle attributes, such as position and size: The following figure applies to mobile applications only.\n• Use the method to create a circle. Use the canvas context to assign the circle attributes, such as position and radius. (The following figure applies to mobile applications only.)\n• Use the interface to transform the created shapes. With compositing, a certain part of the shape can be made transparent. The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following file:\n\nTo draw masks on a canvas, follow these steps:\n• Create the HTML layout with a canvas and 2 button input elements for brush selection:\n• Define the CSS style for the background image:\n• Declare the JavaScript variables needed in the application. The and variables indicate the last position of a user event. The variable indicates whether a button or touch event has occurred, and the variable indicates the current brush size:\n• Draw an image on the canvas using the method. The user is able to replace the image with another using a brush. Create a new object, including the path of the image file. Define the line width to be based on the brush size selected by the user:\n• The and events only store the event coordinates, the and events define the position and direction of the drawing, and the and events indicate that the user event ends, as illustrated in the following figure.\n• Use the method to update the and variable values. The real coordinates can be calculated by reducing the offset position of the canvas element from the touch position coordinates. The string indicates that the event is a touch event:\n• When the user starts drawing, the or event calls the method, which updates the event position, sets the composite operations property to make the drawing a mask, begins to draw a new path, moves the drawing point to the selected coordinates, and sets the button or touch event state to :\n• While the user is drawing, the and events are handled with the method based on the button state retrieved from the variable. The method calls the method only when the mouse or finger is being moved. Use the method to make the drawn line visible:\n• When the touch event ends or the mouse button is released, use the method to stop drawing:\n\nFor the complete source code related to this use case, see the following file:\n\nCreat text and lines on the canvas\n\nTo create text and lines on a canvas, follow these steps:\n• To draw a line, use the method to assign the beginning point of the line, and the method to assign the end point of the line. The method draws the full line:\n• When adding text on the canvas, use various attributes and methods to define how the text looks and where it is located. The attribute defines the font style, and the attribute the vertical alignment of the text:\n• Use the attribute and the method to position the text in the assigned location:\n\nFor the complete source code related to this use case, see the following files:\n\nPerformance comparison of Canvas 2D and WebGL™ in mobile applications\n\nIn Web documents prior to HTML5, only simple image loading was supported. To create graphic animations, you had to use a separate plug-in. However, as the graphic-related APIs have become more standardized, you can now express graphics by using only JavaScript, without a separate plug-in.\n\nWhen developing Web applications that need to express complex graphics, such as games, the most important issue to consider is graphic performance. Currently, the HTML Canvas 2D Context API and WebGL™ are used to express graphic elements in many games. The following example illustrates how to create an effective graphic animation by comparing the performance of the renderers in the Canvas 2D Context API and WebGL™.\n\nTo compare the performance, 2 simple Web applications must be created, using the Canvas 2D Context API and WebGL™:\n• Create the applications with the following logic:\n• Render the loaded image in the random location of the canvas.\n• Use the method of the Timing control for script-based animations API (in mobile, wearable, and TV applications) to change the color of the loaded image, based on different times.\n• Create a logic that measures FPS (frames per second) in order to check the performance.\n• Execute the applications and measure the FPS.\n• Increase only the number of objects so that the same 1~N images, under the same conditions, are shown repeatedly based on 1~N.\n• Measure the FPS as the number of repeatedly shown objects increase.\n\nThe following figure shows the result of the test: As the number of objects increase, the performance of the Canvas 2D Context API rapidly decreases compared to WebGL™ (the result is subject to change according to the complexity of the application logic). As such, when expressing many graphic objects all differently, it is much more efficient to use WebGL™ than the Canvas 2D Context API.\n\nThere is one problem with using WebGL™; the ratio of mobile browsers supporting it is quite low compared to the Canvas 2D Context API, and even when it is supported, usually only partial features are included (support for 3D acceleration, reflection effect, and camera effect is particularly low). The following figure shows the support status of WebGL™ in computer (top) and mobile (bottom) browsers, as published in http://webglstats.com/ in June 2013.\n\nMany mobile browsers do not support WebGL™ or only partially support WebGL™. Even though Tizen supports WebGL™, it is recommended to use the Canvas 2D Context API for small numbers of 2D drawings, since the API is supported in most mobile browsers. However, for performance critical applications, use WebGL™ for faster 2D performance."
    },
    {
        "link": "https://w3schools.com/jsref/api_canvas.asp",
        "document": "You access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/12241113/whats-the-best-way-to-create-key-events-in-html5-canvas",
        "document": "If you want to set key event handling on the itself (not the or ), set a tabindex on the element. Note that the canvas will need to be in focus on to catch key events.\n\nThis is how it is done on the Processing.js website.\n\nIf you don't want a border to appear when you click on the canvas, set its style to ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard",
        "document": "Now, when we have our mobile controls in place and the game is playable on touch-enabled devices, it would be good to add mouse and keyboard support so the game can be playable on desktop also. That way we can broaden the list of supported platforms. We'll look at this below. It's also easier to test control-independent features like gameplay on desktop if you develop it there, so you don't have to push the files to a mobile device every time you make a change in the source code. Note: The Captain Rogers: Battle at Andromeda is built with Phaser and managing the controls is Phaser-based, but it could also be done in pure JavaScript. The good thing about using Phaser is that it offers helper variables and functions for easier and faster development, but it's totally up to you which approach you chose.\n\nLet's think about implementing pure JavaScript keyboard/mouse controls in the game first, to see how it would work. First, we'd need an event listener to listen for the pressed keys: Whenever any key is pressed down, we're executing the function, and when press finishes we're executing the function, so we know when it's no longer pressed. To do that, we'll hold the information on whether the keys we are interested in are pressed or not: let rightPressed = false; let leftPressed = false; let upPressed = false; let downPressed = false; Then we will listen for the and events and act accordingly in both handler functions. Inside them we can get the code of the key that was pressed from the property of the event object, see which key it is, and then set the proper variable. The codes are all readable string names, but you can look them up to be sure; is the left arrow: function keyDownHandler(event) { if (event.code === \"ArrowRight\") { rightPressed = true; } else if (event.code === \"ArrowLeft\") { leftPressed = true; } if (event.code === \"ArrowDown\") { downPressed = true; } else if (event.code === \"ArrowUp\") { upPressed = true; } } The looks almost exactly the same as the above, but instead of setting the pressed variables to , we would set them to . If the left arrow is pressed ( ; ), we can set the variable to and in the function perform the action assigned to it — move the ship left: function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); if (rightPressed) { playerX += 5; } else if (leftPressed) { playerX -= 5; } if (downPressed) { playerY += 5; } else if (upPressed) { playerY -= 5; } ctx.drawImage(img, playerX, playerY); requestAnimationFrame(draw); } The function first clears the whole Canvas — we draw everything from scratch on every single frame. Then the pressed key variables are checked and the and variables (that we define earlier just after and the others) holding the position of the ship are adjusted by a given amount, let's say 5 pixels. Then the player's ship is drawn on the screen and the next draw is called from within the requestAnimationFrame. You can see this example in action online at end3r.github.io/JavaScript-Game-Controls and the full source code can be found at github.com/end3r/JavaScript-Game-Controls.\n\nThe mouse interactions in the game are focused on clicking the buttons. In Phaser, the buttons you create will take any type of input, whether it's a touch on mobile or a click on desktop. That way, if you already implemented the buttons as shown in the Mobile touch controls article, it will work out of the box on the desktop too: The button will be placed ten pixels from the top left corner of the screen, use the image, and will execute the function when clicked. We can assign actions directly to the buttons: this.buttonShoot = this.add.button( this.world.width * 0.5, 0, \"button-alpha\", null, this, ); this.buttonShoot.onInputDown.add(this.shootingPressed, this); this.buttonShoot.onInputUp.add(this.shootingReleased, this); The button used for shooting works perfectly fine on both the mobile and desktop approach. If you want to use the mouse's cursor position on the screen, you can do so with . Let's assume you'd like to shoot a bullet when the right half of the screen is clicked with a mouse, it would be done something like this: If you'd like to differentiate the mouse buttons being pressed, there are three defaults you can pick from: Keep in mind that instead of , it's better to use for platform-independent input, if you want to keep the support for mobile touch interactions.\n\nThe whole game can be controlled with just the keyboard and nothing else. The built-in object manages the input from the keyboard, and has a few helpful methods like and . There's also the Phaser.KeyCode object, which contains all the available keyboard keys: In the main menu of the game, we can add an extra way to begin playing. The Start button can be clicked to do so, but we can use the key to do the same: You can use to add any key the object has to offer. The function is executed whenever the key is pressed. It will launch the method, which starts a new game. It's useful to provide an option to play the game on desktop without using a mouse, so you don't have to take your hands off the keyboard.\n\nWe can support keyboard input in games built with Phaser by enabling the basic cursor keys in the function using the function: This creates four directional arrow keys for us: You can also define the keys on your own and offer an alternative, control mechanism. For example: To support both the cursor and keys, we need to do this: if (this.cursors.left.isDown || this.keyLeft.isDown) { // move left } else if (this.cursors.right.isDown || this.keyRight.isDown) { // move right } if (this.cursors.up.isDown || this.keyUp.isDown) { // move up } else if (this.cursors.down.isDown || this.keyDown.isDown) { // move down } In the function we can now move the player's ship in any direction using one of the two sets of movement key options. We can also offer firing control alternatives. For cursor keys the natural shooting button would be on the other side of the keyboard, so the player can use the other hand — for example the key. For keys it can be the Space bar: In the function we can easily check if any of those two were pressed on each frame: If yes, then it's time to shoot some bullets! We can even define a secret cheat button: And then in the function, whenever is pressed we'll do this: We can set the health of the player to maximum. Remember: it's a secret, so don't tell anyone!\n\nWe've implemented the controls, and now we should inform the player about their options to control the game. They wouldn't know about them otherwise! When showing the how to play screen where the various ways to control the ship in the game are shown, instead of showing them all to everyone, we can detect whether the game is launched on desktop or mobile and just show the appropriate controls for the device: if (this.game.device.desktop) { moveText = \"Arrow keys or WASD to move\"; shootText = \"X or Space to shoot\"; } else { moveText = \"Tap and hold to move\"; shootText = \"Tap to shoot\"; } If the game is running on desktop, the cursor and keys message will be shown. If not, then the mobile touch controls message will be. To skip the how to play screen, we can listen for any key being pressed and move on: This hides the intro and starts the actual game without us having to set up another new key control just for this."
    },
    {
        "link": "https://w3schools.com/jsref/obj_keyboardevent.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/37998351/handling-simultaneous-keyevents-in-a-javascript-game",
        "document": "I'm working on an RPG in Javascript and am setting up controls for the main player, but I am having some issues with the keyEvent handling. This code controls player movement and animation. Where things go wrong, I believe, is that if the game registers a keydown while there is already another keydown, and then that first key goes up, the sprite pauses (the isMoving property basically stops movement and animation when it is false).\n\nIs there a better way to set up controls so that my game can handle multiple keys simultaneously?\n\nAlso, the sprite moves when mac command key is pushed. Not sure why."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values",
        "document": "Modifiers are special keys which are used to generate special characters or cause special actions when used in combination with other keys. Examples include the and keys, and lock keys such as and . The or (Alternate Graphics) key. Enables the ISO Level 3 shift modifier (where is the level 2 modifier). The key. Toggles the capital character lock on and off for subsequent input. The , , or key. Allows typing control characters. The (Function modifier) key. Used to allow generating function key ( – , for instance) characters on keyboards without a dedicated function key area. Often handled in hardware so that events aren't generated for this key. The or (Function Lock) key.Toggles the function key mode described by on and off. Often handled in hardware so that events aren't generated for this key. The key. Allows issuing special command inputs. This is the logo key, or the or key on Mac keyboards. The (Number Lock) key. Toggles the numeric keypad between number entry some other mode (often directional arrows). The key. Toggles between scrolling and cursor movement modes. The key. Modifies keystrokes to allow typing upper (or other) case letters, and to support typing punctuation and other special characters. The modifier key (found on certain virtual keyboards). [1] In Firefox, the key is reported as instead of as . This will be changed in Firefox per Firefox bug 1232918. Until that's fixed, these keys are returned as by Firefox: (0x5B) and (0x5C) on Windows, and (0xFFEB), (0xFFEC), (0xFFED), and (0xFFEE) on Linux. [2] Firefox did not add support for the key until Firefox 37. [3] Firefox generates the key value for the and keys, instead of and . [4] Chrome 67 and Firefox 63 now correctly interpret the right key for keyboard layouts which map that key to . See Firefox bug Firefox bug 900750 and Chrome bug 25503 for further details.\n\nThe , , or key or button. Accepts the currently selected option or input method sequence conversion. Shows the context menu. Typically found between the (or ) key and the key on the right side of the keyboard. The (Escape) key. Typically used as an exit, cancel, or \"escape this operation\" button. Historically, the Escape character was used to signal the start of a special control sequence of characters called an \"escape sequence.\" The key. Opens an interface (typically a dialog box) for performing a find/search operation. The key. Opens or toggles the display of help information. The key. Pauses the current application or state, if applicable. Note: This shouldn't be confused with the key value, which is used for media controllers, rather than to control applications and processes. The key. Resumes a previously paused application, if applicable. Note: This shouldn't be confused with the key value, which is used for media controllers, rather than to control applications and processes. [1] In Google Chrome 52, the key incorrectly returns the key code . This is fixed in Chrome 53. (See Chrome bug 612749 for details.) [2] In Firefox 36 and earlier, the key returns instead of . [3] Firefox 36 and earlier reports instead of for the context menu key. [4] The key generates the key code on Firefox and Google Chrome, unless the Japanese keyboard layout is in effect, in which case it generates instead. [5] The key generates the key code on Firefox, unless the Japanese keyboard layout is in effect, in which case it generates instead. [6] Firefox didn't support the and keys until Firefox 37.\n\nThe key, which starts multi-candidate mode, in which multiple candidates are displayed for the ongoing input. The key, which enables code input mode, which lets the user enter characters by typing their code points (their Unicode character numbers, typically). The key, which instructs the IME to convert the current input method sequence into the resulting character. A dead \"combining\" key; that is, a key which is used in tandem with other keys to generate accented and other modified characters. If pressed by itself, it doesn't generate a character. If you wish to identify which specific dead key was pressed (in cases where more than one exists), you can do so by examining the 's associated event's property. See Dead keycodes for Linux below The (Final Mode) key is used on some Asian keyboards to enter final mode when using IMEs. Switches to the first character group on an ISO/IEC 9995 keyboard. Each key may have multiple groups of characters, each in its own column. Pressing this key instructs the device to interpret keypresses as coming from the first column on subsequent keystrokes. Switches to the last character group on an ISO/IEC 9995 keyboard. Switches to the next character group on an ISO/IEC 9995 keyboard. Switches to the previous character group on an ISO/IEC 9995 keyboard. The Mode Change key. Toggles or cycles among input modes of IMEs. The Next Candidate function key. Selects the next possible match for the ongoing input. The (\"Don't convert\") key. This accepts the current input method sequence without running conversion when using an IME. The Previous Candidate key. Selects the previous possible match for the ongoing input. The key. Instructs the IME to process the conversion. The Single Candidate key. Enables single candidate mode (as opposed to multi-candidate mode); in this mode, only one candidate is displayed at a time. [1] On the X Window System, the key is called the key. [2] The key is reported as instead of the correct by Firefox versions 36 and earlier. [3] The key currently returns in Firefox. Google Chrome returns the value of the key as if IME were not in use. [4] Prior to Firefox 37, these keys were . [5] Firefox generates the key value instead of .\n\nBecause modern remote controls for media devices often include buttons beyond the basic controls covered elsewhere in this document, key values are defined for a broad array of these additional buttons. The values below are derived in part from a number of consumer electronics technical specifications:\n• ANSI/CEA-2014-B: Web-based Protocol and Framework for Remote User Interface on UPnP™ Networks and the Internet Note: Remote controls typically include keys whose values are already defined elsewhere, such as under Multimedia keys or Audio control keys. Those keys' values will match what's documented in those tables. Changes the input mode on an external audio/video receiver (AVR) unit. Toggles the power on an external AVR unit. General-purpose media function key, color-coded red. This has index among the colored keys. General-purpose media function key, color-coded green. This has index among the colored keys. General-purpose media function key, color-coded yellow. This has index among the colored keys. General-purpose media function key, color-coded blue. This has index among the colored keys. General-purpose media function key, color-coded grey. This has index among the colored keys. General-purpose media function key, color-coded brown. This has index among the colored keys. Toggles closed captioning on and off. Adjusts the brightness of the device by toggling between two brightness levels or by cycling among multiple brightness levels. Switches the input source to the Digital Video Recorder (DVR). The Exit button, which exits the current application or menu. Clears the program or content stored in the first favorites list slot. Clears the program or content stored in the second favorites list slot. Clears the program or content stored in the third favorites list slot. Clears the program or content stored in the fourth favorites list slot. Selects (recalls) the program or content stored in the first favorites list slot. Selects (recalls) the program or content stored in the second favorites list slot. Selects (recalls) the program or content stored in the third favorites list slot. Selects (recalls) the program or content stored in the fourth favorites list slot. Stores the current program or content into the first favorites list slot. Stores the current program or content into the second favorites list slot. Stores the current program or content into the third favorites list slot. Stores the current program or content into the fourth favorites list slot. Toggles the display of the program or content guide. If the guide is currently displayed, this button tells the guide to display the next day's content. If the guide is currently displayed, this button tells the guide to display the previous day's content. Toggles the display of information about the currently selected content, program, or media. Tells the device to perform an instant replay (typically some form of jumping back a short amount of time then playing it again, possibly but not usually in slow motion). Opens content linked to the current program, if available and possible. Toggles a display listing currently available live content or programs. Locks or unlocks the currently selected content or program. Presents a list of media applications, such as photo viewers, audio and video players, and games. [1] Jumps back to the last-viewed content, program, or other media. Skips backward to the previous content or program. Skips forward to the next content or program. Steps backward to the previous content or program. Steps forward to the next content or program. Top Menu button. Opens the media's main menu (e.g., for a DVD or Blu-Ray disc). Navigates to the next item. Navigates out of the current screen or menu. Cycles to the next channel in the favorites list. Cycles to the next saved user profile, if this feature is supported and multiple profiles exist. Opens the user interface for selecting on demand content or programs to watch. Starts the process of pairing the remote with a device to be controlled. Toggles display of the picture-in-picture view on and off. Toggles random media (also known as \"shuffle mode\") on and off. A code sent when the remote control's battery is low. This doesn't actually correspond to a physical key at all. Cycles among the available media recording speeds. Toggles radio frequency (RF) input bypass mode on and off. RF bypass mode passes RF input directly to the RF output without any processing or filtering. Toggles the channel scan mode on and off. This is a mode which flips through channels automatically until the user stops the scan. Cycles through the available screen display modes. Toggles display of the device's settings screen on and off. Toggles split screen display mode on and off. Cycles among input modes on an external set-top box (STB). Toggles on and off an external STB. Toggles the display of subtitles on and off if they're available. Toggles display of teletext, if available. Cycles through the available video modes. Causes the device to identify itself in some fashion, such as by flashing a light, briefly changing the brightness of indicator lights, or emitting a tone. Toggles between fullscreen and scaled content display, or otherwise change the magnification level. [1] Don't confuse the media controller key with the Windows key, which is also known as . That key is encoded as . [2] Firefox 36 and earlier identifies the zoom toggle button as . Firefox 37 corrects this to . [3] These keys were until Firefox 37.\n\nSome keyboards offer special keys for launching or switching to certain common applications. Key values for those are listed here. The key, often labeled with an icon. This is often used as a generic application launcher key ( ). The key. Often labeled with an icon. The key. Often labeled with an icon. The key. Often labeled with an icon. The key on Windows keyboards. This is often used as a generic application launcher key ( ). The key. Opens the phone dialer application (if one is present). The key. This key may be labeled with an icon. The key. This key is frequently labeled with an icon. The key. This may be an icon of a specific word processor application, or a generic document icon. [1] Legacy Edge and Firefox (36 and earlier) use instead of . Firefox 37 through Firefox 48 use . Firefox 49 has been updated to match the latest specification, and to return . [2] Google Chrome 57 and earlier returned instead of . See Chrome Bug 612743 for more information. [3] Google Chrome 57 and earlier returned instead of . See Chrome Bug 612743 for more information. [4] Prior to Firefox 37, Firefox returned the key code instead of for the Web browser key. [5] Firefox introduced support for this key in Firefox 37. Prior to that, this key was reported as ."
    }
]