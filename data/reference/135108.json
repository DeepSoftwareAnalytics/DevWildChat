[
    {
        "link": "https://developer.android.com/guide/fragments",
        "document": "A represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments can't live on their own. They must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy.\n\nFragments introduce modularity and reusability into your activity’s UI by letting you divide the UI into discrete chunks. Activities are an ideal place to put global elements around your app's user interface, such as a navigation drawer. Conversely, fragments are better suited to define and manage the UI of a single screen or portion of a screen.\n\nConsider an app that responds to various screen sizes. On larger screens, you might want the app to display a static navigation drawer and a list in a grid layout. On smaller screens, you might want the app to display a bottom navigation bar and a list in a linear layout.\n\nManaging these variations in the activity is unwieldy. Separating the navigation elements from the content can make this process more manageable. The activity is then responsible for displaying the correct navigation UI, while the fragment displays the list with the proper layout.\n\nDividing your UI into fragments makes it easier to modify your activity's appearance at runtime. While your activity is in the lifecycle state or higher, fragments can be added, replaced, or removed. And you can keep a record of these changes in a back stack that is managed by the activity, so that the changes can be reversed.\n\nYou can use multiple instances of the same fragment class within the same activity, in multiple activities, or even as a child of another fragment. With this in mind, only provide a fragment with the logic necessary to manage its own UI. Avoid depending on or manipulating one fragment from another.\n\nFor more documentation and resources related to fragments, see the following.\n• Single Activity: Why, when, and how (Android Dev Summit '18)"
    },
    {
        "link": "https://developer.android.com/guide/fragments/create",
        "document": "A fragment represents a modular portion of the user interface within an activity. A fragment has its own lifecycle, receives its own input events, and you can add or remove fragments while the containing activity is running.\n\nThis document describes how to create a fragment and include it in an activity.\n\nFragments require a dependency on the AndroidX Fragment library. You need to add the Google Maven repository to your project's file in order to include this dependency.\n\nTo include the AndroidX Fragment library to your project, add the following dependencies in your app's file:\n\nTo create a fragment, extend the AndroidX class, and override its methods to insert your app logic, similar to the way you would create an class. To create a minimal fragment that defines its own layout, provide your fragment's layout resource to the base constructor, as shown in the following example:\n\nThe Fragment library also provides more specialized fragment base classes:\n\nGenerally, your fragment must be embedded within an AndroidX to contribute a portion of UI to that activity's layout. is the base class for , so if you're already subclassing to provide backward compatibility in your app, then you do not need to change your activity base class.\n\nYou can add your fragment to the activity's view hierarchy either by defining the fragment in your activity's layout file or by defining a fragment container in your activity's layout file and then programmatically adding the fragment from within your activity. In either case, you need to add a that defines the location where the fragment should be placed within the activity's view hierarchy. It is strongly recommended to always use a as the container for fragments, as includes fixes specific to fragments that other view groups such as do not provide.\n\nTo declaratively add a fragment to your activity layout's XML, use a element.\n\nHere's an example activity layout containing a single :\n\nThe attribute specifies the class name of the to instantiate. When the activity's layout is inflated, the specified fragment is instantiated, is called on the newly instantiated fragment, and a is created to add the fragment to the .\n\nTo programmatically add a fragment to your activity's layout, the layout should include a to serve as a fragment container, as shown in the following example:\n\nUnlike the XML approach, the attribute isn't used on the here, so no specific fragment is automatically instantiated. Instead, a is used to instantiate a fragment and add it to the activity's layout.\n\nWhile your activity is running, you can make fragment transactions such as adding, removing, or replacing a fragment. In your , you can get an instance of the , which can be used to create a . Then, you can instantiate your fragment within your activity's method using , passing in the ID of the container in your layout and the fragment class you want to add and then commit the transaction, as shown in the following example:\n\nIn the previous example, note that the fragment transaction is only created when is . This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, is no longer , and the fragment does not need to be added a second time, as the fragment is automatically restored from the .\n\nIf your fragment requires some initial data, arguments can be passed to your fragment by providing a in the call to , as shown below:\n\nThe arguments can then be retrieved from within your fragment by calling , and the appropriate getter methods can be used to retrieve each argument.\n\nFragment transactions and the are covered in more detail in the Fragment manager guide."
    },
    {
        "link": "https://developer.android.com/guide/fragments/fragmentmanager",
        "document": "is the class responsible for performing actions on your app's fragments, such as adding, removing, or replacing them and adding them to the back stack.\n\nYou might never interact with directly if you're using the Jetpack Navigation library, as it works with the on your behalf. However, any app using fragments is using at some level, so it's important to understand what it is and how it works.\n• How to access the .\n• The role of in relation to your activities and fragments.\n• How to manage the back stack with .\n• How to provide data and dependencies to your fragments.\n\nYou can access the from an activity or from a fragment.\n\nand its subclasses, such as , have access to the through the method.\n\nFragments can host one or more child fragments. Inside a fragment, you can get a reference to the that manages the fragment's children through . If you need to access its host , you can use .\n\nHere are a couple of examples to see the relationships between fragments, their hosts, and the instances associated with each.\n\nFigure 1 shows two examples, each of which has a single activity host. The host activity in both of these examples displays top-level navigation to the user as a that is responsible for swapping out the host fragment with different screens in the app. Each screen is implemented as a separate fragment.\n\nThe host fragment in Example 1 hosts two child fragments that make up a split-view screen. The host fragment in Example 2 hosts a single child fragment that makes up the display fragment of a swipe view.\n\nGiven this setup, you can think about each host as having a associated with it that manages its child fragments. This is illustrated in figure 2 along with property mappings between , , and .\n\nThe appropriate property to reference depends on where the callsite is in the fragment hierarchy along with which fragment manager you are trying to access.\n\nOnce you have a reference to the , you can use it to manipulate the fragments being displayed to the user.\n\nGenerally speaking, your app consists of a single or small number of activities in your application project, with each activity representing a group of related screens. The activity might provide a point to place top-level navigation and a place to scope objects and other view-state between fragments. A fragment represents an individual destination in your app.\n\nIf you want to show multiple fragments at once, such as in a split-view or a dashboard, you can use child fragments that are managed by your destination fragment and its child fragment manager.\n\nOther use cases for child fragments are the following:\n• Screen slides, using a in a parent fragment to manage a series of child fragment views.\n• Jetpack Navigation uses child fragments as individual destinations. An activity hosts a single parent and fills its space with different child destination fragments as users navigate through your app.\n\nThe manages the fragment back stack. At runtime, the can perform back stack operations like adding or removing fragments in response to user interactions. Each set of changes is committed together as a single unit called a . For a more in-depth discussion about fragment transactions, see the fragment transactions guide.\n\nWhen the user taps the Back button on their device, or when you call , the top-most fragment transaction pops off of the stack. If there are no more fragment transactions on the stack, and if you aren't using child fragments, the Back event bubbles up to the activity. If you are using child fragments, see special considerations for child and sibling fragments.\n\nWhen you call on a transaction, the transaction can include any number of operations, such as adding multiple fragments or replacing fragments in multiple containers.\n\nWhen the back stack is popped, all these operations reverse as a single atomic action. However, if you committed additional transactions prior to the call, and if you didn't use for the transaction, these operations don't reverse. Therefore, within a single , avoid interleaving transactions that affect the back stack with those that don't.\n\nTo display a fragment within a layout container, use the to create a . Within the transaction, you can then perform an or operation on the container.\n\nFor example, a simple might look like this:\n\nIn this example, replaces the fragment, if any, that is currently in the layout container identified by the ID. Providing the fragment's class to the method lets the handle instantiation using its . For more information, see the Provide dependencies to your fragments section.\n\noptimizes the state changes of the fragments involved in the transaction so that animations and transitions work correctly. For more information on navigating with animations and transitions, see Fragment transactions and Navigate between fragments using animations.\n\nCalling commits the transaction to the back stack. The user can later reverse the transaction and bring back the previous fragment by tapping the Back button. If you added or removed multiple fragments within a single transaction, all those operations are undone when the back stack is popped. The optional name provided in the call gives you the ability to pop back to a specific transaction using .\n\nIf you don't call when you perform a transaction that removes a fragment, then the removed fragment is destroyed when the transaction is committed, and the user cannot navigate back to it. If you do call when removing a fragment, then the fragment is only and is later when the user navigates back. Its view is destroyed in this case. For more information, see Fragment lifecycle.\n\nYou can get a reference to the current fragment within a layout container by using . Use to look up a fragment either by the given ID when inflated from XML or by the container ID when added in a . Here's an example:\n\nAlternatively, you can assign a unique tag to a fragment and get a reference using . You can assign a tag using the XML attribute on fragments that are defined within your layout or during an or operation within a .\n\nOnly one can control the fragment back stack at any given time. If your app shows multiple sibling fragments on the screen at the same time, or if your app uses child fragments, then one is designated to handle your app's primary navigation.\n\nTo define the primary navigation fragment inside of a fragment transaction, call the method on the transaction, passing in the instance of the fragment whose has primary control.\n\nConsider the navigation structure as a series of layers, with the activity as the outermost layer, wrapping each layer of child fragments underneath. Each layer has a single primary navigation fragment.\n\nWhen the Back event occurs, the innermost layer controls navigation behavior. Once the innermost layer has no more fragment transactions from which to pop back, control returns to the next layer out, and this process repeats until you reach the activity.\n\nWhen two or more fragments are displayed at the same time, only one of them is the primary navigation fragment. Setting a fragment as the primary navigation fragment removes the designation from the previous fragment. Using the preceding example, if you set the detail fragment as the primary navigation fragment, the main fragment's designation is removed.\n\nIn some cases, your app might need to support multiple back stacks. A common example is if your app uses a bottom navigation bar. lets you support multiple back stacks with the and methods. These methods let you swap between back stacks by saving one back stack and restoring a different one.\n\nworks similarly to calling with the optional parameter: the specified transaction and all transactions after it on the stack are popped. The difference is that saves the state of all fragments in the popped transactions.\n\nFor example, suppose you previously added a fragment to the back stack by committing a using , as shown in the following example:\n\nIn that case, you can save this fragment transaction and the state of by calling :\n\nYou can call with the same name parameter to restore all of the popped transactions and all of the saved fragment states:\n\nWhen adding a fragment, you can instantiate the fragment manually and add it to the .\n\nWhen you commit the fragment transaction, the instance of the fragment you created is the instance used. However, during a configuration change, your activity and all of its fragments are destroyed and then recreated with the most applicable Android resources. The handles all of this for you: it recreates instances of your fragments, attaches them to the host, and recreates the back stack state.\n\nBy default, the uses a that the framework provides to instantiate a new instance of your fragment. This default factory uses reflection to find and invoke a no-argument constructor for your fragment. This means that you can't use this default factory to provide dependencies to your fragment. It also means that any custom constructor you used to create your fragment the first time is not used during recreation by default.\n\nTo provide dependencies to your fragment, or to use any custom constructor, instead create a custom subclass and then override . You can then override the default factory of the with your custom factory, which is then used to instantiate your fragments.\n\nSuppose you have a that is responsible for displaying popular desserts in your hometown, and that has a dependency on a class that provides it with the information it needs to display the correct UI to your user.\n\nYou might define your to require a instance in its constructor.\n\nA simple implementation of your might look similar to the following.\n\nThis example subclasses , overriding the method to provide custom fragment creation logic for a . Other fragment classes are handled by the default behavior of through .\n\nYou can then designate as the factory to use when constructing your app's fragments by setting a property on the . You must set this property prior to your activity's to ensure that is used when recreating your fragments.\n\nSetting the in the activity overrides fragment creation throughout the activity's fragment hierarchy. In other words, the of any child fragments you add uses the custom fragment factory set here unless overridden at a lower level.\n\nIn a single activity architecture, test your fragments in isolation using the class. Since you can't rely on the custom logic of your activity, you can instead pass the in as an argument to your fragments test, as shown in the following example:\n\nFor detailed information about this testing process and for full examples, see Test your fragments."
    },
    {
        "link": "https://developer.android.com/guide/fragments/communicate",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nTo reuse fragments, build them as completely self-contained components that define their own layout and behavior. Once you define these reusable fragments, you can associate them with an activity and connect them with the application logic to realize the overall composite UI.\n\nTo properly react to user events and to share state information, you often need to have channels of communication between an activity and its fragments or between two or more fragments. To keep fragments self-contained, don't have fragments communicate directly with other fragments or with their host activity.\n\nThe library provides two options for communication: a shared and the Fragment Result API. The recommended option depends on the use case. To share persistent data with custom APIs, use a . For a one-time result with data that can be placed in a , use the Fragment Result API.\n\nThe following sections show you how to use and the Fragment Result API to communicate between your fragments and activities.\n\nis an ideal choice when you need to share data between multiple fragments or between fragments and their host activity. objects store and manage UI data. For more information about , see ViewModel overview.\n\nIn some cases, you might need to share data between fragments and their host activity. For example, you might want to toggle a global UI component based on an interaction within a fragment.\n\nConsider the following :\n\nIn this example, the stored data is wrapped in a class. is a lifecycle-aware observable data holder class. lets its value be changed. For more information about , see LiveData overview.\n\nBoth your fragment and its host activity can retrieve a shared instance of a with activity scope by passing the activity into the constructor. The handles instantiating the or retrieving it if it already exists. Both components can observe and modify this data.\n\nTwo or more fragments in the same activity often need to communicate with each other. For example, imagine one fragment that displays a list and another that lets the user apply various filters to the list. Implementing this case isn't trivial without the fragments communicating directly, but then they are no longer self-contained. Additionally, both fragments must handle the scenario where the other fragment is not yet created or visible.\n\nThese fragments can share a using their activity scope to handle this communication. By sharing the in this way, the fragments don't need to know about each other, and the activity doesn't need to do anything to facilitate the communication.\n\nThe following example shows how two fragments can use a shared to communicate:\n\nBoth fragments use their host activity as the scope for the . Because the fragments use the same scope, they receive the same instance of the , which enables them to communicate back and forth.\n\nWhen working with child fragments, your parent fragment and its child fragments might need to share data with each other. To share data between these fragments, use the parent fragment as the scope, as shown in the following example:\n\nIf you're using the Navigation library, you can also scope a to the lifecycle of a destination's . For example, the can be scoped to the for the :\n\nFor more information about scoping a to a , see Interact programmatically with the Navigation component.\n\nGet results using the Fragment Result API\n\nIn some cases, you might want to pass a one-time value between two fragments or between a fragment and its host activity. For example, you might have a fragment that reads QR codes, passing the data back to a previous fragment.\n\nIn Fragment version 1.3.0 and higher, each implements . This means that a can act as a central store for fragment results. This change lets components communicate with each other by setting fragment results and listening for those results, without requiring those components to have direct references to each other.\n\nTo pass data back to fragment A from fragment B, first set a result listener on fragment A, the fragment that receives the result. Call on fragment A's , as shown in the following example:\n\nIn fragment B, the fragment producing the result, set the result on the same by using the same . You can do so by using the API:\n\nFragment A then receives the result and executes the listener callback once the fragment is .\n\nYou can have only a single listener and result for a given key. If you call more than once for the same key, and if the listener is not , the system replaces any pending results with your updated result.\n\nIf you set a result without a corresponding listener to receive it, the result is stored in the until you set a listener with the same key. Once a listener receives a result and fires the callback, the result is cleared. This behavior has two major implications:\n• Fragments on the back stack do not receive results until they have been popped and are .\n• If a fragment listening for a result is when the result is set, the listener's callback then fires immediately.\n\nUse to test calls to and . Create a scenario for the fragment under test by using or , and then manually call the method that isn't being tested.\n\nTo test , create a scenario with the fragment that makes the call to . Next, call directly, and verify the result:\n\nTo test , create a scenario with the fragment that makes the call to . Next, call directly, and verify the result:\n\nTo pass a result from a child fragment to a parent, use from the parent fragment instead of when calling .\n\nThe child fragment sets the result on its . The parent then receives the result once the fragment is :\n\nTo receive a fragment result in the host activity, set a result listener on the fragment manager using ."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-new-fragment-in-android-studio",
        "document": "Android Studio is the official integrated development environment for Google’s Android operating system, built on JetBrains’ IntelliJ IDEA software and designed specifically for Android development. You can Develop Android App using this. Here, We are going to learn how to create a new Fragment in Android Studio. A Fragment is a piece of an activity that enables a more modular activity design. A fragment is easier to reuse within activities and layouts. Android devices have a variety of screen sizes and densities. It simplifies the reuse of components in different layouts and their logic. We can also use fragments also to support different layouts for landscape and portrait orientation on a smartphone.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio.\n\nRight click on the app folder, then go to New > Fragment. The next step is to choose the Fragment type. Fragment in Android refers to a single screen with a user interface.\n\nIn the dialog, fill in the Fragment Name text field. In Android studio, files named in CamelCase are preferred. An XML file is used to provide functionalities of the user interface for our app. An XML file of the fragment is created using the first word in the fragment name.\n\nThe fragment will be successfully created along with a xml layout file."
    },
    {
        "link": "https://developer.android.com/topic/performance/sqlite-performance-best-practices",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAndroid offers built-in support for SQLite, an efficient SQL database. Follow these best practices to optimize your app's performance, ensuring it remains fast and predictably fast as your data grows. By using these best practices, you also reduce the possibility of encountering performance issues that are difficult to reproduce and troubleshoot.\n• None Read fewer rows and columns: Optimize your queries to retrieve only the necessary data. Minimize the amount of data read from the database, because excess data retrieval can impact performance.\n• None Push work to SQLite engine: Perform computations, filtering, and sorting operations within the SQL queries. Using SQLite's query engine can significantly improve performance.\n• None Modify the database schema: Design your database schema to help SQLite construct efficient query plans and data representations. Properly index tables and optimize table structures to enhance performance.\n\nAdditionally, you can use the available troubleshooting tools to measure the performance of your SQLite database to help identify areas that require optimization.\n\nWe recommend using the Jetpack Room library.\n\nFollow the steps in this section to configure your database for optimal performance in SQLite.\n\nSQLite implements mutations by appending them to a log, which it occasionally compacts into the database. This is called Write-Ahead Logging (WAL).\n\nEnable WAL unless you are using .\n\nWhen using WAL, by default every commit issues an to help ensure that the data reaches the disk. This improves data durability but slows down your commits.\n\nSQLite has an option to control synchronous mode. If you enable WAL, set synchronous mode to :\n\nIn this setting, a commit can return before the data is stored in a disk. If a device shutdown occurs, such as on loss of power or a kernel panic, the committed data might be lost. However, because of logging, your database isn't corrupted.\n\nIf only your app crashes, your data still reaches the disk. For most apps, this setting yields performance improvements at no material cost.\n\nTo optimize performance and minimize data consumption, define an efficient table schema. SQLite constructs efficient query plans and data, leading to faster data retrieval. This section provides best practices for creating table schemas.\n\nFor this example, define and populate a table as follows:\n\nThe table output is as follows:\n\nThe column is an index that preserves insertion order. Queries that filter by are implemented as a fast B-tree search, but queries that filter by are a slow table scan.\n\nIf you plan on doing lookups by , you can avoid storing the column for less data in storage and an overall faster database:\n\nYour table now looks as follows:\n\nSince you don't need to store the column, queries are fast. Note that the table is now sorted based on instead of insertion order.\n\nSQLite uses indexes to accelerate queries. When filtering ( ), sorting ( ), or aggregating ( ) a column, if the table has an index for the column, the query is accelerated.\n\nIn the previous example, filtering by requires scanning the entire table:\n\nFor an app with a lot of city queries, you can accelerate those queries with an index:\n\nAn index is implemented as an additional table, sorted by the index column and mapped to :\n\nNote that the storage cost of the column is now double, because it's now present in both the original table and the index. Since you are using the index, the cost of added storage is worth the benefit of faster queries. However, don't maintain an index that you're not using to avoid paying the storage cost for no query performance gain.\n\nIf your queries combine multiple columns, you can create multi-column indexes to fully accelerate the query. You can also use an index on an outside column and let the inside search be done as a linear scan.\n\nFor instance, given the following query:\n\nYou can accelerate the query with a multi-column index in the same order as specified in the query:\n\nHowever, if you only have an index on , the outside ordering is still accelerated, while the inside ordering requires a linear scan.\n\nThis also works with prefix inquiries. For example, an index also accelerates filtering, ordering, and grouping by , since the index table for a multi-column index is ordered by the given indexes in the given order.\n\nBy default, SQLite creates a column for your table, where is an implicit . If you already have a column that is , then this column becomes an alias of .\n\nFor tables that have a primary key other than or a composite of columns, consider .\n\nStore small data as a and large data as a file\n\nIf you want to associate large data with a row, such as a thumbnail of an image or a photo for a contact, you can store the data either in a column or in a file, and then store the file path in the column.\n\nFiles are generally rounded up to 4 KB increments. For very small files, where the rounding error is significant, it's more efficient to store them in the database as a . SQLite minimizes filesystem calls and is faster than the underlying filesystem in some cases.\n\nFollow these best practices to improve query performance in SQLite by minimizing response times and maximizing processing efficiency.\n\nRead only the rows you need\n\nFilters let you narrow down your results by specifying certain criteria, such as date range, location, or name. Limits let you control the number of results you see:\n\nRead only the columns you need\n\nAvoid selecting unneeded columns, which can slow down your queries and waste resources. Instead, only select columns that are used.\n\nIn the following example, you select , , and :\n\nHowever, you only need the column:\n\nParameterize queries with SQL Cards, not with String concatenation\n\nYour query string might include a parameter that is only known at runtime, such as the following:\n\nIn the preceding code, every query constructs a different string, and thus doesn't benefit from the statement cache. Each call requires SQLite to compile it before it can execute. Instead, you can replace the argument with a parameter and bind the value with :\n\nNow the query can be compiled once and cached. The compiled query is reused between different invocations of .\n\nIterate in SQL, not in code\n\nUse a single query that returns all targeted results, instead of a programmatic loop iterating on SQL queries to return individual results. The programmatic loop is about 1000 times slower than a single SQL query.\n\nUsing the keyword can improve the performance of your queries by reducing the amount of data that needs to be processed. For example, if you want to return only the unique values from a column, use :\n\nUse aggregate functions whenever possible\n\nUse aggregate functions for aggregate results without row data. For example, the following code checks whether there is at least one matching row:\n\nTo only fetch the first row, you can use to return if a matching row does not exist and if one or more rows match:\n\nUse SQLite aggregate functions in your app code:\n• : counts how many rows are in a column.\n• or : determines the lowest or highest value. Works for numeric columns, types, and text types.\n\nUse instead of\n\nIn the following example, the function reads all the rows from the database and returns all the row values:\n\nHowever, by using , the database returns only the count:\n\nSQL is composable and supports subqueries, joins, and foreign key constraints. You can use the result of one query in another query without going through app code. This reduces the need to copy data from SQLite and lets the database engine optimize your query.\n\nIn the following example, you can run a query to find which city has the most customers, then use the result in another query to find all the customers from that city:\n\nTo get the result in half the time of the previous example, use a single SQL query with nested statements:\n\nIf a row must not be inserted unless a particular column value is unique in the table, then it might be more efficient to enforce that uniqueness as a column constraint.\n\nIn the following example, one query is run to validate the row to be inserted and another to actually insert:\n\nInstead of checking the unique constraint in Kotlin or Java, you can check it in SQL when you define the table:\n\nSQLite does the same as the following:\n\nNow you can insert a row and let SQLite check the constraint:\n\nSQLite validates constraints faster and with less overhead than Kotlin or Java code. It is a best practice to use SQLite rather than app code.\n\nA transaction commits multiple operations, which improves not only efficiency but also correctness. To improve data consistency and accelerate performance, you can batch insertions:\n\nSQLite provides the following troubleshooting tools to help measure performance.\n\nRun SQLite on your machine to run queries and learn. Different Android platform versions use different revisions of SQLite. To use the same engine that's on an Android-powered device, use and run on your target device.\n\nYou can ask SQLite to time queries:\n\nYou can ask SQLite to explain how it intends to answer a query by using :\n\nThe previous example requires a full table scan without an index to find all customers from Paris. This is called linear complexity. SQLite needs to read all the rows and only keep the rows that match customers from Paris. To fix this, you can add an index:\n\nIf you're using the interactive shell, you can ask SQLite to always explain query plans:\n\nFor more information, see Query Planning.\n\nSQLite offers the command-line interface (CLI) to dump additional information that can be used to troubleshoot performance. To install, visit the SQLite Download Page.\n\nYou can use to download a database file from a target device to your workstation for analysis:\n\nYou can also install the GUI tool SQLite Browser on the SQLite Downloads page.\n\nAndroid times SQLite queries and logs them for you:\n\nWhen configuring Perfetto, you may add the following to include tracks for individual queries:"
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n• There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n• You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://medium.com/@shivani.patel18/a-comprehensive-guide-to-sqlite-databases-in-android-development-df74f01df6c3",
        "document": "In the world of Mobile app development, data persistence is a fundamental aspect. Whether you are building a to-do list app, a note-taking app, or a complex e-commerce platform, the need to store and manage data efficiently arises in almost every application. SQLite, a lightweight and efficient relational database, is the go-to choice for many Android developers due to its simplicity and robustness.\n\nSQLite is an open-source relational database i.e. used to perform database operations on android devices such as storing, manipulating or retrieving persistent data from the database. It is embedded in android by default. So, there is no need to perform any database setup or administration task.\n\nThis article helps to provide a comprehensive guide to working with SQLite databases in Android development. We will cover the following topics:\n• Why Use SQLite in Android?\n\nSQLite is a self-contained, serverless, and transactional SQL database engine. It is embedded into the Android operating system, making it an ideal choice for local data storage in Android applications. SQLite databases are lightweight, efficient, and easy to use, making them a popular choice for developers.\n\n2. Why Use SQLite in Android?\n\nThere are several reasons why SQLite is a preferred choice for data storage in Android applications:\n• Lightweight: SQLite is designed to be lightweight and has a small footprint, making it suitable for mobile devices with limited resources.\n• Reliability: It is ACID compliant (Atomicity, Consistency, Isolation, Durability), ensuring data integrity and reliability.\n• Speed: SQLite operations are fast, and it provides efficient indexing mechanisms for quick data retrieval.\n• Compatibility: SQLite is built into the Android OS, so you don’t need to include additional libraries in your app.\n• No Network Dependency: Unlike client-server databases, SQLite doesn’t require a network connection, making it ideal for offline applications.\n\nTo start using SQLite in your Android project, follow these steps:\n• Create a Database Helper Class: Create a subclass of to manage database creation, version management, and connection.\n\n2. Initialize the Database: Open or create the database in your app’s method.\n\nTo create a SQLite database, you need to define its structure using SQL statements. Use the method of your subclass to execute these statements. Here's a simple example:\n\nSQLiteOpenHelper class provides the functionality to use the SQLite database.\n\nSQLite supports all the standard CRUD (Create, Read, Update, Delete) operations. Here’s a brief overview:\n• Create: Use the statement to add new records to the database.\n• Read: Use the statement to retrieve data from the database.\n• Update: Use the statement to modify existing records.\n• Delete: Use the statement to remove records.\n\nThe class is used for database creation and version management. It helps you handle upgrades and downgrades of your database schema. For performing any database operation, you have to provide the implementation of onCreate() and onUpgrade() methods of SQLiteOpenHelper class.\n\nThere are two constructors of SQLiteOpenHelper class.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) :- creates an object for creating, opening and managing the database.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) :- creates an object for creating, opening and managing the database. It specifies the error handler.\n• public abstract void onCreate(SQLiteDatabase db) :- called only once when database is created for the first time.\n• public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be upgraded.\n• public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be downgraded.\n• Always use parameterized queries to prevent SQL injection.\n• Avoid opening and closing the database frequently; instead, use a singleton pattern for database access.\n• Handle database operations on a background thread to avoid blocking the UI thread.\n• Monitor and optimize database queries for performance using tools like Android Profiler.\n\nLet’s see the simple example of android sqlite database.\n\nNow, let’s create the database handler class that extends SQLiteOpenHelper class and provides the implementation of its methods.\n\npublic class DatabaseHandler extends SQLiteOpenHelper {\n\n private static final int DATABASE_VERSION = 1;\n\n private static final String DATABASE_NAME = \"studentlist\";\n\n private static final String TABLE_STUDENTS = \"students\";\n\n private static final String KEY_ID = \"id\";\n\n private static final String KEY_NAME = \"name\";\n\n\n\n public DatabaseHandler(Context context) {\n\n super(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n //3rd argument to be passed is CursorFactory instance\n\n }\n\n\n\n // Creating Tables\n\n @Override\n\n public void onCreate(SQLiteDatabase db) {\n\n String CREATE_STUDENTS_TABLE = \"CREATE TABLE \" + TABLE_STUDENTS + \"(\"\n\n + KEY_ID + \" INTEGER PRIMARY KEY,\" \n\n + KEY_NAME + \" TEXT\"\n\n + \")\";\n\n db.execSQL(CREATE_STUDENTS_TABLE);\n\n }\n\n \n\n // Upgrading database\n\n @Override\n\n public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n // Drop older table if existed\n\n db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_STUDENTS);\n\n\n\n // Create tables again\n\n onCreate(db);\n\n }\n\n\n\n // code to add the new student\n\n void addStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName()); // studentName\n\n\n\n // Inserting Row\n\n db.insert(TABLE_STUDENTS, null, values);\n\n //2nd argument is String containing nullColumnHack\n\n db.close(); // Closing database connection\n\n }\n\n\n\n // code to get the single student\n\n StudentList getStudent(int id) {\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n\n\n Cursor cursor = db.query(TABLE_STUDENTS, \n\n new String[] { KEY_ID, KEY_NAME}, KEY_ID + \"=?\",\n\n new String[] { String.valueOf(id) }, \n\n null, null, null, null);\n\n if (cursor != null)\n\n cursor.moveToFirst();\n\n\n\n StudentList studentList = new StudentList(Integer.parseInt(cursor.getString(0)),\n\n cursor.getString(1), \n\n cursor.getString(2));\n\n // return studentList\n\n return studentList;\n\n }\n\n\n\n\n\n // code to get all student in a list view\n\n public List<StudentList> getAllStudentList() {\n\n List<StudentList> studentList = new ArrayList<StudentList>();\n\n // Select All Query\n\n String selectQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n Cursor cursor = db.rawQuery(selectQuery, null);\n\n\n\n // looping through all rows and adding to list\n\n if (cursor.moveToFirst()) {\n\n do {\n\n StudentList student = new StudentList();\n\n student.setID(Integer.parseInt(cursor.getString(0)));\n\n student.setName(cursor.getString(1));\n\n // Adding student to list\n\n studentList.add(student);\n\n } while (cursor.moveToNext());\n\n }\n\n\n\n // return student list\n\n return studentList;\n\n }\n\n\n\n // code to update the single student\n\n public int updateStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName());\n\n\n\n // updating row\n\n return db.update(TABLE_STUDENTS, values, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n }\n\n\n\n\n\n // Deleting single student\n\n public void deleteStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n db.delete(TABLE_STUDENTS, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n db.close();\n\n }\n\n\n\n\n\n // Getting student Count\n\n public int getStudentListCount() {\n\n String countQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n Cursor cursor = db.rawQuery(countQuery, null);\n\n cursor.close();\n\n\n\n // return count\n\n return cursor.getCount();\n\n }\n\n\n\n}\n\nIn the main activity of the app, call the function to initialize the DB\n\nSQLite is a powerful and reliable choice for managing local data storage in Android applications. Understanding how to create and manipulate SQLite databases is a valuable skill for any Android developer. By following the best practices outlined in this guide, you can ensure your Android apps perform efficiently and provide a seamless user experience.\n\nIncorporate SQLite into your Android projects, experiment with different database structures, and leverage the flexibility it offers to create data-driven applications that meet your users’ needs. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/28881583/best-way-to-store-and-retrieve-data-locally-in-android",
        "document": "Assuming that the table creation only happens once when the app is installed, then unless the table creation is very, very slow you can simply do it at app first install and include some appropriate message to the user on the screen.\n\nIdeally, if your app can do other useful things without using the data then you can let the user use other parts of the app while the table creation completes in the background.\n\nI have found from past experience that creating very large simple tables is actually very fast, but you would need to test to see how long your examples take.\n\nNote also that you have the option, through the onUpgrade method of the SQLiteOpenHelper, to only modify the parts of the database that you need to at upgrade times, so you may not have to recreate the full data base when installing new versions of the app. This also includes mechanisms to avoid delaying app startup by deferring the updates until the database is first used, although that may not be what you want in this case."
    },
    {
        "link": "https://stackoverflow.com/questions/1725880/best-practices-for-sqlite-db-and-contentprovider",
        "document": "My Android app is reading and writing to a local SQLite DB from a few different Activities and a Service. Pretty standard. But I'm not happy with the way I've got all the DB details stored as constants that I then use anywhere I access the DB. I've been advised to wrap the DB in a ContentProvider. Sounds good to me. While I'm refactoring my code, I figured I'd ask:\n• What are your best practices for local DB data storage in Android?\n• Where and how do you store \"CREATE TABLE\" statements, column names, other SQL?\n• Would you mind sharing a list of the classes you instantiate and what goes into each (ContentProvider, DatabaseProvider, DatabaseHelper...)?\n• How do you coordinate the structure of your local Android DB with a server-side DB available through a REST interface?\n\nYeah, I realize I'm getting at the perennial \"where's the Android object-relation-mapping framework?\" question. For now, I'm mainly curious to hear how you structure your Android apps with what's available in the standard SDK.\n\nAs always, thanks for the pointers!"
    }
]