[
    {
        "link": "http://pc1500.com/technical_reference_manual.html",
        "document": ""
    },
    {
        "link": "http://basic.hopto.org/basic/manual/Sharp%20PC-1500%20Technical%20Manual.pdf",
        "document": ""
    },
    {
        "link": "https://albillo.hpcalc.org/publications/SHARP%20Book%20-%20PC-1500%20Instruction%20Manual.pdf",
        "document": ""
    },
    {
        "link": "https://pockemul.com/wp-content/uploads/2020/05/PC1500A_OM_EN.pdf",
        "document": ""
    },
    {
        "link": "http://basic.hopto.org/basic/manual/Sharp%20PC-1500%20Manual%20de%20instrucciones%20EN.pdf",
        "document": ""
    },
    {
        "link": "https://freecodecamp.org/news/random-number-generator",
        "document": "People have been using random numbers for millennia, so the concept isn't new. From the lottery in ancient Babylon, to roulette tables in Monte Carlo, to dice games in Vegas, the goal is to leave the end result up to random chance.\n\nBut gambling aside, randomness has many uses in science, statistics, cryptography and more. Yet using dice, coins, or similar media as a random device has its limitations.\n\nBecause of the mechanical nature of these techniques, generating large quantities of random numbers requires great deal of time and work. Thanks to human ingenuity, we have more powerful tools and methods at our disposal.\n\nLet's consider two principal methods used to generate random numbers. The first method is based on a physical process, and harvests the source of randomness from some physical phenomenon that is expected to be random.\n\nSuch a phenomenon takes place outside of the computer. It is measured and adjusted for possible biases due to the measurement process. Examples include radioactive decay, the photoelectric effect, cosmic background radiation, atmospheric noise (which we will use in this article), and more.\n\nThus, random numbers generated based on such randomness are said to be \"true\" random numbers.\n\nTechnically, the hardware part consists of a device that converts energy from one form to another (for example, radiation to an electrical signal), an amplifier, and an analog-to-digital converter to turn the output into a digital number.\n\n_Picture of computer code flowing through computer screen. Photo by Markus Spiske._\n\nAs an alternative to \"true\" random numbers, the second method of generating random numbers involves computational algorithms that can produce apparently random results.\n\nWhy apparently random? Because the end results obtained are in fact completely determined by an initial value also known as the seed value or key. Therefore, if you knew the key value and how the algorithm works, you could reproduce these seemingly random results.\n\nRandom number generators of this type are frequently called Pseudorandom number generators and, as a result, output Pseudorandom Numbers.\n\nEven though this type of generator typically doesn't gather any data from sources of naturally occurring randomness, such gathering of keys can be made possible when needed.\n\nLet's compare some aspects of true random number generators or TRNGs and pseudorandom number generators or PRNGs.\n\nPRNGs are faster than TRNGs. Because of their deterministic nature, they are useful when you need to replay a sequence of random events. This helps a great deal in code testing, for example.\n\nOn the other hand, TRNGs are not periodic and work better in security sensitive roles such as encryption.\n\nA period is the number of iterations a PRNG goes through before it starts repeating itself. Thus, all other things being equal, a PRNG with a longer period would take more computer resources to predict and crack.\n\nA computer executes code that is based on a set of rules to be followed. For PRNGs in general, those rules revolve around the following:\n• Accept some initial input number, that is a seed or key.\n• Apply that seed in a sequence of mathematical operations to generate the result. That result is the random number.\n• Use that resulting random number as the seed for the next iteration.\n\nNow let's look at an example.\n\nThis generator produces a series of pseudorandom numbers. Given an initial seed X and integer parameters a as the multiplier, b as the increment, and m as the modulus, the generator is defined by the linear relation: X ≡ (aX + b)mod m. Or using more programming friendly syntax: X = (a * X + b) % m.\n\nEach of these members have to satisfy the following conditions:\n• 0 < a < m (the multiplier is positive but less than the modulus),\n• 0 ≤ b < m (the increment is non negative but less than the modulus), and\n• 0 ≤ X < m (the seed is non negative but less than the modulus).\n\nLet's create a JavaScript function that takes the initial values as arguments and returns an array of random numbers of a given length:\n\nThe Linear Congruential Generator is one of the oldest and best-known PRNG algorithms.\n\nAs for random number generator algorithms that are executable by computers, they date back as early as the 1940s and 50s (the Middle-square method and Lehmer generator, for example) and continue to be written today (Xoroshiro128+, Squares RNG, and more).\n\nWhen I decided to write this article about embedding a random number generator within a web page, I had a choice to make.\n\nI could've used JavaScript's function as the base and generate output in pseudorandom numbers like I have in earlier articles (see Multiplication Chart - Code Your Own Times Table).\n\nBut this article itself is about generating random numbers. So I decided to learn how to gather \"true\" randomness based data and share my discovery with you.\n\nSo below is the \"true\" Random Number Generator. Set the parameters and hit Generate.\n\nThe code fetches data from one of the APIs, courtesy of Random.org. This online resource has a plethora of useful, customizable tools and comes with excellent documentation to go with it.\n\nThe randomness comes from atmospheric noise. I was able to use asynchronous functions. That is a huge benefit going forward. The core function looks like this:\n\nThe parameters it takes allow a user to customize random number output. For example, min and max allow you to set lower and upper limits on generated output. And base determines if the output is printed as binary, decimal or hexadecimal.\n\nAgain, I chose this configuration but there are many more available at the source.\n\nWhen you click the Generate button, the function is called. It in turn invokes the asynchronous function, manages error handling, and outputs results:\n\nThe rest of the code deals with HTML structure, appearance, and styling.\n\nThe code is ready to be embedded and used within this web page. I separated it into component parts and supplied it with detailed comments. It can easily be modified. You can also modify the functionality and styles as your needs require.\n\nThis is the link to the GitHub repo of the complete code: https://github.com/sandroarobeli/random-generator"
    },
    {
        "link": "https://albillo.hpcalc.org/publications/SHARP%20Book%20-%20PC-1500A%20Instruction%20Manual.pdf",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Sharp_PC-1500",
        "document": "The Sharp PC-1500 was a pocket computer produced by Sharp between 1981 and 1985. A rebadged version was also sold as the TRS-80 Pocket Computer PC-2.\n\nThe whole computer was designed around the LH5801, an 8-bit CPU similar to the Zilog Z80, but all laid-out in power-saving CMOS circuits. Equipped with 2 KB of on-board RAM, the programming language is BASIC. Later, German engineers provided an assembler for the machine.[1] Later even a C compiler followed. An external slot is available and accepts memory (from 4 KB to 32 KB) and ROM modules.\n\nEight versions of this pocket computer with 2 KB memory:[2]\n• Sharp PC-1500 - Japanese version with blue paint around LCD. CE-157 Kana module bundle model. Known as PC-1500D (1984)\n• Connector for external power supply (Official adaptor is Sharp EA-150, rated at 500 mA at 9 V, comes with the CE-150 printer interface.)\n• CE-150 4-colour printer/plotter and cassette interface in travel case. Known as KA-160 with PTA-4000.\n• CE-152 Cassette recorder (as external storage) (same as General Electric 3-5160A 3 )\n• CE-158 Communication dock with RS-232C and parallel interface with (4 rechargeable, shrink-wrapped, permanently built-in) NiCd battery (AA) as additional power supply for the computer.\n• CE-163 32 KB (2x16 KB) dual-page memory module with CR2032 battery data backup. Only one page (16 KB) can be accessed at a time, switchable via the following command in PROG mode:\n• Sharp PC-1600 with more memory and larger multi-line LCD display and more graphics capabilities\n\nSome earlier model PC-1500s will show a value 1 less in the FOR...NEXT counter on exiting the loop compared to later PC-1500s and the PC-1600.[4]\n\nK will be set to 11 on later model PC-1500s and PC-1600s, but will be 10 on early PC-1500s.\n\nConsider this example:\n\nS will be set to 3 on later model PC-1500s and PC-1600s, but will be 4 on early PC-1500s.\n\nEarly model PC-1500s evaluate IF...THEN statements differently. The behaviour can be summarised thus:\n\nAn early model PC-1500 can be detected by using the command: .\n\nIf the value returned is 6, it is an early model.\n\nThe PC-1500 allows special abbreviations, and the syntax can also look as follows:\n\nThe design of initial prototypes of EMKE series of public transport cash registers were built around customized versions of the PC-1500 and its Hungarian clone PTA-4000. The series production models used almost exclusively in Hungarian regional and national bus services up to present day, are built around a version designed by EMKE and are heavily influenced by the PC-1500 design.[5]\n\nWith the SHARP PC-1500A emulator and the PockEmul you can emulate a PC-1500A.\n• None SHARP Taschencomputer Modell PC-1500A Bedienungsanleitung [SHARP Pocket Computer Model PC-1500A Operation Manual] (in German). 4LQ.3T(TINSG3993CCZZ)5. Archived from the original on 2017-02-25 ."
    },
    {
        "link": "https://pockemul.com/wp-content/uploads/2020/05/PC1500A_OM_EN.pdf",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/computerscience/comments/1acir7n/how_tf_do_computers_generate_random_numbers",
        "document": "Hi guys, I’ve been using random number generators lately and I can’t seem to figure out how a computer can generate a random number. Don’t they just do what they’re told? Please explain like im stupid Edit: holy moly this is blowing up"
    }
]