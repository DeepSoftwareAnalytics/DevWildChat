[
    {
        "link": "https://geeksforgeeks.org/rsa-algorithm-cryptography",
        "document": "RSA(Rivest-Shamir-Adleman) Algorithm is an asymmetric or public-key cryptography algorithm which means it works on two different keys: Public Key and Private Key. The Public Key is used for encryption and is known to everyone, while the Private Key is used for decryption and must be kept secret by the receiver. RSA Algorithm is named after Ron Rivest, Adi Shamir and Leonard Adleman, who published the algorithm in 1977.\n\nIf Person A wants to send a message securely to Person B:\n• decrypts the message using their Private\n• p q . These prime numbers should be kept secret.\n• n = p * q . This product is part of the public as well as the private key.\n• e\n• None gcd(e, Φ(n)) = 1, that is e should be co-prime with Φ(n).\n• d,\n• (d * e) ≡ 1 mod Φ(n) , that is d is e mod Φ(n). Some common methods to calculate multiplicative inverse are:\n• None We can have multiple values of d satisfying (d * e) ≡ 1 mod Φ(n) but it does not matter which value we choose as all of them are valid keys and will result into same message on decryption.\n\nFinally, the Public Key = (n, e) and the Private Key = (n, d).\n\nTo encrypt a message M, it is first converted to numerical representation using ASCII and other encoding schemes. Now, use the public key (n, e) to encrypt the message and get the cipher text using the formula:\n\nTo decrypt the cipher text C, use the private key (n, d) and get the original data using the formula:\n\nThe idea of RSA is based on the fact that it is difficult to factorize a large integer. The Public Key is (n, e), where n and e are publicly known, while the Private Key is (n, d). Since only the receiver knows the value of d, only they can decrypt the message. But is it possible to find the value of d using n and e?\n\nWe know that (d * e) ≡ 1 mod Φ(n), so if we can calculate the value of Φ(n), we can find the value of d. But Φ(n) = (p – 1) * (q – 1). So, we need the value of p and q. Now, one might think that it’s quite easy to find the value of p and q as n = p * q and n is already publicly known but RSA Algorithm takes the value of p and q to be very large which in turn makes the value of n extremely large and factorizing such a large value is computationally impossible.\n\nTherefore encryption strength lies in the values of p and q. RSA keys can be typically 1024 or 2048 bits long, but experts believe that 1024-bit keys could be broken shortly. But till now it seems to be an infeasible task.\n\nNote: If someone gets to know the value of p and q, then he can calculate the value of d and decrypt the message.\n\n// C++ Program for implementation of RSA Algorithm // Here we are calculating phi(n) using Hit and Trial Method // but we can optimize it using Extended Euclidean Algorithm # Here we are calculating phi(n) using Hit and Trial Method # but we can optimize it using Extended Euclidean Algorithm\n• Security: RSA algorithm is considered to be very secure and is widely used for secure data transmission.\n• Public-key cryptography: RSA algorithm is a public-key cryptography algorithm, which means that it uses two different keys for encryption and decryption. The public key is used to encrypt the data, while the private key is used to decrypt the data.\n• Key exchange: RSA algorithm can be used for secure key exchange, which means that two parties can exchange a secret key without actually sending the key over the network.\n• Digital signatures: RSA algorithm can be used for digital signatures, which means that a sender can sign a message using their private key, and the receiver can verify the signature using the sender’s public key.\n• Widely used: Online banking, e-commerce, and secure communications are just a few fields and applications where the RSA algorithm is extensively developed.\n• Slow processing speed: RSA algorithm is slower than other encryption algorithms, especially when dealing with large amounts of data.\n• Large key size: RSA algorithm requires large key sizes to be secure, which means that it requires more computational resources and storage space.\n• Vulnerability to side-channel attacks: RSA algorithm is vulnerable to side-channel attacks, which means an attacker can use information leaked through side channels such as power consumption, electromagnetic radiation, and timing analysis to extract the private key.\n• Limited use in some applications: RSA algorithm is not suitable for some applications, such as those that require constant encryption and decryption of large amounts of data, due to its slow processing speed.\n• Complexity: The RSA algorithm is a sophisticated mathematical technique that some individuals may find challenging to comprehend and use.\n• Key Management: The secure administration of the private key is necessary for the RSA algorithm, although in some cases this can be difficult.\n• Vulnerability to Quantum Computing: Quantum computers have the ability to attack the RSA algorithm, potentially decrypting the data.\n\nWhat is the RSA algorithm, and how does it work?\n\nWhat are the key components of the RSA algorithm?\n\nWhat are the primary applications of RSA?\n\nHow can I ensure the security of RSA encryption?"
    },
    {
        "link": "https://stackoverflow.com/questions/610048/rsa-encryption-decryption-compatible-with-javascript-and-php",
        "document": "I'd like to encrypt in Javascript and then decrypt in PHP. There are RSA implementations for Javascript and PHP but they are not compatible. I cannot decrypt in PHP correctly what I had encrypted with Javascript. Does anyone know a library/code that will work both with Javascript and PHP?"
    },
    {
        "link": "https://stackoverflow.com/questions/18279141/javascript-string-encryption-and-decryption",
        "document": "The existing answers which leverage SJCL, CryptoJS, and/or WebCrypto aren't necessarily wrong but they're not as safe as you might initially suspect. Generally you want to use libsodium. First I'll explain why, then how.\n\nWhy Not SJCL, CryptoJS, WebCrypto, etc.?\n\nShort answer: In order for your encryption to actually be secure, these libraries expect you to make too many choices e.g. the block cipher mode (CBC, CTR, GCM; if you can't tell which of the three I just listed is secure to use and under what constraints, you shouldn't be burdened with this sort of choice at all).\n\nUnless your job title is cryptography engineer, the odds are stacked against you implementing it securely.\n\nCryptoJS offers a handful of building blocks and expects you to know how to use them securely. It even defaults to CBC mode (archived).\n\nWebCrypto is a potluck standard, designed by committee, for purposes that are orthogonal to cryptography engineering. Specifically, WebCrypto was meant to replace Flash, not provide security.\n\nSJCL's public API and documentation begs users to encrypt data with a human-remembered password. This is rarely, if ever, what you want to do in the real world.\n\nAdditionally: Its default PBKDF2 round count is roughly 86 times as small as you want it to be. AES-128-CCM is probably fine.\n\nOut of the three options above, SJCL is the least likely to end in tears. But there are better options available.\n\nWhy is Libsodium Better?\n\nYou don't need to choose between a menu of cipher modes, hash functions, and other needless options. You'll never risk screwing up your parameters and removing all security from your protocol.\n\nInstead, libsodium just gives you simple options tuned for maximum security and minimalistic APIs.\n• / offer authenticated public-key encryption.\n• The algorithm in question combines X25519 (ECDH over Curve25519) and XSalsa20-Poly1305, but you don't need to know (or even care) about that to use it securely\n• / offer shared-key authenticated encryption.\n• The algorithm in question is XSalsa20-Poly1305, but you don't need to know/care\n\nAdditionally, libsodium has bindings in dozens of popular programming languages, so it's very likely that libsodium will just work when trying to interoperate with another programming stack. Also, libsodium tends to be very fast without sacrificing security.\n\nHow to Use Libsodium in JavaScript?\n\nFirst, you need to decide one thing:\n• Do you just want to encrypt/decrypt data (and maybe still somehow use the plaintext in database queries securely) and not worry about the details? Or...\n• Do you need to implement a specific protocol?\n\nIf you selected the first option, get CipherSweet.js.\n\nThe documentation is available online. is sufficient for most use cases, but the and APIs may be easier if you have a lot of distinct fields you want to encrypt.\n\nWith CipherSweet, you don't need to even know what a nonce/IV is to use it securely.\n\nAdditionally, this handles / encryption without leaking facts about the contents through ciphertext size.\n\nOtherwise, you'll want sodium-plus, which is a user-friendly frontend to various libsodium wrappers. Sodium-Plus allows you to write performant, asynchronous, cross-platform code that's easy to audit and reason about.\n\nThere is currently no public CDN for browser support. This will change soon. However, you can grab from the latest Github release if you need it.\n\nThe documentation for sodium-plus is available on Github.\n\nIf you'd like a step-by-step tutorial, this dev.to article has what you're looking for."
    },
    {
        "link": "https://crypto.stackexchange.com/questions/11239/rsa-decrypt-long-messages-javascript",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://gaitatzis.medium.com/creating-compatible-asymmetric-keys-in-java-and-javascript-in-the-browser-98650fd9facc",
        "document": "It is said many times that “Cryptography is hard.”\n\nBut a lot of what makes it hard is that it doesn’t work at all if the configurations aren’t tuned exactly right.\n\nUnlike normal programming, there are no visual queues that you are getting closer to a solution. Only random binary data no matter how close you got.\n\nThis is especially hard when using cryptography libraries between two different programming libraries, such as Java and JavaScript.\n\nIn this article, I will show how to get Java and JavaScript to encrypt and decrypt messages to each other using asymmetric encryption.\n\nNote: This tutorial assumes JavaScript is running in the browser.\n\nSince keypair cryptography is typically performed between two separate parties, it is useful to have a common format to share public keys. This format should be one that doesn’t conform to the data and object types of the language that created it.\n\nA common way of storing and transferring keys is to use a Base64-encoded text format called “X509\" for public keys and “PKCS8” for private keys.\n\nThese formats have text headers and footers that read something like or depending on the key type.\n\nThis article will show how to create and export these formats from JavaScript in the browser and in Java.\n\nRegardless of which language produces the keys, we want the output to resemble this for a public key:\n\nAnd this for a private key:\n\nThe first step is to get keys into your system. Normally a sender will have a public key for a receiver, the receiver has a private key.\n\nThe sender can encrypt a message using the receiver’s public key, then the receiver can decrypt it using their private key.\n\nIn order for encryption and decryption to work between both platforms later, it is important to tune the key creation settings to match the encryption and decryption settings later.\n\nFor this reason, we will use padding in JavaScript. Both keys will be created using the encryption algorithm, because at the time of writing, elliptic curve algorithms are more challenging to work with in Java.\n\nIn JavaScript, we can use the Crypto.Subtle library to create a new public and private key pair.\n\nWe do this by using the method and making sure to pass in a modulus length of , a public exponent of (represented as a , and the hashing algorithm.\n\nIf we intend to export the keys for use on another platform, or we intend to test encryption and decryption on the same system, we specify that the key can be used for encryption for both encryption in the last argument of .\n\nThe in this process refers to the type of padding applied to encrypted messages. To aid in making encrypted messages difficult to identify from from their source, each encrypted message is padded to be the same length so that ‘Hello” and “How are you doing my dear friend” so that the length of the message doesn’t reveal which message is which.\n\nOnce the key pair is created, you can reference the public key and private key separately from the key pair object.\n\nNote: In the RSA encryption algorithm, a restricted number space is used, defined by the modulus. Numbers bigger than the modules wrap around to the start of the space the way a clock hand moves from 12 to 1. The public exponent refers to a prime number that is used to calculate the public key from the private key. In cryptography, bigger numbers for these values is typically more secure, at the cost of computation time.\n\nIn Java, the options for creating a private key are more limited. You simply create a object with an algorithm. You initialize it with the modulus , then retrieve the public key and the private key separately.\n\nNow that we have an in-memory public and private key, we should export it to the common text format to exchange with the other system.\n\nTypically, the public key can be shared with other systems and the private key should always remain a secret, never leaving the device it was created on.\n\nIn Javascript, we export the key using a format called or Subject Public Key Info, which is compatible with X509.\n\nWe export to an binary format using the function. This binary format must be converted to a so that the browser’s Base64 function, can work with it.\n\nWith the Base64-encoded, we can add the headers and footers that identify it to the reader as a public key, and add newlines every 80 characters so it is easy to see when printed into a console or code editor.\n\nIn Java, the process is straight-forward. Simply export the key to a array using the public key’s method, create an encoder and use it to encode the key into that format, Base64-encode, and add headers and footers to make the key easily distinguishable as a public key:\n\nThe process in JavaScript is almost identical to exporting a public key, except that we export using a format called or PKCS #8.\n\nThis results in an . This then must be converted to a so that the browser’s Base64 function, can work with it.\n\nWith the Base64-encoded, we can add the headers and footers that identify it to the reader as a public key, and add newlines every 80 characters so it is easy to see when printed into a console or code editor.\n\nIn Java, the process for exporting a Private Key to PKCS #8 format is pretty straight-forward.\n\nSimply create a from the private key and encode into that format, then Base64 encode the resulting bytes into a and assemble the header and footer to make the key visibly identifiable as a private key.\n\nThe whole point of exporting keys in a common format is to be able to load them later in the other (or sometimes the same) program.\n\nThis requires transmitting the public key somehow, for example over an API, or saving the private key into a text file. The text representation of the key can then be decoded and imported into a native format which can be used for cryptography.\n\nTo convert the key from a PEM text format to a native Public Key format, we must:\n• Strip out the headers and footers and formatting.\n• Convert the string from Base64 encoding to a binary format (still a at this stage). Note that works in the browser but not from the console.\n• Convert the decoded to an array of binary data\n• Import the data, specifying the inbound data format, the key type and data padding ( ) and hash algorithm ( ), and what functions the key will be allowed to perform. In this example, we expect to encrypt data.\n\nPublic keys can be used to encrypt data or verify signatures. Note that it is considered a good security practice to use separate public keys for encryption and signature verification.\n\nIn Java, a similar process happens, where we:\n• Strip out the formatting in the PEM string\n\nThen we import the key using a object that expects an encryption type, resulting in a object.\n\nThis key can be used to encrypt data.\n\nA major step in being able to encrypt and decrypt data between Java and JavaScript is to ensure that the key settings are compatible between the two.\n\nThis of course means the public key used for encryption was created from the private key that will be used for decryption. This implies that the keys are both created using the same algorithm, in this example .\n\nBut it also means that the hash used to randomize data is the same.\n\nIn Java, the hash is used by default in key generation. In JavaScript, that setting must be configured during the time of key creation or import.\n\nThe process of converting a PEM-formatted key string into a private key object is similar to the public key, except that we expect to import a format key, and that the key will be used to decrypt data.\n\nNote that it is considered a good security practice to use different private keys for decryption and for message signing.\n\nPrivate keys can be used to decrypt data or sign messages. Note that it is considered a good security practice to use separate private keys for decryption and signing.\n\nThe process for importing a private key in Java is similar to that for importing a public key. The major difference is that we configure the key specification for the to use a , where is the encoding format for private keys.\n\nAdditionally, we expect to remove the headers and footers containing text that may include . Although check your key file as it may contain text such as or some other version of this string.\n\nLearn how to use these keys to Encrypt and Decrypt Messages across JavaScript and Java apps."
    },
    {
        "link": "https://stackoverflow.com/questions/58146853/get-the-congruence-of-big-numbers-javascript-rsa-algorithm",
        "document": "In the RSA asymmetric cryptography algorithm every user has a public key (n,e) and a private key (d) to send and receive encrypted messages from other users.\n\nTo encrypt a message it changes the characters to their ascii codes:\n\nand to send the message encrypted with RSA (c), has to calculate\n\nfor each character m in the message using the public keys n and e.\n\nto decrypt a message that the user receives has to calculate:\n\nto each number c usign the private key d.\n\nif some user wants to send a message to Beto:\n\nto encrypt the message the user had to calculate\n\nand the encrypted code was\n\nBeto to decipher the message had to calculate:\n\nand he got the decrypted message => .\n\nI have this code to solve the last part, but I cant use it with big numbers (like the ones in the example):\n\nHow can I get the result if use big numbers?\n\nCan I use another algorithm to find the answer?\n\nthere is a library I can use to do it?"
    },
    {
        "link": "https://pomcor.com/2015/10/25/faster-modular-exponentiation-in-javascript",
        "document": "Modular exponentiation is the algorithm whose performance determines the performance and practicality of many public key cryptosystems, including RSA, DH and DSA. We have recently achieved a manyfold improvement in the performance of modular exponentiation in JavaScript over the implementation of modular exponentiation in the Stanford JavaScript Crypto Library (SJCL). JavaScript was originally intended for performing simple tasks in web pages, but it has grown into a sophisticated general purpose programming language used for both client and server computing, which is arguably the most important programming language today. Good performance of public key cryptography is difficult to achieve in JavaScript, because JavaScript is an interpreted language inherently slower than a compiled language such as C, and provides floating point arithmetic but no integer arithmetic. But fast JavaScript public key cryptography is worth the effort, because it may radically change the way cryptography is used in web applications.\n\nOur implementation of modular exponentiation is part of a JavaScript big integer library that we are developing as the basis of a cryptographic authentication toolkit for web applications. We initially considered building the toolkit on top of the Web Cryptography API of the W3C. That approach was appealing because it would have provided our JavaScript code with access to fast cryptographic primitives supplied by the browser, presumably implemented in C, perhaps with assembly language optimizations. But we decided against it for several reasons: the API is unfinished and seems to be in a state of flux; it lacks important primitives, notably DSA; and it is unnecessarily complicated, requiring cryptographic primitives to be invoked via asynchronous JavaScript Promises. Instead we took up the challenge of implementing faster public key cryptography in JavaScript itself, and were lucky to succeed well beyond our expectations.\n\nModular exponentiation computesmod, whereis the base,is the exponent, andis the modulus. The bit lengths ofanddepend on the cryptosystem where the algorithm is used and the desired security strength. The security strength of a cryptosystem is defined by the amount of work that it would take to break it with the best available cryptanalytic techniques. That amount of work can be loosely measured by the key length of a symmetric encryption algorithm such as AES for which an exhaustive search of the key space would require the same amount of work.\n\nIn Table 2 of SP 800-57 Part 1, NIST lists the key sizes that are required in several cryptosystems to achieve a range of security strengths. We have measured the performance of modular exponentiation for the parameter bit lengths used in the cryptosystems of columns FFC and IFC at the security strengths that NIST considers acceptable, i.e. 112, 128, 192 and 256 bits.\n\nFFC stands for Finite-Field Cryptography, which comprises DSA and DH. Column FFC of the NIST table lists key sizes (L,N) for DSA and DH, L being the bit length of the public key, and N the bit length of the private key. DSA involves one modular exponentiation for signing and two for decrypting, while DH requires one modular exponentiation by each participant in a key exchange. In those modular exponentiations g and m are L bits long, while x is N bits long. The following table shows the time it takes to compute those modular exponentiations with our implementation and with the one in Stanford library, both running in Firefox on a Mac laptop with a 1.7 GHz 64-bit Intel Core i5 processor. (The bit length of g has negligible effect on performance but is included for clarity. The same is true for the other three tables below.)\n\nIFC stands for Integer-Factorization Cryptography, which comprises RSA. Column IFC of the NIST table lists the bit length k of the RSA modulus at the range of security strengths. When the usual CRT optimization is used, a private key RSA operation for signing or decrypting requires two modular exponentiations, where the bit lengths of g and x are k and the bit length of m is k/2. (Public key operations matter less for performance because they use a very small exponent.) The following table shows the time it takes to compute each of those two modular exponentiations with our implementation and with the one in the Stanford library, again in Firefox on the same Mac laptop.\n\nColumn ECC of the NIST table lists the key sizes for elliptic curve cryptosystems such as ECDSA and ECDH, shown as the order f of the group generated by the base point of the elliptic curve. ECC has important advantages over classical public key cryptography and we plan to support it in our big integer library and authentication toolkit. But after the Snowden revelations, some users of cryptography, especially in Europe, are worried that elliptic curves chosen by NIST or by others may have back doors. This was reported and discussed at the NIST ECC workshop last June (webcast available). Hence the use of classical cryptography may be preferable or required for some applications or use cases. (Classical DSA was designed by the NSA but it not under suspicion.) Modular exponentiation with general moduli is not used in ECC, where scalar multiplication of curve points is used instead.\n\nThe next two tables report measurements for implementations running in Chrome on a Samsung Galaxy Note 3 with a 32-bit 2.3 GHz processor. Our implementation includes Karatsuba multiplication, which is asymptotically faster than long multiplication, but slower for shorter bit lengths. We use it only where indicated. SJCL does not implement Karatsuba multiplication.\n\nThe following observations can be made from the timings shown in the above tables:\n• Our modular exponentiation is from 6 to 10 times faster than the one in SJCL for the bit lengths used in DSA, DH and RSA with CRT at the tested security strengths.\n• With our fast implementation, given that a DSA signature takes one exponentiation, cryptographic authentication by signing a challenge should take a small fraction of a second on a laptop at security strengths 112, 128 and 192, and not much more than a second at security strength 256. On a smart phone with a 32-bit processor it should take a small fraction of a second at security strengths 112 and 128, and less than a second at security strength 192. For security strength 256 on a phone it would be necessary to resort to ECDSA.\n• A private key operation with the CRT optimization of RSA takes two exponentiations. Thus, using our implementation, cryptographic authentication or public key encryption using RSA on a laptop would take a small fraction of a second at security strengths 112 and 128, and less than two seconds at security strength 192. At security strength 256 it would be necessary to use ECDSA one would use instead DSA or ECDSA for authentication or an elliptic curve version of El Gamal for encryption. On a phone with a 32-bit processor, authentication or encryption with RSA would take less than a second at security strengths 112 and 128, but would not be practical at security strengths 192 and beyond.\n• In our implementation, Karatsuba multiplication does not help in any of the cases where the size of the multiplicands (as determined by the modulus), is 3840 bits or less. This is surprising, and it was disappointing to us, since we made a serious effort to optimize our implementation of Karatsuba. By contrast, the Wikipedia article on Karatsuba states that “as a rule of thumb, Karatsuba is usually faster when the multiplicands are longer than 320–640 bits”.\n\nIt is difficult to measure performance in JavaScript. Programs written in C can use the clock function of the C Standard Library to measure the number of processor cycles spent by the program; but JavaScript does not have equivalent functionality, so we have to measure elapsed time rather than clock cycles. The JavaScript Date object can be used to measure elapsed time, but not accurately enough. The getTime() method of the Date object reports time in milliseconds, but the reported time may not be accurate to the millisecond and is subject to occasional system clock adjustments forward or backwards. We use instead the performance.now() function introduced by the High Resolution Time specification of the W3C, which is supposed to be accurate to the millisecond and not subject to clock adjustments, and which is now supported by most browsers. Elapsed time, however, is not a good measure of program performance, since the process that executes the program may have to yield the processor core on which it runs to other processes, and the system clock may be slowed down to conserve battery life.\n\nWe cope with these difficulties as follows. To measure the time taken by an algorithm for a set of inputs, we run the algorithm on the inputs in a loop with enough loop iterations for the total time to be at least 200ms, and we divide the total time by the number of iterations. Then we manually repeat the loop a number of times. As the number of repetitions increases, the minimum time over the set repetitions converges towards the ideal time that the algorithm would take without interruptions or slowdowns. We report the minimum time observed after a large number of repetitions.\n\n…come to the XXI Internet Identity Workshop, where we will make a presentation and give a demo. The workshop takes place next week, October 27-29, at the Computer History Museum in Mountain View.\n\nWe plan to release the big integer library together with the cryptographic toolkit as soon as they are both ready. We will then explain in detail what makes our modular exponentiation code faster.\n\nUpdate. The presentation at IIW is now available.\n\nUPDATE. We have now released a beta test version of the Pomcor JavaScript Cryptographic Library (PJCL)."
    },
    {
        "link": "https://geeksforgeeks.org/rsa-algorithm-cryptography",
        "document": "RSA(Rivest-Shamir-Adleman) Algorithm is an asymmetric or public-key cryptography algorithm which means it works on two different keys: Public Key and Private Key. The Public Key is used for encryption and is known to everyone, while the Private Key is used for decryption and must be kept secret by the receiver. RSA Algorithm is named after Ron Rivest, Adi Shamir and Leonard Adleman, who published the algorithm in 1977.\n\nIf Person A wants to send a message securely to Person B:\n• decrypts the message using their Private\n• p q . These prime numbers should be kept secret.\n• n = p * q . This product is part of the public as well as the private key.\n• e\n• None gcd(e, Φ(n)) = 1, that is e should be co-prime with Φ(n).\n• d,\n• (d * e) ≡ 1 mod Φ(n) , that is d is e mod Φ(n). Some common methods to calculate multiplicative inverse are:\n• None We can have multiple values of d satisfying (d * e) ≡ 1 mod Φ(n) but it does not matter which value we choose as all of them are valid keys and will result into same message on decryption.\n\nFinally, the Public Key = (n, e) and the Private Key = (n, d).\n\nTo encrypt a message M, it is first converted to numerical representation using ASCII and other encoding schemes. Now, use the public key (n, e) to encrypt the message and get the cipher text using the formula:\n\nTo decrypt the cipher text C, use the private key (n, d) and get the original data using the formula:\n\nThe idea of RSA is based on the fact that it is difficult to factorize a large integer. The Public Key is (n, e), where n and e are publicly known, while the Private Key is (n, d). Since only the receiver knows the value of d, only they can decrypt the message. But is it possible to find the value of d using n and e?\n\nWe know that (d * e) ≡ 1 mod Φ(n), so if we can calculate the value of Φ(n), we can find the value of d. But Φ(n) = (p – 1) * (q – 1). So, we need the value of p and q. Now, one might think that it’s quite easy to find the value of p and q as n = p * q and n is already publicly known but RSA Algorithm takes the value of p and q to be very large which in turn makes the value of n extremely large and factorizing such a large value is computationally impossible.\n\nTherefore encryption strength lies in the values of p and q. RSA keys can be typically 1024 or 2048 bits long, but experts believe that 1024-bit keys could be broken shortly. But till now it seems to be an infeasible task.\n\nNote: If someone gets to know the value of p and q, then he can calculate the value of d and decrypt the message.\n\n// C++ Program for implementation of RSA Algorithm // Here we are calculating phi(n) using Hit and Trial Method // but we can optimize it using Extended Euclidean Algorithm # Here we are calculating phi(n) using Hit and Trial Method # but we can optimize it using Extended Euclidean Algorithm\n• Security: RSA algorithm is considered to be very secure and is widely used for secure data transmission.\n• Public-key cryptography: RSA algorithm is a public-key cryptography algorithm, which means that it uses two different keys for encryption and decryption. The public key is used to encrypt the data, while the private key is used to decrypt the data.\n• Key exchange: RSA algorithm can be used for secure key exchange, which means that two parties can exchange a secret key without actually sending the key over the network.\n• Digital signatures: RSA algorithm can be used for digital signatures, which means that a sender can sign a message using their private key, and the receiver can verify the signature using the sender’s public key.\n• Widely used: Online banking, e-commerce, and secure communications are just a few fields and applications where the RSA algorithm is extensively developed.\n• Slow processing speed: RSA algorithm is slower than other encryption algorithms, especially when dealing with large amounts of data.\n• Large key size: RSA algorithm requires large key sizes to be secure, which means that it requires more computational resources and storage space.\n• Vulnerability to side-channel attacks: RSA algorithm is vulnerable to side-channel attacks, which means an attacker can use information leaked through side channels such as power consumption, electromagnetic radiation, and timing analysis to extract the private key.\n• Limited use in some applications: RSA algorithm is not suitable for some applications, such as those that require constant encryption and decryption of large amounts of data, due to its slow processing speed.\n• Complexity: The RSA algorithm is a sophisticated mathematical technique that some individuals may find challenging to comprehend and use.\n• Key Management: The secure administration of the private key is necessary for the RSA algorithm, although in some cases this can be difficult.\n• Vulnerability to Quantum Computing: Quantum computers have the ability to attack the RSA algorithm, potentially decrypting the data.\n\nWhat is the RSA algorithm, and how does it work?\n\nWhat are the key components of the RSA algorithm?\n\nWhat are the primary applications of RSA?\n\nHow can I ensure the security of RSA encryption?"
    },
    {
        "link": "https://stackoverflow.com/questions/1450608/fastest-modular-exponentiation-in-javascript",
        "document": "My problem is to compute quickly in JavaScript, where is exponentiation, is the modulo operation. All inputs are nonnegative integers, has about 256 bits, and is a prime number of 2048 bits, and may have up to 2048 bits.\n\nMost of the software I've found that can do this in JavaScript seems to use the JavaScript BigInt library (http://www.leemon.com/crypto/BigInt.html). Doing a single exponentiation of such size with this library takes about 9 seconds on my slow browser (Firefox 3.0 with SpiderMonkey). I'm looking for a solution which is at least 10 times faster. The obvious idea of using square-and-multiply (exponentiation by squaring, http://en.wikipedia.org/wiki/Exponentiation_by_squaring) is too slow for 2048-bit numbers: it needs up to 4096 multiplications.\n\nUpgrading the browser is not an option. Using another programming language is not an option. Sending the numbers to a web service is not an option.\n\nUpdate: By doing some extra preparations (i.e. precomputing a few hundred powers) as recommended by the article http://www.ccrwest.org/gordon/fast.pdf mentioned in outis' answer below, it is possible do to a 2048-bit modular exponentiation using only at most 354 modular multiplications. (The traditional square-and-multiply method is much slower: it uses maximum 4096 modular multiplications.) Doing so speeds up the modular exponentiation by a factor of 6 in Firefox 3.0, and by a factor of 4 in Google Chrome. The reason why we are not getting the full speedup of 4096/354 is that BigInt's modular exponentation algorithm is already faster than square-and-multiply, because it uses Montgomery reduction (http://en.wikipedia.org/wiki/Montgomery_reduction).\n\nUpdate: Starting from BigInt's code, it seems worthwhile doing two levels of hand-optimized (and inlined) Karatsuba multiplication (http://en.wikipedia.org/wiki/Karatsuba_algorithm), and only then revert to the base-32768 O(n^2) multiplication implemented in BigInt. This speeds up multiplications by a factor of 2.25 for 2048-bit integers. Unfortunately, the modulo operation does not become faster.\n\nUpdate: Using the modified Barrett reduction defined in http://www.lirmm.fr/arith18/papers/hasenplaugh-FastModularReduction.pdf and Karatsuba multiplication and precomputing powers (as defined in http://www.ccrwest.org/gordon/fast.pdf), I can get down the time needed for a single multiplication from 73 seconds to 12.3 seconds in Firefox 3.0. This seems to be the best I can do, but it is still too slow.\n\nUpdate: The ActionScript 2 (AS2) interpreter in the Flash Player isn't worth using, because it seems to be slower than the JavaScript interpreter in Firefox 3.0: for Flash Player 9, it seems to be 4.2 times slower, and for Flash Player 10, it seems to be 2.35 times slower. Does anybody know the speed difference between ActionScript2 and ActionScript3 (AS3) for number chrunching?\n\nUpdate: The ActionScript 3 (AS3) interpreter in Flash Player 9 isn't worth using because it has just about the same speed as the JavaScript int Firefox 3.0.\n\nUpdate: The ActionScript 3 (AS3) interpreter in Flash Player 10 can be up to 6.5 times faster than the JavaScript interpreter in Firefox 3.0 if is used instead of , and is used instead of . At least it was 2.41 times faster for 2048-bit big integer multiplication. So it might be worth doing the modular exponentiation in AS3, executing it in Flash Player 10 if available. Please note that this is still slower than V8, the JavaScript interpreter of Google Chrome. See http://ptspts.blogspot.com/2009/10/javascript-and-actionscript-performance.html for a speed comparison of various programming language and JavaScript implementations.\n\nUpdate: There is a very fast Java solution, which can be called from the browser's JavaScript if the Java plugin is installed. The following solution is about 310 times faster than the pure JavaScript implementation using BigInt.\n\nCan anyone translate this code to Silverlight (C#)?"
    },
    {
        "link": "https://algocademy.com/blog/practical-guide-to-modular-exponentiation-efficient-power-calculation-in-cryptography",
        "document": "Welcome to AlgoCademy’s comprehensive guide on modular exponentiation! If you’re preparing for technical interviews at top tech companies or looking to enhance your algorithmic skills, understanding this crucial concept is essential. Modular exponentiation is a fundamental operation in various cryptographic algorithms and has wide-ranging applications in computer science. In this article, we’ll dive deep into the topic, exploring its importance, implementation, and optimization techniques.\n\nModular exponentiation is the operation of calculating the remainder when a number (base) is raised to a power (exponent) and then divided by a modulus. Mathematically, it’s represented as:\n\nFor example, if we want to calculate 3^7 mod 10, the result would be 7 because 3^7 = 2187, and 2187 mod 10 = 7.\n\nWhile this may seem simple for small numbers, it becomes challenging when dealing with large values, which is often the case in cryptographic applications. The naive approach of first calculating the full exponentiation and then taking the modulus is inefficient and can lead to integer overflow for large numbers.\n\nModular exponentiation is a cornerstone of many cryptographic algorithms and protocols. Its importance stems from several key factors:\n• Security: It forms the basis of public-key cryptography systems like RSA, where the security relies on the difficulty of factoring large numbers.\n• Efficiency: It allows for computations with very large numbers without causing overflow, which is crucial in cryptography.\n• Diffie-Hellman Key Exchange: This protocol uses modular exponentiation to securely exchange cryptographic keys over a public channel.\n• Digital Signatures: Many digital signature algorithms rely on modular exponentiation for their security properties.\n• Primality Testing: Some primality tests, like the Miller-Rabin test, use modular exponentiation as a core operation.\n\nBeyond cryptography, modular exponentiation finds applications in various areas of computer science, including:\n\nBefore we dive into efficient algorithms, let’s look at the naive approach to understand why it’s inadequate for large numbers:\n\nThis approach has a time complexity of O(exponent), which becomes impractical for large exponents. Moreover, it doesn’t handle the potential overflow that can occur when dealing with large numbers in cryptographic applications.\n\nThe efficient approach to modular exponentiation is the “Square and Multiply” algorithm, also known as the “Binary Exponentiation” method. This algorithm reduces the time complexity to O(log(exponent)), making it suitable for large numbers.\n\nThe key idea is to use the binary representation of the exponent and perform a series of squaring and multiplying operations. Here’s how it works:\n• Convert the exponent to its binary representation.\n• For each bit in the binary representation of the exponent (from left to right):\n• If the current bit is 1, multiply the result by the base.\n• Apply the modulus operation after each step to keep the numbers manageable.\n\nHere’s a Python implementation of the Square and Multiply algorithm:\n\nThis algorithm is much more efficient and can handle large numbers without overflow issues.\n\nLet’s look at implementations of the Square and Multiply algorithm in different programming languages:\n\nNote: In JavaScript, we use BigInt (denoted by the ‘n’ suffix) to handle large integers accurately.\n\nWhile the Square and Multiply algorithm is efficient, there are several optimization techniques that can further improve its performance:\n\nMontgomery reduction is a technique that replaces expensive division operations with cheaper multiplication and bit-shift operations. It’s particularly useful when performing many modular multiplications with the same modulus.\n\nWhen the modulus is a product of coprime factors (as in RSA), the Chinese Remainder Theorem can be used to perform the exponentiation in smaller subgroups and then combine the results. This can significantly speed up the computation.\n\nThis is an extension of the Square and Multiply method that processes multiple bits of the exponent at once, reducing the number of multiplications required.\n\nIf the base and modulus are fixed and multiple exponentiations are needed, precomputing and storing some powers of the base can speed up subsequent calculations.\n\nModular exponentiation is used in various real-world applications:\n\nRSA, one of the first public-key cryptosystems, heavily relies on modular exponentiation. The encryption process involves computing:\n\nWhere ‘e’ is the public exponent and ‘n’ is the modulus.\n\nThis protocol allows two parties to establish a shared secret over an insecure channel. It uses modular exponentiation to compute the shared secret:\n\nAnother public-key cryptosystem that uses modular exponentiation for both encryption and decryption.\n\nDSA uses modular exponentiation in the process of generating and verifying digital signatures.\n\nWhen preparing for technical interviews, especially for FAANG companies, it’s crucial to have a solid understanding of modular exponentiation. Here are some tips and common questions:\n\nBe prepared to discuss the time and space complexity of your implementation. The Square and Multiply algorithm has a time complexity of O(log n) and space complexity of O(1).\n\nInterviewers might ask how you’d handle numbers that are too large for standard integer types. Discuss using libraries for arbitrary-precision arithmetic or implementing your own big integer class.\n\nBe familiar with optimization techniques like Montgomery reduction or the Chinese Remainder Theorem. Even if you don’t implement them, being able to discuss these optimizations shows depth of knowledge.\n• “How would you optimize modular exponentiation if you need to perform it multiple times with the same base and modulus?”\n• “Explain how modular exponentiation is used in the RSA algorithm.”\n• “What’s the difference between (a * b) % m and ((a % m) * (b % m)) % m? When would you use each?”\n\nModular exponentiation is a fundamental concept in cryptography and computer science. Its efficient implementation is crucial for the security and performance of many cryptographic systems. By understanding the Square and Multiply algorithm and various optimization techniques, you’ll be well-prepared to tackle related problems in technical interviews and real-world applications.\n\nRemember, practice is key. Implement the algorithms yourself, experiment with different optimizations, and solve related problems to solidify your understanding. With dedication and consistent practice, you’ll master this important concept and be well on your way to excelling in your coding interviews and career.\n\nStay curious, keep coding, and best of luck in your journey with AlgoCademy!"
    }
]