[
    {
        "link": "https://wiremock.org/docs/stubbing",
        "document": "A core feature of WireMock API mocking is the ability to return canned HTTP responses for requests matching criteria. These are described in detail in Request Matching.\n\nYou can configure stubs using JSON configuration files or code:\n• Via a file under the directory\n• Via a POST request to with the JSON as a body\n• From code using one of the SDKs\n\nExample. To configure a response with a status of 200 to be returned when the relative URL exactly matches (including query parameters). The body of the response will be “Hello world!” and a header will be sent with a value of .\n\nIn Java, if you’d prefer to use slightly more BDDish language in your tests, you can replace with .\n\nSome common request and response patterns can be expressed in Java in abbreviated forms.\n\nRequests matching an exact URL plus one of the most common HTTP methods (GET, POST, PUT, DELETE) can be stubbed like this:\n\nCommon responses can also be abbreviated e.g.:\n\nMore DSL examples can be found here.\n\nHTTP methods currently supported are: . You can specify if you want the stub mapping to match on any request method. is a special method that could be used to match incoming requests for both or http method. A request will result in the same behaviour expected from a web server i.e. the and headers will be emitted but no response body. A detailed guide about various HTTP methods can be found here. can be used the following way\n\nIn addition to the status code, the status message can optionally also be set.\n\nIt is sometimes the case that you’ll want to declare two or more stub mappings that “overlap”, in that a given request would be a match for more than one of them. By default, WireMock will use the most recently added matching stub to satisfy the request. However, in some cases it is useful to exert more control.\n\nOne example of this might be where you want to define a catch-all stub for any URL that doesn’t match any more specific cases. Adding a priority to a stub mapping facilitates this:\n\nWhen unspecified, stubs default to a priority of ^ where is the highest priority and Java (i.e., ) is the minimum priority.\n\nIn addition to matching on request headers, it’s also possible to send response headers.\n\nThe simplest way to specify a response body is as a string literal.\n\nIf you’re specifying a JSON body via the JSON API, you can avoid having to escape it like this:\n\nTo read the body content from a file, place the file under the directory. By default this is expected to be under when running from the JUnit rule. When running standalone it will be under the current directory in which the server was started. To make your stub use the file, simply call on the response builder with the file’s path relative to :\n\nA response body in binary format can be specified as a via an overloaded in Java.\n\nJSON API accepts this as a base64 string (to avoid stupidly long JSON documents):\n\nWhen a request cannot be mapped to a response, Wiremock returns an HTML response with a 404 status code.\n\nIt is possible to customize the response by catching all URLs with a low priority.\n\nStub mappings which have been created can be persisted to the directory via a call to in Java or posting a request with an empty body to .\n\nIn Java, Existing stub mappings can be modified, provided they have been assigned an ID.\n\nTo do the equivalent via the JSON API, the edited stub mapping to\n\nWhen running the standalone JAR, files placed under the directory will be served up as if from under the docroot, except if stub mapping matching the URL exists. For example if a file exists and no stub mapping will match then hitting will serve the file.\n\nThis feature is also available with the standard JAR. To use it, define the filesRoot using , i.e.\n\nStub mappings can be deleted via the Java API, either by passing the stub object or the stub ID:\n\nWhere stubs have metadata set on them this can be used to remove them:\n\nThey can be deleted via the HTTP API by issuing a to where is the UUID of the stub mapping, found in its field.\n\nThe WireMock server can be reset at any time, removing all stub mappings and deleting the request log. If you’re using either of the JUnit rules this will happen automatically at the start of every test case. However you can do it yourself via a call to in Java or sending a request with an empty body to .\n\nTo reset just the stub mappings leaving the request log intact send a to .\n\nIf you’ve created some file based stub mappings to be loaded at startup and you don’t want these to disappear when you do a reset you can call instead, or post an empty request to .\n\nGetting all currently registered stub mappings #\n\nAll stub mappings can be fetched in Java by calling .\n\nTo fetch them via the HTTP API send a to .\n\nOptionally limit and offset parameters can be specified to constrain the set returned e.g.\n\nA single stub mapping can be retrieved by ID in Java by calling where is the UUID of the stub mapping.\n\nVia the HTTP client a mapping can be retrieved by sending a to .\n\nIn Java, Multiple stubs can be imported in one call.\n\nThe equivalent can be carried out Via the JSON API, the to :\n\nBy default, if a stub in an import already exists (has an ID of a stub already loaded), then the existing stub will be overwritten. This can be changed by setting in the JSON to or calling on the Java builder.\n\nReplacing all stubs with the import #\n\nIf you want to ensure that the only stubs loaded after the import has completed are the ones it contains, you can set in the JSON or call on the Java builder.\n\nIf you want to user Gzip disabled response option at the ResponseDefinitionBuilder level. You can use"
    },
    {
        "link": "https://wiremock.org/docs/standalone/admin-api-reference",
        "document": "The WireMock admin API is described in OpenAPI 3.0. The spec file plus an instance of Swagger UI can be accessed from a running WireMock instance under , e.g. .\n\nBelow is the full API reference:"
    },
    {
        "link": "https://wiremock.org/docs/configuration",
        "document": "Both and the take a configuration builder as the parameter to their constructor e.g.\n\nEvery option has a sensible default, so only options that you require an override for should be specified.\n\nTypically it is only necessary to tweak these settings if you are doing performance testing under significant loads.\n\nWireMock can accept HTTPS connections from clients, require a client to present a certificate for authentication, and pass a client certificate on to another service when proxying.\n\nWireMock uses the trust store for three purposes:\n• As a server, when requiring client auth, WireMock will trust the client if it presents a public certificate in this trust store\n• As a proxy, WireMock will use the private key & certificate in this key store to authenticate its http client with target servers that require client auth\n• As a proxy, WireMock will trust a target server if it presents a public certificate in this trust store\n\nHTTP/2 can be disabled separately for plain text (HTTP) and TLS (HTTPS):\n\n// Set the timeout for requests to the proxy in milliseconds // Send the Host header in the original request onwards to the system being proxied to // As of WireMock `3.7.0`, when in proxy mode, this option will transfer the original `User-Agent` header from the client to the proxied service. // Override the Host header sent when reverse proxying to another system (this and the previous parameter are mutually exclusive) // When reverse proxying, also route via the specified forward proxy (useful inside corporate firewalls) // When proxying, path to a security store containing client private keys and trusted public certificates for communicating with a target server // The password to the trust store // When proxying, a key store containing a root Certificate Authority private key and certificate that can be used to sign generated certificates // The password to the CA key store // The type of the CA key store // Which proxy encodings to proxy through to the target if the request contains an Accept-Encoding header // By default this is null, which means the header is sent to the target unchanged // If there is an Accept-Encoding header on the request, and it does not contain any of the supported proxy encodings, the header is not sent to the target.\n\nWireMock, when started programmatically, will default to as a filesystem root if not configured otherwise.\n\nThe request journal records requests received by WireMock. It is required by the verification features, so these will throw errors if it is disabled.\n\nWhen response templating is enabled, compiled template fragments are cached to improve performance. This setting allows you to configure the maximum number of entries to allow in the cache. As of WireMock , this defaults to 1000 cache entries. Before WireMock the default was unlimited\n\nWireMock wraps all logging in its own interface. It ships with no-op, Slf4j and console (stdout) implementations.\n\nGzipping of responses can be disabled.\n\nBy default WireMock will send all responses chunk encoded, meaning with a header present and no header.\n\nThis behaviour can be modified by setting a chunked encoding policy e.g.\n• - Never use chunked encoding. Warning: this will buffer all response bodies in order to calculate the size. This might put a lot of strain on the garbage collector if you’re using large response bodies.\n• - Use chunked encoding for body files but calculate a for directly configured bodies.\n• - Always use chunk encoding - the default.\n\nWireMock always sends CORS headers with admin API responses, but not by default with stub responses. To enable automatic sending of CORS headers on stub responses, do the following:\n\nBy default, response bodies will be recorded in the journal in their entirety. This can result in out of memory errors when very large bodies are served so WireMock provides an option to limit the number of bytes of response bodies retained (truncating any that are larger).\n\nPreventing proxying to and recording from specific target addresses #\n\nAs a security measure WireMock can be configured to only permit proxying (and therefore recording) to certain addresses. This is achieved via a list of allowed address rules and a list of denied address rules, where the allowed list is evaluated first.\n\nEach rule can be one of the following:\n• An IP address range in the e.g.\n\nThe ruleset is built and applied as follows:\n\nWireMock can set up specific filename template format based on stub information. The main rule for set up specify stub metadata information in handlebar format. For instance for endpoint and format will be generated: filename. Default template: .\n\nIf you would like to observe raw HTTP traffic to and from Jetty for debugging purposes you can use a .\n\nOne scenario where it can be useful is where Jetty alters the response from Wiremock before sending it to the client. (An example of that is where Jetty appends a –gzip postfix to the ETag response header if the response is gzipped.) Using WireMock’s request listener extension points in this case would not show those alterations.\n\nTo output all raw traffic to console use , for example:\n\nIf you would like to collect the traffic and for example add it to your acceptance test’s output, you can use the .\n\nIf you want to increase the proxying performance of wiremock you can enable Connection reuse and increse max Connections"
    },
    {
        "link": "https://geeksforgeeks.org/wiremock-stubbing-with-json-mappings",
        "document": "WireMock is a tool for mocking HTTP-based APIs that runs in the unit tests, on the desktop, or in the test environment. We can also say it is a simulator for HTTP-based APIs, considered a service virtualization tool or a mock server. It enables you to stay productive when an API you depend on Doesn’t exist and, Isn’t complete or, Costly to access. It supports the testing of Edge cases and failure modes. It’s fast so reduces build time significantly. In simple terms, Wiremock is a mocking setup for integration testing. It is mainly used during the development and more significantly during the Integration testing while a system or service talks to one or multiple external or internal dependencies/services.\n\nOne of the most important features of WireMock is Stubbing. Stubbing is the core feature of WireMock and it has the ability to return canned HTTP responses for requests matching criteria. So in this article, we are going to see how Stubbing works with JSON Mappings in WireMock.\n\n1. Basic Stubbing for the GET Request\n\nOpen your Postman and send a POST request to the following URL\n\nwith the following JSON request body\n\nFor example in this article our URL is\n\nAnd the JSON request body is\n\nClick on the Send button now and in the Response, you can see the following Response Body with the status code 201 Created.\n\nPlease refer to the below image if you are stuck somewhere\n\nNow, let’s test our Stubbed API. Again open a new tab in Postman and send a GET request to the following URL\n\nAnd you are going to get the following response in the Response body.\n\nPlease refer to the below image if you are stuck somewhere\n\nIn case you have hit the wrong endpoint then you are going to get a response something like this with the 404 Not Found error code. Suppose instead of hitting the endpoint http://localhost:8080/gfg/user1, we have hit the following endpoint http://localhost:8080/gfg/user2, then we are going to get the response like this\n\nAnd you can see the same thing in your WireMock console also\n\nSimilar to the GET request just change the values of “request” -> “method” to “POST” in the JSON request body and you are done. Refer to the below JSON code.\n\nWe can also send a response header along with the Stub. Refer to the below JSON code for the syntax.\n\nIn addition to the status code, the status message can optionally also be set. Refer to the below JSON code for the syntax.\n\nStub mappings that have been created can be persisted in the mappings directory via posting a request with an empty body to the following URL\n\nExisting stub mappings can be modified, provided they have been assigned an ID. To do it send a PUT request to the following URL\n\nwith the following JSON request body\n\nPlease refer to the below image if you are stuck somewhere\n\nThe stub can be deleted via the HTTP API by using the DELETE request to the following URL\n\nwhere id is the UUID of the stub mapping, found in its id field."
    },
    {
        "link": "https://stackoverflow.com/questions/76455655/wiremock-how-to-include-request-json-body-into-the-response-body",
        "document": "What I have achieved so far?\n\nI'm using WireMock with Spring Boot Application using the JUNIT 5.\n\nI am stubbing the endpoint with the custom Request and Response JSON payload:\n\nWhat I'm trying to achieve?\n\nResponsePayload.getResponseJsonPayload() contains below value:\n\nWhat is not working?\n\nSince my JSON Request payload is dynamic. I want to create a dynamic JSON Payload in response as well where tokens values in JSON are static but the id's value in JSON is dynamic based on the request payload's id value.When I am debugging the program I can see the stub is throwing following error:\n\nI've already read below answers but couldn't find a way of using the :\n• WireMock: How configure a JSON to show request headers in the response\n\nAny help would be appreciable."
    },
    {
        "link": "https://wiremock.org/docs/request-matching",
        "document": "WireMock enables flexible definition of a mock API by supporting rich matching of incoming requests. Stub matching and verification queries can use the following request attributes:\n\nHere’s an example showing all attributes being matched using WireMock’s in-built match operators. It is also possible to write custom matching logic if you need more precise control:\n\nThe following sections describe each type of matching strategy in detail.\n\nURLs can be matched either by equality or by regular expression. You also have a choice of whether to match just the path part of the URL or the path and query together.\n\nIt is usually preferable to match on path only if you want to match multiple query parameters in an order invariant manner.\n\nEquality matching on the path only #\n\nRegex matching on the path only #\n\nWireMock from 3.0.0 onwards supports matching on URL path templates conforming to the RFC 6570 standard.\n\nWhen the path template URL match type is used this enables\n• The ability to match path variables in the same way as query parameters, headers etc.\n• The ability to reference path variables by name in response templates.\n\nTo match any request URL that conforms to the path template, you can do the following.\n\nTo further constrain the match to specific values of the path variables you can add match clauses for some or all of the variables in the path expression.\n\nAll request attributes other than the URL can be matched using the following set of operators.\n\nDeems a match if the entire attribute value equals the expected value.\n\nDeems a match if the entire attribute value equals the expected value, ignoring case.\n\nDeems a match if the entire binary attribute value equals the expected value. Unlike the above equalTo operator, this compares byte arrays (or their equivalent base64 representation).\n\nDeems a match if the a portion of the attribute value equals the expected value.\n\nNegative substring (does not contain) #\n\nDeems a match if the attribute value does not contain the expected value.\n\nDeems a match if the entire attribute value matched the expected regular expression.\n\nIt is also possible to perform a negative match i.e. the match succeeds when the attribute value does not match the regex:\n\nDeems a match if the attribute (most likely the request body in practice) is valid JSON and is a semantic match for the expected value.\n\nBy default different array orderings and additional object attributes will trigger a non-match. However, both of these conditions can be disabled individually.\n\nJSON equality matching is based on JsonUnit and therefore supports placeholders. This allows specific attributes to be treated as wildcards, rather than an exactly value being required for a match.\n\nFor instance, the following:\n\nwould match a request with a JSON body of:\n\nIt’s also possible to use placeholders that constrain the expected value by type or regular expression. See the JsonUnit placeholders documentation for the full syntax.\n\nDeems a match if the attribute value is valid JSON and matches the JSON Path expression supplied. A JSON body will be considered to match a path expression if the expression returns either a non-null single value (string, integer etc.), or a non-empty object or array.\n\nDeems a match if the attribute value is present in the JSON.\n\nDeems a match if the attribute value equals the expected value.\n\nDeems a match if the attribute value matches the regex expected value.\n\nDeems a match if the attribute size matches the expected size.\n\nThe JSONPath matcher can be combined with another matcher, such that the value returned from the JSONPath query is evaluated against it:\n\nSince WireMock’s matching operators all work on strings, the value selected by the JSONPath expression will be coerced to a string before the match is evaluated. This true even if the returned value is an object or array. A benefit of this is that this allows a sub-document to be selected using JSONPath, then matched using the operator. E.g. for the following request body:\n\nThe following will match:\n\nDeems a match if the value conforms to the expected JSON schema.\n\nBy default the V202012 version of the JSON schema spec will be used, but this can be changed to one of , , , , via the parameter.\n\nDeems a match if the attribute value is valid XML and is semantically equal to the expected XML document. The underlying engine for determining XML equality is XMLUnit.\n\nThe XMLUnit placeholders feature is supported in WireMock. For example, when comparing the XML documents, you can ignore some text nodes.\n\nWhen the actual request body is , it will be deemed a match.\n\nIf the default placeholder delimiters and can not be used, you can specify custom delimiters (using regular expressions). For example:\n\nYou can further tune how XML documents are compared for equality by disabling specific XMLUnit comparison types.\n\nThe full list of comparison types used by default is as follows:\n\nSame child nodes with different content #\n\nBy default, WireMock takes into account an order of identical child nodes. Meaning if actual request has different order of same node on same level than stub it won’t be matched. As of WireMock version , this can be changed by passing additional argument to the method\n\nThis will make sure that stub above matches both of following requests:\n\nIf third argument is passed as then first xml will not match the stub\n\nTo configure how XML namespaces are handled, as of WireMock , the property can be set.\n\nThe available options for namespace awareness behaviour are , and .\n\nadheres to strict XML namespace comparison. Namespace prefixes must be bound to a namespace URI. Namespace prefixes as well as namespace URIs must match (for both elements and attributes), unless explicitly excluded by the parameter.\n\ndoes not consider XML namespaces when reading and comparing XML documents. Namespace prefixes do not need to be bound to a namespace URI and are not considered a separate part of an element/attribute name (i.e. the entire element/attribute name must match, not just the local name, regardless of the parameter). namespaced attributes are treated no differently to any other attribute.\n\nis not recommended and is only kept as an option for backwards compatibility.\n\nDeems a match if the attribute value is valid XML and matches the XPath expression supplied. An XML document will be considered to match if any elements are returned by the XPath evaluation. WireMock delegates to Java’s in-built XPath engine (via XMLUnit), therefore up to (at least) Java 8 it supports XPath version 1.0.\n\nThe above example will select elements based on their local name if used with a namespaced XML document.\n\nIf you need to be able to select elements based on their namespace in addition to their name you can declare the prefix to namespace URI mappings and use them in your XPath expression:\n\nThe XPath matcher described above can be combined with another matcher, such that the value returned from the XPath query is evaluated against it:\n\nIf multiple nodes are returned from the XPath query, all will be evaluated and the returned match will be the one with the shortest distance.\n\nIf the XPath expression returns an XML element rather than a value, this will be rendered as an XML string before it is passed to the value matcher. This can be usefully combined with the matcher e.g.\n\nDeems a match if the attribute specified is absent from the request.\n\nDeems a match if a multipart value is valid and matches any or all the multipart pattern matchers supplied. As a Multipart is a ‘mini’ HTTP request in itself all existing Header and Body content matchers can by applied to a Multipart pattern. A Multipart pattern can be defined as matching request multiparts or . The default matching type is .\n\nAlthough matching on HTTP basic authentication could be supported via a correctly encoded header, you can also do this more simply via the API.\n\nDates and times can be matched in several ways. Three comparison operators are available: , and , all of which have the same set of parameters.\n\nAdditionally, the expected value can be either literal (fixed) or an offset from the current date. Both the expected and actual dates can be truncated in various ways.\n\nYou can match an incoming date/time against a fixed value e.g. “match if the X-Munged-Date request header is after x”:\n\nYou can also match in incoming value against the current date/time or an offset from it:\n\nBoth the expected and actual date/time values can either have timezone information or not. For instance a date in ISO8601 format could be zoned: or , or local: .\n\nLikewise a date/time in RFC 1123 (HTTP standard) format is also zoned: .\n\nWhether the expected and actual values are zoned or not affects whether they can be matched and how. Generally, the best approach is to try to ensure you’re using the same on both sides - if you’re expected a zoned actual date, then use one as the expected date also, plus the equivalent for local dates.\n\nIf the expected date is zoned and the actual is local, the actual date will assume the system timezone before the comparison is attempted.\n\nIf the expected date is local and the actual is zoned, the timezone will be stripped from the actual value before the comparison is attempted.\n\nBy default these matchers will attempt to parse date/times in ISO8601 format, plus the three standard formats defined by HTTP RFCs 1123, 1036 and asctime (taken from C but also valid for specifying HTTP dates).\n\nIt is also possible to specify your own format using Java’s date format strings.\n\nBoth the expected and actual date/times can be truncated in various ways e.g. to the first hour of the day. When using offset from now as the expected date with truncation, the truncation will be applied first followed by the offsetting.\n\nTruncation is useful if you want to create expressions like “before the end of this month” or “equal to the current hour”.\n\nIt can usefully be combined with offsetting so e.g. if the match required is “after the 15th of this month” we could do as follows.\n\nTruncating the actual value can be useful when checking for equality with literal date/times e.g. to say “is in March 2020”:\n\nThe full list of available truncations is:\n• None first day of next month\n• None first day of next year\n\nBy default, the date/time truncation is applied first and the offset is applied afterwards. There are scenarios, though, where the order needs to be reversed. For instance, if we want to match with the last day of the next month then the truncation should be applied last. In this case the boolean property should be set to true:\n\nIn the example above setting the property to true means that the expected date/time value will first be offset by one month and only afterwards truncated to the last day of that month. Which in turn means that if the current date is September 1st then the expected date will first be offset to October 1st and only then truncated to October 31st. Had the property been false (the default value) then the resulting expected date would be October 30th, one day off the date we were aiming for.\n\nLogical AND and OR #\n\nYou can combine two or more matchers in an AND expression.\n\nSimilarly you can also construct an OR expression.\n\nAs an example of how various matchers can be combined, suppose we want to match if a field named in a JSON request body is a date/time between two points.\n\nWe can do this by extracting the field using then matching the result of this against the and matchers AND’d together.\n\nThis would match the following JSON request body:\n\nYou can match multiple values of a query parameter or header with below provided matchers.\n\nExactly matcher exactly matches multiple values or patterns and make sure that it does not contain any other value.\n\nThere must be 3 values of id exactly whose values are 1, 2, and 3:\n\nThere must be 3 values of id exactly whose values conform to the match expressions\n\nIncludes matcher matches multiple values or patterns specified and may contain other values as well.\n\nThe values of id must include 1, 2, and 3:\n\nValues of id must conform to the match expressions:"
    },
    {
        "link": "https://stackoverflow.com/questions/61289508/wiremock-post-request-json-body-property-value-is-dynamic-generated-value-how-to",
        "document": "Am new to wiremock, am using wiremock in my spring boot integration test for mocking one of the external http call.\n\nMy json request body contains two dynamic properties, all other fields am able to set and stub in the request only two field values am not able to set as they are dynamic values.\n\nAs these are dynamic in nature, I mean value of the property is random-auto-genarated values. Is there a way to ignore these properties and remaining all properties are anyhow matching.\n\nI know that ignore is available for extra fields and array order\n\nI want to know similar to above, ignore feature to specific property (user can mention the property name so that property it should ignore) is available?\n\nI have a following json request body that I need to stub in wire mock post so am using\n\nHere in the request json, I have around almost 60 to 70 properties, except for property_four and property_seven remaining all fields match is happening properly.\n\nI wanted to know how to ignore these two fields with equaltoJson(requestJson) in wiremock, as these field values are dynamic in nature, I wanted to skip these properties from matching.\n\nAny one have any Idea how to skip or ignore these properties Or any other good solution to this problem.\n\nI thought of using withRequestBody(matchingJsonPath(PATH)) but with huge and complex request,\n\nI felt, that is not the right solution.\n\nMy request body is so complex, I mean many fields, just for example, I mentioned only ten properties with example properties and values.\n\nThanks in advance, as I said earlier am new to wiremock."
    },
    {
        "link": "https://wiremock.org/docs/stubbing",
        "document": "A core feature of WireMock API mocking is the ability to return canned HTTP responses for requests matching criteria. These are described in detail in Request Matching.\n\nYou can configure stubs using JSON configuration files or code:\n• Via a file under the directory\n• Via a POST request to with the JSON as a body\n• From code using one of the SDKs\n\nExample. To configure a response with a status of 200 to be returned when the relative URL exactly matches (including query parameters). The body of the response will be “Hello world!” and a header will be sent with a value of .\n\nIn Java, if you’d prefer to use slightly more BDDish language in your tests, you can replace with .\n\nSome common request and response patterns can be expressed in Java in abbreviated forms.\n\nRequests matching an exact URL plus one of the most common HTTP methods (GET, POST, PUT, DELETE) can be stubbed like this:\n\nCommon responses can also be abbreviated e.g.:\n\nMore DSL examples can be found here.\n\nHTTP methods currently supported are: . You can specify if you want the stub mapping to match on any request method. is a special method that could be used to match incoming requests for both or http method. A request will result in the same behaviour expected from a web server i.e. the and headers will be emitted but no response body. A detailed guide about various HTTP methods can be found here. can be used the following way\n\nIn addition to the status code, the status message can optionally also be set.\n\nIt is sometimes the case that you’ll want to declare two or more stub mappings that “overlap”, in that a given request would be a match for more than one of them. By default, WireMock will use the most recently added matching stub to satisfy the request. However, in some cases it is useful to exert more control.\n\nOne example of this might be where you want to define a catch-all stub for any URL that doesn’t match any more specific cases. Adding a priority to a stub mapping facilitates this:\n\nWhen unspecified, stubs default to a priority of ^ where is the highest priority and Java (i.e., ) is the minimum priority.\n\nIn addition to matching on request headers, it’s also possible to send response headers.\n\nThe simplest way to specify a response body is as a string literal.\n\nIf you’re specifying a JSON body via the JSON API, you can avoid having to escape it like this:\n\nTo read the body content from a file, place the file under the directory. By default this is expected to be under when running from the JUnit rule. When running standalone it will be under the current directory in which the server was started. To make your stub use the file, simply call on the response builder with the file’s path relative to :\n\nA response body in binary format can be specified as a via an overloaded in Java.\n\nJSON API accepts this as a base64 string (to avoid stupidly long JSON documents):\n\nWhen a request cannot be mapped to a response, Wiremock returns an HTML response with a 404 status code.\n\nIt is possible to customize the response by catching all URLs with a low priority.\n\nStub mappings which have been created can be persisted to the directory via a call to in Java or posting a request with an empty body to .\n\nIn Java, Existing stub mappings can be modified, provided they have been assigned an ID.\n\nTo do the equivalent via the JSON API, the edited stub mapping to\n\nWhen running the standalone JAR, files placed under the directory will be served up as if from under the docroot, except if stub mapping matching the URL exists. For example if a file exists and no stub mapping will match then hitting will serve the file.\n\nThis feature is also available with the standard JAR. To use it, define the filesRoot using , i.e.\n\nStub mappings can be deleted via the Java API, either by passing the stub object or the stub ID:\n\nWhere stubs have metadata set on them this can be used to remove them:\n\nThey can be deleted via the HTTP API by issuing a to where is the UUID of the stub mapping, found in its field.\n\nThe WireMock server can be reset at any time, removing all stub mappings and deleting the request log. If you’re using either of the JUnit rules this will happen automatically at the start of every test case. However you can do it yourself via a call to in Java or sending a request with an empty body to .\n\nTo reset just the stub mappings leaving the request log intact send a to .\n\nIf you’ve created some file based stub mappings to be loaded at startup and you don’t want these to disappear when you do a reset you can call instead, or post an empty request to .\n\nGetting all currently registered stub mappings #\n\nAll stub mappings can be fetched in Java by calling .\n\nTo fetch them via the HTTP API send a to .\n\nOptionally limit and offset parameters can be specified to constrain the set returned e.g.\n\nA single stub mapping can be retrieved by ID in Java by calling where is the UUID of the stub mapping.\n\nVia the HTTP client a mapping can be retrieved by sending a to .\n\nIn Java, Multiple stubs can be imported in one call.\n\nThe equivalent can be carried out Via the JSON API, the to :\n\nBy default, if a stub in an import already exists (has an ID of a stub already loaded), then the existing stub will be overwritten. This can be changed by setting in the JSON to or calling on the Java builder.\n\nReplacing all stubs with the import #\n\nIf you want to ensure that the only stubs loaded after the import has completed are the ones it contains, you can set in the JSON or call on the Java builder.\n\nIf you want to user Gzip disabled response option at the ResponseDefinitionBuilder level. You can use"
    },
    {
        "link": "https://stackoverflow.com/questions/65334967/dynamic-wiremock-to-capture-path-parameter-and-return-in-response",
        "document": "I am trying to create dynamic mocks using WireMock. I have a situation where if I specify URL like\n\nthen I should receive response like this:\n\nIn brief, the path param is returned in the response body, but I am not sure how should I capture 121 and return this in the response using wiremock.\n\nand for this kind of request\n\nwhat can I used so response will filter out the id and role and put in the response.\n\nI am using standalone wiremock jar 2.27.2 to create wiremock-server."
    },
    {
        "link": "https://medium.com/@nlavanya207/handling-dynamic-responses-with-wiremock-9edce172bbc1",
        "document": "Explanation of WireMock WireMock is a library for simulating HTTP-based APIs. It enables developers to test their code that makes HTTP requests by returning pre-determined responses or dynamic responses.\n\nWireMock provides a flexible and simple way to test HTTP-based APIs and ensures that the APIs are working as expected.\n\nPurpose of handling dynamic responses with WireMock Handling dynamic responses with WireMock is crucial for testing APIs that need to return unique or constantly changing responses.\n\nBy handling dynamic responses with WireMock, developers can test the API’s response to different scenarios, such as real-time data or random values.\n\nThis helps ensure that the API is working correctly and can handle changing data.\n\nStandalone version WireMock can be used as a standalone version, which means it can be run without the need for a separate application server or a web container. This makes it easier to set up and start using WireMock.\n\nDownloading the latest version from the WireMock website\n\nTo get started with WireMock, the latest version must be downloaded from the WireMock website.\n\nThis version can be run as a standalone JAR file, and it comes with all the necessary dependencies.\n\nAfter downloading the latest version of WireMock, it can be run in the terminal. To start WireMock, navigate to the directory where the JAR file is located and run the following command:\n\nThis will start WireMock and make it available for stubbing and testing HTTP-based APIs. WireMock will run on port 8080 by default, and it can be accessed through a web interface or through the API.\n\nWith WireMock set up and running, you’re ready to start stubbing dynamic responses.\n\nStubbing is the process of creating a mock API endpoint that returns a pre-determined or dynamic response.\n\nThis allows developers to test their code without having to make real API calls, which can be slow and unreliable. With WireMock, developers can stub dynamic responses easily, making it a useful tool for testing APIs.\n\nWireMock provides an API for stubbing dynamic responses in Java code. This makes it easy to set up dynamic responses, as well as test them.\n\nWhen using Java code to stub dynamic responses, developers can write custom logic to return dynamic responses based on the request.\n\nExample of stubbing a dynamic response that returns the current time Here’s an example of how to stub a dynamic response that returns the current time in Java code:\n\nIn this example, we’re using the method to create a new stub for a GET request to the \"/time\" endpoint.\n\nThe stub will return a response with a body that includes the current time, and a status code of 200.\n\nThis is just one example of how to stub dynamic responses with WireMock, and there are many other possibilities, depending on your use case.\n\nWith dynamic responses stubbed, you’re ready to test them and make sure they’re working as expected.\n\nNow that you have stubbed a dynamic response, you can test it by sending a GET request to the endpoint you stubbed.\n\nHere is an example of how to test the dynamic response:\n\nThis should return the current time in the format .\n\nWireMock provides a simple and flexible way to stub dynamic responses. By using the Java code approach, you can easily generate dynamic responses based on the current time, random numbers, or any other data you need for your tests.\n\nTo know more about Wiremock visit here. You can get to know how to mock API’s using Wiremock and Docker."
    }
]