[
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://programiz.com/c-programming/c-dynamic-memory-allocation",
        "document": "As you know, an array is a collection of a fixed number of values. Once the size of an array is declared, you cannot change it.\n\nSometimes the size of the array you declared may be insufficient. To solve this issue, you can allocate memory manually during run-time. This is known as dynamic memory allocation in C programming.\n\nTo allocate memory dynamically, library functions are , , and are used. These functions are defined in the header file.\n\nThe name \"malloc\" stands for memory allocation.\n\nThe function reserves a block of memory of the specified number of bytes. And, it returns a pointer of which can be casted into pointers of any form.\n\nThe above statement allocates 400 bytes of memory. It's because the size of is 4 bytes. And, the pointer holds the address of the first byte in the allocated memory.\n\nThe expression results in a pointer if the memory cannot be allocated.\n\nThe name \"calloc\" stands for contiguous allocation.\n\nThe function allocates memory and leaves the memory uninitialized, whereas the function allocates memory and initializes all bits to zero.\n\nThe above statement allocates contiguous space in memory for 25 elements of type .\n\nDynamically allocated memory created with either or doesn't get freed on their own. You must explicitly use to release the space.\n\nThis statement frees the space allocated in the memory pointed by .\n\nHere, we have dynamically allocated the memory for number of .\n\nIf the dynamically allocated memory is insufficient or more than required, you can change the size of previously allocated memory using the function.\n\nHere, is reallocated with a new size ."
    },
    {
        "link": "https://medium.com/@theodoretsori/how-to-use-malloc-and-free-in-c-for-dynamic-memory-allocation-and-deallocation-335482dd15b4",
        "document": "and are two important functions in the C programming language that are used to dynamically allocate and deallocate memory, respectively.\n\nstands for \"memory allocation\", and it is used to dynamically allocate a block of memory in the heap. It takes a single argument, the size of the block of memory to be allocated in bytes, and returns a pointer to the first byte of the allocated memory. If the allocation fails, it returns a null pointer. Here is an example of using to dynamically allocate memory for an array of integers:\n\nis used to deallocate memory that was previously allocated using or another memory allocation function such as or . It takes a single argument, a pointer to the memory to be deallocated. It is important to deallocate memory when it is no longer needed to avoid memory leaks. Here is an example of using to deallocate the memory allocated in the example above:\n\nIt is important to note that does not set the pointer to the deallocated memory to , so it is a good idea to set the pointer to after calling to prevent any attempts to use the deallocated memory.\n\nIn summary, and are essential functions in C for dynamically allocating and deallocating memory. They allow a program to obtain and release memory as needed, making it possible to create complex data structures and manage memory efficiently.\n\nIf you found this article helpful follow and leave a comment."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/1eshvzc/best_tutorials_on_coding_your_own_dynamic_memory",
        "document": "I intend to make a Resource Acquisition is Inialization in C that automatically deallocates objects from the heap once the variable goes out-of-scope (there is a gcc feature that can detect this). Right now I am trying to understand how malloc and calloc work. What books would you recommend for a beginner to understand how allocating and deallocating memory from the heap work in C?"
    },
    {
        "link": "https://w3schools.com/c/c_memory_allocate.php",
        "document": "The process of reserving memory is called allocation. The way to allocate memory depends on the type of memory.\n\nC has two types of memory: Static memory and dynamic memory.\n\nStatic memory is memory that is reserved for variables before the program runs. Allocation of static memory is also known as compile time memory allocation.\n\nC automatically allocates memory for every variable when the program is compiled.\n\nFor example, if you create an integer array of 20 students (e.g. for a summer semester), C will reserve space for 20 elements which is typically 80 bytes of memory (20 * 4):\n\nBut when the semester starts, it turns out that only 12 students are attending. Then you have wasted the space of 8 unused elements.\n\nSince you are not able to change the size of the array, you are left with unnecessary reserved memory.\n\nNote that the program will still run, and it is not damaged in any way. But if your program contains a lot of this kind of code, it may run slower than it optimally could.\n\nIf you want better control of allocated memory, take a look at Dynamic Memory below.\n\nDynamic memory is memory that is allocated after the program starts running. Allocation of dynamic memory can also be referred to as runtime memory allocation.\n\nUnlike with static memory, you have full control over how much memory is being used at any time. You can write code to determine how much memory you need and allocate it.\n\nDynamic memory does not belong to a variable, it can only be accessed with pointers.\n\nTo allocate dynamic memory, you can use the or functions. It is necessary to include the header to use them. The and functions allocate some memory and return a pointer to its address.\n\nThe function has one parameter, size, which specifies how much memory to allocate, measured in bytes.\n\nThe function has two parameters:\n• amount - Specifies the amount of items to allocate\n• size - Specifies the size of each item measured in bytes\n\nThe best way to allocate the right amount of memory for a data type is to use the operator:\n\nLet's use dynamic memory to improve the students example above.\n\nAs noted previously, we cannot use to measure how much memory was allocated, we have to calculate that by multiplying the amount of items by the size of the data type:\n\nWhen working with dynamic memory allocation, you should also check for errors and free memory at the end of the program. You will learn more about this in the next chapters.\n\nFor completeness, it is worth mentioning stack memory. Stack memory is a type of dynamic memory which is reserved for variables that are declared inside functions. Variables declared inside a function use stack memory rather than static memory.\n\nWhen a function is called, stack memory is allocated for the variables in the function. When the function returns the stack memory is freed.\n\nIt is good to be aware of stack memory to be able to handle the memory usage of nested function calls and recursion. Recursion that repeats itself too many times may take up too much stack memory. When that happens it is called a stack overflow."
    },
    {
        "link": "https://geeksforgeeks.org/linked-list-data-structure",
        "document": ""
    },
    {
        "link": "https://linkedin.com/advice/1/what-most-common-errors-when-implementing-linked-list-fzlpe",
        "document": "A fifth common error when implementing a linked list is failing to test your code thoroughly and rigorously. This can leave undetected bugs, errors, or vulnerabilities in your code, which can compromise its quality, reliability, or security. To avoid testing errors, you should use a systematic and comprehensive testing strategy, such as unit testing, integration testing, or regression testing. You can also use tools such as frameworks, libraries, or generators to automate and simplify your testing process. Help others by sharing more (125 characters min.)\n• Testing linked lists involves checking fundamental operations (insertion, deletion, search), handling edge cases (empty lists, insertions at the beginning/end), validating traversal and memory management, detecting and preventing cyclic structures, assessing performance for large datasets, addressing concurrency issues in multithreaded environments, ensuring data integrity, conducting boundary testing, and checking error handling. Systematic testing helps identify and address errors, ensuring the reliability and correctness of the linked list implementation.\n• Testing error refers to the mistakes or inaccuracies that can occur during the process of testing a system, software, or product. It's like proofreading a document – even with careful testing, there might be overlooked errors or issues that need fixing. Reducing testing errors involves thorough and systematic testing, often using various testing techniques, to increase the reliability and accuracy of the final product.\n• Testing your linked-list implementation is crucial. If you don't consider all the possible edge cases , it can backfire pretty quickly."
    },
    {
        "link": "https://harsh05.medium.com/linked-lists-data-structure-in-c-ef52fcee0e09",
        "document": "Linked lists are fundamental data structures widely used in computer science and programming. In this comprehensive guide, we’ll delve into the world of linked lists, covering their definition, types, operations, and practical implementations. Whether you’re a beginner exploring data structures or a seasoned developer looking to deepen your understanding, this guide will equip you with the knowledge and skills to master linked lists effectively.\n\nA linked list is a linear data structure consisting of nodes connected by pointers or references. Unlike arrays, linked lists do not require contiguous memory allocation and can dynamically adjust their size. Each node in a linked list contains data and a reference to the next node, forming a sequence of elements.\n\nA node is a fundamental building block of a linked list. It mainly contains two components:\n• Data: The actual value or payload stored in the node.\n• Next Pointer: A reference or pointer to the next node in the sequence.\n\nThe head is a special node that serves as the starting point or entry point of a linked list. It contains the reference to the first node in the list. By accessing the head node, we can traverse the entire linked list by following the pointers to subsequent nodes.\n\nThere are several types of linked lists, including:\n\nEach node has a reference to the next node in the sequence, allowing traversal in one direction only.\n\n// Defining the Methods\n\nclass SinglyLinkedList {\n\n public:\n\n Node *head;\n\n LinkedList(int Arr[], int n); // Contructor\n\n void Insert(int num, int index);\n\n void Traversal();\n\n void Delete(int index);\n\n int Searching(int index);\n\n};\n\n\n\n// To Create Linked List\n\nSinglyLinkedList::LinkedList(int Arr[], int n){\n\n head = new Node;\n\n head -> data = NULL;\n\n head -> next = NULL;\n\n Node *last = head; // We will not touch head thats why we create \"last\", now-on we will do changes on \"last\"\n\n \n\n for(int i=0; i < n; i++){ \n\n last -> next = new Node; // First it will create new space for new node addr\n\n last -> next -> data = Arr[i]; // then it will store data into its data variable\n\n last -> next -> next = NULL; // then it will make the next variable there as NULL and create new NODE there in the next round.\n\n last = last -> next;\n\n }\n\n}\n\nEach node has references to both the next and previous nodes, allowing traversal in both directions.\n\nHow to Create Doubly Liked List :\n• Insertion: Adding a new node at the beginning, end, or middle of the list.\n• Deletion: Removing a node from the list based on its position or value.\n• Traversal: Iterating through the list to access and process each node’s data.\n• Searching: Finding a specific node or value within the list.\n• Reversal: Changing the order of nodes in the list to reverse its sequence.\n• Push_Back : Inserting a new node at the end of the list.\n• Push_Front : Inserting a new node at the beginning of the list.\n• Pop : Removing the last node from the list.\n• Peek : Getting the last node from the list.\n\nWhen working with linked lists, it’s essential to consider:\n• Efficiency: Optimize operations for time and space complexity, especially in performance-critical applications.\n• Error Handling: Handle edge cases and errors gracefully to ensure robustness and reliability.\n• Testing: Thoroughly test linked list implementations to validate correctness and identify potential bugs.\n\nLinked lists are versatile and powerful data structures with diverse applications in software development and computer science. By understanding the fundamentals, types, operations, and practical implementations of linked lists, developers can leverage their flexibility and efficiency to solve a wide range of problems effectively. Whether you’re building algorithms, designing data structures, or optimizing memory management, mastering linked lists is an essential skill for any programmer."
    },
    {
        "link": "https://stackoverflow.com/questions/9516884/problems-with-understanding-a-linked-list-implementation",
        "document": "Update: Thanks a lot to everybody who responded!!! It made me feel that I'm not completely alone in my efforts to learn Java. Please excuse me, but I guess I didn't clarify enough what I don't get about linked lists and the exercise application -\n\nfirst - how can a class definition contain an object of itself, OK I know that this is recursion but it's still a very strange and alien concept to me.\n\nsecond - how exactly can a linked list object \"link\" to another node?\n\nthird - if two objects are separated by an equals sign it means what - that the second object disappears and what's left of it is it's \"name\" that now points to the first object or vice versa?\n\nthen - the thing that I don't get about the program I quoted below is the following: after the linkList class is instantiated it's constructor is called and it gives the object of class Link private Link first the value of null, i.e. sets it pointing to nothing. Then, when the first new node is created the method public void insertFirst is called, it gives the object values to its variables and then something absurd happens - the object first that points to nothing is assigned to the new item thus making both objects pointing to nothing and with the first = newLink; I'm completely lost...\n\nI'm doing a college course on Algorithms and Data structures and since the professor is really mean and his explanations are useless I'm trying to learn on my own from a book called Algorithms and data structures by Robert Lafore.\n\nNow I'm learning Linked lists and there is the following code example for a linked list implementation in the book:\n\nI just CANNOT understand the code that inserts and displays items in the linked list class.\n\nHow can it be that newLink.next = first; and first = newLink; after the new object is created?"
    },
    {
        "link": "https://cwblogs.com/posts/linked-list2",
        "document": "Although simple, linked lists are crucial in data structures, providing a dynamic and flexible way of storing and managing data. It is important for us to avoid some common pitfalls in linked lists and learn how to perform common operations with linked list.\n• Common Operations with Linked List\n• Delete the n-th Node From the Bottom\n\nOne of the first errors often encountered is an incorrect handling of an empty linked list, especially when inserting the first node or deleting the last node.\n• Always check if the head pointer is (for an empty list) before performing operations.\n• When inserting the first node, remember to set the head to the newly created node.\n• When deleting nodes, if the list becomes empty, ensure you reset the head (and tail, in a doubly linked list) to .\n\nWhen inserting or deleting nodes, especially in a singly linked list, there’s a risk of losing access to the rest of the list if the next pointers are not handled correctly.\n• When inserting nodes, always pay attention to the order of operations.\n\nFor example, insert the x node:\n\nYou need to do first, then , so that you don’t lose the pointer. If the above code changes the order, the linked list will be broken.\n\nIn languages like C and C++, where manual memory management is required, forgetting to free the memory of deleted nodes can lead to memory leaks.\n• Always use or the appropriate memory deallocation function to free the memory of a node immediately after it is removed from the list.\n\nParticularly in circular linked lists, incorrect handling of pointers when adding or removing nodes can lead to infinite loops or lost segments of the list.\n• Use caution when traversing circular linked lists to avoid infinite loops by checking for the return to the head node as a termination condition.\n\nDelete the n-th Node From the Bottom\n\n// Create a dummy head to simplify edge cases, such as removing the actual head node // Advance first pointer so there's an n-node gap between first and second // n must be greater than 0 and less than or equal to the length of the list. // Move first to the end, maintaining the gap // Skip the nth node from the end // Return the head of the modified list\n• Wang, Zheng (2019) The Beauty of Data Structures and Algorithms. Geek Time."
    }
]