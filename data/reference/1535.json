[
    {
        "link": "https://mongoosejs.com/docs/6.x/docs/guide.html",
        "document": "If you haven't yet done so, please take a minute to read the quickstart to get an idea of how Mongoose works. If you are migrating from 5.x to 6.x please take a moment to read the migration guide.\n\nEverything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n\nIf you want to add additional keys later, use the Schema#add method.\n\nEach key in our code defines a property in our documents which will be cast to its associated SchemaType. For example, we've defined a property which will be cast to the String SchemaType and property which will be cast to a SchemaType.\n\nNotice above that if a property only requires a type, it can be specified using a shorthand notation (contrast the property above with the property).\n\nKeys may also be assigned nested objects containing further key/type definitions like the property above. This will happen whenever a key's value is a POJO that doesn't have a property.\n\nIn these cases, Mongoose only creates actual schema paths for leaves in the tree. (like and above), and the branches do not have actual paths. A side-effect of this is that above cannot have its own validation. If validation is needed up the tree, a path needs to be created up the tree - see the Subdocuments section for more information on how to do this. Also read the Mixed subsection of the SchemaTypes guide for some gotchas.\n\nRead more about SchemaTypes here.\n\nSchemas not only define the structure of your document and casting of properties, they also define document instance methods, static Model methods, compound indexes, and document lifecycle hooks called middleware.\n\nTo use our schema definition, we need to convert our into a Model we can work with. To do so, we pass it into :\n\nBy default, Mongoose adds an property to your schemas.\n\nWhen you create a new document with the automatically added property, Mongoose creates a new of type ObjectId to your document.\n\nYou can also overwrite Mongoose's default with your own . Just be careful: Mongoose will refuse to save a document that doesn't have an , so you're responsible for setting if you define your own path.\n\nInstances of are documents. Documents have many of their own built-in instance methods. We may also define our own custom document instance methods.\n\nNow all of our instances have a method available to them.\n• Overwriting a default mongoose document method may lead to unpredictable results. See this for more details.\n• The example above uses the object directly to save an instance method. You can also use the helper as described here.\n• Do not declare methods using ES6 arrow functions ( ). Arrow functions explicitly prevent binding , so your method will not have access to the document and the above examples will not work.\n\nYou can also add static functions to your model. There are three equivalent ways to add a static:\n• Add a function property to the second argument of the schema-constructor ( )\n\nDo not declare statics using ES6 arrow functions ( ). Arrow functions explicitly prevent binding , so the above examples will not work because of the value of .\n\nYou can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's chainable query builder API.\n\nMongoDB supports secondary indexes. With mongoose, we define these indexes within our at the path level or the level. Defining indexes at the schema level is necessary when creating compound indexes.\n\nSee SchemaType#index() for other index options.\n\nWhen your application starts up, Mongoose automatically calls for each defined index in your schema. Mongoose will call for each index sequentially, and emit an 'index' event on the model when all the calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a significant performance impact. Disable the behavior by setting the option of your schema to , or globally on the connection by setting the option to .\n\nMongoose will emit an event on the model when indexes are done building or an error occurred.\n\nSee also the Model#ensureIndexes method.\n\nVirtuals are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.\n\nSuppose you want to print out the person's full name. You could do it yourself:\n\nBut concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like removing diacritics? A virtual property getter lets you define a property that won't get persisted to MongoDB.\n\nNow, mongoose will call your getter function every time you access the property:\n\nIf you use or mongoose will not include virtuals by default. This includes the output of calling on a Mongoose document, because calls . Pass to either or .\n\nYou can also add a custom setter to your virtual that will let you set both first name and last name via the virtual.\n\nVirtual property setters are applied before other validation. So the example above would still work even if the and name fields were required.\n\nOnly non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.\n\nYou can learn more about virtuals here.\n\nAliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.\n\nYou can also declare aliases on nested paths. It is easier to use nested schemas and subdocuments, but you can also declare nested path aliases inline as long as you use the full nested path as the alias.\n\nSchemas have a few configurable options which can be passed to the constructor or to the method:\n\nBy default, Mongoose's function creates all the indexes defined in your model's schema by calling after you successfully connect to MongoDB. Creating indexes automatically is great for development and test environments. But index builds can also create significant load on your production database. If you want to manage indexes carefully in production, you can set to false.\n\nThe option is set to by default. You can change this default by setting\n\nBefore Mongoose builds indexes, it calls to create the underlying collection in MongoDB by default. Calling sets the collection's default collation based on the collation option and establishes the collection as a capped collection if you set the schema option.\n\nYou can disable this behavior by setting to using . Like , is helpful for development and test environments, but you may want to disable it for production to avoid unnecessary database calls.\n\nUnfortunately, cannot change an existing collection. For example, if you add to your schema and the existing collection is not capped, will not overwrite the existing collection. That is because the MongoDB server does not allow changing a collection's options without dropping the collection first.\n\nBy default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set to false.\n\nIf is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n\nMongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be , set the option to the maximum size of the collection in bytes.\n\nThe option may also be set to an object if you want to pass additional options like max. In this case you must explicitly pass the option, which is required.\n\nMongoose by default produces a collection name by passing the model name to the method. This method pluralizes the name. Set this option if you need a different name for your collection.\n\nWhen you define a discriminator, Mongoose adds a path to your schema that stores which discriminator a document is an instance of. By default, Mongoose adds an path, but you can set to overwrite this default.\n\nMongoose assigns each of your schemas an virtual getter by default which returns the document's field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an getter added to your schema, you may disable it by passing this option at schema construction time.\n\nMongoose assigns each of your schemas an field by default if one is not passed into the Schema constructor. The type assigned is an ObjectId to coincide with MongoDB's default behavior. If you don't want an added to your schema at all, you may disable it using this option.\n\nYou can only use this option on subdocuments. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an .\n\nMongoose will, by default, \"minimize\" schemas by removing empty objects.\n\nThis behavior can be overridden by setting option to . It will then store empty objects.\n\nTo check whether an object is empty, you can use the helper:\n\nAllows setting query#read options at the schema level, providing us a way to apply default ReadPreferences to all queries derived from a model.\n\nThe alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\nThe read option also allows us to specify tag sets. These tell the driver from which members of the replica-set it should attempt to read. Read more about tag sets here and here.\n\nNOTE: you may also specify the driver read preference strategy option when connecting:\n\nAllows setting write concern at the schema level.\n\nThe option is used when we have a sharded MongoDB architecture. Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we’ll be all set.\n\nNote that Mongoose does not send the command for you. You must configure your shards yourself.\n\nThe strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\nThis also affects the use of to set a property value.\n\nThis value can be overridden at the model instance level by passing a second boolean argument:\n\nThe option may also be set to which will cause errors to be produced instead of dropping the bad data.\n\nNOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.\n\nMongoose supports a separate option to avoid strict mode for query filters. This is because empty query filters cause Mongoose to return all documents in the model, which can cause issues.\n\nThe option does apply to updates. The option is just for query filters.\n\nMongoose has a separate option to toggle strict mode for the parameter to queries.\n\nIn general, we do not recommend passing user-defined objects as query filters:\n\nIn Mongoose 6, is equal to by default. However, you can override this behavior globally:\n\nIn Mongoose 7, default value will be switched back to . You can prepare for the change by specifying:\n\nExactly the same as the toObject option but only applies when the document's method is called.\n\nTo see all available options, read this.\n\nDocuments have a toObject method which converts the mongoose document into a plain JavaScript object. This method accepts a few options. Instead of applying these options on a per-document basis, we may declare the options at the schema level and have them applied to all of the schema's documents by default.\n\nTo have all virtuals show up in your output, set the option to :\n\nTo see all available options, read this.\n\nBy default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.\n\nHowever, for applications like geoJSON, the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n\nBy default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set to false.\n\nThe is a property set on each document when first created by Mongoose. This keys value contains the internal revision of the document. The option is a string that represents the path to use for versioning. The default is . If this conflicts with your application you can configure as such:\n\nNote that Mongoose's default versioning is not a full optimistic concurrency solution. Mongoose's default versioning only operates on arrays as shown below.\n\nIf you need optimistic concurrency support for , you can set the option\n\nDocument versioning can also be disabled by setting the to . DO NOT disable versioning unless you know what you are doing.\n\nMongoose only updates the version key when you use . If you use , , etc. Mongoose will not update the version key. As a workaround, you can use the below middleware.\n\nOptimistic concurrency is a strategy to ensure the document you're updating didn't change between when you loaded it using or , and when you update it using .\n\nFor example, suppose you have a model that contains a list of , and a that represents whether this house shows up in searches. Suppose that a house that has status must have at least two . You might implement the logic of approving a house document as shown below:\n\nThe function looks right in isolation, but there might be a potential issue: what if another function removes the house's photos between the call and the call? For example, the below code will succeed:\n\nIf you set the option on the model's schema, the above script will throw an error.\n\nSets a default collation for every query and aggregation. Here's a beginner-friendly overview of collations.\n\nIf you set the option on a schema, Mongoose will create a timeseries collection for any model that you create from that schema.\n\nallows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For subdocuments, include this on the parent document using the fully qualified path.\n\nThe option tells Mongoose to assign and fields to your schema. The type assigned is Date.\n\nBy default, the names of the fields are and . Customize the field names by setting and .\n\nThe way works under the hood is:\n• If you create a new document, mongoose simply sets , and to the time of creation.\n• If you update a document, mongoose will add to the object.\n• If you set on an update operation, mongoose will use operator to add to the document in case the operation resulted into a new inserted document.\n\nBy default, Mongoose uses to get the current time. If you want to overwrite the function Mongoose uses to get the current time, you can set the option. Mongoose will call the function whenever it needs to get the current time.\n\nMongoose supports defining global plugins, plugins that apply to all schemas.\n\nSometimes, you may only want to apply a given plugin to some schemas. In that case, you can add to a schema:\n\nIf you call with a option, Mongoose will only apply that plugin to schemas that have a matching entry in .\n\nBy default, Mongoose will automatically any populated paths for you, unless you explicitly exclude them.\n\nTo opt out of selecting populated fields by default, set to in your schema.\n\nFor legacy reasons, when there is a validation error in subpath of a single nested schema, Mongoose will record that there was a validation error in the single nested schema path as well. For example:\n\nSet the to on the child schema to make Mongoose only reports the parent error.\n\nSchemas have a method that you can use to create a Mongoose schema from an ES6 class:\n\nHere's an example of using to create a schema from an ES6 class:\n\nSchemas are also pluggable which allows us to package up reusable features into plugins that can be shared with the community or just between your projects.\n\nTo get the most out of MongoDB, you need to learn the basics of MongoDB schema design. SQL schema design (third normal form) was designed to minimize storage costs, whereas MongoDB schema design is about making common queries as fast as possible. The 6 Rules of Thumb for MongoDB Schema Design blog series is an excellent resource for learning the basic rules for making your queries fast.\n\nUsers looking to master MongoDB schema design in Node.js should look into The Little MongoDB Schema Design Book by Christian Kvalheim, the original author of the MongoDB Node.js driver. This book shows you how to implement performant schemas for a laundry list of use cases, including e-commerce, wikis, and appointment bookings.\n\nNow that we've covered , let's take a look at SchemaTypes."
    },
    {
        "link": "https://mongoosejs.com/docs/guide.html",
        "document": "If you haven't yet done so, please take a minute to read the quickstart to get an idea of how Mongoose works. If you are migrating from 7.x to 8.x please take a moment to read the migration guide.\n\nEverything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n\nIf you want to add additional keys later, use the Schema#add method.\n\nEach key in our code defines a property in our documents which will be cast to its associated SchemaType. For example, we've defined a property which will be cast to the String SchemaType and property which will be cast to a SchemaType.\n\nNotice above that if a property only requires a type, it can be specified using a shorthand notation (contrast the property above with the property).\n\nKeys may also be assigned nested objects containing further key/type definitions like the property above. This will happen whenever a key's value is a POJO that doesn't have a property.\n\nIn these cases, Mongoose only creates actual schema paths for leaves in the tree. (like and above), and the branches do not have actual paths. A side-effect of this is that above cannot have its own validation. If validation is needed up the tree, a path needs to be created up the tree - see the Subdocuments section for more information on how to do this. Also read the Mixed subsection of the SchemaTypes guide for some gotchas.\n\nRead more about SchemaTypes here.\n\nSchemas not only define the structure of your document and casting of properties, they also define document instance methods, static Model methods, compound indexes, and document lifecycle hooks called middleware.\n\nTo use our schema definition, we need to convert our into a Model we can work with. To do so, we pass it into :\n\nBy default, Mongoose adds an property to your schemas.\n\nWhen you create a new document with the automatically added property, Mongoose creates a new of type ObjectId to your document.\n\nYou can also overwrite Mongoose's default with your own . Just be careful: Mongoose will refuse to save a top-level document that doesn't have an , so you're responsible for setting if you define your own path.\n\nMongoose also adds an property to subdocuments. You can disable the property on your subdocuments as follows. Mongoose does allow saving subdocuments without an property.\n\nAlternatively, you can disable using the following syntax:\n\nInstances of are documents. Documents have many of their own built-in instance methods. We may also define our own custom document instance methods.\n\nNow all of our instances have a method available to them.\n• Overwriting a default mongoose document method may lead to unpredictable results. See this for more details.\n• The example above uses the object directly to save an instance method. You can also use the helper as described here.\n• Do not declare methods using ES6 arrow functions ( ). Arrow functions explicitly prevent binding , so your method will not have access to the document and the above examples will not work.\n\nYou can also add static functions to your model. There are three equivalent ways to add a static:\n• Add a function property to the second argument of the schema-constructor ( )\n\nDo not declare statics using ES6 arrow functions ( ). Arrow functions explicitly prevent binding , so the above examples will not work because of the value of .\n\nYou can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's chainable query builder API.\n\nMongoDB supports secondary indexes. With mongoose, we define these indexes within our at the path level or the level. Defining indexes at the schema level is necessary when creating compound indexes.\n\nSee SchemaType#index() for other index options.\n\nWhen your application starts up, Mongoose automatically calls for each defined index in your schema. Mongoose will call for each index sequentially, and emit an 'index' event on the model when all the calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a significant performance impact. Disable the behavior by setting the option of your schema to , or globally on the connection by setting the option to .\n\nMongoose will emit an event on the model when indexes are done building or an error occurred.\n\nSee also the Model#ensureIndexes method.\n\nVirtuals are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.\n\nSuppose you want to print out the person's full name. You could do it yourself:\n\nBut concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like removing diacritics? A virtual property getter lets you define a property that won't get persisted to MongoDB.\n\nNow, mongoose will call your getter function every time you access the property:\n\nIf you use or Mongoose will not include virtuals by default. Pass to or to include virtuals.\n\nThe above caveat for also includes the output of calling on a Mongoose document, because calls . To include virtuals in output, you can either call on the document before calling , or set the option on your schema.\n\nYou can also add a custom setter to your virtual that will let you set both first name and last name via the virtual.\n\nVirtual property setters are applied before other validation. So the example above would still work even if the and name fields were required.\n\nOnly non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.\n\nYou can learn more about virtuals here.\n\nAliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.\n\nYou can also declare aliases on nested paths. It is easier to use nested schemas and subdocuments, but you can also declare nested path aliases inline as long as you use the full nested path as the alias.\n\nSchemas have a few configurable options which can be passed to the constructor or to the method:\n\nBy default, Mongoose's function creates all the indexes defined in your model's schema by calling after you successfully connect to MongoDB. Creating indexes automatically is great for development and test environments. But index builds can also create significant load on your production database. If you want to manage indexes carefully in production, you can set to false.\n\nThe option is set to by default. You can change this default by setting\n\nBefore Mongoose builds indexes, it calls to create the underlying collection in MongoDB by default. Calling sets the collection's default collation based on the collation option and establishes the collection as a capped collection if you set the schema option.\n\nYou can disable this behavior by setting to using . Like , is helpful for development and test environments, but you may want to disable it for production to avoid unnecessary database calls.\n\nUnfortunately, cannot change an existing collection. For example, if you add to your schema and the existing collection is not capped, will not overwrite the existing collection. That is because the MongoDB server does not allow changing a collection's options without dropping the collection first.\n\nBy default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set to false.\n\nIf is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n\nMongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be , set the option to the maximum size of the collection in bytes.\n\nThe option may also be set to an object if you want to pass additional options like max. In this case you must explicitly pass the option, which is required.\n\nMongoose by default produces a collection name by passing the model name to the method. This method pluralizes the name. Set this option if you need a different name for your collection.\n\nWhen you define a discriminator, Mongoose adds a path to your schema that stores which discriminator a document is an instance of. By default, Mongoose adds an path, but you can set to overwrite this default.\n\nWhen is , Mongoose will not create indexes from the given subdocument schema. This option only works when the schema is used in a subdocument path or document array path, Mongoose ignores this option if set on the top-level schema for a model. Defaults to .\n\nMongoose assigns each of your schemas an virtual getter by default which returns the document's field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an getter added to your schema, you may disable it by passing this option at schema construction time.\n\nMongoose assigns each of your schemas an field by default if one is not passed into the Schema constructor. The type assigned is an ObjectId to coincide with MongoDB's default behavior. If you don't want an added to your schema at all, you may disable it using this option.\n\nYou can only use this option on subdocuments. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an .\n\nMongoose will, by default, \"minimize\" schemas by removing empty objects.\n\nThis behavior can be overridden by setting option to . It will then store empty objects.\n\nTo check whether an object is empty, you can use the helper:\n\nAllows setting query#read options at the schema level, providing us a way to apply default ReadPreferences to all queries derived from a model.\n\nThe alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\nThe read option also allows us to specify tag sets. These tell the driver from which members of the replica-set it should attempt to read. Read more about tag sets here and here.\n\nNOTE: you may also specify the driver read preference strategy option when connecting:\n\nAllows setting write concern at the schema level.\n\nThe option is used when we have a sharded MongoDB architecture. Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we’ll be all set.\n\nNote that Mongoose does not send the command for you. You must configure your shards yourself.\n\nThe strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\nThis also affects the use of to set a property value.\n\nThis value can be overridden at the model instance level by passing a second boolean argument:\n\nThe option may also be set to which will cause errors to be produced instead of dropping the bad data.\n\nNOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.\n\nMongoose supports a separate option to avoid strict mode for query filters. This is because empty query filters cause Mongoose to return all documents in the model, which can cause issues.\n\nThe option does apply to updates. The option is just for query filters.\n\nMongoose has a separate option to toggle strict mode for the parameter to queries.\n\nIn general, we do not recommend passing user-defined objects as query filters:\n\nIn Mongoose 7, is by default. However, you can override this behavior globally:\n\nExactly the same as the toObject option but only applies when the document's method is called.\n\nTo see all available options, read this.\n\nDocuments have a toObject method which converts the mongoose document into a plain JavaScript object. This method accepts a few options. Instead of applying these options on a per-document basis, we may declare the options at the schema level and have them applied to all of the schema's documents by default.\n\nTo have all virtuals show up in your output, set the option to :\n\nTo see all available options, read this.\n\nBy default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.\n\nHowever, for applications like geoJSON, the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n\nBy default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set to false.\n\nThe is a property set on each document when first created by Mongoose. This keys value contains the internal revision of the document. The option is a string that represents the path to use for versioning. The default is . If this conflicts with your application you can configure as such:\n\nNote that Mongoose's default versioning is not a full optimistic concurrency solution. Mongoose's default versioning only operates on arrays as shown below.\n\nIf you need optimistic concurrency support for , you can set the option.\n\nDocument versioning can also be disabled by setting the to . DO NOT disable versioning unless you know what you are doing.\n\nMongoose only updates the version key when you use . If you use , , etc. Mongoose will not update the version key. As a workaround, you can use the below middleware.\n\nOptimistic concurrency is a strategy to ensure the document you're updating didn't change between when you loaded it using or , and when you update it using .\n\nFor example, suppose you have a model that contains a list of , and a that represents whether this house shows up in searches. Suppose that a house that has status must have at least two . You might implement the logic of approving a house document as shown below:\n\nThe function looks right in isolation, but there might be a potential issue: what if another function removes the house's photos between the call and the call? For example, the below code will succeed:\n\nIf you set the option on the model's schema, the above script will throw an error.\n\nSets a default collation for every query and aggregation. Here's a beginner-friendly overview of collations.\n\nIf you set the option on a schema, Mongoose will create a timeseries collection for any model that you create from that schema.\n\nallows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For subdocuments, include this on the parent document using the fully qualified path.\n\nThe option tells Mongoose to assign and fields to your schema. The type assigned is Date.\n\nBy default, the names of the fields are and . Customize the field names by setting and .\n\nThe way works under the hood is:\n• If you create a new document, mongoose simply sets , and to the time of creation.\n• If you update a document, mongoose will add to the object.\n• If you set on an update operation, mongoose will use operator to add to the document in case the operation resulted into a new inserted document.\n\nBy default, Mongoose uses to get the current time. If you want to overwrite the function Mongoose uses to get the current time, you can set the option. Mongoose will call the function whenever it needs to get the current time.\n\nMongoose supports defining global plugins, plugins that apply to all schemas.\n\nSometimes, you may only want to apply a given plugin to some schemas. In that case, you can add to a schema:\n\nIf you call with a option, Mongoose will only apply that plugin to schemas that have a matching entry in .\n\nBy default, Mongoose will automatically any populated paths for you, unless you explicitly exclude them.\n\nTo opt out of selecting populated fields by default, set to in your schema.\n\nFor legacy reasons, when there is a validation error in subpath of a single nested schema, Mongoose will record that there was a validation error in the single nested schema path as well. For example:\n\nSet the to on the child schema to make Mongoose only reports the parent error.\n\nOptions like and affect the options Mongoose passes to MongoDB when creating a new collection. Mongoose schemas support most MongoDB options, but not all. You can use the option to set any options; Mongoose will use as the default values when calling for your schema.\n\nSimilar to , except for automatically creates any Atlas search indexes defined in your schema. Unlike , this option defaults to false.\n\nRead concerns are similar to , but for read operations like and . To set a default , pass the option to the schema constructor as follows.\n\nSchemas have a method that you can use to create a Mongoose schema from an ES6 class:\n\nHere's an example of using to create a schema from an ES6 class:\n\nSchemas are also pluggable which allows us to package up reusable features into plugins that can be shared with the community or just between your projects.\n\nTo get the most out of MongoDB, you need to learn the basics of MongoDB schema design. SQL schema design (third normal form) was designed to minimize storage costs, whereas MongoDB schema design is about making common queries as fast as possible. The 6 Rules of Thumb for MongoDB Schema Design blog series is an excellent resource for learning the basic rules for making your queries fast.\n\nUsers looking to master MongoDB schema design in Node.js should look into The Little MongoDB Schema Design Book by Christian Kvalheim, the original author of the MongoDB Node.js driver. This book shows you how to implement performant schemas for a laundry list of use cases, including e-commerce, wikis, and appointment bookings.\n\nNow that we've covered , let's take a look at SchemaTypes."
    },
    {
        "link": "https://geeksforgeeks.org/mongoose-schemas-creating-a-model",
        "document": "Mongoose is one of the most popular Object Data Modeling (ODM) libraries for MongoDB, providing schema-based solutions to model our application’s data. This allows us to define the structure of documents within a MongoDB collection, including validation, typecasting, and other powerful features that simplify database operations.\n\nWhat is Mongoose Schema and Model?\n\nBefore diving into creating a model, it’s important to understand the schema and model concepts in MongoDB:\n\nSchema: A MongoDB schema defines the structure of documents within a collection. It specifies the fields, their types, validation rules, default values, and other constraints.\n\nModel: A model is a wrapper around the schema that allows us to interact with the MongoDB database (CRUD operations like create, read, update, delete). It provides an interface for querying and manipulating the data.\n\nTo demonstrate how to create a model using Mongoose, follow these steps to set up the environment:\n\nFirst, we need to create a Node.js project if you haven’t done so already. Run the following command in your terminal:\n\nThis will generate a file, which will manage the project’s dependencies.\n\nWe can start the developement server using the below command.\n\nNote: The above command will not do anything right now since we have not written any code in our JavaScript file.\n\nWe need to install the required modules to use in our project. Run the following command to install mongoose and mongosd as dependencies.\n\nNow, create an app.js file where you will define the Mongoose schema and model and connect to MongoDB. Start by connecting to your MongoDB instance:\n\nTo create a schema and model in Mongoose, define a schema with fields like name, power type, gold, health, and mana for a “Mage.” Use mongoose.Schema() to set up the structure, ensuring required fields. Then, use mongoose.model() to create a model based on this schema, enabling interaction with the database.\n\nStep 5: Create the Model Using the Schema\n\nOnce the schema is defined, create a model using . This model will provide an interface to interact with the collection in the MongoDB database.\n\nStep 6: Create and Save Documents Using the Model\n\nTo create and save a model in Mongoose, instantiate an object from the model class using the new keyword, then call the save() method on this object to create a document in the corresponding MongoDB collection.\n\nWe can view the saved model and document by opening up the Studio 3T desktop application, clicking on connect, and then going through the following hierarchy and double click on the mode collection name.\n\nThis is what you will see when you double-click on the collection name. Notice that it has been given an _id field automatically.\n\nWe can create as many objects from the Mage class as you want, and call the save() method on them to create a document for each of them in the mages collection.\n\nBenefits of Using Mongoose Schema and Model\n\n1. Schema Validation: Mongoose automatically validates data based on the defined schema before saving it to the database.\n\n2. Ease of Use: Mongoose provides a simple interface to work with MongoDB, eliminating the need to write complex queries manually.\n\n3. Middleware Support: Mongoose supports middleware (pre and post hooks), allowing you to run custom logic before or after database operations.\n\nMongoose is a powerful tool for managing MongoDB collections in a Node.js application. By defining schemas and models, Mongoose allows us to structure your data, perform validation, and interact with MongoDB in a straightforward and efficient manner. With the ability to create complex models, define indexes, and validate documents, Mongoose significantly streamlines the development of MongoDB-based applications.\n\nWhat is MongoDB schema and model?\n\nHow do you create an index in Mongoose schema?\n\nHow to create a model in MongoDB?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/mongoose",
        "document": "Before you jump in and start coding the models, it's worth taking a few minutes to think about what data we need to store and the relationships between the different objects. We know that we need to store information about books (title, summary, author, genre, ISBN) and that we might have multiple copies available (with globally unique ids, availability statuses, etc.). We might need to store more information about the author than just their name, and there might be multiple authors with the same or similar names. We want to be able to sort information based on the book title, author, genre, and category. When designing your models it makes sense to have separate models for every \"object\" (a group of related information). In this case some obvious candidates for these models are books, book instances, and authors. You might also want to use models to represent selection-list options (e.g. like a drop-down list of choices), rather than hard-coding the choices into the website itself — this is recommended when all the options aren't known up front or may change. A good example is a genre (e.g. fantasy, science fiction, etc.). Once we've decided on our models and fields, we need to think about the relationships between them. With that in mind, the UML association diagram below shows the models we'll define in this case (as boxes). As discussed above, we've created models for the book (the generic details of the book), book instance (status of specific physical copies of the book available in the system), and author. We have also decided to have a model for the genre so that values can be created dynamically. We've decided not to have a model for the — we will hard code the acceptable values because we don't expect these to change. Within each of the boxes, you can see the model name, the field names and types, and also the methods and their return types. The diagram also shows the relationships between the models, including their multiplicities. The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each model that may be present in the relationship. For example, the connecting line between the boxes shows that and a are related. The numbers close to the model show that a must have zero or more s (as many as you like), while the numbers on the other end of the line next to the show that a book can have zero or more associated s. Note: As discussed in our Mongoose primer below it is often better to have the field that defines the relationship between the documents/models in just one model (you can still find the reverse relationship by searching for the associated in the other model). Below we have chosen to define the relationship between / and / in the Book schema, and the relationship between the / in the Schema. This choice was somewhat arbitrary — we could equally well have had the field in the other schema. Note: The next section provides a basic primer explaining how models are defined and used. As you read it, consider how we will construct each of the models in the diagram above.\n\nDatabase methods to create, find, update, or delete records are asynchronous. What this means is that the methods return immediately, and the code to handle the success or failure of the method runs at a later time when the operation completes. Other code can execute while the server is waiting for the database operation to complete, so the server can remain responsive to other requests. JavaScript has a number of mechanisms for supporting asynchronous behavior. Historically JavaScript relied heavily on passing callback functions to asynchronous methods to handle the success and error cases. In modern JavaScript callbacks have largely been replaced by Promises. Promises are objects that are (immediately) returned by an asynchronous method that represent its future state. When the operation completes, the promise object is \"settled\", and resolves an object that represents the result of the operation or an error. There are two main ways you can use promises to run code when a promise is settled, and we highly recommend that you read How to use promises for a high level overview of both approaches. In this tutorial, we'll primarily be using to wait on promise completion within an , because this leads to more readable and understandable asynchronous code. The way this approach works is that you use the keyword to mark a function as asynchronous, and then inside that function apply to any method that returns a promise. When the asynchronous function is executed its operation is paused at the first method until the promise settles. From the perspective of the surrounding code the asynchronous function then returns and the code after it is able to run. Later when the promise settles, the method inside the asynchronous function returns with the result, or an error is thrown if the promise was rejected. The code in the asynchronous function then executes until either another is encountered, at which point it will pause again, or until all the code in the function has been run. You can see how this works in the example below. is an asynchronous function that is called within a block. When is run, code execution is paused at until the promise resolves, at which point the code continues to and waits again. The code in the block runs if an error is thrown in the asynchronous function, and this will happen if the promise returned by either of the methods is rejected. The asynchronous methods above are run in sequence. If the methods don't depend on each other then you can run them in parallel and finish the whole operation more quickly. This is done using the method, which takes an iterable of promises as input and returns a single . This returned promise fulfills when all of the input's promises fulfill, with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason. The code below shows how this works. First, we have two functions that return promises. We on both of them to complete using the promise returned by . Once they both complete returns and the results array is populated, the function then continues to the next , and waits until the promise returned by is settled. You would call the in a block to catch any errors. Promises with / allow both flexible and \"comprehensible\" control over asynchronous execution!\n\nModels are defined using the interface. The Schema allows you to define the fields stored in each document along with their validation requirements and default values. In addition, you can define static and instance helper methods to make it easier to work with your data types, and also virtual properties that you can use like any other field, but which aren't actually stored in the database (we'll discuss a bit further below). Schemas are then \"compiled\" into models using the method. Once you have a model you can use it to find, create, update, and delete objects of the given type. Note: Each model maps to a collection of documents in the MongoDB database. The documents will contain the fields/schema types defined in the model . The code fragment below shows how you might define a simple schema. First you mongoose, then use the Schema constructor to create a new schema instance, defining the various fields inside it in the constructor's object parameter. In the case above we just have two fields, a string and a date. In the next sections, we will show some of the other field types, validation, and other methods. Models are created from schemas using the method: The first argument is the singular name of the collection that will be created for your model (Mongoose will create the database collection for the model SomeModel above), and the second argument is the schema you want to use in creating the model. Note: Once you've defined your model classes you can use them to create, update, or delete records, and run queries to get all records or particular subsets of records. We'll show you how to do this in the Using models section, and when we create our views. A schema can have an arbitrary number of fields — each one represents a field in the documents stored in MongoDB. An example schema showing many of the common field types and how they are declared is shown below. const schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now() }, age: { type: Number, min: 18, max: 65, required: true }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, array: [], ofString: [String], // You can also have an array of each of the other types too. nested: { stuff: { type: String, lowercase: true, trim: true } }, }); Most of the SchemaTypes (the descriptors after \"type:\" or after field names) are self-explanatory. The exceptions are:\n• : Represents specific instances of a model in the database. For example, a book might use this to represent its author object. This will actually contain the unique ID ( ) for the specified object. We can use the method to pull in the associated information when needed.\n• : An array of items. You can perform JavaScript array operations on these models (push, pop, unshift, etc.). The examples above show an array of objects without a specified type and an array of objects, but you can have an array of any type of object. The code also shows both ways of declaring a field:\n• Field name and type as a key-value pair (i.e. as done with fields , and ).\n• Field name followed by an object defining the , and any other options for the field. Options include things like:\n• Whether the field is required\n• Whether fields should automatically be set to lowercase, uppercase, or trimmed (e.g. ) For more information about options see SchemaTypes (Mongoose docs). Mongoose provides built-in and custom validators, and synchronous and asynchronous validators. It allows you to specify both the acceptable range of values and the error message for validation failure in all cases.\n• All SchemaTypes have the built-in required validator. This is used to specify whether the field must be supplied in order to save a document.\n• \n• enum: specifies the set of allowed values for the field.\n• match: specifies a regular expression that the string must match.\n• maxLength and minLength for the string. The example below (slightly modified from the Mongoose documents) shows how you can specify some of the validator types and error messages: const breakfastSchema = new Schema({ eggs: { type: Number, min: [6, \"Too few eggs\"], max: 12, required: [true, \"Why no eggs?\"], }, drink: { type: String, enum: [\"Coffee\", \"Tea\", \"Water\"], }, }); For complete information on field validation see Validation (Mongoose docs). Virtual properties are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage. The example in the documentation constructs (and deconstructs) a full name virtual property from a first and last name field, which is easier and cleaner than constructing a full name every time one is used in a template. Note: We will use a virtual property in the library to define a unique URL for each model record using a path and the record's value. For more information see Virtuals (Mongoose documentation). A schema can also have instance methods, static methods, and query helpers. The instance and static methods are similar, but with the obvious difference that an instance method is associated with a particular record and has access to the current object. Query helpers allow you to extend mongoose's chainable query builder API (for example, allowing you to add a query \"byName\" in addition to the , and methods).\n\nOnce you've created a schema you can use it to create models. The model represents a collection of documents in the database that you can search, while the model's instances represent individual documents that you can save and retrieve. We provide a brief overview below. For more information see: Models (Mongoose docs). Note: Creation, update, deletion and querying of records are asynchronous operations that return a promise. The examples below show just the use of the relevant methods and (i.e. the essential code for using the methods). The surrounding and block to catch errors are omitted for clarity. For more information on using see Database APIs are asynchronous above. To create a record you can define an instance of the model and then call on it. The examples below assume is a model (with a single field ) that we have created from our schema. // Create an instance of model SomeModel const awesome_instance = new SomeModel({ name: \"awesome\" }); // Save the new model instance asynchronously await awesome_instance.save(); You can also use to define the model instance at the same time as you save it. Below we create just one, but you can create multiple instances by passing in an array of objects. Every model has an associated connection (this will be the default connection when you use ). You create a new connection and call on it to create the documents on a different database. You can access the fields in this new record using the dot syntax, and change the values. You have to call or to store modified values back to the database. // Access model field values using dot notation console.log(awesome_instance.name); //should log 'also_awesome' // Change record by modifying the fields, then calling save(). awesome_instance.name = \"New cool name\"; await awesome_instance.save(); You can search for records using query methods, specifying the query conditions as a JSON document. The code fragment below shows how you might find all athletes in a database that play tennis, returning just the fields for athlete name and age. Here we just specify one matching field (sport) but you can add more criteria, specify regular expression criteria, or remove the conditions altogether to return all athletes. const Athlete = mongoose.model(\"Athlete\", yourSchema); // find all athletes who play tennis, returning the 'name' and 'age' fields const tennisPlayers = await Athlete.find( { sport: \"Tennis\" }, \"name age\", ).exec(); Note: It is important to remember that not finding any results is not an error for a search — but it may be a fail-case in the context of your application. If your application expects a search to find a value you can check the number of entries returned in the result. Query APIs, such as , return a variable of type Query. You can use a query object to build up a query in parts before executing it with the method. executes the query and returns a promise that you can on for the result. // find all athletes that play tennis const query = Athlete.find({ sport: \"Tennis\" }); // selecting the 'name' and 'age' fields query.select(\"name age\"); // limit our results to 5 items query.limit(5); // sort by age query.sort({ age: -1 }); // execute the query at a later time query.exec(); Above we've defined the query conditions in the method. We can also do this using a function, and we can chain all the parts of our query together using the dot operator (.) rather than adding them separately. The code fragment below is the same as our query above, with an additional condition for the age. The method gets all matching records, but often you just want to get one match. The following methods query for a single record:\n• : Finds the document with the specified (every document has a unique ).\n• : Finds a single document that matches the specified criteria.\n• , , , : Finds a single document by or criteria and either updates or removes it. These are useful convenience functions for updating and removing records. Note: There is also a method that you can use to get the number of items that match conditions. This is useful if you want to perform a count without actually fetching the records. There is a lot more you can do with queries. For more information see: Queries (Mongoose docs). You can create references from one document/model instance to another using the schema field, or from one document to many using an array of . The field stores the id of the related model. If you need the actual content of the associated document, you can use the method in a query to replace the id with the actual data. For example, the following schema defines authors and stories. Each author can have multiple stories, which we represent as an array of . Each story can have a single author. The property tells the schema which model can be assigned to this field. const mongoose = require(\"mongoose\"); const Schema = mongoose.Schema; const authorSchema = new Schema({ name: String, stories: [{ type: Schema.Types.ObjectId, ref: \"Story\" }], }); const storySchema = new Schema({ author: { type: Schema.Types.ObjectId, ref: \"Author\" }, title: String, }); const Story = mongoose.model(\"Story\", storySchema); const Author = mongoose.model(\"Author\", authorSchema); We can save our references to the related document by assigning the value. Below we create an author, then a story, and assign the author id to our story's author field. const bob = new Author({ name: \"Bob Smith\" }); await bob.save(); // Bob now exists, so lets create a story const story = new Story({ title: \"Bob goes sledding\", author: bob._id, // assign the _id from our author Bob. This ID is created by default! }); await story.save(); Note: One great benefit of this style of programming is that we don't have to complicate the main path of our code with error checking. If any of the operations fail, the promise will reject and an error will be thrown. Our error handling code deals with that separately (usually in a block), so the intent of our code is very clear. Our story document now has an author referenced by the author document's ID. In order to get the author information in the story results we use , as shown below. Story.findOne({ title: \"Bob goes sledding\" }) .populate(\"author\") // Replace the author id with actual author information in results .exec(); Note: Astute readers will have noted that we added an author to our story, but we didn't do anything to add our story to our author's array. How then can we get all stories by a particular author? One way would be to add our story to the stories array, but this would result in us having two places where the information relating authors and stories needs to be maintained. A better way is to get the of our author, then use to search for this in the author field across all stories. This is almost everything you need to know about working with related items for this tutorial. For more detailed information see Population (Mongoose docs).\n\nNow that we understand something of what Mongoose can do and how we want to design our models, it's time to start work on the LocalLibrary website. The very first thing we want to do is set up a MongoDB database that we can use to store our library data. For this tutorial, we're going to use the MongoDB Atlas cloud-hosted sandbox database. This database tier is not considered suitable for production websites because it has no redundancy, but it is great for development and prototyping. We're using it here because it is free and easy to set up, and because MongoDB Atlas is a popular database as a service vendor that you might reasonably choose for your production database (other popular choices at the time of writing include ScaleGrid and ObjectRocket). Note: If you prefer, you can set up a MongoDB database locally by downloading and installing the appropriate binaries for your system. The rest of the instructions in this article would be similar, except for the database URL you would specify when connecting. In the Express Tutorial Part 7: Deploying to Production tutorial we host both the application and database on Railway, but we could equally well have used a database on MongoDB Atlas. You will first need to create an account with MongoDB Atlas (this is free, and just requires that you enter basic contact details and acknowledge their terms of service). After logging in, you'll be taken to the home screen:\n• Click the + Create button in the Overview section.\n• This will open the Deploy your cluster screen. Click on the M0 FREE option template.\n• Scroll down the page to see the different options you can choose.\n• You can change the name of your Cluster under Cluster Name. We are keeping it as for this tutorial.\n• Deselect the Preload sample dataset checkbox, as we'll import our own sample data later on\n• Select any provider and region from the Provider and Region sections. Different regions offer different providers.\n• Tags are optional. We will not use them here.\n• Click the Create deployment button (creation of the cluster will take some minutes).\n• This will open the Security Quickstart section.\n• Enter a username and password for your application to use to access the database (above we have created a new login \"cooluser\"). Remember to copy and store the credentials safely as we will need them later on. Click the Create User button. Note: Avoid using special characters in your MongoDB user password as mongoose may not parse the connection string properly.\n• Select Add by current IP address to allow access from your current computer\n• Enter in the IP Address field and then click the Add Entry button. This tells MongoDB that we want to allow access from anywhere. Note: It is a best practice to limit the IP addresses that can connect to your database and other resources. Here we allow a connection from anywhere because we don't know where the request will come from after deployment.\n• This will open the following screen. Click on the Go to Overview button.\n• You will return to the Overview screen. Click on the Database section under the Deployment menu on the left. Click the Browse Collections button.\n• This will open the Collections section. Click the Add My Own Data button.\n• This will open the Create Database screen.\n• Enter the name for the new database as .\n• Enter the name of the collection as .\n• Click the Create button to create the database.\n• You will return to the Collections screen with your database created.\n• Click the Overview tab to return to the cluster overview.\n• From the Cluster0 Overview screen click the Connect button.\n• This will open the Connect to Cluster0 screen.\n• Select the Drivers category, then the Driver Node.js and Version as shown.\n• DO NOT install the driver as suggested.\n• Click the Copy icon to copy the connection string.\n• Paste this in your local text editor.\n• Replace placeholder in the connection string with your user's password.\n• Insert the database name \"local_library\" in the path before the options ( )\n• Save the file containing this string somewhere safe. You have now created the database, and have a URL (with username and password) that can be used to access it. This will look something like:"
    },
    {
        "link": "https://habtesoft.medium.com/getting-started-with-mongoose-in-node-js-a-complete-guide-19f6fac6050d",
        "document": "Mongoose is a powerful and popular Object Data Modeling (ODM) library for MongoDB and Node.js. It simplifies interactions with MongoDB by providing a schema-based solution to model your application data, validate it, and manage relationships between objects. In this guide, you’ll learn how to get started with Mongoose in a Node.js application, from setting up to basic CRUD operations.\n\nNot a Medium member? Read this article here\n\nMongoose acts as a bridge between your Node.js application and a MongoDB database. It allows you to define schemas and models for your MongoDB collections, enforcing structure and validation at the application level. This helps ensure that your data remains consistent and correctly formatted before being stored in the database.\n\nBefore diving in, make sure you have the following:\n• MongoDB installed and running (either locally or using a cloud provider like MongoDB Atlas).\n\nTo start using Mongoose, you’ll need to install it in your Node.js project. If you haven’t already set up a Node.js…"
    },
    {
        "link": "https://mongoosejs.com/docs/connections.html",
        "document": "You can connect to MongoDB with the method.\n\nThis is the minimum needed to connect the database running locally on the default port (27017). For local MongoDB databases, we recommend using instead of . That is because Node.js 18 and up prefer IPv6 addresses, which means, on many machines, Node.js will resolve to the IPv6 address and Mongoose will be unable to connect, unless the mongodb instance is running with ipv6 enabled.\n\nYou can also specify several more parameters in the :\n\nSee the mongodb connection string spec for more details.\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will not throw any errors by default if you use a model without connecting.\n\nTo disable buffering, turn off the option on your schema. If you have on and your connection is hanging, try turning off to see if you haven't opened a connection properly. You can also disable globally:\n\nNote that buffering is also responsible for waiting until Mongoose creates collections if you use the option. If you disable buffering, you should also disable the option and use to create capped collections or collections with collations.\n\nThere are two classes of errors that can occur with a Mongoose connection.\n• Error on initial connection: If initial connection fails, Mongoose will emit an 'error' event and the promise returns will reject. However, Mongoose will not automatically try to reconnect.\n• Error after initial connection was established: Mongoose will attempt to reconnect, and it will emit an 'error' event.\n\nTo handle initial connection errors, you should use or with async/await.\n\nTo handle errors after initial connection was established, you should listen for error events on the connection. However, you still need to handle initial connection errors as shown above.\n\nNote that Mongoose does not necessarily emit an 'error' event if it loses connectivity to MongoDB. You should listen to the event to report when Mongoose is disconnected from MongoDB.\n\nThe method also accepts an object which will be passed on to the underlying MongoDB driver.\n\nA full list of options can be found on the MongoDB Node.js driver docs for . Mongoose passes options to the driver without modification, modulo a few exceptions that are explained below.\n• - This is a mongoose-specific option (not passed to the MongoDB driver) that disables Mongoose's buffering mechanism\n• / - The username and password for authentication. These options are Mongoose-specific, they are equivalent to the MongoDB driver's and options.\n• - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set to false, mongoose will not automatically build indexes for any model associated with this connection.\n• - Specifies which database to connect to and overrides any database specified in the connection string. This is useful if you are unable to specify a default database in the connection string like with some syntax connections.\n\nBelow are some of the options that are important for tuning Mongoose.\n• - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, is 100. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js. You may want to decrease if you are running into connection limits.\n• - The minimum number of sockets the MongoDB driver will keep open for this connection. The MongoDB driver may close sockets that have been inactive for some time. You may want to increase if you expect your app to go through long idle times and want to make sure your sockets stay open to avoid slow trains when activity picks up.\n• - How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n• - The MongoDB driver will try to find a server to send any given operation to, and keep retrying for milliseconds. If not set, the MongoDB driver defaults to using (30 seconds).\n• - The MongoDB driver sends a heartbeat every to check on the status of the connection. A heartbeat is subject to , so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits . We recommend you do not set this setting below 1000, too many heartbeats can lead to performance degradation.\n\nThe option is extremely important: it controls how long the MongoDB Node.js driver will attempt to retry any operation before erroring out. This includes initial connection, like , as well as any operations that make requests to MongoDB, like or .\n\nBy default, is 30000 (30 seconds). This means that, for example, if you call when your standalone MongoDB server is down, your call will only throw an error after 30 seconds.\n\nSimilarly, if your standalone MongoDB server goes down after initial connection, any or calls will error out after 30 seconds, unless your MongoDB server is restarted.\n\nWhile 30 seconds seems like a long time, means you're unlikely to see any interruptions during a replica set failover. If you lose your replica set primary, the MongoDB Node driver will ensure that any operations you send during the replica set election will eventually execute, assuming that the replica set election takes less than .\n\nTo get faster feedback on failed connections, you can reduce to 5000 as follows. We don't recommend reducing unless you are running a standalone MongoDB server rather than a replica set, or unless you are using a serverless runtime like AWS Lambda.\n\nThere is no way to tune independently for vs for queries. If you want to reduce for queries and other operations, but still retry for longer, you are responsible for retrying the calls yourself using a loop or a tool like p-retry.\n\nThe function also accepts a callback parameter and returns a promise.\n\nYou can also specify driver options in your connection string as parameters in the query string portion of the URI. This only applies to options passed to the MongoDB driver. You can't set Mongoose-specific options like in the query string.\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for , etc. Best practice is to put options that likely differ between development and production, like or , in the connection string, and options that should remain constant, like or , in the options object.\n\nThe MongoDB docs have a full list of supported connection string options. Below are some options that are often useful to set in the connection string because they are closely associated with the hostname and authentication information.\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n\nConnections inherit from Node.js' class, and emit events when something happens to the connection, like losing connectivity to the MongoDB server. Below is a list of events that a connection may emit.\n• : Emitted when Mongoose starts making its initial connection to the MongoDB server\n• : Emitted when Mongoose successfully makes its initial connection to the MongoDB server, or when Mongoose reconnects after losing connectivity. May be emitted multiple times if Mongoose loses connectivity.\n• : Emitted after and is executed on all of this connection's models. May be emitted multiple times if Mongoose loses connectivity.\n• : Your app called to disconnect from MongoDB. This includes calling , which calls on all connections.\n• : Emitted when Mongoose lost connection to the MongoDB server. This event may be due to your code explicitly closing the connection, the database server crashing, or network connectivity issues.\n• : Emitted after successfully closes the connection. If you call , you'll get both a 'disconnected' event and a 'close' event.\n• : Emitted if Mongoose lost connectivity to MongoDB and successfully reconnected. Mongoose attempts to automatically reconnect when it loses connection to the database.\n• : Emitted if an error occurs on a connection, like a due to malformed data or a payload larger than 16MB.\n\nWhen you're connecting to a single MongoDB server (a \"standalone\"), Mongoose will emit if it gets disconnected from the standalone server, and if it successfully connects to the standalone. In a replica set, Mongoose will emit if it loses connectivity to the replica set primary, and if it manages to reconnect to the replica set primary.\n\nIf you are using , you can use the following to listen to the above events:\n\nWith , use the following instead:\n\nBefore Mongoose 5.2.0, you needed to enable the option to initiate TCP keepalive to prevent errors. However, has been by default since Mongoose 5.2.0, and the is deprecated as of Mongoose 7.2.0. Please remove and options from your Mongoose connections.\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\nTo connect to a single node replica set, specify the option.\n\nThe underlying MongoDB driver uses a process known as server selection to connect to MongoDB and send operations to MongoDB. If the MongoDB driver can't find a server to send an operation to after , you'll get the below error:\n\nYou can configure the timeout using the option to :\n\nA has a property that explains why server selection timed out. For example, if you're connecting to a standalone server with an incorrect password, will contain an \"Authentication failed\" error.\n\nMongoDB replica sets rely on being able to reliably figure out the domain name for each member.\n\nOn Linux and OSX, the MongoDB server uses the output of the command to figure out the domain name to report to the replica set. This can cause confusing errors if you're connecting to a remote MongoDB replica set running on a machine that reports its as :\n\nIf you're experiencing a similar error, connect to the replica set using the shell and run the command to check the host names of each replica set member. Follow this page's instructions to change a replica set member's host name.\n\nYou can also check the property of to see what the MongoDB Node driver thinks the state of your replica set is. The property contains a map of server descriptions.\n\nYou can also connect to multiple mongos instances for high availability in a sharded cluster. You do not need to pass any special options to connect to multiple mongos in mongoose 5.x.\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. Mongoose creates a default connection when you call . You can access the default connection using .\n\nYou may need multiple connections to MongoDB for several reasons. One reason is if you have multiple databases or multiple MongoDB clusters. Another reason is to work around slow trains. The function takes the same arguments as and returns a new connection.\n\nThis connection object is then used to create and retrieve models. Models are always scoped to a single connection.\n\nThe function returns a connection instance, not a promise. If you want to use to make sure Mongoose successfully connects to MongoDB, use the function:\n\nIf you use multiple connections, you should make sure you export schemas, not models. Exporting a model from a file is called the export model pattern. The export model pattern is limited because you can only use one connection.\n\nIf you use the export schema pattern, you still need to create models somewhere. There are two common patterns. The first is to create a function that instantiates a new connection and registers all models on that connection. With this pattern, you may also register connections with a dependency injector or another inversion of control (IOC) pattern.\n\nExporting a function that creates a new connection is the most flexible pattern. However, that pattern can make it tricky to get access to your connection from your route handlers or wherever your business logic is. An alternative pattern is to export a connection and register the models on the connection in the file's top-level scope as follows.\n\nYou can create separate files for each connection, like and if you want to create separate connections for your web API backend and your mobile API backend. Your business logic can then or the connection it needs.\n\nEach , whether created with or are all backed by an internal configurable connection pool defaulting to a maximum size of 100. Adjust the pool size using your connection options:\n\nThe connection pool size is important because MongoDB currently can only process one operation per socket. So functions as a cap on the number of concurrent operations.\n\nIn the context of Mongoose, a multi-tenant architecture typically means a case where multiple different clients talk to MongoDB through a single Mongoose application. This typically means each client makes queries and executes updates through a single Mongoose application, but has a distinct MongoDB database within the same MongoDB cluster.\n\nWe recommend reading this article about multi-tenancy with Mongoose; it has a good description of how we define multi-tenancy and a more detailed overview of our recommended patterns.\n\nThere are two patterns we recommend for multi-tenancy in Mongoose:\n• Maintain one connection pool, switch between tenants using the method.\n• Maintain a separate connection pool per tenant, store connections in a map or POJO.\n\nThe following is an example of pattern (1). We recommend pattern (1) for cases where you have a small number of tenants, or if each individual tenant's workload is light (approximately < 1 request per second, all requests take < 10ms of database processing time). Pattern (1) is simpler to implement and simpler to manage in production, because there is only 1 connection pool. But, under high load, you will likely run into issues where some tenants' operations slow down other tenants' operations due to slow trains.\n\nThe following is an example of pattern (2). Pattern (2) is more flexible and better for use cases with > 10k tenants and > 1 requests/second. Because each tenant has a separate connection pool, one tenants' slow operations will have minimal impact on other tenants. However, this pattern is harder to implement and manage in production. In particular, MongoDB does have a limit on the number of open connections, and MongoDB Atlas has separate limits on the number of open connections, so you need to make sure the total number of sockets in your connection pools doesn't go over MongoDB's limits.\n\nNow that we've covered connections, let's take a look at models."
    },
    {
        "link": "https://geeksforgeeks.org/mongoose-connection-string-options",
        "document": "Mongoose is a JavaScript library that provides a convenient way to interact with MongoDB databases. In order to use Mongoose, you need to create a connection between your Node.js application and the MongoDB server. The Mongoose connection represents this connection and provides a number of useful features, such as connection pooling and events for monitoring the connection status.\n\nParameters: A Mongoose connection string is a URL-like string that contains all the information needed to connect to a MongoDB database using Mongoose.\n\nIt typically includes the following parameters:\n• dbName: The name of the database to connect to.\n• user and pass: The username and password to use for authentication.\n• host: The hostname or IP address of the MongoDB server.\n• port: The port number on which the MongoDB server is listening.\n• useNewUrlParser: Set to true to use the new MongoDB connection string parser.\n• useUnifiedTopology: Set to true to use the new Server Discovery and Monitoring engine.\n• authSource: The name of the database to use for authentication. This is typically the admin database.\n• connectTimeoutMS: specifies the time in milliseconds to wait for a connection to be established before timing out.\n• socketTimeoutMS: specifies the time in milliseconds to wait for a response from the server before timing out.\n• heartbeatFrequencyMS: specifies the frequency in milliseconds to send a server monitoring command to check the health of the server.\n• retryWrites: specifies that write operations should be retried once after a network error.\n• w: specifies the write concern level for write operations. Here, we are using the majority value to require acknowledgment from a majority of replica set members.\n• ssl: Whether to use SSL/TLS for the connection.\n• replicaSet: The name of the replica set to connect to.\n• readPreference: The read preference mode for the connection.\n• writeConcern: The write concern options for the connection.\n\nThese options can be passed in as query parameters in the connection string, or they can be specified as an options object passed to the mongoose.connect() method in your Node.js application.\n\nStep 1: You can install this package by using this command.\n\nStep 2: After installing the mongoose module, you can check your mongoose version in the command prompt using the command.\n\nStep 3: After that, you can just create a folder and add a file for example index.js, To run this file you need to run the following command.\n\nProject Structure: The project structure will look like this:\n\nExample 1: The below code establishes a connection to a MongoDB database running on localhost with the name Geeksforgeeks. The useNewUrlParser and useUnifiedTopology options are specified to use the new MongoDB connection string parser and Server Discovery and Monitoring engine. The callback function logs a message to the console indicating whether the connection was successful or not.\n\nSteps to run the application: Run the index.js file using the below command:\n\nStep 1: Make sure you have installed the mongoose module using the following command:\n\nStep 2: Run the index.js file using the below command:\n\nExample 2: In this example, we are using the following Mongoose connection string options: authSource, useNewUrlParser, useUnifiedTopology, connectTimeoutMS, socketTimeoutMS, heartbeatFrequencyMS, retryWrites, w.\n\nIf the connection is successful with the given string options then “connected to MongoDB!” will be printed in the console, else error block will run.\n\nStep to run the application: Run the index.js file using the below command:"
    },
    {
        "link": "https://stackoverflow.com/questions/64026488/setting-usenewurlparser-useunifiedtopology-to-true-in-mongodb-connection-u",
        "document": "In my code, I've used mongoose to establish a mongodb url connection. To avoid \"DeprecationWarning\", I've set \"useNewUrlParser\", \"useUnifiedTopology\", \"useFindAndModify\", \"useCreateIndex\" to true.\n\nBut, this avoids the catch block error. For example: If I put the wrong credentials in my atlas url, then this code doesn't show the error in the console."
    },
    {
        "link": "https://mongoosejs.com/docs/5.x/docs/connections.html",
        "document": "You can connect to MongoDB with the method.\n\nThis is the minimum needed to connect the database running locally on the default port (27017). If connecting fails on your machine, try using instead of .\n\nYou can also specify several more parameters in the :\n\nSee the mongodb connection string spec for more detail.\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will not throw any errors by default if you use a model without connecting.\n\nTo disable buffering, turn off the option on your schema. If you have on and your connection is hanging, try turning off to see if you haven't opened a connection properly. You can also disable globally:\n\nNote that buffering is also responsible for waiting until Mongoose creates collections if you use the option. If you disable buffering, you should also disable the option and use to create capped collections or collections with collations.\n\nThere are two classes of errors that can occur with a Mongoose connection.\n• Error on initial connection. If initial connection fails, Mongoose will emit an 'error' event and the promise returns will reject. However, Mongoose will not automatically try to reconnect.\n• Error after initial connection was established. Mongoose will attempt to reconnect, and it will emit an 'error' event.\n\nTo handle initial connection errors, you should use or with async/await.\n\nTo handle errors after initial connection was established, you should listen for error events on the connection. However, you still need to handle initial connection errors as shown above.\n\nNote that Mongoose does not necessarily emit an 'error' event if it loses connectivity to MongoDB. You should listen to the event to report when Mongoose is disconnected from MongoDB.\n\nThe method also accepts an object which will be passed on to the underlying MongoDB driver.\n\nA full list of options can be found on the MongoDB Node.js driver docs for . Mongoose passes options to the driver without modification, modulo a few exceptions that are explained below.\n• - This is a mongoose-specific option (not passed to the MongoDB driver) that disables Mongoose's buffering mechanism\n• / - The username and password for authentication. These options are Mongoose-specific, they are equivalent to the MongoDB driver's and options.\n• - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set to false, mongoose will not automatically build indexes for any model associated with this connection.\n• - Specifies which database to connect to and overrides any database specified in the connection string. This is useful if you are unable to specify a default database in the connection string like with some syntax connections.\n\nBelow are some of the options that are important for tuning Mongoose.\n• - The underlying MongoDB driver has deprecated their current connection string parser. Because this is a major change, they added the flag to allow users to fall back to the old parser if they find a bug in the new parser. You should set unless that prevents you from connecting. Note that if you specify , you must specify a port in your connection string, like . The new url parser does not support connection strings that do not have a port, like .\n• - False by default. Set to to make Mongoose's default index build use instead of to avoid deprecation warnings from the MongoDB driver.\n• - True by default. Set to to make and use native rather than .\n• - False by default. Set to to opt in to using the MongoDB driver's new connection management engine. You should set this option to , except for the unlikely case that it prevents you from maintaining a stable connection.\n• - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• - How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. This is set to by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n\nThe following options are important for tuning Mongoose only if you are running without the option:\n• - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do not set this option to .\n• - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every milliseconds for times, and give up afterward. When the driver gives up, the mongoose connection emits a event. This option does nothing for replica set connections.\n• - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set to on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.\n• - How long the MongoDB driver will wait before killing a socket due to inactivity during initial connection. Defaults to 30000. This option is passed transparently to Node.js' function.\n\nThe following options are important for tuning Mongoose only if you are running with the option:\n• - With , the MongoDB driver will try to find a server to send any given operation to, and keep retrying for milliseconds. If not set, the MongoDB driver defaults to using (30 seconds).\n• - With , the MongoDB driver sends a heartbeat every to check on the status of the connection. A heartbeat is subject to , so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits . We recommend you do not set this setting below 1000, too many heartbeats can lead to performance degradation.\n\nThe option also handles how long will retry initial connection before erroring out. With , will retry for 30 seconds by default (default ) before erroring out. To get faster feedback on failed operations, you can reduce to 5000 as shown below.\n\nSee this page for more information about and\n\nThe function also accepts a callback parameter and returns a promise.\n\nYou can also specify driver options in your connection string as parameters in the query string portion of the URI. This only applies to options passed to the MongoDB driver. You can't set Mongoose-specific options like in the query string.\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for , , etc. Best practice is to put options that likely differ between development and production, like or , in the connection string, and options that should remain constant, like or , in the options object.\n\nThe MongoDB docs have a full list of supported connection string options. Below are some options that are often useful to set in the connection string because they are closely associated with the hostname and authentication information.\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n\nConnections inherit from Node.js' class, and emit events when something happens to the connection, like losing connectivity to the MongoDB server. Below is a list of events that a connection may emit.\n• : Emitted when Mongoose starts making its initial connection to the MongoDB server\n• : Emitted when Mongoose successfully makes its initial connection to the MongoDB server, or when Mongoose reconnects after losing connectivity.\n• : Your app called to disconnect from MongoDB\n• : Emitted when Mongoose lost connection to the MongoDB server. This event may be due to your code explicitly closing the connection, the database server crashing, or network connectivity issues.\n• : Emitted after successfully closes the connection. If you call , you'll get both a 'disconnected' event and a 'close' event.\n• : Emitted if Mongoose lost connectivity to MongoDB and successfully reconnected. Mongoose attempts to automatically reconnect when it loses connection to the database.\n• : Emitted if an error occurs on a connection, like a due to malformed data or a payload larger than 16MB.\n• : Emitted when you're connecting to a replica set and Mongoose has successfully connected to the primary and at least one secondary.\n• : Emitted when you're connecting to a replica set and Mongoose has successfully connected to all servers specified in your connection string.\n• : Emitted when you're connected to a standalone server and Mongoose has run out of . The MongoDB driver will no longer attempt to reconnect after this event is emitted. This event will never be emitted if you're connected to a replica set.\n\nWhen you're connecting to a single MongoDB server (a \"standalone\"), Mongoose will emit 'disconnected' if it gets disconnected from the standalone server, and 'connected' if it successfully connects to the standalone. In a replica set with , Mongoose will emit 'disconnected' if it loses connectivity to every server in the replica set, and 'connected' if it manages to reconnect to at least one server in the replica set.\n\nFor long running applications, it is often prudent to enable with a number of milliseconds. Without it, after some period of time you may start to see errors for what seems like no reason. If so, after reading this, you may decide to enable :\n\nis the number of milliseconds to wait before initiating on the socket. is true by default since mongoose 5.2.0.\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\nTo connect to a single node replica set, specify the option.\n\nIf you enable the option, the underlying MongoDB driver will use server selection to connect to MongoDB and send operations to MongoDB. If the MongoDB driver can't find a server to send an operation to after , you'll get the below error:\n\nYou can configure the timeout using the option to :\n\nA has a property that explains why server selection timed out. For example, if you're connecting to a standalone server with an incorrect password, will contain an \"Authentication failed\" error.\n\nMongoDB replica sets rely on being able to reliably figure out the domain name for each member. On Linux and OSX, the MongoDB server uses the output of the command to figure out the domain name to report to the replica set. This can cause confusing errors if you're connecting to a remote MongoDB replica set running on a machine that reports its as :\n\nIf you're experiencing a similar error, connect to the replica set using the shell and run the command to check the host names of each replica set member. Follow this page's instructions to change a replica set member's host name.\n\nYou can also connect to multiple mongos instances for high availability in a sharded cluster. You do not need to pass any special options to connect to multiple mongos in mongoose 5.x.\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. Mongoose creates a default connection when you call . You can access the default connection using .\n\nYou may need multiple connections to MongoDB for several reasons. One reason is if you have multiple databases or multiple MongoDB clusters. Another reason is to work around slow trains. The function takes the same arguments as and returns a new connection.\n\nThis connection object is then used to create and retrieve models. Models are always scoped to a single connection.\n\nIf you use multiple connections, you should make sure you export schemas, not models. Exporting a model from a file is called the export model pattern. The export model pattern is limited because you can only use one connection.\n\nIf you use the export schema pattern, you still need to create models somewhere. There are two common patterns. First is to export a connection and register the models on the connection in the file:\n\nAnother alternative is to register connections with a dependency injector or another inversion of control (IOC) pattern.\n\nEach , whether created with or are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options:\n\nYou may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the option in 4.x:\n\nIn older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections:\n\nIn mongoose v5.x you can instead declare these options at the top level, without all that extra nesting. Here's the list of all supported options.\n\nNow that we've covered connections, let's take a look at models."
    },
    {
        "link": "https://stackoverflow.com/questions/68917683/mongoose-connecturi-connectoptions-does-not-recognize-usenewurlparser-and-oth",
        "document": "The new version of (the latest version when I wrote this post is ) has the following type definitions for the function.\n\nThe you're passing to the function\n\nis, therefore, should have a type of .\n\nCurrent definition of the is as follows:\n\nLooking at the new definition of the and , we can see that there is no definition of or inside the . That is the reason we got such an error. You can delete the options and and your code should be able to connect to your MongoDB. If you want to pass in some options to the function, then they should follow the new type definition of the ."
    }
]