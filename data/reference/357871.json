[
    {
        "link": "https://freetype.org/freetype2/docs/tutorial/step1.html",
        "document": "The following are instructions required to compile an application that uses the FreeType 2 library.\n• You have to add it to your compilation include path. In Unix-like environments you can use the program to retrieve the appropriate compilation flags; say. to get the compilation flags. This program can also be used to check the version of the library that is installed on your system, as well as the required librarian and linker flags. Another solution is the script. However, its use is deprecated since it can't be used reliably for cross compilation.\n• It contains various macro declarations that are later used to the appropriate public FreeType 2 header files.\n• You should do that using the macro , like in the following example. is a special macro defined in file . It contains some installation-specific macros to name other public header files of the FreeType 2 API. You can read this section of the FreeType 2 API Reference for a complete listing of the header macros.\n\nThe use of macros in statements is ANSI-compliant. It is used for several reasons.\n• The macro names are not limited to the DOS 8.3 file naming limit; names like or are a lot more readable and explanatory than the real file names and .\n• It allows special installation tricks that will not be discussed here.\n\nTo initialize the FreeType library, create a variable of type named, for example, , and call the function .\n\nThis function is in charge of\n• creating a new instance of the FreeType 2 library and setting the handle to it, and\n• loading each module that FreeType knows about in the library. Among others, your new object is able to handle TrueType, Type 1, CID-keyed & OpenType/CFF fonts gracefully.\n\nAs you can see, the function returns an error code, like most other functions of the FreeType API. An error code of 0 (also known as ) always means that the operation was successful; otherwise, the value describes the error, and is set to NULL.\n\nA list of all FreeType error codes can be found in file .\n\nCreate a new object by calling . A face describes a given typeface and style. For example, ‘Times New Roman Regular’ and ‘Times New Roman Italic’ correspond to two different faces.\n\nAs you can certainly imagine, opens a font file, then tries to extract one face from it. Its parameters are as follows.\n\nTo know how many faces a given font file contains, set to , then check the value of , which indicates how many faces are embedded in the font file.\n\nIn the case where you have already loaded the font file into memory, you can similarly create a new face object for it by calling .\n\nAs you can see, takes a pointer to the font file buffer and its size in bytes instead of a file pathname. Other than that, it has exactly the same semantics as .\n\nNote that you must not deallocate the font file buffer before calling .\n\nc. From Other Sources (Compressed Files, Network, etc.)\n\nThere are cases where using a file pathname or preloading the file into memory is not sufficient. With FreeType 2, it is possible to provide your own implementation of I/O routines.\n\nThis is done through the function, which can be used to open a new font face with a custom input stream, select a specific driver for opening, or even pass extra parameters to the font driver when creating the object. We advise you to look up the FreeType 2 reference manual in order to learn how to use it.\n\nA face object models all information that globally describes the face. Usually, this data can be accessed directly by dereferencing a handle, like in .\n\nThe complete list of available fields is in the structure description. However, we describe here a few of them in more detail.\n\nFreeType 2 uses size objects to model all information related to a given character size for a given face. For example, a size object holds the value of certain metrics, such as and , which are both expressed in pixels, and the ascender, text height, and maximum horizontal advance, which are each expressed in 1/64 of a pixel (however, those values are rounded to integers, i.e., multiples of 64).\n\nWhen the function is called (or one of its siblings), it automatically creates a new size object for the returned face. This size object is directly accessible as .\n\nNOTE: A single face object can deal with one or more size objects at a time; however, this is something that few programmers really need to do. We have thus decided to make this feature available through additional functions.\n\nWhen a new face object is created, all elements are set to 0 during initialization. To populate the structure with sensible values, you should call . Here is an example, setting the character size to 16pt for a 300×300dpi device:\n• The character widths and heights are specified in 1/64 of points. A point is a physical distance, equaling 1/72 of an inch. Normally, it is not equivalent to a pixel.\n• Value of 0 for the character width means ‘same as character height’, value of 0 for the character height means ‘same as character width’. Otherwise, it is possible to specify different character widths and heights.\n• The horizontal and vertical device resolutions are expressed in dots-per-inch, or dpi. Standard values are 72 or 96 dpi for display devices like the screen. The resolution is used to compute the character pixel size from the character point size.\n• Value of 0 for the horizontal resolution means ‘same as vertical resolution’, value of 0 for the vertical resolution means ‘same as horizontal resolution’. If both values are zero, 72 dpi is used for both dimensions.\n• The first argument is a handle to a face object, not a size object.\n\nThis function computes the (possibly fractional) character pixel size that corresponds to the character width and height and device resolutions. A common acronym for the pixel size is ppem (pixel per em).\n\nIf you want to specify the (integer) pixel sizes yourself, you can call .\n\nThis example sets the character pixel sizes to 16×16 pixels. As previously, a value of 0 for one of the dimensions means ‘same as the other’.\n\nNote that both functions return an error code. Usually, an error occurs with a fixed-size font format (like FNT or PCF) when trying to set the pixel size to a value that is not listed in the array.\n\nBe aware that fractional ppem values are not always supported. For example, the native bytecode engine for hinting TrueType fonts (TTFs) only supports integer ppem values, and FreeType rounds fractional ppem values accordingly.\n\nNormally, an application wants to load a glyph image based on its character code, which is a unique value that defines the character for a given encoding. For example, code 65 (0x41) represents character ‘A’ in ASCII encoding.\n\nA face object contains one or more tables, called charmaps, to convert character codes to glyph indices. For example, most older TrueType fonts contain two charmaps: One is used to convert Unicode character codes to glyph indices, the other one is used to convert Apple Roman encoding to glyph indices. Such fonts can then be used either on Windows (which uses Unicode) and old MacOS versions (which use Apple Roman). Note also that a given charmap might not map to all the glyphs present in the font.\n\nBy default, when a new face object is created, FreeType tries to select a Unicode charmap. It emulates a Unicode charmap if the font doesn't contain such a charmap, based on glyph names. Note that it is possible that the emulation misses glyphs if glyph names are non-standard. For some fonts like symbol fonts, no Unicode emulation is possible at all.\n\nLater on we will describe how to look for specific charmaps in a face. For now, we assume that the face contains at least a Unicode charmap that was selected during a call to . To convert a Unicode character code to a font glyph index, we use .\n\nThis code line looks up the glyph index corresponding to the given in the charmap that is currently selected for the face. You should use the UTF-32 representation form of Unicode; for example, if you want to load character U+1F028, use value 0x1F028 as the value for .\n\nIf no charmap was selected, the function returns the charcode.\n\nNote that this is one of the rare FreeType functions that do not return an error code. However, when a given character code has no glyph image in the face, value 0 is returned. By convention, it always corresponds to a special glyph image called the missing glyph, which is commonly displayed as a box or a space.\n\nOnce you have a glyph index, you can load the corresponding glyph image. The latter can be stored in various formats within the font file. For fixed-size formats like FNT or PCF, each image is a bitmap. Scalable formats like TrueType or CFF use vectorial shapes (outlines) to describe each glyph. Some formats may have even more exotic ways of representing glyphs (e.g., MetaFont – but this format is not supported). Fortunately, FreeType 2 is flexible enough to support any kind of glyph format through a simple API.\n\nThe glyph image is always stored in a special object called a glyph slot. As its name suggests, a glyph slot is a container that is able to hold one glyph image at a time, be it a bitmap, an outline, or something else. Each face object has a single glyph slot object that can be accessed as . Its fields are explained by the structure documentation.\n\nLoading a glyph image into the slot is performed by calling .\n\nThe value is a set of bit flags to indicate some special operations. The default value is 0.\n\nThis function tries to load the corresponding glyph image from the face.\n• If a bitmap is found for the corresponding glyph and pixel size, it is loaded into the slot. Embedded bitmaps are always favoured over native image formats, because we assume that they are higher-quality versions of the same glyph. This can be changed by using the flag.\n• Otherwise, a native image for the glyph is loaded. It is also scaled to the current pixel size, as well as hinted for certain formats like TrueType and Type 1.\n\nThe field describes the format used for storing the glyph image in the slot. If it is not , one can immediately convert it to a bitmap through .\n\nThe parameter is a set of bit flags to specify how to render the glyph image. , the default, renders an anti-aliased coverage bitmap with 256 gray levels (also called a pixmap), as this is the default. You can alternatively use if you want to generate a 1-bit monochrome bitmap. More values are available for the enumeration value.\n\nOnce you have a bitmapped glyph image, you can access it directly through (a simple descriptor for bitmaps or pixmaps), and position it through and . For optimal rendering on a screen the bitmap should be used as an alpha channel in linear blending with gamma correction.\n\nNote that is the horizontal distance from the current pen position to the leftmost border of the glyph bitmap, while is the vertical distance from the pen position (on the baseline) to the topmost border of the glyph bitmap. It is positive to indicate an upwards distance.\n\nc. Using Other Charmaps\n\nAs said before, when a new face object is created, it looks for a Unicode charmap and select it. The currently selected charmap can be accessed via . This field is NULL if no charmap is selected, which typically happens when you create a new object from a font file that doesn't contain a Unicode charmap (which is rather infrequent today).\n\nThere are two ways to select a different charmap with FreeType. It's easiest if the encoding you need already has a corresponding enumeration defined in , for example . In this case, you can call .\n\nAnother way is to manually parse the list of charmaps for the face; this is accessible through the fields and (notice the ‘s’) of the face object. As you could expect, the first is the number of charmaps in the face, while the second is a table of pointers to the charmaps embedded in the face.\n\nEach charmap has a few visible fields to describe it more precisely. The most important ones are and , defining a pair of values that describe the charmap in a rather generic way: Each value pair corresponds to a given encoding. For example, the pair (3,1) corresponds to Unicode. The list is defined in the OpenType specification; you can also use the file , which defines several helpful constants to deal with them. Note that we use the OpenType enumeration values for non-OpenType fonts also (by defining additional constants where necessary).\n\nTo select a specific encoding, you need to find a corresponding value pair in the specification, then look for it in the charmaps list.\n\nOnce a charmap has been selected, either through or , it is used by all subsequent calls to .\n\nIt is possible to specify an affine transformation with , to be applied to glyph images when they are loaded. Of course, this only works for scalable (vectorial) font formats.\n\nThis function sets the current transformation for a given face object. Its second parameter is a pointer to an structure that describes a 2×2 affine matrix. The third parameter is a pointer to an structure, describing a two-dimensional vector that translates the glyph image after the 2×2 transformation.\n\nNote that the matrix pointer can be set to NULL, in which case the identity transformation is used. Coefficients of the matrix are otherwise in 16.16 fixed-point units.\n\nThe vector pointer can also be set to NULL (in which case a delta of (0,0) is used). The vector coordinates are expressed in 1/64 of a pixel (also known as 26.6 fixed-point numbers).\n\nThe transformation is applied to every glyph that is loaded through and is completely independent of any hinting process. This means that you won't get the same results if you load a glyph at the size of 24 pixels, or a glyph at the size of 12 pixels scaled by 2 through a transformation, because the hints are computed differently (except if you have disabled hints).\n\nIf you ever need to use a non-orthogonal transformation with optimal hints, you first have to decompose your transformation into a scaling part and a rotation/shearing part. Use the scaling part to compute a new character pixel size, then the other one to call . This is explained in more detail in part II of this tutorial.\n\nLoading a glyph bitmap with a non-identity transformation works; the transformation is ignored in this case.\n\nWe now present a simple example to render a string of 8-bit Latin-1 text, assuming a face that contains a Unicode charmap.\n\nThe idea is to create a loop that loads one glyph image on each iteration, converts it to a pixmap, draws it on the target surface, then increments the current pen position.\n\nThe following code performs our simple text rendering with the functions previously described.\n\nThis code needs a few explanations.\n• We define a handle named that points to the face object's glyph slot. (The type is a pointer). That is a convenience to avoid using every time.\n• We increment the pen position with the vector , which correspond to the glyph's advance width (also known as its escapement). The advance vector is expressed in 1/64 of pixels, and is truncated to integer pixels on each iteration.\n• The function is not part of FreeType but must be provided by the application to draw the bitmap to the target surface. In this example, it takes a pointer to an descriptor and the position of its top-left corner as arguments. For ideal rendering on a screen this function should perform linear blending with gamma correction, using the bitmap as an alpha channel.\n• The value of is positive for an upwards vertical distance. Assuming that the coordinates taken by use the opposite convention (increasing Y corresponds to downwards scanlines), we subtract it from , instead of adding to it.\n\nThe following code is a refined version of the example above. It uses features and functions of FreeType that have not yet been introduced, and which are explained below.\n\nWe have reduced the size of our code, but it does exactly the same thing.\n• We use the function instead of . As you probably imagine, it is equivalent to calling , then .\n• We do not use for the loading mode, but the bit flag . It indicates that the glyph image must be immediately converted to an anti-aliased bitmap. This is of course a shortcut that avoids calling explicitly but is strictly equivalent. Note that you can also specify that you want a monochrome bitmap instead by using the additional load flag.\n\nLet us try to render transformed text now (for example through a rotation). We can do this using .\n• We now use a vector of type to store the pen position, with coordinates expressed as 1/64 of pixels, hence a multiplication. The position is expressed in cartesian space.\n• Glyph images are always loaded, transformed, and described in the cartesian coordinate system within FreeType (which means that increasing Y corresponds to upper scanlines), unlike the system typically used for bitmaps (where the topmost scanline has coordinate 0). We must thus convert between the two systems when we define the pen position, and when we compute the topleft position of the bitmap.\n• We set the transformation on each glyph to indicate the rotation matrix as well as a delta that moves the transformed image to the current pen position (in cartesian space, not bitmap space). As a consequence, the values of and correspond to the bitmap origin in target space pixels. We thus don't add or to their values when calling .\n• The advance width is always returned transformed, which is why it can be directly added to the current pen position. Note that it is not rounded this time.\n\nA complete source code example can be found here.\n\nIt is important to note that, while this example is a bit more complex than the previous one, it is strictly equivalent for the case where the transformation is the identity. Hence it can be used as a replacement (but a more powerful one).\n\nThe still present few shortcomings will be explained, and solved, in the next part of this tutorial."
    },
    {
        "link": "https://dbader.org/blog/monochrome-font-rendering-with-freetype-and-python",
        "document": "What we’re going to do I’ve structured this tutorial into four main sections. First, there’ll be a brief introduction to the FreeType font rendering library. Second, we’ll attempt to render bitmap images of single characters. Third, we expand the previous functionality to render strings of multiple characters. Fourth, you’ll learn how to add support for kerning in order to improve the visual quality of your font rendering. The image above shows what results to expect from this tutorial. At the end of the article you’ll also find the full example code for download.\n\nThe first thing we want to achieve is to render monochromatic images for single characters. Once we can do that it’ll be reasonably simple to extend our code to display strings with multiple characters. To generate a bitmap image representation for a single character (glyph) with FreeType we need to do the following:\n• Get the glyph bitmap for the given character.\n• Unpack the glyph bitmap into a more convenient format. After this we’re able to render monochrome bitmaps for single characters. For example, the character e would look like this: We’re going to work on this list from top to bottom and start by defining a class that represents a fixed-size font as loaded from a file on disk: # Let FreeType load the glyph for the given character and # tell it to render a monochromatic bitmap representation. We’ve used a yet undefined class called in the method. The class is our wrapper around FreeType’s glyph representations and primarily helps with unpacking FreeType’s bitmap format for monochrome glyphs. FreeType stores monochrome bitmaps in a packed format where multiple pixels are encoded within a single byte. This format is slightly inconvenient to use because it involves some bit-fiddling. To give an example on how to access individual pixels in this format we’re going to unpack the glyph bitmap into a Python . In this unpacked format each pixel is represented by a single byte. A value of means that the pixel is off and any other value means that it is on. The class with the bitmap unpacking code looks as follows: each pixel is represented by a single byte. # Allocate a bytearray of sufficient size to hold the glyph bitmap. # Iterate over every byte in the glyph bitmap. Note that we're not # iterating over every pixel in the resulting unpacked bitmap -- # we're iterating over the packed bytes in the input bitmap. # Read the byte that contains the packed pixel data. # We've processed this many bits (=pixels) so far. This determines # where we'll read the next batch of pixels from. # Pre-compute where to write the pixels that we're going # to unpack from the current byte in the glyph bitmap. # Iterate over every bit (=pixel) that's still a part of the # output bitmap. Sometimes we're only unpacking a fraction of a byte # because glyphs may not always fit on a byte boundary. So we make sure # to stop if we unpack past the current row of pixels. # Unpack the next pixel from the current glyph byte. # Write the pixel to the output bytearray. We ensure that `off` # pixels have a value of 0 and `on` pixels have a value of 1. Clearly, the most important parts of class are in the bitmap unpacking code. Once we’re rendering multi-character strings we’ll extend the class with additional metadata, such as the advance width that tells us the horizontal distance between glyphs. The final part that’s missing is the class. It’s a simple helper class for working with -based bitmaps: A 2D bitmap image represented as a list of byte values. Each byte indicates the state of a single pixel in the bitmap. A value of 0 indicates that the pixel is `off` and any other value indicates that it is `on`. The class allows us to quickly experiment with font rendering in the Python REPL. Calling on a object returns a textual representation of the 2D image encoded in the bitmap. This is going to be very helpful when we start debugging our font rendering code. Next, let’s actually try to render a single glyph bitmap: Great, that means our glyph rendering code works. The most complicated thing here was the bitmap unpacking code. We now continue with rendering strings with multiple characters.\n\nNow that we know how to render single character glyphs we’re going to extend that functionality into rendering strings with several characters. The critical part here is glyph placement, that is, ensuring that all characters line up correctly. To render multi-character strings we make the following changes to the existing code:\n• Extend the class with additional metadata that tells us how characters are placed next to each other (advance width, top-side bearing, ascent, and descent).\n• Implement a two pass algorithm for rendering strings:\n• Pass 1: Compute the dimensions of the bitmap for a given string.\n• Pass 2: Successively draw the glyph for each character into an output bitmap. Once we’ve completed these steps we’ll be able to render strings such as this one: We start with extending the class with fields for the glyph’s advance width, top-side bearing, ascent, and descent. I’ll briefly explain the purpose of these fields before we continue. If you want to learn more about these glyph metrics take a look at the FreeType documentation. The advance width tells us where to place the next character horizontally, that is, how many pixels we move to the right (or to the left) to draw the next glyph. The ascent, descent, and the top-side bearing determine the vertical placement of the glyph. To understand vertical glyph placement the concept of the baseline is very important. The baseline is defined to be the line upon which most letters sit. The ascent and descent determine how the glyph should be placed relative to the baseline. In western typography most letters extend above the baseline. We say that they have a positive ascent. Some letters, such as g, extend below the baseline. This means that both their ascent and descent are positive. Of course, other mixtures are also possible, for example, there may be letters with an ascent of zero but a positive descent, and so on. The top-side bearing is the vertical distance from the glyph’s baseline to its bitmap’s top-most scanline. We need this value to compute the glyph’s ascent and descent. While these glyph metrics seem straightforward to compute, it took me a few tries and some pencil drawing to get them right. The updated version of the class with added metrics looks like this: # The glyph bitmap's top-side bearing, i.e. the vertical distance from the # Ascent and descent determine how many pixels the glyph extends # above or below the baseline. # The advance width determines where to place the next character # horizontally, that is, how many pixels we move to the right # to draw the next glyph. Next, we’re going to work on the class and extend it with a two-pass algorithm for rendering multi-character strings. The first pass computes the space occupied by the given string, that is, the dimensions of the given text as if it were rendered into a bitmap. Besides the width and height of the resulting bitmap in pixels, we also need to know the position of the baseline for correct vertical glyph placement. We compute the overall width by summing up the advance widths for all glyphs. The overall height is determined by the maximum ascent and descent. The baseline of a multi-character string equals the maximum descent of all glyphs within the string. The resulting function looks as follows: Return (width, height, baseline) of `text` rendered in the current font. # For each character in the text string we get the glyph # and update the overall dimensions of the resulting bitmap. The second pass successively draws the glyph images into an output . For the second pass we must know the text dimensions in order to allocate a bitmap of sufficient size and to correctly place each character vertically. You can see the function that performs the second pass here: Render the given `text` into a Bitmap and return it. If `width`, `height`, and `baseline` are not specified they are computed using the `text_dimensions' method. Drawing characters into the bitmap is done by . It performs a bit blit operation to copy pixels from one bitmap into another: \"\"\"Copy all pixels from `src` into this bitmap, starting at (`x`, `y`).\"\"\" Using the new code we’re able to render our first multi-character string: Great, this is starting to look useful. The tricky parts in this section were handling the advance width and vertical glyph placement correctly. So, be sure to also try some combinations of characters that descent below the baseline. For example, the string “greetings, world” should render correctly with parts of the g and the comma descending below the baseline.\n\nKerning adjusts the horizontal space between glyphs to achieve visually pleasing typography. A typical example where kerning leads to a more pleasing result is the letter pair AV. With kerning the bounding boxes of both letters overlap slightly to prevent superfluous horizontal space. In the following picture the first line was rendered without kerning and the second line was rendered with kerning: As you can see, kerning is a visual optimization – it’s not mandatory but can make quite a difference in the quality of your text rendering. For displaying text on a 128 × 64 pixels monochrome display it’s probably overkill to implement kerning. But with FreeType it’s reasonably simple to add kerning support so let’s go ahead with it anyways. To add kerning to our existing codebase we need to make three changes:\n• Add a way to access kerning information for a character pair.\n• Take kerning information into account during multi-character rendering. So we start by extending the class with the following function that returns the kerning offset for a character pair, that is, two characters that are to be drawn in sequence: Return the horizontal kerning offset in pixels when rendering `char` # The kerning offset is given in FreeType's 26.6 fixed point format, # which means that the pixel values are multiples of 64. We then use the resulting kerning offset to adjust the glyph’s drawing position. This reduces extraneous horizontal whitespace. Let’s go back briefly to our kerning example with the letter pair AV. We saw there that the the glyph bitmaps for A and V overlapped slightly. In this case the glyph for V has a negative horizontal kerning offset and it is moved slightly left towards the A. To do this automatically we update and to take the kerning offset into account: # With kerning, the advance width may be less than the width of the # glyph's bitmap. Make sure we compute the total width so that # all of the glyph's pixels fit into the returned dimensions. # Take kerning information into account before we render the # The vertical drawing position should place the glyph # on the baseline as intended. If we run the code at this stage we’ll see that it adjusts the glyph placement correctly – but produces unpleasant visual artefacts in some cases. If the glyph bounding boxes overlap, the glyph rendered last overwrites some of the previous glyph’s pixels. To fix this visual artefact we update with a simple blending operation. We need this to draw text that contains glyphs with overlapping bounding boxes correctly. The updated method looks as follows: \"\"\"Copy all pixels from `src` into this bitmap\"\"\" # Perform an OR operation on the destination pixel and the source pixel # because glyph bitmaps may overlap if character kerning is applied, # e.g. in the string \"AVA\", the \"A\" and \"V\" glyphs must be rendered Once you’ve made the change you should see the visual artefacts from glyph overlapping disappear. Congratulations for implementing kerning support! This also concludes"
    },
    {
        "link": "https://freetype-py.readthedocs.io/_/downloads/en/stable/pdf",
        "document": ""
    },
    {
        "link": "http://freetype.org",
        "document": "Counting the above products only, you get more than a billion devices that contain FreeType.\n\nSome products that use FreeType for rendering fonts on screen or on paper, either exclusively or partially:\n\nIt is written in C, designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images) of most vector and bitmap font formats.\n\nThe B/W rasterizer has become much faster; besides that, it is a maintenance release.\n\nAs usual, a list of the more noteworthy changes can be found in the release notes.\n\nThis is a maintenance release with only minor changes.\n\nDetails can be found in the release notes.\n\nThis is a maintenance release with only minor changes, for example, a new load flag to ignore glyphs in an SFNT table, or a new function to get the index of the default named instance of an OpenType Variation Font.\n\nPlease check release notes for more details.\n\nThis new release brings you a completely updated and enhanced demo program, which now combines the functionality of almost all other graphical FreeType demo programs into a single application based on the Qt framework.\n\nAnother two noteworthy features are related to OpenType fonts: The ‘COLR’ v1 API is now considered as stable, and the ‘avar’ v2 extension is supported.\n\nOther news and changes can be found in the release notes.\n\nThis is a maintenance release. All users should upgrade. A list of the most important changes and fixes can be found here.\n\nThe main new feature of this release is support for OpenType fonts with an ‘SVG’ table, using an external SVG rendering library. Other changes, fixes, and improvements are documented here.\n\nThis is a maintenance release with no significant changes. For more details on the various fixes and changes please see here.\n\nOur new release brings an additional rendering module to create Signed Distance Fields (SDF) for glyphs; it also introduces an experimental interface to access ‘COLR’ v1 fonts.\n\nAs usual, there are many more fixes and features; please see here for more.\n\nWe are now using the infrastructure of the gitlab instance of freedesktop.org. All bug issues have been imported (kudos to Anurag Thakur for doing this tedious job!), together with the git repositories, which have been renamed to freetype and freetype-demos (this is, we are dropping the ‘2’ in the repository names).\n\nThe git repositories at Savannah will stay as mirrors.\n\nThis is an emergency release, fixing a severe vulnerability in embedded PNG bitmap handling (see here for more).\n\nThis is a maintenance release, having better support for TrueType glyphs with overlapping contours. See the list of changes for more details.\n\nA warning for distribution maintainers: Version 2.10.3 and later may break the build of ghostscript, due to ghostscript's use of a withdrawn macro that wasn't intended for external usage. A fix is available here.\n\nBesides various maintenance fixes, this release comes with support of WOFF 2 fonts. More details are listed in the list of changes.\n\nA new maintenance release, fixing bytecode hinting of OpenType variation fonts and cmap processing of PCF fonts, among other things. Check the list of changes for more fixes.\n\nThis release brings one notable feature, namely support for color-layered outline glyphs (for example, scalable emoji glyphs). Additionally, the API reference has been completely overhauled and modernized, as already announced.\n\nAs usual, many minor fixes and corrections have been applied also; a detailed list is given here.\n\nA revamped version of the FreeType website is available for preview here. It includes a complete interface redesign, and uses markdown as input which greatly improves maintainability. Comments are welcome.\n\nThis is a maintenance release; most importantly fixing correct handling of Type 1 fonts with flex features, which was broken in version 2.9. An overview of the remaining changes is given here. All users should upgrade.\n\nFreeType version 2.9, the first release of a new ‘minor’ series, is now available for download. The main reason for starting a new series is Ewald Hew's GSoC contribution of making Adobe's CFF engine handle Type 1 fonts also, greatly improving the rendering quality of this ancient but still important font format.\n\nIf you are going to use variation fonts, please update to this version since it comes with some important fixes. More information on this and other changes can be found here.\n\nFreeType 2.8.1 has been released. This is mainly a maintenance release with one important change: By default, FreeType now offers high quality LCD-optimized output without resorting to ClearType techniques of resolution tripling and filtering. In this method, called Harmony, each color channel is generated separately after shifting the glyph outline, capitalizing on the fact that the color grids on LCD panels are shifted by a third of a pixel. This output is indistinguishable from ClearType with a light 3-tap filter.\n\nSee here for a extensive list of changes; noteworthy bug fixes are correct handling of B/W TrueType hinting and some OpenType variation font handling issues.\n\nFreeType 2.8 has been released. CFF2 support and OpenType variation font handling is now complete; the auto-hinter now understands 25 more scripts, for example N'Ko and Tifinagh.\n\nSee here for a list of changes; noteworthy bug fixes are the handling of TrueType fonts: unhinted loading didn't work as expected, and the light auto-hinter used incorrect metrics.\n\nThe FreeType project was accepted to be part of Google Summer of Code 2017! Here's a link to our ideas list – if you have another one, please write to our mailing list so that we can discuss your suggestions, eventually adding them to the list. And if you want to participate as a student, now is the time to discuss everything, again using the mailing list.\n\nFreeType 2.7.1 has been released. The most important news is preliminary support of Adobe's new CFF2 font format and variation fonts as specified in the new OpenType specification version 1.8. It also fixes the handling of raw CID fonts (which might be found in PDF files)\n\nSee here for a list of changes.\n\nWe start a new ‘minor’ series, which finally allows us to activate a new default mode for bytecode hinting (see also the announcements below for version 2.6.4 and 2.6.5): Subpixel hinting, also known as ClearType hinting.\n\nIn case you are already using subpixel hinting (for example, by using the ‘Infinality patches’ as provided by some GNU/Linux or BSD distributions, or directly from bohoomil.com), be noted that the new mode might provide subtle differences; the code was simplified to make it much faster. If you are used to the old full-pixel hinting, you will see many rendering changes. If you really dislike them, you can disable them at compile time or using the new environment variable.\n\nA description of the remaining changes can be found here, as usual.\n\nThis release is almost identical to the previous version, with two differences.\n• It compiles again on Mac OS X, and\n• it reverts the activation of subpixel hinting by default; it will be enabled by default in the forthcoming 2.7.x series. Main reason for reverting this feature is the principle of least surprise: a sudden change in appearance of all fonts (even if the rendering improves for almost all recent fonts) should not be expected in a new micro version of a series.\n\nFreeType 2.6.4 has been released. The most important change is a new bytecode hinting mode for TrueType fonts that finally activates subpixel hinting (a.k.a. ClearType hinting) by default.\n\nThe new release also brings support for the following new scripts in the auto-hinter: Armenian, Cherokee, Ethiopic, Georgian, Gujarati, Gurmukhi, Malayalam, Sinhala, and Tamil.\n\nSee here for a detailed list of changes.\n\nFreeType 2.6.3 has been released. It brings support for four new Asian scripts in the auto-hinter (Khmer, Myanmar, Kannada, and Bengali), together with other, minor improvements and bug fixes.\n\nSee here for a detailed list of changes.\n\nMore on the 2.6.2 release for users and developers\n\nFreeType 2.6.2 ships with three interesting details for users and developers of rendering libraries that deal with text. Read more.\n\nFreeType 2.6.2 has been released. This is a minor release that mainly provides better handling of malformed fonts. All users should upgrade.\n\nA new feature is stem darkening support for the auto-hinter. Note, however, that it is off by default, since most graphic systems don't provide correct linear alpha blending with gamma correction, which is crucial for a good appearance. For the same reason, stem darkening for the CFF engine is now off by default, too.\n\nSee here for a more detailed list of changes.\n\nFreeType 2.6.1 has been released. This is a minor release that corrects problems with CFF metrics, and that provides better handling of malformed fonts. Two notably new features are auto-hinting support for the Lao script and a simple interface for accessing named instances in GX TrueType variation fonts.\n\nSee here for a list of changes.\n\nFreeType 2.6 has been released. This is a new major release that provides a better (and simpler) thread-safety model. Among other new features we now have auto-hinting support for Arabic and Thai, together with much improved handling of Apple's GX TrueType variation font format.\n\nSee here for a list of changes.\n\nBesides user support and fixing bugs, your money will help me implement the following issues.\n• Setting up a test framework for FreeType. This is a huge, long-term undertaking that will ensure both stability and reliability of the library. The idea is to collect test cases (mainly broken fonts) that cover as much source code as possible. Another idea to investigate is the development of scripts that can generate both valid and invalid input data to systematically increase the coverage of executed library code, including the unlikely cases. Finally, images of valid, well-rendered input fonts could be collected: As soon as a change to the rendering image gets applied, a comparison run with those images should detect rendering regressions.\n• Further improvements to the auto-hinter. Right now, the module for Indic support is a dummy, and support for the family of Arabic scripts is completely missing. Both investigation and research is necessary to find out how much auto-hinting is possible and useful, and whether other, completely different scripts can be supported at all.\n• Right now, rendering Type 1 and CID-keyed fonts is the weakest part of FreeType. However, we now have a brand-new module for handling CFF. Given that CFF is very similar to Type 1, it should be not too difficult to use and/or extend the CFF code so that Type 1 fonts can be handled, too.\n• Explore whether it makes sense to merge FreeType with (parts of) the HarfBuzz library. Since version 2.5.3, FreeType already links to HarfBuzz to use its abilities for scanning OpenType layout features, and more integration might be sensible for both libraries.\n• More improvements to this website. Last year I’ve redesigned the FreeType website. However, a large bunch of documents are still using the old design, and some of them are also no longer up to date.\n\nFreeType 2.5.3 has been released. All users should upgrade due to fixed vulnerability in the CFF driver (CVE-2014-2240).\n\nIts main new feature is much enhanced support of auto-hinting SFNT fonts (i.e., TrueType and CFF fonts) due to the use of the HarfBuzz library. A more detailed description of this and other changes can be found here.\n\nFreeType 2.5.2 has been released. It fixes a serious bug introduced in version 2.5.1; all users should upgrade.\n\nA listing of the changes can be found here.\n\nFreeType 2.5.1 has been released, providing three major new features.\n• Support for the WOFF font format, contributed by Behdad Esfahbod.\n• The auto-hinter now supports Hebrew, together with improved support for Cyrillic and Greek.\n• The directory layout of the (installed) FreeType header files has been simplified.\n\nAmong other changes I want to mention that FreeType's TrueType debugger ( ) has been made more versatile. An exhaustive list of changes can be found here.\n\nThanks to a very generous donation by Pierre Arnaud from Epsitec, the pledgie campaign for FreeType has reached its goal. I want to say thank you again to all donors! Of course, noone stops you from further donating to the campaign :-)\n\nAfter integration of Adobe's CFF module and Google's color emoji support, I will use the next months to work on the remaining issues that I've promised to implement. Stay tuned!\n\nFreeType 2.5 has been released. A major new feature is support for color embedded bitmaps (eg. color emoji), contributed by Behdad Esfahbod on behalf of Google. Additionally, Adobe's CFF engine is now the default, which makes a good reason to change from the 2.4.x to the 2.5.x series.\n\nOn the technical side, the property API to access FreeType module parameters ( and ) is now declared as stable.\n\nAs usual, see this file for the complete release notes, which give more details. And we have again blog entries from Adobe and Google.\n\n[Please download the 2.5.0.1 bundle of the FreeType library, which fixes a packaging error.]"
    },
    {
        "link": "https://pypi.org/project/freetype-py",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://matplotlib.org/stable/tutorials/images.html",
        "document": "First, let's start IPython. It is a most excellent enhancement to the standard Python prompt, and it ties in especially well with Matplotlib. Start IPython either directly at a shell, or with the Jupyter Notebook (where IPython as a running kernel). With IPython started, we now need to connect to a GUI event loop. This tells IPython where (and how) to display plots. To connect to a GUI loop, execute the %matplotlib magic at your IPython prompt. There's more detail on exactly what this does at IPython's documentation on GUI event loops. If you're using Jupyter Notebook, the same commands are available, but people commonly use a specific argument to the %matplotlib magic: This turns on inline plotting, where plot graphics will appear in your notebook. This has important implications for interactivity. For inline plotting, commands in cells below the cell that outputs a plot will not affect the plot. For example, changing the colormap is not possible from cells below the cell that creates a plot. However, for other backends, such as Qt, that open a separate window, cells below those that create the plot will change the plot - it is a live object in memory. This tutorial will use Matplotlib's implicit plotting interface, pyplot. This interface maintains global state, and is very useful for quickly and easily experimenting with various plot settings. The alternative is the explicit, which is more suitable for large application development. For an explanation of the tradeoffs between the implicit and explicit interfaces see Matplotlib Application Interfaces (APIs) and the Quick start guide to start using the explicit interface. For now, let's get on with the implicit approach:\n\nMatplotlib relies on the Pillow library to load image data. Here's the image we're going to play with: It's a 24-bit RGB PNG image (8 bits for each of R, G, B). Depending on where you get your data, the other kinds of image that you'll most likely encounter are RGBA images, which allow for transparency, or single-channel grayscale (luminosity) images. Download stinkbug.png to your computer for the rest of this tutorial. We use Pillow to open an image (with ), and immediately convert the object into an 8-bit ( ) numpy array. Each inner list represents a pixel. Here, with an RGB image, there are 3 values. Since it's a black and white image, R, G, and B are all similar. An RGBA (where A is alpha, or transparency) has 4 values per inner list, and a simple luminance image just has one value (and is thus only a 2-D array, not a 3-D array). For RGB and RGBA images, Matplotlib supports float32 and uint8 data types. For grayscale, Matplotlib supports only float32. If your array data does not meet one of these descriptions, you need to rescale it."
    },
    {
        "link": "https://geeksforgeeks.org/working-with-images-in-python-using-matplotlib",
        "document": "Matplotlib is an amazing visualization library in Python for 2D plots of arrays. Matplotlib is a multi-platform data visualization library built on NumPy arrays and designed to work with the broader SciPy stack.\n\nWorking with Images in Python using Matplotlib\n\nThe module in library is used for working with images in Python. The module also includes two useful methods which are which is used to read images and which is used to display the image.\n\nBelow are some examples which illustrate various operations on images using library:\n\nExample 1: In this example, the program reads an image using the and displays that image using .\n\nExample 2: The below program reads an image and then represents the image in array.\n\nExample 3: Here, the shape of the image is which represents (height, width, mode) of the image, for colored image mode value is from 0 to 2 and for black and white image mode value is 0 and 1 only. In the output image, only the mode of the image is modified.\n\nExample 4: In the below program, all the parameters of the shape of the image are modified. Here the height of the image is 150 pixels (displaying from the 50th pixel), width is 100 pixels (displaying from the 100th pixel) and mode value is 1.\n\nExample 5: Here, none of the parameters are modified. So, the original image is displayed."
    },
    {
        "link": "https://stackoverflow.com/questions/69596518/display-images-with-matplotlib",
        "document": "I wanna display in a list of lists the images inside it using matplotlib. So for example I wanna have in the first row, the images of the first list, the second row, the images of the second list and so on. I tried this, but I obtain the images in each row, maybe because it will call over and over again subplot. How can I fix it?"
    },
    {
        "link": "https://stackoverflow.com/questions/35286540/how-to-display-an-image",
        "document": "I tried to use IPython.display with the following code:\n\nI also tried to use matplotlib with the following code:\n\nIn both cases, nothing is displayed, not even an error message."
    },
    {
        "link": "https://matplotlib.org/stable/gallery/images_contours_and_fields/image_demo.html",
        "document": "The most common way to plot images in Matplotlib is with . The following examples demonstrate much of the functionality of imshow and the many images you can create.\n\nIt is also possible to show images of pictures.\n\nIt is also possible to interpolate images before displaying them. Be careful, as this may manipulate the way your data looks, but it can be helpful for achieving the look you want. Below we'll display the same (small) array, interpolated with three different interpolation methods.\n\nThe center of the pixel at A[i, j] is plotted at (i+0.5, i+0.5). If you are using interpolation='nearest', the region bounded by (i, j) and (i+1, j+1) will have the same color. If you are using interpolation, the pixel center will have the same color as it does with nearest, but other pixels will be interpolated between the neighboring pixels.\n\nTo prevent edge effects when doing interpolation, Matplotlib pads the input array with identical pixels around the edge: if you have a 5x5 array with colors a-y as below:\n\nMatplotlib computes the interpolation and resizing on the padded array\n\nand then extracts the central region of the result. (Extremely old versions of Matplotlib (<0.63) did not pad the array, but instead adjusted the view limits to hide the affected edge areas.)\n\nThis approach allows plotting the full extent of an array without edge effects, and for example to layer multiple images of different sizes over one another with different interpolation methods -- see Layer images with alpha blending. It also implies a performance hit, as this new temporary, padded array must be created. Sophisticated interpolation also implies a performance hit; for maximal performance or very large images, interpolation='nearest' is suggested.\n\nYou can specify whether images should be plotted with the array origin x[0, 0] in the upper left or lower right by using the origin parameter. You can also control the default setting image.origin in your matplotlibrc file. For more on this topic see the complete guide on origin and extent.\n\nFinally, we'll show an image using a clip path."
    }
]