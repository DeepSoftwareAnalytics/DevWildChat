[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://oxylabs.io/blog/nodejs-fetch-api",
        "document": "The world’s first website started with HTML only – no CSS, no images, and no JavaScript. Since then, browsers and websites have come a long way. Nowadays, it’s common for a website to depend on dozens of different resources such as images, CSS, fonts, JavaScript, JSON data, etc. On top of all that, dynamic websites load even more resources. As an excellent language for client-side scripting, JavaScript has played an essential role in the evolution of websites. With the help of XMLHttpRequest or XHR objects, JavaScript enabled client-server communication without page reloads. Today this dynamic is challenged by the Fetch API. However, JavaScript is still more popular because it can be used for server-side code, thanks to Node.js. Fetch API is now included by default with Node.js version 18 and above. This article explains what Fetch API is, how it can be used in Node.js, and how it is better than alternatives such as Axios or XHR. For your convenience, we also prepared this tutorial in a video format:\n\nFetch API is an application programming interface for fetching network resources. It facilitates making HTTP requests such as GET, POST, etc. Fetch API supports new standards, such as Promise, resulting in cleaner code that doesn’t require callbacks. The native support for the Fetch API exists in all major browsers. JavaScript developers rely on the npm node-fetch package for the server-side code. The package is wildly popular, with millions of downloads every week. Node.js has released experimental support for the Fetch API with version 17.5, while with Node.js version 18, the Fetch API became stable and is enabled by default as part of the Node.js runtime. Since then, you can write your server-side JavaScript code that uses the Fetch API without installing a third-party library. To check your Node.js version, run the following command in your terminal: If you’re running a Node.js version between 17.5 and 18, you can run Fetch API code files by enabling the --experimental-fetch flag: If your node version is below 17.5, you can install node-fetch with the command below: How to use Fetch API For the following examples, a scraping sandbox website will be used as a target. As the Fetch API returns a Promise object, you can use the fetch-then syntax. First, initialize the Node.js project by executing the following lines in your terminal: These commands will create a package.json file in a new folder called fetch-api-scraper. To see node-fetch in action, create a new .js file and enter the following lines of code: This code sends a fetch request using an HTTP GET method and prints the HTML by logging the response body. To explain it further, the fetch() method returns a Promise object. The first then() extracts the text from the response, and the second then() prints the response HTML. Save the code file as product.js, open the terminal, and run the following: Running this line will print the HTML document of the target page:\n\nYou can also send a fetch request using an async function with the async-await syntax as follows: If you want to extend the code to fetch data like the product title from the entire HTML, you can scrape and parse data using Cheerio. Install the Cheerio library by executing the following line in your terminal: The following Node.js Fetch example extracts the product’s title: Learn more about web scraping in JavaScript here.\n\nWhile running this code using Node.js, you’ll see all of the response headers as expected. However, things will be unexpectedly different when running in the browser. If a server you attempt to query has CORS headers enabled, your browser will limit the headers you can access for security reasons. You’ll only be able to access the following headers: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, and Pragma. Read more about it here. It’s also possible to send custom request headers using the second parameter of fetch(), where various options can be set, including headers. The following example shows how to send a custom User-Agent header in the HTTP request: The ip.oxylabs.io/headers URL outputs the headers of your request. As discussed in the next section, the second parameter can be used for additional functionality. Tip: If you have a cURL command with headers you want to use for your Fetch API code, you can easily extract them by using a cURL to JSON converter. The default request method used by the Fetch API is GET. However, it’s possible to send a POST request as follows: Let’s practice sending some dummy data to a test website that accepts POST requests: https://httpbin.org/post. You’ll need to convert the data you want to send in a node-fetch POST request into a string: Notice how to set method: 'POST' and how to use JSON.stringify(data) to convert the data into a string in the request body. To learn how to handle JSON data, follow our tutorial on how to read JSON files in JavaScript. Similarly, you can also use the HTTP methods such as DELETE, PUT, etc. As the Node Fetch API returns a Promise object, you can use the fetch-then-catch convention to handle errors: If you’re using an async function, you can handle errors with the try-catch block as follows: Both methods should produce an output as shown in the screenshot:\n\nAxios is a popular Node package for making HTTP GET and POST requests with ease. Make sure to check our tutorial on web scraping with JavaScript and Node.js to see a practical example of Axios. Additionally, you might also find it useful to read about using proxies in Node-Fetch and proxy integration with Axios. In case you have a cURL command that you want to replicate using Axios, Node.js, or JavaScript, you can also take advantage of these cURL to Node Axios, cURL to Node.js, and cURL to JavaScript converters. You can install Axios with the following command: To send a GET request, call the get() method as follows: Similarly, to send a POST request, call the post() method as follows: Let's take an example to see how the Node Fetch API differs from Axios. Send a POST request to https://httpbin.org/post with JSON data. The important things to note here are the following:\n• None The response will be in JSON format Writing the same code using Axios and Fetch API will distinguish the differences. The following code uses Axios: And below you can find a Node Fetch example: Both of these code snippets will produce the same output. As evident from the examples above, here are the differences between Axios and Fetch API:\n• None Fetch API uses the body property of the request, while Axios uses the data property.\n• None Using Axios, JSON data can be sent directly, while Fetch API requires the conversion to a string.\n• None Axios can handle JSON directly. The Fetch API requires the response.json() method to be called first to get the response in JSON format.\n• None The response data variable name must be data in the case of Axios, while it can be anything in the case of Fetch API.\n• None Axios allows an easy way to monitor and update progress using the progress event. There is no direct method in Fetch API.\n• None Fetch API does not support interceptors, while Axios does.\n• None Fetch API allows the streaming of a response, while Axios doesn’t. Here are some of the most common Fetch API errors and mistakes you may encounter, along with their solutions:\n• None The Fetch API does not throw an error for HTTP response codes like 404 or 500. Check the response.ok property to determine if the request was successful.\n• None Fetch API does not natively support request timeouts, causing requests to hang indefinitely. Implement timeouts manually using techniques like AbortController.\n• None When using response.body, forgetting to properly consume or close the stream can lead to memory leaks. Consume the stream completely using methods like .json() or .text().\n• None Fetch does not send cookies by default, which can break authentication for same-origin requests. To include cookies in your Fetch requests, you need to explicitly set the credentials option in the Fetch API.\n• None Fetch fails silently for CORS errors; response.ok or catch won’t help since the request doesn't even reach the server. Check the browser console for CORS issues and configure server headers to allow cross-origin requests. The addition of Fetch API to Node.js is a long-awaited feature, which is now stable and included with node by default. Combined with libraries such as Cheerio, the Fetch API can also be used for web scraping. Curious to find out more about web scraping? Make sure to check our blog. If you want to learn about a different method of scraping via a headless browser, refer to our Puppeteer tutorial. Also, don’t hesitate to try our general-purpose web scraper for free."
    },
    {
        "link": "https://brightdata.com/blog/how-tos/fetch-api-nodejs",
        "document": "The Fetch API represents the new officially supported way to perform HTTP requests and retrieve local resources in Node.js. This means that you no longer need external HTTP client dependencies in your project. All you have to do is learn how to use the Node Fetch API, which is what this guide is all about.\n\nHere, you will see:\n• What is the Fetch API\n• Making HTTP requests in Node.js with the Fetch API\n\nWhat Is the Fetch API?\n\nThe Fetch API is a JavaScript interface for fetching resources locally or over a network. In detail, it provides a global fetch() function that makes it easier to perform asynchronous HTTP requests. The same method can also be used to retrieve local files. The JavaScript Fetch API is a flexible replacement for the legacy XMLHttpRequest API.\n\nThe fetch() method is based on the Request and Response objects. It requires only one mandatory argument, the local path or URL to the resource you want to fetch. Then, it also accepts some optional options, including CORS, HTTP header, and caching settings. As an asynchronous method, fetch() returns a Promise that resolves the response produced by the server. This is represented by a Response object, which exposes several methods to access and parse its content body.\n\nThis is what a basic Fetch API call looks like:\n\nThe Fetch API has been supported by major browsers for years. Yet, it has only been part of the standard Node.js library since version 18.0.0, released in April 2022. Specifically, the Node Fetch API is based on undici’s implementation.\n\nBefore Node.js 18, you could use fetch() by enabling it as an experimental feature or thanks to the node-fetch npm library, another popular Fetch API implementation. Since fetch() is now part of the official Node.js standard library, you can use it directly in your code without importing it. All you have to do is call the fetch() method with the syntax below:\n\nurl is mandatory and can contain:\n• The URL to a remote endpoint or resource (e.g., https://httpbin.io/ip or https://example.com/movies.json)\n\noptions is instead an optional object that accepts the following optional fields:\n• method: The HTTP method of the request, such as “GET”, “POST”, “PUT”, “PATCH”, and “DELETE”. The default is “GET”.\n• headers: A Headers or object literal containing the HTTP headers to add to your request. By default, no header is set.\n• body: The object containing the data to use as the body of your request. Note that GET and HEAD requests cannot have a body.\n• mode: The mode to use for the request (e.g., “cors”, “no-cors”, “same-origin”, “navigate”, or “websocket”). By default, it is set to cors.\n• credentials: To specify whether the browser should send the credentials or not. It must be one of the following strings: “omit”, “same-origin”, or “include”.\n• redirect: To determine how to handle an HTTP redirect response. It can be “follow”, “error”, or “manual”. By default, it is set to “follow”.\n• referrer: A string containing the referrer of the request. By default, it is an empty string.\n• referrerPolicy: Specifies the referrer policy to use for the request.\n• signal: An AbortSignal object instance that allows you to abort the request via the AbortController interface.\n• priority: A string that specifies the priority of the current Fetch request relative to other requests of the same type. It accepts “high”, “low”, or “auto”. By default, it is “auto”.\n\nCheck out the fetch() parameters section from the official documentation to learn more.\n\nThis is an example of a Node.js Fetch request with an options object:\n\nNote that the body data must match the Content-Type header.\n\nMaking HTTP Requests in Node.js With the Fetch API\n\nLet’s now see the Node Fetch API in action in real-world request examples for the most popular HTTP methods.\n\nThis is how you can perform a GET request with the Fetch API:\n\nAs you can see, it takes only one line of code. That is because fetch() performs GET requests by default.\n\nThen, you can access the response content with one of the methods below:\n• response.text(): Returns a Promise that resolves with the response body as text.\n• response.json(): Returns a Promise that resolves with an object parsed from the JSON response.\n• response.blob(): Returns a Promise that resolves with the response body as a Blob object.\n• response.arrayBuffer(): Returns a Promise that resolves with the response body as an ArrayBuffer instance.\n• response.formData(): Returns a promise that resolves with the response body as a FormData object.\n\nSo, the code of a complete example would be:\n\nIf the response returned by the server is not in JSON format, the response.json() instruction will fail with a SyntaxError.\n\nMaking a POST request with a Node Fetch API call only takes a few lines:\n\nThe key to sending a POST request with fetch() is to specify data to send to the server in the body option. This can be in several formats, including JSON, FormData, and text. When sending a FormData object, you do not need to specify a Content-Type header. Otherwise, it is mandatory.\n\nPerforming a PUT request with the Fetch API is just like making a POST:\n\nThe only difference is that you need to specify “PUT” as method setting. Similarly, you can send a PATCH request by setting it to “PATCH”.\n\nHere is an example of an HTTP DELETE request with fetch():\n\nAgain, it all comes down to setting the right HTTP method. The Fetch API implementation will take care of the rest.\n\nNow that you know how to use fetch() in common scenarios, you are ready to explore the Node Fetch API’s advanced options.\n\nfetch() enables you to customize the HTTP headers of your request through the headers field of the options object. In particular, headers accepts a Headers object or an object literal with specific string values.\n\nSuppose you want to set the Content-Type and User-Agent header in your fetch() request. You could either use a Headers object as below:\n\nOtherwise, you could equivalently set them with an object literal:\n\nThis syntax is more compact and easier to read.\n\nIf you want to read the HTTP headers set by the server in the response, you can access them as follows:\n\nThe response.headers field returns a Headers object, from which you can access specific headers with the get() method.\n\nA Node.js Fetch API call can fail only for two reasons:\n• An AbortError exception: When the request was intentionally aborted by an AbortController.\n• A TypeError exception: This can occur because of several reasons, such as an invalid header name, an invalid URL, or a generic network error. Find out more causes in the docs.\n\nWhat is essential to understand is that any 4xx or 5xx response is considered a successful request for the Fetch API. In other words, an error response produced by the server will not trigger any JavaScript error. The reason for this behavior is that fetch() made the request and the server replied with a response. Conceptually, that cannot be considered an error from the network’s point of view. At the end of the day, the request ended successfully.\n\nThis means that before dealing with the data returned by the server, you should always check for a successful response. To do so, you can implement the error-handling logic below:\n\nNote that the ok property from Response contains true only when the request was successful.\n\nThe Fetch API supports the abortion of already initiated requests through the AbortController API.\n\nTo stop an ongoing fetch() request, you first need to generate a signal object as below:\n\nNow, whenever you call the following instruction, your request will be interrupted by an AbortError:\n\nKeep in mind that the server might have already received the request. In this case, the server will still execute the request but the response will be ignored by Node.js.\n\nCongrats! You are now a Node.js Fetch API master!\n\nIn this article, you learned what is the Fetch API and how to use it in Node.js. In detail, you started from the fetch() basics and then dug into its advanced options and features. With such a powerful HTTP client, retrieving online data becomes easy. For example, you could use it to call our SERP API endpoints and start scraping SERP data.\n\nWant to learn more about scraping with Node.js? Read our web scraping with Node.js guide."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
        "document": "The Fetch API uses and objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.\n\nFor making a request and fetching a resource, use the method. It is a global method in both and contexts. This makes it available in pretty much any context you might want to fetch resources in.\n\nThe method takes one mandatory argument, the path to the resource you want to fetch. It returns a that resolves to the to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an options object as the second argument (see ).\n\nOnce a is retrieved, there are a number of methods available to define what the body content is and how it should be handled.\n\nYou can create a request and response directly using the and constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, from service workers).\n\nFind out more about using the Fetch API features in Using Fetch."
    },
    {
        "link": "https://medium.com/@data-surge/how-to-make-http-requests-in-node-js-with-fetch-api-83a8edb8e511",
        "document": "Web development often requires making HTTP requests to interact with external APIs or servers. Node.js, with its non-blocking, event-driven architecture, is a popular choice for building scalable network applications. Integrating the Fetch API into Node.js allows developers to make these HTTP requests efficiently. This guide will walk you through everything you need to know about using the Fetch API in Node.js, from setting up your environment to advanced techniques and best practices.\n\nHTTP requests are a fundamental part of modern web development. They allow applications to communicate with servers, retrieve data, and send updates. The Fetch API is a versatile tool for making these requests, and when combined with Node.js, it provides a powerful way to handle network operations. This guide will cover the basics of making HTTP requests with the Fetch API in Node.js, including GET and POST requests, handling headers, and advanced usage scenarios.\n\nBefore diving into making HTTP requests, you need to set up your development environment. Here’s what you need:\n• Node.js: Ensure you have Node.js installed. You can download it from Node.js official website.\n• Fetch API: Node.js doesn’t include the Fetch API by default, so you’ll need to install the package.\n• Install Node.js: Follow the installation instructions on the Node.js website.\n• Install node-fetch: Use npm to install the package.\n\nMaking GET requests is straightforward with the Fetch API. Here’s an example:\n• fetch: The fetch function initiates a network request to the specified URL.\n• catch(error): Handles any errors that occur during the request.\n\nTo send data to a server, you can use a POST request. Here’s how\n• method: Specifies the request method (POST in this case).\n• headers: Adds headers to the request, like .\n• body: The data to be sent, stringified into JSON format.\n\nHeaders are essential for sending additional information with your requests, such as authentication tokens.\n\nFetch API can be combined with other libraries like Cheerio for web scraping.\n\nAxios is another popular library for making HTTP requests. Here’s a comparison:\n• Minimize the payload size by sending only necessary data.\n• Use HTTPS to encrypt data in transit.\n\nHow to handle JSON responses in Fetch API?\n\nWhat are the common errors with Fetch API and how to fix them?\n\nCan Fetch API be used for web scraping in Node.js?\n• Yes, combine it with libraries like Cheerio for scraping purposes.\n\nThe Fetch API in Node.js offers a powerful way to make HTTP requests. By understanding the basics and advanced usage, you can effectively handle network operations in your applications. Remember to follow best practices for performance, security, and maintainability. Happy coding!\n\nFor further reading, check out the Fetch API Documentation and Node.js Documentation.\n\nCurious to find out more about web scraping? Make sure to check this blog. If you want to learn about a different method of scraping via a headless browser, refer to our Puppeteer tutorial. Also, don’t hesitate to try web scraper for free.\n\nRead more web scraping related articles: How to Bypass Amazon CAPTCHA When Scraping, How to Scrape Amazon Prices using Python, Web Scraping Google Finance (Python), Google Maps Data Scraper: Ultimate Guide, Web Scraping with ChatGPT: 2025 Guide, How to Scrape Amazon Reviews, How to Track Amazon Prices With Python."
    },
    {
        "link": "https://core.telegram.org/method/messages.sendMessage",
        "document": "Groups can be associated to a channel as a discussion group, to allow users to discuss about posts."
    },
    {
        "link": "https://core.telegram.org/bots/api",
        "document": "All queries to the Telegram Bot API must be served over HTTPS and need to be presented in this form: . Like this for example:\n\nThe boost was obtained by the creation of a Telegram Premium or a Telegram Star giveaway. This boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription for Telegram Premium giveaways and prize_star_count / 500 times for one year for Telegram Star giveaways.\n• Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.\n\nUse this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link , where is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.\n\nUse this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success."
    },
    {
        "link": "https://telegram-bot-sdk.readme.io/reference/sendmessage",
        "document": "Use this method to send text messages. On success, the sent Message is returned.\n\nSee sendMessage official docs for a list of supported parameters and other info.\n\nThe Bot API supports basic formatting for messages. You can use bold and italic text, as well as inline links and pre-formatted code in your bots' messages. Telegram clients will render them accordingly. You can use either markdown-style or HTML-style formatting.\n\nNote that Telegram clients will display an alert to the user before opening an inline link (‘Open this link?’ together with the full URL).\n\nTo use this mode, pass Markdown in the parse_mode field when using sendMessage. Use the following syntax in your message:\n\nTo use this mode, pass HTML in the parse_mode field when using sendMessage. The following tags are currently supported:"
    },
    {
        "link": "https://stackoverflow.com/questions/41664810/how-can-i-send-a-message-to-someone-with-my-telegram-bot-using-their-username",
        "document": "It's totally not safe to use other telegram versions available on internet, but I've seen that Telegram Plus has a ability to show you the chat_id of the user in their profile, even tho you don't have their contact.\n\nAnother way to extract chat_id of that particular user is that you have the phone number of that account, save it as your contact, then share it to this bot. It's easy to code it yourself but you can forward something from that user to this bot too, if you want to recieve the chat_id.\n\nurmurmur has also mentioned another way. I haven't checked it yet but seems to be interesting."
    },
    {
        "link": "https://rollout.com/integration-guides/telegram-bot-api/api-essentials",
        "document": "What type of API does Telegram Bot provide?\n\nThe Telegram Bot API is a REST API. Here are the key points about Telegram's Bot API:\n• It is an HTTP-based interface created for developers to build bots for Telegram.\n• All queries to the Telegram Bot API must be served over HTTPS.\n• Requests are made to endpoints in the format: https://api.telegram.org/bot <token> /METHOD_NAME.\n• It supports both GET and POST HTTP methods.\n• Responses contain a JSON object with a Boolean 'ok' field and an optional 'description' field.\n• If successful, the result is in the 'result' field of the JSON response.\n\nHere's a simple example of using the Telegram Bot API to send a message:\n\nThe Telegram Bot API follows REST principles, using HTTP methods and JSON for data exchange. It provides a straightforward way for developers to interact with Telegram's platform and create bots. The API's design allows for easy integration with various programming languages and frameworks that support HTTP requests.\n\nDoes the Telegram Bot API have webhooks?\n\nYes, the official Telegram Bot API does support webhooks. Here are the key points about webhooks in the Telegram Bot API:\n• Webhooks can be set up using the method.\n• When using webhooks, Telegram will send HTTPS POST requests to your specified URL whenever there is an update for your bot.\n• The updates are sent as JSON-serialized objects.\n• You can specify which types of updates you want to receive via webhook using the parameter. This allows you to subscribe to specific event types.\n• Some of the event types you can subscribe to include:\n• Webhooks require SSL/TLS encryption and can only be set on certain ports (443, 80, 88, 8443).\n• You can optionally set a secret token to verify webhook requests are coming from Telegram.\n• When using webhooks, you cannot use the method to receive updates.\n\nSo in summary, webhooks are fully supported and allow you to receive real-time updates for a wide variety of event types from the Telegram Bot API. The method gives you fine-grained control over what types of events you want to subscribe to.\n\nHere are the key API rate limits for the Telegram Bot API:\n• When sending messages inside a particular chat, avoid sending more than one message per second. Exceeding this may eventually result in 429 errors.\n• For bulk notifications to multiple users, the API will not allow more than 30 messages per second overall.\n• Bots cannot send more than 20 messages per minute to the same group.\n• Overall limit: 30 messages per second across all chats\n• The limits are per bot account, not per host/server. Multiple bots on the same server each have their own limits.\n• There are no built-in methods for sending bulk messages. Spreading notifications over longer intervals (8-12 hours) is recommended to avoid hitting limits.\n• If limits are exceeded, you'll start receiving 429 (Too Many Requests) errors.\n• Telegram has \"soft\" limits where you may be able to exceed them briefly, but will eventually be restricted if continued.\n• Implement queuing and rate limiting in your bot code to stay within the limits proactively.\n• Use different queues/limits for individual chats vs groups/channels.\n• For mass notifications, spread them out over longer time periods.\n\nBy following these limits and best practices, you can ensure your Telegram bot operates smoothly within the API constraints. Proper queuing and rate limiting implementation is key to avoiding issues.\n\nThe most recent version of the Telegram Bot API is 7.7 [3].\n• The Telegram Bot API is an HTTP-based interface created for developers to build bots for Telegram [1].\n• It provides JSON-encoded responses to queries [4].\n• The API is regularly updated with new features and improvements [2].\n• Developers can use libraries and frameworks in various programming languages to interact with the API more efficiently [4].\n• The Bot API documentation provides detailed information on all available methods and objects [1].\n• There are optional dependencies for certain features, but the core functionality requires only [3].\n• is a popular library that supports all types and methods of the Telegram Bot API 7.7 [3].\n• Telegram offers both the Bot API and the Telegram API (for custom clients) to developers free of charge [5].\n• Developers can also make use of the Payments API to accept payments from Telegram users [5].\n• Stay updated with the latest API changes by checking the changelog regularly [2].\n• Use libraries and frameworks for more robust and scalable bot development [4].\n• Consider using optional dependencies for advanced features when needed [3].\n• Familiarize yourself with the official Telegram Bot API documentation for comprehensive information [3].\n\nHow to get a Telegram Bot developer account and API Keys?\n\nFirst, you need to sign up for a Telegram account using any Telegram application if you don't already have one.\n\nTo create a bot, you need to talk to the BotFather on Telegram:\n• Start a chat with BotFather and send the command /newbot\n• Follow the prompts to choose a name and username for your bot\n• BotFather will generate an authorization token for your bot\n\nTo get API credentials for your bot:\n• Log in to the Telegram website: https://my.telegram.org\n• Fill out the form to create a new application\n• You will receive an api_id and api_hash for your application\n\nWith your bot token and API credentials, you can now use the Telegram Bot API:\n• Replace <method> with the API method you want to call\n\nWhat can you do with the Telegram Bot API?\n\nHere are the key data models you can interact with using the Telegram Bot API:\n• Get user information like ID, name, username, language code\n• Check if user is a bot, premium user, etc.\n• Get message information like ID, date, sender, etc.\n• Set bot commands that appear in menu\n• Receive updates about new messages, edited messages, etc.\n\nThe API allows you to interact with these models by sending HTTP requests to perform actions like sending messages, editing chats, answering inline queries, etc. The full capabilities for each model are detailed in the official Bot API documentation."
    }
]