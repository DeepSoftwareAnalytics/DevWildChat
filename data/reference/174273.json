[
    {
        "link": "https://geeksforgeeks.org/reverse-a-linked-list",
        "document": "Given a linked list, the task is to reverse the linked list by changing the links between nodes.\n\n[Expected Approach] Using Iterative Method – O(n) Time and O(1) Space\n\nThe idea is to reverse the links of all nodes using three pointers:\n• prev: pointer to keep track of the previous node\n• curr: pointer to keep track of the current node\n• next: pointer to keep track of the next node Starting from the first node, initialize curr with the head of linked list and next with the next node of curr. Update the next pointer of curr with prev. Finally, move the three pointer by updating prev with curr and curr with next.\n\nFollow the steps below to solve the problem:\n• None Iterate through the linked list. In a loop, do the following:\n• None Update the next pointer of curr to prev , curr -> next = prev\n• None Update prev as curr and curr as next, prev = curr curr = next\n\n// Given the head of a list, reverse the list and // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // of the linked list starting from the head # Given the head of a list, reverse the list and return the # Initialize three pointers: curr, prev and next # Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List\n\n[Alternate Approach – 1] Using Recursion – O(n) Time and O(n) Space\n\nFollow the steps below to solve the problem:\n• None Divide the list in two parts – first node and rest of the linked list.\n• reverse for the rest of the linked list.\n• None Link the rest linked list to first.\n\n// Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // Given the head of a list, reverse the list and // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // of the linked list starting from the head // Given the head of a list, reverse the list // and return the head of reversed list // If we have reached last node or linked // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // of the linked list starting from the head # Given the head of a list, reverse the list and # reverse the rest of linked list and put the # first element at the end # Make the current head as last node of # Update next of current head to NULL // Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and // put the first element at the end // Make the current head as last node // Update next of current head to NULL // of the linked list starting from the head // Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and // put the first element at the end // Make the current head as last node of // Update next of current head to NULL\n\n[Alternate Approach – 2] Using Stack – O(n) Time and O(n) Space\n\n\n\nFollow the steps below to solve the problem:\n• None Push all the nodes(values and address) except the last node in the stack.\n• None Once the nodes are pushed, update the Head pointer to the last node.\n• None Start popping the nodes and push them at the end of the linked list in the same order until the stack is empty.\n• None Update the next pointer of last node in the stack by NULL.\n\n// C++ program to reverse linked list using Stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // Pop the value from stack // move to the next node in the list // Update the next pointer of last node of stack to NULL // C program to reverse linked list using Stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list and // pop the top value by decrementing top by 1 // move to the next node in the list // Update the next pointer of last node of stack to NULL // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node // of the linked list starting from the head # Push all nodes except the last node into stack # Make the last node as new head of the linked list # Pop all the nodes and append to the linked list # append the top value of stack in list # move to the next node in the list # Update the next pointer of last node // C# program to reverse linked list using stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node of stack to null // Push all nodes except the last node into stack // Make the last node as new head of the Linked List // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node of stack to null"
    },
    {
        "link": "https://stackoverflow.com/questions/71036469/what-is-the-best-way-to-create-reverse-a-linked-list",
        "document": "The best way to reverse a singly-linked list is to reverse it without invoking undefined behavior\n\nIn your function you do not check whether the passed pointer is equal to . So the expression in the while loop\n\nThe function can be defined the following way\n\nPay attention to that the parameter of the recursive function should be declared with the qualifier because the list is not changed within the function\n\nI would declare and define the recursive function the following way\n\nand in main you could write\n\nUsing such a function you could output the list in any stream including a file stream."
    },
    {
        "link": "https://medium.com/outco/reversing-a-linked-list-easy-as-1-2-3-560fbffe2088",
        "document": "What I want to demonstrate with this post, is a simple way of reversing a list, with just 3 pointers. This runs in time and space.\n\nLet’s start by talking about what reversing actually means.\n\nIn a singly linked list, order is determined by a given node’s property. This property can either reference another node or will point to if this is the last node in the list. So reversing a linked list, simply means reassigning all the properties, on every node.\n\nSo we are really just going from this:\n\nLet’s look at what happens on an individual node level:\n\nTo do a reassignment on a single node (in this example it will be the 2 node) we just need two variables, let’s call them , . And all we’re doing is taking (which is represented by the arrow) and setting it equal to .\n\nBut now we’ve lost our reference to the node the was originally pointing to. So to make sure we don’t lose track of that node, we need a third variable: . This has to be set BEFORE we do the reassignment.\n\nThis lays out the basic mechanics of pointer reassignment, now let’s start to look at how this works on the list as a whole.\n\nBecause we need to repeat this process throughout the entire list if we want to fully reverse it. We can do this by moving each of those variables up through the list, from front to back, after each reassignment. We just have to be careful in our order of operations.\n\nThere are four tricky pieces to all this:\n• Knowing what to assign the variables to initially.\n• Knowing when to end this process of reassignments.\n• Making sure the order of operations is correct so we don’t lose track of any nodes.\n\nLet’s start with the first point. Initially, we want both the and the equal to the that is given as the input.\n\nThis is because we can’t assume the length of the linked list. What if was and we’re looking at an empty list?\n\nIf we do have at least one node in our list, we will end up assigning our variable to whatever comes next, but we first need to be sure we have at least one.\n\nWhich brings us to our next point, how long do we keep running our reassignment algorithm? Or put another way, how do we know when to end this series of reassignments?\n\nWell if your goal is to look at EVERY node, and reassign its property to whatever came before it, we need to make sure that our variable is assigned once to every node. This means doing a linear scan through the list, starting at the head.\n\nEventually though, it will reach the last node’s , which ALWAYS points to . So we can can run this function\n\nThe third step is to figure out the order of operations so we don’t lose track of anything.\n\nThat while loop we just made won’t run unless we have at least one node. But once it does, the first thing we want to do is set to so we don’t lose track of what comes after .\n\nRemember, before this point was equal to .\n\nThen we want to do the reassignment of , since we have all three pointers in place. This is the logic of actually reversing the linked list. We set equal to , which at this point is equal to .\n\nOnce we’ve done that, we can move up to equal , since we’re done with that node.\n\nAnd then finally we can move up by setting it equal to .\n\nSo to summarize those steps:\n\nAnd that completes one round of reversals. We just need to apply these same operations then to every node until we reach the end of the list.\n\nOne way to think about what we’re doing, is that we’re looking at a small window around each node. We’re keeping track of the node before it so that we can point its pointer to it. And we’re keeping track of the node after it so we don’t lose it and we can continue to move through the list.\n\nWhich brings us to our final step, on what to return.\n\nWell following the diagram and code it should be pretty clear. Since the while loop is running as long as is not , then must be for us to break out of the loop. also isn’t an option because at the end of a single loop, it’s equal to .\n\nWhich means we’re going to be returning , since it’s pointing to the node right before .\n\nAnd that concludes the algorithm. As you can see it takes only 10 lines of code, and shouldn’t be something that trips you up on an interview.\n\nIf you’re looking for a challenge from here, try swapping two nodes in a linked list. Here’s a link to the problem description and a diagram as a hint:"
    },
    {
        "link": "https://stackoverflow.com/questions/67205705/linked-list-reversal-has-errors",
        "document": "In our class right now we're covering nodes and linked lists, and are working on our first linked list program.\n\nWe've been given the following guidelines by the teacher:\n\nMake sure your function will accept 10 characters from STDIN and create a linked list with those characters (so your nodes will have a char member). Then, add an additional function called . The purpose of the reverse function will be to create a copy of the linked list with the nodes reversed. Finally, print off the original linked list as well as the reversed linked list.\n\nI've gotten it all written out, and I've compiled it with no errors - but the program doesn't work as intended, and I'm not entirely sure why. I'm sure it has something to do with how I've set up the pointers to \"walk\" the nodes - as the debug I put in shows it looping twice per user input letter. Specifications are that we're only supposed to use one function, and we pass a to the function, and it returns the same. The function cannot print out anything - only make the second list that is a reverse of the first.\n\nAny help would be greatly appreciated, I'm not terribly good at this yet and I'm sure I've made some rather silly mistakes."
    },
    {
        "link": "https://almabetter.com/bytes/articles/how-to-reverse-a-linked-list",
        "document": "A linked list is a technique to store a list of things, like a to-do list, where each item has a reference to the next item in the list. It's like a chain, where each link points to the next link. You can add or remove items easily by changing the links between them. In technical terms, A linked list is a data structure used for storing a sequence of elements. It consists of a sequence of nodes, each containing some data and a reference to the next node in the list.\n\nReversing a linked list means changing the order of the elements in the list so that the last element becomes the first, the second-to-last becomes the second, and so on. This is usually done by updating the references in each node to point to the previous node instead of the next one, effectively reversing the direction of the list.\n\nUnderstanding Reversal of Linked List with the Help of a Story\n\nThere was a little girl named Alice who enjoyed playing with her toy trains. She had an extensive track set up in her room that snaked around her bed, bookshelf, and beloved armchair. One day, she decided to arrange her trains on the track in a specific sequence: first, the red train, then the blue, the green, and finally, the yellow train.\n\nAlice was content with her trains' arrangement, but her younger brother Bob entered her room and wanted to play with the trains as well. Unlike Alice, Bob was not very orderly, and he chose to play with the trains by haphazardly pushing them along the track. When he finished, the trains' order was completely different from Alice's initial setup.\n\nUnhappy with the new arrangement, Alice resolved to reverse the order. She placed the yellow train at the front of the track, followed by the green, the blue, and lastly, the red train. The trains were now in the precise order she desired.\n\nSimilarly, we can reverse a linked list's order, much like Alice did with her trains. A linked list can be compared to a train track, where each train car represents a node in the list and contains a reference to the subsequent car. To reverse the list, we need to alter the next reference of each node to point to the preceding node instead of the following one. This is akin to positioning the last train car at the track's beginning, succeeded by the second-to-last car, and so forth.\n\nSituations where reversing a linked list might be useful:\n• Pagination: When implementing pagination on a website or application, a linked list can be used to represent the list of items being paginated. Reversing the linked list can make it easier to display the most recent items first.\n• Text editing: In a text editor, a linked list can be used to represent the characters in a document. Reversing the list can be useful for operations like searching for a word or sentence from the end of the document.\n• Routing tables: In computer networking, routing tables are used to determine the best path for data packets to travel between nodes on a network. Linked lists can be used to represent the routing table, and reversing the list can help to optimize the pathfinding algorithm.\n• Audio and video processing: In digital signal processing, linked lists can be used to represent the data stream of an audio or video file. Reversing the list can be useful for certain audio and video processing algorithms, such as reverse playback or real-time effects processing.\n\nIterative solutions use loops and conditionals to repeatedly execute a block of code until a condition is met. Iterative solutions are often more efficient in terms of memory usage and execution time since they don't require the overhead of function calls and maintaining a call stack.\n\nLet's say we have the following linked list:\n\nInitially, we have three pointers:\n\nWe start by reversing the first node in the list:\n\nWe then move the prev, current, and next pointers to the next node:\n\nWe repeat this process for each node in the list until we reach the end:\n\nAt this point, the list has been fully reversed. We update the head pointer to the last node, which is 4, and return it.\n\nA complete code to reverse the linked list iteratively would be:\n\nCommon challenges or errors that can arise:\n• Off-by-one errors: It's easy to make off-by-one errors when manipulating pointers in a linked list. This can result in the list being incorrectly reversed or even in an infinite loop.\n• Pointer reassignment: When reversing a linked list iteratively, it's important to keep track of the previous, current, and next pointers. If these pointers are not properly reassigned during the reversal process, it can result in the list being incorrectly reversed.\n• Null pointer exceptions: Null pointer exceptions can occur when trying to manipulate a null pointer in a linked list. This can happen if the pointers are not properly initialized or if the list is empty.\n• Memory leaks: Memory leaks can occur if the memory used by the nodes in the linked list is not properly deallocated. This can happen if the pointers are not properly reassigned during the reversal process.\n\nRecursion is a programming technique where a function calls itself with different arguments until a certain condition is met. Recursion allows you to solve complex problems by breaking them down into smaller, simpler sub-problems that can be solved recursively.\n\nTo reverse a linked list recursively, we need to define a recursive function that takes the head of the linked list as input and returns the new head of the reversed linked list.\n\nSuppose we have the following linked list:\n\nWe first define a recursive function reverseList that takes the head of the linked list as an argument:\n\nIn this example, the head of the linked list is the node with value 1.\n\nWe check if the head of the linked list is either None or the last node in the linked list (i.e., if it doesn't have a next node). If so, we simply return the head as is:\n\nIn this example, the head has a next node (i.e., it's not the last node in the linked list), so we proceed with the recursive call.\n\nWe make a recursive call to reverseList with the next node as the new head:\n\nThis will recursively reverse the rest of the linked list and return the new head, which in this example is the node with value 5.\n\nWe then set head.next.next to head to reverse the order of the nodes:\n\nAt this point, the linked list looks like this:\n\nWe then set head.next to None to sever the original link between head and its next node:\n\nAt this point, the linked list looks like this:\n\nWe finally return the new head of the reversed linked list, which is the node that was originally the last node in the linked list (i.e., the node that was returned by the last recursive call):\n\nThe final reversed linked list looks like this:\n\nSo the complete code to reverse the linked list recursively would be:\n\nCommon challenges or errors that can arise:\n\nReversing a linked list through a recursive approach can present some difficulties and common pitfalls. Here are a few to be aware of:\n• Incorrect Base Case Handling: A frequent mistake is not defining the base case correctly. The base case acts as the stopping point for the recursive function and if not set properly, can result in an infinite loop and cause a stack overflow error.\n• Modifying the Original Linked List: When reversing the linked list, it is crucial to create a new one instead of altering the original. Doing so can result in a corrupted linked list that no longer links to the correct nodes.\n• Losing the Head Pointer: Keeping track of the head pointer is crucial to ensure the linked list is reversed correctly. Losing sight of it can result in a mis-reversed linked list.\n• Improper Updating of Node Pointers: The correct order of updating the node pointers is crucial to a successful reverse. Updating them in the wrong order can result in a mis-reversed linked list.\n• Stack Overflow Error: Recursion generates a new stack frame for each call, and a deep level of recursion can cause a stack overflow error. Optimizing the recursive function and reaching the base case in a timely manner can prevent this.\n\nWhich is better - Reversing a Linked List Recursively or Iteratively?\n\nDeciding whether to use a recursive or iterative approach for reversing a linked list depends on the specific context and requirements. Here are some factors to keep in mind:\n• Efficiency: Iterative methods tend to be more efficient than recursive ones, as they do not involve the overhead of function calls and managing a call stack. If efficiency is a priority, consider using an iterative approach.\n• Memory consumption: Recursive techniques can consume more memory than iterative ones because they necessitate a call stack. If memory usage is a concern, an iterative approach might be more suitable.\n• Clarity: Recursive methods are often more comprehensible and straightforward than iterative ones, as they closely resemble the problem statement. If clarity is important, a recursive approach might be preferable.\n• Ease of maintenance: Recursive methods can be more challenging to maintain and debug than iterative ones due to their increased complexity. If ease of maintenance is a priority, consider using an iterative approach.\n• Support from language and libraries: Certain programming languages and libraries provide better support for recursive methods. If the language or library used has robust support for recursion, a recursive approach might be more appropriate.\n\nIn general, if efficiency is a key concern, an iterative approach might be more suitable. However, if the clarity is of greater importance or the problem is inherently recursive, a recursive approach might be the better option.\n\nIn conclusion, reversing a linked list is a way of changing the order of elements in the list so that the last becomes the first, the second-to-last becomes the second, and so on. This is typically done by updating the references in each node to point to the previous node instead of the next one. Iterative solutions use loops and conditionals to execute a block of code repeatedly until a condition is met. They are often more efficient in terms of memory usage and execution time than recursive solutions. Reversing a linked list can be useful in various situations, such as pagination, text editing, routing tables, and audio and video processing.\n\nSome best practices to keep in mind while reversing a linked list:\n• Handle edge cases: Make sure to handle edge cases such as empty lists, lists with only one node, or lists with circular references.\n• Keep track of three-pointers: To reverse a linked list, you need to keep track of three-pointers: prev, curr, and next. The prev pointer points to the previous node, the curr pointer points to the current node, and the next pointer points to the next node in the original list.\n• Use temporary variables: When updating the pointers of each node, use temporary variables to store the values of the pointers before updating them. This will prevent you from losing access to the original values and will ensure that the reversal is done correctly.\n• Base case: Make sure to define a base case for the recursion. The base case should handle empty or single-node lists, which cannot be further reversed.\n• Check for null values: Always check for null values before accessing any node's pointer. This will prevent your program from crashing due to null pointer exceptions.\n• Examine your code: After completing your code, rigorously test it using various test cases to ensure it functions as intended. Evaluate its performance with diverse linked list scenarios, including lists of varying sizes, circular linked lists, and lists containing repeated values.\n\n1. Can you explain the time and space complexity of your iterative linked list reversal algorithm?\n\nAnswer: The time complexity of an iterative linked list reversal algorithm is O(n), where n is the number of nodes in the list. The space complexity is O(1), because the algorithm only uses a constant amount of additional memory for the three-pointers.\n\n2. Can you explain the time and space complexity of your recursive linked list reversal algorithm?\n\nAnswer: The time complexity of a recursive linked list reversal algorithm is also O(n), where n is the number of nodes in the list. The space complexity is O(n) because the algorithm uses additional memory for the recursive function call stack.\n\n3. How would you handle edge cases such as empty or single-node lists when reversing a linked list?\n\nAnswer: When reversing a linked list, it's important to handle edge cases such as empty or single-node lists. For example, you might define a base case to return the head pointer if the list is empty or if it contains only one node."
    },
    {
        "link": "https://learn-c.org/en/Linked_lists",
        "document": "Linked lists are the best and simplest example of a dynamic data structure that uses pointers for its implementation. However, understanding pointers is crucial to understanding how linked lists work, so if you've skipped the pointers tutorial, you should go back and redo it. You must also be familiar with dynamic memory allocation and structures.\n\nEssentially, linked lists function as an array that can grow and shrink as needed, from any point in the array.\n\nLinked lists have a few advantages over arrays:\n• Items can be added or removed from the middle of the list\n• There is no need to define an initial size\n\nHowever, linked lists also have a few disadvantages:\n• There is no \"random\" access - it is impossible to reach the nth item in the array without first iterating over all items up until that item. This means we have to start from the beginning of the list and count how many times we advance in the list until we get to the desired item.\n• Dynamic memory allocation and pointers are required, which complicates the code and increases the risk of memory leaks and segment faults.\n• Linked lists have a much larger overhead over arrays, since linked list items are dynamically allocated (which is less efficient in memory usage) and each item in the list also must store an additional pointer.\n\nA linked list is a set of dynamically allocated nodes, arranged in such a way that each node contains one value and one pointer. The pointer always points to the next member of the list. If the pointer is NULL, then it is the last node in the list.\n\nA linked list is held using a local pointer variable which points to the first item of the list. If that pointer is also NULL, then the list is considered to be empty.\n\nNotice that we are defining the struct in a recursive manner, which is possible in C. Let's name our node type .\n\nNow we can use the nodes. Let's create a local variable which points to the first item of the list (called ).\n\nWe've just created the first variable in the list. We must set the value, and the next item to be empty, if we want to finish populating the list. Notice that we should always check if malloc returned a NULL value or not.\n\nTo add a variable to the end of the list, we can just continue advancing to the next pointer:\n\nThis can go on and on, but what we should actually do is advance to the last item of the list, until the variable will be .\n\nLet's build a function that prints out all the items of a list. To do this, we need to use a pointer that will keep track of the node we are currently printing. After printing the value of the node, we set the pointer to the next node, and print again, until we've reached the end of the list (the next node is NULL).\n\nAdding an item to the end of the list\n\nTo iterate over all the members of the linked list, we use a pointer called . We set it to start from the head and then in each step, we advance the pointer to the next item in the list, until we reach the last item.\n\nThe best use cases for linked lists are stacks and queues, which we will now implement:\n\nAdding an item to the beginning of the list (pushing to the list)\n\nTo add to the beginning of the list, we will need to do the following:\n• Create a new item and set its value\n• Link the new item to point to the head of the list\n• Set the head of the list to be our new item\n\nThis will effectively create a new head to the list with a new value, and keep the rest of the list linked to it.\n\nSince we use a function to do this operation, we want to be able to modify the head variable. To do this, we must pass a pointer to the pointer variable (a double pointer) so we will be able to modify the pointer itself.\n\nRemoving the first item (popping from the list)\n\nTo pop a variable, we will need to reverse this action:\n• Take the next item that the head points to and save it\n• Set the head to be the next item that we've stored on the side\n\nHere is the code:\n\nRemoving the last item of the list\n\nRemoving the last item from a list is very similar to adding it to the end of the list, but with one big exception - since we have to change one item before the last item, we actually have to look two items ahead and see if the next item is the last one in the list:\n\nTo remove a specific item from the list, either by its index from the beginning of the list or by its value, we will need to go over all the items, continuously looking ahead to find out if we've reached the node before the item we wish to remove. This is because we need to change the location to where the previous node points to as well.\n\nHere is the algorithm:\n• Iterate to the node before the node we wish to delete\n• Save the node we wish to delete in a temporary pointer\n• Set the previous node's next pointer to point to the node after the node we wish to delete\n• Delete the node using the temporary pointer\n\nThere are a few edge cases we need to take care of, so make sure you understand the code.\n\nYou must implement the function which receives a double pointer to the head and removes the first item in the list which has the value ."
    },
    {
        "link": "https://medium.com/@thisislong/pointer-manipulation-the-key-to-linked-list-algorithmic-problems-part-2-9eb979d117b3",
        "document": "This topic includes 2 parts. If you have not read part 1, click here to do so.\n\nA reminder, this post would be more like a document for myself about the problems that I have encountered. The thought process in here would either be my thoughts that lead to my solution or my understanding of how other people’s solution (that I found) work and how they thought of it (or at least I think that’s how they thought).\n\nInput: a singly linked list with or without the position on the list that the tail connects to. If = -1 then tail does not connect to anything, hence, no cycle.\n\nOutput: The node that tail connects to. if no cycle found\n\nThe first solution that came to my mind involves a Set, which could be used to store unique nodes that we have visited as we go through the list. If there is a cycle in this list, the first node that we encounter for the second time — by checking with the Set — would be the one we need to return. This would be O(n) time and space solution with n being the number of nodes.\n\nHowever, the question wants us to solve this by using constant space O(1), so using Set would not be the most optimal. This is one of those problems where if you know, then you know. Otherwise it would take more time than expected to solve using constant space."
    },
    {
        "link": "https://geeksforgeeks.org/linked-list-in-c",
        "document": "A linked list is a linear data structure where each element, known as a node, is connected to the next one using pointers. Unlike array, elements of linked list are stored in random memory locations.\n\nIn this article, we will learn about the linked list, its types, representation of the linked list in C, and discuss what link list offers as compared to the similar data structures.\n\nA linked list is a sequence of nodes where each node contains two parts:\n• Data : The value stored in the node.\n• Pointer : A reference to the next node in the sequence. \n\n(There can be multiple pointers for different kind of linked list.)\n\nUnlike arrays, linked lists do not store elements in contiguous memory locations. Instead, each node points to the next, forming a chain-like structure and to access any element (node), we need to first sequentially traverse all the nodes before it.\n\nIt is a recursive data structure in which any smaller part of it is also a linked list in itself.\n\nRepresentation of Linked List in C\n\nIn C, linked lists are represented as the pointer to the first node in the list. For that reason, the first node is generally called head of the linked list. Each node of the linked list is represented by a structure that contains a data field and a pointer of the same type as itself. Such structure is called self-referential structures.\n\nTypes of Linked List in C\n\nLinked list can be classified on the basis of the type of structure they form as a whole and the direction of access. Based on this classification, there are five types of linked lists:\n\nLet's discuss about each of them.\n\nA linked list or singly linked list is a linear data structure that is made up of a group of nodes in which each node has two parts: the data, and the pointer to the next node. The last node's (also known as tail) pointers point to NULL to indicate the end of the linked list.\n\nRepresentation of Singly Linked List in C\n\nA linked list is represented as a pointer to the first node where each node contains:\n• Data: Here the actual information is stored.\n• Next: Pointer that links to the next node.\n\nA doubly linked list is a bit more complex than singly linked list. In it, each node contains three parts: the data, a pointer to the next node, and one extra pointer which points to the previous node. This allows for traversal in both directions, making it more versatile than a singly linked list.\n\nRepresentation of Doubly Linked List in C\n\nA doubly linked list is represented as a pointer to the first node (head), where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node in the sequence.\n• Previous : A pointer that links to the previous node in the sequence.\n\nA circular linked list is a variation of a singly linked list where the last node points back to the first node, forming a circle. This means there is no NULL at the end, and the list can be traversed in a circular manner.\n\nThe structure of the circular linked list node is same as that of singly linked list.\n\nRepresentation of Circular Linked List in C\n\nA circular linked list is represented as a pointer to the first node, where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node, with the last node pointing back to the first node.\n\nIt is same as the structure for singly linked list node.\n\n\n\nApplications of Linked Lists in C\n\nThe following are some major applications of linked list:\n• None Dynamic memory allocation efficiently manages and allocates dynamic memory in systems and applications.\n• None Implementing other data structures such as stacks, queues, etc.\n• None Represents and manipulates polynomials, with each node storing terms.\n• None Used in file system management dynamically in operating systems.\n• None Linked lists can grow or shrink in size dynamically, as memory is allocated or deallocated as needed.\n• None Inserting or deleting nodes in a linked list is efficient and does not require shifting elements, unlike arrays.\n• None Memory is utilized more efficiently as linked lists do not require a pre-allocated size, reducing wasted space.\n• None They serve as the foundation for implementing more complex data structures like stacks, queues, and graphs.\n• None They can utilize non-contiguous memory blocks, making them suitable for applications where memory is fragmented.\n• None Linked lists do not allow direct access to elements by index. Accessing a specific node requires traversing from the head, leading to slower access times.\n• None Managing pointers can be tricky, increasing the complexity of coding.\n• None Searching for an element or accessing a node by index takes O(N) time, making linked lists slower for such operations compared to arrays.\n\nHow does a linked list differ from an array?\n\nWhat are the main types of linked lists?\n\nWhy use a linked list instead of an array?\n\nWhat are the limitations of linked lists?\n\nWhat are real-world applications of linked lists?"
    },
    {
        "link": "https://medium.com/@thisislong/pointer-manipulation-the-key-to-linked-list-algorithmic-problems-part-1-49b302fc95bd",
        "document": "Linked list is quite a special data structure that is often asked in coding interview but never actually used in real life. They are scary at first as pointers are usually very confusing. I have been practicing solving a few of those problems on Leetcode recently and most of them are just about how to manipulate those pointers ‘creatively’. Once you understand how to use that and the way it works, linked list problems would become less intimidating. There are also not many different types of linked list question so once you have done a few, you can mostly do any other ones. This post would be more like a document for myself about the problems that I have encountered. The thought process in here would either be my thoughts that lead to my solution or my understanding of how other people’s solution (that I found) work and how they thought of it (or at least I think that’s how they thought). The post is a bit too long so I break them down into 2 parts. Click here to go to Part 2. A few observations I had after doing a few of those problems:\n• Never use the TreeNode to traverse or modify the list directly. If we do so we would lose track of the original list — singly linked list cannot be iterated backwards.\n• Sometimes, we can create a new TreeNode that its pointer points to . It is treated as a dummy pointer. The main reason we need it is that we want a way to return to the start of the result list.\n• In order to remove a node from a list, we need the node before that. We simply update its next pointer to skip the node we want to remove. Now let’s dive into some coding questions.\n\nThe good thing about this problem is that the list is sorted, so if the number is duplicated, we could find out straight away by moving the pointer to check the next element. However, in order to do so, we need to ‘store’ or somehow mark the current number so that when we move to the next element, we can verify with that saved value. This leads to the idea of having 2 pointers. Let’s call them and . But how do we use these 2 pointers? is used to mark the start of the duplicated sequence. will keep on traversing and do whatever it needs to (we’ll get to that). Another question, should we put the on the first duplicate found or on the element right before that (meaning would be the start of the duplicated sequence)? That leads to the next point.\n\nFor example, we choose to put the on the first element of the duplicated sequence. Another challenge arises: say, after detecting a few duplicates and remove them from the list, if the next element is NOT similar to the value at , we need to remove the node at . It causes a problem because we can only remove it by updating the pointer of the element before it and with the singly linked list, we could not move back in the opposite way. Ok so seems like the needs to be before the start of such sequence. What about ?\n\nObviously, the should move faster than the . But how fast? Initially, I thought I would just move the and remove duplicates one by one. But I realised to remove a node, I need access to the previous node, which I would not have if I remove one by one. A better solution would be remove the whole duplicated sequence. We could use as a scout, moving 1 step in front of and check if the next element is the same as itself or not. If not, it is ‘safe’ for to move forward to the current . This ensures that always is 1 node before the start of the duplicates.So we keep traversing the until is not a duplicated value. In other words, if current value of is equal to value of , we keep moving forward until they are different. By this time, the duplicated values are in the range from to . Now, if we want to skip the whole duplicated sequence, simply make point to . - If they are pointing to the same thing then there has been no duplication yet, hence move both pointers. Fast forward... - Now, start.next is 3 and end is at 3 also - Now, start.next is still node 3 (Node that has value 3 and point to another 3), whereas end is now pointing to node with value 3 but its next pointer POINT TO 4. Meaning the duplicated sequence is identified. - Update node 2 to point to end.next, which is 4, skipping all duplicated val\n\nMy thought was to make the original list my list with all index nodes, and create another list for all index nodes. Then, as I traverse the original list, skip the index and put those even nodes on the second list. Finally, merge them together by make the tail of the list point to the start of the list. There should be 4 pointers involved: should start out as . Whereas should be the next node. in this case would be the first even node, which temporarily is being pointed at by .\n\nThe condition for the while loop might be a bit tricky. Since the starts off slightly faster than the with 1 node ahead, and we want to ‘virtually’ cut the list in half, then we need to check for 2 conditions:\n• If is not (after last node — in the case that there are odd number of nodes in the list)\n• AND if is not ( at last node — in the case that there are even number of nodes in the list) Inside the loop, there are 4 steps. Since the starts slower, we process it first:\n• Update to point to the next odd node — skipping even node\n• Move the to that next odd node\n• Update to point to the next even node, which is after the current\n• Move the to that next even node We simply manipulate current pointers to skip odd/even nodes and then combine them at the end. Until the loop finishes, the is still pointing at the first even node of the original list; and is still the start of the original list, or eventually, the result list. I find pointers quite confusing: even though is assigned to , as moves along, does not. could manipulate the current node to point to the next node, but when it moves to the next node, that does not mean is also moved. The thing about pointer is that it is about referencing — pointing to address on memory. Think of it as the address of current node is , which is originally assigned to both and . When the ‘moves’ to the next node, which has address , is still at ."
    },
    {
        "link": "https://cs.princeton.edu/courses/archive/spr01/cs126/lectures/P8-4up.pdf",
        "document": ""
    }
]