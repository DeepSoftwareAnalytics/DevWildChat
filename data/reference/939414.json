[
    {
        "link": "https://reddit.com/r/ProgrammingLanguages/comments/8yzdwq/creating_esoteric_programming_languages",
        "document": "I've been working on an esoteric programming language, \"What?\", over the past few hours (GitHub).\n\nWhile programming language design has always been something that interests me, I've never really given esoteric language design much thought. Given the success of languages like Brainfuck, what would you consider to be the best practices? Simplicity? Completeness? Functionality? Ridiculousness?\n\nTell me what you think. Have you ever created an esoteric language yourself?"
    },
    {
        "link": "https://blinry.org/esolangs/esolangs.pdf",
        "document": ""
    },
    {
        "link": "https://quora.com/How-can-I-build-my-own-programming-language-like-Brainfuck",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Esoteric_programming_language",
        "document": "Programming language not aimed for serious use\n\nAn esoteric programming language (sometimes shortened to esolang) is a programming language designed to test the boundaries of computer programming language design, as a proof of concept, as software art, as a hacking interface to another language (particularly functional programming or procedural programming languages), or as a joke. The use of the word esoteric distinguishes them from languages that working developers use to write software. The creators of most esolangs do not intend them to be used for mainstream programming, although some esoteric features, such as visuospatial syntax,[1] have inspired practical applications in the arts. Such languages are often popular among hackers and hobbyists.[citation needed]\n\nUsability is rarely a goal for designers of esoteric programming languages; often their design leads to quite the opposite. Their usual aim is to remove or replace conventional language features while still maintaining a language that is Turing-complete, or even one for which the computational class is unknown.\n\nThe earliest, and still the canonical example of an esoteric programming language, is INTERCAL,[2] designed in 1972 by Don Woods and James M. Lyon, who said that their intention was to create a programming language unlike any with which they were familiar.[3][4] It parodied elements of established programming languages of the day such as Fortran, COBOL and assembly language.\n\nFor many years, INTERCAL was represented only by paper copies of the INTERCAL manual. Its revival in 1990 as an implementation in C under Unix stimulated a wave of interest in the intentional design of esoteric computer languages.\n\nIn 1993, Wouter van Oortmerssen created FALSE, a small stack-oriented programming language with syntax designed to make the code inherently obfuscated, confusing and unreadable. Its compiler is only 1024 bytes in size.[5] This inspired Urban Müller to create an even smaller language, the now-infamous Brainfuck, which consists of only eight recognized characters. Along with Chris Pressey's Befunge (like FALSE, but with a two-dimensional instruction pointer), Brainfuck is now one of the best-supported esoteric programming languages, with canonical examples of minimal Turing tarpits and needlessly obfuscated language features. Brainfuck is related to the P′′ family of Turing machines.\n\nWhile esoteric programming languages differ in many ways, there are some common traits that characterize many languages, such as parody, minimalism, and the goal of making programming difficult.[2] Many esoteric programming languages, such as brainfuck, and similar, use single characters as commands, however, it is not uncommon for languages to read line by line like conventional programming languages.\n\nConventional imperative programming languages typically allow data to be stored in variables, but esoteric languages may utilize different methods of storing and accessing data. Languages like Brainfuck and Malbolge only permit data to be read through a single pointer, which must be moved to a location of interest before data is read. Others, like Befunge and Shakespeare, utilize one or more stacks to hold data, leading to a manner of execution akin to Reverse Polish notation. Finally, there are languages which explore alternative forms of number representation: the Brainfuck variant Boolfuck only permits operations on single bits, while Malbolge and INTERCAL variant TriINTERCAL replace bits altogether with a base 3 ternary system.[6]\n\nEsoteric languages also showcase unique ways of representing program instructions. Some languages, such as Befunge and Piet, represent programs in two or more dimensions, with program control moving around in multiple possible directions through the program.[page needed] This differs from conventional languages in which a program is a set of instructions usually encountered in sequence. Other languages modify instructions to appear in an unusual form, often one that can be read by humans with an alternate meaning to the underlying instructions. Shakespeare achieves this by making all programs resemble Shakespearian plays. Chef achieves the same by having all programs be recipes.[6] Chef is particularly notable in that some have created programs that successfully function both as a program and as a recipe, demonstrating the ability of the language to produce this double meaning.[8]\n\nMany esoteric programming languages are designed to produce code that is deeply obfuscated, making it difficult to read and to write.[9] The purpose of this may be to provide an interesting puzzle or challenge for program writers: Malbolge for instance was explicitly designed to be challenging, and so it has features like self-modifying code and highly counterintuitive operations.[9] On the other hand, some esoteric languages become difficult to write due to their other design choices. Brainfuck is committed to the idea of a minimalist instruction set, so even though its instructions are straightforward in principle, the code that arises is difficult for a human to read. INTERCAL's difficulty arises as a result of the choice to avoid operations used in any other programming language, which stems from its origin as a parody of other languages.[9]\n\nOne of the aims of esoteric programming languages is to parody or spoof existing languages and trends in the field of programming.[9] For instance, the first esoteric language INTERCAL began as a spoof of languages used in the 1960s, such as APL, Fortran, and COBOL. INTERCAL's rules appear to be the inverse of rules in these other languages.[10] However, the subject of parody is not always another established programming language. Shakespeare can be viewed as spoofing the structure of Shakespearean plays, for instance. The language Ook! is a parody of Brainfuck, where Brainfuck's eight commands are replaced by various orangutan sounds like \"Ook. Ook?\"[6]\n\nBefunge allows the instruction pointer to roam in multiple dimensions through the code. For example, the following program displays \"Hello World\" by pushing the characters in reverse order onto the stack, then printing the characters in a loop which circulates clockwise through the instructions , , , , , and .\n\nThere are many versions of Befunge, the most common being Befunge-93, named as such because of its release year.[11]\n\nBinary lambda calculus is designed from an algorithmic information theory perspective to allow for the densest possible code with the most minimal means, featuring a 29-byte self interpreter, a 21-byte prime number sieve, and a 112-byte Brainfuck interpreter.[12]\n\nBrainfuck is designed for extreme minimalism and leads to obfuscated code, with programs containing only eight distinct characters. The following program outputs \"Hello, world!\":[13]\n\nAll characters other than are ignored.\n\nChicken has just three tokens, the word \"chicken\", \" \" (the space character), and the newline character. The compiler interprets the number of \"chickens\" on a line as an opcode instruction which it uses to manipulate data on a stack. A simple chicken program can contain dozens of lines with nothing but the word \"chicken\" repeated countless times.[14] Chicken was invented by Torbjörn Söderstedt who drew his inspiration for the language from a parody of a scientific dissertation.[15][16][17]\n\nChef is a stack-oriented programming language created by David Morgan-Mar, designed to make programs look like cooking recipes.[18] Programs consist of a title, a list of variables and their data values, and a list of stack manipulation instructions.[19] A joking design principle states that \"program recipes should not only generate valid output, but be easy to prepare and delicious\", and Morgan-Mar notes that an example \"Hello, World!\" program with 101 eggs and 111 cups (~26,640 mL) oil would produce \"a lot of food for one person.\"[19][20]\n\nA FRACTRAN program is an ordered list of positive fractions together with an initial positive integer input . The program is run by multiplying the integer by the first fraction in the list for which is an integer. The integer is then replaced by and the rule is repeated. If no fraction in the list produces an integer when multiplied by , the program halts. FRACTRAN was invented by mathematician John Conway.[21]\n\nPrograms in GolfScript, a language created for code golf, consist of lists of items, each of which is pushed onto the stack as it is encountered, with the exception of variables which have code blocks as their value, in which case the code is executed.[22]\n\nINTERCAL, short for \"Compiler Language With No Pronounceable Acronym\", was created in 1972 as a parody to satirize aspects of the various programming languages at the time.[4]\n\nJSFuck is an esoteric programming style of JavaScript, where code is written using only six characters: , , , , , and . Unlike Brainfuck, which requires its own compiler or interpreter, JSFuck is valid JavaScript code, meaning JSFuck programs can be run in any web browser or engine that interprets JavaScript.[23][24] It has been used in a number of cross-site scripting (XSS) attacks on websites such as eBay due to its ability to evade cross-site scripting detection filters.[25]\n\nLOLCODE is designed to resemble the speech of lolcats. The following is the \"Hello World\" example:\n\nWhile the semantics of LOLCODE is not unusual, its syntax has been described as a linguistic phenomenon, representing an unusual example of informal speech and internet slang in programming.[26]\n\nMalbolge (named after the 8th circle of Hell) was designed to be the most difficult and esoteric programming language. Among other features, code is self-modifying by design and the effect of an instruction depends on its address in memory.[27]\n\nPiet is a language designed by David Morgan-Mar, whose programs are bitmaps that look like abstract art.[28] The execution is guided by a \"pointer\" that moves around the image, from one continuous coloured region to the next. Procedures are carried out when the pointer exits a region.\n\nThere are 20 colours for which behaviour is specified: 18 \"colourful\" colours, which are ordered by a 6-step hue cycle and a 3-step brightness cycle; and black and white, which are not ordered. When exiting a \"colourful\" colour and entering another one, the performed procedure is determined by the number of steps of change in hue and brightness. Black cannot be entered; when the pointer tries to enter a black region, the rules of choosing the next block are changed instead. If all possible rules are tried, the program terminates. Regions outside the borders of the image are also treated as black. White does not perform operations, but allows the pointer to \"pass through\". The behaviour of colours other than the 20 specified is left to the compiler or interpreter.[28][non-primary source needed]\n\nVariables are stored in memory as signed integers in a single stack. Most specified procedures deal with operations on that stack, while others deal with input/output and with the rules by which the compilation pointer moves.[29]\n\nPiet was named after the Dutch painter Piet Mondrian.[30] The original intended name, Mondrian, was already taken by an open-source statistical data-visualization system.[28]\n\nShakespeare Programming Language (SPL) is designed to make programs look like Shakespearean plays. For example, the following statement declares a point in the program which can be reached via a GOTO-type statement:[citation needed]\n\nUnlambda is a minimalist functional programming language based on SKI calculus, but combined with first-class continuations and imperative I/O (with input usually requiring the use of continuations).[31]\n\nWhitespace uses only whitespace characters (space, tab, and return), ignoring all other characters, which can therefore be used for comments. This is the reverse of many traditional languages, which do not distinguish between different whitespace characters, treating tab and space the same. It also allows Whitespace programs to be hidden in the source code of programs in languages like C.[citation needed]\n\nThe cultural context of esolangs has been studied by Geoff Cox, who writes that esolangs \"shift attention from command and control toward cultural expression and refusal\",[32] seeing esolangs as similar to code art and code poetry, such as Mez Breeze's mezangelle, a belief shared by others in field.[33] Daniel Temkin describes Brainfuck as \"refusing to ease the boundary between human expression and assembly code and thereby taking us on a ludicrous journey of logic,\"[34] exposing the inherent conflict between human thinking and computer logic by deconstructing their relationship. He connects programming within an esolang to performing an event score such as those of the Fluxus movement, where playing out the irregular rules of the logic in code makes the point of view of the language clear.[35]\n• None Kneusel, Ronald (2022). Strange Code: Esoteric Languages That Make Programming Fun Again. No Starch Press. ISBN ."
    },
    {
        "link": "https://medium.com/@shawnnkoski/-2f720bdde87f",
        "document": "It’s week 12 of my Flatiron experience and the end of the program is quickly approaching. Soon I’ll be working on my mod 5 project and shortly afterwards will begin my job search. With this in mind I can’t help but to wonder what my potential job situations will be, and how I will best be able to use what I have learned during this program during the next phase of my life.\n\nThis program has taught me more than just how to code in Ruby and Javascript; it has given me valuable insight about how to understand the logic and processes of coding. Regardless of what language I will be using in the future this program has taught me to think like a developer and I have faith I will be able to learn and understand most programming languages if given enough time. With that in mind I decided to look into some less well known programming languages and what I found was… surprising… or inspiring… or maybe just terrifying. I’m really not sure yet.\n\nWhat I stumbled on were esoteric programming languages. These languages have been developed to test boundaries of programming language design. Many of these languages are considered Turing tar-pits, a term used by Alan Perlis in his 1982 book the Epigrams on Programming.\n\nBrainfuck is an extremely minimalist language created by Urban Müller in 1993. It has just 8 commands and an instruction pointer. The first Brainfuck compiler was released in September 1993 on Aminet, an archive for Amiga computer related software and files. The readme included the question “Who can program anything useful with it? :)”.\n\nThe only commands Brainfuck accepts are ><+-.,[] with these eight characters you can move the pointer, add or decrease one byte at a time, output the data at the pointer, accept one byte of input, and tell the pointer to jump forward or back(a loop!).\n\nBefunge was created in 1993 for the Amiga computer by Chris Pressey. He created it in an attempt to make a language that was as hard as possible to compile. The most notable characteristic of Befuge is that instead of the language being read left to right, top to bottom it is written in a 2d grid with commands telling the system which direction to read the code next.\n\nHello World! In the Befunge the <, >, and v tell the compiler which way to read the program next. the letters are placed on to the stack in the order they are read and then popped of the stack in LIFO order by the ‘,’ the numbers represent the ascii code for a space (4 * 8 = 32) and a linefeed (2 * 5 = 10). The @ ends the program.\n\nThis might be the most impossible to comprehend language I came across. It was created by Gregor Richards and is a loose combination of the Brainfuck and PATH programming languages. (PATH is a language that was created by combining Brainfuck with a 2d grid system like Befunge). 2L or the Two Language uses only two symbols * and +. This one was a bit to complex for me to pretend like I know whats going on, but I thought it was a good example of insane these esoteric languages can get.\n\nThese super “simple” languages aren’t the only type of esoteric languages you can find. there is also a large collection of “absurdist” esoteric languages. These languages tend to be designed to be readable, though probably not immediately understandable. One of my favorite of the absurdist languages that I found is Homespring.\n\nHomespring was created in 2003 by Jefferey M. Binder. the program takes the form of “a network of rivers; the data are represented by salmon that swim upstream to spawn and then back out to the ocean.” Algorithms are represented by features that alter the behavior of the fish.\n\nCherryBlossom is another absurdist language, this time using haikus created by specific keywords to input commands. It was created in 2010 by Vivin Paliath. It uses the same structure of Brainfuck, but replaces the symbols with keywords and forces the programmer to write in haiku format.\n\nremembering you,\n\ndreaming of your lovely smile,\n\nwhen will you come here? I can remember\n\nmy happy dreams of summer\n\nit was beautiful flying doves, sunrays\n\nbeauty flying in sunshine\n\nrain in the valley. snow falls in moonlight,\n\nreturns to the mountainside.\n\nlovely, beautiful. the fragrant flowers\n\nand the pretty butterflies\n\nspring by singing creek. sunrays and sunshine,\n\nthe butterflies and flowers\n\nloving the new spring. the pretty flowers\n\nare dreaming of a summer\n\nwith the smiling sun. music from heaven,\n\nis melodious and sweet,\n\ndreamy and happy. the river is cold\n\nand misty in the moonlight,\n\nin the autumn chill."
    },
    {
        "link": "https://pointersgonewild.com/2022/05/23/minimalism-in-programming-language-design",
        "document": "Four years ago, I wrote a blog post titled Minimalism in Programming, in which I tried to formulate an argument as to why it's usually a good idea to try to minimize complexity in your programming projects. Today, I want to write about something I've been thinking about for a long time, which is the idea that we also ought to take a more intentionally minimalistic philosophy when designing programming languages.\n\nDesigning a programming language to be intentionally minimalistic is an idea that's highly underrated in my opinion. Most modern programming languages adopt much more of a maximalist design approach. Rapidly adding new features is seen as a competitive edge over other programming languages. The general thinking seems to be that if your language doesn't have feature X, then people will choose to use another language, or that adding more features is an easy way to show progress. This line of thinking is simplistic, and disregards many other key aspects that are necessary for a programming language to succeed and thrive, such as learnability, stability, tool support and performance.\n\nI'd like to make the argument that intentionally designing a programming languages to have fewer features, and to change less rapidly over time, is in itself a powerful feature. When a programming language changes often, it necessarily causes breakage and churn. Tools become out of date, codebases need to be updated, libraries become broken, but it causes churn on the human side too.\n\nI first started programming in C++ around 1998. I haven't really touched the language in a few years, and I have to say, I feel kind of lost. So many new features have been added that it's a different language now. Last year, I wanted to use C++20 modules in a new project, only to find that support in G++ and Clang was so incomplete that modules were just not a viable feature. My general impression at the time was that there aren't enough people working on C++ compilers to keep said compilers up to date. The language has become so complex, and so many new features have been added, that compiler developers are kind of burned out. It seems to me that slowly but surely, C++ is crumbling under its own weight.\n\nSomething that many people forget, is that for a language to succeed, there has to be good tool support. If the language and its feature set keeps changing, then tools need to be updated constantly. One of the many problems with C++ is that its grammar is very hard to parse. That was already the case back in 1998. If you add on top of that the problem that the grammar changes to become even more complex every year or two, what do you think the impact of that will be? The people maintaining C++ tools are going to want to go do something else with their lives, and so will the users of those tools.\n\nMore recently, colleagues and I have decided to port a C codebase to Rust. I'm generally pleased with the core feature set of Rust and I feel that in many ways it's a great improvement over C and C++. However, one of the main weaknesses of Rust, in my opinion, is its high complexity. Both at the syntactic and semantic level, Rust is a very complex language. The syntax can get very verbose, and there's a lot to know, a lot of rules and unintuitive subtleties about what you can and can't do where. The learning curve is steep and the cognitive load is high.\n\nLast week, I was pair programming with a colleague when he said \"I feel like the Rust compiler is always telling me that I'm too stupid\". That remark surprised me, because I'd had the same thought. Somehow Rust feels unergonomic, and the high complexity of the language surely contributes to that feeling that the language is a bit user-hostile. It breaks your intuition, and it constantly feels like the compiler is telling you that you're writing code wrong. Two days after my colleague made that remark, I saw a post appear on Hacker News titled Rust: A Critical Retrospective which echoed similar feelings about Rust's complexity.\n\nIn a lot of ways, I feel like designing a language to be minimalistic, to have fewer concepts, and to choose primitives that combine well together, is a good way to make the language easier to learn. If the programming language has fewer concepts, there's less to learn, and your level of proficiency will increase faster. Code written in a more minimalistic language may also be easier to read. If we think about C++ code, we have a situation where the language has so many redundant features that a typical workplace will mandate that code be written in a subset of C++, with some language features being explicitly banned. That can mean that people writing C++ code at different workplaces will have a hard time reading each other's code because foreign C++ code will be written in a different dialect.\n\nIn some ways, I feel like intentionally minimizing complexity and keeping the feature set small is a way of better respecting programmers. It means we respect that programmers are people with potentially busy lives and many things to do, and that they probably don't have time to read hundreds of pages of documentation to learn our language. Programming languages are user interfaces, and as such, they should obey the principle of least surprise. Minimizing complexity is also a way to reduce cognitive load and respect human limitations. Human beings are amazingly capable creatures, but we're also basically just clever monkeys that can talk. We can only keep a few items in our working memory, we can only account for so many design constraints, and we can only focus for so long. A well-designed programming language ought to help us succeed despite our human limitations.\n\nAt the end of the day, I think that a language's complexity and how intuitive it feels is going to affect its ability to attract and retain new users. In my opinion, the focus on reducing friction contributed greatly to Python's initial success and rapid increase in popularity. I think it's also fair to say that many people were frustrated when the complexity of the Python ecosystem increased, for example, during the switch from Python 2 to 3, or when the redundant walrus operator was introduced.\n\nSo far, I've made multiple references to minimalism and I've also briefly mentioned the principle of least surprise. I've hinted that minimalism also means having a smaller feature set and less concepts to learn. Minimalism doesn't just mean a smaller feature set though. It also means carefully choosing features that combine together seamlessly. If we design a language with a large feature set, there's a combinatorial explosion in how these different features could interact, which means we're more likely to end up with situations where some language features interact together poorly.\n\nImperative programming languages typically make a grammatical distinction between statements and expression. Functional languages instead tend to be structured in a way that everything inside a function body is an expression. The latter is more minimalistic, and also imposes less constraints on the programmer. Some languages impose a distinction between code that can be run at compile time vs code that can be run at program execution time. This distinction often increases the complexity of the language as there tends to be a duplication of language features and fairly arbitrary restrictions as to what code the compiler is able to run at compilation time.\n\nIn terms of minimizing surprise, we want to avoid introducing strange corner cases that only show up in some circumstances. Another important pitfall to avoid is introducing hidden behaviors that the programmer may not expect. An example of this would be the equality operator in JavaScript, which actually includes an implicit conversion to the string type, meaning that evaluates to true. Because of this undesirable hidden behavior, JS actually has a separate strict equality operator which doesn't perform the hidden string conversion. This suggests to me that JS should only ever have had a strict equality operator, and that if you want to convert the values you're comparing to strings before performing the equality comparison, you should just have to explicitly spell that out. It should not be the default behavior.\n\nLanguage design is hard because the space of possible programming languages is infinite, and so compromises have to be made. It's hard to provide hard numbers to quantify what makes one design better than another. Some of the things that can be quantified to some degree are the complexity of the implementation of a language and also the way that a particular language implementation performs.\n\nMy PhD thesis involved the implementation of a JIT compiler for JavaScript ES5. As such, I got to become intimately familiar with the semantics of the language and everything that has to go on behind the scenes to make JavaScript code run fast. At times, that was a frustrating experience. I've become convinced that a lot of the complexity and the hidden behaviors in JS and in many other languages are essentially bad for everyone.\n\nUnnecessary complexity in a language is bad for those learning the language, because it makes the language less intuitive and harder to learn. It's bad for the programmers working with the language everyday, because it increases their cognitive load and makes it harder to communicate about code. It's bad for language implementers and tool maintainers, because it makes their job harder, but at the end of the day, it's also bad for end users, because it leads to software with more bugs and poorer performance.\n\nTo give you an example of unnecessary implementation complexity, many object-oriented languages have this idea, borrowed from Smalltalk, that everything should be an object, including booleans and integer values. At the same time, languages implementation for these languages have to do a lot of work behind the scenes to try and represent integers efficiently (as machine integers) while presenting an interface to the user that resembles that of an object. However, the abstraction presented to the user for an integer object is typically not really the same as that of a normal OOP object, it's a leaky abstraction, because being able to redefine integer values makes no sense, because integer values have to be singletons, and because being able to store properties/attributes on integers is both dumb and terrible for performance and so typically isn't allowed.\n\nUltimately, integers are not objects in the object oriented sense. They're a distinct type of atomic value with a special meaning, and that's okay. The mistaken idea that \"everything should be an object\" doesn't actually simplify anything in practice. We're lying to ourselves, and in doing so, we actually makes the life of both language implementers and programmers more complicated.\n\nThis blog post has turned into more of a rant than I expected it to be. It's easy to critique the status quo, but I'll also try to conclude with some actionable advice. My first piece of advice for aspiring language designers is that you should start small. Your language is a user interface, and an API which people use to interface with machines. The smaller the API surface, the less you risk introducing accidental complexity and subtle design mistakes.\n\nMy second piece of advice is that if you can, you should try to keep your language small. Limiting yourself to a smaller feature set likely means you will want to choose features that don't overlap and that provide the most expressiveness, the most value to programmers. If you do want to grow your language, do it slowly. Take some time to write code in your language and work through the potential implications of the design changes that you are making.\n\nIt's easy to add new features later on, but if you add new features and people begin using them, it's going to be hard or even impossible to take these features back, so choose wisely. Remember that you don't have to please everyone and say yes to every feature request. No language or tool can possibly satisfy every use case, and in my opinion, trying to do so is a mistake.\n\nLastly, remember that language design is an art. It's a delicate balance of many different constraints, just like user interface design. Brainfuck is a language that is very small and has very few concepts, but nobody would call it expressive or elegant. Lisp is regarded by many as one of the most beautiful and elegant languages in existence, but my PhD advisor, a Scheme fanatic, had the habit of writing code with single-letter variable names and very few comments. An elegant language doesn't automatically make for elegant code, but you can encourage good coding practices if you lead by example."
    },
    {
        "link": "https://quora.com/What-are-several-examples-of-minimalistic-programming-languages",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://scorpiosoftware.net/2023/08/18/writing-your-own-programming-language",
        "document": "Ever since I realized BASIC wasn’t the only living programming language, I thought about writing my own. Who wouldn’t? If you’re a developer, surely this idea popped into your mind at some point. No matter how much you love a particular programming language, you always have some ideas for improvement or even removal of annoying features.\n\nThe post assumes you have some background in compilers, and understand concepts like tokenizing (scanning), parsing, and Abstract Syntax Trees (ASTs)\n\nObviously, writing a programming language is not for the faint of heart. Even before you set out to implement your language, you have to design it first. Or maybe you have some fundamental ideas that would make your language unique, and you may decide to flesh out the details while you’re implementing it.\n\nA new programming language does not have to be “general-purpose” – that is, it could be a “domain specific language” (DSL), which means it’s best suited for certain domain(s) or tasks. This makes your life (usually) at least somewhat easier; in addition, you’ll be unlikely to compete with the gazillion general-purpose languages out there. Still, a general-purpose language might be your goal.\n\nDesigning a programming language is a big topic, well outside the scope of this post. I’ll focus on the implementation details, so to speak. There are other considerations for a programming language beyond the language itself – its accompanying standard library, tooling (e.g., some IDE or at least syntax highlighting), debugging, testing, and few more. One decision is whether to make your language compiled or interpreted. This decision may not affect some aspects of the implementation, but it will definitely affect the language’s back-end. You can even support both interpretation and compilation for maximum flexibility.\n\nI played around with the idea of creating a programming language for many years, never really getting very far beyond a basic parser and a minimal interpreter. Lately, I’ve read more about Pratt Parsing, that sparked my interest again. Pratt Parsing is one of many techniques for parsing expressions, something like “a+2*b”, and doing that correctly (parenthesis, operator precedence and associativity). Pratt parsing is really elegant, much more so than other techniques, and it’s also more flexible, supporting (indirectly) ternary operations and other unusual constructs. Once you have an expression parser, the rest of the parser is fairly easy to implement (relatively speaking) using the recursive-descent approach which is well suited for hand-crafted parsers.\n\nRobert Nystrom gives a nice introduction to Pratt Parsing and an elegant idea for implementing it. His implementation is in Java, but there is a link to a C# implementation and even one in Rust. My go-to language is C++ (still), so you know where this is going. I’ve implemented a Pratt parser based on Robert’s ideas, and it turned out very well.\n\nI’ve also been interested in visualization (a term which has way too much stuffed into it), but I thought I’d start small. A popular teaching language in the 80s was LOGO. Although it was treated as a “toy language”, it was a full-blown language, mostly resembling LISP internally.\n\nHowever, LOGO became famous because of the “Turtle Graphics” built-in support that was provided, which allowed drawing with an imaginary turtle (you could even ask LOGO to show it) that would follow your commands like moving forward, backwards, rotating, lifting the pen and putting it back down. Why not create a fun version of Turtle Graphics with ideas from LOGO?\n\nHere is an example from LOGO to draw a symmetric hexagon:\n\nYou can probably guess what is going on here. “FD” is “forward” and “RT” is “right”, although it could be mistaken for “rotate”. LOGO supported functions as well, so you could create complex shapes by reusing functions.\n\nMy language, called “Logo2” for a lack of originality at this time, tries to capture that fun drawing, but put the syntax more inline with the C-family of functions, which I like more. The above hexagon is written with Logo2 like so:\n\nIndentation is not significant, so it all could be placed on the same line. You can also define functions and execute them:\n\nI also added support for colors, with the pencolor(r,g,b) function, something I don’t recall LOGO having in the 80s.\n\nThere are 3 main projects in the solution (a fourth project in the works to create a simple IDE for easier experimentation):\n• Logo2Core – contains the tokenizer, parser, and interpreter.\n• Logo2Runtime – contains the runtime support for turtle graphics, currently using GDI+.\n• Logo2 – is a simple REPL, that can parse and execute single line statements. If you provide a command line argument, it’s treated as file name to be parsed and executed. Anything not inside a function is executed directly (for now).\n\nThe tokenizer’s job (Tokenizer class) is to read text and turn it into a bunch of tokens. A token is a single unit of the language, like a number, keyword, identifier, operator, etc. To start tokenization, the Tokenize method can be invoked with the string to tokenize.\n\nThe Next() method returns the next token, whereas the Peek() method returns the next token without advancing the stream forward. This means the tokenizer is not doing all the work immediately, but only advanced to the next token when requested. The parser is the one “driving” the tokenizer.\n\nThe implementation of the tokenizer is not perfect, but it works well-enough. I didn’t want to use any existing tools like YACC (or BISON), for a couple reasons. For one, I don’t like generated code that I have little control colover. Second, I like to understand what I am writing. Writing a tokenizer is not rocket science, but it’s not trivial, either. And since one of my goals is to experiment, I need the freedom not available with generated code.\n\nThe parser is much more interesting than the tokenizer (by far). This is where the syntax of the language is fleshed out. Just like with tokenization, usage of tools like LEX (or FLEX) is inappropriate. In fact, most languages have their own hand-written parser. The parser accepts a string to parse (Parse method) or a filename (ParseFile method) and begins the parsing. It calls on the tokenizer when the next token is needed.\n\nThe Init method of the parser initializes the tokenizer with the specific tokens it should be able to recognize (like specific keywords and operators), and also initializes its own “parslets” (defined in the above mentioned article) to make Pratt Parsing work. I will not show here the Pratt Parsing part since there’s quite a bit of code there, but here is an example of parsing the “repeat” statement:\n\nParseExpression parses an expression to be used for the argument to repeat. Then ParseBlock is called to parse a curly-brace surrounded block of code. Finally, the result is an AST node representing a “repeat” statement is created, initialized, and returned to the caller.\n\nThe m_LoopCount variable is incremented when entering loop parsing and decremented afterwards. This is done so that parsing the keywords break and continue can check if there is any enclosing loop for these keywords to make sense.\n\nParseBlock starts by making sure there is an open curly brace. Then it creates a symbol table and pushes it to be the “current” as there is a new scope within the block. The parameter to ParseBlock is used when parsing a function body, where these “args” are the parameters to the function. If this is the case, they are added to the symbol table as local variables.\n\nThe main work is to call ParseStatement as many times as needed until a close brace is encountered. The block is a vector of statements being filled up. Finally, the symbol table is popped and the AST node is returned.\n\nParseStatement is a big switch that calls the appropriate specific parsing method based on the first token encountered. Here is an excerpt:\n\nIf a statement is not recognized, an expression parsing is attempted. This allows using Logo2 as a simple calculator, for example. ParseStatement is where the support for more statements is added based on an initial token.\n\nOnce an AST is built by the parser, the next step is to execute the AST by some interpreter. In a more complex language (maybe once it grows some more), some semantic analysis may be appropriate, which is about looking at the usage of the language beyond the syntax. For now, we’ll just interpret what we have, and if any error is encountered it’s going to be a runtime error. Some parsing errors can be caught without semantic analysis, but some cannot.\n\nThe Interpreter class provides the runtime behavior, by “executing” the AST. It receives the root of the AST tree constructed by the parser by implementing the well-known Visitor design pattern, whose purpose here is to decouple between the AST node types and the way they are handled by the interpreter. Alternatively, it would be possible to add a virtual “Execute” or “Eval” method to AST nodes, so the nodes can “evaluate” themselves, but that creates coupling, and goes against the single-responsibility principle (SRP) that states that a class should have one and only one job. Using the visitor pattern also makes it easier to add semantic analysis later without modifying the AST node types.\n\nThe gist of the visitor pattern is to have an “Accept” method in the AST nodes that calls back to whoever (the visitor) with the current node details. For example, here it is for a binary operator:\n\nThis same idea is repeated for all concrete AST nodes. The Visitor type is abstract, implemented by the Interpreter class having methods like: VisitBinary, VisitRepeat, etc.\n\nEach one of these “Visit” method’s purpose is to “execute” (or evaluate) that node. Here is an excerpt for the binary expression visiting:\n\nHere it is for “repeat”:\n\nYou should get the idea at this point. (Eval is just a simple wrapper that calls Accept with the provided node).\n\nThe Value type used with the above code (the one returned from Accept methods is the way to represent “values” in Logo2. Logo2 is a dynamically typed language (at least for now), so variables can hold any one of a listed of supported types, encapsulated in Value. You can think of that as a C-style union. Specifically, it wraps a std::variant<> C++17 type that currently supports the following: 64-bit integer, 64-bit floating point (double), bool, string (std::string), and null (representing no value). The list of possibilities will increase, allowing user-defined types as well.\n\nThe Logo2Runtime project contains the support for managing turtles, and displaying their “drawings”. The Turtle class is a graphics-free type to manage the state of the turtle – its position and heading, but also a list of “command” indicating operations the turtle has been instructed to do, such as drawing a line, changing color, or changing width of drawing. This list is necessary whenever a window’s output needs to be refreshed.\n\nThe Window class servers as a wrapper for an HWND, that also has the “power” to draw a set of turtle commands. Here is its DrawTurtle method:\n\nEach command does the right thing:\n\nThe graphical objects are GDI+ objects provided by the Windows API. Of course, it would be possible to switch to a different API. I chose GDI+ for its flexibility and 2D capabilities.\n\nThe Runtime class ties a turtle and a window together. It holds on to a (single) Turtle object and single Window object. In the future, this is going to be more dynamic, so any number of windows and turtles can be created, even more than one turtle in the same window.\n\nA simple REPL is implemented in the Logo2 project. It’s not trivial, as there is a user interface that must be kept alive, meaning messages have to be pumped. This means using functions like gets_s is not good enough, as they block the calling thread. Assuming the UI is on the same thread, this will cause the UI to become non-responsive. For now, the same thread is used, so that no special synchronization is required. The downside is that a custom input “loop” has to be written, and currently it’s very simple, and only supports the BACKSPACE key for typing error correction.\n\nThe first step is to get the input, key by key. If there is no key available, messages are pumped. A WM_QUIT message indicates it’s time to exit. Not very elegant, but here goes:\n\nOnce we have a line of input, it’s time to parse and (if no errors occur), execute:\n\nSome parser errors are accumulated in a vector, some throw an exception (errors where it would be difficult for the parser to recover confidently). At runtime, errors could occur as well, such as the wrong types being used with certain operations.\n\nWriting a language can be lots of fun. You can invent your “dream” language. For me, the Logo2 experiment is ongoing. I’m planning to build a simple IDE, to extend the language to support user-defined types, lambdas (with closures), and much more. Your ideas are welcome as well!\n\nThe project is at zodiacon/Logo2 (github.com)"
    },
    {
        "link": "https://daily.dev/blog/create-programming-language-design-principles",
        "document": "Creating your own programming language is a fascinating journey that involves careful consideration of several key principles to ensure it meets the needs of its users effectively. Whether you're designing a language to tackle specific types of projects or aiming for general use, understanding the core elements is crucial. Here's a quick overview:\n• Purpose: Identify the main problem your language aims to solve and its target audience.\n• Readability and Expressibility: Ensure the language is easy to understand and expressive enough to allow programmers to convey ideas clearly.\n• Efficiency and Scalability: Optimize for performance and ensure it can handle large-scale projects.\n• Human-Centric Design: Focus on making the programming experience enjoyable and intuitive.\n• Extensibility: Allow for growth and community contributions to keep the language evolving.\n\nThis guide will dive deeper into these principles, offering insights into the basics of programming languages, the role of compilers, and practical steps to take when creating your own language.\n\nThink of a programming language as a way to chat with computers. It's how developers tell a computer what to do. The computer then turns this into actions it can understand and carry out.\n\nHere are some basics:\n• Syntax - These are the rules on how to write your code. For example, some languages want you to put a semicolon (;) at the end of each instruction.\n• Semantics - This is about what the bits of your code actually do. It's the meaning behind the commands.\n• Variables - These are like boxes where you can store information. You can put things in, take things out, or check what's inside.\n• Data types - This tells you what kind of data you can put in your variables, like numbers or text.\n• Expressions and operators - These are the tools to do math or compare things in your code.\n• Control flow statements - These are instructions that decide what happens next, like making a choice or repeating actions.\n• Comments - These are notes for people reading the code. The computer ignores them, but they're super helpful for humans.\n\nOverall, programming languages make it possible for humans to write instructions that computers can follow. The way a language is designed affects how easy it is to use.\n\nCompilers are like translators. They take the code you write in a human-friendly way and turn it into something the computer can understand and do.\n\nHere's what they do:\n• They change your code into a more basic form that the computer can work with directly.\n• Before translating, they check your code to make sure there are no mistakes. This helps find problems early.\n• They make the code run faster and more efficiently.\n• Some languages that need compilers are C, C++, and Rust. Other languages, like JavaScript and Python, work differently and don't always need them.\n• The simpler your programming language is, the easier it is to make a compiler for it.\n\nSo, compilers help turn your ideas into actions a computer can perform. When you create your own programming language, thinking about how to make a good compiler is important.\n\nWhen you set out to create your own programming language, it's really important to first think about what you want it to do and who will use it. Ask yourself what problems it will solve and how it will make coding easier or better for people.\n• Think about what you want your language to be great at. Is it for all kinds of programming, or just for certain areas like making websites or doing science stuff?\n• Look at what's annoying or hard in other languages and try to do it better in yours. This could be making errors easier to find, working on many different devices, or making programs run faster.\n• Decide where your language can run. Will it work on computers, phones, or web browsers?\n• Keep in mind who will use your language. Is it for pros, students, or just for fun? Make sure it fits their needs.\n\nKnowing what you want your language to do helps make sure every part of it works towards that goal.\n\nMaking code easy to read and write is super important. You want people to easily get what the code does and be able to put their ideas into code without a headache.\n• Use familiar ways of writing code so it feels natural.\n• Name things clearly so everyone knows what they do.\n• Use spaces and lines to make code neat and easy to follow.\n• Let people add notes and explanations in their code.\n• Make it simple to use parts of code again or to use tools made by others.\n• Give clear errors that help find and fix problems.\n\nKeeping code clean and predictable makes it friendlier for everyone.\n\nYou want your language to not only run fast but also be able to handle big projects as they grow.\n• Choosing between a compiler or an interpreter can affect speed.\n• The way you organize data and solve problems can save memory and make things quicker.\n• Making your language good at doing many things at once or working across many computers helps it scale up.\n• Being strict about what kind of data can be used can catch mistakes early but might limit flexibility.\n• How your language deals with unused data can make coding easier.\n\nThinking about these things from the start is better than trying to fix them later.\n\nRemember, real people will use your language, so make it as easy as possible for them.\n• Use abstraction to keep things simple.\n• Provide tools for seeing how code works and finding bugs.\n• Make sure your language is forgiving when people make mistakes.\n\nFocusing on making coding a pleasant experience will make people want to use your language.\n\nAllowing your language to grow and improve over time is key.\n• Make it easy to add new features or tools.\n• Work well with other software.\n• Have a library of ready-to-use code for common tasks.\n• Let people modify your language without breaking it.\n\nBuilding a community around your language helps it get better and supports the people using it. Sharing ideas and working together makes everyone's experience better.\n\nWith clear goals, a focus on making coding easier, and support from a community, your language has a great chance of success.\n\nThe first thing you need to do is set up the rules for how code in your language should look. This is called the grammar. It includes:\n• What symbols and words can be used.\n• How to put those symbols together to make something the computer understands.\n• Rules for doing math and setting up conditions.\n• The way to write if statements and loops.\n\nTools like ANTLR can help with this. Your goal is to make these rules clear, so they're easy to follow and don't cause confusion. Look for guides on how to create programming language grammar for more help.\n\nOnce you have your rules set, you need to make a compiler. This is the tool that turns the code written in your language into something a computer can run. The main parts include:\n• Lexer - Reads the code and breaks it down into pieces.\n• Parser - Makes sure the code fits the grammar and organizes it in a tree structure.\n• Code generator - Turns the optimized code into machine code the computer can use.\n\nYou can find step-by-step guides on building a compiler. Using existing tools can make this easier. The main aim is to translate your language's code into machine code efficiently.\n• Try it with correct code to see if it works as expected.\n• Use wrong code to check if it finds errors.\n• Check how fast it runs and how much memory it uses.\n• Get feedback from people who try it.\n\nYou'll find bugs, but that's normal. Use the feedback to make your language better. Keep improving it based on what users say. Testing and updating are key to making a programming language that people like using.\n\nMaking your own programming language is a big project. It's all about thinking through how your language should work and making it easy for people to use. Keeping the people who will use your language in mind will help you create something that really helps them.\n\nHere are some key points to remember as you start this project:\n• Start with the basics. First, make a simple version of your language that works well with just the basic features. Try it out, see what people think, and then slowly add more to it.\n• Keep it simple. Always look for ways to make things easier for the people writing code. Using simple ideas to hide complicated stuff is very important.\n• Write good guides. Spend time on tutorials, how-tos, and examples. Making it easy for people to start using your language is crucial.\n• Share your work early. When you share what you're making, you get help and ideas from others. Working together often leads to better results.\n• Make it enjoyable to use. Think about small details like clear error messages, smart suggestions, and easy-to-use designs. These things make people trust and like your language more.\n• Plan for the future. Think about how your language can handle more work over time. Make sure it can do many things at once and work with other software easily. Adding new features should also be straightforward.\n\nCreating a programming language is a journey that will challenge and inspire you. The goal is to make a new tool that helps developers. See this as a chance to explore and be creative. And most importantly, enjoy the process!\n\nWhat are the principles of language design?\n\nWhen creating a programming language, think about these important ideas:\n• Simplicity: The language should be straightforward. This makes it easier to use and less likely to have mistakes.\n• Security: Having safety features like checking for errors can protect users.\n• Fast translation: A compiler can make your language work faster than an interpreter.\n• Efficient object code: Using smart ways to make the final computer-readable code run faster is good.\n• Readability: It's important that the code tells clearly what it does. Using names that make sense and organizing code well helps a lot.\n\nRemember, keeping things simple is often best.\n\nHow to design your own programming language?\n• Decide what you want your language to do and who it's for.\n• Create rules for how to write code in it.\n• Help users learn your language with guides.\n• Listen to user feedback to make your language better.\n\nStart with easy stuff and improve as you go.\n\nWhat are the principles of programming languages?\n• Having essential tools like if statements and loops.\n• Making sure code is easy to read and understand.\n• Being clear about what each part of the code does.\n\nThese ideas help make languages that are powerful yet easy to use.\n\nWhat is the design of a programming language?\n• Deciding what each part of the code means.\n• Picking the right types of data.\n• Choosing how to move through the code.\n• Figuring out how to deal with mistakes.\n• Making sure the code is easy to read.\n• Adding features to help with coding big projects.\n• Creating tools to help check and run code.\n\nThe goal is to make a language that lets people express their ideas clearly and works well.\n• How to Start Coding from Zero: Finding Your Coding Community\n• Gleam: The new programming language for building typesafe systems"
    },
    {
        "link": "https://afeinman.medium.com/design-principles-2a-1874c14975ab",
        "document": "In part 1 of this article, I explained how to design programming languages to help us feeble humans managing complexity. This isn’t a new thought:\n\n…so I thought I could just quote a bunch of inspirational sayings and be done. No, wait. Some of you asked for more details on the specific criteria I outlined.\n\nSo today, we got details. We got half the details; the other half will appear in an upcoming post. Clap for this one if you want to encourage me to finish it faster.\n\nEvery programming language possesses all of these qualities, in some measure.\n\nReadability measures how easy it is to, well, read a bit of code and figure out what it is doing. Ideally, a programmer can easily understand what code does simply by reading it; in practice, many times it’s necessary to step through the code while it’s running, using some inspectional debugging method like print statements, to really understand the behavior. The language itself can help or hurt this, as can the programmer. Obvious wins include clear keywords and conventions for understandable variable names.\n\nUnambiguous syntax helps, but is not essential; for example, in MATLAB, there’s usually no way to tell whether is an indexing expression, method, or a function call until the moment that the line is executed.\n\nThis type of ambiguity can be useful to hide implementation details from callers of a function—most people don’t need to know which operation is happening behind the scenes, and in fact becuse of MATLAB’s dispatching rules, it might be a function or method call at different times depending on the types of and . It improves readability by allowing the reader to operate at the level they want: that there is an FFT occurring, on this data.\n\nIn contrast, perl requires you to label all indexing with the resultant type of the indexed variable:\n\nWhile is, technically, a scalar value, many programmers get confused because they consider to be the name of the variable — and indeed it is, because could be a different variable. This impairs the readability of perl code; the reader must pick out (or an even more complex indexing operation) and mentally connect it with previous uses of .\n\nI love perl, but readability is not one of its strong suits; it’s even been called a “write-only language”.\n\nIt’s tempting to make things as simple as possible, in the hopes that that will make them more readable. The MATLAB example given above is an example of that.\n\nHowever, this can very easily be taken to far. With a little effort, it can be taken WAY too far. Malebolge is…well, it was created to flaunt this principle. Witness the reference implementation of “HELLO WORLD!”:\n\nYou got that, right?\n\nDespite what it looks like, this really is a programming language — v7 of the Inform language, built for writing text-based games. This snippet is an example of room creation, complete with a custom rule (“instead of…”) which prevents the player from taking anything in the room.\n\nBut you got all that, because Inform excels at readability.\n\nExpressability is the converse[1] of readability. It measures how easy it is to figure out what to type when you’ve got an idea in your head.\n\nInform7, by contrast with its excellent readability, has some issues here. A programmer might be tempted to write the above snippet like this:\n\nThis is valid English, but it isn’t valid Inform7 code. Worse, there’s no clear indication from within the language or IDE of the correct expression of the intended statement.\n\nI find Java to have good expressability: while there are usually a handful of ways to say something in Java, it has a high degree of structure and predictability which means you can almost tab-complete a full program if you’re using a smart editor like IntelliJ. Say I want to build that same room:\n\nLanguages with good expressability guide the programmer toward a solution that works. If it feels awkward, it’s often because you’re doing things The Wrong Way. This was my experience when learning MATLAB; my process looked like this for an embarrassingly long time:\n• I want to read numbers from this file and compute the Fourier transform.\n• Okay, I wrote a loop which , and figured out all the and calls. But I had to convert from strings to numbers, and looks kinda dorky.\n• Oh, wait, there’s a parameter which reads in the file as numbers.\n• Oh, there’s an function, and it takes arrays as input. Duh.\n• Oh, hey, if I use that, I can stick it on the GPU with one extra line of code.\n\nAnd what had been fifteen lines of code is suddenly one or two. That’s powerful, and power often fights with Expressability — because there is so much you can say with the language.\n\nSimplicity is alluring when it comes to Expressability: a simpler syntax seems like it should lead to increased ease of expression. But the winner for simplest syntax is probably LISP; there are only two and a half rules (some folks would omit the third rule):\n\nAnd indeed, given these, programmer can, at some level, understand precisely how to generate a new expression. In practice, however, this leads to confusion at the next level: you know how the expression will look, but are left at a loss figuring out what expression to write. It puts the burden of creative expression entirely on the programmer.\n\nLibraries are a great help here, allowing you to pull larger and larger patterns and stitch them together. Using LISP in a library-free environment is a fun exercise — LISP can be written in LISP, after all — but it scores poorly on Summarizability, and is a lot of work.\n\nThis one’s simple to explain, but devilish to accomplish. Ook! is a canonical bad example:\n\nThat’s “Hello World” again. Yyyyeah. I don’t want to have to write Ook! code.\n\nLess ridiculously, assembler is perhaps equally verbose, without being perversely so: it’s simply written at the most detailed level.\n\nIn contrast, Golfscript is written for concision at all costs. With it you can win at Code Golf, for exampel, finding all the primes below a certain number in only twenty characters:\n\nConcision is usually in tension with both Readability and Expressability.\n\nRegularity! It’s not just from fiber any more!\n\nRegularity means that parts of the language are recurring and uninteresting: they’re regular, they recur in roughly the same way, over and over. This is a good thing. Regularity lets the mind separate what’s important from the frame around it.\n\nOne way to achieve this is to ensure that parts of the language that look the same also work the same. The inverse is also important: things that look different should work differently. These are the two halves of an important maxim in user experience.\n\nJavascript, frustratingly and famously, violates this with its confusing equality operators:\n\nHere, looks the same but works quite differently[2] depending on its operands. As a result, the practice of the language has evolved such that is recommended or required instead, because it works the way most people expect equality to work.\n\nThis is because something that should be Regular, and therefore ignorable, became a “gotcha” that you had to think about every time you encountered it. When things work confusingly differently based on context, the programmer has to treat each one as a different unit, and reason about them individually. In contrast, if you can trust that section to Do The Right Thing, it fades into the background.\n\nA counter-example would be Java, or other similiarly strongly typed languages. This is a mistake that won’t ship in Java code:\n\nbecause is an assignment that returns an integer, and the construct expects a boolean value. Your editor will flag it immediately; at worst, you’ll get an error at compile-time. So you can be confident when you look at an error-free condition that you’re looking at the right operator.\n\nRegularity enhances both Readability and Expressibility, sometimes at the cost of Concision; but the nice thing about verbose regularity is that it’s often easy to teach a computer to fill it in for you. Good Regularity also improves Predictability, because it provides context that both the programmer and the computer can agree on.\n\nAnd that’s it for this installment. Hope you learned something, or at least gave yourself a neck cramp nodding in agreement.\n\nIf you enjoyed this, please follow me for more programming insights, random topics, and/or just to artificially inflate my follower numbers."
    }
]