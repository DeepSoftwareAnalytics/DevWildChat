[
    {
        "link": "https://react.dev/learn/managing-state",
        "document": "Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset. Read More Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs! For example, this form has a redundant state variable:\n\nThis might seem like a small change, but many bugs in React apps are fixed this way. Read Choosing the State Structure to learn how to design the state shape to avoid bugs. Read More Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.\n\nRead Sharing State Between Components to learn how to lift state up and keep components in sync. Read More When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:\n\nReact lets you override the default behavior, and force a component to reset its state by passing it a different , like . This tells React that if the recipient is different, it should be considered a different component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.\n\nRead Preserving and Resetting State to learn the lifetime of state and how to control it. Read More Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!\n\nRead Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function. Read More Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props. Here, the component determines its heading level by “asking” the closest for its level. Each tracks its own level by asking the parent and adding one to it. Every provides information to all components below it without passing props—it does that through context.\n\nRead Passing Data Deeply with Context to learn about using context as an alternative to passing props. Read More Scaling up with reducer and context Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state."
    },
    {
        "link": "https://react.dev/learn/reacting-to-input-with-state",
        "document": "React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.\n• How to enumerate the different visual states your component can be in\n• How to trigger the changes between the different visual states from code When you design UI interactions, you probably think about how the UI changes in response to user actions. Consider a form that lets the user submit an answer:\n• When you type something into the form, the “Submit” button becomes enabled.\n• When you press “Submit”, both the form and the button become disabled, and a spinner appears.\n• If the network request succeeds, the form gets hidden, and the “Thank you” message appears.\n• If the network request fails, an error message appears, and the form becomes enabled again. In imperative programming, the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here’s another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.\n\nThey don’t know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It’s called imperative because you have to “command” each element, from the spinner to the button, telling the computer how to update the UI. In this example of imperative UI programming, the form is built without React. It only uses the browser DOM:\n\nManipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven’t introduced a bug (for example, forgetting to show or hide something). React was built to solve this problem. In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, you declare what you want to show, and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It’s the driver’s job to get you there, and they might even know some shortcuts you haven’t considered!\n\nYou’ve seen how to implement a form imperatively above. To better understand how to think in React, you’ll walk through reimplementing this UI in React below:\n• Determine what triggers those state changes\n• Represent the state in memory using\n• Connect the event handlers to set the state In computer science, you may hear about a “state machine” being in one of several “states”. If you work with a designer, you may have seen mockups for different “visual states”. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration. First, you need to visualize all the different “states” of the UI the user might see:\n• Success: “Thank you” message is shown instead of a form.\n• Error: Same as Typing state, but with an extra error message. Just like a designer, you’ll want to “mock up” or create “mocks” for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called with a default value of :\n\nIn both cases, you must set state variables to update the UI. For the form you’re developing, you will need to change state in response to a few different inputs:\n• Changing the text input (human) should switch it from the Empty state to the Typing state or back, depending on whether the text box is empty or not.\n• Clicking the Submit button (human) should switch it to the Submitting state.\n• Successful network response (computer) should switch it to the Success state.\n• Failed network response (computer) should switch it to the Error state with the matching error message. To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation. Step 3: Represent the state in memory with Next you’ll need to represent the visual states of your component in memory with . Simplicity is key: each piece of state is a “moving piece”, and you want as few “moving pieces” as possible. More complexity leads to more bugs! Start with the state that absolutely must be there. For example, you’ll need to store the for the input, and the (if it exists) to store the last error: Then, you’ll need a state variable representing which one of the visual states that you want to display. There’s usually more than a single way to represent that in memory, so you’ll need to experiment with it. If you struggle to think of the best way immediately, start by adding enough state that you’re definitely sure that all the possible visual states are covered: Your first idea likely won’t be the best, but that’s ok—refactoring state is a part of the process! You want to avoid duplication in the state content so you’re only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to prevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see. (For example, you never want to show an error message and disable the input at the same time, or the user won’t be able to correct the error!) Here are some questions you can ask about your state variables:\n• Does this state cause a paradox? For example, and can’t both be . A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the “impossible” state, you can combine these into a that must be one of three values: , , or .\n• Is the same information available in another state variable already? Another paradox: and can’t be at the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can remove and instead check .\n• Can you get the same information from the inverse of another state variable? is not needed because you can check instead. After this clean-up, you’re left with 3 (down from 7!) essential state variables: You know they are essential, because you can’t remove any of them without breaking the functionality. These three variables are a good enough representation of this form’s state. However, there are still some intermediate states that don’t fully make sense. For example, a non-null doesn’t make sense when is . To model the state more precisely, you can extract it into a reducer. Reducers let you unify multiple state variables into a single object and consolidate all the related logic! Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:"
    },
    {
        "link": "https://legacy.reactjs.org/docs/forms.html",
        "document": "HTML form elements work a bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:\n\nThis form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called “controlled components”.\n\nIn HTML, form elements such as , , and typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with .\n\nWe can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.\n\nFor example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:\n\nTry it on CodePen\n\nSince the attribute is set on our form element, the displayed value will always be , making the React state the source of truth. Since runs on every keystroke to update the React state, the displayed value will update as the user types.\n\nWith a controlled component, the input’s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.\n\nIn HTML, a element defines its text by its children:\n\nIn React, a uses a attribute instead. This way, a form using a can be written very similarly to a form that uses a single-line input:\n\nNotice that is initialized in the constructor, so that the text area starts off with some text in it.\n\nIn HTML, creates a drop-down list. For example, this HTML creates a drop-down list of flavors:\n\nNote that the Coconut option is initially selected, because of the attribute. React, instead of using this attribute, uses a attribute on the root tag. This is more convenient in a controlled component because you only need to update it in one place. For example:\n\nTry it on CodePen\n\nOverall, this makes it so that , , and all work very similarly - they all accept a attribute that you can use to implement a controlled component.\n\nIn HTML, an lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the File API.\n\nBecause its value is read-only, it is an uncontrolled component in React. It is discussed together with other uncontrolled components later in the documentation.\n\nWhen you need to handle multiple controlled elements, you can add a attribute to each element and let the handler function choose what to do based on the value of .\n\nTry it on CodePen\n\nNote how we used the ES6 computed property name syntax to update the state key corresponding to the given input name:\n\nIt is equivalent to this ES5 code:\n\nAlso, since automatically merges a partial state into the current state, we only needed to call it with the changed parts.\n\nSpecifying the prop on a controlled component prevents the user from changing the input unless you desire so. If you’ve specified a but the input is still editable, you may have accidentally set to or .\n\nThe following code demonstrates this. (The input is locked at first but becomes editable after a short delay.)\n\nIt can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out uncontrolled components, an alternative technique for implementing input forms.\n\nIf you’re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, Formik is one of the popular choices. However, it is built on the same principles of controlled components and managing state — so don’t neglect to learn them."
    },
    {
        "link": "https://propelauth.com/post/state-management-in-react",
        "document": "If you are writing a React application, you are almost certainly managing state somewhere. State is surprisingly hard to define, but easier to understand with examples:\n• An input box has state - which is often just the value in the input box.\n• A form has state - which is usually all the values in the form.\n• An application has state - which is all the values that it takes to render/operate the application.\n\nThose are more conceptual examples of state. React components themselves will have their own state and will often pass state to their child components via .\n\nIn this post, we’ll look at the common ways to manage client state - meaning state that is managine on the frontend. We’ll look at when you should use the different patterns as well as some example code snippets. We’ll save server/async state for a followup post.\n\nFor state management, we need a place to start, and one of the simplest primitives is useState.\n\nis a React hook that manages a single value. It’ll return both the value itself, and a function you can call to update the value.\n\ntends to shine in simple cases, where the state is used in at most a few components. Take this Menu example (from Mantine):\n\nYou click the button, is set to true, the menu opens. It’s about as easy as it gets, but let’s look at when it starts to get a bit more complicated.\n\nNot to diss booleans, but your application will almost certainly have more complicated interactions that require more complicated types.\n\nLet’s take a big jump in complexity and imagine we are working at Redfin and we are building all the filters for searching for a house:\n\nUltimately, this entire form is designed to produce a query that will be sent to our backend. Here’s a simplified example of what our query object might look like:\n\nNow we need to create different components that manage each of these fields. One naive approach would be to use :\n\nEach of our components can pull out the parts of that are relevant for them, and they can make any changes they want to with .\n\nThis isn’t terrible, but it does feel odd to pass the full query to each component when they don’t need it (note that we’re going to ignore any performance implications of this, because that would make this post a lot longer).\n\nEven worse, debugging this can be a pain. If we were tracking down a bug that someone reported like:\n\nIt’s hard to know the full scope of where we need to check. We actually need to check every call to as any of them could accidentally (or intentionally in the case of the ) modify the zip code.\n\nSo we have a brilliant idea: let’s make dedicated functions for each concrete state change. It could look like this:\n\nThis has some nice advantages - it’s way easier to audit all changes made to as they should all be contained in functions defined in . The component also only ever needs to be exposed to and , instead of needing to know the full query and how to update it.\n\nHowever, there are two disadvantages that would be nice to fix:\n• It feels odd to put all our state updating logic inside one specific component.\n• For each new function we make, we have to hook up another prop to the filter(s) that need it.\n\nThis is where useReducer can come in handy. Let’s rewrite our example with it.\n\nThe way to think about is there are 3 major pieces:\n• The state - in our case, this is our type\n• Actions - in our case, these are and . In other words, these are triggers that may affect the state.\n• The reducer - this is a function that takes in both the state and an action, and returns an updated state.\n\nHere’s our example from above, using this format:\n\nWe can hook this up in our filter with :\n\nAnd finally, we can call this from our components:\n\nThe nice thing here is our ZipCodeFilter is explicit with what it is doing - it’s dispatching the action .\n\nIf you want to add a new action , your props don’t need to change. You just add the new action, update the reducer to show how that action affects the state, and then any component can trigger the action.\n\nWe also don’t have the same problem as before where we need to audit every call to dispatch for debugging, we only need to audit the relevant actions.\n\ntends to shine when actions can have complicated updates to the state. The component doesn’t need to worry about updating the state itself, it can just fire off an action and subsequently get/render the updated state passed in to it.\n\nThis separation of concerns has other advantages - like the fact that you can test the reducer without needing to render any components.\n\nIt is a little annoying to have to pass around everywhere. In the “Global State” section, we’ll see how to handle cases where we have state that needs to be accessed/modified across potentially many layers of components.\n\nSince is great when your state exists in one component, you might be tempted to use it for forms, like so:\n\nThis is totally reasonable, especially for small forms. But this example is a little overly simplified, as it doesn’t include important things like errors or a loading state while the API call is being made.\n\nHelpful forms will also have features like preventing the user from leaving the page if they haven’t saved yet, which means you need to track the last persisted form state.\n\nInstead of managing it all with a bunch of s, you can instead reach for a library that specializes in forms like Mantine’s use-form or React Hook Form. These libraries can significantly reduce the amount of boilerplate you need to write.\n\nAt PropelAuth, we turned this code snippet into a hook called . Combining that with Mantine’s use-form, warning users about unsaved changes in our dashboard looks like this:\n\nForms and menus are great, but what about a global dark mode setting? Or Stripe’s test mode toggle? Or a deeply nested tree of React components, where the state at the top needs to be accessed and modified by many of the child components?\n\nWe can only type or so many times before deciding that maybe AI should just do all this for us.\n\nLet’s look at a few patterns for handling state that needs to be accessed in many components across our application.\n\nWe’ll start with a simple example: a global test-mode toggle, similar to Stripe.\n\nThis toggle affects everything - which API endpoints to hit, whether or not to display warnings in the dashboard, etc. To set it up, there’s nothing stopping us from doing this:\n\nBut you can see how this gets unwieldy very quickly. Every component that needs to know if test mode is enabled, needs the prop passed to it. This process of passing down a prop through many layers of components is called prop drilling, and it gets annoying quickly.\n\nIn an ideal world, our components could just use hooks:\n\nand when we call , it automatically updates all the components that call . Luckily, this is totally possible with React Contexts.\n\nReact Contexts enable you to make some state available to the entire tree of React components beneath it. If you place a React context at the very top of your application, every component in the application will have access to the state within it.\n\nFor our test mode example, we need to call to create it, as well as provide a type for the state it’s managing:\n\nThere are then two things to do with the :\n• provides the values for and (in other words, it will store the ).\n• will return the value stored by the closest provider.\n\nIt’s best practice to write our own wrapper around :\n\nIt’s also best practice to provide some easy-to-use hooks:\n\nAnd now that we have everything ready, we just need to place the at the top of our application (it can technically go anywhere, but only components underneath it get access):\n\nand then any component will have access to our hook. All calls to will affect every component using that hook!\n\nIf we zoom out for a second, all we’ve really done is made a global version of . In fact, our is literally using to manage the boolean.\n\nThis is an important point - while the Context allows us to make our state global, we can still use all the same primitives we used before.\n\nIf we go back to our filter example, we needed to pass and around everywhere. But if we create a to store those values, and some custom hooks to expose them, you can avoid prop drilling and make a better developer experience:\n\nThere is still a good amount of boilerplate that goes into making a Context - we needed to make and hook up providers. zustand is a state management library that makes the process of managing global state easier. The equivalent testMode example would look like this:\n\nAnd then we can just use across multiple components.\n\nIn all the examples in the first two sections, our state was stored in memory. For our initial Menu example, if you open the menu and refresh the page, the menu will reset to the default - closed.\n\nThat’s pretty reasonable for our menu, but what about a multi-step job application form? Accidentally refreshing and losing all your progress there is a lot more soul crushing.\n\nLet’s see how we can avoid some hate mail.\n\nUltimately, this boils down to needing to store our state somewhere else. One common option is localStorage, which has a really simple API:\n\nand will look & operate exactly like they would with .\n\nThe idea is that the hook will load the initial value from localStorage. If it doesn’t exist, it’ll fall back to the default of . Calls to will not only update , it will also save the value in localStorage for the future.\n\nThe only difference when compared to is that we need to tell it what key to persist the state under, and now our state persists across refreshes!\n\nHere’s an example implementation for this hook (named ). If you want to try and implement it yourself, look at the docs for useSyncExternalStore which will take care of a lot of the heavy lifting.\n\nisn’t the only option. You can also persist data to IndexedDB, sessionStorage, or a non HTTP-only cookie which all have different tradeoffs. For a deeper dive into some of those tradeoffs, this article goes into more detail.\n\nMaking state shareable by saving in the URL as query parameters\n\nLet’s move on to a different example that will highlight a different pain point: a paginated table. We’ll assume that we have two variables to track: the page number the user is on and an optional search query.\n\nOur first attempt is to store them as state:\n\nBut we know what’s wrong here - a user that refreshes the page loses their query and page number leading to a pretty rough experience.\n\nEasy enough, we switch to our fancy new hook:\n\nThis is better, but it has some shortcomings:\n• If a user opens the table in a new tab, they’ll be greeted with the same page number and query. In fact, our table state will be synced across all our tabs, which might not be what you want.\n• A user may want to share something interesting they found in the table with a coworker, but they have no way of doing that.\n\nInstead of storing the state in memory, we can instead place it in the URL, like so:\n\nThis has some pretty cool properties:\n• It still persists across refreshes\n• Users can share links to their view of the table\n\nEach framework will have a slightly different way of reading/writing query parameters, so you’ll need to check with yours for this approach.\n\nOne other thing to point out here: you may not want every state change to be reflected in the URL. If you don’t want to deal with reading/writing to the URL on each user interaction, you can instead change to a “Copy link to share” approach:\n\nWith this approach, the workflow looks like this:\n• When the user clicks “Copy sharable link…”, it creates a URL that contains the filters, like\n• When the component initially loads, it’ll populate it’s initial state by checking the URL\n\nThis can often make the implementation simpler since you only need to sync w/ the query parameters once.\n\nSave your state to the database\n\nWhile we’re primarily talking about client state / FE state, this list didn’t seem complete without this entry. You can always store state in your backend / database. This often looks as simple as:\n\nAnd then it’s the backend’s responsibility to store the information. We’ll examine this more in a future post where we dig into managing server/asynchronous state.\n\nIn React applications, managing state is both critical and ubiquitous. Here’s an overview of the methods we discussed above:\n• useState: This React hook manages simple state for individual components. It's ideal for managing straightforward state changes within a component. Example: managing the state of a menu's open/close state.\n• useReducer: For more complex state logic, useReducer is preferred. It's useful when state changes involve more intricate updates or when multiple components need to interact with the same state object.\n• Form State Management: If you are managing a form, dedicated libraries such as React Hook Form or Mantine's useForm provide efficient ways to manage form state, including handling validations and submission states.\n• React Context: Useful for managing global state that needs to be accessed across multiple components without prop drilling. Contexts provide a way to share state between components without explicitly passing props through every level of the tree.\n• Persisting State: To maintain state across page refreshes, you can use options like , , or query parameters. Prefer query parameters if the state should be shareable.\n\nOverall, understanding these state management techniques and choosing the appropriate one based on your application's needs helps in building scalable and maintainable React applications."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://pluralsight.com/resources/blog/guides/inline-styling-with-react",
        "document": "In frontend projects, which seldom require the use of a single-page app, inline styles of DOM elements are often placed in the style=\"property:value\" attribute of the target element. But in React, things are quite different when it comes to styling inline. This guide focuses on exactly how to achieve that using a real-world example of building a user profile card component.\n\nNotice that the value of padding does not have a unit as React appends a 'px' suffix to some numeric inline style properties. In cases where you need to use other units, such as 'em' or 'rem', specify the unit with the value explicitly as a string. Applying that to the padding property should result in padding: '1.5em'. In addition, these styles are not vendor-prefixed automatically, so you have to add vendor prefixes manually.\n\nThe readability of MyComponent reduces dramatically if styles become a lot and everything gets clunky. Since styles are mere objects, they can be extracted out of the component as shown below.\n\nThe official React documentation frowns upon the use of inline styling as a primary means of styling projects and recommends the use of the className attribute instead. Note: Some examples in the documentation use style for convenience, but using the style attribute as the primary means of styling elements is generally not recommended. In most cases, className should be used to reference classes defined in an external CSS stylesheet. style is most often used in React apps to add dynamically computed styles at render time.\n\nWell, that's a wrap! In this guide, you were introduced to the concept of inline styling in React. If you would like to read more on this, you can visit the the React docs for more details: React Styling. Feel free to ping me on Twitter as well: Desmond Nyamador."
    },
    {
        "link": "https://react.dev/reference/react-dom/components/style",
        "document": "To add inline styles to your document, render the built-in browser component. You can render from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.\n\nSee more examples below.\n• : a string, required. The contents of the stylesheet.\n• : a string. Tells React where to rank the DOM node relative to others in the document , which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are or inline tags or loaded using functions.\n• : a string. Allows React to de-duplicate styles that have the same .\n• : a string. Restricts the stylesheet to a certain media query.\n• : a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\n• : a string. Specifies the name of an alternative stylesheet.\n\nProps that are not recommended for use with React:\n• : a string. If set to , instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\n\nReact can move components to the document’s , de-duplicate identical stylesheets, and suspend while the stylesheet is loading.\n\nTo opt into this behavior, provide the and props. React will de-duplicate styles if they have the same . The precedence prop tells React where to rank the DOM node relative to others in the document , which determines which stylesheet can override the other.\n\nThis special treatment comes with two caveats:\n• React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)\n• React will drop all extraneous props when using the prop (beyond and ).\n• React may leave the style in the DOM even after the component that rendered it has been unmounted.\n\nIf a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.\n\nThe prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same . If you supply a prop, React will reorder inline stylesheets based on the order these values appear in the component tree.\n\nInline stylesheets will not trigger Suspense boundaries while they’re loading. Even if they load async resources like fonts or images."
    },
    {
        "link": "https://stackoverflow.com/questions/26882177/react-js-inline-style-best-practices",
        "document": "There aren't a lot of \"Best Practices\" yet. Those of us that are using inline-styles, for React components, are still very much experimenting.\n\nThere are a number of approaches that vary wildly: React inline-style lib comparison chart\n\nAll or nothing?\n\nWhat we refer to as \"style\" actually includes quite a few concepts:\n• Layout — how an element/component looks in relationship to others\n• Appearance — the characteristics of an element/component\n• Behavior and state — how an element/component looks in a given state\n\nReact is already managing the state of your components, this makes styles of state and behavior a natural fit for colocation with your component logic.\n\nInstead of building components to render with conditional state-classes, consider adding state-styles directly:\n\nNote that we're using a class to style appearance but no longer using any prefixed class for state and behavior.\n\nWe can use (ES6) or (underscore/lodash) to add support for multiple states:\n\nNow that we're using it becomes very simple to make our component reusable with different styles. If we want to override the default styles, we can do so at the call-site with props, like so: . Implemented like this:\n\nPersonally, I don't see compelling reason to inline layout styles. There are a number of great CSS layout systems out there. I'd just use one.\n\nThat said, don't add layout styles directly to your component. Wrap your components with layout components. Here's an example.\n\nFor layout support, I often try to design components to be and .\n\nThis is the most contentious area of the \"inline-style\" debate. Ultimately, it's up to the component your designing and the comfort of your team with JavaScript.\n\nOne thing is certain, you'll need the assistance of a library. Browser-states ( , ), and media-queries are painful in raw React.\n\nI like Radium because the syntax for those hard parts is designed to model that of SASS.\n\nOften you'll see a style object outside of the module. For a todo-list component, it might look something like this:\n\nAdding a bunch of style logic to your template can get a little messy (as seen above). I like to create getter functions to compute styles:\n\nI discussed all of these in more detail at React Europe earlier this year: Inline Styles and when it's best to 'just use CSS'.\n\nI'm happy to help as you make new discoveries along the way :) Hit me up -> @chantastic"
    },
    {
        "link": "https://legacy.reactjs.org/docs/faq-styling.html",
        "document": "How do I add CSS classes to components?\n\nIt is common for CSS classes to depend on the component props or state:\n\nYes, see the docs on styling here.\n\nCSS classes are generally better for performance than inline styles.\n\n“CSS-in-JS” refers to a pattern where CSS is composed using JavaScript instead of defined in external files.\n\nNote that this functionality is not a part of React, but provided by third-party libraries. React does not have an opinion about how styles are defined; if in doubt, a good starting point is to define your styles in a separate file as usual and refer to them using .\n\nCan I do animations in React?\n\nReact can be used to power animations. See React Transition Group, React Motion, React Spring, or Framer Motion, for example."
    },
    {
        "link": "https://w3schools.com/react/react_css.asp",
        "document": "There are many ways to style React with CSS, this tutorial will take a closer look at inline styling, and CSS stylesheet.\n\nTo style an element with the inline style attribute, the value must be a JavaScript object:\n\nNote: In JSX, JavaScript expressions are written inside curly braces, and since JavaScript objects also use curly braces, the styling in the example above is written inside two sets of curly braces .\n\nSince the inline CSS is written in a JavaScript object, properties with two names, like , must be written with camel case syntax:\n\nYou can also create an object with styling information, and refer to it in the style attribute:\n\nYou can write your CSS styling in a separate file, just save the file with the file extension, and import it in your application.\n\nImport the stylesheet in your application:\n\nAnother way of adding styles to your application is to use CSS Modules.\n\nCSS Modules are convenient for components that are placed in separate files.\n\nThe CSS inside a module is available only for the component that imported it, and you do not have to worry about name conflicts.\n\nCreate the CSS module with the extension, example: .\n\nImport the stylesheet in your component:\n\nImport the component in your application:"
    }
]