[
    {
        "link": "https://doc.qt.io/qt-6/qfontmetricsf.html",
        "document": "The QFontMetricsF class provides font metrics information. More...\n\nNote: All functions in this class are reentrant.\n\n\"What's the advance width of this text?\"\n\nThe string functions include horizontalAdvance (), to return the width of a string in pixels (or points, for a printer), boundingRect (), to return a rectangle large enough to contain the rendered string, and size (), to return the size of that rectangle.\n\nFor each character, you can get its horizontalAdvance (), leftBearing (), and rightBearing (), and find out whether it is in the font using inFont (). You can also treat the character as a string, and use the string functions on it.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing (), minRightBearing () and maxWidth (). These are by necessity slow, and we recommend avoiding them if possible.\n\nThere are several functions that operate on the font: ascent (), descent (), height (), leading () and lineSpacing () return the basic size properties of the font. The underlinePos (), overlinePos (), strikeOutPos () and lineWidth () functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nQFontMetricsF functions calculate the size of characters and strings for a given font. You can construct a QFontMetricsF object with an existing QFont to obtain metrics for that font. If the font is changed later, the font metrics object is not updated.\n\nSee also QFont, QFontInfo, and QFontDatabase.\n\nThe font metrics will be compatible with the paintdevice used to create font.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nUse QFontMetricsF(const QFont &, QPaintDevice *) to get the font metrics that are compatible with a certain paint device.\n\nConstructs a font metrics object with floating point precision from the given fontMetrics object.\n\nThe font metrics will be compatible with the paintdevice passed. If the paintdevice is , the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nDestroys the font metrics object and frees all allocated resources.\n\nReturns the ascent of the font.\n\nThe ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nReturns the average width of glyphs in the font.\n\nReturns the bounding rectangle of the character ch relative to the left-most point on the base line.\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nNote that the rectangle usually extends both above and below the base line.\n\nReturns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned height().\n\nSee also horizontalAdvance(), height(), and QPainter::boundingRect().\n\nReturns the bounding rectangle of the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned height().\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and QPainter::boundingRect().\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the characters in the given text. This is the set of pixels the text would cover if drawn when constrained to the bounding rectangle specified by rect. If rect is a reference to a object, e.g. when passing a default constructed QRectF, the bounding rectangle will not constrain itself to the size.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nQt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop.\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nThese flags are defined in Qt::AlignmentFlag.\n\nIf Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts.\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nSee also horizontalAdvance(), QPainter::boundingRect(), and Qt::Alignment.\n\nReturns the cap height of the font.\n\nThe cap height of a font is the height of a capital letter above the baseline. It specifically is the height of capital letters that are flat - such as H or I - as opposed to round letters such as O, or pointed letters like A, both of which may display overshoot.\n\nReturns the descent of the font.\n\nThe descent is the distance from the base line to the lowest point characters extend to. (Note that this is different from X, which adds 1 pixel.) In practice, some font designers break this rule, e.g. to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nIf the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string.\n\nThe mode parameter specifies whether the text is elided on the left (for example, \"...tech\"), in the middle (for example, \"Tr...ch\"), or on the right (for example, \"Trol...\").\n\nThe width is specified in pixels, not characters.\n\nThe flags argument is optional and currently only supports Qt::TextShowMnemonic as value.\n\nThe elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is , and on the left side of the text if the mode is .\n\nReturns the height of the font.\n\nThis is always equal to ascent()+descent().\n\nSee also leading() and lineSpacing().\n\nReturns the horizontal advance in pixels of text laid out using option.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis function was introduced in Qt 6.3.\n\nReturns the horizontal advance in pixels of the first length characters of text. If length is negative (the default), the entire string is used. The entire length of text is analysed even if length is substantially shorter.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis is an overloaded function.\n\nReturns the horizontal advance of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch.\n\nSome of the metrics are described in the image to the right. The central dark rectangles cover the logical horizontalAdvance() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive.\n\nReturns if character ch is a valid character in the font; otherwise returns .\n\nReturns if the character given by ch, encoded in UCS-4/UTF-32, is a valid character in the font; otherwise returns .\n\nReturns the leading of the font.\n\nThis is the natural inter-line spacing.\n\nSee also height() and lineSpacing().\n\nReturns the left bearing of character ch in the font.\n\nThe left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also rightBearing(), minLeftBearing(), and horizontalAdvance().\n\nReturns the distance from one base line to the next.\n\nThis value is always equal to leading()+height().\n\nSee also height() and leading().\n\nReturns the width of the underline and strikeout lines, adjusted for the point size of the font.\n\nSee also underlinePos(), overlinePos(), and strikeOutPos().\n\nReturns the width of the widest character in the font.\n\nReturns the minimum left bearing of the font.\n\nThis is the smallest leftBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minRightBearing() and leftBearing().\n\nReturns the minimum right bearing of the font.\n\nThis is the smallest rightBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minLeftBearing() and rightBearing().\n\nReturns the distance from the base line to where an overline should be drawn.\n\nSee also underlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the right bearing of character ch in the font.\n\nThe right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also leftBearing(), minRightBearing(), and horizontalAdvance().\n\nReturns the size in pixels of the characters in the given text.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nThese flags are defined in the Qt::TextFlag enum.\n\nIf Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote: Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nReturns the distance from the base line to where the strikeout line should be drawn.\n\nSee also underlinePos(), overlinePos(), and lineWidth().\n\nSwaps this font metrics instance with other. This operation is very fast and never fails.\n\nReturns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns a tight bounding rectangle around the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0,0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns the distance from the base line to where an underscore should be drawn.\n\nSee also overlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the 'x' height of the font. This is often but not always the same as the height of the character 'x'.\n\nThis is an overloaded function.\n\nReturns if the font metrics are not equal to the other font metrics; otherwise returns .\n\nMove-assigns other to this QFontMetricsF instance.\n\nAssigns other to this object.\n\nAssigns the font metrics fm to this font metrics object.\n\nReturns if the font metrics are equal to the other font metrics; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered to be compatible."
    },
    {
        "link": "https://doc.qt.io/qt-6/qfontmetrics.html",
        "document": "The QFontMetrics class provides font metrics information. More...\n\nNote: All functions in this class are reentrant.\n\n\"What's the advance width of this text?\"\n\nNote: The advance width can be different from the width of the actual rendered text. It refers to the distance from the origin of the string to where you would append additional characters. As text may have overhang (in the case of an italic font for instance) or padding between characters, the advance width can be either smaller or larger than the actual rendering of the text. This is called the right bearing of the text.\n\nThe string functions include horizontalAdvance (), to return the advance width of a string in pixels (or points, for a printer), boundingRect (), to return a rectangle large enough to contain the rendered string, and size (), to return the size of that rectangle.\n\nFor each character, you can get its horizontalAdvance (), leftBearing (), and rightBearing (), and find out whether it is in the font using inFont (). You can also treat the character as a string, and use the string functions on it.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing (), minRightBearing () and maxWidth (). These are by necessity slow, and we recommend avoiding them if possible.\n\nThere are several functions that operate on the font: ascent (), descent (), height (), leading () and lineSpacing () return the basic size properties of the font. The underlinePos (), overlinePos (), strikeOutPos () and lineWidth () functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nThere are three ways you can create a QFontMetrics object:\n\nQFontMetrics functions calculate the size of characters and strings for a given font. The class is an integer-based version of QFontMetricsF and will round all numbers to the nearest integer. This means its results will be inaccurate for any font with fractional metrics. In most cases QFontMetricsF should be used instead.\n\nSee also QFont, QFontInfo, and QFontDatabase.\n\nThe font metrics will be compatible with the paintdevice used to create font.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nUse QFontMetrics(const QFont &, QPaintDevice *) to get the font metrics that are compatible with a certain paint device.\n\nThe font metrics will be compatible with the paintdevice passed. If the paintdevice is , the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nDestroys the font metrics object and frees all allocated resources.\n\nReturns the ascent of the font.\n\nThe ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nReturns the average width of glyphs in the font.\n\nReturns the rectangle that is covered by ink if character ch were to be drawn at the origin of the coordinate system.\n\nNote that the bounding rectangle may extend to the left of (0, 0) (e.g., for italicized fonts), and that the text output may cover all pixels in the bounding rectangle. For a space character the rectangle will usually be empty.\n\nNote that the rectangle usually extends both above and below the base line.\n\nReturns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned by height().\n\nSee also horizontalAdvance(), height(), QPainter::boundingRect(), and tightBoundingRect().\n\nReturns the bounding rectangle of the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned by height().\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), QPainter::boundingRect(), and tightBoundingRect().\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the characters in the string specified by text, which is the set of pixels the text would cover if drawn at (0, 0). The drawing, and hence the bounding rectangle, is constrained to the rectangle rect.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nQt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop.\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nIf Qt::TextExpandTabs is set in flags, then: if tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nSee also horizontalAdvance(), QPainter::boundingRect(), and Qt::Alignment.\n\nThis is an overloaded function.\n\nReturns the bounding rectangle for the given text within the rectangle specified by the x and y coordinates, width, and height.\n\nIf Qt::TextExpandTabs is set in flags and tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise, if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nReturns the cap height of the font.\n\nThe cap height of a font is the height of a capital letter above the baseline. It specifically is the height of capital letters that are flat - such as H or I - as opposed to round letters such as O, or pointed letters like A, both of which may display overshoot.\n\nReturns the descent of the font.\n\nThe descent is the distance from the base line to the lowest point characters extend to. In practice, some font designers break this rule, e.g. to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nIf the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string.\n\nThe mode parameter specifies whether the text is elided on the left (e.g., \"...tech\"), in the middle (e.g., \"Tr...ch\"), or on the right (e.g., \"Trol...\").\n\nThe width is specified in pixels, not characters.\n\nThe flags argument is optional and currently only supports Qt::TextShowMnemonic as value.\n\nThe elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is , and on the left side of the text if the mode is .\n\nReturns the height of the font.\n\nThis is always equal to ascent()+descent().\n\nSee also leading() and lineSpacing().\n\nReturns the horizontal advance in pixels of text laid out using option.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis function was introduced in Qt 6.3.\n\nReturns the horizontal advance in pixels of the first len characters of text. If len is negative (the default), the entire string is used. The entire length of text is analysed even if len is substantially shorter.\n\nThis is the distance appropriate for drawing a subsequent character after text.\n\nThis is an overloaded function.\n\nReturns the horizontal advance of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch.\n\nSome of the metrics are described in the image. The central dark rectangles cover the logical horizontalAdvance() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive.\n\nReturns if character ch is a valid character in the font; otherwise returns .\n\nReturns if the character ucs4 encoded in UCS-4/UTF-32 is a valid character in the font; otherwise returns .\n\nReturns the leading of the font.\n\nThis is the natural inter-line spacing.\n\nSee also height() and lineSpacing().\n\nReturns the left bearing of character ch in the font.\n\nThe left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also rightBearing(), minLeftBearing(), and horizontalAdvance().\n\nReturns the distance from one base line to the next.\n\nThis value is always equal to leading()+height().\n\nSee also height() and leading().\n\nReturns the width of the underline and strikeout lines, adjusted for the point size of the font.\n\nSee also underlinePos(), overlinePos(), and strikeOutPos().\n\nReturns the width of the widest character in the font.\n\nReturns the minimum left bearing of the font.\n\nThis is the smallest leftBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minRightBearing() and leftBearing().\n\nReturns the minimum right bearing of the font.\n\nThis is the smallest rightBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minLeftBearing() and rightBearing().\n\nReturns the distance from the base line to where an overline should be drawn.\n\nSee also underlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the right bearing of character ch in the font.\n\nThe right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also leftBearing(), minRightBearing(), and horizontalAdvance().\n\nReturns the size in pixels of text.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nIf Qt::TextExpandTabs is set in flags, then: if tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nReturns the distance from the base line to where the strikeout line should be drawn.\n\nSee also underlinePos(), overlinePos(), and lineWidth().\n\nSwaps this font metrics instance with other. This operation is very fast and never fails.\n\nReturns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns a tight bounding rectangle around the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns the distance from the base line to where an underscore should be drawn.\n\nSee also overlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the 'x' height of the font. This is often but not always the same as the height of the character 'x'.\n\nReturns if other is not equal to this object; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered compatible.\n\nMove-assigns other to this QFontMetrics instance.\n\nReturns if other is equal to this object; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered compatible."
    },
    {
        "link": "https://qt.developpez.com/doc/5.15/qfontmetricsf",
        "document": "QFontMetricsF functions calculate the size of characters and strings for a given font. You can construct a QFontMetricsF object with an existing QFont to obtain metrics for that font. If the font is changed later, the font metrics object is not updated. Once created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font. There are several functions that operate on the font: ascent(), descent(), height(), leading() and lineSpacing() return the basic size properties of the font. The underlinePos(), overlinePos(), strikeOutPos() and lineWidth() functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast. There are also some functions that operate on the set of glyphs in the font: minLeftBearing(), minRightBearing() and maxWidth(). These are by necessity slow, and we recommend avoiding them if possible. For each character, you can get its horizontalAdvance(), leftBearing(), and rightBearing(), and find out whether it is in the font using inFont(). You can also treat the character as a string, and use the string functions on it. The string functions include horizontalAdvance(), to return the width of a string in pixels (or points, for a printer), boundingRect(), to return a rectangle large enough to contain the rendered string, and size(), to return the size of that rectangle. QFont font( , ); QFontMetricsF fm(font); qreal pixelsWide fm.horizontalAdvance( \"What's the width of this text?\" ); qreal pixelsHigh fm.height();\n\nThe font metrics will be compatible with the paintdevice used to create font. The font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later. Use QFontMetricsF(const QFont &, QPaintDevice *) to get the font metrics that are compatible with a certain paint device. Constructs a font metrics object for font and paintdevice. The font metrics will be compatible with the paintdevice passed. If the paintdevice is nullptr, the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter. The font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later. This function was introduced in Qt 5.13. Constructs a font metrics object with floating point precision from the given fontMetrics object. This function was introduced in Qt 4.2. Returns the ascent of the font. The ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate an unusual character in an exotic language, so it is possible (though rare) that this value will be too small. Returns the average width of glyphs in the font. This function was introduced in Qt 4.2. Returns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks. The height of the bounding rectangle is at least as large as the value returned height(). Returns the bounding rectangle of the character ch relative to the left-most point on the base line. Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle. Note that the rectangle usually extends both above and below the base line. This is an overloaded function. Returns the bounding rectangle of the characters in the given text. This is the set of pixels the text would cover if drawn when constrained to the bounding rectangle specified by rect. The flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle. Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop. If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined. These flags are defined in Qt::AlignmentFlag. If Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts. Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same. The bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights. Returns the cap height of the font. The cap height of a font is the height of a capital letter above the baseline. It specifically is the height of capital letters that are flat - such as H or I - as opposed to round letters such as O, or pointed letters like A, both of which may display overshoot. This function was introduced in Qt 5.8. Returns the descent of the font. The descent is the distance from the base line to the lowest point characters extend to. (Note that this is different from X, which adds 1 pixel.) In practice, some font designers break this rule, e.g. to accommodate an unusual character in an exotic language, so it is possible (though rare) that this value will be too small. If the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string. The mode parameter specifies whether the text is elided on the left (for example, \"...tech\"), in the middle (for example, \"Tr...ch\"), or on the right (for example, \"Trol...\"). The width is specified in pixels, not characters. The flags argument is optional and currently only supports Qt::TextShowMnemonic as value. The elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is Qt::ElideLeft, and on the left side of the text if the mode is Qt::ElideRight. This function was introduced in Qt 4.2. This function was introduced in Qt 5.14. Returns the height of the font. This is always equal to ascent()+descent(). Returns the horizontal advance in pixels of the first length characters of text. If length is negative (the default), the entire string is used. The advance is the distance appropriate for drawing a subsequent character after text. This function was introduced in Qt 5.11. This is an overloaded function. Returns the horizontal advance of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch. Some of the metrics are described in the image to the right. The central dark rectangles cover the logical horizontalAdvance() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive. This function will produce incorrect results for Arabic characters or non-spacing marks in the middle of a string, as the glyph shaping and positioning of marks that happens when processing strings cannot be taken into account. When implementing an interactive text control, use QTextLayout instead. This function was introduced in Qt 5.11. Returns true if character ch is a valid character in the font; otherwise returns false. Returns true if the character given by ch, encoded in UCS-4/UTF-32, is a valid character in the font; otherwise returns false. Returns the leading of the font. This is the natural inter-line spacing. Returns the left bearing of character ch in the font. The left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin. See horizontalAdvance() for a graphical description of this metric. Returns the distance from one base line to the next. This value is always equal to leading()+height(). Returns the width of the underline and strikeout lines, adjusted for the point size of the font. Returns the width of the widest character in the font. Returns the minimum left bearing of the font. This is the smallest leftBearing(char) of all characters in the font. Note that this function can be very slow if the font is large. Returns the minimum right bearing of the font. This is the smallest rightBearing(char) of all characters in the font. Note that this function can be very slow if the font is large. Returns the distance from the base line to where an overline should be drawn. Returns the right bearing of character ch in the font. The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character. See horizontalAdvance() for a graphical description of this metric. Returns the size in pixels of the characters in the given text. The flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle. These flags are defined in the Qt::TextFlag enum. If Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels). Note: Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same. Returns the distance from the base line to where the strikeout line should be drawn. Swaps this font metrics instance with other. This function is very fast and never fails. This function was introduced in Qt 5.0. Returns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks. Calling this method is very slow on Windows. This function was introduced in Qt 4.3. Returns the distance from the base line to where an underscore should be drawn. Returns the 'x' height of the font. This is often but not always the same as the height of the character 'x'. This is an overloaded function. Returns true if the font metrics are not equal to the other font metrics; otherwise returns false. Assigns the font metrics fm to this font metrics object. This function was introduced in Qt 4.2. Returns true if the font metrics are equal to the other font metrics; otherwise returns false. Two font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered to be compatible."
    },
    {
        "link": "https://qt.developpez.com/doc/6.6/qfontmetricsf",
        "document": "The string functions include horizontalAdvance (), to return the width of a string in pixels (or points, for a printer), boundingRect (), to return a rectangle large enough to contain the rendered string, and size (), to return the size of that rectangle.\n\nFor each character, you can get its horizontalAdvance (), leftBearing (), and rightBearing (), and find out whether it is in the font using inFont (). You can also treat the character as a string, and use the string functions on it.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing (), minRightBearing () and maxWidth (). These are by necessity slow, and we recommend avoiding them if possible.\n\nThere are several functions that operate on the font: ascent (), descent (), height (), leading () and lineSpacing () return the basic size properties of the font. The underlinePos (), overlinePos (), strikeOutPos () and lineWidth () functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nQFontMetricsF functions calculate the size of characters and strings for a given font. You can construct a QFontMetricsF object with an existing QFont to obtain metrics for that font. If the font is changed later, the font metrics object is not updated.\n\nConstructs a font metrics object for font and paintdevice. The font metrics will be compatible with the paintdevice passed. If the paintdevice is nullptr, the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter. The font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nReturns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks. The height of the bounding rectangle is at least as large as the value returned height().\n\nReturns the bounding rectangle of the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks. The height of the bounding rectangle is at least as large as the value returned height(). This function was introduced in Qt 6.3.\n\nThis is an overloaded function. Returns the bounding rectangle of the characters in the given text. This is the set of pixels the text would cover if drawn when constrained to the bounding rectangle specified by rect. If rect is a reference to a nullptr object, e.g. when passing a default constructed QRectF, the bounding rectangle will not constrain itself to the size. The flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle. Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop. If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined. These flags are defined in Qt::AlignmentFlag. If Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts. Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same. The bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nIf the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string. The mode parameter specifies whether the text is elided on the left (for example, \"...tech\"), in the middle (for example, \"Tr...ch\"), or on the right (for example, \"Trol...\"). The width is specified in pixels, not characters. The flags argument is optional and currently only supports Qt::TextShowMnemonic as value. The elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is Qt::ElideLeft, and on the left side of the text if the mode is Qt::ElideRight.\n\nReturns the left bearing of character ch in the font. The left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin. See horizontalAdvance() for a graphical description of this metric.\n\nReturns the right bearing of character ch in the font. The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character. See horizontalAdvance() for a graphical description of this metric.\n\nReturns the size in pixels of the characters in the given text. The flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle. These flags are defined in the Qt::TextFlag enum. If Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels). Note: Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nReturns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks.\n\nReturns a tight bounding rectangle around the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0,0). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns. If you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead. Newline characters are processed as normal characters, not as linebreaks. This function was introduced in Qt 6.3."
    },
    {
        "link": "https://dreamswork.github.io/qt4/classQFontMetricsF.html",
        "document": "The QFontMetricsF class provides font metrics information. More...\n\nThis class or function is reentrant. QFontMetricsF functions calculate the size of characters and strings for a given font. You can construct a QFontMetricsF object with an existing QFont to obtain metrics for that font. If the font is changed later, the font metrics object is not updated. Once created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font. There are several functions that operate on the font: ascent(), descent(), height(), leading() and lineSpacing() return the basic size properties of the font. The underlinePos(), overlinePos(), strikeOutPos() and lineWidth() functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast. There are also some functions that operate on the set of glyphs in the font: minLeftBearing(), minRightBearing() and maxWidth(). These are by necessity slow, and we recommend avoiding them if possible. For each character, you can get its width(), leftBearing() and rightBearing() and find out whether it is in the font using inFont(). You can also treat the character as a string, and use the string functions on it. The string functions include width(), to return the width of a string in pixels (or points, for a printer), boundingRect(), to return a rectangle large enough to contain the rendered string, and size(), to return the size of that rectangle. pixelsWide = fm.width( \"What's the width of this text?\" );\n\nReturns the bounding rectangle of the characters in the given text. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This is the set of pixels the text would cover if drawn when constrained to the bounding rectangle specified by rect. The flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle. Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop. If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined. These flags are defined in Qt::AlignmentFlag. If Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels). Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts. Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same. The bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights. The QRectF class defines a rectangle in the plane using floating point precision. ... The QFont class specifies a font used for drawing text.\n\nThe documentation for this class was generated from the following files:"
    },
    {
        "link": "https://doc.qt.io/qt-6/qfontmetrics.html",
        "document": "The QFontMetrics class provides font metrics information. More...\n\nNote: All functions in this class are reentrant.\n\n\"What's the advance width of this text?\"\n\nNote: The advance width can be different from the width of the actual rendered text. It refers to the distance from the origin of the string to where you would append additional characters. As text may have overhang (in the case of an italic font for instance) or padding between characters, the advance width can be either smaller or larger than the actual rendering of the text. This is called the right bearing of the text.\n\nThe string functions include horizontalAdvance (), to return the advance width of a string in pixels (or points, for a printer), boundingRect (), to return a rectangle large enough to contain the rendered string, and size (), to return the size of that rectangle.\n\nFor each character, you can get its horizontalAdvance (), leftBearing (), and rightBearing (), and find out whether it is in the font using inFont (). You can also treat the character as a string, and use the string functions on it.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing (), minRightBearing () and maxWidth (). These are by necessity slow, and we recommend avoiding them if possible.\n\nThere are several functions that operate on the font: ascent (), descent (), height (), leading () and lineSpacing () return the basic size properties of the font. The underlinePos (), overlinePos (), strikeOutPos () and lineWidth () functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nThere are three ways you can create a QFontMetrics object:\n\nQFontMetrics functions calculate the size of characters and strings for a given font. The class is an integer-based version of QFontMetricsF and will round all numbers to the nearest integer. This means its results will be inaccurate for any font with fractional metrics. In most cases QFontMetricsF should be used instead.\n\nSee also QFont, QFontInfo, and QFontDatabase.\n\nThe font metrics will be compatible with the paintdevice used to create font.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nUse QFontMetrics(const QFont &, QPaintDevice *) to get the font metrics that are compatible with a certain paint device.\n\nThe font metrics will be compatible with the paintdevice passed. If the paintdevice is , the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nDestroys the font metrics object and frees all allocated resources.\n\nReturns the ascent of the font.\n\nThe ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nReturns the average width of glyphs in the font.\n\nReturns the rectangle that is covered by ink if character ch were to be drawn at the origin of the coordinate system.\n\nNote that the bounding rectangle may extend to the left of (0, 0) (e.g., for italicized fonts), and that the text output may cover all pixels in the bounding rectangle. For a space character the rectangle will usually be empty.\n\nNote that the rectangle usually extends both above and below the base line.\n\nReturns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned by height().\n\nSee also horizontalAdvance(), height(), QPainter::boundingRect(), and tightBoundingRect().\n\nReturns the bounding rectangle of the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned by height().\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), QPainter::boundingRect(), and tightBoundingRect().\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the characters in the string specified by text, which is the set of pixels the text would cover if drawn at (0, 0). The drawing, and hence the bounding rectangle, is constrained to the rectangle rect.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nQt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop.\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nIf Qt::TextExpandTabs is set in flags, then: if tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nSee also horizontalAdvance(), QPainter::boundingRect(), and Qt::Alignment.\n\nThis is an overloaded function.\n\nReturns the bounding rectangle for the given text within the rectangle specified by the x and y coordinates, width, and height.\n\nIf Qt::TextExpandTabs is set in flags and tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise, if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nReturns the cap height of the font.\n\nThe cap height of a font is the height of a capital letter above the baseline. It specifically is the height of capital letters that are flat - such as H or I - as opposed to round letters such as O, or pointed letters like A, both of which may display overshoot.\n\nReturns the descent of the font.\n\nThe descent is the distance from the base line to the lowest point characters extend to. In practice, some font designers break this rule, e.g. to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nIf the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string.\n\nThe mode parameter specifies whether the text is elided on the left (e.g., \"...tech\"), in the middle (e.g., \"Tr...ch\"), or on the right (e.g., \"Trol...\").\n\nThe width is specified in pixels, not characters.\n\nThe flags argument is optional and currently only supports Qt::TextShowMnemonic as value.\n\nThe elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is , and on the left side of the text if the mode is .\n\nReturns the height of the font.\n\nThis is always equal to ascent()+descent().\n\nSee also leading() and lineSpacing().\n\nReturns the horizontal advance in pixels of text laid out using option.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis function was introduced in Qt 6.3.\n\nReturns the horizontal advance in pixels of the first len characters of text. If len is negative (the default), the entire string is used. The entire length of text is analysed even if len is substantially shorter.\n\nThis is the distance appropriate for drawing a subsequent character after text.\n\nThis is an overloaded function.\n\nReturns the horizontal advance of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch.\n\nSome of the metrics are described in the image. The central dark rectangles cover the logical horizontalAdvance() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive.\n\nReturns if character ch is a valid character in the font; otherwise returns .\n\nReturns if the character ucs4 encoded in UCS-4/UTF-32 is a valid character in the font; otherwise returns .\n\nReturns the leading of the font.\n\nThis is the natural inter-line spacing.\n\nSee also height() and lineSpacing().\n\nReturns the left bearing of character ch in the font.\n\nThe left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also rightBearing(), minLeftBearing(), and horizontalAdvance().\n\nReturns the distance from one base line to the next.\n\nThis value is always equal to leading()+height().\n\nSee also height() and leading().\n\nReturns the width of the underline and strikeout lines, adjusted for the point size of the font.\n\nSee also underlinePos(), overlinePos(), and strikeOutPos().\n\nReturns the width of the widest character in the font.\n\nReturns the minimum left bearing of the font.\n\nThis is the smallest leftBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minRightBearing() and leftBearing().\n\nReturns the minimum right bearing of the font.\n\nThis is the smallest rightBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minLeftBearing() and rightBearing().\n\nReturns the distance from the base line to where an overline should be drawn.\n\nSee also underlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the right bearing of character ch in the font.\n\nThe right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also leftBearing(), minRightBearing(), and horizontalAdvance().\n\nReturns the size in pixels of text.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nIf Qt::TextExpandTabs is set in flags, then: if tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nReturns the distance from the base line to where the strikeout line should be drawn.\n\nSee also underlinePos(), overlinePos(), and lineWidth().\n\nSwaps this font metrics instance with other. This operation is very fast and never fails.\n\nReturns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns a tight bounding rectangle around the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns the distance from the base line to where an underscore should be drawn.\n\nSee also overlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the 'x' height of the font. This is often but not always the same as the height of the character 'x'.\n\nReturns if other is not equal to this object; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered compatible.\n\nMove-assigns other to this QFontMetrics instance.\n\nReturns if other is equal to this object; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered compatible."
    },
    {
        "link": "https://stackoverflow.com/questions/13432746/why-is-qfontmetricslinespacing-smaller-than-the-height-of-the-characters-bo",
        "document": "This happens on Linux.\n\nThe problem shows when executing this code (I'm drawing in the paint event of a widget):\n\nNotice the height of the bounding box for the character is , while the line spacing is . This is partly because the leading is negative, but even without that, the font height is still smaller.\n\nHow does Qt calculate the character bounding box it returns? Its height obviously is not derived from and ."
    },
    {
        "link": "https://stackoverflow.com/questions/74246330/qfontmetrics-leave-extra-space-between-lines",
        "document": "First of all, the height of a bounding rect of a font metrics doesn't depend on the characters used, but on the font specifications.\n\nTwo lines of text don't have the double of the of the bounding rect of a single line: instead, you have to consider the .\n\nIn practice, the height of a bounding rect is normally the sum of:\n• the multiplied the number of lines;\n• the multiplied by the number of spaces between the lines (aka: number of lines - 1);\n\nOr, similarly, the sum of:\n• the multiplied by the number of spaces between lines;\n\nNote that, obviously, the number of lines depends on the input text and the given options, for instance, if word wrapping was enabled and any of the source lines didn't fit the given source rectangle.\n\nAlso consider that most fonts are vectorial, meaning that their coordinates and metrics are proportional and in floating point values. QFontMetrics, instead, works with integer values for simplicity and optimization reasons, so you might get inconsistent results caused by rounding in cases for which the point size doesn't give rounded values: non integer numbers are generally \"floored\" (like in python).\n\n In your case, the is probably more than 0 (but still less than 1), so you don't get a proper sum of the aforementioned heights.\n\nSpecifically, returns a QRect resulting by the of the computed formatted text, which is always \"the smallest possible integer rectangle that completely contains this rectangle\".\n\nIf you need to get precise coordinates, you need to use QFontMetricsF, which is the floating point counterpart of the default basic QFontMetrics.\n\nThat said, if you plan on drawing formatted text with QPainter, then consider using QTextDocument or, at least, QTextLayout, which is consistent with the standard Qt text drawing and is generally faster, more reliable and \"simpler\" (well, once you get to know it). While it might seem a bit too complex than required, it's actually what Qt does when calling , so if you need custom painting, the QTextLayout option is actually better, especially if you can combine it with some smart caching (see QPicture) to avoid the common python bottleneck."
    },
    {
        "link": "https://doc.qt.io/qt-6/qfontmetricsf.html",
        "document": "The QFontMetricsF class provides font metrics information. More...\n\nNote: All functions in this class are reentrant.\n\n\"What's the advance width of this text?\"\n\nThe string functions include horizontalAdvance (), to return the width of a string in pixels (or points, for a printer), boundingRect (), to return a rectangle large enough to contain the rendered string, and size (), to return the size of that rectangle.\n\nFor each character, you can get its horizontalAdvance (), leftBearing (), and rightBearing (), and find out whether it is in the font using inFont (). You can also treat the character as a string, and use the string functions on it.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing (), minRightBearing () and maxWidth (). These are by necessity slow, and we recommend avoiding them if possible.\n\nThere are several functions that operate on the font: ascent (), descent (), height (), leading () and lineSpacing () return the basic size properties of the font. The underlinePos (), overlinePos (), strikeOutPos () and lineWidth () functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nQFontMetricsF functions calculate the size of characters and strings for a given font. You can construct a QFontMetricsF object with an existing QFont to obtain metrics for that font. If the font is changed later, the font metrics object is not updated.\n\nSee also QFont, QFontInfo, and QFontDatabase.\n\nThe font metrics will be compatible with the paintdevice used to create font.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nUse QFontMetricsF(const QFont &, QPaintDevice *) to get the font metrics that are compatible with a certain paint device.\n\nConstructs a font metrics object with floating point precision from the given fontMetrics object.\n\nThe font metrics will be compatible with the paintdevice passed. If the paintdevice is , the metrics will be screen-compatible, ie. the metrics you get if you use the font for drawing text on a widgets or pixmaps, not on a QPicture or QPrinter.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nDestroys the font metrics object and frees all allocated resources.\n\nReturns the ascent of the font.\n\nThe ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nReturns the average width of glyphs in the font.\n\nReturns the bounding rectangle of the character ch relative to the left-most point on the base line.\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nNote that the rectangle usually extends both above and below the base line.\n\nReturns the bounding rectangle of the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned height().\n\nSee also horizontalAdvance(), height(), and QPainter::boundingRect().\n\nReturns the bounding rectangle of the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThe height of the bounding rectangle is at least as large as the value returned height().\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and QPainter::boundingRect().\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the characters in the given text. This is the set of pixels the text would cover if drawn when constrained to the bounding rectangle specified by rect. If rect is a reference to a object, e.g. when passing a default constructed QRectF, the bounding rectangle will not constrain itself to the size.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::AlignLeft aligns to the left border, except for Arabic and Hebrew where it aligns to the right.\n• Qt::AlignRight aligns to the right border, except for Arabic and Hebrew where it aligns to the left.\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nQt::Horizontal alignment defaults to Qt::AlignLeft and vertical alignment defaults to Qt::AlignTop.\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nThese flags are defined in Qt::AlignmentFlag.\n\nIf Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts.\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe bounding rectangle returned by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nSee also horizontalAdvance(), QPainter::boundingRect(), and Qt::Alignment.\n\nReturns the cap height of the font.\n\nThe cap height of a font is the height of a capital letter above the baseline. It specifically is the height of capital letters that are flat - such as H or I - as opposed to round letters such as O, or pointed letters like A, both of which may display overshoot.\n\nReturns the descent of the font.\n\nThe descent is the distance from the base line to the lowest point characters extend to. (Note that this is different from X, which adds 1 pixel.) In practice, some font designers break this rule, e.g. to accommodate a certain character, so it is possible (though rare) that this value will be too small.\n\nIf the string text is wider than width, returns an elided version of the string (i.e., a string with \"...\" in it). Otherwise, returns the original string.\n\nThe mode parameter specifies whether the text is elided on the left (for example, \"...tech\"), in the middle (for example, \"Tr...ch\"), or on the right (for example, \"Trol...\").\n\nThe width is specified in pixels, not characters.\n\nThe flags argument is optional and currently only supports Qt::TextShowMnemonic as value.\n\nThe elide mark follows the layoutdirection. For example, it will be on the right side of the text for right-to-left layouts if the mode is , and on the left side of the text if the mode is .\n\nReturns the height of the font.\n\nThis is always equal to ascent()+descent().\n\nSee also leading() and lineSpacing().\n\nReturns the horizontal advance in pixels of text laid out using option.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis function was introduced in Qt 6.3.\n\nReturns the horizontal advance in pixels of the first length characters of text. If length is negative (the default), the entire string is used. The entire length of text is analysed even if length is substantially shorter.\n\nThe advance is the distance appropriate for drawing a subsequent character after text.\n\nThis is an overloaded function.\n\nReturns the horizontal advance of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch.\n\nSome of the metrics are described in the image to the right. The central dark rectangles cover the logical horizontalAdvance() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive.\n\nReturns if character ch is a valid character in the font; otherwise returns .\n\nReturns if the character given by ch, encoded in UCS-4/UTF-32, is a valid character in the font; otherwise returns .\n\nReturns the leading of the font.\n\nThis is the natural inter-line spacing.\n\nSee also height() and lineSpacing().\n\nReturns the left bearing of character ch in the font.\n\nThe left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also rightBearing(), minLeftBearing(), and horizontalAdvance().\n\nReturns the distance from one base line to the next.\n\nThis value is always equal to leading()+height().\n\nSee also height() and leading().\n\nReturns the width of the underline and strikeout lines, adjusted for the point size of the font.\n\nSee also underlinePos(), overlinePos(), and strikeOutPos().\n\nReturns the width of the widest character in the font.\n\nReturns the minimum left bearing of the font.\n\nThis is the smallest leftBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minRightBearing() and leftBearing().\n\nReturns the minimum right bearing of the font.\n\nThis is the smallest rightBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minLeftBearing() and rightBearing().\n\nReturns the distance from the base line to where an overline should be drawn.\n\nSee also underlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the right bearing of character ch in the font.\n\nThe right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the horizontalAdvance() of the character.\n\nSee horizontalAdvance() for a graphical description of this metric.\n\nSee also leftBearing(), minRightBearing(), and horizontalAdvance().\n\nReturns the size in pixels of the characters in the given text.\n\nThe flags argument is the bitwise OR of the following flags:\n• Qt::TextWordWrap breaks the text to fit the rectangle.\n\nThese flags are defined in the Qt::TextFlag enum.\n\nIf Qt::TextExpandTabs is set in flags, the following behavior is used to interpret tab characters in the text:\n• If tabArray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs in the text.\n• If tabStops is non-zero, it is used as the tab spacing (in pixels).\n\nNote: Despite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nReturns the distance from the base line to where the strikeout line should be drawn.\n\nSee also underlinePos(), overlinePos(), and lineWidth().\n\nSwaps this font metrics instance with other. This operation is very fast and never fails.\n\nReturns a tight bounding rectangle around the characters in the string specified by text. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0, 0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns a tight bounding rectangle around the characters in the string specified by text laid out using option. The bounding rectangle always covers at least the set of pixels the text would cover if drawn at (0,0).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the horizontalAdvance() method returns.\n\nIf you want to know the advance width of the string (to lay out a set of strings next to each other), use horizontalAdvance() instead.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nThis function was introduced in Qt 6.3.\n\nSee also horizontalAdvance(), height(), and boundingRect().\n\nReturns the distance from the base line to where an underscore should be drawn.\n\nSee also overlinePos(), strikeOutPos(), and lineWidth().\n\nReturns the 'x' height of the font. This is often but not always the same as the height of the character 'x'.\n\nThis is an overloaded function.\n\nReturns if the font metrics are not equal to the other font metrics; otherwise returns .\n\nMove-assigns other to this QFontMetricsF instance.\n\nAssigns other to this object.\n\nAssigns the font metrics fm to this font metrics object.\n\nReturns if the font metrics are equal to the other font metrics; otherwise returns .\n\nTwo font metrics are considered equal if they were constructed from the same QFont and the paint devices they were constructed for are considered to be compatible."
    },
    {
        "link": "https://web.mit.edu/~firebird/arch/sun4x_59/doc/html/qfontmetrics.html",
        "document": "The QFontMetrics class provides font metrics information. More...\n\nQFontMetrics functions calculate the size of characters and strings for a given font. There are three ways you can create a QFontMetrics object:\n• Calling the QFontMetrics constructor with a QFont creates a font metrics object for a screen-compatible font, i.e. the font cannot be a printer font*. If the font is changed later, the font metrics object is not updated.\n• QWidget::fontMetrics() returns the font metrics for a widget's font. This is equivalent to QFontMetrics(widget->font()). If the widget's font is changed later, the font metrics object is not updated.\n• QPainter::fontMetrics() returns the font metrics for a painter's current font. The font metrics object is automatically updated if you set a new painter font.\n\n* If you use a printer font the values returned will almost certainly be inaccurate. Printer fonts are not always accessible so the nearest screen font is used if a printer font is supplied.\n\nOnce created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.\n\nThere are several functions that operate on the font: ascent(), descent(), height(), leading() and lineSpacing() return the basic size properties of the font. The underlinePos(), strikeOutPos() and lineWidth() functions, return the properties of the line that underlines or strikes out the characters. These functions are all fast.\n\nThere are also some functions that operate on the set of glyphs in the font: minLeftBearing(), minRightBearing() and maxWidth(). These are by necessity slow, and we recommend avoiding them if possible.\n\nFor each character, you can get its width(), leftBearing() and rightBearing() and find out whether it is in the font using inFont(). You can also treat the character as a string, and use the string functions on it.\n\nThe string functions include width(), to return the width of a string in pixels (or points, for a printer), boundingRect(), to return a rectangle large enough to contain the rendered string, and size(), to return the size of that rectangle.\n\nSee also QFont, QFontInfo, QFontDatabase, Graphics Classes, and Implicitly and Explicitly Shared Classes.\n\nThe font must be screen-compatible, i.e. a font you use when drawing text in widgets or pixmaps, not QPicture or QPrinter.\n\nThe font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.\n\nUse QPainter::fontMetrics() to get the font metrics when painting. This is a little slower than using this constructor, but it always gives correct results because the font info data is updated.\n\nThe ascent of a font is the distance from the baseline to the highest position characters extend to. In practice, some font designers break this rule, e.g. when they put more than one accent on top of a character, or to accommodate an unusual character in an exotic language, so it is possible (though rare) that this value will be too small.\n\nIf len is negative (the default), the entire string is used.\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nNewline characters are processed as normal characters, not as linebreaks.\n\nDue to the different actual character heights, the height of the bounding rectangle of e.g. \"Yes\" and \"yes\" may be different.\n\nSee also width() and QPainter::boundingRect().\n\nReturns the bounding rectangle of the character ch relative to the left-most point on the base line.\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nNote that the rectangle usually extends both above and below the base line.\n\nReturns the bounding rectangle of the first len characters of str, which is the set of pixels the text would cover if drawn at (0, 0). The drawing, and hence the bounding rectangle, is constrained to the rectangle (x, y, w, h).\n\nIf len is negative (which is the default), the entire string is used.\n\nThe flgs argument is the bitwise OR of the following flags:\n• aligns to the left border for all languages except Arabic and Hebrew where it aligns to the right.\n• aligns to the right border.\n• breaks the text to fit the rectangle.\n\nHorizontal alignment defaults to and vertical alignment defaults to .\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nThese flags are defined in qnamespace.h.\n\nIf is set in flgs, then: if tabarray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabstops is non-zero, it is used as the tab spacing (in pixels).\n\nNote that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover all pixels in the bounding rectangle.\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe bounding rectangle given by this function is somewhat larger than that calculated by the simpler boundingRect() function. This function uses the maximum left and right font bearings as is necessary for multi-line text to align correctly. Also, fontHeight() and lineSpacing() are used to calculate the height, rather than individual character heights.\n\nThe intern argument should not be used.\n\nSee also width(), QPainter::boundingRect(), and Qt::AlignmentFlags.\n\nThe whole string is needed, as the glyph drawn may change depending on the context (the letter before and after the current one) for some languages (e.g. Arabic).\n\nThis function also takes non spacing marks and ligatures into account.\n\nThe descent is the distance from the base line to the lowest point characters extend to. (Note that this is different from X, which adds 1 pixel.) In practice, some font designers break this rule, e.g. to accommodate an unusual character in an exotic language, so it is possible (though rare) that this value will be too small.\n\nThis is always equal to ascent()+descent()+1 (the 1 is for the base line).\n\nSee also leading() and lineSpacing().\n\nThis is the natural inter-line spacing.\n\nSee also height() and lineSpacing().\n\nThe left bearing is the right-ward distance of the left-most pixel of the character from the logical origin of the character. This value is negative if the pixels of the character extend to the left of the logical origin.\n\nSee width(QChar) for a graphical description of this metric.\n\nSee also rightBearing(), minLeftBearing(), and width().\n\nThis value is always equal to leading()+height().\n\nSee also height() and leading().\n\nSee also underlinePos() and strikeOutPos().\n\nThis is the smallest leftBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minRightBearing() and leftBearing().\n\nThis is the smallest rightBearing(char) of all characters in the font.\n\nNote that this function can be very slow if the font is large.\n\nSee also minLeftBearing() and rightBearing().\n\nThe right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the width() of the character.\n\nSee width() for a graphical description of this metric.\n\nSee also leftBearing(), minRightBearing(), and width().\n\nIf len is negative (the default), the entire string is used.\n\nThe flgs argument is the bitwise OR of the following flags:\n• breaks the text to fit the rectangle.\n\nThese flags are defined in qnamespace.h.\n\nIf is set in flgs, then: if tabarray is non-null, it specifies a 0-terminated sequence of pixel-positions for tabs; otherwise if tabstops is non-zero, it is used as the tab spacing (in pixels).\n\nDespite the different actual character heights, the heights of the bounding rectangles of \"Yes\" and \"yes\" are the same.\n\nThe intern argument should not be used.\n\nSee also underlinePos() and lineWidth().\n\nSee also strikeOutPos() and lineWidth().\n\nNote that this value is not equal to boundingRect().width(); boundingRect() returns a rectangle describing the pixels this string will cover whereas width() returns the distance to where the next string should be drawn.\n\nReturns the logical width of character ch in pixels. This is a distance appropriate for drawing a subsequent character after ch.\n\nSome of the metrics are described in the image to the right. The central dark rectangles cover the logical width() of each character. The outer pale rectangles cover the leftBearing() and rightBearing() of each character. Notice that the bearings of \"f\" in this particular font are both negative, while the bearings of \"o\" are both positive.\n\nWarning: This function will produce incorrect results for Arabic characters or non spacing marks in the middle of a string, as the glyph shaping and positioning of marks that happens when processing strings cannot be taken into account. Use charWidth() instead if you aren't looking for the width of isolated characters.\n\nSee also boundingRect() and charWidth().\n\nThis is an overloaded member function, provided for convenience. It behaves essentially like the above function.\n\nThis function is obsolete. It is provided to keep old source working. We strongly advise against using it in new code.\n\nThis file is part of the Qt toolkit. Copyright © 1995-2003 Trolltech. All Rights Reserved."
    }
]