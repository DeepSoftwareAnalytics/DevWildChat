[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-numerics-complex",
        "document": "This article provides supplementary remarks to the reference documentation for this API.\n\nA complex number is a number that comprises a real number part and an imaginary number part. A complex number z is usually written in the form , where x and y are real numbers, and i is the imaginary unit that has the property i2 = -1. The real part of the complex number is represented by x, and the imaginary part of the complex number is represented by y.\n\nThe Complex type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers. A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane. The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).\n\nAny point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system. In polar coordinates, a point is characterized by two numbers:\n• Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).\n• Its phase, which is the angle between the real axis and the line drawn from the origin to the point.\n\nYou can assign a value to a complex number in one of the following ways:\n• None By passing two Double values to its constructor. The first value represents the real part of the complex number, and the second value represents its imaginary part. These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.\n• None By calling the static ( in Visual Basic) Complex.FromPolarCoordinates method to create a complex number from its polar coordinates.\n• None By assigning a Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, or Double value to a Complex object. The value becomes the real part of the complex number, and its imaginary part equals 0.\n• None By casting (in C#) or converting (in Visual Basic) a Decimal or BigInteger value to a Complex object. The value becomes the real part of the complex number, and its imaginary part equals 0.\n• None By assigning the complex number that is returned by a method or operator to a Complex object. For example, Complex.Add is a static method that returns a complex number that is the sum of two complex numbers, and the Complex.Addition operator adds two complex numbers and returns the result.\n\nThe following example demonstrates each of these five ways of assigning a value to a complex number.\n\nThe Complex structure in .NET includes members that provide the following functionality:\n• Methods to compare two complex numbers to determine whether they are equal.\n• Operators to perform arithmetic operations on complex numbers. Complex operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.\n• Methods to perform other numerical operations on complex numbers. In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.\n• Methods to perform trigonometric operations on complex numbers. For example, you can calculate the tangent of an angle represented by a complex number.\n\nNote that, because the Real and Imaginary properties are read-only, you cannot modify the value of an existing Complex object. All methods that perform an operation on a Complex number, if their return value is of type Complex, return a new Complex number.\n\nThe real and imaginary parts of a complex number are represented by two double-precision floating-point values. This means that Complex values, like double-precision floating-point values, can lose precision as a result of numerical operations. This means that strict comparisons for equality of two Complex values may fail, even if the difference between the two values is due to a loss of precision. For more information, see Double.\n\nFor example, performing exponentiation on the logarithm of a number should return the original number. However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.\n\nSimilarly, the following example, which calculates the square root of a Complex number, produces slightly different results on the 32-bit and IA64 versions of .NET.\n\nThe real and imaginary parts of a complex number are represented by Double values. In addition to ranging from Double.MinValue to Double.MaxValue, the real or imaginary part of a complex number can have a value of Double.PositiveInfinity, Double.NegativeInfinity, or Double.NaN. Double.PositiveInfinity, Double.NegativeInfinity, and Double.NaN all propagate in any arithmetic or trigonometric operation.\n\nIn the following example, division by Zero produces a complex number whose real and imaginary parts are both Double.NaN. As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are Double.NaN. Similarly, performing a multiplication that overflows the range of the Double type produces a complex number whose real part is Double.NaN and whose imaginary part is Double.PositiveInfinity. Subsequently performing division with this complex number returns a complex number whose real part is Double.NaN and whose imaginary part is Double.PositiveInfinity.\n\nMathematical operations with complex numbers that are invalid or that overflow the range of the Double data type do not throw an exception. Instead, they return a Double.PositiveInfinity, Double.NegativeInfinity, or Double.NaN under the following conditions:\n• The division of a positive number by zero returns Double.PositiveInfinity.\n• Any operation that overflows the upper bound of the Double data type returns Double.PositiveInfinity.\n• The division of a negative number by zero returns Double.NegativeInfinity.\n• Any operation that overflows the lower bound of the Double data type returns Double.NegativeInfinity.\n• The division of a zero by zero returns Double.NaN.\n• Any operation that is performed on operands whose values are Double.PositiveInfinity, Double.NegativeInfinity, or Double.NaN returns Double.PositiveInfinity, Double.NegativeInfinity, or Double.NaN, depending on the specific operation.\n\nNote that this applies to any intermediate calculations performed by a method. For example, the multiplication of new Complex(9e308, 9e308) and new Complex(2.5, 3.5) uses the formula (ac - bd) + (ad + bc)i. The calculation of the real component that results from the multiplication evaluates the expression 9e308 2.5 - 9e308 3.5. Each intermediate multiplication in this expression returns Double.PositiveInfinity, and the attempt to subtract Double.PositiveInfinity from Double.PositiveInfinity returns Double.NaN.\n\nBy default, the string representation of a complex number takes the form real imaginary , where real and imaginary are the string representations of the Double values that form the complex number's real and imaginary components. Some overloads of the ToString method allow customization of the string representations of these Double values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string. (For more information, see Standard Numeric Format Strings and Custom Numeric Format Strings.)\n\nOne of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component. In electrical engineering, a complex number is most commonly expressed as a + bj. You can return the string representation of a complex number in either of these two forms. To do this, define a custom format provider by implementing the ICustomFormatter and IFormatProvider interfaces, and then call the String.Format(IFormatProvider, String, Object[]) method.\n\nThe following example defines a class that represents a complex number as a string in the form of either a + bi or a + bj.\n\nThe following example then uses this custom formatter to display the string representation of a complex number."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.numerics.complex?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nFor more information about this API, see Supplemental API remarks for Complex.\n\nGets the additive identity of the current type. Gets the multiplicative identity of the current type. Computes the absolute of a value. Determines if a value is in its canonical representation. Determines if a value is zero. Compares two values to compute which has the greater magnitude and returning the other value if an input is . Compares two values to compute which has the lesser magnitude and returning the other value if an input is . Gets the value for the type. Gets the radix, or base, for the type. Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type. Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type. Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type. Gets the value for the type. Gets the value for the type."
    },
    {
        "link": "https://github.com/microsoft/referencesource/blob/master/System.Numerics/System/Numerics/Complex.cs",
        "document": "** This feature is intended to create Complex Number as a type\n\n** that can be a part of the .NET framework (base class libraries).\n\n** A complex number z is a number of the form z = x + yi, where x and y\n\n** are real numbers, and i is the imaginary unit, with the property i2= -1.\n\n// Using the above we can factor out the square of the larger component to dodge overflow.\n\n// c is either 0.0 or NaN\n\n// Conjugate of a Complex number: the conjugate of x+i*y is x-i*y\n\n// Reciprocal of a Complex number : the reciprocal of x+i*y is 1/(x+i*y)\n\n/* Log of the complex number value to the base of 'e' */"
    },
    {
        "link": "https://numerics.mathdotnet.com/api/MathNet.Numerics/Complex32.htm",
        "document": "The class provides all elementary operations on complex numbers. All the operators , , , , , are defined in the canonical way. Additional complex trigonometric functions are also provided. Note that the structures has two special constant values NaN and PositiveInfinity. For mathematical details about complex numbers, please have a look at the\n\nThe string representation of the current instance in Cartesian form, as specified by and . Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts."
    },
    {
        "link": "https://github.com/mathnet/mathnet-numerics/blob/master/src/Numerics/Complex32.cs",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/how-to-handle-user-input-events-in-windows-forms-controls?view=netframeworkdesktop-4.8",
        "document": "How to: Handle User Input Events in Windows Forms Controls\n\nThis example demonstrates how to handle most keyboard, mouse, focus, and validation events that can occur in a Windows Forms control. The text box named receives the events when it has focus, and information about each event is written in the text box named in the order in which the events are raised. The application also includes a set of check boxes that can be used to filter which events to report.\n• References to the System, System.Drawing and System.Windows.Forms assemblies."
    },
    {
        "link": "https://stackoverflow.com/questions/183589/best-practice-for-exception-handling-in-a-windows-forms-application",
        "document": "The main things I'm currently trying to work out are:\n\nWould anyone like to share any pearls of wisdom on the subject? Post any common mistakes you've seen newbies like myself make, and any general advice on handling exceptions in a way that will my application more stable and robust.\n\nI'm currently in the process of writing my first Windows Forms application. I've read a few C# books now so I've got a relatively good understanding of what language features C# has to deal with exceptions. They're all quite theoretical however so what I haven't got yet is a feel for how to translate the basic concepts into a good exception-handling model in my application.\n\nYou absolutely should have a centralized exception handling policy in place. This can be as simple as wrapping in a try/catch, failing fast with a graceful error message to the user. This is the \"last resort\" exception handler. Preemptive checks are always correct if feasible, but not always perfect. For example, between the code where you check for a file's existence and the next line where you open it, the file could have been deleted or some other issue may impede your access. You still need try/catch/finally in that world. Use both the preemptive check and the try/catch/finally as appropriate. Never \"swallow\" an exception, except in the most well-documented cases when you are absolutely, positively sure that the exception being thrown is livable. This will almost never be the case. (And if it is, make sure you're swallowing only the specific exception class -- don't ever swallow .) When building libraries (used by your app), do not swallow exceptions, and do not be afraid to let the exceptions bubble up. Do not re-throw unless you have something useful to add. Do not ever (in C#) do this: As you will erase the call stack. If you must re-throw (which is occasionally necessary, such as when using the Exception Handling Block of Enterprise Library), use the following: At the end of the day, the very vast majority of exceptions thrown by a running application should be exposed somewhere. They should not be exposed to end users (as they often contain proprietary or otherwise valuable data), but rather usually logged, with administrators notified of the exception. The user can be presented with a generic dialog box, maybe with a reference number, to keep things simple. Exception handling in .NET is more art than science. Everyone will have their favorites to share here. These are just a few of the tips I've picked up using .NET since day 1, techniques which have saved my bacon on more than one occasion. Your mileage may vary.\n\nAll of the advice posted here so far is good and worth heeding. One thing I'd like to expand on is your question \"Do handling exceptions which might be thrown have a performance hit compared with pre-emptively testing things like whether a file on disk exists?\" The naive rule of thumb is \"try/catch blocks are expensive.\" That's not actually true. Trying isn't expensive. It's the catching, where the system has to create an Exception object and load it up with the stack trace, that's expensive. There are many cases in which the exception is, well, exceptional enough that it's perfectly fine to wrap the code in a try/catch block. For instance, if you're populating a Dictionary, this: is often faster than doing this: for every single item you're adding, because the exception only gets thrown when you are adding a duplicate key. (LINQ aggregate queries do this.) In the example you gave, I'd use try/catch almost without thinking. First, just because the file exists when you check for it doesn't mean that it's going to exist when you open it, so you should really handle the exception anyway. Second, and I think more importantly, unless your a) your process is opening thousands of files and b) the odds of a file it's trying to open not existing are not trivially low, the performance hit of creating the exception is not something you're ever going to notice. Generally speaking, when your program is trying to open a file, it's only trying to open one file. That's a case where writing safer code is almost certainly going to be better than writing the fastest possible code.\n\nHere are a few guidelines that I follow\n• None Fail-Fast: This is more of a exception generating guideline, For every assumption that you make and every parameter that you are getting into a function do a check to make sure that you're starting off with the right data and that the assumptions you're making are correct. Typical checks include, argument not null, argument in expected range etc.\n• None When rethrowing preserve stack trace - This simply translates to using throw when rethrowing instead of throw new Exception(). Alternatively if you feel that you can add more information then wrap the original exception as an inner exception. But if you're catching an exception only to log it then definitely use throw;\n• None Do not catch exceptions that you cannot handle, so don't worry about things like OutOfMemoryException because if they occur you won't be able to do much anyways.\n• None Do hook global exception handlers and make sure to log as much information as possible. For winforms hook both the appdomain and thread unhandled exception events.\n• None Performance should only be taken into consideration when you've analyzed the code and seen that it's causing a performance bottleneck, by default optimize for readability and design. So about your original question on the file existence check, I would say it depends, If you can do something about the file not being there, then yes do that check otherwise if all you're going to do is throw an exception if the file's not there then I don't see the point.\n• None There are definitely times when empty catch blocks are required, I think people who say otherwise have not worked on codebases that have evolved over several releases. But they should be commented and reviewed to make sure that they're really needed. The most typical example is developers using try/catch to convert string to integer instead of using ParseInt().\n• None If you expect the caller of your code to be able to handle error conditions then create custom exceptions that detail what the un excepected situation is and provide relevant information. Otherwise just stick to built-in exception types as much as possible.\n\nThe golden rule that have tried to stick to is handle the exception as close to the source as possible. If you must re-throw an exception try to add to it, re-throwing a FileNotFoundException does not help much but throwing a ConfigurationFileNotFoundException will allow it to be captured and acted upon somewhere up the chain. Another rule I try to follow is not to use try/catch as a form of program flow, so I do verify files/connections, ensure objects have been initiated, ect.. prior to using them. Try/catch should be for Exceptions, things you can not control. As for an empty catch block, if you are doing anything of importance in the code that generated the exception you should re-throw the exception at a minimum. If there is no consequences of the code that threw the exception not running why did you write it in the first place.\n\nYou have to think about the user. The application crash is the last thing the user wants. Therefore any operation that can fail should have a try catch block at the ui level. It's not necessary to use try catch in every method, but every time the user does something it must be able to handle generic exceptions. That by no means frees you from checking everything to prevent exceptions in the first case, but there is no complex application without bugs and the OS can easily add unexpected problems, therefore you must anticipate the unexpected and make sure if a user wants to use one operation there won't be data loss because the app crashes. There is no need to ever let your app crash, if you catch exceptions it will never be in an indeterminate state and the user is ALWAYS inconvenienced by a crash. Even if the exception is at the top most level, not crashing means the user can quickly reproduce the exception or at least record the error message and therefore greatly help you to fix the problem. Certainly a lot more than getting a simple error message and then seeing only windows error dialog or something like that. That's why you must NEVER just be conceited and think your app has no bugs, that is not guaranteed. And it is a very small effort to wrap some try catch blocks about the appropriate code and show an error message / log the error. As a user, I certainly get seriously pissed whenever a brows or office app or whatever crashes. If the exception is so high that the app can't continue it's better to display that message and tell the user what to do (restart, fix some os settings, report the bug, etc.) than to simply crash and that's it."
    },
    {
        "link": "https://stackoverflow.com/questions/11146099/best-practice-with-common-event-handling",
        "document": "In a WinForms solution, you have multiple controls of the same type. You need to add an event handler to each of the control and at the current time the event handler will be doing the same thing. You do not expect there to be difference between them down the road any reason.\n\nNow is it better to sharing an single Event Handler between the different events as shown below or use different ones like in the code sample shown above?\n\nIn the following page, Microsoft seems to suggest that sharing is better, however I notice that they have not updated it since .NET 2.0 (ie: Visual Studio 2008)\n\nIs there a Guide that makes a best practices recommendation in this case?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/apps/get-started/best-practices",
        "document": "The best practices in this document will help you build great Windows apps that reach and delight ~1.5 billion diverse PC users around the world. This document is divided into the following sections:\n• User experience: Guidance in this section will help you improve the look, feel, and usability of your apps.\n• Performance and fundamentals: Guidance in this section will help you improve your app's performance and resource utilization.\n• Operating system / hardware optimization: Guidance in this section will help you optimize your packaging and distribution for a variety of hardware configurations.\n• Application discovery and management: Guidance in this section will make it easier for users to discover, install, update, and uninstall your app.\n• Accessibility: Guidance in this section will help you build accessible and inclusive experiences.\n• Security and privacy: Guidance in this section will help you mitigate security risks and meet your users' privacy needs.\n\nWindows 11 marks a visual evolution of the Windows operating system that improves the look, feel, and usability of Windows. Our studies show that users have high expectations for Windows apps:\n• They expect Windows apps to work with a complete range of inputs.\n• They expect design and interaction patterns that look and feel native on current and future devices.\n• They expect support for modern windowing workflows and shell integration points.\n\nWhen applications adhere to Windows styles and standard Windows behaviors, users don't have to re-learn interaction patterns. This makes it much easier for users to use your app. An app that looks great can create a great first impression, but an app that's also easy to use and helps the user accomplish their goals will create a great lasting impression.\n\nWindows 11 is built on the Windows 11 design principles. Following these guidelines as you build your apps will help you meet your customers' expectations of a great app experience. When thinking about incorporating the latest and recommended Windows application UI/UX patterns into your Windows applications, we recommend that you focus on these 5 areas:\n\nWinUI 3 provides built-in support for many of these experiences and styles through its common controls. If you aren't able to use WinUI 3, consider emulating the styles demonstrated in our design toolkits and WinUI Gallery.\n\nWindows applications run on a variety of configurations that match users' needs. Test your application's panes and/or pages across a variety of dimensions, devices, window sizes, DPI settings, and scale settings. Your application should work as expected even when resized down to small dimensions.\n\nWinUI applications automatically scale for each display that they're running on. Other Windows programming technologies (Win32, WinForms, WPF, etc.) don't automatically handle per-monitor DPI scaling. Without additional work to support per-monitor DPI scaling for these technologies, applications may appear blurry or incorrectly-sized. See High DPI Desktop Application Development on Windows for more information.\n\nUse responsive design techniques to optimize your app pages for different window sizes. Follow the guidelines for panning or scrolling to ensure that users can always access your content, no matter how small the app window gets.\n\nWindows users can choose from a wide variety of input devices to interact with your application, and Windows has specific system experiences that people are accustomed to using. When your application adheres to these experiences, your users can use your application reliably. When your app doesn't follow these conventions, users may find it confusing or frustrating.\n\nUse on-object commanding such as context menus, swipe commands, and keyboard shortcuts. Windows 11 improves the behavior of the right-click context menu, so if your app creates context menus, refer to the latest context menu integration guidance. WinUI text controls automatically expose cut/copy/paste commands, but other controls may need extra work to support these commands.\n\nWhenever there is text in an application, users expect that they can select and copy it. If the text is editable, they expect that they can cut and paste, as well. By providing consistent shortcuts to users, you let them complete their tasks more efficiently. Ensure that these actions can be performed using keyboard, mouse or trackpad, touch, and pen.\n\nIt is uncommon for an application's UI to fit entirely inside a single page that does not need to scroll. Even if there are only a few UI elements, users can freely resize the app Window and cause some UI elements to be hidden. Ensure that your application's UI properly supports scrolling and panning (using keyboard, mouse or trackpad, touch, and pen) to let users access any UI elements that might have moved out of the visible window area.\n\nWindows 11 is built on the Windows 11 design principles: Effortless, Calm, Personal, Familiar, and Complete + Coherent. We believe experiences that follow these principles bring great user experiences on Windows.\n\nAcrylic and Mica are visual materials that give interactive UI controls a distinct \"occluded\" visual style. Use Acrylic to apply a semi-transparent style to transient surfaces like context menus, flyouts, and other elements that can be light-dismissed. Use Mica to add a subtle adaptive tint to long-lived UI surfaces like the title bar.\n\nMore information about Acrylic and Mica materials can be found in Things you can do to make your app great on Windows 11.\n\nDark and Light themes give users a way to adapt your app to their visual preferences. Windows 11 updates the color tones to be softer on the eyes by avoiding pure white and black, which makes the colors much more delightful. WinUI supports switching between Dark and Light themes by default (see XAML theme resources). For Win32 apps, see Support Dark and Light themes in Win32 apps. (The title bar in Win32 apps does not automatically adapt to the Dark theme. Be sure to follow the title bar guidance in the article).\n\nWindows 11 geometry has been crafted to support modern app experiences. Progressively rounded corners, nested elements, and consistent gutters combine to create a soft, calm, and approachable effect that emphasizes unity of purpose and ease of use.\n\nThe visual and behavioral changes are built in to WinUI 3. Use WinUI 3 where you can to take advantage of the work that has already been done. If you aren't able to use WinUI 3, consider emulating the styles demonstrated in our design toolkits and WinUI Gallery.\n\nA context menu is a shortcut menu that the user invokes with a right-click or tap & hold action to reveal a menu of commands relevant to the context of the control the user is interacting with. Users expect the appearance and behavior of context menus to be coherent across Windows. Use platform-provided context menus whenever possible to keep them consistent with the rest of the system.\n\nWindows 11 has updated icons (\"Segoe Fluent Icons\"), improved support for animated icons, and a new UI font (\"Segoe UI Variable\"). We recommend that you use these new icons and font whenever possible to be coherent on Windows 11. The new font brings much softer geometry and makes the text much more legible.\n\nMore information about iconography and typography on Windows can be found in Things you can do to make your app great on Windows 11.\n\nApplications run in a frame provided by Windows, and users expect the built-in Windows look and behaviors to be consistent across app windows. Consider supporting the features listed here to ensure that your app looks and functions as users expect on Windows 11.\n\nWindow snapping is greatly enhanced in Windows 11, and the Snap Layout menu is a new feature to help users discover and use the power of window snapping. Use the Snap Layout menu to test your app in different Snap Layouts and ensure your app supports different snap sizes, like 1/2, 1/3, and 1/4 screen.\n\nIf the Snap Layout menu doesn't appear for your app by default, see Support snap layouts for desktop apps on Windows 11 for some steps you can take to enable it.\n\nThe title bar and caption buttons (minimize, maximize, close) are how users interact with Windows to resize, move, and close app windows. Having a consistent experience will help people use your application smoothly. See Windows app title bar to learn about title bar and caption button design for Windows.\n\nYou can use the Windows App SDK APIs to integrate app content with the title bar in WinUI 3, .NET, WinForms, and WPF apps.\n\nIn most cases, your app's window will have rounded corners by default on Windows 11. If you've customized your app window and don't have rounded corners, see Apply rounded corners in desktop apps for Windows 11 for some things you can do. You should also avoid customizing window borders and shadows, which can prevent the system from rounding the window corners.\n\nWindows shell integration lets users benefit from your app even when its not running in the foreground or even visible on-screen. When your app integrates well with Windows, it becomes part of the users workflow with other apps and helps create a seamless experience.\n\nToast notifications are the Windows notifications that appear at the bottom of the user's screen and in the Notification Center.\n• Notifications should be personalized, actionable, and useful to your users. Try to give your users what they want, not what you want them to know.\n• Notifications shouldn't be noisy. Too many interruptions from your app leads to users turning off this critical communication channel for your app.\n• Respond to the user's intent. Selecting a notification should launch your app in the notification's context. The only exception to this guideline is when the user selects a button on your notification that's attached to a background task, such as a quick reply.\n• Provide a consistent Notification Center experience. Keep Notification Center tidy by clearing out old notifications.\n\nFor more information about toast notifications, see Notifications design basics.\n\nWindows users expect Windows apps to exhibit great performance and fundamentals. As you design and build your app, it is important to keep in mind optimizing for memory usage, power consumption, responsiveness, reliability, and the impact on long-term sustainability. Allocating time to test and measure your application's fundamentals and performance will ensure that your users have a first-class experience.\n\nFollowing the best practices in this section will help you meet your customers' expectations across these criteria.\n• \n• Release resources while in the background.\n• Ensure your application does not leak memory.\n• None Make efficient use of the disk footprint:\n• \n• Do not wake the CPU or use system resources while in the background.\n• None Improve the responsiveness of your app's launch and key interactions\n• Define your key interaction scenarios and add ETW events to measure.\n• Set goals based on the interaction class associated with user expectations.\n\nTo learn more, see the Performance and fundamentals overview, which will cover questions such as \"What is application performance and why is it important?\" or \"What tools can I use to measure Windows application performance?\", as well as linking to case studies, related blogs, support communities, and information on how performance engineering intersects with sustainability--reducing the impact your application will have on our planet.\n\nWindows apps can be built, packaged, and delivered in a variety of ways. The best practices in this section will help you optimize these aspects of your application across hardware configurations.\n\nIf you want your app to run best in an enterprise environment, add support for MSIX app attach.\n\nMSIX app attach lets you deliver MSIX applications to both physical and virtual machines. It's made specifically for Azure Virtual Desktop (AVD), a desktop and app virtualization service that runs on the cloud. Using MSIX app attach with AVD can help you improve sign-in times for users, and it can reduce infrastructure costs for your enterprise.\n\nWindows can run on Arm devices. Arm PCs benefit from extended battery life and integrated support for mobile data networks. These PCs also provide great application compatibility and allow you to run your existing and applications unmodified.\n\nFor best performance, you should enable your apps to take full advantage of the energy-efficient Arm processor architecture by either building a full Arm version or by optimizing the parts of the codebase that would benefit most from native performance. For more information on these techniques, refer to Windows on Arm and Arm64EC for Windows 11 apps on Arm.\n\nPush notifications allow you send information from your cloud service to your app in a performance-optimized way. Push notifications include raw notifications, badge notifications, and toast notifications sent from your cloud service.\n• Use push notifications to wake up the app/client rather than always keeping it running to optimize performance on the user's device.\n• Notification channels are not meant to be used to send advertisements.\n• Respect headers – this protects our service and ensures notification delivery success.\n• Remove expired/revoked channels from the system. Windows Notification Service (WNS) does not process requests for expired/revoked channels.\n• Avoid sudden, large bursts of requests to WNS. This can lead to throttled responses.\n• Utilize the header. This will help with end-to-end traceability and diagnostics.\n• Have a back-up mechanism for when notifications don't work.\n• Use Azure Notification Hubs (ANH). ANH gives you access to engagement features like targeting audiences, scheduling notifications, and broadcasting notifications. If you're a Windows-only developer today, using ANH will make it easy for you to transition your notifications infrastructure to other platforms in the future.\n\nReliable installation, update, and uninstallation experiences are important pieces of a consistent, high-quality user experience. The following best practices will help ensure that your application leaves a good impression when discovered and managed by users:\n• Listing your app on Microsoft Store can make your app more discoverable for users.\n• If you're hosting your app across multiple channels (for example - on a website and on the Microsoft Store), your application should have a consistent application identity and update mechanism across all channels.\n• Distribute your app through the Microsoft Store to make it more discoverable for users. Note that Store apps are made available to users through the Windows Package Manager WinGet. If you don't publish to the Microsoft Store, you can still make your app easily discoverable in WinGet via the WinGet repository.\n• Support a per-user install. This will enable users to install more easily and avoid UAC prompts.\n• Ensure that your application's installation is error free, transparent, and thoughtful about its file management. Your application's installation shouldn't leave any temporary files behind.\n• Avoid requiring elevated permissions to install and requiring operating system reboots when possible.\n• Support silent installation. This is important for app manageability in enterprise environments.\n• Ensure your app is listed in the Apps -> Installed Apps list.\n• Consider using MSIX to ensure that users experience a seamless installation, update, and uninstallation experience. MSIX automatically removes the app binaries and data. For information about how packaged apps handle files and registry entries, see Understanding how packaged desktop apps run on Windows.\n• For unpackaged apps, ensure that your application can be easily uninstalled through the Apps -> Installed Apps list in Settings. When your application is uninstalled, ensure that Start menu entries, files, directories, registry entries, and temporary files are also removed. Consider giving your users the option to preserve their data when they uninstall your application.\n• Ensure that during uninstallation your app removes all binaries and application data. User-created content should be stored in locations like , which can then be retained by users even after the app is uninstalled.\n• Avoid installing or updating system binaries that may require a reboot.\n• Integrate with RestartManager to save and restore state between OS updates.\n• Support an update mechanism that allows your app to restart when its convenient for the user. Consider using the Windows App SDK Restart APIs to manage app behavior for WinUI 3 apps.\n• Ensure that your update mechanism downloads only the essential changed components that need to be updated. This can minimize the network bandwidth required.\n• Ensure that you provide a way to update and repair your app. Consider MSIX, which automatically handles update repair. For more information, see Auto-update and repair apps.\n• Consider push notification-based updates or checking for available updates at app startup or at restart.\n\nAccessible Windows applications support rich and inclusive experiences for as many people as possible, including those with disabilities (both temporary and permanent), personal preferences, specific work styles, or situational constraints (such as shared work spaces, driving, cooking, glare, and so on).\n\nIn fact, the World Health Organization defines disability not as a personal characteristic, but rather as a mismatched interaction between a person and the physical and digital world around them.\n\nIncorporating accessibility into your Windows apps can maximize user engagement, increase product satisfaction, and encourage product loyalty. Proactively designing and implementing accessible experiences typically results in reduced development and maintenance costs over the long-term.\n\nFor detailed guidance on building accessible Windows apps, see Accessibility in Windows 11 and Windows 10.\n\nAccessibility Insights is a powerful suite of tools for developers to test the accessibility of their apps and services. Here are some tools to leverage in testing accessibility:\n• Inspect in Accessibility Insights for Windows. Inspect the accessibility tree to find low-hanging fruit like hints in labels, incorrect roles, etc.\n• Event monitoring in Accessibility Insights for Windows · Accessibility Insights. See Supporting UI Automation Control Types for more info on event monitoring.\n• Run Accessibility Insights automated checks in your PRs or CI/CD. For more info, see axe-pipelines-samples.\n• Fix all bugs you find, they all have direct impact on accessibility.\n\nAn insecure application can be an entry point that allows an attacker to perform malicious activities. Even if your app doesn't have security bugs, attackers can use your app to initiate their attacks through phishing and other forms of social engineering that violate security and privacy boundaries. The best practices in this section will help you mitigate risks related to security and user privacy.\n• Follow the Security Development Lifecycle for all development.\n• Threat modeling can help you avoid security flaws.\n• Don't require administrative privileges to install your app.\n• Ideally, your app should support both administrative installs and per-user installs.\n• Using MSIX packaging is one way to achieve this.\n• Don't require administrative privileges to run your app.\n• If there are certain features that need administrative privileges, consider separating them into their own processes to reduce attack surface.\n• Prefer to use languages with guaranteed memory safety (such as C#, JavaScript, or Rust), especially for risky code paths (like parsing untrusted data).\n• Use all security mitigations provided by your compiler and toolset (see Security Features In Microsoft Visual C++ for Visual C++).\n• Always use your chosen language or framework's standard libraries for cryptography and other security-sensitive code. Do not try to build your own.\n• Digitally sign all components of your application – not just the installer, but also the uninstaller (if you have one). Also sign all the EXE, DLL, and other executable files that make up your app.\n• Digital signatures enable the user to verify the authenticity of your app and allow Enterprise admins to secure their devices using Windows Defender Application Control.\n• Using MSIX packaging is one way to achieve this.\n• Ensure all network communication is over a secure transport, such as SSL.\n• Provide guardrails or other mitigations that can help protect users from accidentally performing harmful actions, even when coerced into doing so by attackers.\n• Simple \"Are you sure you want to do X? Yes / No\" dialogs are typically not effective, because users have been conditioned to click \"Yes.\"\n\nMost modern apps collect and use a large amount of data – including personal data – for various reasons. Telemetry, product improvement, and monetization are three common reasons for using data, but users and regulators alike are becoming more sensitive to the privacy implications of these practices. They expect transparency and control over the data collected and used by apps. Use the following tips to help meet the privacy needs of your users.\n• Ensure that your app provides an accurate Privacy Policy. Ideally, provide both a summary document written for a casual audience (your users) in addition to a long-form legal policy (written for your lawyers).\n• Familiarize yourself with privacy regulations in the markets where your app will be available, and ensure your app meets or exceeds any requirements for disclosure, usage rights, deletion requests, etc.\n• Ensure you're collecting the least amount of personal data needed to complete your app's experiences.\n• Don't collect data \"just in case\" – there should be a valid reason for collecting all data, e.g. to improve the customer's experience or to facilitate monetization.\n• Always get the user's consent before collecting and storing personal data and provide the user with an easy way to revert their decision in the future. Avoid \"dark patterns\" such as making the \"Yes\" button larger or more prominent than the \"No\" button in a consent dialog.\n• Consult with applicable regulations to determine what specific disclosures and consent is required for specified kinds of data. For example, some regions may allow users to view, change, or delete the data you have stored about them.\n• If you must transmit data over the network, always use secured connections, e.g. over TLS.\n• Avoid storing personal data in a centralized location (e.g. website). If you must store personal data, minimize the amount of data you store, store it only for as long as strictly necessary, and ensure it is securely encrypted.\n• Verify that any 3rd-party libraries or SDKs you use also have good privacy practices. Note this is not limited to just advertising SDKs – any library that connects to the internet may impact the privacy of your app's users.\n• Things you can do to make your app great on Windows 11"
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2002/august/advanced-basics-best-practices-for-windows-forms-applications",
        "document": "Q I'm just about to begin development of my first .NET Windows® Forms application. What are the guidelines I should follow to make my application scalable and efficient?\n\n \n\n A There are several best practices you can follow. Many of the guidelines apply to most development while others are specific to Windows Forms because of the technologies available. Here are some of the most important ones.\n\n Adopt a naming convention You should decide on the naming conventions you are going to use before you begin your project. The Microsoft® .NET Framework contains a number of suggestions on naming conventions. For instance, you can find Visual Basic® naming convention suggestions at this location in the docs:\n\n Some folks believe that these guidelines are the only ones to use, but I disagree. First, it is far more important to decide on and adhere to a set of naming conventions than to limit yourself to a particular one. Second, it is important to think through the impact of the naming conventions you use. For instance, I still like to prefix control names with the type of control because I can type \"txt\" in the code editor, press Ctrl+Space, and get a list of all the textbox controls on a form, for example. As a result, the naming conventions have an impact on your programming efficiency, and more importantly, on the ability to maintain your code.\n\n Use n-tier concepts Two key techniques in n-tier development, coupling and cohesion, influence code reuse.\n\n Coupling defines how tightly a particular piece of code is tied to another piece of code, and the rule of thumb is that it should be loosely coupled. For instance, if you have a control named txtCustomer on a form, you should never have a direct reference to txtCustomer in a block of code that provides any type of business or generic functionality. In other words, the code should not be tied directly to that textbox; instead it should be passed the value to the textbox or a reference to the textbox.\n\n It is recommended that each block of code be highly specific. For instance, instead of having a block of code named UpdateCustomerOrderAndProducts, you should have functions named UpdateCustomer, UpdateOrder, and UpdateProducts. This concept is well illustrated in the .NET Framework; in many areas (such as ADO.NET), functions were factored out to make each as task-specific as possible. For example, the Command class has methods named ExecuteNonQuery and ExecuteScalar instead of simply having an Execute method which takes parameters to direct the method's behavior.\n\n Both of these concepts lead to an n-tier design in which the application is broken apart into layers. Visual Studio® .NET and the .NET Framework make this design much easier to implement because they make it simpler to create and implement classes, component design surfaces, and so forth.\n\n Use inheritance for extensibility and maintainability Windows Forms provides a great opportunity to build an extensible framework for your applications. For instance, you can easily customize or extend a control by deriving a new control from an existing one, like so:\n\n Then you can tweak the behavior of the control to meet your needs. For example, I created a control based on the textbox, then added some event code to monitor the keystrokes. The code in Figure 1 shows all that was necessary to modify this control to handle only numeric data.\n\n You could create similar controls to handle customer names, customer numbers, or generic data types such as government issued IDs (Social Security numbers in the United States, for instance).\n\n Most input controls have a validation event which you can take advantage of. You can find out more about these events at the following location in the MSDN® help:\n\n And don't forget about form inheritance. With form inheritance, you create a base form that has items such as logos, common buttons, menus, and so on, and any new forms simply inherit from this form. This kind of inheritance makes creating and maintaining applications easy and it minimizes the amount of code you must write. However, also make sure to minimize the amount of code in the UI. For instance, a button click event should never have more than a few lines of code in it. If the code gets too complex or handles some type of generic function, put it into a function in a module. Then you have a logically constructed architecture that provides a high level of abstraction and code reusability.\n\n You should also invest the time in creating a component framework from which your classes can be built. This rich architecture will make your derived classes much more elegant.\n\n Limit resource glut Consider the number of resources used by a form. For instance, instead of having a single form with hundreds of controls, try to narrow the functionality of the form. You can break the form into parts and limit the controls on each form. This is nothing new—you always have to manage resources in any type of app. You can also add and remove controls dynamically so the need to have a large number of static controls is reduced.\n\n Write applications to update automatically You can save your organization a tremendous amount of effort by creating auto- updateable applications. Windows Forms allows you to easily write an application that pulls itself down from a Web server and automatically checks for updates. The following short example shows the key components of this process:\n\n As you can see, the LoadFrom method takes a URL that points to your DLL to download it automatically. How should you build your application to use this technique? One of the keys is to follow the coupling and cohesion guidelines I discussed earlier.\n\n Auto-downloading applications should be built in small pieces. That is, you break the forms up into small chunks and package them in assemblies, making them easy to manage and facilitate faster downloading of updates.\n\n You can also place the application components in a Web farm. This gives you the advantage of providing a fault-tolerant distribution mechanism for your application. You could even send the starting point of the application (usually an .exe) to the user in e-mail or post it on a Web site and allow users to access it by clicking a page. I prefer to send the application to the users via a Windows Installer (.msi) file that not only installs the application but also places shortcuts on the Programs menu, desktop, or other location. An MSI installation can also provide other services such as installing files into preferred locations, setting up a local database, placing items into a user's Favorites folder, and so on. The installer even provides an automatic uninstall option.\n\n Think stateless Because of the stateless nature of many network apps, you should not build your application to depend upon the state of an instance of a component. You should adhere to this concept even in Windows-based applications, and even if you are not using COM+, because doing so will make your application scalable and flexible. If an application does not depend upon state, the components of that application can usually be moved to provide for scaling and distribution. And, of course, they're easier to debug and maintain.\n\n Use a variety of error handling Your application should also have several types of error handling and logging support. Use try-catch error handling throughout to protect your code. This will allow your application to handle errors elegantly without presenting cryptic error messages. You can also rely on features such as rich custom performance monitoring support and custom event logs to allow system managers to monitor your application while it's running. You can also place tracing code in your application to record important features while the application runs.\n\n Make fewer calls across processes Consider the transports used to move data between the client and application servers. You can use .NET Remoting or Web Services to handle this task. Remoting using TCP/IP is probably the best approach for intranet applications but, whatever the protocol, always remember to move data in chunks between tiers or clients to minimize the number of calls across processes or the network. Reducing the number of calls is critical in the creation of high-performance applications.\n\n Test, test, test Test everything thoroughly, and do unit testing of the various components that go into the application. Visual Studio .NET includes Application Center Test for Web applications. What does this have to do with Windows-based applications? If you build an n-tier application, you can easily test the components by creating a simple Web interface to them. Then you can run a test on the components under a heavy load and monitor the performance. In addition, the Visual Studio Analyzer is a good choice for testing the performance of your application.\n\n \n\n Send questions and comments for Ken to basics@microsoft.com. Ken Spencer works for 32X Tech (https://www.32X.com). 32X provides training, software development, and consulting services on Microsoft technologies."
    }
]