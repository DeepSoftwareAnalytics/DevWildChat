[
    {
        "link": "https://geeksforgeeks.org/static-keyword-cpp",
        "document": "The static keyword in C++ has different meanings when used with different types. In this article, we will learn about the static keyword in C++ along with its various uses.\n\nIn C++, a static keyword can be used in the following context:\n\nIn a function, when a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of the variable in the previous call gets carried through the next function call.\n\nLet’s take a look at an example:\n\nYou can see in the above program that the variable count is declared static. So, its value is carried through the function calls. The variable count is not getting initialized every time the function is called. As a side note, Java doesn’t allow static local variables in functions.\n\nThe static variables in a function have the following applications:\n• None or any other application where the previous state of function needs to be stored.\n\nAs the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static member variables in a class are shared by the objects. There cannot be multiple copies of the same static variables for different objects. Also because of this reason static variables cannot be initialized using constructors.\n\nLet’s take a look at an example:\n\nExplanation: You can see in the above program that we have tried to create multiple copies of the static variable i for multiple objects. But this didn’t happen.\n\nSo, a static variable inside a class should be initialized explicitly by the user using the class name and scope resolution operator outside the class as shown below:\n\nExplanation: We were able to access the static variable when is was initialized globally outside the class. Moreover, we can access the static data member without creating the object of the class.\n\nThe static data members can be used to implement the following:\n• None Ensure a class has only one instance by using static members.\n\nJust like the static data members or static variables inside the class, static member functions also do not depend on the object of the class. We are allowed to invoke a static member function using the object and the ‘.’ operator but it is recommended to invoke the static members using the class name and the scope resolution operator. Static member functions are allowed to access only the static data members or other static member functions, they cannot access the non-static data members or member functions of the class.\n\nLet’s take a look at an example:\n\nThe static member functions have the following uses in C++:\n• None Implement helper functions that do not depend on specific instances.\n• None Factory Methods to create and return objects without requiring an instance of the class.\n\nA global static variable in C++ is a static variable declared outside of any class or function. Unlike regular global variables, a global static variable has internal linkage, meaning it is accessible only within the file where it is defined. This ensures that its scope is limited to the current translation unit, preventing conflicts with variables in other files that may have the same name.\n\nLet’s take a look at an example:\n\nThe global static variables have the following uses in C++:\n• None Limiting variable scope to a file to prevent conflicts by ensuring the variable is accessible only within the file.\n• None Store settings or values that are specific to the functionality implemented in a single file.\n• None Use for shared resources in scenarios where frequent initialization and destruction can be avoided.\n• None Comparison of static keyword in C++ and Java"
    },
    {
        "link": "https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c",
        "document": "In order to clarify the question, I would rather categorize the usage of 'static' keyword in three different forms:\n\nthe explanation follows below for each of the subheadings:\n\nThis one can be little tricky however if explained and understood properly, it's pretty straightforward.\n\nTo explain this, first it is really useful to know about the scope, duration and linkage of variables, without which things are always difficult to see through the murky concept of static keyword\n\n1. Scope : Determines where in the file, the variable is accessible. It can be of two types: (i) Local or Block Scope. (ii) Global Scope\n\n2. Duration : Determines when a variable is created and destroyed. Again it's of two types: (i) Automatic Storage Duration (for variables having Local or Block scope). (ii) Static Storage Duration (for variables having Global Scope or local variables (in a function or a in a code block) with static specifier).\n\n3. Linkage: Determines whether a variable can be accessed (or linked ) in another file. Again ( and luckily) it is of two types: (i) Internal Linkage (for variables having Block Scope and Global Scope/File Scope/Global Namespace scope) (ii) External Linkage (for variables having only for Global Scope/File Scope/Global Namespace Scope)\n\nLet's refer an example below for a better understanding of plain global and local variables (no local variables with static storage duration) :\n\nNow comes the concept of Linkage. When a global variable defined in one file is intended to be used in another file, the linkage of the variable plays an important role.\n\nThe Linkage of global variables is specified by the keywords: (i) static , and, (ii) extern\n\nstatic keyword can be applied to variables with local and global scope, and in both cases, they mean different things. I will first explain the usage of 'static' keyword in variables with global scope ( where I also clarify the usage of keyword 'extern') and later the usage for those with local scope.\n\nGlobal variables have static duration, meaning they don't go out of scope when a particular block of code (e.g main() ) in which it is used ends . Depending upon the linkage, they can be either accessed only within the same file where they are declared (for static global variable), or outside the file even outside the file in which they are declared (extern type global variables)\n\nIn the case of a global variable having extern specifier, and if this variable is being accessed outside the file in which it has been initialized, it has to be forward declared in the file where it's being used, just like a function has to be forward declared if it's definition is in a file different from where it's being used.\n\nIn contrast, if the global variable has static keyword, it cannot be used in a file outside of which it has been declared.\n\nnow any variable in c++ can be either a const or a non-const and for each 'const-ness' we get two cases of default c++ linkage, in case none is specified:\n\n(i) If a global variable is non-const, its linkage is extern by default, i.e, the non-const global variable can be accessed in another .cpp file by forward declaration using the extern keyword (in other words, non const global variables have external linkage ( with static duration of course)). Also, usage of extern keyword in the original file where it has been defined is redundant. In this case, to make a non-const global variable inaccessible to external file, use the specifier 'static' before the type of the variable.\n\n(ii) If a global variable is const, its linkage is static by default, i.e a const global variable cannot be accessed in a file other than where it is defined, (in other words, const global variables have internal linkage (with static duration of course)). Also, usage of static keyword to prevent a const global variable from being accessed in another file is redundant. Here, to make a const global variable have an external linkage, use the specifier 'extern' before the type of the variable\n\nHere's a summary of global scope variables with various linkages\n\nNext, we investigate how the above global variables behave when accessed in a different file.\n\nUpdates (August 2019) on static keyword for variables in local scope\n\nThis further can be subdivided in two categories :\n\n(i) static keyword for variables within a function block, and (ii) static keyword for variables within an unnamed local block.\n\nEarlier, I mentioned that variables with local scope have automatic duration, i.e they come to exist when the block is entered ( be it a normal block, be it a function block) and cease to exist when the block ends, long story short, variables with local scope have automatic duration and automatic duration variables (and objects) have no linkage meaning they are not visible outside the code block.\n\nIf static specifier is applied to a local variable within a function block, it changes the duration of the variable from automatic to static and its lifetime is the entire duration of the program which means it has a fixed memory location and its value is initialized only once prior to program start up as mentioned in cpp reference(initialization should not be confused with assignment)\n\nlets take a look at an example.\n\nLooking at the above criterion for static local variables and static global variables, one might be tempted to ask, what the difference between them could be. While global variables are accessible at any point within the code (in the same as well as different translation units depending upon the const-ness and extern-ness), a static variable defined within a function block is not directly accessible. The variable has to be returned by the function value or reference. Lets demonstrate this by using an example:\n\nMore explanation about choice of static global and static local variables could be found on this stackoverflow thread\n\n(ii) static keyword for variables within an unnamed local block.\n\nstatic variables within a local block (not a function block) cannot be accessed outside the block once the local block goes out of scope. No caveats to this rule.\n\nC++11 introduced the keyword which guarantees the evaluation of an expression at compile time and allows the compiler to optimize the code. Now if the value of a static const variable within a scope is known at compile time, the code is optimized similarly to the one with . Here's a small example\n\nI recommend readers also to look up the difference between and for variables in this stackoverflow thread. this concludes my explanation for the static keyword applied to variables.\n\nin terms of functions, the static keyword has a straightforward meaning. Here, it refers to linkage of the function Normally all functions declared within a cpp file have external linkage by default, i.e a function defined in one file can be used in another cpp file by forward declaration.\n\nusing a static keyword before the function declaration limits its linkage to internal , i.e a static function cannot be used within a file outside of its definition.\n\nC. Static Keyword used for member variables and functions of classes\n\nI start directly with an example here\n\nIn this example, the static variable m_designNum retains its value and this single private member variable (because it's static) is shared b/w all the variables of the object type DesignNumber\n\nAlso like other member variables, static member variables of a class are not associated with any class object, which is demonstrated by the printing of anyNumber in the main function\n\n(i) non-const class static member variables In the previous example the static members (both public and private) were non constants. ISO standard forbids non-const static members to be initialized in the class. Hence as in previous example, they must be initialized after the class definition, with the caveat that the static keyword needs to be omitted\n\n(ii) const-static member variables of class this is straightforward and goes with the convention of other const member variable initialization, i.e the const static member variables of a class can be initialized at the point of declaration and they can be initialized at the end of the class declaration with one caveat that the keyword const needs to be added to the static member when being initialized after the class definition.\n\nI would however, recommend to initialize the const static member variables at the point of declaration. This goes with the standard C++ convention and makes the code look cleaner\n\nfor more examples on static member variables in a class look up the following link from learncpp.com http://www.learncpp.com/cpp-tutorial/811-static-member-variables/\n\nJust like member variables of classes can be static, so can member functions of classes. Normal member functions of classes are always associated with a object of the class type. In contrast, static member functions of a class are not associated with any object of the class, i.e they have no *this pointer.\n\nSecondly since the static member functions of the class have no *this pointer, they can be called using the class name and scope resolution operator in the main function (ClassName::functionName(); )\n\nThirdly static member functions of a class can only access static member variables of a class, since non-static member variables of a class must belong to a class object.\n\nfor more examples of static member functions in a class, look up the following link from learncpp.com\n\nLambda expressions follow normal name lookup rules and hence the scope (local vs global) and storage class (static vs automatic) affect how the variables are available to the lambda expressions\n• non-static global variable is available to lambda expression within a local scope.\n• Non-Static local variable is not available to lambda expression that appears within the same or a different scope. In this case, as we're mostly used to, the variables have to be captured by value or by reference\n• Static variables locally scoped static variables can be captured by lambda expressions within the same or lower/child scope\n\nHowever static variables in unnamed scope cannot be accessed outside the scope as explained previously"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/keyword",
        "document": "This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading. As an exception, they are not considered reserved in attributes (excluding attribute argument lists).(since C++11)\n• — meaning changed or new meaning added in C++11.\n• — meaning changed or new meaning added in C++17.\n• — meaning changed or new meaning added in C++20.\n\nNote that: , , , , , , , , , and (along with digraphs: <%, %>, <:, :>, %:, %:%: and trigraphs: ??<, ??>, ??(, ??), ??=, ??/, ??', ??!, ??-(until C++17)) provide an alternative way to represent standard tokens. These keywords are also considered reserved in attributes (excluding attribute argument lists), but some implementations handle them the same as the others.(since C++11)\n\nIn addition to keywords, there are identifiers with special meaning, which may be used as names of objects or functions, but have special meaning in certain contexts.\n\nAlso, all identifiers that contain a double underscore in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved, and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See identifiers for more details.\n\nThe namespace is used to place names of the standard C++ library. See Extending namespace std for the rules about adding names to it.\n\nThe following tokens are recognized by the preprocessor when in context of a preprocessor directive:\n\nThe following tokens are recognized by the preprocessor outside the context of a preprocessor directive:"
    },
    {
        "link": "https://w3schools.com/cpp/ref_keyword_static.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/9321/how-do-you-create-a-static-class",
        "document": "\n• In C++, a \"static class\" has no meaning. The nearest thing is a class with only static methods and members.\n• Using static methods will only limit you.\n\nWhat you want is, expressed in C++ semantics, to put your function (for it is a function) in a namespace.\n\nThere is no \"static class\" in C++. The nearest concept would be a class with only static methods. For example:\n\nBut you must remember that \"static classes\" are hacks in the Java-like kind of languages (e.g. C#) that are unable to have non-member functions, so they have instead to move them inside classes as static methods.\n\nIn C++, what you really want is a non-member function that you'll declare in a namespace:\n\nWhy is that?\n\nIn C++, the namespace is more powerful than classes for the \"Java static method\" pattern, because:\n• static methods have access to the classes private symbols\n• private static methods are still visible (if inaccessible) to everyone, which breaches somewhat the encapsulation\n• static methods cannot be overloaded by the class user without modifying the library header\n• there is nothing that can be done by a static method that can't be done better than a (possibly friend) non-member function in the same namespace\n• namespaces have their own semantics (they can be combined, they can be anonymous, etc.)\n\nConclusion: Do not copy/paste that Java/C#'s pattern in C++. In Java/C#, the pattern is mandatory. But in C++, it is bad style.\n\nThere was an argument in favor to the static method because sometimes, one needs to use a static private data member.\n\nI disagree somewhat, as show below:\n\nFirst, myGlobal is called myGlobal because it is still a global private variable. A look at the CPP source will clarify that:\n\nAt first sight, the fact the free function barC can't access Foo::myGlobal seems a good thing from an encapsulation viewpoint... It's cool because someone looking at the HPP won't be able (unless resorting to sabotage) to access Foo::myGlobal.\n\nBut if you look at it closely, you'll find that it is a colossal mistake: Not only your private variable must still be declared in the HPP (and so, visible to all the world, despite being private), but you must declare in the same HPP all (as in ALL) functions that will be authorized to access it !!!\n\nSo using a private static member is like walking outside in the nude with the list of your lovers tattooed on your skin : No one is authorized to touch, but everyone is able to peek at. And the bonus: Everyone can have the names of those authorized to play with your privies.\n\nAnonymous namespaces will have the advantage of making things private really private.\n\nJust to be sure you remarked: There is no useless declaration of barB nor myGlobal. Which means that no one reading the header knows what's hidden behind barA.\n\nAs you can see, like the so-called \"static class\" declaration, fooA and fooB are still able to access myGlobal. But no one else can. And no one else outside this CPP knows fooB and myGlobal even exist!\n\nUnlike the \"static class\" walking on the nude with her address book tattooed on her skin the \"anonymous\" namespace is fully clothed, which seems quite better encapsulated AFAIK.\n\nDoes it really matter?\n\nUnless the users of your code are saboteurs (I'll let you, as an exercise, find how one can access to the private part of a public class using a dirty behaviour-undefined hack...), what's is , even if it is visible in the section of a class declared in a header.\n\nStill, if you need to add another \"private function\" with access to the private member, you still must declare it to all the world by modifying the header, which is a paradox as far as I am concerned: If I change the implementation of my code (the CPP part), then the interface (the HPP part) should NOT change. Quoting Leonidas : \"This is ENCAPSULATION!\"\n\nWhen are classes static methods are actually better than namespaces with non-member functions?\n\nWhen you need to group together functions and feed that group to a template:\n\nBecause, if a class can be a template parameter, a namespaces cannot."
    },
    {
        "link": "https://stackoverflow.com/questions/39025709/is-it-good-practice-to-have-heavy-use-of-static-member-variables",
        "document": "As somebody without any formal training in programming, I'd like to know whether my C++ coding approach is considered good practice. Specifically, I am talking about the use of classes whose members are all static. This is a model which I use frequently, for cases when I know for certain that the class will only be instantiated once, and I want to be able to access that class from anywhere in my code. However, it tends to look a little odd because of the vast number of keywords around, and the fact that I have to explicitly initialise these variables outside the class definition.\n\nFor example, if I am writing a game, there may be several classes which I instantiate just once and want to access from anywhere. These classes could be , to represent the colours and shapes to render, , to represent the world in which my characters live, , to represent the current human player of the game, , to represent the current score, etc. I would typically create these as \"static\" classes, because then I can access them from anywhere in my code. If they were \"non-static\" classes, then I would have to keep passing around pointers to these objects.\n\nSo, for a football game, my code might look like:\n\nThis kind of code runs fine, but I'm just wondering whether using lots of static classes like this is a typical approach, or whether there is something more highly recommended? Thanks!"
    },
    {
        "link": "https://stackoverflow.com/questions/15252842/is-a-bad-practice-to-declare-static-variables-into-functions-member-functions",
        "document": "This is certainly a rare occurrence, at least, in good quality code, because of the narrow case for which it's appropriate. What this basically does is a just-in-time initialization of a global state (to deliver some global functionality). A typical example of this is having a random number generator function that seeds the generator at the first call to it. Another typical use of this is a function that returns the instance of a singleton, initialized on the first call. But other use-case examples are few and far between.\n\nIn general terms, global state is not desirable, and having objects that contain self-sufficient states is preferred (for modularity, etc.). But if you need global state (and sometimes you do), you have to implement it somehow. If you need any kind of non-trivial global state, then you should probably go with a singleton class, and one of the preferred ways to deliver that application-wide single instance is through a function that delivers a reference to a local static instance initialized on the first call. If the global state needed is a bit more trivial, then doing the scheme with the local static bool flag is certainly an acceptable way to do it. In other words, I see no fundamental problem with employing that method, but I would naturally question its motivations (requiring a global state) if presented with such code.\n\nAs is always the case for global data, multi-threading will cause some problems with a simplistic implementation like this one. Naive introductions of global state are never going to be inherently thread-safe, and this case is no exception, you'd have to take measures to address that specific problem. And that is part of the reasons why global states are not desirable.\n\nIf there is an alternative to achieve the same behavior, then the two alternatives have to be judged on the technical issues (like thread-safety). But in this case, the required behavior is the questionable thing, more so than the implementation details, and the existence of alternative implementations doesn't change that.\n\nSecond, I don't see how you can replace a just-in-time initialization of a global state by anything that is based on a non-static data member (a static data member, maybe). And even if you can, it would be wasteful (require per-object storage for a one-time-per-program-execution thing), and on that ground alone, wouldn't make it a better alternative.\n\nI would generally put that in the \"Pro\" column (as in Pro/Con). This is a good thing. This is information hiding or encapsulation. If you can hide away things that shouldn't be a concern to others, then great! But if there are other functions that would need to know that the global state has already been initialized or not, then you probably need something more along the lines of a singleton class.\n\nOOPish or not, who cares? But yes, the global state is the concern here. Not so much the use of a local static variable to implement its initialization. Global states, especially mutable global states, are bad in general and should never be abused. They hinder modularity (modules are less self-sufficient if they rely on global states), they introduce multi-threading concerns since they are inherently shared data, they make any function that use them non-reentrant (non-pure), they make debugging difficult, etc... the list goes on. But most of these issues are not tied to how you implement it. On the other hand, using a local static variable is a good way to solve the static-initialization-order-fiasco, so, they are good for that reason, one less problem to worry about when introducing a (well-justified) global state into your code."
    },
    {
        "link": "https://geeksforgeeks.org/static-member-function-in-cpp",
        "document": "The static keyword is used with a variable to make the memory of the variable static once a static variable is declared its memory can’t be changed. To know more about static keywords refer to the article static Keyword in C++.\n\nStatic members of a class are not associated with the objects of the class. Just like a static variable once declared is allocated with memory that can’t be changed every object points to the same memory. To know more about the topic refer to a static Member in C++.\n\nOnce a static member is declared it will be treated as same for all the objects associated with the class.\n\nStatic Member Function in a class is the function that is declared as static because of which function attains certain properties as defined below:\n• A static member function is independent of any object of the class.\n• A static member function can be called even if no objects of the class exist.\n• A static member function can also be accessed using the class name through the scope resolution operator.\n• A static member function can access static data members and static member functions inside or outside of the class.\n• Static member functions have a scope inside the class and cannot access the current object pointer.\n• You can also use a static member function to determine how many objects of the class have been created.\n\nThe reason we need Static member function:\n• Static members are frequently used to store information that is shared by all objects in a class.\n• For instance, you may keep track of the quantity of newly generated objects of a specific class type using a static data member as a counter. This static data member can be increased each time an object is generated to keep track of the overall number of objects."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/static",
        "document": "Inside a class definition, the keyword declares members that are not bound to class instances.\n\nOutside a class definition, it has a different meaning: see storage duration.\n\nA declaration for a static member is a member declaration whose declaration specifiers contain the keyword static. The keyword static usually appears before other specifiers (which is why the syntax is often informally described as static data-member or static member-function), but may appear anywhere in the specifier sequence.\n\nThe name of any static data member and static member function must be different from the name of the containing class.\n\nStatic members of a class are not associated with the objects of the class: they are independent variables with static or thread(since C++11) storage duration or regular functions.\n\nThe static keyword is only used with the declaration of a static member, inside the class definition, but not with the definition of that static member:\n\nThe declaration inside the class body is not a definition and may declare the member to be of incomplete type (other than void), including the type in which the member is declared:\n\nTo refer to a static member of class , two forms may be used: qualified name or member access expression or , where is an expression that evaluates to or respectively. When in the same class scope, the qualification is unnecessary:\n\nStatic member functions are not associated with any object. When called, they have no this pointer.\n\nStatic member functions cannot be virtual, const, volatile, or ref-qualified.\n\nThe address of a static member function may be stored in a regular pointer to function, but not in a pointer to member function.\n\nStatic data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static storage duration, unless the keyword is used, in which case there is one such object per thread with thread storage duration(since C++11).\n\nStatic data members of a class in namespace scope have external linkage if the class itself has external linkage (is not a member of unnamed namespace). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members.\n\nIf a static data member of integral or enumeration type is declared const (and not volatile), it can be initialized with an initializer in which every expression is a constant expression, right inside the class definition:\n\nIf a const non-inline(since C++17) static data member or a constexpr static data member(since C++11)(until C++17) is ODR-use, a definition at namespace scope is still required, but it cannot have an initializer.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members",
        "document": "A static class is basically the same as a non-static class, but there's one difference: a static class can't be instantiated. In other words, you can't use the new operator to create a variable of the class type. Because there's no instance variable, you access the members of a static class by using the class name itself. For example, if you have a static class that is named that has a public static method named , you call the method as shown in the following example:\n\nA static class can be used as a convenient container for sets of methods that just operate on input parameters and don't have to get or set any internal instance fields. For example, in the .NET Class Library, the static System.Math class contains methods that perform mathematical operations, without any requirement to store or retrieve data that is unique to a particular instance of the Math class. That is, you apply the members of the class by specifying the class name and the method name, as shown in the following example.\n\nAs is the case with all class types, the .NET runtime loads the type information for a static class when the program that references the class is loaded. The program can't specify exactly when the class is loaded. However, it's guaranteed to load and have its fields initialized and its static constructor called before the class is referenced for the first time in your program. A static constructor is only called one time, and a static class remains in memory for the lifetime of the application domain in which your program resides.\n\nThe following list provides the main features of a static class:\n\nCreating a static class is therefore basically the same as creating a class that contains only static members and a private constructor. A private constructor prevents the class from being instantiated. The advantage of using a static class is that the compiler can check to make sure that no instance members are accidentally added. The compiler guarantees that instances of this class can't be created.\n\nStatic classes are sealed and therefore can't be inherited. They can't inherit from any class or interface except Object. Static classes can't contain an instance constructor. However, they can contain a static constructor. Non-static classes should also define a static constructor if the class contains static members that require non-trivial initialization. For more information, see Static Constructors.\n\nHere's an example of a static class that contains two methods that convert temperature from Celsius to Fahrenheit and from Fahrenheit to Celsius:\n\nA non-static class can contain static methods, fields, properties, or events. The static member is callable on a class even when no instance of the class exists. The static member is always accessed by the class name, not the instance name. Only one copy of a static member exists, regardless of how many instances of the class are created. Static methods and properties can't access non-static fields and events in their containing type, and they can't access an instance variable of any object unless it's explicitly passed in a method parameter.\n\nIt's more typical to declare a non-static class with some static members, than to declare an entire class as static. Two common uses of static fields are to keep a count of the number of objects that are instantiated, or to store a value that must be shared among all instances.\n\nStatic methods can be overloaded but not overridden, because they belong to the class, and not to any instance of the class.\n\nAlthough a field can't be declared as , a const field is essentially static in its behavior. It belongs to the type, not to instances of the type. Therefore, fields can be accessed by using the same notation used for static fields. No object instance is required.\n\nC# doesn't support static local variables (that is, variables that are declared in method scope).\n\nYou declare static class members by using the keyword before the return type of the member, as shown in the following example:\n\nStatic members are initialized before the static member is accessed for the first time and before the static constructor, if there's one, is called. To access a static class member, use the name of the class instead of a variable name to specify the location of the member, as shown in the following example:\n\nIf your class contains static fields, provide a static constructor that initializes them when the class is loaded.\n\nA call to a static method generates a call instruction in common intermediate language (CIL), whereas a call to an instance method generates a instruction, which also checks for null object references. However, most of the time the performance difference between the two isn't significant.\n\nFor more information, see Static classes, Static and instance members and Static constructors in the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    }
]