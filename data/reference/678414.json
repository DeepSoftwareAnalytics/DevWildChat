[
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_characterbody3d.html",
        "document": "CharacterBody3D is a specialized class for physics bodies that are meant to be user-controlled. They are not affected by physics at all, but they affect other physics bodies in their path. They are mainly used to provide high-level API to move objects with wall and slope detection (move_and_slide() method) in addition to the general collision detection provided by PhysicsBody3D.move_and_collide(). This makes it useful for highly configurable physics bodies that must move in specific ways and collide with the world, as is often the case with user-controlled characters. For game objects that don't require complex movement or collision detection, such as moving platforms, AnimatableBody3D is simpler to configure.\n\nApply when notions of walls, ceiling and floor are relevant. In this mode the body motion will react to slopes (acceleration/slowdown). This mode is suitable for grounded games like platformers. Apply when there is no notion of floor or ceiling. All collisions will be reported as . In this mode, when you slide, the speed will always be constant. This mode is suitable for games without ground like space games. Add the last platform velocity to the velocity when you leave a moving platform. Add the last platform velocity to the velocity when you leave a moving platform, but any downward motion is ignored. It's useful to keep full jump height even when the platform is moving down. Do nothing when leaving a platform.\n\nIf , the body will be able to move on the floor only. This option avoids to be able to walk on walls, it will however allow to slide down along them. If (by default), the body will move faster on downward slopes and slower on upward slopes. If , the body will always move at the same speed on the ground no matter the slope. Note that you need to use floor_snap_length to stick along a downward slope at constant speed. Maximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall, when calling move_and_slide(). The default value equals 45 degrees. Sets a snapping distance. When set to a value different from , the body is kept attached to slopes when calling move_and_slide(). The snapping vector is determined by the given distance along the opposite direction of the up_direction. As long as the snapping vector is in contact with the ground and the body moves against up_direction, the body will remain attached to the surface. Snapping is not applied if the body moves along up_direction, meaning it contains vertical rising velocity, so it will be able to detach from the ground when jumping or when the body is pushed up by something. If you want to apply a snap without taking into account the velocity, use apply_floor_snap(). If , the body will not slide on slopes when calling move_and_slide() when the body is standing still. If , the body will slide on floor's slopes when velocity applies a downward force. Maximum number of times the body can change direction before it stops when calling move_and_slide(). Sets the motion mode which defines the behavior of move_and_slide(). See MotionMode constants for available modes. Collision layers that will be included for detecting floor bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all floor bodies are detected and propagate their velocity. Sets the behavior to apply when you leave a moving platform. By default, to be physically accurate, when you leave the last platform velocity is applied. See PlatformOnLeave constants for available behavior. Collision layers that will be included for detecting wall bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all wall bodies are ignored. Extra margin used for collision recovery when calling move_and_slide(). If the body is at least this close to another body, it will consider them to be colliding and will be pushed away before performing the actual motion. A higher value means it's more flexible for detecting collision, which helps with consistently detecting walls and floors. A lower value forces the collision algorithm to use more exact detection, so it can be used in cases that specifically require precision, e.g at very low scale to avoid visible jittering, or for stability with a stack of character bodies. If , during a jump against the ceiling, the body will slide, if it will be stopped and will fall vertically. Vector pointing upwards, used to determine what is a wall and what is a floor (or a ceiling) when calling move_and_slide(). Defaults to Vector3.UP. As the vector will be normalized it can't be equal to Vector3.ZERO, if you want all collisions to be reported as walls, consider using MOTION_MODE_FLOATING as motion_mode. Current velocity vector (typically meters per second), used and modified during calls to move_and_slide(). Minimum angle (in radians) where the body is allowed to slide when it encounters a slope. The default value equals 15 degrees. When motion_mode is MOTION_MODE_GROUNDED, it only affects movement if floor_block_on_wall is .\n\nAllows to manually apply a snap to the floor regardless of the body's velocity. This function does nothing when is_on_floor() returns . Returns the floor's collision angle at the last collision point according to , which is Vector3.UP by default. This value is always positive and only valid after calling move_and_slide() and when is_on_floor() returns . Returns the collision normal of the floor at the last collision point. Only valid after calling move_and_slide() and when is_on_floor() returns . Warning: The collision normal is not always the same as the surface normal. Returns the last motion applied to the CharacterBody3D during the last call to move_and_slide(). The movement can be split into multiple motions when sliding occurs, and this method return the last one, which is useful to retrieve the current direction of the movement. Returns a KinematicCollision3D, which contains information about the latest collision that occurred during the last call to move_and_slide(). Returns the angular velocity of the platform at the last collision point. Only valid after calling move_and_slide(). Returns the linear velocity of the platform at the last collision point. Only valid after calling move_and_slide(). Returns the travel (position delta) that occurred during the last call to move_and_slide(). Returns the current real velocity since the last call to move_and_slide(). For example, when you climb a slope, you will move diagonally even though the velocity is horizontal. This method returns the diagonal movement, as opposed to velocity which returns the requested velocity. Returns a KinematicCollision3D, which contains information about a collision that occurred during the last call to move_and_slide(). Since the body can collide several times in a single call to move_and_slide(), you must specify the index of the collision in the range 0 to (get_slide_collision_count() - 1). Returns the number of times the body collided and changed direction during the last call to move_and_slide(). Returns the collision normal of the wall at the last collision point. Only valid after calling move_and_slide() and when is_on_wall() returns . Warning: The collision normal is not always the same as the surface normal. Returns if the body collided with the ceiling on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided only with the ceiling on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided with the floor on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided only with the floor on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided with a wall on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Returns if the body collided only with a wall on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Moves the body based on velocity. If the body collides with another, it will slide along the other body rather than stop immediately. If the other body is a CharacterBody3D or RigidBody3D, it will also be affected by the motion of the other body. You can use this to make moving and rotating platforms, or to make nodes push other nodes. Modifies velocity if a slide collision occurred. To get the latest collision call get_last_slide_collision(), for more detailed information about collisions that occurred, use get_slide_collision(). When the body touches a moving platform, the platform's velocity is automatically added to the body motion. If a collision occurs due to the platform's motion, it will always be first in the slide collisions. Returns if the body collided, otherwise, returns ."
    },
    {
        "link": "https://docs.godotengine.org/en/latest/classes/class_characterbody3d.html",
        "document": "This is the latest (unstable) version of this documentation, which may document features not available in or compatible with released stable versions of Godot.\n\nCharacterBody3D is a specialized class for physics bodies that are meant to be user-controlled. They are not affected by physics at all, but they affect other physics bodies in their path. They are mainly used to provide high-level API to move objects with wall and slope detection (move_and_slide() method) in addition to the general collision detection provided by PhysicsBody3D.move_and_collide(). This makes it useful for highly configurable physics bodies that must move in specific ways and collide with the world, as is often the case with user-controlled characters. For game objects that don't require complex movement or collision detection, such as moving platforms, AnimatableBody3D is simpler to configure.\n\nApply when notions of walls, ceiling and floor are relevant. In this mode the body motion will react to slopes (acceleration/slowdown). This mode is suitable for grounded games like platformers. Apply when there is no notion of floor or ceiling. All collisions will be reported as . In this mode, when you slide, the speed will always be constant. This mode is suitable for games without ground like space games. Add the last platform velocity to the velocity when you leave a moving platform. Add the last platform velocity to the velocity when you leave a moving platform, but any downward motion is ignored. It's useful to keep full jump height even when the platform is moving down. Do nothing when leaving a platform.\n\nIf , the body will be able to move on the floor only. This option avoids to be able to walk on walls, it will however allow to slide down along them. If (by default), the body will move faster on downward slopes and slower on upward slopes. If , the body will always move at the same speed on the ground no matter the slope. Note that you need to use floor_snap_length to stick along a downward slope at constant speed. Maximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall, when calling move_and_slide(). The default value equals 45 degrees. Sets a snapping distance. When set to a value different from , the body is kept attached to slopes when calling move_and_slide(). The snapping vector is determined by the given distance along the opposite direction of the up_direction. As long as the snapping vector is in contact with the ground and the body moves against up_direction, the body will remain attached to the surface. Snapping is not applied if the body moves along up_direction, meaning it contains vertical rising velocity, so it will be able to detach from the ground when jumping or when the body is pushed up by something. If you want to apply a snap without taking into account the velocity, use apply_floor_snap(). If , the body will not slide on slopes when calling move_and_slide() when the body is standing still. If , the body will slide on floor's slopes when velocity applies a downward force. Maximum number of times the body can change direction before it stops when calling move_and_slide(). Sets the motion mode which defines the behavior of move_and_slide(). See MotionMode constants for available modes. Collision layers that will be included for detecting floor bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all floor bodies are detected and propagate their velocity. Sets the behavior to apply when you leave a moving platform. By default, to be physically accurate, when you leave the last platform velocity is applied. See PlatformOnLeave constants for available behavior. Collision layers that will be included for detecting wall bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all wall bodies are ignored. Extra margin used for collision recovery when calling move_and_slide(). If the body is at least this close to another body, it will consider them to be colliding and will be pushed away before performing the actual motion. A higher value means it's more flexible for detecting collision, which helps with consistently detecting walls and floors. A lower value forces the collision algorithm to use more exact detection, so it can be used in cases that specifically require precision, e.g at very low scale to avoid visible jittering, or for stability with a stack of character bodies. If , during a jump against the ceiling, the body will slide, if it will be stopped and will fall vertically. Vector pointing upwards, used to determine what is a wall and what is a floor (or a ceiling) when calling move_and_slide(). Defaults to Vector3.UP. As the vector will be normalized it can't be equal to Vector3.ZERO, if you want all collisions to be reported as walls, consider using MOTION_MODE_FLOATING as motion_mode. Current velocity vector (typically meters per second), used and modified during calls to move_and_slide(). Minimum angle (in radians) where the body is allowed to slide when it encounters a slope. The default value equals 15 degrees. When motion_mode is MOTION_MODE_GROUNDED, it only affects movement if floor_block_on_wall is .\n\nAllows to manually apply a snap to the floor regardless of the body's velocity. This function does nothing when is_on_floor() returns . Returns the floor's collision angle at the last collision point according to , which is Vector3.UP by default. This value is always positive and only valid after calling move_and_slide() and when is_on_floor() returns . Returns the collision normal of the floor at the last collision point. Only valid after calling move_and_slide() and when is_on_floor() returns . Warning: The collision normal is not always the same as the surface normal. Returns the last motion applied to the CharacterBody3D during the last call to move_and_slide(). The movement can be split into multiple motions when sliding occurs, and this method return the last one, which is useful to retrieve the current direction of the movement. Returns a KinematicCollision3D, which contains information about the latest collision that occurred during the last call to move_and_slide(). Returns the angular velocity of the platform at the last collision point. Only valid after calling move_and_slide(). Returns the linear velocity of the platform at the last collision point. Only valid after calling move_and_slide(). Returns the travel (position delta) that occurred during the last call to move_and_slide(). Returns the current real velocity since the last call to move_and_slide(). For example, when you climb a slope, you will move diagonally even though the velocity is horizontal. This method returns the diagonal movement, as opposed to velocity which returns the requested velocity. Returns a KinematicCollision3D, which contains information about a collision that occurred during the last call to move_and_slide(). Since the body can collide several times in a single call to move_and_slide(), you must specify the index of the collision in the range 0 to (get_slide_collision_count() - 1). Returns the number of times the body collided and changed direction during the last call to move_and_slide(). Returns the collision normal of the wall at the last collision point. Only valid after calling move_and_slide() and when is_on_wall() returns . Warning: The collision normal is not always the same as the surface normal. Returns if the body collided with the ceiling on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided only with the ceiling on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided with the floor on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided only with the floor on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided with a wall on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Returns if the body collided only with a wall on the last call of move_and_slide(). Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Moves the body based on velocity. If the body collides with another, it will slide along the other body rather than stop immediately. If the other body is a CharacterBody3D or RigidBody3D, it will also be affected by the motion of the other body. You can use this to make moving and rotating platforms, or to make nodes push other nodes. Modifies velocity if a slide collision occurred. To get the latest collision call get_last_slide_collision(), for more detailed information about collisions that occurred, use get_slide_collision(). When the body touches a moving platform, the platform's velocity is automatically added to the body motion. If a collision occurs due to the platform's motion, it will always be first in the slide collisions. Returns if the body collided, otherwise, returns ."
    },
    {
        "link": "https://reddit.com/r/godot/comments/1b4fm9p/using_the_default_characterbody3d_movement_script",
        "document": "I've tried using look_at(), but my character just flops around. I am new to this, and some help (or even just pointing to a resource that would help me understand this) would be great. I've looked at the other threads on the subject and have not been able to apply code from the solutions there to the default player movement script in a way that works."
    },
    {
        "link": "https://docs.godot.community/classes/class_characterbody3d.html",
        "document": "CharacterBody3D is a specialized class for physics bodies that are meant to be user-controlled. They are not affected by physics at all, but they affect other physics bodies in their path. They are mainly used to provide high-level API to move objects with wall and slope detection (move_and_slide method) in addition to the general collision detection provided by PhysicsBody3D.move_and_collide. This makes it useful for highly configurable physics bodies that must move in specific ways and collide with the world, as is often the case with user-controlled characters. For game objects that don't require complex movement or collision detection, such as moving platforms, AnimatableBody3D is simpler to configure.\n\nApply when notions of walls, ceiling and floor are relevant. In this mode the body motion will react to slopes (acceleration/slowdown). This mode is suitable for grounded games like platformers. Apply when there is no notion of floor or ceiling. All collisions will be reported as . In this mode, when you slide, the speed will always be constant. This mode is suitable for games without ground like space games. Add the last platform velocity to the velocity when you leave a moving platform. Add the last platform velocity to the velocity when you leave a moving platform, but any downward motion is ignored. It's useful to keep full jump height even when the platform is moving down. Do nothing when leaving a platform.\n\nIf , the body will be able to move on the floor only. This option avoids to be able to walk on walls, it will however allow to slide down along them. If (by default), the body will move faster on downward slopes and slower on upward slopes. If , the body will always move at the same speed on the ground no matter the slope. Note that you need to use floor_snap_length to stick along a downward slope at constant speed. Maximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall, when calling move_and_slide. The default value equals 45 degrees. Sets a snapping distance. When set to a value different from , the body is kept attached to slopes when calling move_and_slide. The snapping vector is determined by the given distance along the opposite direction of the up_direction. As long as the snapping vector is in contact with the ground and the body moves against up_direction, the body will remain attached to the surface. Snapping is not applied if the body moves along up_direction, meaning it contains vertical rising velocity, so it will be able to detach from the ground when jumping or when the body is pushed up by something. If you want to apply a snap without taking into account the velocity, use apply_floor_snap. If , the body will not slide on slopes when calling move_and_slide when the body is standing still. If , the body will slide on floor's slopes when velocity applies a downward force. Maximum number of times the body can change direction before it stops when calling move_and_slide. Sets the motion mode which defines the behavior of move_and_slide. See MotionMode constants for available modes. Collision layers that will be included for detecting floor bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all floor bodies are detected and propagate their velocity. Sets the behavior to apply when you leave a moving platform. By default, to be physically accurate, when you leave the last platform velocity is applied. See PlatformOnLeave constants for available behavior. Collision layers that will be included for detecting wall bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all wall bodies are ignored. Extra margin used for collision recovery when calling move_and_slide. If the body is at least this close to another body, it will consider them to be colliding and will be pushed away before performing the actual motion. A higher value means it's more flexible for detecting collision, which helps with consistently detecting walls and floors. A lower value forces the collision algorithm to use more exact detection, so it can be used in cases that specifically require precision, e.g at very low scale to avoid visible jittering, or for stability with a stack of character bodies. If , during a jump against the ceiling, the body will slide, if it will be stopped and will fall vertically. Vector pointing upwards, used to determine what is a wall and what is a floor (or a ceiling) when calling move_and_slide. Defaults to . As the vector will be normalized it can't be equal to Vector3.ZERO, if you want all collisions to be reported as walls, consider using MOTION_MODE_FLOATING as motion_mode. Current velocity vector (typically meters per second), used and modified during calls to move_and_slide. Minimum angle (in radians) where the body is allowed to slide when it encounters a slope. The default value equals 15 degrees. When motion_mode is MOTION_MODE_GROUNDED, it only affects movement if floor_block_on_wall is .\n\nAllows to manually apply a snap to the floor regardless of the body's velocity. This function does nothing when is_on_floor returns . Returns the floor's collision angle at the last collision point according to , which is by default. This value is always positive and only valid after calling move_and_slide and when is_on_floor returns . Returns the surface normal of the floor at the last collision point. Only valid after calling move_and_slide and when is_on_floor returns . Returns the last motion applied to the CharacterBody3D during the last call to move_and_slide. The movement can be split into multiple motions when sliding occurs, and this method return the last one, which is useful to retrieve the current direction of the movement. Returns a KinematicCollision3D, which contains information about the latest collision that occurred during the last call to move_and_slide. Returns the angular velocity of the platform at the last collision point. Only valid after calling move_and_slide. Returns the linear velocity of the platform at the last collision point. Only valid after calling move_and_slide. Returns the travel (position delta) that occurred during the last call to move_and_slide. Returns the current real velocity since the last call to move_and_slide. For example, when you climb a slope, you will move diagonally even though the velocity is horizontal. This method returns the diagonal movement, as opposed to velocity which returns the requested velocity. Returns a KinematicCollision3D, which contains information about a collision that occurred during the last call to move_and_slide. Since the body can collide several times in a single call to move_and_slide, you must specify the index of the collision in the range 0 to (get_slide_collision_count - 1). Returns the number of times the body collided and changed direction during the last call to move_and_slide. Returns the surface normal of the wall at the last collision point. Only valid after calling move_and_slide and when is_on_wall returns . Returns if the body collided with the ceiling on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided only with the ceiling on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"ceiling\" or not. Returns if the body collided with the floor on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided only with the floor on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"floor\" or not. Returns if the body collided with a wall on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Returns if the body collided only with a wall on the last call of move_and_slide. Otherwise, returns . The up_direction and floor_max_angle are used to determine whether a surface is \"wall\" or not. Moves the body based on velocity. If the body collides with another, it will slide along the other body rather than stop immediately. If the other body is a CharacterBody3D or RigidBody3D, it will also be affected by the motion of the other body. You can use this to make moving and rotating platforms, or to make nodes push other nodes. Modifies velocity if a slide collision occurred. To get the latest collision call get_last_slide_collision, for more detailed information about collisions that occurred, use get_slide_collision. When the body touches a moving platform, the platform's velocity is automatically added to the body motion. If a collision occurs due to the platform's motion, it will always be first in the slide collisions. Returns if the body collided, otherwise, returns ."
    },
    {
        "link": "https://docs.godotengine.org/pl/stable/classes/class_characterbody3d.html",
        "document": "CharacterBody3D is a specialized class for physics bodies that are meant to be user-controlled. They are not affected by physics at all, but they affect other physics bodies in their path. They are mainly used to provide high-level API to move objects with wall and slope detection ( move_and_slide method) in addition to the general collision detection provided by PhysicsBody3D.move_and_collide . This makes it useful for highly configurable physics bodies that must move in specific ways and collide with the world, as is often the case with user-controlled characters.\n\nAdd the last platform velocity to the velocity when you leave a moving platform, but any downward motion is ignored. It's useful to keep full jump height even when the platform is moving down.\n\nIf , the body will be able to move on the floor only. This option avoids to be able to walk on walls, it will however allow to slide down along them.\n\nIf (by default), the body will move faster on downward slopes and slower on upward slopes.\n\nIf , the body will always move at the same speed on the ground no matter the slope. Note that you need to use floor_snap_length to stick along a downward slope at constant speed.\n\nMaximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall, when calling move_and_slide. The default value equals 45 degrees.\n\nSets a snapping distance. When set to a value different from , the body is kept attached to slopes when calling move_and_slide. The snapping vector is determined by the given distance along the opposite direction of the up_direction.\n\nAs long as the snapping vector is in contact with the ground and the body moves against up_direction, the body will remain attached to the surface. Snapping is not applied if the body moves along up_direction, meaning it contains vertical rising velocity, so it will be able to detach from the ground when jumping or when the body is pushed up by something. If you want to apply a snap without taking into account the velocity, use apply_floor_snap.\n\nCollision layers that will be included for detecting floor bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all floor bodies are detected and propagate their velocity.\n\nSets the behavior to apply when you leave a moving platform. By default, to be physically accurate, when you leave the last platform velocity is applied. See PlatformOnLeave constants for available behavior.\n\nCollision layers that will be included for detecting wall bodies that will act as moving platforms to be followed by the CharacterBody3D. By default, all wall bodies are ignored.\n\nA lower value forces the collision algorithm to use more exact detection, so it can be used in cases that specifically require precision, e.g at very low scale to avoid visible jittering, or for stability with a stack of character bodies.\n\nVector pointing upwards, used to determine what is a wall and what is a floor (or a ceiling) when calling move_and_slide. Defaults to Vector3.UP. As the vector will be normalized it can't be equal to Vector3.ZERO, if you want all collisions to be reported as walls, consider using MOTION_MODE_FLOATING as motion_mode."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/first_3d_game/03.player_movement_code.html",
        "document": "It's time to code! We're going to use the input actions we created in the last part to move the character.\n\nRight-click the node and select Attach Script to add a new script to it. In the popup, set the Template to Empty before pressing the Create button. We set it to Empty because we want to write our own code for player movement.\n\nLet's start with the class's properties. We're going to define a movement speed, a fall acceleration representing gravity, and a velocity we'll use to move the character.\n\nThese are common properties for a moving body. The is a 3D vector combining a speed with a direction. Here, we define it as a property because we want to update and reuse its value across frames.\n\nLet's code the movement. We start by calculating the input direction vector using the global object, in .\n\nHere, instead of , we're going to make all calculations using the virtual function. It's designed specifically for physics-related code like moving a kinematic or rigid body. It updates the node using fixed time intervals.\n\nWe start by initializing a variable to . Then, we check if the player is pressing one or more of the inputs and update the vector's and components accordingly. These correspond to the ground plane's axes.\n\nThese four conditions give us eight possibilities and eight possible directions.\n\nIn case the player presses, say, both W and D simultaneously, the vector will have a length of about . But if they press a single key, it will have a length of . We want the vector's length to be consistent, and not move faster diagonally. To do so, we can call its method.\n\nHere, we only normalize the vector if the direction has a length greater than zero, which means the player is pressing a direction key.\n\nWe compute the direction the is looking by creating a Basis that looks in the direction.\n\nThen, we update the velocity. We have to calculate the ground velocity and the fall speed separately. Be sure to go back one tab so the lines are inside the function but outside the condition we just wrote above.\n\nThe function returns if the body collided with the floor in this frame. That's why we apply gravity to the only while it is in the air.\n\nFor the vertical velocity, we subtract the fall acceleration multiplied by the delta time every frame. This line of code will cause our character to fall in every frame, as long as it is not on or colliding with the floor.\n\nThe physics engine can only detect interactions with walls, the floor, or other bodies during a given frame if movement and collisions happen. We will use this property later to code the jump.\n\nOn the last line, we call which is a powerful method of the class that allows you to move a character smoothly. If it hits a wall midway through a motion, the engine will try to smooth it out for you. It uses the velocity value native to the CharacterBody3D\n\nAnd that's all the code you need to move the character on the floor.\n\nHere is the complete code for reference.\n\nWe're going to put our player in the scene to test it. To do so, we need to instantiate the player and then add a camera. Unlike in 2D, in 3D, you won't see anything if your viewport doesn't have a camera pointing at something. Save your scene and open the scene. You can click on the Main tab at the top of the editor to do so. If you closed the scene before, head to the FileSystem dock and double-click to re-open it. To instantiate the , right-click on the node and select Instantiate Child Scene. In the popup, double-click . The character should appear in the center of the viewport. Let's add the camera next. Like we did with our Player's Pivot, we're going to create a basic rig. Right-click on the node again and select Add Child Node. Create a new Marker3D, and name it . Select and add a child node Camera3D to it. Your scene tree should look similar to this. Notice the Preview checkbox that appears in the top-left of the 3D view when you have the Camera selected. You can click it to preview the in-game camera projection. We're going to use the Pivot to rotate the camera as if it was on a crane. Let's first split the 3D view to be able to freely navigate the scene and see what the camera sees. In the toolbar right above the viewport, click on View, then 2 Viewports. You can also press ( on macOS). On the bottom view, select your Camera3D and turn on camera Preview by clicking the checkbox. In the top view, make sure your Camera3D is selected and move the camera about units on the Z axis (drag the blue arrow). Here's where the magic happens. Select the CameraPivot and rotate it degrees around the X axis (using the red circle). You'll see the camera move as if it was attached to a crane. You can run the scene by pressing and press the arrow keys to move the character. We can see some empty space around the character due to the perspective projection. In this game, we're going to use an orthographic projection instead to better frame the gameplay area and make it easier for the player to read distances. Select the Camera again and in the Inspector, set the Projection to Orthogonal and the Size to . The character should now look flatter and the ground should fill the background. When using an orthogonal camera in Godot 4, directional shadow quality is dependent on the camera's Far value. The higher the Far value, the further away the camera will be able to see. However, higher Far values also decrease shadow quality as the shadow rendering has to cover a greater distance. If directional shadows look too blurry after switching to an orthogonal camera, decrease the camera's Far property to a lower value such as . Don't decrease this Far property too much, or objects in the distance will start disappearing. Test your scene and you should be able to move in all 8 directions and not glitch through the floor! Ultimately, we have both player movement and the view in place. Next, we will work on the monsters."
    },
    {
        "link": "https://reddit.com/r/godot/comments/7xth0f/godot_3d_player_movement_tutorial",
        "document": "The official subreddit for the Godot Engine. Meet your fellow game developers as well as engine contributors, stay up to date on Godot news, and share your projects and resources with each other. Maintained by the Godot Foundation, the non-profit taking good care of the Godot project - consider donating to https://fund.godotengine.org/ to keep us going!"
    },
    {
        "link": "https://forum.godotengine.org/t/how-do-i-attach-animations-to-movements-and-non-movements/25513",
        "document": "Topic was automatically imported from the old Question2Answer platform. I’m new to Godot but I’ve worked with python before and I’m working on a project over my break. I have a sprite sheet and have tried sprite and animatedsprite to do this but I can’t seem to figure out how to get either to display 4 walking animations and 4 idle animations. I think what I need is some function to check if the player is moving, but I don’t know how to set that up (side note: what does it mean to put Vector2 in your script???)… Just in case I haven’t been clear, the outcome I want is for the player to have a movement animation corresponding to up down left right and when the player has finished moving the sprite will stay on the idle frame corresponding to the direction they were traveling last. hi, Have you already checked the “Your First Game” tutorial on godot documentation? there it shows how to select animation based on movement. what does it mean to put Vector2 in your script??? I don’t even know what the question means without a context. This is something someone told you to do? I think it could mean to define a variable of type Vector2 in your script, for using it for some purpose…\n\nI believe the way to do this is to just put the code to start the animation at the same place you tell the program to do something. For example, say you have: Just add the code to animate it with the code to move it in the first place. So in this case, it’d be… Obviously the code won’t be exactly the same as what I put here, and you’ll need to set some other stuff up (like the input map so the computer knows what , , etc. means, and the AnimatedSprite animations (which I’m assuming you’ve already done), or the velocity vector and use it for or whatever you’re using to move) so if you need help with that just reply to this post or hit me up on Discord: Also, about the vectors, in Godot a vector is basically a variable but with two or three values (depending on if it’s 2D or 3D) that is usually used for physical positions. Again, this can be a bit confusing so reply to this post or send me a Discord message if you need help.\n\nActually you can use this method\n\n U just have to create a seperate method and give it a name let say “animation_manager” which u will call in ur process or physics_process method then u have to create boolean variables for all action that the player takes such as running sliding jumping falling attacking etc for example if Input.is_action_pressed(\"ui_left\"): \"Run to the left\" Running = true if Input.is_action_pressed(\"ui_right\"): \"Run to the right\" Running = true If Input.is_action_just_released(\"ui_left\") or Input.is_action_just_released(\"ui_right\"): running = false Then you do same for jump and sliding i will recommend for u to have use of enum and array for easy data arrangement for your animation_manager method the code went like this Func animation_manager(): If running and not ( jumping or sliding): \"Play run animation\" If jumping: \"Play jump animation\" // for idle u just have to check if all the states are false then it mean that the player is truly idle\" That the code am currently using am also new to game development as a whole and am still looking for the best way to manage my animation but this works perfectly for now And sorry if my explanation is not so good am not really good at explaining\n\n Thanks"
    },
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/first_3d_game/index.html",
        "document": "In this step-by-step tutorial series, you will create your first complete 3D game with Godot. By the end of the series, you will have a simple yet finished project of your own like the animated gif below.\n\nThe game we'll code here is similar to Your first 2D game, with a twist: you can now jump and your goal is to squash the creeps. This way, you will both recognize patterns you learned in the previous tutorial and build upon them with new code and features.\n\nYou will learn to:\n• None Use kinematic bodies to move 3D characters and detect when and how they collide.\n• None Use physics layers and a group to detect interactions with specific entities.\n• None Design a movement animation and change its speed at runtime.\n\nThis tutorial is for beginners who followed the complete getting started series. We'll start slow with detailed instructions and shorten them as we do similar steps. If you're an experienced programmer, you can browse the complete demo's source code here: Squash the Creep source code.\n\nYou can follow this series without having done the 2D one. However, if you're new to game development, we recommend you to start with 2D. 3D game code is always more complex and the 2D series will give you foundations to follow along more comfortably.\n\nWe prepared some game assets so we can jump straight to the code. You can download them here: Squash the Creeps assets.\n\nWe will first work on a basic prototype for the player's movement. We will then add the monsters that we'll spawn randomly around the screen. After that, we'll implement the jump and squashing mechanic before refining the game with some nice animation. We'll wrap up with the score and the retry screen."
    }
]