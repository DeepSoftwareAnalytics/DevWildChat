[
    {
        "link": "https://typescriptlang.org/docs/handbook/decorators.html",
        "document": "With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.\n\nTo enable experimental support for decorators, you must enable the compiler option either on the command line or in your :\n\nA Decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form , where must evaluate to a function that will be called at runtime with information about the decorated declaration.\n\nFor example, given the decorator we might write the function as follows:\n\nIf we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A Decorator Factory is simply a function that returns the expression that will be called by the decorator at runtime.\n\nWe can write a decorator factory in the following fashion:\n\nMultiple decorators can be applied to a declaration, for example on a single line:\n\nWhen multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics. In this model, when composing functions f and g, the resulting composite (f ∘ g)(x) is equivalent to f(g(x)).\n\nAs such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:\n• The expressions for each decorator are evaluated top-to-bottom.\n• The results are then called as functions from bottom-to-top.\n\nIf we were to use decorator factories, we can observe this evaluation order with the following example:\n\nWhich would print this output to the console:\n\nThere is a well defined order to how decorators applied to various declarations inside of a class are applied:\n• Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each instance member.\n• Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.\n• Parameter Decorators are applied for the constructor.\n• Class Decorators are applied for the class.\n\nA Class Decorator is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a class).\n\nThe expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.\n\nIf the class decorator returns a value, it will replace the class declaration with the provided constructor function.\n\nThe following is an example of a class decorator ( ) applied to a class:\n\nWe can define the decorator using the following function declaration:\n\nWhen is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing or by defining properties on itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does not prevent classes from sub-classing .\n\nNext we have an example of how to override the constructor to set new defaults.\n\nA Method Decorator is declared just before a method declaration. The decorator is applied to the Property Descriptor for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a class).\n\nThe expression for the method decorator will be called as a function at runtime, with the following three arguments:\n• Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n• The name of the member.\n• The Property Descriptor for the member.\n\nIf the method decorator returns a value, it will be used as the Property Descriptor for the method.\n\nThe following is an example of a method decorator ( ) applied to a method on the class:\n\nWe can define the decorator using the following function declaration:\n\nThe decorator here is a decorator factory. When the decorator is called, it modifies the property of the property descriptor.\n\nAn Accessor Decorator is declared just before an accessor declaration. The accessor decorator is applied to the Property Descriptor for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a class).\n\nThe expression for the accessor decorator will be called as a function at runtime, with the following three arguments:\n• Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n• The name of the member.\n• The Property Descriptor for the member.\n\nIf the accessor decorator returns a value, it will be used as the Property Descriptor for the member.\n\nThe following is an example of an accessor decorator ( ) applied to a member of the class:\n\nWe can define the decorator using the following function declaration:\n\nA Property Decorator is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a class).\n\nThe expression for the property decorator will be called as a function at runtime, with the following two arguments:\n• Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n• The name of the member.\n\nWe can use this information to record metadata about the property, as in the following example:\n\nWe can then define the decorator and functions using the following function declarations:\n\nThe decorator here is a decorator factory. When is called, it adds a metadata entry for the property using the function from the library. When is called, it reads the metadata value for the format.\n\nA Parameter Decorator is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a class).\n\nThe expression for the parameter decorator will be called as a function at runtime, with the following three arguments:\n• Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n• The name of the member.\n• The ordinal index of the parameter in the function’s parameter list.\n\nThe return value of the parameter decorator is ignored.\n\nThe following is an example of a parameter decorator ( ) applied to parameter of a member of the class:\n\nWe can then define the and decorators using the following function declarations:\n\nThe decorator adds a metadata entry that marks the parameter as required. The decorator then wraps the existing method in a function that validates the arguments before invoking the original method.\n\nSome examples use the library which adds a polyfill for an experimental metadata API. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.\n\nYou can install this library via npm:\n\nTypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the compiler option either on the command line or in your :\n\nWhen enabled, as long as the library has been imported, additional design-time type information will be exposed at runtime.\n\nWe can see this in action in the following example:\n\nThe TypeScript compiler will inject design-time type information using the decorator. You could consider it the equivalent of the following TypeScript:"
    },
    {
        "link": "https://blog.logrocket.com/practical-guide-typescript-decorators",
        "document": "This article was last updated by on 21 March 2024 to provide information about parameter decorators in TypeScript, and explore advanced decorator patterns like decorator composition and factories.\n\nA decorator is a programming design pattern in which you wrap something to change its behavior. This feature is currently at stage three in JavaScript. Decorators are not new; several programming languages, such as Python, Java, and C#, adopted this pattern before JavaScript. Further refinement of the syntax will require feedback from implementation and users.\n\nAt the time of writing, most browsers do not support decorators. Nonetheless, you can test them out by using compilers like Babel.\n\nIn this article, we will learn how decorators compare in JavaScript and TypeScript. We will also explore the various types of TypeScript decorators, including the class, method, property, and accessor decorators.\n\nTypeScript’s decorator feature differs significantly from JavaScript’s. The first big difference concerns what we can decorate. TypeScript decorators allow us to annotate and modify class declarations, methods, properties, accessors, and parameters.\n\nTypeScript 5.0 introduces the new implementation of decorator support, which aligns with the ECMAScript stage three proposal. However, it does not currently support parameter decoration, but that might change in future ECMAScript proposals. Old TypeScript decorators do support parameter decoration. We’ll learn more about this later in the article. JavaScript, on the other hand, only lets us decorate class declarations and methods.\n\nThe second important difference between decorators in JavaScript and TypeScript is type checking. Because TypeScript is a strongly typed programming language, it can type-check the parameters and return the value of the decorator function. JavaScript lacks this type checking and validation, so you need to rely on runtime checks or external tools like linters to catch type errors.\n\nGetting started with decorators in TypeScript\n\nThe package contains the Node.js type definitions for TypeScript. We need this package to access some Node.js standard libraries.\n\nAdd an npm script in the file to compile your TypeScript code:\n\nUntil TypeScript 5.0, we had to explicitly set a flag, , to use decorators in our code. With TypeScript 5.0, this is no longer the case. While such a flag will likely stay around for the foreseeable future, we can use new-style decorators without it. In fact, the old-style decorators modeled a different version of the proposal (Stage 2). We can use both styles in our code because the type rules differ, but it’s not advisable.\n\nRemember to configure your working environment to use at least TypeScript 5. Otherwise, the code in this article won’t compile.\n\nWe’ll use as a target for TypeScript because all modern browsers support it:\n\nNext, we’ll create a simple TypeScript file to test the project out:\n\nInstead of repeating this command repeatedly, we can simplify the compilation and execution process by using a package called ts-node. It’s a community package that enables us to run TypeScript code directly without compiling it first.\n\nNext, add a script to the file:\n\nI have all the source code for this article published on my GitHub. You can clone it onto your machine using the command below:\n\nIn TypeScript, decorators are functions that can be attached to classes and their members, such as methods and properties.\n\nIn this section, we’re going to look at new-style decorators. First, the new type is defined as follows:\n\nThe definition above looks complex, so let’s break it down one piece at a time:\n• represents the element we’re decorating, whose type is\n• contains metadata about how the decorated method was declared, namely:\n• : The type of decorated value. As we’ll see, this can be either , , , , , or\n• : The name of the decorated object\n• : An object with references to a getter and setter method to access the decorated object\n• : Whether the decorated object is a class member\n• : Whether the decorated object is a class member\n• : A way to add custom initialization logic at the beginning of the constructor (or when the class is defined)\n• represents the type of value returned by the function\n\nIn the next section, we’ll examine the types of decorators. Interestingly, while old-style decorators let us decorate function parameters, new-style ones don’t, at least for now. In fact, parameter decorators are waiting for a follow-on proposal to reach Stage 3.\n\nNow that we know how the Decorator type is defined, we’ll examine the various types of decorators.\n\nClass decorators allow modification of class behavior. Upon class initialization, they are invoked and gain access to the class’s constructor, methods, and properties.\n\nWhen you attach a function to a class as a decorator, you’ll receive the class constructor as the first parameter:\n\nFor example, let’s assume we want to use a decorator to add two properties, and , to a class. In this case, we could write the following function:\n\nAfter ensuring the of the decorated element is indeed , we return a new class with two additional properties. Alternatively, we could have used prototype objects to add new methods dynamically:\n\nWe can use as follows:\n\nYou might have noticed that we had to cast to to access the new properties. That’s because decorators can’t influence the structure of the type.\n\nIf the original class defines a property that is later decorated, the decorator overrides the original value. For example, if has a property with a different value, would override\n\n such a value:\n\nAnother use of the class decorators is to enhance the existing class methods. Let’s say we have an method in the class:\n\nWe can extend the method by applying a new class decorator: :\n\nThe above decorator adds logging functionality around the method of the class, allowing us to track changes in the fuel level before and after each fuel addition operation. Now, when we add it to the class as below, the change in fuel amount will be printed in the console:\n\nAnother good place to attach a decorator is class methods. In this case, the type of the decorator function is as follows:\n\nWe can use method decorators when we want something to happen before or after the invocation of the method being decorated.\n\nFor example, during development, it might be useful to log the calls using a given method or verify pre/post-conditions before/after the call. Additionally, we can influence how the method is invoked, for example, by delaying its execution or limiting the number of calls within a given amount of time.\n\nFinally, we can use method decorators to mark a method as deprecated, logging a message to warn the user and tell them which method to use instead:\n\nAgain, the first parameter of the function is, in this case, the method we’re decorating. After making sure it’s indeed a method ( ), we return a new that wraps the decorated method and logs a warning message before calling the actual method call.\n\nWe can then use our new decorator as follows:\n\nIn the method, we refer to the method we added via the decorator. Notice how we had to cast to an instance of , as we did before. When we call , we’ll see the following output, showing that the warning gets correctly printed out:\n\nMethod decorators can be useful if you want to extend the functionality of our methods, which we’ll cover later.\n\nProperty decorators are very similar to method decorators:\n\nNot surprisingly, the use cases for property decorators are very similar to those for method decorators. For example, we can track the accesses to a property or mark it as deprecated:\n\nThe code is very similar to the decorator we defined for methods, and so is its usage.\n\nVery similar to method decorators are accessor decorators, which are decorators that target getters and setters:\n\nThe definition of accessor decorators is similar to that of method decorators. For example, we can merge our and decorations into a single, function that features support for getters and setters as well:\n\nThe new decorator proposal also introduced a new element called the “auto-accessor field”:\n\nThe transpiler will turn the field above into a pair of getter and setter methods, with a property behind the scenes. This is useful to represent a simple accessor pair and helps avoid some edgy issues that might arise while using decorators on class fields.\n\nAuto-accessors can also be decorated, and their type will essentially be a merge of and . You can find additional details in the Stage 3 decorators pull request.\n\nPlease note that the parameter decorator is not supported in TypeScript 5.0. The TypeScript documentation states: “This new decorator proposal is not compatible with — , and it does not allow decorating parameters. Future ECMAScript proposals may be able to help bridge that gap.”\n\nIf you are still supporting the older version of TypeScript code, here is how we can use the parameter decorator.\n\nA parameter decorator is placed before the parameter’s declaration and used to observe parameter declarations within methods. It takes three parameters:\n• The constructor function of the class (for static) or the class prototype (for instance)\n• The ordinal index of the parameter\n\nBelow is a simple example:\n\nThe above example defines a parameter decorator that logs the index and name of a parameter. It’s applied to the parameter of method. When an instance of class is created and its method is invoked, we can observe the console output showing the logging of the parameter information.\n\nNow that we’ve covered what decorators are and how to use them properly, let’s look at some specific problems they can help us solve.\n\nLet’s say we want to estimate how long it takes to run a function to gauge your application performance. We can create a decorator to calculate the execution time of a method and print it on the console:\n\nThe class has a method inside of it. To measure the execution time of the method, you can attach the decorator:\n\nAs you can see, the decorator replaces the original method with a new one that enables it to calculate the execution time of the original method and log it to the console. To calculate the execution time, we’ll use the Performance Hooks API from the Node.js standard library. Instantiate a new instance and call the method:\n\nYou’ll get the following result:\n\nIn TypeScript, advanced decorator patterns such as decorator composition and factories provide flexibility and reusability when applying decorators to classes, methods, and properties.\n\nDecorator composition involves applying multiple decorators to a single class, method, or property, allowing for combining different behaviors to achieve more dynamic functionality. We can compose decorators by stacking them one after another, with each decorator executing sequentially.\n\nBelow is an example of two decorators: and :\n\nWe can apply both decorators to the method, so both conditions can be enforced: the fuel level must be within the minimum and maximum levels before initiating the launch:\n\nWhen using multiple decorators in combination, the sequence is important. The decorators execute in the order they are listed. In this case, the decorator is applied first, followed by the decorator.\n\nTo configure our decorators to act differently in a certain scenario, we can use a concept called the decorator factory. Decorator factories are functions returning a decorator. This enables us to customize the behavior of our decorators by passing some parameters to the factory.\n\nTake a look at the example below:\n\nThe decorator factory generates a decorator that can be applied to a property. When applied, it adds the value provided to the decorator to the value provided during field initialization:\n\nWe can also use the decorator factory to create a class decorator. Here is an example of a class decorator called , which throttles the execution of the method:\n\nIn the above code, we retrieve the original method from the target class prototype, then call the method if the timeout is active; otherwise, we skip the call.\n\nIn this example, the class is decorated with the newly created decorator, specifying a throttle duration of 1000 milliseconds (one second). As shown in the console output, the first call to is successful, but the second call is skipped as it is still within the timeout period.\n\nAnother common use case for decorators is checking pre- and post-conditions on method calls. For example, assume we want to make sure is at least a given value before calling the method:\n\nLet’s say we have a class that has a method. To launch a rocket, the fuel level must be above, for example, 75.\n\nLet’s create the decorator for it:\n\nis a factory decorator. It takes the fuel parameter, indicating how much fuel is needed to launch a particular rocket. Just like in the previous use case, to check the fuel condition, wrap the original method with a new method. Notice how we can freely refer to , which will only work at runtime.\n\nNow, we can plug our decorator into the method and set the minimum fuel level:\n\nIf we now invoke the method, it won’t launch the rocket because the current fuel level is 50:\n\nThe cool thing about this decorator is that you can apply the same logic to a different method without rewriting the whole if-else statement.\n\nIn some scenarios, we don’t need to create custom decorators. Many TypeScript libraries and frameworks, such as TypeORM and Angular, already provide all the decorators we need. But it’s always worth the extra effort to understand what’s going on under the hood, and it might even inspire you to build your own TypeScript framework."
    },
    {
        "link": "https://medium.com/@asormeil/understanding-and-utilizing-decorators-in-typescript-a-simple-guide-2328228aac85",
        "document": "Decorators in TypeScript are a powerful and expressive feature of the language. They provide a way to add annotations and a meta-programming syntax for class declarations and members. Decorators are a part of the ECMAScript proposal, which TypeScript adopts to provide more functionality with minimal syntax.\n\nA decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form , where the must evaluate a function that will be called at runtime with information about the decorated declaration.\n\nClass Decorators: Applied to class constructors, they can observe, modify, or replace a class definition. The following example shows a simple class decorator . When the class is defined, the decorator is called.\n\nMethod Decorators: Applied to method declarations, they can be used to observe, modify, or replace method definitions. In the following example, is a method decorator that wraps the method to add logging functionality.\n\nProperty Decorators: Applied to property declarations, they provide a way to add additional metadata or logic. Here we can see that decorator assigns a default value to the property of the class.\n\nParameter Decorators: Applied to parameters in class constructors. In the next example, the decorator is used here to mark the parameter in method as required.\n\nDecorators in TypeScript offer a declarative and elegant way to modify the behavior of classes, methods, properties, and parameters. They encourage a cleaner and more modular codebase, facilitating aspects like logging, validation, and metadata management. As TypeScript continues to evolve, decorators are likely to become an integral part of the TypeScript developer’s toolkit."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/29775830/how-to-implement-a-typescript-decorator",
        "document": "TS decorators allow extra functionality to be added on a class. The class is altered by decorators at declare time, before any instance of the class is created.\n\nDecorators are declared with an sign, for example . TS will now search for a corresponding metadata function and will automatically supply it with sevaral argument which vary on what is exactly decorated (e.g. class or class property get different arguments)\n\nThese parameters are supplied in the decorator function:\n• The prototype object of the class\n• PropertyDescriptor object, looks like this\n\nDepending on the type of decorator 1-3 of these arguments are passed to the decorator function.\n\nThe following decorators can be applied to a class and TS will evaluate them in the following order (following summation comes from TS docs):\n• Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each instance member.\n• Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.\n• Parameter Decorators are applied for the constructor.\n• Class Decorators are applied for the class\n\nThe best way to understand them better is via examples. Note that these example do need significant understanding of the TS language and concepts like .\n\ndecorators can be declared via decorators function or decorator factory functions. There is a difference in syntax which is best explained via an example:"
    },
    {
        "link": "https://phrase.com/blog/posts/ultimate-guide-to-vue-localization-with-vue-i18n",
        "document": "Arguably the most approachable among the big three UI frameworks, Evan You’s Vue seems an unlikely contender among the giant Meta’s React and Google’s Angular. Yet this brainchild of one man has seen adoption that matches Angular’s, thanks to its gentle learning curve, first-class dev experience, and production-ready features.\n\nWith its popularity, Vue has given birth to a rich ecosystem of plugins, extensions, and services. Vue app internationalization (i18n) — presumably the reason you’re here — sees the robust third-party Vue I18n plugin as the apparent go-to. In this hands-on guide, we’ll use Vue I18n to internationalize a little demo app, covering everything you need to get started with Vue localization. Let’s go.\n\n✋ Heads up » This article covers Vue 3 localization. If you’re interested in Vue 2, check out Vue 2 Localization with Vue I18n: A Step-by-Step Guide.\n\n🔗 Resource » We're using the Vue I18n library in this article. If you would rather use i18next, our Deep Dive: Vue Translation with vue-i18next might be useful to you.\n\nWe’ve used the following NPM packages in this article (versions in parentheses).\n• Tailwind CSS (3.1) — used for styling and optional for our purposes\n\n🗒 Note » To focus on the i18n, we won’t show any CSS styling in this article. You can find all styling code in the full code of our article on GitHub.\n\nOur humble demo, Mushahed, is based on data from the Open Notify space APIs.\n\nShout outs to the following people and organizations for providing their assets for free.\n• We’ve used the Satellite icon by Akriti Bhusal on The Noun Project for our demo brand icon.\n• Cai Xuzhe’s photo and Chen Dong’s photo are copyrighted by China News Service and used under the CC BY 3.0 license.\n• Liu Yang’s photo is copyrighted by Manfred Werner (Tsui) and used under the CC BY-SA 3.0 license.\n• All other astronaut photos are public domain.\n\nOur demo is a Vue SPA spun up with . We added router support and opted out of TypeScript when the project was being scaffolded. After the requisite gutting of the boilerplate components added by the scaffolding tool, we built this little hierarchy:\n\n🗒 Note » Our houses a Vue and we’re using s in our nav. We’ll look at routing a bit later.\n\nLet’s take a closer look at our component.\n\nWhen is created, we load our astronaut data from and feed it to instances of the presentational .\n\nNote that our UI strings are all hard-coded in English at this point. Let’s take care of this and localize our app.\n\n🔗 Resource » We’re omitting much of our demo starter code for brevity. You can get all of it from the start-options branch of our GitHub repo.\n\nHow do I install and set up Vue I18n?\n\nThis will shock you: We start with an NPM install on the command line from the root of our Vue project.\n\n🗒 Note » You’ll want v9+ of Vue I18n if you’re working with Vue 3. Vue 2 uses Vue i18n v8.\n\n🔗 Resource » Check out all the ways to install Vue I18n in the official documentation.\n\nOnce NPM has done its thing, we need to create a Vue I18n instance, configure it, and register it as a plugin with our Vue instance. Let’s construct the Vue I18n instance in a new module. We’ll create a directory called and place an file within.\n\nWe pass our translation to the i18n object that we construct with . The initial locale, the one our app defaults to on first load, is set via the config option.\n\n🗒 Note » I’m supporting English ( ) and Arabic ( ) in my app. Feel free to support any languages you want here. Use a standard BCP 47 language tag (like ) or a language tag with a region subtag (like ) to identify your translation locales.\n\n🔗 Resource » All config options for are available in the official API documentation.\n\nOur Vue instance now needs to register our object as a plugin with a call.\n\nThat should round out our setup. Let’s test our i18n by internationalizing the app title in our component.\n\nWe'll replace the hard-coded text with the following.\n\nAvailable to all our components now is Vue I18n’s translation function. Calling when the active locale is English ( ) will cause to return the message we specified at above. When the active locale is Arabic ( ), is returned.\n\n🤿 Go deeper » Check out the myriad ways to use in the official API listing.\n\nIf we reload our app now we should see no change: That’s because our initial locale is configured to English. Let’s switch it to Arabic.\n\nOur app name translated to Arabic\n\nThat’s all it takes to start working with Vue I18n in our apps. Of course, we probably want to keep adding translation messages as we grow our app. To keep things tidy, let’s refactor our object to its own module.\n\n🗒 Note » When developing with Vue I18n, you might get a warning in your browser console that says, “You are running the esm-bundler build of vue-i18n…”. This is a known issue and may be fixed by the time you read this.\n\nHow do I translate messages in my components?\n\nWe touched on this when we tested our Vue I18n installation above, but it bears repeating. It takes two steps:\n• In our object, under each of our locales, we add translations with a shared key.\n• We use in our component templates to render the translation corresponding to the active locale.\n\nLet’s apply this by localizing the rest of our component. We'll need a few more translations to start.\n\nWe can use with the syntax to translate the inner text of an element. When translating an attribute, the binding shorthand comes in handy.\n\nHow do I work with dynamic values in my translation messages?\n\nA common use case, interpolating values that change at runtime in our messages is easy with Vue I18n. Our component, which shows the coordinates of the International Space Station (ISS) at a given time, is a perfect place to demonstrate.\n\nWe’ve hard-coded the coordinate and datetime values above for clarity, but in a real app these would likely be fetched from an API and updated on component . Vue I18n accommodates these dynamic values in its messages via a syntax.\n\nPassing a second argument to — a map of key/value pairs where the keys match the ones in our translation messages — renders these messages with the injected values.\n\n🗒 Note » The numbers and date above are not in Arabic. We’ll take care of this a bit later.\n\n🤿 Go deeper » Learn all the ways you can interpolate in messages from the official Vue I18n documentation.\n\nHow do I translate strings in my component JavaScript?\n\nThe function is available to our component JavaScript via . Let’s use this to refactor our component and move that chunky call to our component .\n\nHow do I work with HTML within my translation messages?\n\nOn occasion, we will need to place HTML inside our translation messages. Our is a good example.\n\nLocalizing this string is tricky because the locations of the embedded links can differ depending on the translation language. We could just place the tags directly in our translation messages and exploit Vue’s unsafe directive to output the translations. This would expose us to XSS attacks if we’re not careful, however.\n\nVue I18n offers a better solution: Its component allows us to render its children, including HTML elements, inside our messages via placeholders.\n\nWe pass a prop with the key of our parent translation message, in this case. For rendering, we let know that we want it to output a surrounding via the prop.\n\nWithin our parent message, we specify placeholders using list interpolation, meaning we index our placeholders starting with and moving on to , etc. Order matters here: The first inside will replace the placeholder, the second will replace , and so on. This allows us to control the order our HTML elements appear in each language’s translation message.\n\n🗒 Note » If we don’t explicitly set the prop on the component we will get a console warning reading, “[intlify] Not found parent scope. use the global scope.”\n\n🔗 Resource » The Component Interpolation section of the official guide covers the component in further detail.\n\nHow do I work with plurals in my translations?\n\nThe two English plural forms are simple: “a satellite is orbiting above”; “three satellites are orbiting above”. Other languages are more complex. Some have four plural forms. Welsh and Arabic have six. Vue I18n handles simple plurals, like those of English, out of the box. We can extend the plugin to handle complex plurals. We’ll cover both simple and complex plurals here.\n\n🔗 Resource » The CLDR Language Plural Rules reference is canon for languages’ plural forms.\n\nLet’s revisit the header of our component for a moment.\n\nOur astronaut counter is hard-coded and ripe for localization. Let’s add an English message for it.\n\nVue I18n expects plural forms to be separated by a pipe ( ) character. We’ve specified the two plural forms for English above. The placeholder will be replaced by an integer counter when we retrieve the plural message.\n\n, another translation function injected by Vue i18n into all of our components, chooses the correct plural form based on its second parameter, the integer counter.\n\nRenders of English plural forms. Note that {n} is replaced with our counter.\n\nTwo forms work fine for English, but our Arabic translation will need six plural variants.\n\nOn its own Vue I18n only works with English-like plurals, so we need to add a custom extension function that handles Arabic’s six forms.\n\nJavaScript’s standard Intl.PluralRules object handles complex plurals wonderfully. All we have to do is give it a locale when constructing it, then call its method with an integer counter. The method returns the name of the correct form for the given language. For example, returns the correct form.\n\nVue I18n needs an integer index to select the correct form in our translation messages, so our custom plural selector needs to map the CLDR plural form name ( ) to a zero-based index ( ). The index selects from our pipe-separated message. So would select our fourth variant from the message above.\n\nAll we have to do now is wire up our Arabic plural rule selector when constructing the Vue I18n instance.\n\nWith our selector wired up, our Arabic plurals should work like a charm.\n\nRenders of Arabic plural forms. Note that {n} is replaced with our counter.\n\n✋ Heads up » You may have noticed that the interpolated counter is being displayed in Western Arabic numerals (1, 2, etc.). However, Arabic uses Eastern Arabic numerals (١، ٢، ٣، etc.). While not a showstopper, I have logged this issue on the Vue i18n GitHub if you care to follow it.\n\n🔗 Resource » Learn more from the official guide on pluralization.\n\nDifferent locales use different numeral systems, thousands separators, and symbols when representing numbers. JavaScript’s built-in Intl.NumberFormat object handles all this for us and is used under the hood by Vue I18n. We just need to give Vue I18n preconfigured number formats, which the plugin in turn passes to . The formats we registered are then available to use in our components.\n\n🤿 Go deeper » Our Concise Guide to Number Localization covers numeral systems, separators, and more.\n\nWe need to register our number formats with the Vue I18n object during construction.\n\nNow we can use the injected function to format localized numbers in our component templates.\n\n✋ Heads up » You may have noticed that we swapped with and with in our configuration above. This is because number formatting is region-specific, not language-specific. Adding countries or regions to our locale tags means we can control the output of localized number formatting. Otherwise, we risk the browser using a default region. Of course, we have to update our so that they’re keyed with and as well.\n\nLet’s update our component to format the ISS coordinates in the active locale’s number format.\n\n🔗 Resource » Get more details from the Number Formatting section of the Vue I18n documentation.\n\nThe date above looks very English in the otherwise Arabic message, doesn’t it? No worries. Guess what’s next?\n\nHow do I format localized dates and times?\n\nMuch like number formatting, date formatting is region-specific. The US and Canada both use English, but the 9th of September, 2022 can be 9/4/2022 in the US and 2022-09-04 in Canada. To work with localized dates correctly, we follow a recipe much like we did with dates. We provide Vue I18n with named datetime formats, which the plugin passes as options to the standard Intl.DateTimeFormat. We then use these registered formats in our components.\n\n🗒 Note » Date localization is very similar to number localization, so this section builds on the last.\n\nWith formats specified and registered, we can use the injected function to display localized dates in our components. Let’s round out our component with proper date formatting.\n\nWhile we’re at it, let’s format our header to show localized short dates in its “Updated” message.\n\n🔗 Resource » The official Vue I18n guide covers more date formatting options.\n\nHow do I retrieve the active locale?\n\nSometimes we need to make decisions based on the runtime locale of the app. With Vue I18n we can get the active locale simply via .\n\nWe can also assign a new value to to set a new active locale. We’ll see this in action momentarily.\n\nIn the next few sections we’ll tackle some advanced topics like localized routes and asynchronous translation file loading. These will be easier to implement if we refactor our little i18n library so that we can control how locales are set and loaded.\n\n🗒️ Note » Vue I18n supports scoping which we can use to change the locale for a subset of our app’s component hierarchy. We use to access Vue I18n’s global, app-wide scope. This is Vue I18n's default scope, and we’ll only work with global scope in this article.\n\nLet’s see how the rest of our app changes based on this refactor.\n\nNothing else in our app needs to change, yet our refactor will allow us to build more complex features in the following sections more easily.\n\nHow do I localize my routes?\n\nIt’s often a good idea to make sure that our URLs reflect the associated content. Localized URLs can mean that and point to the English and Arabic versions of the page, respectively. Let’s get this working in our demo app.\n\nFirst, let’s take a look at how we’ve configured the routes in our demo.\n\nOur relatively simple setup has the route loading our and loading our . The components are loaded inside a in the root component.\n\nLet’s localize these routes so that shows the English About page and shows the Arabic About page.\n\n🔗 Resource » The official Vue Router guide is a great start to learn the basics of Vue routing.\n\nWith these changes, if we now visit , we will be redirected to (assuming is our configured default locale). is our localized root route. It shows the in the ’s by default. shows the .\n\nHowever, if we visit , or any other Arabic route, we’re greeted with English translations. That’s because we’re not switching the active locale when the route parameter changes. Let’s remedy this using a router navigation guard.\n\nThe Vue router’s handy global beforeEach() guard runs before any navigation, ensuring that when the locale param in the URL changes we’ll know about it. We pass an anonymous callback to the guard, and use our new function to update Vue I18n’s active locale when the locale param changes. This means that when we hit , we’ll see the Arabic version of the About page.\n\nOne problem with our current localized routing solution is that we would need to inject the route parameter manually every time we create a router link.\n\nThis doesn’t scale very well and is error-prone. Let’s DRY (Don’t Repeat Yourself) this up by wrapping Vue’s in a custom component that handles route localization automatically.\n\nOur new is almost a drop-in replacement for s. We just need to be careful to use relative URLs for anything other than the root route.\n\nTo allow our site visitors the ability to select their locales, let’s build a language switcher dropdown component that makes use of our localized routes. First, we’ll configure and expose our app’s supported locales in our i18n library.\n\nWe can now import our and use them in a new component, which wraps a humble .\n\n🤿 Go Deeper » We’re using in our to navigate to the chosen locale’s root route. Learn more about Vue Router’s programmatic navigation in the official guide.\n\nNow we can drop our new component into our app’s navigation bar for our users.\n\nIf you’re not using localized routes, you can bind directly to as follows.\n\n🤿 Go Deeper » You can learn more about locale changing in Vue I18n’s documentation.\n\nHow do I load my translation files asynchronously?\n\nAs our apps grow, and we add more supported locales, we risk bloating our main bundle with all our translation messages. Realistically we will only need messages for the current visitor’s chosen locale. We can make our main bundle leaner by downloading only the active locale’s messages when needed.\n\nLet’s add this async translation loading to our demo app. We’ll start by breaking our file up into per-locale JSON files.\n\nNext we’ll add a loading function to our i18n library.\n\nuses Webpack’s async code splitting and dynamic imports to asynchronously load the translation file for the given locale. Once the translation file has loaded, it feeds the file’s messages to Vue I18n, associating them with the given locale. Finally, to ensure that Vue has updated the DOM before we resolve, we return the Promise from nextTick().\n\nNow we can update the navigation guard in our router to load the locale’s messages before rendering a route’s associated component.\n\nIf we reload our app now we shouldn’t see any major changes. However, if we open the network tab in our browser’s developer tools, we should see that a message JSON file loads in when we switch locales.\n\n🔗 Resource » Read more about async/lazy loading in Vue I18n’s Lazy loading guide.\n\nHow do I work with locale fallback?\n\nYou may have noticed some console warnings after implementing asynchronous translation loading above. The warnings occur when you load an route for the first time.\n\nVue I18n attempting to fall back on a more general locale when it can't find a translation message\n\nWhat’s happening is that Vue I18n can’t find any message when the app first loads. The messages load in a HTTP request separate from the main bundle, so they may not be available when the app first loads. We’ll address this in a minute.\n\nNotice, however, that Vue I18n tries to find the message in a general locale when it can’t find it in the region-specific locale. This is the library’s default fallback behaviour. It can come in quite handy when one of our locales is missing translations.\n\n🤿 Go Deeper » Check out all of the options Vue I18n gives you for fallback in the Fallbacking guide.\n\nA config option is available to us as a bottom catch-all: Any locales we list under will be used to display a message if one can’t otherwise be found. Let’s use this option to ensure that we fall back on English in our app.\n\nWe our translation messages and pass them into Vue I18n’s option. This will include our English messages in the main bundle, ensuring that our app won’t have to wait for them to load asynchronously. Setting as the ensures that the equivalent English message will be shown instead of a missing message in another locale.\n\nThe English message for \"home\" is used instead of the missing Arabic message\n\nWith that in place, our little demo app is internationalized.\n\n🔗 Resource You can get all of the code of the internationalized Options API demo app we built above from GitHub. The demo code includes some features we didn’t have space for in this article, like listening for locale changes to reload data and right-to-left language support.\n\nHow do I localize my Vue app with the Composition API?\n\nEverything we’ve covered in this article so far pertains to Vue’s object-oriented Options API. If your app is using the Composition API in Vue 3, we got you covered in this section.\n\n✋ Heads up » Vue I18n is designed to work with either the Options API or Composition API, but not both. The Vue I18n Options API is the default and is called the Legacy API. Read the Migration to Composition API from Legacy API guide for information about limitations and caveats.\n\nBefore we refactor our I18n code, let’s briefly look at how we would refactor our Vue components (sans I18n) from the Options API to the Composition API.\n\n🗒️ Note » The following sections build on what we’ve already covered in this article. If you’re new to Vue I18n it’s recommended that you read the rest of the article before continuing.\n\nOnly three files in our demo need to be refactored for Composition: , , and .\n\n🔗 Resource » We’ll stop here to keep things brief and get to the i18n. You can view the diff for the Composition API refactor (before i18n) on our GitHub repo.\n\nRefactoring i18n to use the Composition API\n\nThere’s not too much to change if we want to use Vue I18n’s Composition API. Here’s what we’ll cover:\n• Refactoring all calls to their functional equivalents in our component s.\n\nLet’s get to it.\n\nBy default Vue I18n is in “legacy” mode, where returns a object instance. We want the factory function to create a Composer instance, which provides functions like and to our composition component.\n\nTo accomplish this, we just need to pass one option to , setting .\n\nAs soon as we start using the Composition with we need to refactor our calls to Vue I18n’s , since now acts like a reactive ref.\n\nThat’s all we we have to change in our i18n library. The remaining updates will be in our components.\n\n🔗 Resource » Check out the Composition API guide for additional info.\n\nUsing t() instead of tc() for plural messages\n\nVue I18n’s Composer instance doesn’t have a function for outputting plural messages; switching to the Composition API will cause Vue I18n to throw an error whenever we attempt to use . Instead, we can just the regular function as a drop-in replacement.\n\n🗒️ Note » , , and work in component s in both Legacy and Composition modes. This is because, by default, Vue I18n injects them globally in both modes. This is not the case with component , where , etc. are not available in Composition mode. We’ll deal with that next.\n\nIn our component we’re using , and to retrieve translation messages and localized dates and numbers, respectively.\n\nWhen we switch the Composition API, we no longer have pointing to the component instance, so we can’t use and its ilk anymore. Vue I18n provides a function that returns the Composer instance, which includes and company. Let’s see it in action.\n\n✋ Heads up » Don’t use the $ prefix with the functional variants in component s.\n\nJust like needed to be refactored, so to does . We can get and set the active by destructuring it from the Composer instance in our components. Let’s refactor our and components to use the reactive property.\n\n🔗 Resource » The Composer instance exposes other properties: Check out the API docs for a comprehensive listing.\n\nAnd with that, our refactor is complete.\n\nOur demo works exactly as it did in Legacy mode\n\n🔗 Resource » You can get the complete code for the Composition i18n demo from GitHub.\n\n🔗 Resource » If you're interested in general JavaScript i18n, including other UI and i18n libraries, you might enjoy our Ultimate Guide to JavaScript Localization.\n\nThat about does it for our Vue 3 i18n demo. We hope you enjoyed it and learned a few things along the way. If you’re looking to take your i18n game to the next level, check out Phrase. Phrase supports Vue I18n out of the box with its In-Context Editor, allowing your translators to update messages directly in your app. The fully-featured Phrase web console, with machine learning and smart suggestions, is a joy for translators to use. Once translations are ready, they can sync back to your project automatically — Phrase comes with a CLI and syncs with Bitbucket, GitHub, and GitLab. You set it and forget it, leaving you to focus on the code you love. Check out all the features Phrase has to offer, and give it a spin with a 14-day free trial."
    },
    {
        "link": "https://medium.com/simform-engineering/globalize-your-vue-app-a-practical-guide-to-vue-3-internationalization-93f5c7da4494",
        "document": "A step-by-step guide to creating an international website with Vue 3 and Vite.\n\nBuilding web experiences that can cater to a diverse audience is important, and so is internationalization to create applications adapted to different languages and cultures.\n\nInternationalization is also known as i18n, which means “I — eighteen letters — N”. It helps improve user experience through features such as language switching, date and time formatting, and number formatting.\n\nIn today’s digital world, overlooking internationalization in your projects could mean leaving out a significant number of users who speak different languages or have diverse cultural preferences.\n\nWhen you embrace internationalization, you’re not just making your websites or apps accessible, you’re also making them attractive and relatable to people from various backgrounds.\n• Localization (L10n): Adapting an application for a specific language or region by translating text and adjusting date formats without altering the core functionality.\n• 0Translation: Converting UI labels, messages, and other user-facing text from one language to another while preserving the original meaning.\n• Globalization (G11n): Designing software to be easily adapted to different languages and regions, encompassing both internationalization and localization efforts.\n\nSo, let’s start exploring internationalization with the Vue internationalization example.\n\nVue I18n is a powerful internationalization plugin for Vue.js applications that makes the process of handling multilingual content seamless. Before delving into the practical implementation, let’s grasp the key concepts of Vue I18n.\n• Locale \n\nA locale represents a specific language and region combination (e.g., ‘en-US’ for English in the United States). Vue I18n allows your application to switch between different locales dynamically.\n• Messages\n\nMessages are key-value pairs that hold the translations for your application. Each key corresponds to a specific phrase or sentence in your application, and its value is the translation in a particular language.\n• Translation\n\nThe process of providing content in multiple languages. Vue I18n facilitates the storage and retrieval of translations based on the current locale.\n\nNow, let’s use the command to create a new Vue 3 project. Navigate to the desired directory and run:\n• To start with Vue 3 Internationalization, install the vue-i18n package. This can be done using npm or yarn.\n• Here are the respective commands to install the library:\n• After installation, create a new file for configuration.\n• In this file, we will place all of the i18n’s configuration.\n• The default locale that I want to configure is English:\n• Set legacy to false. By this, legacy API will be removed and only be left with the vue-i18n’s composition API\n• :- Fallbacks come into play when a translation is missing for a specific locale. This ensures that even if a translation is unavailable for a specific locale, the user will still see content in a language they understand. In this case, we set it to\n• Set message object to message property in the function, which returns value according to language (For message object, refer to next point as we need to add locale files for this step)\n• Once the configuration is done, import this file into our\n• First, create a folder named in the src folder\n• In this folder, create a file for all locales that you want to include for internationalization\n• For now, we will create two files: &\n• As mentioned above, we import these two files in for messages. Directory structure for different languages in the locales folder looks like:\n• As we build internationalized Vue.js applications, providing users with the ability to switch between different locales (languages) is a key feature.\n• Switching the locale is quite simple: Just assign the new locale to the property.\n\nLet’s create a file and save it as\n• In it, create a dropdown button with the two languages we have in the locales folder.\n• Ensure that your language-sensitive content is properly set up in your Vue I18n messages.\n• Add this component to the navbar so we can change language easily\n\nHow to use Vue I18n inside the Vue 3 components?\n• Once you have set up the global I18n instance, you can use it in your components. You can access the method to retrieve translations.\n• Another option is to import the composable function. This function returns the global composer instance.\n\nUse VueI18n to Translate Your templates\n• Named interpolation:- \n\nThe Named interpolation can be interpolated in the placeholder using variable names defined in JavaScript.\n• List interpolation:- \n\nThe List interpolation can be interpolated in the placeholder using an array defined in JavaScript.\n• Literal interpolation:- \n\nThe Literal interpolation can be interpolated in the placeholder using a literal string.\n• Simple text:- \n\nTo use a translation, use the function with a translation id as a parameter, as already seen above.\n• Translating attribute values:-\n\nYou can pass translated attribute values to sub-components this way.\n\nVue I18n provides built-in support for formatting numbers and dates according to the user’s locale.\n\nBefore diving into usage, let’s configure Vue I18n to handle number and date formatting. Update your Vue I18n instance in :\n• We add this format to createI18n functions in i18n configurations:\n• Number formatting:- The method is used for formatting numbers, and the second parameter corresponds to the defined formatting style.\n• Date formatting:- is the method for formatting dates, and ‘shortFormat’ is the defined date and time formatting style.\n\nPluralization is about changing the text depending on the values. e.g., in English, you want to say 1 flower but 2 flowers.\n\nPluralization is a crucial aspect of internationalization that addresses the challenge of adapting content based on numeric values.\n• Usage: Define the locale messages that have a pipe separator and define plurals in the pipe separator.\n• Plural messages are selected by the logic of the choice rule in the translation API according to the numeric value you specify at the translation API.\n• Passing a number to the translation method will return appropriate translations.\n• To enhance the organization and maintainability of your Vue I18n translations, consider structuring your translation messages in a well-defined JSON format.\n• This approach not only streamlines the management of multilingual content but also ensures consistency and clarity across your application.\n• JSON structure: Organize translations into logical sections or screens, each represented by an object.\n• Using JSON structure in Vue I18n:\n\nIn your components, access translations by referencing the appropriate keys in your JSON file. For example:\n• Vue I18n allows you to create references to other translations within your JSON files.\n• This feature enables you to reuse common phrases or terms across different contexts, promoting consistency and simplifying the management of your multilingual content.\n• In this example, we use ​\n• : Uppercase all characters in the linked message\n• : Lowercase all characters in the linked message\n• : Capitalize the first character in the linked message\n• In this example, we use ​ which will return a word in lowercase like “about us”.\n\nVue 3 Internationalization is an important feature for building multilingual applications. With its powerful features, it allows developers to create and manage translations easily.\n\nBy following these guidelines, you can create high-quality multilingual applications using Vue 3 Internationalization."
    },
    {
        "link": "https://stackoverflow.com/questions/43700573/internationalization-in-vue-js",
        "document": "What are the best practices for internationalization in Vue?\n\nCurrently I'm thinking of having a 'strings' object that contains all strings, then a bit of ajax magic to update that strings object based on a json file with translated strings to certain languages.\n\nAnyone got any better ideas? I'm currently having a bit of trouble using my strings approach since the strings object has to be loaded before anything else.\n\nIs there a placeholder functionality for strings in Vue? For example, I have a menu whose entries reside in my vm's data. Is there a way to set that to a static string and then automatically bind that to another string once it exists?"
    },
    {
        "link": "https://30dayscoding.com/blog/implementing-internationalization-i18n-in-vuejs-applications",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/75167471/using-t-translation-on-props-in-vue-with-vue-i18n",
        "document": "I would like to translate the titles that are passed to my component via props. However I assume because my strings are being passed via props they are not being translated like the rest of my code. Below you will find my current 2 components that I am working with:\n\nHow ever if I do add the below variation it obviously wont work."
    }
]