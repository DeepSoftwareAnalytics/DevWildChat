[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/forms/formsets",
        "document": "A formset is a layer of abstraction to work with multiple forms on the same page. It can be best compared to a data grid. Let’s say you have the following form:\n\nYou might want to allow the user to create several articles at once. To create a formset out of an you would do:\n\nYou now have created a formset class named . Instantiating the formset gives you the ability to iterate over the forms in the formset and display them as you would with a regular form:\n\nAs you can see it only displayed one empty form. The number of empty forms that is displayed is controlled by the parameter. By default, defines one extra form; the following example will create a formset class to display two blank forms:\n\nFormsets can be iterated and indexed, accessing forms in the order they were created. You can reorder the forms by overriding the default and behavior if needed.\n\nInitial data is what drives the main usability of a formset. As shown above you can define the number of extra forms. What this means is that you are telling the formset how many additional forms to show in addition to the number of forms it generates from the initial data. Let’s take a look at an example: There are now a total of three forms showing above. One for the initial data that was passed in and two extra forms. Also note that we are passing in a list of dictionaries as the initial data. If you use an for displaying a formset, you should pass the same when processing that formset’s submission so that the formset can detect which forms were changed by the user. For example, you might have something like: .\n\nThe parameter to gives you the ability to limit the number of forms the formset will display: If the value of is greater than the number of existing items in the initial data, up to additional blank forms will be added to the formset, so long as the total number of forms does not exceed . For example, if and and the formset is initialized with one item, a form for the initial item and one blank form will be displayed. If the number of items in the initial data exceeds , all initial data forms will be displayed regardless of the value of and no extra forms will be displayed. For example, if and and the formset is initialized with two initial items, two forms with the initial data will be displayed. A value of (the default) puts a high limit on the number of forms displayed (1000). In practice this is equivalent to no limit. By default, only affects how many forms are displayed and does not affect validation. If is passed to the , then will affect validation. See validate_max.\n\nValidation with a formset is almost identical to a regular . There is an method on the formset to provide a convenient way to validate all forms in the formset: We passed in no data to the formset which is resulting in a valid form. The formset is smart enough to ignore extra forms that were not changed. If we provide an invalid article: # <-- this date is missing but required As we can see, is a list whose entries correspond to the forms in the formset. Validation was performed for each of the two forms, and the expected error message appears for the second item. Just like when using a normal , each field in a formset’s forms may include HTML attributes such as for browser validation. However, form fields of formsets won’t include the attribute as that validation may be incorrect when adding and deleting forms. To check how many errors there are in the formset, we can use the method: # Using the previous example We can also check if form data differs from the initial data (i.e. the form was sent without any data): You may have noticed the additional data ( , ) that was required in the formset’s data above. This data is required for the . This form is used by the formset to manage the collection of forms contained in the formset. If you don’t provide this management data, the formset will be invalid: It is used to keep track of how many form instances are being displayed. If you are adding new forms via JavaScript, you should increment the count fields in this form as well. On the other hand, if you are using JavaScript to allow deletion of existing objects, then you need to ensure the ones being removed are properly marked for deletion by including in the data. It is expected that all forms are present in the data regardless. The management form is available as an attribute of the formset itself. When rendering a formset in a template, you can include all the management data by rendering (substituting the name of your formset as appropriate). As well as the and fields shown in the examples here, the management form also includes and fields. They are output with the rest of the management form, but only for the convenience of client-side code. These fields are not required and so are not shown in the example data. has a couple of methods that are closely related to the , and . returns the total number of forms in this formset. returns the number of forms in the formset that were pre-filled, and is also used to determine how many forms are required. You will probably never need to override either of these methods, so please be sure you understand what they do before doing so. provides an additional attribute which returns a form instance with a prefix of for easier use in dynamic forms with JavaScript. The argument lets you override the default messages that the formset will raise. Pass in a dictionary with keys matching the error messages you want to override. Error message keys include , , and . The and error messages may contain , which will be replaced with and , respectively. For example, here is the default error message when the management form is missing: ['ManagementForm data is missing or has been tampered with. Missing fields: form-TOTAL_FORMS, form-INITIAL_FORMS. You may need to file a bug report if the issue persists.'] And here is a custom error message: \"Sorry, something went wrong.\" ['Sorry, something went wrong.'] A formset has a method similar to the one on a class. This is where you define your own validation that works at the formset level: \"\"\"Checks that no two articles have the same title.\"\"\" # Don't bother validating the formset unless each form is valid on its own \"Articles in a set must have distinct titles.\" ['Articles in a set must have distinct titles.'] The formset method is called after all the methods have been called. The errors will be found using the method on the formset. Non-form errors will be rendered with an additional class of to help distinguish them from form-specific errors. For example, would look like: Articles in a set must have distinct titles.\n\nDealing with ordering and deletion of forms¶ The provides two optional parameters and to help with ordering of forms in formsets and deletion of forms from a formset. Lets you create a formset with the ability to order: This adds an additional field to each form. This new field is named and is an . For the forms that came from the initial data it automatically assigned them a numeric value. Let’s look at what will happen when the user changes these values: also provides an attribute and method that control the widget used with . Set to specify the widget class to be used with : Override if you need to provide a widget instance for use with : Lets you create a formset with the ability to select forms for deletion: Similar to this adds a new field to each form named and is a . When data comes through marking any of the delete fields you can access them with : If you are using a , model instances for deleted forms will be deleted when you call . If you call , objects will not be deleted automatically. You’ll need to call on each of the to actually delete them: On the other hand, if you are using a plain , it’s up to you to handle , perhaps in your formset’s method, as there’s no general notion of what it means to delete a form. also provides a attribute and method that control the widget used with . Set to specify the widget class to be used with : Override if you need to provide a widget instance for use with : While setting , specifying will remove the option to delete extra forms.\n\nUsing a formset in views and templates¶ Formsets have the following attributes and methods associated with rendering: Specifies the renderer to use for the formset. Defaults to the renderer specified by the setting. The name of the template rendered if the formset is cast into a string, e.g. via or in a template via . By default, a property returning the value of the renderer’s . You may set it as a string template name in order to override that for a particular formset class. This template will be used to render the formset’s management form, and then each form in the formset as per the template defined by the form’s . The name of the template used when calling . By default this is . This template renders the formset’s management form and then each form in the formset as per the form’s method. The name of the template used when calling . By default this is . This template renders the formset’s management form and then each form in the formset as per the form’s method. The name of the template used when calling . By default this is . This template renders the formset’s management form and then each form in the formset as per the form’s method. The name of the template used when calling . By default this is . This template renders the formset’s management form and then each form in the formset as per the form’s method. Returns the context for rendering a formset in a template. The available context is:\n• None : The instance of the formset. The render method is called by as well as the , , , and methods. All arguments are optional and will default to: Renders the formset with the template. Renders the formset with the template. Renders the formset with the template. Renders the formset with the template. Using a formset inside a view is not very different from using a regular class. The only thing you will want to be aware of is making sure to use the management form inside the template. Let’s look at a sample view: # do something with the formset.cleaned_data The template might look like this: However there’s a slight shortcut for the above by letting the formset itself deal with the management form: The above ends up calling the method on the formset class. This renders the formset using the template specified by the attribute. Similar to forms, by default the formset will be rendered , with other helper methods of , , and being available. The rendering of the formset can be customized by specifying the attribute, or more generally by overriding the default template. If you manually render fields in the template, you can render parameter with : Similarly, if the formset has the ability to order ( ), it is possible to render it with . Using more than one formset in a view¶ You are able to use more than one formset in a view if you like. Formsets borrow much of its behavior from forms. With that said you are able to use to prefix formset form field names with a given value to allow more than one formset to be sent to a view without name clashing. Let’s take a look at how this might be accomplished: # do something with the cleaned_data on the formsets. You would then render the formsets as normal. It is important to point out that you need to pass on both the POST and non-POST cases so that it is rendered and processed correctly. Each formset’s prefix replaces the default prefix that’s added to each field’s and HTML attributes."
    },
    {
        "link": "https://stackoverflow.com/questions/501719/dynamically-adding-a-form-to-a-django-formset",
        "document": "This is how I do it, using jQuery:\n\nWhat it does:\n\naccepts as the first argument, and the of formset as the 2nd one. What the should do is pass it what it should duplicate. In this case, I pass it so that jQuery looks for the last table with a class of . The part of it is important because the is also used to determine what the new form will be inserted after. More than likely you'd want it at the end of the rest of the forms. The argument is so that we can update the field, notably , as well as the actual form fields. If you have a formset full of, say, models, the management fields will have IDs of and , while the form fields will be in a format of with being the form number, starting with . So with the argument the function looks at how many forms there currently are, and goes through every input and label inside the new form replacing all the field names/ids from something like to and so on. After it is finished, it updates the field to reflect the new form and adds it to the end of the set.\n\nThis function is particularly helpful to me because the way it is setup it allows me to use it throughout the app when I want to provide more forms in a formset, and doesn't make me need to have a hidden \"template\" form to duplicate as long as I pass it the formset name and the format in which the forms are laid out."
    },
    {
        "link": "https://justdjango.com/blog/dynamic-forms-in-django-htmx",
        "document": "This tutorial will cover how to build dynamic forms in Django using Htmx. It will also cover the basic concepts of Django formsets. But most of all, we're going to focus on how to make dynamic forms look and feel good.\n\nYou can find the code from this tutorial in this GitHub repository\n\nIf you want to watch the video instead of reading:\n\nFor this project we will work with the same set of models. Create a Django app and register it in the settings:\n\nAdd it to INSTALLED_APPS in settings.py Inside add the following models:\n\nAnd add the following to :\n\nUsing these models we can create an author and add as many books as we want to that author.\n\nHow to use Django Formsets\n\nFormsets are one of the best parts of Django. The idea behind formsets is that you get a really flexible rendering of forms in your template and you don't have to write a lot of code to achieve it.\n\nFormset factories are the main tools you can use to create formsets in Django:\n\nCreate a file inside the app and add the following:\n\nWe'll use the to create the formset but the other functions work pretty much the same way. The only difference is that and work specifically with forms that inherit from .\n\nHere we are creating an inline formset. The first argument is the parent model, which in this case is the . The second argument is the child model which is the . The form argument is the form used to create instances, and the other arguments change the styling of the form.\n\nWe'll now use this form in a function-based view. Inside add the following:\n\nIn this view we create an instance of the and pass it into the context. If the request method is a request we then pass the request into the form, check if it is valid and then call the method. Because we are using a this will save the values of the form as instances. Notice we're also assigning the of the formset as the author. The property is needed to link the child models to the parent.\n\nImportant to note is that this view requires the primary key of the author that we will add books to. Create a few authors in the Django admin:\n\nAdd a superuser so you can login to the admin:\n\nAdd the view to the project :\n\nIn the root of the project create a folder and inside it create . Add the following to it:\n\nRegister the templates folder in the :\n\nVisit and you should see three forms to create books as well as the heading showing .\n\nInspect the page and go to the tab in the developer tools - you should see the following:\n\nDjango's formsets include a lot of hidden fields. The renders them in the template. These fields are very important because they provide Django with meta information about the forms. To understand how to make dynamic formsets it is important to understand how the forms are rendered.\n\nFill in the book form and submit it. You should see the newly created books display at the bottom of the page.\n\nHow to setup Htmx with Django\n\nHtmx is a library that allows you to access modern browser features directly from HTML, rather than using JavaScript.\n\nThere are many examples of how to use Htmx for things like deleting table rows, progress bars, file uploads and much more.\n\nSo the question is; how do you use Htmx for dynamic forms?\n\nThere are some packages available to setup Htmx with Django. However, we are going to install it from scratch. You can also follow the official Htmx installation docs.\n\nWe will use a for all the other templates to inherit from so that they all contain the required files for Htmx. Create and add the following:\n\nIn the head of the document we've added the script to use the CDN for Htmx. We've also added a script at the bottom for Htmx to listen for requests and add the so that requests are accepted.\n\nThe first Htmx view we'll create is the view that will return a new form.\n\nNotice that we are using the here. Not the .\n\nAdd the view to the :\n\nNow back inside replace everything with the following:\n\nWe're now extending from which lets us use Htmx properties. On the button element we've added the attribute which is pointing to the URL. The target is set as the div with an ID of . Lastly the attribute is for configuring how the response is rendered. will add the response to the end of the div.\n\nWhen you click the button a GET request is sent to the backend where Django will return an HTML response of an empty . The HTML response is then added to the div.\n\nClick the Add form button and you should see the following:\n\nTo get the form submissions to work we have to change the view. It no longer works with so it now looks like this:\n\nNotice the statement returns a render of the form with the template so that the form errors can be displayed.\n\nWe also have to add some functionality to\n\nWe have wrapped the form inside a div with two Htmx properties. The specifies as the target which means it is pointing to itself. The property has been set to . Combining these two properties basically means that when the form is submitted, the entire form will be replaced by the response. The property on the button element ensures we send an Htmx request and not a normal request. The value means the request will be sent to the current URL.\n\nTest the form submission. You should see the form is replaced with . That is because the is returning . We can get more creative with this response by adding a detail view and returning the detail view response instead.\n\nAdd the view to the urls:\n\nChange the response in the view from:\n\nThis will return the detail view of the book as the response for when the form is submitted.\n\nTest the form submission and you should see the book title and number of pages being displayed, while the form disappears.\n\nNow we have the create view and detail view working. We'll add the update view so that when the book is created we can click a button to edit that book.\n\nThis works similarly to the create view. The main difference is that we're passing in to the form to update the book. We're also returning which renders the same form as in the create_view. But be careful though. In the template there's no way to distinguish between updating books and creating new books.\n\nUpdate so that the button is different depending on if we're updating an existing book:\n\nAdd the view to the urls:\n\nReplace the contents of with the following:\n\nSimilar to , in this template we've added the attributes and so that when the request is made it swaps the entire detail snippet for the response - which in this case is the populated form from the update view.\n\nTest it out and check that the books are being updated after you save.\n\nAdd it to the urls:\n\nTo make testing easier, loop through the books in the . Add the following inside the content block:\n\nTest the delete button. You should see the book removed from the page. Check the Django admin as well to confirm that the book is deleted.\n\nWhen clicking to update a book there is no way to cancel and go back to the detail view.\n\nUpdate to look like this:\n\nWe've added a button that requests the detail view. It will also replace the outer HTML with the response from the request. In this way it acts like a cancel button.\n\nNow test to update a form and then click the cancel button. It should replace the form with the detail view of the book.\n\nDjango's Formsets are very useful. But if you want to make the formsets look and feel good, particularly when using inline formsets, then you'll need to add JavaScript. This can land up being very complex and time consuming to get right.\n\nI spent a lot of time trying to get formsets to play nice with Htmx. But ultimately decided that these two just don't work well together. Here's why:\n\nBrennan Tymrak's article on dynamic formsets outlines a way to dynamically render formsets using JavaScript. When it comes to making formsets dynamic:\n• Get an existing form from the page\n• Increment the number of the form\n• Insert the new form on the page\n• Update the number of total forms in the management form\n\nTo try replicate this functionality in Htmx defeats the point of using Htmx. It requires some complicated logic that might as well be done using JavaScript.\n\nUltimately, the solution to achieving dynamic form logic with Htmx is to not use formsets. As you've seen in this tutorial so far we haven't used formsets at all when dealing with Htmx.\n\nWhile this solution might not end up with exactly the result you were looking for, in my experience the things that matter are:\n• How understandable and maintainable is the code?\n• Does the desired outcome solve the problem?\n\nWith what we've shown so far I believe both these boxes can be ticked.\n\nOne of the issues with formsets is that while they function well, they normally don't look great.\n\nWe're going to add TailwindCSS to the project to style the forms. We'll use the CDN because it is easier to test with. In production you would want to minimise the size of the CSS bundle. A project like django-tailwind can help achieve this.\n\nTo add the CDN in the head tag:\n\nIn wrap the content block like this:\n\nThe go-to package for better forms is django-crispy-forms. We're going to use the TailwindCSS template pack for styling.\n\nNow in load the tailwind filters at the top:\n\nNow we have much better looking forms. Play around with the project. Maybe there are some areas you want to improve on.\n\nSo far Htmx has been very useful. Using it you can write simple code that significantly improves the UI experience. Dynamic forms feel like a breeze and we don't even have to work with formsets or JavaScript.\n\nIf you want to become a professional Django developer consider JustDjango Pro."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/forms",
        "document": "Unless you’re planning to build websites and applications that do nothing but publish content, and don’t accept input from your visitors, you’re going to need to understand and use forms.\n\nDjango provides a range of tools and libraries to help you build forms to accept input from site visitors, and then process and respond to the input.\n\nIn HTML, a form is a collection of elements inside that allow a visitor to do things like enter text, select options, manipulate objects or controls, and so on, and then send that information back to the server. Some of these form interface elements - text input or checkboxes - are built into HTML itself. Others are much more complex; an interface that pops up a date picker or allows you to move a slider or manipulate controls will typically use JavaScript and CSS as well as HTML form elements to achieve these effects. As well as its elements, a form must specify two things:\n• None where: the URL to which the data corresponding to the user’s input should be returned\n• None how: the HTTP method the data should be returned by As an example, the login form for the Django admin contains several elements: one of for the username, one of for the password, and one of for the “Log in” button. It also contains some hidden text fields that the user doesn’t see, which Django uses to determine what to do next. It also tells the browser that the form data should be sent to the URL specified in the ’s attribute - - and that it should be sent using the HTTP mechanism specified by the attribute - . When the element is triggered, the data is returned to . and are the only HTTP methods to use when dealing with forms. Django’s login form is returned using the method, in which the browser bundles up the form data, encodes it for transmission, sends it to the server, and then receives back its response. , by contrast, bundles the submitted data into a string, and uses this to compose a URL. The URL contains the address where the data must be sent, as well as the data keys and values. You can see this in action if you do a search in the Django documentation, which will produce a URL of the form . and are typically used for different purposes. Any request that could be used to change the state of the system - for example, a request that makes changes in the database - should use . should be used only for requests that do not affect the state of the system. would also be unsuitable for a password form, because the password would appear in the URL, and thus, also in browser history and server logs, all in plain text. Neither would it be suitable for large quantities of data, or for binary data, such as an image. A web application that uses requests for admin forms is a security risk: it can be easy for an attacker to mimic a form’s request to gain access to sensitive parts of the system. , coupled with other protections like Django’s CSRF protection offers more control over access. On the other hand, is suitable for things like a web search form, because the URLs that represent a request can easily be bookmarked, shared, or resubmitted.\n\nHandling forms is a complex business. Consider Django’s admin, where numerous items of data of several different types may need to be prepared for display in a form, rendered as HTML, edited using a convenient interface, returned to the server, validated and cleaned up, and then saved or passed on for further processing. Django’s form functionality can simplify and automate vast portions of this work, and can also do it more securely than most programmers would be able to do in code they wrote themselves. Django handles three distinct parts of the work involved in forms:\n• None preparing and restructuring data to make it ready for rendering\n• None receiving and processing submitted forms and data from the client It is possible to write code that does all of this manually, but Django can take care of it all for you.\n\nWe’ve described HTML forms briefly, but an HTML is just one part of the machinery required. In the context of a web application, ‘form’ might refer to that HTML , or to the Django that produces it, or to the structured data returned when it is submitted, or to the end-to-end working collection of these parts. At the heart of this system of components is Django’s class. In much the same way that a Django model describes the logical structure of an object, its behavior, and the way its parts are represented to us, a class describes a form and determines how it works and appears. In a similar way that a model class’s fields map to database fields, a form class’s fields map to HTML form elements. (A maps a model class’s fields to HTML form elements via a ; this is what the Django admin is based upon.) A form’s fields are themselves classes; they manage form data and perform validation when a form is submitted. A and a handle very different kinds of data and have to do different things with it. A form field is represented to a user in the browser as an HTML “widget” - a piece of user interface machinery. Each field type has an appropriate default Widget class, but these can be overridden as required. When rendering an object in Django, we generally:\n• None get hold of it in the view (fetch it from the database, for example)\n• None pass it to the template context\n• None expand it to HTML markup using template variables Rendering a form in a template involves nearly the same work as rendering any other kind of object, but there are some key differences. In the case of a model instance that contained no data, it would rarely if ever be useful to do anything with it in a template. On the other hand, it makes perfect sense to render an unpopulated form - that’s what we do when we want the user to populate it. So when we handle a model instance in a view, we typically retrieve it from the database. When we’re dealing with a form we typically instantiate it in the view. When we instantiate a form, we can opt to leave it empty or prepopulate it, for example with:\n• None data from a saved model instance (as in the case of admin forms for editing)\n• None data that we have collated from other sources The last of these cases is the most interesting, because it’s what makes it possible for users not just to read a website, but to send information back to it too.\n\nThe work that needs to be done¶ Suppose you want to create a simple form on your website, in order to obtain the user’s name. You’d need something like this in your template: This tells the browser to return the form data to the URL , using the method. It will display a text field, labeled “Your name:”, and a button marked “OK”. If the template context contains a variable, that will be used to pre-fill the field. You’ll need a view that renders the template containing the HTML form, and that can supply the field as appropriate. When the form is submitted, the request which is sent to the server will contain the form data. Now you’ll also need a view corresponding to that URL which will find the appropriate key/value pairs in the request, and then process them. This is a very simple form. In practice, a form might contain dozens or hundreds of fields, many of which might need to be prepopulated, and we might expect the user to work through the edit-submit cycle several times before concluding the operation. We might require some validation to occur in the browser, even before the form is submitted; we might want to use much more complex fields, that allow the user to do things like pick dates from a calendar and so on. At this point it’s much easier to get Django to do most of this work for us. We already know what we want our HTML form to look like. Our starting point for it in Django is this: This defines a class with a single field ( ). We’ve applied a human-friendly label to the field, which will appear in the when it’s rendered (although in this case, the we specified is actually the same one that would be generated automatically if we had omitted it). The field’s maximum allowable length is defined by . This does two things. It puts a on the HTML (so the browser should prevent the user from entering more than that number of characters in the first place). It also means that when Django receives the form back from the browser, it will validate the length of the data. A instance has an method, which runs validation routines for all its fields. When this method is called, if all fields contain valid data, it will:\n• None place the form’s data in its attribute. The whole form, when rendered for the first time, will look like: Note that it does not include the tags, or a submit button. We’ll have to provide those ourselves in the template. Form data sent back to a Django website is processed by a view, generally the same view which published the form. This allows us to reuse some of the same logic. To handle the form we need to instantiate it in the view for the URL where we want it to be published: # if this is a POST request we need to process the form data # create a form instance and populate it with data from the request: # process the data in form.cleaned_data as required # if a GET (or any other method) we'll create a blank form If we arrive at this view with a request, it will create an empty form instance and place it in the template context to be rendered. This is what we can expect to happen the first time we visit the URL. If the form is submitted using a request, the view will once again create a form instance and populate it with data from the request: This is called “binding data to the form” (it is now a bound form). We call the form’s method; if it’s not , we go back to the template with the form. This time the form is no longer empty (unbound) so the HTML form will be populated with the data previously submitted, where it can be edited and corrected as required. If is , we’ll now be able to find all the validated form data in its attribute. We can use this data to update the database or do other processing before sending an HTTP redirect to the browser telling it where to go next. We don’t need to do much in our template: All the form’s fields and their attributes will be unpacked into HTML markup from that by Django’s template language. Django ships with an easy-to-use protection against Cross Site Request Forgeries. When submitting a form via with CSRF protection enabled you must use the template tag as in the preceding example. However, since CSRF protection is not directly tied to forms in templates, this tag is omitted from the following examples in this document. If your form includes a , an or any integer field type, Django will use the , and HTML5 input types. By default, browsers may apply their own validation on these fields, which may be stricter than Django’s validation. If you would like to disable this behavior, set the attribute on the tag, or specify a different widget on the field, like . We now have a working web form, described by a Django , processed by a view, and rendered as an HTML . That’s all you need to get started, but the forms framework puts a lot more at your fingertips. Once you understand the basics of the process described above, you should be prepared to understand other features of the forms system and ready to learn a bit more about the underlying machinery.\n\nAll form classes are created as subclasses of either or . You can think of as a subclass of . and actually inherit common functionality from a (private) class, but this implementation detail is rarely important. In fact if your form is going to be used to directly add or edit a Django model, a ModelForm can save you a great deal of time, effort, and code, because it will build a form, along with the appropriate fields and their attributes, from a class. The distinction between Bound and unbound forms is important:\n• None An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.\n• None A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct. The form’s attribute will tell you whether a form has data bound to it or not. Consider a more useful form than our minimal example above, which we could use to implement “contact me” functionality on a personal website: Our earlier form used a single field, , a . In this case, our form has four fields: , , and . , and are just three of the available field types; a full list can be found in Form fields. Each form field has a corresponding Widget class, which in turn corresponds to an HTML form widget such as . In most cases, the field will have a sensible default widget. For example, by default, a will have a widget, that produces an in the HTML. If you needed instead, you’d specify the appropriate widget when defining your form field, as we have done for the field. Whatever the data submitted with a form, once it has been successfully validated by calling (and has returned ), the validated form data will be in the dictionary. This data will have been nicely converted into Python types for you. You can still access the unvalidated data directly from at this point, but the validated data is better. In the contact form example above, will be a boolean value. Likewise, fields such as and convert values to a Python and respectively. Here’s how the form data could be processed in the view that handles this form: For more on sending email from Django, see Sending email. Some field types need some extra handling. For example, files that are uploaded using a form need to be handled differently (they can be retrieved from , rather than ). For details of how to handle file uploads with your form, see Binding uploaded files to a form.\n\nAll you need to do to get your form into a template is to place the form instance into the template context. So if your form is called in the context, will render its and elements appropriately. Don’t forget that a form’s output does not include the surrounding tags, or the form’s control. You will have to provide these yourself. The HTML output when rendering a form is itself generated via a template. You can control this by creating an appropriate template file and setting a custom to use that site-wide. You can also customize per-form by overriding the form’s attribute to render the form using the custom template, or by passing the template name directly to . The example below will result in being rendered as the output of the template. # In your template: # In form_snippet.html: Then you can configure the setting: … or for a single render of a form instance, passing in the template name to the . Here’s an example of this being used in a view: See Outputting forms as HTML for more details. Each field is available as an attribute of the form, using in a template. A field has a method which renders the related elements of the field as a group, its label, widget, errors, and help text. This allows generic templates to be written that arrange fields elements in the required layout. For example: By default Django uses the template which is designed for use with the default form style. The default template can be customized by setting in your project-level : … or on a per-request basis by calling and supplying a template name: More fine grained control over field rendering is also possible. Likely this will be in a custom field template, to allow the template to be written once and reused for each field. However, it can also be directly accessed from the field attribute on the form. For example: Email subject: Your message: Your email address: CC yourself? Complete elements can also be generated using the . For example: The price of this flexibility is a bit more work. Until now we haven’t had to worry about how to display form errors, because that’s taken care of for us. In this example we have had to make sure we take care of any errors for each field and any errors for the form as a whole. Note at the top of the form and the template lookup for errors on each field. Using displays a list of form errors, rendered as an unordered list. This might look like: The list has a CSS class of to allow you to style its appearance. If you wish to further customize the display of errors you can do so by looping over them: Non-field errors (and/or hidden field errors that are rendered at the top of the form when using helpers like ) will be rendered with an additional class of to help distinguish them from field-specific errors. For example, would look like: See The Forms API for more on errors, styling, and working with form attributes in templates. If you’re using the same HTML for each of your form fields, you can reduce duplicate code by looping through each field in turn using a loop: Outputs a containing any validation errors corresponding to this field. You can customize the presentation of the errors with a loop. In this case, each object in the loop is a string containing the error message. The instance from the form class that this wraps. You can use it to access attributes, e.g. . Any help text that has been associated with the field. The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set. The ID that will be used for this field ( in the example above). If you are constructing the label manually, you may want to use this in lieu of . It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID. This attribute is if the form field is a hidden field and otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as: The label of the field, e.g. . The field’s label wrapped in the appropriate HTML tag. This includes the form’s . For example, the default is a colon: Similar to but uses a tag in place of , for widgets with multiple inputs wrapped in a . This attribute is if the form field’s widget contains multiple inputs that should be semantically grouped in a with a to improve accessibility. An example use in a template: The value of the field. e.g . For a complete list of attributes and methods, see . If you’re manually laying out a form in a template, as opposed to relying on Django’s default form layout, you might want to treat fields differently from non-hidden fields. For example, because hidden fields don’t display anything, putting error messages “next to” the field could cause confusion for your users – so errors for those fields should be handled differently. Django provides two methods on a form that allow you to loop over the hidden and visible fields independently: and . Here’s a modification of an earlier example that uses these two methods: This example does not handle any errors in the hidden fields. Usually, an error in a hidden field is a sign of form tampering, since normal form interaction won’t alter them. However, you could easily insert some error displays for those form errors, as well."
    },
    {
        "link": "https://stackoverflow.com/questions/74757197/the-right-way-to-dynamically-add-django-formset-instances-and-post-usign-htmx",
        "document": "My approach to working with dynamic formsets using the mighty :\n\nHave a view that renders an of a formset instance (i.e, ). This will return a form with in the part that normally will contain the form number (i.e, instead of , it will be ). The trick here is to simply replace the with the appropriate form number.\n\n@Matt's answer achieves this by iterating over the form and doing the relevant replacement. While this works okay, I think an even easier way is simply to change the formset's prefix after instantiating it. That way, you don't need the helper function.\n\nRender the in the . And include the value of the formset's [hidden input field] in HTMX's GET request using attribute (please note I am using a jquery selector, that's just for convenience. Vanilla JS should work too).\n\nAfter the htmx's request, the total forms in formset needs to be updated (incremented at each formset addition). If you want to strictly use HTMX, you can use the attribute which allows you to listen to events and run inline JS. However, I find quite easier for this because of is command.\n\nThen you can handle the request in your view: views.py\n\nI think that's pretty much it.\n\nNotes Instead of you can use\n\nAnd in view you will have to get the value by"
    },
    {
        "link": "https://stackoverflow.com/questions/53410815/django-inline-formset-multiple-models",
        "document": "TL;DR: I need a some kind of formset for formsets.\n\nI have two different models related to one buisness-entity, and I need to make a form to edit both models like a one form. And I need to create a lot of such forms on the one page like Django inline formset does.\n\nNow I have the following thing:\n\nAnd I render a lot of them using inline formsets:\n\nBut now I have to add second child model and a form for it, and still render it like an one inline form, but make it form actually edit two models. Like this:\n\nAs far as I understand, Django formsets cannot work with multiple models right now.\n\nSo which way should I choose to implement this behaviour and do not broke all django conceptions?, I cannot use some extra libraries so I have to implement everything by myself and I use django 1.6 if it is important."
    },
    {
        "link": "https://forum.djangoproject.com/t/how-to-handle-multiple-different-models-with-formsets/5915",
        "document": "I am tasked to create a template that conditionally needs to duplicate a form made of User table, Profile table, and Location table data. I a formset could be ideal - but I have seen/read nothing on how to do a formset with aggregated forms using different models. One form would be for a Parent’s data and the other for the Reporter (an unrelated Reporter can call in a rescue - or the parent can. Both need the users name and contact info and address, if available). I know I can do one model form with formsets but can you do this with an aggregated ‘form’ made of several model forms? Should I instead create a DATABASE view of these separate models first and do a formset off the database view? If I did that would I create headaches if this eventually becomes a progressive web app with SQLite (local) and PostgresSQL (primary db on server)? Any examples/tutorials you know of? Other, better, options? The specifics are: I have a Django view that allows volunteers to enter a Parent or a Reporter to describe a need to rescue a child. The only diff between a parent and a reporter is Reporter gets a boolean reporter flag set (initially schema was designed with one to many Parent to possibly many Children - but have considered a many to many so children can be associated with a parent and a Reporter). Names are in User, telephone and email are in Profile and physical address/latlong are in Location tables. The template has a set of the same fields for both Parent and Reporter but you check a ‘reporter’ checkbox if the info is from a Reporter. Only the Parent fields and an ‘Add Reporter’ button are visible initially. I have never actually implemented a formset yet… Thanks in advance. Any insight appreciated.\n\nI’m not sure I’m following you here - it almost looks to me like you’re asking a couple different questions. Trying to approach this from a slightly different angle: A formset is an abstraction layer to handle multiple instances of the same form. If you can create a form for , you can create a formset to manage multiple instances of that form on a single page. Forms can be created outside the context of a model. (In fact, a Model Form is just a special case of a form.) So I’m getting the impression from what I’m able to understand here is that you might be looking to create a formset supporting a generic form that is suitable for either a Parent or Reporter. Then, when you’re processing that formset, you create & store the appropriate data type from each instance of the form. Am I on the right track here, or am I missing something?\n\nLet me try again with an image: I have a web page that copies a paper form used in real life. There are two sections of page with form parts with essentially identical fields; one for Reporter and the other for Parent. But they are composites made from fields from different model forms. Sometimes there is no known parent, only a reporter. Sometimes the parent is the reporter (so no Reporter section needs to be filled in). The yellow fields are from the User table/model (and UserForm), the blue from the Profile table/model (ProfileForm) and the pink from the Location table/model (LocationForm). So, the question is: can I do a formset to replicate these two sections and send the appropriate keys for the potentially 2 people associated with the children (Child table/model and ChildForm)? Or is there a better way? I have read, and you state, formsets are for replicating the SAME model form…if formsets simply cannot do this then would a model form based on a view be a good solution? Would a many to many relationship and a corresponding Django view do this best? \n\n Apologies to those with difficulty resolving colors…\n\nThe picture helps a little, but I’m still confused by what you’re saying. It looks to me now that you shouldn’t be working with Model forms at all. Since you’re pulling (feeding?) data from (to) different Models, you may just want to use a form and do the association between the forms and their related models in your view. Make sure you’re clear in your mind the difference between your models and your forms. Models are the representation of your data in your database. Forms are the representation of your data on a web page. When your web page closely aligns to your database, then ModelForms are appropriate. Otherwise, you want to manage those relationships yourself. So I when you are making references to ModelForms, you’re actually just talking about your models, correct? formsets are for replicating the SAME model form Is wrong. Formsets are for replicating the same form, not necessarily the same form.\n\nThanks for the clarification, I believe I know the distinction between models and forms and have been using modelforms to represent forms that interact with models and the database - which are all my forms currently. I imagine I could use ‘regular’ form.Forms and then use Modelname.objects.create() to manually assign form field values to the appropriate model and then save into the Db. Do people do that as standard practice? I was under the impression that for any form that does CRUD you really want to use modelforms. It seems unduly complex for this situation (not hard but sort of Rube Goldbergesque). I think you are saying that\n\n 1: I cannot use formsets with form templates made of mutiple different modelforms - you can ONLY use them to duplicate a single form - whether it is a form.Form or modelform.\n\n 2: I CAN (and should likely here) create a form.Form type form similar to one of the multi-colored sections in the image, with ANY fields, as they have no connection to a model until I manually assign them to the model via the view.\n\n 3: Then I could replicate it as with a formset.\n\n 4: You are not suggesting better options yet, you have not weighed in on creating models or modelforms from database views or if this scenario is best handled in some other way/has some sort of Django design pattern. Thanks for the input, I will consider using a ‘regular’ form with a formset.\n\nI imagine I could use ‘regular’ form.Forms and then use Modelname.objects.create() to manually assign form field values to the appropriate model and then save into the Db. Do people do that as standard practice? Generally, yes - when the form doesn’t correlate closely to a model. I’ve got a couple of applications where there are few, if any, model forms at all. I was under the impression that for any form that does CRUD you really want to use modelforms. When your form has a strict correlation to your model, it makes it easier to use a model form. But the “further away” your form is from your model, the more you’re going to find it easier to not try and wedge your process into a model form. A model form is an abstraction layer over a standard form that does some work for you. Whether you do the work or Django does the work doesn’t matter a whole lot. I cannot use formsets with form templates made of mutiple different modelforms - you can ONLY use them to duplicate a single form - whether it is a form.Form or modelform You don’t create formsets from form templates. You create formsets from a form. (Not just model form.) The formset is created any rendering is done with the template. I CAN (and should likely here) create a form.Form type form similar to one of the multi-colored sections in the image, with ANY fields, as they have no connection to a model until I manually assign them to the model via the view. Correct. That’s what I was heading toward in the next-to-last paragraph of my earlier reply and the second paragraph of a subsequent reply. Then I could replicate it as with a formset. You are not suggesting better options yet, you have not weighed in on creating models or modelforms from database views or if this scenario is best handled in some other way/has some sort of Django design pattern. Correct, I was trying to make sure we’re clear on terminology and function. Creating models mapping to database views works great - I’ve done a lot of that. (In my case, it’s always been for read-only, not read-write - but assuming your database engine allows for writable views it shouldn’t be a problem.) But you don’t create model forms from a database view - you create a model form from a model. I’m not aware of alternative design patterns for addressing something like this.\n\n My personal experience has been that Django is designed around the architecture that the database is built Django and that you’re not trying to layer Django on top of a pre-existing database used for other applications. There are a couple of areas that create “friction” when trying to build a Django app on top of a database that was built outside of it.\n\nAs always: Thanks Ken. That was above and beyond in terms of patience. Over and over I see people referring to the ‘excellent’ documentation (I suspect for % coverage vs clear explanations) for Django, but I have found, for a beginner, they are less than that. Statements like: ‘When your form has a strict correlation to your model, it makes it easier to use a model form. But the “further away” your form is from your model, the more you’re going to find it easier to not try and wedge your process into a model form.’ are invaluable to a beginner because most tutorials are echoes of each other doing only the basics, and beginners do not know what is just an ugly hack vs a standard practice. Now you have blessed the pursuit of what I would have thought would be (and likely will be in MY hands…) an ugly hack."
    },
    {
        "link": "https://stackoverflow.com/questions/31037147/django-form-with-multiple-models-and-dynamic-quantity-of-models",
        "document": "I am creating a form that creates a dynamic number of models. seem like the tool for the job, but I can't find examples that use multiple models.\n\nUsing the models in this example ( and ), My formset needs exactly one form, and at least one form. The user can add as many books as they would like to the author, all within the same form(set).\n\nWhat is the best way to accomplish this in the Django backend?\n\nWould I be better off posting JSON to a REST api to create these models?"
    },
    {
        "link": "https://medium.com/@adandan01/django-inline-formsets-example-mybook-420cc4b6225d",
        "document": "Recently I needed to use django formset for a work project. Django formset allows you to edit a collection of the same forms on the same page. It basically allows you to bulk edit a collection of objects at the same time. Imagine you need to update an address book, you can either add each entry on an address form page individually or you can probably do it faster by having a page that allows you to enter as many new entries as you want. I haven’t used this django feature before so I started by spending some time reading about this feature on the internet. To my surprise, I couldn’t find a good working example that closely matches my requirements. The official django documentation is quite barebone. It didn’t give me a good picture on how to put everything together. After a lot of trial and errors and googling, I was able to put together a solution that I was happy with. This post is my attempt to recreate what I implemented with a much simpler scenario. Hopefully, it will be a better learning experience for the next person that might be looking for a good example. I am sure I need to come back to it at some point myself.\n\nWe are working on a social networking site called mybook. Like many social networking sites, this app allows you to create user profiles. On the edit profile page, you can also add and remove family members to that profile. Sounds simple enough?\n\nWhat I would like to achieve at the end:\n• Conceptually I have two basic django models. (Profile and FamilyMember) The child model (FamilyMember)has a foreign key relationship to the parent model(Profile). I’t is a classic one to many relationship. I would like to have a form that allows me to update this relationship easily.\n• Layout: Formset is essentially a collection of the same form. You can render the formset easily like {{ form.as_p }} in django template, but the default layout is really not ideal since the labels of the fields are just repeated over and over again. Instead of rendering each form as tables or lists, I would like to render the field labels once and each form in a table row.\n• I would like to be able add new member/delete member on the page dynamically. Default django templates don’t allow this kind of behavior. We will need some javascript help.\n• Achieve all the above with as little code as possible. None of this seems complicated. The solution should look very generic. Following Django’s DRY principle, we should strive to reduce the amount of boilerplate code.\n\nHere is what the end result looks like:\n\nLet’s look at different parts of the solution. I will try to point out the important bits.\n\nNotes: It is pretty straightforward here. Just two simple Django models that have a 1:m relationship.\n\nNotes: With modelForm and inlineformset, we can create all the necessary formset with minimal code. Django scores high points here. If you would like to have custom validation logic on the formset, then you should create a baseformset class that extends the BaseInlineFormSet and override the clean method. The extra param controls the number empty form that will be displayed by default.\n\nNotes: This part is where Django is falling short a little bit. It’s very easy to have a ProfileCreateView without overriding any methods. Like this:\n\nBut what if you also want to edit the foreign key relationship with this form. Things becomes muddy very quickly. The approach I have taken at thend basically treat the inlineformset as an additional form that the generic createview needs to process. We need to initialize the formset with get() and inject it into context. With post(), we need to call the save() method. Finding the right places to do all these is a bit tricky. You can get a better understanding on how to do this from this django doc.\n• The template has the meat of this custom solution. I have bolded the section that worth paying attention to. In order to layout the form in the desired fashion, I have to render the labels and each form manually. It’s very important to include the “management_form” and the hidden fields in the template. It is worth taking a closer at what management_form is. You will need to understand what it does in order to write proper unit tests.\n• For dynamically adding and removing the form, I use this jquery plugin that works very nicely with django formset. It is important to add a special class (formset_row) to the tr row so the plugin can decorate it appropriately. Another thing worth noting is the prefix. This prefix should be the “related_name” of the foreign key relationship in the django world. Django uses the related name as prefix in the rendered form. In this example, the related_name is defaulted to familymember_set. You can override the related_name in models.py. If you do that, you need to make sure the prefix is also updated here. Otherwise, the form processing will be quite buggy.\n\nThat’s it for now. Hope you find it useful. The source code can be found here."
    },
    {
        "link": "https://forum.djangoproject.com/t/multiple-models-to-one-form/18498",
        "document": "Hi , I´ve been looking around the net for hours and I just can´t find a solution. There seems to be a lot of confusion about how to create a single form which sends the data to all models at the same time. I wanted to create an app where the user can write a post and upload multiple pictures and also add multiple tags from either a selection of existing ones or create one himself by just clicking a create new button. I thought this was easy but it´s getting more and more complicated the deeper I read into it. For a better understanding see the picture. I would have just created a single model but the problem is that you can´t store more than one value in a table cell. So when the user wants to add 10 tags to his post it wont work. The other problem is the relationship. If I save multiple model data at once in one form will the relationship between the Post and the other models also be saved at the same time? And the biggest question is: HOW DO I DO THIS?\n\nYes thanks for the answer. I´ve tried all this but it´s still not working. from django.db import models from django.urls import reverse from datetime import datetime class Category(models.Model): name = models.CharField(max_length=250, help_text='Kategorie', blank=True) class Meta: verbose_name_plural = \"Categories\" def __str__(self): return self.name class Link(models.Model): alias = models.CharField(max_length=250, help_text='Linkalias', blank=True) link = models.URLField((\"Links zum Thema\"), max_length=128, db_index=True, unique=True, blank=True) def __str__(self): return self.alias class File(models.Model): name = models.CharField(max_length=250, help_text='Dateiname', blank=True) upload = models.FileField(upload_to ='uploads/', null=True, blank=False) def __str__(self): return self.name class Tag(models.Model): name = models.CharField(max_length=250, help_text='tagname', blank=True) def __str__(self): return self.name class Thema(models.Model): publication_date = models.DateField(verbose_name=\"Date the Post was published.\", default=datetime.now) title = models.CharField(max_length=70, help_text=\"The title of the Post\") text = models.TextField(max_length=5000,default='text 1') text2 = models.TextField(max_length=5000,default='text 2') text3 = models.TextField(max_length=5000,default='text 3') # Relation Fields category = models.ForeignKey(Category, on_delete=models.CASCADE) links = models.ManyToManyField(Link) files = models.ManyToManyField(File) tags = models.ManyToManyField(Tag) def get_absolute_url(self): return reverse('thema-detail', kwargs={'pk' : self.pk}) def __str__(self): return self.title class Bilder(models.Model): name = models.CharField(max_length=250, help_text='Bildname', blank=True) beschreibung = models.CharField(max_length=400, help_text='Kurzbschreibung', blank=True) thema = models.ForeignKey(Thema, on_delete=models.CASCADE, related_name='bilder', null=True) image = models.ImageField(null=True, blank=True, upload_to='images/') class Meta: verbose_name_plural = \"Bilder\" def __str__(self): return self.name from .models import Thema from django.views.generic import ListView, DetailView from .forms import ThemaForm, BilderForm, LinkForm, CategoryForm, TagForm, FileForm from django.shortcuts import redirect, render from django.shortcuts import render class HomePageView(ListView): model = Thema context_object_name = 'themas' template_name = \"home/home.html\" class ThemaView(DetailView): model = Thema context_object_name = 'thema' template_name = \"home/thema.html\" def get_name(request): if request.method == 'POST': bilder = BilderForm(request.POST, prefix='bilder') thema = ThemaForm(request.POST, prefix='thema') link = LinkForm(request.POST, prefix='link') tag = TagForm(request.POST, prefix='tag') category = CategoryForm(request.POST, prefix='category') file = FileForm(request.POST, prefix='file') if bilder.is_valid() and thema.is_valid() and link.is_valid() and tag.is_valid() and category.is_valid() and file.is_valid(): return redirect('home') else: bilder = BilderForm(prefix='name') thema = ThemaForm(prefix='person') file = FileForm(prefix='person') link = LinkForm(prefix='person') tag = TagForm(prefix='person') category = CategoryForm(prefix='person') return render(request, 'home/create.html', {'bilder': bilder, 'thema': thema, 'link': link, 'tag': tag, 'category': category, 'file': file}) from django import forms from .models import Bilder, Thema, Category, Link, Tag, File class BilderForm(forms.ModelForm): class Meta: model = Bilder fields = ('name', 'beschreibung', 'image') class ThemaForm(forms.ModelForm): class Meta: model = Thema fields = ('title', 'text') class CategoryForm(forms.ModelForm): class Meta: model = Category fields = ('name',) class LinkForm(forms.ModelForm): class Meta: model = Link fields = ('alias', 'link') class FileForm(forms.ModelForm): class Meta: model = File fields = ('name', 'upload') class TagForm(forms.ModelForm): class Meta: model = Tag fields = ('name',) I think I also need FormSets. The problem is if I create for example a TAG this way. The tag is saved but at the same time the thema model needs to store the relation to this tag in his own model which it probably can´t because I can´t set it in the form because it isn´t in the database by that time…\n\nOkay thanks a lot. I will read more about it. Right now the form fields are all showing up but the somehow I can´t submit them. After I hit the submit button I always get the message that the field is required but all fields are filled. Maybe I need to change the request.POST to request.FILES also in the image and file forms. How can I use the formSets? Because as far as I have understood they are for making multiple form instances of the same form like more fields to upload files, which is also what I need but I will do this later. First I want to make it work somehow.\n\nOk, I missed the file upload parts of this. For those, you do need to read File Uploads | Django documentation | Django. They do require some changes both in your form handling and a change in your template. (See the note on .) Yes, model formsets are what you use to create multiple instances of the same model. They generally require some JavaScript to be written to make them most useful, but it’s not strictly-speaking required.\n\nIt would be helpful if you provided the complete set of errors being generated by the submission. I do notice that your prefixes don’t match for your forms between your GET and POST handling. Also, you might find it easier to diagnose if you reduced this to one form, and added one form at a time until the errors started to appear. It may make it easier to identify where the problems are occurring.\n\nThanks for the answers. I´ve set the enctype in the html template. The problem is So what I think is that there is a two step process:\n• Create the entry in the thema table the problem is that I can´t assign it a category which doesn´t exist by that time. It has to be created the same time as the thema entry. So I want to store both with the relationship at the same time in different tables. I don´t know if this is possible. Mybe I need to change the order of the save() method."
    }
]