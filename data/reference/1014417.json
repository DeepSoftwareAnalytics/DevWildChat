[
    {
        "link": "https://w3schools.com/java/java_user_input.asp",
        "document": "The class is used to get user input, and it is found in the package.\n\nTo use the class, create an object of the class and use any of the available methods found in the class documentation. In our example, we will use the method, which is used to read Strings:\n\nIn the example above, we used the method, which is used to read Strings. To read other types, look at the table below:\n\nIn the example below, we use different methods to read data of various types:\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\"). You can read more about exceptions and how to handle errors in the Exceptions chapter."
    },
    {
        "link": "https://medium.com/@AlexanderObregon/a-beginners-guide-to-handling-user-input-in-java-with-scanner-85be33c8702d",
        "document": "Navigating through Java for the first time can feel like unraveling a complex web of code, especially when it comes to understanding how to handle user input. The goal of this guide is help you understand the process, focusing on one of Java’s most accessible tools for beginners: the class. By the end of this guide, you'll be well-equipped to write Java programs that interact with users in a meaningful way.\n\nWhat is User Input In the Context of Java?\n\nJava, an object-oriented programming language, is a important part of modern software development. It’s renowned for its portability, which means that Java programs can run on any device that has the Java Virtual Machine (JVM) installed. This universality has made Java a preferred choice for everything from web applications to Android apps. A vital aspect of engaging with Java, especially for beginners, is understanding how to handle user input. This process is what allows Java applications to interact with users, making programs dynamic and responsive.\n\nAt its core, user input is what makes software interactive. Without it, programs are static, limited to performing the tasks they were explicitly programmed to do without any room for variability or user preference. By incorporating user input, programs can execute different branches of logic, gather information directly from the user, and provide a tailored experience. For instance, a simple Java application could change its behavior based on user preferences, such as altering its interface from light mode to dark mode. More complex applications, like data analysis tools, can ask users to input datasets for processing, making the software infinitely more flexible.\n\nIn the early days of computing, user interaction was primarily through command-line interfaces (CLI), where users would type commands and receive text output from the program. This mode of interaction is still widely used for many backend applications, server management, and by developers for tasks that require precision and control.\n\nAs graphical user interfaces (GUIs) became more common, the methods of user input expanded to include clicks, drags, and other gestures. However, for learning programming and understanding the fundamentals of user input, starting with CLI-based input is beneficial. It reduces the complexity of dealing with graphical elements and allows the programmer to focus on the core logic of processing user input.\n\nThe Role of the Scanner Class in Java\n\nThe class provides a convenient and efficient way for programs to read text input, including entire lines, words, or even specific types of data like integers and floating-point numbers. This functionality is crucial for beginners to learn as it lays the foundation for understanding how data can be dynamically received and processed within Java applications.\n\nThe class, part of the package, acts as a parser that can break down incoming data streams into tokens, which can then be interpreted according to the program’s needs. By default, uses whitespace as the delimiter to separate these tokens, making it intuitive to work with for new programmers. Understanding how to leverage the class effectively is the first step toward building interactive Java applications that respond to user inputs in real-time.\n\nGrasping the basics of handling user input in Java is a stepping stone to more complex programming skills. While the class is just one of many tools in Java's vast arsenal for dealing with input, it exemplifies Java's approach to versatility and programmer-friendliness. By learning how to use to gather input from users, beginners can start to build applications that are interactive, dynamic, and responsive to the needs and preferences of their users, laying the groundwork for more advanced programming concepts and techniques in Java.\n\nThe class is one of the most fundamental components of Java, allowing beginners and seasoned developers alike to interact with users through the console. Understanding and utilizing this class is crucial for creating interactive applications. This section dives deeper into what the class is, its importance, and how to effectively use it to read user input.\n\nWhat is the Scanner Class?\n\nThe class in Java is a part of the package, making it readily available without the need for any additional downloads or installations. It is designed to parse primitive types and strings using regular expressions. This means it can automatically interpret inputted text as integers, double values, strings, and more, based on the method you call.\n• Versatility: can read data from various sources, including files, strings, and most importantly, the standard input stream (typically the keyboard).\n• Ease of Use: With , reading different types of data is straightforward, thanks to its intuitive methods like , , , and more.\n• Customization: While uses whitespace as its default delimiter to separate tokens (pieces of input), this can be customized with regular expressions to accommodate more complex input patterns.\n\nSetting Up Scanner in Your Java Program\n\nTo begin using the class, you must first import it at the beginning of your Java code. This is done with the import statement:\n\nOnce imported, you can create an instance of the class. The most common use-case for beginners is to read input from the keyboard, which is done by passing (the standard input stream) to the constructor:\n\nThis line of code creates a new object named that is ready to read input from the console.\n\nThe class provides various methods to read different types of data. The method you choose depends on what type of input you expect from the user. Below are some of the most commonly used methods for reading user input:\n• : Reads input including spaces until the end of the line. It's the method you'll use when you want to capture an entire line of input as a single string.\n• : Reads the next token of input as an . It's suitable when you're expecting a numerical input that represents an integer value.\n\n: Similar to , but reads the next token as a . This method is used when expecting numbers that may have decimal points.\n\nIt is a good practice to close your object once it is no longer needed. Closing the helps free up resources that it might be using. However, when using with , be cautious as closing the will also close , affecting other parts of your program that might read from the console. Here is how you close a scanner:\n\nThe class is a powerful yet easy-to-use tool for reading user input in Java applications. By understanding how to set up and use , you can start building interactive applications that respond to user input. Remember, the key to mastering Java is practice, so consider incorporating user input in your next Java project to get hands-on experience with these concepts.\n\nAfter familiarizing ourselves with the basics of the class and how to set it up, it's time to dive into some practical examples. These examples will showcase how to use the to read different types of inputs from the console, emphasizing the flexibility and usefulness of this class in real-world applications.\n\nLet’s start with a simple program that asks for the user’s name and age, then responds with a personalized message. This example demonstrates how to read strings and integers from the console.\n\nThis example illustrates the basic use of for string inputs and for integer inputs. Notice the call to at the end, which is good practice to release resources.\n\nNext, let’s create a program that calculates the area of a circle based on a radius provided by the user. This example will show how to handle floating-point numbers with .\n\nThis program makes use of to read a decimal number from the console, which is then used to calculate the area of a circle.\n\nLet’s create a more complex example that reads multiple types of data from the user, illustrating how to combine different methods in a single program.\n\nThis program collects the user’s name, age, and favorite color. Note the call after reading the age. This is necessary to consume the newline character left by , ensuring the next call works as expected.\n\nIn this example, we’ll create a program that asks the user to enter a series of numbers. The program will sum these numbers and display the total. The user can stop entering numbers by typing any non-numeric value.\n\nThis example uses to check if the next input is a double value. This method is particularly useful for validating input without causing the program to crash due to input mismatches. It allows the program to gracefully handle unexpected input types and demonstrates a dynamic way to read multiple inputs until a condition is met.\n\nLet’s build a simple quiz program that asks the user a multiple-choice question. The user will input the letter corresponding to their answer choice, and the program will tell them whether they are correct or incorrect.\n\nThis program demonstrates how to handle string input, process it (by trimming whitespace and converting it to lower case), and compare strings to check for the correct answer. It’s a basic example of how can be used to create interactive quizzes or tests, showcasing the potential for educational applications or games.\n\nThrough these examples, we’ve seen in action, from reading simple strings and numbers to handling more complex scenarios. Here are some key takeaways to remember:\n• Use the correct method ( , , , etc.) based on the expected input type.\n• After reading numeric inputs ( , , etc.), remember to consume the trailing newline character with an additional if you plan to read more text input afterward.\n• Always close the with when it's no longer needed, but be mindful of closing indirectly through the .\n\nBy integrating these practices and examples into your Java projects, you’ll be well-equipped to create interactive and user-friendly console applications.\n\nIn this guide, we’ve explored the class in Java, a powerful tool for reading user input from the console. Starting with an introduction to Java and the importance of user input, we proceeded to discuss how to get started with the class, including its setup and various methods for reading different types of data. Through practical examples, we demonstrated the versatility and utility of the class in creating interactive Java applications.\n\nThe journey through understanding and applying the class highlights the importance of engaging users in a conversation, making Java programs more dynamic and responsive. By mastering the basics of the class, beginners can take their first steps towards building sophisticated Java applications that interact with users in meaningful ways. This foundation is crucial for any aspiring Java developer, opening doors to further exploration and mastery of the Java programming language."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html",
        "document": "A simple text scanner which can parse primitive types and strings using regular expressions.\n\nA breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various methods.\n\nFor example, this code allows a user to read a number from :\n\nAs another example, this code allows types to be assigned from entries in a file :\n\nThe scanner can also use delimiters other than whitespace. This example reads several items in from a string:\n\nThe same output can be generated with this code, which uses a regular expression to parse all four tokens at once:\n\nThe default whitespace delimiter used by a scanner is as recognized by . . The method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed.\n\nThe and methods and their primitive-type companion methods (such as and ) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both and methods may block waiting for further input. Whether a method blocks has no connection to whether or not its associated method will block.\n\nThe , , and methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input.\n\nWhen a scanner throws an , the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.\n\nDepending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern could return empty tokens since it only passes one space at a time.\n\nA scanner can read text from any object which implements the interface. If an invocation of the underlying readable's method throws an then the scanner assumes that the end of the input has been reached. The most recent thrown by the underlying readable can be retrieved via the method.\n\nWhen a is closed, it will close its input source if the source implements the interface.\n\nA is not safe for multithreaded use without external synchronization.\n\nUnless otherwise mentioned, passing a parameter into any method of a will cause a to be thrown.\n\nA scanner will default to interpreting numbers as decimal unless a different radix has been set by using the method. The method will reset the value of the scanner's radix to regardless of whether it was previously changed.\n\nAn instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the method; it may be changed via the method. The method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed.\n\nThe localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's object, , and its and object, .\n\nThe strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\nWhitespace is not significant in the above regular expressions."
    },
    {
        "link": "https://softteco.com/blog/java-scanner-class",
        "document": "Even though Java Scanner was introduced long time ago in the Java SE 5 version in 2004, developers still ask questions about its use and particular use cases. In this article, we answer the most common questions related to Scanner and we hope our answers will be helpful to you — now, let’s get started!\n\nWhat is Scanner class in Java?\n\nScanner is a class in package that is used for parsing primitive types and strings by using regular expressions. Basically it is used for reading input from the command line, although this approach is not very effective for situations where time is limited. For time-sensitive cases it’s preferable to use reading values from a file.\n\nHere is a sample of Scanner source code for a reference:\n\nHow to use Scanner in Java?\n\nTo use the Scanner class, you’ll need to create a class object and select one of the methods described in the Scanner class documentation.\n\nTo get the instance of Java Scanner that reads user input, you’ll have to pass the input stream (System.in) in the constructor of Scanner.\n\nTo get the instance of Java Scanner that is responsible for strings parsing, you’ll have to pass the strings in the constructor of Scanner.\n\nOr you may pass an object of class File if we want to read input from a file.\n\nScanner has a lot of constructors for different types of input. You can find all of them in Scanner.java class.\n\nHow to import scanner in Java?\n\nSince Scanner belongs to the package, you can import it without downloading any external libraries. There are two ways of how you can do this:\n\nIf you plan to work with the Scanner class only, you can import the Scanner class directly.\n\nIf you work with other modules in the java.util library, it may be a good idea to import the full library.\n\nThe first line of code imports the Scanner class. The second line of code imports all the packages within the java.util library, including Scanner.\n\nHow to read a file in Java using Scanner?\n\nTo read the content of a file, the Scanner class provides the following constructors:\n\nYou have to use the following Scanner methods for reading information from a file:\n\nHow to take input from user in Java using Scanner?\n\nJava Scanner class allows the user to take input from the console. To get the instance of Java Scanner which reads input from the user, we need to pass the input stream (System.in) in the constructor of the Scanner class.\n\nIt helps read the input of primitive types (i.e. int, double, long, short, float, or byte) and is the easiest way to read input in Java. The Java Scanner class provides the following methods to read different primitives types:\n\nThe following example allows users to read different types of data form the System.in.\n\nHow to close Scanner in Java?\n\nScanner is a class, where non-memory resources (like file descriptors) are used. So, java garbage collector cannot manage these resources and cannot free them up in order to avoid the resource leak.\n\nThere are two ways of keeping Scanner in the correct state in java.\n\nFirst is using method after reading input in block. This approach is useful if you’re using a Java version that’s earlier than JDK 7.\n\nA more correct way is to use try-with-resources construction, which was introduced in JDK 7.\n\nIn this case, Java will handle the process of closing resources automatically and the developer will not have to worry about closing the Scanner implicitly.\n\nHow to import a Scanner in Java?\n\nFor importing Scanner, we’ll use a standard operator import as there is no other way to do so in Java.\n\nHow to read multiple string input in Java?\n\nThere might be cases when you need to read a non-defined number of strings from CLI. In this case you can use the following example:\n\nBut in this case you won’t get out of the while loop, so for using this example you have to think of the condition when reading from the scanner will be finished. For instance, you would want to check if еру input string contains еру word «finish» and then break the .\n\nHow to read user input in Java without using Scanner?\n\nAre there alternative ways of reading input from users without using a Scanner in java? Definitely, there are. For example, here is sample with\n\nBut in fact it doesn’t matter which approach you’re using (either with or with ), because in both cases you will have to pass System.in input stream to the constructor.\n\nHow to close Scanner in Java?\n\nClass Scanner has a method named . This method does not take any arguments and returns nothing. It just closes the current scanner instance.\n\nThe invocation of this method will have no effect if the Scanner is already closed.\n\nWhy we need to close it?\n\nOnce you perform the operations on Scanner, you should close it. Otherwise, Scanner will be opened and it is available to pass any info to the application and may cause data leaks.\n\nAfter closing instance of Scanner you can’t use it. Otherwise you will get .\n\nThe result will be:\n\nThe most correct way to close a Scanner instance is to use block. Because classes which utilize non-memory resources should provide ways to explicitly allocate/deallocate those resources. We need to explicitly call methods for deallocation of file descriptors in , as it will execute whether or not an exception is thrown.\n\nHow to clear Scanner in Java?\n\nHonestly, you can’t really clear Scanner’s buffer. Internally, it may clear the buffer after a token is read, but that’s an implementation detail outside of the programmers’ reach.\n\nHow to loop a Scanner in Java?\n\nYou have many ways to loop: using , while or different methods of Scanner class if you want to control data which is input by the user.\n\nExample 1: User must input only a word and then display it. (Used while loop)\n\nExample 2: User must input number until result of multiplying will be bigger than 100. (Used for loop)\n\nExample 3: Read words from a file until they run out (Using methods of Scanner).\n\nAn important note! When you create a file object, you need to specify a pathname to this file. In example we put file in the root of the project. If you want to read file from directory from PC you can do something like this:\n\nWhew, that was a lot of information on Java Scanner and we hope you found it useful. Let us know whether you have any other unanswered questions in the comments below — or share your ideas about development tips that we can review next!"
    },
    {
        "link": "https://index.dev/blog/java-capture-user-input-console",
        "document": "Explore the best ways to capture user input in Java, with practical examples using Scanner, BufferedReader, Console, and more.\n\nReading user input from the console is something every Java developer deals with, whether you're building a quick CLI tool or a more complex app. Picking the right approach matters—it affects performance, flexibility, and how easy your code is to work with.\n\nJava gives you a few solid options for handling console input, each with its pros and cons. I’ll walk you through the best methods, focusing on real-world use cases and what works best in production. Let’s get into it.\n\nJoin Index.dev to find top remote Java developer jobs and grow your career with global companies!\n\nprovides you with a convenient way to parse both primitive types and strings. While it's versatile, it comes with performance implications that developers should understand.\n\nSystem.out.printf(\"Hello %s! You are %d years old.%n\", name, age);\n• None Easy to use for basic input tasks\n\nThe class, in combination with InputStreamReader, provides a faster alternative to Scanner due to efficient buffering. It is ideal for high-performance scenarios or when you are dealing with large inputs.\n\nprivate static final int BUFFER_SIZE = 8192; // Optimal buffer size for most use cases\n\nSystem.out.printf(\"Hello %s! Your number is: %d%n\", name, number);\n\nSystem.out.print(\"Input cannot be empty. Please try again: \");\n\nWhen you are handling sensitive input like passwords, the class provides built-in security features that make it the preferred choice as it does not echo characters back to the terminal.\n\nSystem.err.println(\"Console is not available. Please run from a terminal.\");\n\nconsole.format(\"Password must be at least 8 characters long.%n\");\n• None Does not echo input back to the screen\n• None Does not work in IDEs like Eclipse and IntelliJ\n\nRead More: How to Run an Autohotkey Script from Java\n\nWhile DataInputStream is primarily designed for reading binary data, it can be used for console input in legacy applications. However, modern applications should prefer Scanner or BufferedReader.\n\nSystem.out.printf(\"Hello %s! Your number is: %d%n\", name, number);\n\nthrow new IllegalArgumentException(\"Input cannot be empty\");\n• None Useful when working with binary data alongside text input\n• None Can be combined with\n• None Less efficient for text processing compared to modern alternatives\n\nThe enhanced version addresses several limitations of the basic implementation while maintaining compatibility with legacy systems. However, for new applications, we strongly recommend using Scanner or BufferedReader instead.\n\nHere’s a flowchart summarizing the best input methods for different scenarios:\n\nPicking the right way to read user input in Java depends on what you’re building. If you just need a simple solution, Scanner works well. For handling large text inputs efficiently, BufferedReader is the way to go. And if you need secure input (like passwords), Console is your best bet.\n\nOlder options like DataInputStream still exist, but they’re mostly outdated. Knowing these choices—and their pitfalls—helps you write cleaner, faster, and more secure code. Java keeps evolving, so staying up to date with best practices ensures your apps stay reliable and scalable.\n\nStrengthen your Java expertise and master efficient console input handling. to access global remote opportunities and work on enterprise-level projects with leading tech companies. Take your remote career to the next level!\n\nNeed skilled Java developers who can build efficient, high-performing applications? At Index.dev, we connect you with senior remote tech talent within 48 hours—backed by a risk-free 30-day trial. and accelerate project success with qualified engineers."
    },
    {
        "link": "https://geeksforgeeks.org/object-oriented-programming-oops-concept-in-java",
        "document": "Object-Oriented Programming or Java OOPs concept refers to programming languages that use objects in programming. They use objects as a primary source to implement what is to happen in the code. Objects are seen by the viewer or user, performing tasks you assign.\n\nObject-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc. in programming. The main aim of OOPs is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.\n\nIt is a simple example showing a class Numbers containing two variables which can be accessed and updated only by instance of the object created.\n\nA Class is a user-defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type. Using classes, you can create multiple objects with the same behavior instead of writing their code multiple times. This includes classes for objects occurring more than once in your code. In general, class declarations can include these components in order:\n• Modifiers : A class can be public or have default access (Refer to\n• Class name: The class name should begin with the initial letter capitalized by convention.\n• Body: The class body is surrounded by braces, { }.\n\nAn Object is a basic unit of Object-Oriented Programming that represents real-life entities. A typical Java program creates many objects, which as you know, interact by invoking methods. The objects are what perform your code, they are the part of your code visible to the viewer/user. An object mainly consists of:\n• State : It is represented by the attributes of an object. It also reflects the properties of an object.\n• Behavior : It is represented by the methods of an object. It also reflects the response of an object to other objects.\n• Identity : It is a unique name given to an object that enables it to interact with other objects.\n• Method: A method is a collection of statements that perform some specific task and return the result to the caller. A method can perform some specific task without returning anything. Methods allow us to reuse the code without retyping it, which is why they are considered time savers . In Java, every method must be part of some class, which is different from languages like\n\nFor more information, please refer to the article – Classes and Object.\n\nA method is a collection of statements that perform specific tasks and return a result to the caller. It can be declared with or without arguments, depending on the requirements. A method can take input values, perform operations, and return a result.\n\nData Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.\n\nData Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.\n\nConsider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the car speed or applying brakes will stop the car, but he does not know how on pressing the accelerator, the speed is actually increasing. He does not know about the inner mechanism of the car or the implementation of the accelerators, brakes etc. in the car. This is what abstraction is.\n\nNote: In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.\n\n\n\nTo learn more about the Abstraction refer to the Abstraction in Java article\n\nIt is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n• None Technically, in encapsulation, the variables or the data in a class is hidden from any other class and can be accessed only through any member function of the class in which they are declared.\n• None In encapsulation, the data in a class is hidden from other classes, which is similar to what data-hiding does. So, the terms “encapsulation” and “data-hiding” are used interchangeably.\n• None Encapsulation can be achieved by declaring all the variables in a class as private and writing public methods in the class to set and get the values of the variables.\n\nTo learn more about topic refer to Encapsulation in Java article.\n\nInheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as “is-a” relationship.\n\nLet us discuss some frequently used important terminologies:\n• Superclass: The class whose features are inherited is known as superclass (also known as base or parent class).\n• Subclass: The class that inherits the other class is known as subclass (also known as derived or extended or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.\n• Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.\n\n\n\nTo learn more about topic refer to Inheritance in Java article.\n\nIt refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently. This is done by Java with the help of the signature and declaration of these entities. The ability to appear in many forms is called polymorphism.\n\nPolymorphism in Java is mainly of 2 types as mentioned below:\n\n1. Method Overloading: Also, known as compile-time polymorphism, is the concept of Polymorphism where more than one method share the same name with different signature(Parameters) in a class. The return type of these methods can or cannot be same.\n\n2. Method Overriding: Also, known as run-time polymorphism, is the concept of Polymorphism where method in the child class has the same name, return-type and parameters as in parent class. The child class provides the implementation in the method already written.\n\nBelow is the implementation of both the concepts:\n\nTo know more about the topic refer the Polymorphism in Java article.\n• OOP promotes code reusability : By using objects and classes, you can create reusable components, leading to less duplication and more efficient development.\n• OOP enhances code organization : It provides a clear and logical structure, making the code easier to understand, maintain, and debug.\n• OOP supports the DRY (Don’t Repeat Yourself) principle : This principle encourages minimizing code repetition, leading to cleaner, more maintainable code. Common functionalities are placed in a single location and reused, reducing redundancy.\n• OOP enables faster development : By reusing existing code and creating modular components, OOP allows for quicker and more efficient application development\n\nThe Object Oriented Programming (OOPs) concept in Java is a powerful way to organize and write code. It uses key ideas like classes, objects, inheritance, polymorphism, encapsulation, and abstraction to create flexible and reusable code.\n\nBy using the Java OOPs concept, programmers can build complex applications more efficiently, making the code easier to manage, understand, and modify. Overall, Java’s OOPs concepts help in creating robust and scalable software solutions.\n\nWhat is OOPs concept in Java?\n\nWhy is OOPs important in Java?\n\nWhat are the main principles of OOPs in Java?\n\nHow is OOPs implemented in Java?\n\nWhat are the advantages of using OOPs in Java?\n\nCan you provide an example of OOPs concept implementation in Java?"
    },
    {
        "link": "https://raygun.com/blog/oop-concepts-java",
        "document": "Java is a class-based object-oriented programming (OOP) language built around the concept of objects. OOP concepts are intended to improve code readability and reusability by defining how to structure your Java program efficiently. There are seven core principles of object-oriented programming, as follows.\n\nJava comes with specific code structures for each OOP concept, such as the keyword for the inheritance principle or the getter and setter methods for the encapsulation principle.\n\nWhile these concepts are crucial for creating well-structured Java programs in the development phase, implementing crash reporting can also help you catch the errors your end-users encounter in the operation and maintenance phase of the software development life cycle.\n\nIn this guide, we’ll look into both the theory and practice of object-oriented programming to help you write performant and error-free Java code.\n\nWhat are OOP concepts in Java?\n\nObject-oriented programming focuses on objects made up of both data (fields) and code (properties or attributes). Using OOP, programmers can create classes in order to iteratively reuse code, with the same set of “instructions” being sent to different objects, rather than coding each operation from scratch each time. This works particularly well for large team projects where states change often.\n\nJava supports object-oriented programming, along with other popular languages like Python and C++. In Java, OOP concepts allow us to create specific interactions between Java objects. They make it possible to reuse code without creating security risks or harming performance and code readability.\n• Make large and complex code bases more efficient and manageable\n• Teams working from the same code base will benefit from existing well-written classes\n• Java in particular enforces OOP, which creates good habits (but may be challenging for beginners)\n\nThere are four main and three secondary principles of object-oriented Java programming. Let’s take a look at what they are and why they’re useful. You can also download or clone the code examples below from this GitHub repo.\n\nAbstraction aims to hide complexity from users and show them only relevant information. For example, if you’re driving a car, you don’t need to know about its internal workings.\n\nThe same is true of Java classes. You can hide internal implementation details using abstract classes or interfaces. On the abstract level, you only need to define the method signatures (name and parameter list) and let each class implement them in their own way.\n• Presents only the signature of internal functionality\n• Gives flexibility to programmers to change the implementation of abstract behavior\n• Partial abstraction (0-100%) can be achieved with abstract classes\n• Total abstraction (100%) can be achieved with interfaces\n\nExample: How abstraction works in practice\n\nAs mentioned above, abstraction allows you to hide the internal workings of an object and only show the features the user needs to know about.\n\nJava provides two ways to implement abstraction: abstract classes and interfaces. With abstract classes, you can achieve partial abstraction, while interfaces make total (100%) abstraction possible.\n\nAn abstract class is a superclass (parent class) that cannot be instantiated. To create a new object, you need to instantiate one of its child classes. Abstract classes can have both abstract and concrete methods. Abstract methods contain only the method signature, while concrete methods declare the method body as well. Abstract classes are defined with the keyword.\n\nIn the code example below, we create an abstract class called with two abstract and one concrete method.\n\nThen, we extend it with two child classes: and . Both of them define their own implementations of the and abstract methods.\n\nNow, we’ll test it with the help of the and classes. Both initialize an object ( and ) and call the one concrete ( ) and the two abstract ( and ) methods.\n\nNote, however, that you don’t necessarily have to call all the methods if you don’t want to — this is how abstract classes make partial abstraction possible (for example, you could call just ).\n\nAs you can see below, the concrete method has been called from the abstract class, while the two abstract methods have been called from and , respectively.\n\nAn interface is a 100% abstract class. It can only have static, final, and public fields and abstract methods. It’s frequently referred to as a blueprint of a class as well. Java interfaces allow you to implement multiple inheritances in your code, as a class can implement any number of interfaces. Classes can access an interface with the keyword.\n\nIn the example, we define two interfaces: with two abstract methods (interface methods are abstract by default) and with two static fields and an abstract method.\n\nThe class implements both interfaces. It defines its own functionality for the three abstract methods. The and methods come from the class, while comes from .\n\nIn the test class, we instantiate a new object (called ) and print out all the fields and methods to the console.\n\nAs static fields ( and ) don’t belong to a specific object but to the interface, we need to access them from the interface instead of the object.\n\nThe Java console returns all the information we wanted to access:\n\nEncapsulation helps with data security, allowing you to protect the data stored in a class from system-wide access. As the name suggests, it safeguards the internal contents of a class like a capsule.\n\nYou can implement encapsulation in Java by making the fields (class variables) private and accessing them via their public getter and setter methods. JavaBeans are examples of fully encapsulated classes.\n• Each field has a getter and setter method\n• Setter methods let us change the value of the field\n\nExample: how encapsulation works in practice\n\nWith encapsulation, you can protect the fields of a class. To do so, you need to declare the fields as and provide access to them with getter and setter methods.\n\nThe class below is fully encapsulated. It has three private fields, and each has its own pair of getter and setter methods.\n\nThe class first creates a new object (called ), then defines a value for each field with the setter methods, and finally prints out the values using the getter methods.\n\nAs you can see below, the Java console returns all the values we have set with the setter methods:\n\nInheritance makes it possible to create a child class that inherits the fields and methods of the parent class. The child class can override the values and methods of the parent class, but it’s not necessary. It can also add new data and functionality to its parent.\n\nParent classes are also called superclasses or base classes, while child classes are known as subclasses or derived classes as well. Java uses the keyword to implement the principle of inheritance in code.\n• A class (child class) can extend another class (parent class) by inheriting its features\n• Multi-level inheritance is allowed in Java (a child class can have its own child class as well)\n• Multiple inheritances are not allowed in Java (a class can’t extend more than one class)\n\nExample: How inheritance works in practice\n\nInheritance lets you extend a class with one or more child classes that inherit the fields and methods of the parent class. It’s an excellent way to achieve code reusability. In Java, you need to use the keyword to create a child class.\n\nIn the example below, the class extends the parent class. It inherits all of its fields and methods, plus defines two extra fields that belong only to .\n\nThe class instantiates a new object (called ) and prints out all the information (both the inherited fields and methods and the two fields defined by the class).\n\nHere’s the console output we get:\n\nPolymorphism refers to the ability to perform a certain action in different ways. In Java, polymorphism can take two forms: method overloading and method overriding.\n\nMethod overloading happens when various methods with the same name are present in a class. When they are called, they are differentiated by the number, order, or types of their parameters. Method overriding occurs when a child class overrides a method of its parent.\n• The same method name is used several times\n• Different methods of the same name can be called from an object\n• All Java objects can be considered polymorphic (at the minimum, they are of their own type and instances of the class)\n• Static polymorphism in Java is implemented by method overloading\n• Dynamic polymorphism in Java is implemented by method overriding\n\nExample: How polymorphism works in practice\n\nPolymorphism makes it possible to use the same code structure in different forms. In Java, this means that you can declare several methods with the same name as long as they are different in certain characteristics.\n\nAs mentioned above, Java provides two ways to implement polymorphism: method overloading and method overriding.\n\nMethod overloading means that you can have several methods with the same name within a class. However, the number, names, or types of their parameters need to be different.\n\nFor example, the class below has three methods. The first one doesn’t have any parameters, the second one has one parameter ( ), and the third one has two parameters ( and ).\n\nThe test class instantiates a new object and calls the method three times: first, without parameters, second, with one integer parameter for , and third, with two parameters for and .\n\nIn the console, you can see that Java could have differentiated the three polymorphic fly() methods:\n\nUsing the method overriding feature of Java, you can override the methods of a parent class from its child class.\n\nIn the code example below, the class extends the class. Both have an method. By default, inherits its parent’s method. However, as it also defines its own method, Java will override the original method and call from the child class.\n\nThe class first instantiates a new object and calls its method. Then, it also creates a object and calls the polymorphic method again.\n\nThe console returns the values of the relevant methods properly because Java could have differentiated the two methods:\n\nAbstraction, encapsulation, polymorphism, and inheritance are the four main theoretical principles of object-oriented programming. But Java also works with three further OOP concepts: association, aggregation, and composition. Aggregation is a special form of association, while composition is a special form of aggregation. While that may sound a bit convoluted, we’re about to explain. Read on!\n\nAssociation means the act of establishing a relationship between two unrelated classes. For example, when you declare two fields of different types (e.g. and ) within the same class and make them interact with each other, you have created an association.\n• Two separate classes are associated through their objects\n• The two classes are unrelated, each can exist without the other one\n• Can be a one-to-one, one-to-many, many-to-one, or many-to-many relationship\n\nAggregation is a narrower kind of association. It occurs when there’s a one-way (HAS-A) relationship between the two classes we associate through their objects.\n\nFor example, every has a , but a doesn’t necessarily have a . When you declare the class, you can create a field of the type that shows which car the passenger belongs to. Then, when you instantiate a new object, you can access the data stored in the related as well.\n• Only one class is dependent on the other\n\nComposition is a stricter form of aggregation. It occurs when the two classes you associate are mutually dependent and can’t exist without each other.\n\nFor example, take a and an class. A cannot run without an , while an also can’t function without being built into a . This kind of relationship between objects is also called a PART-OF relationship.\n• Both classes are dependent on each other\n• If one class ceases to exist, the other can’t survive alone\n\nRemember, the code examples in this post are also available to clone or download from this GitHub repo.\n\nOOP concepts in Java help you to structure your program more efficiently. The seven object-oriented principles we’ve explored here (abstraction, encapsulation, polymorphism, inheritance, association, aggregation, and composition) can help you reuse your code, prevent security issues, and improve the performance of your Java applications.\n\nObject-oriented programming is a broad and complex field, and if you’re upskilling in this area, we’d also recommend exploring this guide to object-oriented design patterns.\n\nWhile you’re focused on boosting the performance of your Java code, add Raygun Application Performance Monitoring and Crash Reporting in minutes and detect problems in your software as they happen.\n\nSign up today and start your 14-day free trial."
    },
    {
        "link": "https://medium.com/@manishkumar_75473/mastering-object-oriented-programming-oop-in-java-encapsulation-inheritance-polymorphism-and-12b5c5c4469c",
        "document": "Object-Oriented Programming (OOP) is a fundamental programming paradigm that is widely used in Java. It focuses on organising software around objects, rather than functions or logic. The four pillars of OOP are Encapsulation, Inheritance, Polymorphism, and Abstraction.\n\nEncapsulation is like putting a lock on the box where your data is stored and only giving access through a controlled key (getter and setter methods). It allows you to hide the internal details of an object and only expose what is necessary to the outside world. This protects your data from unauthorised access and changes. In Java, encapsulation is achieved by making class variables and providing getter and setter methods to access them. class Person {\n\n private String name; // Private variable\n\n\n\n// Getter method\n\n public String getName() {\n\n return name;\n\n }\n\n // Setter method\n\n public void setName(String name) {\n\n this.name = name;\n\n }\n\n}\n\npublic class Main {\n\n public static void main(String[] args) {\n\n Person person = new Person();\n\n person.setName(\"John\"); // Set the name using setter\n\n System.out.println(person.getName()); // Get the name using getter\n\n }\n\n}\n• We declared as , meaning it can't be accessed directly from outside the class.\n• The method allows us to get the value of , and the method lets us modify it.\n\nInheritance allows one class to inherit properties and behaviours from another class. It helps avoid duplication of code by enabling a new class to reuse code from an existing class. In Java, a subclass (child class) can inherit from a superclass (parent class) using the keyword. class Animal {\n\n public void speak() {\n\n System.out.println(\"Animal speaks\");\n\n }\n\n}\n\n\n\nclass Dog extends Animal { // Dog inherits from Animal\n\n @Override\n\n public void speak() {\n\n System.out.println(\"Dog barks\");\n\n }\n\n}\n\npublic class Main {\n\n public static void main(String[] args) {\n\n Dog dog = new Dog();\n\n dog.speak(); // Calls the speak() method in Dog class\n\n }\n\n}\n• The class extends the class and inherits its method.\n• The method is overridden in the class to provide a more specific behavior for dogs.\n• We create a object and call , which prints \"Dog barks\".\n\nPolymorphism allows objects of different classes to be treated as objects of a common superclass. The specific method that gets called is determined at runtime, depending on the object type. It means “many forms” and is mostly achieved through method overriding and method overloading. In method overriding, a subclass provides its own version of a method already defined in the superclass. class Animal {\n\n public void sound() {\n\n System.out.println(\"Animal makes a sound\");\n\n }\n\n}\n\n\n\nclass Cat extends Animal {\n\n @Override\n\n public void sound() {\n\n System.out.println(\"Cat meows\");\n\n }\n\n}\n\nclass Dog extends Animal {\n\n @Override\n\n public void sound() {\n\n System.out.println(\"Dog barks\");\n\n }\n\n}\n\npublic class Main {\n\n public static void main(String[] args) {\n\n Animal animal1 = new Cat();\n\n animal1.sound(); // Calls sound() method in Cat class\n\n Animal animal2 = new Dog();\n\n animal2.sound(); // Calls sound() method in Dog class\n\n }\n\n}\n• We have an class with a method , and both the and classes override this method.\n• At runtime, when we create objects of and , the appropriate method is called based on the object type.\n\nAbstraction is the concept of hiding the complex implementation details and showing only the essential features. It allows you to focus on what an object does, rather than how it does it. In Java, abstraction is achieved using abstract classes and interfaces. abstract class Animal {\n\n abstract void sound(); // Abstract method (no body)\n\n\n\npublic void eat() {\n\n System.out.println(\"Animal eats food\");\n\n }\n\n}\n\nclass Dog extends Animal {\n\n @Override\n\n void sound() {\n\n System.out.println(\"Dog barks\");\n\n }\n\n}\n\npublic class Main {\n\n public static void main(String[] args) {\n\n Dog dog = new Dog();\n\n dog.sound(); // Calls Dog's sound method\n\n dog.eat(); // Calls the inherited eat method from Animal\n\n }\n\n}\n• The class is abstract and contains an abstract method , which is implemented by the class.\n• The method is concrete (non-abstract) and is inherited by the class, so we can call it without overriding."
    },
    {
        "link": "https://freecodecamp.org/news/java-object-oriented-programming-system-principles-oops-concepts-for-beginners",
        "document": "Object-oriented programming is a programming paradigm where everything is represented as an object.\n\nObjects pass messages to each other. Each object decides what to do with a received message. OOP focuses on each object’s states and behaviors.\n\nAn object is an entity that has states and behaviors.\n\nFor example, dog, cat, and vehicle. To illustrate, a dog has states like age, color, name, and behaviors like eating, sleeping, and running.\n\nState tells us how the object looks or what properties it has.\n\nBehavior tells us what the object does.\n\nWe can actually represent a real world dog in a program as a software object by defining its states and behaviors.\n\nSoftware objects are the actual representation of real world objects. Memory is allocated in RAM whenever creating a logical object.\n\nAn object is also referred to an instance of a class. Instantiating a class means the same thing as creating an object.\n\nThe important thing to remember when creating an object is: the reference type should be the same type or a super type of the object type. We’ll see what a reference type is later in this article.\n\nA class is a template or blueprint from which objects are created.\n\nImagine a class as a cookie-cutter and objects as cookies.\n\nFigure 1: Illustrates class and object relationship through cookie-cutter and cookies. [Source](https://www.piqsels.com/en/public-domain-photo-sswme\" rel=\"noopener).\n\nClasses define states as instance variables and behaviors as instance methods.\n\nInstance variables are also known as member variables.\n\nTo give you an idea about classes and objects, let's create a Cat class that represents states and behaviors of real world Cat.\n\nNow we have successfully defined a template for Cat. Let’s say we have two cats named Thor and Rambo.\n\nHow can we define them in our program?\n\nFirst, we need to create two objects of the Cat class.\n\nNext, we’ll define their states and behaviors.\n\nLike the above code examples, we can define our class, instantiate it (create objects) and specify the states and behaviors for those objects.\n\nNow, we have covered the basics of object-oriented programming. Let's move on to the principles of object-oriented programming.\n\nThese are the four main principles of the object-oriented programming paradigm. Understanding them is essential to becoming a successful programmer.\n\nNow let's look at each in more detail.\n\nEncapsulation is a process of wrapping code and data together into a single unit.\n\nIt's just like a capsule that contains a mix of several medicines, and is a technique that helps keep instance variables protected.\n\nThis can be achieved by using access modifiers that can’t be accessed by anything outside the class. In order to access private states safely, we have to provide public getter and setter methods. (In Java, these methods should follow JavaBeans naming standards.)\n\nLet’s say there is a record shop that sells music albums of different artists and a stock keeper who manages them.\n\nIf you look at figure 4, the class can access the class’s states directly as class’s states are set to .\n\nWhat if the stock keeper creates an album and sets states to negative values? This can be done intentionally or unintentionally by a stock keeper.\n\nTo illustrate, let’s see a sample Java program that explains the above diagram and statement.\n\nThe album’s price and number of copies can’t be negative values. How can we avoid this situation? This is where we use encapsulation.\n\nIn this scenario, we can block the stock keeper from assigning negative values. If they attempt to assign negative values for the album’s price and number of copies, we’ll assign them as 0.0 and 0.\n\nWith encapsulation, we’ve blocked our stock keeper from assigning negative values, meaning we have control over the data.\n• We can make a class read-only or write-only: for a read-only class, we should provide only a getter method. For a write-only class, we should provide only a setter method.\n• Control over the data: we can control the data by providing logic to setter methods, just like we restricted the stock keeper from assigning negative values in the above example.\n\nLet’s say that the record shop we discussed above also sells Blu-ray movies.\n\nAs you can see in the above diagram, there are many common states and behaviors (common code) between and .\n\nWhen implementing this class diagram into code, are you going to write (or copy & paste) the entire code for ? If you do, you are repeating yourself. How can you avoid code duplication?\n\nThis is where we use inheritance.\n\nInheritance is a mechanism in which one object acquires all the states and behaviors of a parent object.\n\nSo what exactly is inherited?\n\nVisibility/access modifiers impact what gets inherited from one class to another.\n\nIn Java, as a rule of thumb we make instance variables and instance methods .\n\nIn this case, we can safely say that the following are inherited:\n• private instance variables (private instance variables can be accessed only through public getter and setter methods).\n\nThere are five types of inheritance in Java. They are single, multilevel, hierarchical, multiple, and hybrid.\n\nClass allows single, multilevel and hierarchical inheritances. Interface allows multiple and hybrid inheritances.\n\nA class can extend only one class however it can implement any number of interfaces. An interface can extend more than one interfaces.\n\nAn IS-A relationship refers to inheritance or implementation.\n\nGeneralization uses an IS-A relationship from a specialization class to generalization class.\n\nAn instance of one class HAS-A reference to an instance of another class.\n\nIn this relationship, the existence of class A and B are not dependent on each other.\n\nFor this aggregation part, we going to see an example of the class and the class.\n\nHAS-A . can be used in other places – for example, a company's class can also use this class. So can exist without and can exist without . This type of relationship is known as aggregation.\n\nIn this relationship, class B can not exist without class A – but class A can exist without class B.\n\nTo give you an idea about composition, let's see an example of the class and the class.\n\nHAS-A . can exist without but can not exist without . This type of relationship is known as composition.\n\nNow, let’s back to our previous record shop example that we discussed above.\n\nWe can implement this diagram in Java to avoid code duplication.\n• Code reuse: the child class inherits all instance members of the parent class.\n• You have more flexibility to change code: changing code in place is enough.\n• You can use polymorphism: method overriding requires IS-A relationship.\n\nAbstraction is a process of hiding the implementation details and showing only functionality to the user.\n\nA common example of abstraction is that pressing the accelerator will increase the speed of a car. But the driver doesn’t know how pressing the accelerator increases the speed – they don't have to know that.\n\nTechnically abstract means something incomplete or to be completed later.\n\nIn Java, we can achieve abstraction in two ways: abstract class (0 to 100%) and interface (100%).\n\nThe keyword can be applied to classes and methods. and or can never be together.\n\nAn abstract class is one that contains the keyword .\n\nAbstract classes can’t be instantiated (can’t create objects of abstract classes). They can have constructors, static methods, and final methods.\n\nAn abstract method is one that contains the keyword .\n\nAn abstract method doesn’t have implementation (no method body and ends up with a semi colon). It shouldn’t be marked as .\n• If at least one abstract method exists inside a class then the whole class should be abstract.\n• We can have an abstract class with no abstract methods.\n• We can have any number of abstract as well as non-abstract methods inside an abstract class at the same time.\n• The first concrete sub class of an abstract class must provide implementation to all abstract methods.\n• If this doesn't happen, then the sub class also should be marked as abstract.\n\nIn a real world scenario, the implementation will be provided by someone who is unknown to end users. Users don’t know the implementation class and the actual implementation.\n\nLet’s consider an example of abstract concept usage.\n\nFigure 13: Class diagram that shows the relationship between an abstract class and a concrete class\n\nWhen do we want to mark a class as abstract?\n• To force sub classes to implement abstract methods.\n• To stop having actual objects of that class.\n• To keep having a class reference.\n\nAn interface is a blueprint of a class.\n\nAn interface is 100% abstract. No constructors are allowed here. It represents an IS-A relationship.\n\nNOTE: Interfaces only define required methods. We can not retain common code.\n\nAn interface can have only abstract methods, not concrete methods. By default, interface methods are and . So inside the interface, we don’t need to specify and .\n\nSo when a class implements an interface’s method without specifying the access level of that method, the compiler will throw an error stating “Cannot reduce the visibility of the inherited method from interface” . So that implemented method’s access level must be set to .\n\nBy default, interface variables are , and .\n\nLet’s see an example that explains the interface concept:\n\nFigure 14: Class diagram that shows the relationship between an interface and a concrete class\n\nUsually we implement interface methods in a separate class. Let’s say we are required to add a new method in an interface. Then we must implement that method in that separate class, too.\n\nTo overcome this issue Java 8 introduced default and static methods that implement methods inside an interface, unlike abstract methods.\n\nSimilar to static methods of classes, we can call them by their interface’s name.\n\nIt’s an empty interface. For instance, Serializable, Cloneable, and Remote interfaces.\n• They help us use multiple inheritance in Java.\n• They provide loose coupling: objects are independent from one another.\n\nWhen do we want to change a class to an interface?\n• To force sub classes to implement abstract methods.\n• To stop having actual objects of that class.\n• To keep having a class reference.\n\nIf you want to define potentially required methods and common code, use an abstract class.\n\nIf you just want to define a required method, use an interface.\n\nPolymorphism is the ability of an object to take on many forms.\n\nPolymorphism in OOP occurs when a super class references a sub class object.\n\nAll Java objects are considered to be polymorphic as they share more than one IS-A relationship (at least all objects will pass the IS-A test for their own type and for the class Object).\n\nWe can access an object through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.\n\nA reference variable can be declared as a class or interface type.\n\nA single object can be referred to by reference variables of many different types as long as they are the same type or a super type of the object.\n\nIf a class has multiple methods that have same name but different parameters, this is known as method overloading.\n• Must have a different parameter list.\n• May have different return types.\n• May have different access modifiers.\n\nNOTE: Static methods can also be overloaded.\n\nNOTE: We can overload the main() method but the Java Virtual Machine (JVM) calls the main() method that receives String arrays as arguments.\n• It can only look in reference type for methods.\n• At runtime, JVM follows exact runtime type (object type) to find method.\n• Must match compile time method signature to method in actual object’s class.\n\nIf a subclass has the same method as declared in the super class, this is known as method overriding.\n• Must have the same parameter list.\n• Must have the same return type: although a covariant return allows us to change the return type of the overridden method.\n• Must not have a more restrictive access modifier: may have a less restrictive access modifier.\n• Must not throw new or broader checked exceptions: may throw narrower checked exceptions and may throw any unchecked exception.\n• Only inherited methods may be overridden (must have IS-A relationship).\n\nNOTE: Static methods can’t be overridden because methods are overridden at run time. Static methods are associated with classes while instance methods are associated with objects. So in Java, the method also can’t be overridden.\n\nNOTE: Constructors can be overloaded but not overridden.\n\nIn , this object creation is perfectly fine.\n\nis a type reference variable and will create a new object.\n\ncan’t access in compile time because the compiler only knows the reference type. Since there is no in the reference type class, it can’t access it. But in runtime is going to be the type (Runtime type/ object type).\n\nPlease review this post for more information on runtime types.\n\nIn this case, we can convince the compiler by saying “at runtime, will be type, so please allow me to call it”. How can we convince the compiler like this? This is where we use casting.\n\nWe can make a type in compile time and can call by casting it.\n\nJava type casting is classified into two types:\n\nIn primitives, is a larger type than . Like in objects, the parent class is a larger type than the child class.\n\nThe reference variable only refers to an object. Casting a reference variable doesn’t change the object on the heap but it labels the same object in another way by means of instance members accessibility.\n\nWe have to be careful when narrowing. When narrowing, we convince the compiler to compile without any error. If we convince it wrongly, we will get a run time error (usually ).\n\nIn order to perform narrowing correctly, we use the operator. It checks for an IS-A relationship.\n\nAs I already stated before, we must remember one important thing when creating an object using the keyword: the reference type should be the same type or a super type of the object type.\n\nThank you everyone for reading. I hope this article helped you.\n\nI strongly encourage you to read more related articles on OOP.\n\nCheckout my original article series on Medium: Object-oriented programming principles in Java\n\nPlease feel free to let me know if you have any questions."
    },
    {
        "link": "https://geeksforgeeks.org/encapsulation-in-java",
        "document": "Encapsulation in Java is a fundamental OOP (object-oriented programming) principle that combines data and methods in a class. It allows implementation details to be hidden while exposing a public interface for interaction.\n\nExample: Below is a simple example of Encapsulation in Java.\n\nExplanation: In this example, the class restricts direct access to it from outside. The and methods, known as getters and setters, provide controlled access to the attribute. This encapsulation mechanism protects the internal state of the object and allows for better control and flexibility in how the attribute is accessed and modified.\n\nIn Java, encapsulation is implemented by declaring instance variables as private, restricting direct access. Public getter methods retrieve variable values, while setter methods modify them, enabling controlled access. This approach allows the class to enforce data validation and maintain a consistent internal state, enhancing security and flexibility.\n\nEncapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. Another way to think about encapsulation is, that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n• None In encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of its own class.\n• None A private class can hide its members or methods from the end user, using abstraction to hide implementation details, by combining data hiding abstraction.\n• None Encapsulation can be achieved by Declaring all the variables in the class as private and writing public methods in the class to set and get the values of variables.\n• None It is more defined with the setter and getter method.\n\nExample 1: Here is another example of encapsulation in Java\n\nExplanation: Here the encapsulation is achieved by restricting direct access to the name and age fields of the Person class. These fields are marked as private and can only be accessed or modified through public getter and setter methods (getName(), setName(), getAge(), setAge()). This approach ensures data hiding and maintains control over the values of these fields.\n\nExample 2: In this example, we use abstraction to hide the implementation and show the functionality.\n\nExample 2: The program to access variables of the class EncapsulateDemo is shown below:\n\nExplanation: In the above program, the class Encapsulate is encapsulated as the variables are declared private. The get methods like getAge(), getName(), and getRoll() are set as public, these methods are used to access these variables. The setter methods like setName(), setAge(), and setRoll() are also declared as public and are used to set the values of the variables.\n\nExample 4: Below is the implementation of the Java Encapsulation:\n\nExplanation: in the above code we can easily get the values and set the values easily by using the methods. Here the implementation is hidden and we can perform the tasks which makes it easy to use for end users.\n• Data Hiding: Encapsulation provides data hiding. Users don’t see the implementation of the class. The user only knows that we are passing the values to a setter method and variables are getting initialized with that value.\n• Data Integrity : By using getter and setter methods, we can ensure that only valid data is assigned to variables. If we omit the setter methods, we make the variables read-only, and if we omit the getter methods, we make them write-only. This ensures the internal state of the object is protected and maintains data integrity.\n• Reusability: Encapsulation also improves the re-usability and is easy to change with new requirements.\n• Testing code is easy: Encapsulated code is easy to test for unit testing.\n• Freedom of the details: one of the major advantages of encapsulation is that it gives the programmer freedom to implement the details of a system. The only constraint on the programmer is to maintain the abstract interface that outsiders see.\n• None It can lead to increased complexity, especially if not used properly.\n• None It can make it more difficult to understand how the system works.\n• None This may limit the flexibility of the implementation."
    },
    {
        "link": "https://stackoverflow.com/questions/78133631/java-getter-and-setters-for-simple-properties-best-practice",
        "document": "I know this is a common question and I've read several answers but they're all very subjective and I'm trying to get an answer on best common practice (i.e what to use a majority of the time).\n\nMy background is in C# .net and I'm re-writing an application in Java (ver. 21). With C# a public property with a getter and setter is functionally the same thing as a private field with a public getter and setter (C# example below). The get and set are implicitly used when referencing the property. So in practice 99% of the time I use a public property with getter and setter because it gives me the added benefit of encapsulation and doesn't add any verbosity to the code.\n\nNow with Java I'm struggling when to use getters and setters. If I where to code like I do with C#, most of my java object properties would be private fields with public getter and setter methods. That makes the code really verbose (example1 below) and I'm not sure if it's necessary/common for simple objects like json responses (mapped by jackson) or entities.\n\nSo with that all being said, in practice what is the most standard way of handling simple properties that just get and set a field in Java (without data manipulation). Like if I where to see an enterprise application what would be the most standard way of handling example1 and example2 below. Based on my research thus far I'm leaning towards example1 (keeps encapsulation), but I don't want to use getters and setters everywhere if it's actually more common practice to just use public fields with simple properties. Let me know your thoughts.\n\nExample2 using fields (assume public fields on objects above):"
    },
    {
        "link": "https://dzone.com/articles/java-getter-and-setter-basics-common-mistakes-and",
        "document": "Getter and setter are widely used in Java. It is seemingly simple, but not every programmer understands and implements this kind of method properly. So in this article, I would like to deeply discuss getter and setter methods in Java — from the basics to common mistakes and best practices.\n\nIf you are already good with the basics, jump directly to section 4 where I talk about common mistakes and best practices.\n\n1. What Are Getter and Setter?\n\nIn Java, getter and setter are two conventional methods that are used for retrieving and updating the value of a variable.\n\nThe following code is an example of a simple class with a private variable and a couple of getter/setter methods:\n\nThe class declares a private variable, number. Since number is private, the code from the outside of this class cannot access the variable directly, as shown below:\n\nInstead, the outside code has to invoke the getter, , and the setter, , in order to read or update the variable, for example:\n\nSo, a setter is a method that updates the value of a variable. And a getter is a method that reads the value of a variable. Getter and setter are also known as accessor and mutator in Java.\n\n2. Why Do We Need Getter and Setter?\n\nBy using getter and setter, the programmer can control how their important variables are accessed and updated in the proper manner, such as changing the value of a variable within a specified range. Consider the following code of a setter method:\n\nThis ensures that the value of the number is always set between 10 and 100. Suppose the variable number can be updated directly, the caller can set any arbitrary value to it:\n\nAnd that violates the constraint for values ranging from 10 to 100 for that variable. Of course, we don’t expect that to happen. Thus, hiding the variable number as private and then using a setter comes to the rescue.\n\nOn the other hand, a getter method is the only way for the outside world to read the variable’s value:\n\nThe following picture illustrates the situation:\n\nSo far, the setter and getter methods protect a variable’s value from unexpected changes by the outside world — the caller code.\n\nWhen a variable is hidden by the private modifier and can be accessed only through getter and setter, it is encapsulated. Encapsulation is one of the fundamental principles in object-oriented programming (OOP), thus implementing getter and setter is one of the ways to enforce encapsulation in the program’s code.\n\nSome frameworks such as Hibernate, Spring, and Struts can inspect information or inject their utility code through getter and setter. So providing getter and setter is necessary when integrating your code with such frameworks.\n\nThe naming scheme of setter and getter should follow the Java bean naming convention as and , where is the name of the variable. For example, with the following variable name:\n\nThe appropriate setter and getter will be:\n\nIf the variable is of the type boolean, then the getter’s name can be either or , but the former naming is preferred. For example:\n\nThe following table shows some examples of getters and setters which qualified for the naming convention:\n\nPeople often make mistakes, and developers are no exception. This section describes the most common mistakes when implementing setters and getters in Java, as well as workarounds.\n\nMistake #1: You have setter and getter, but the variable is declared in a less restricted scope.\n\nConsider the following code snippet:\n\nThe variable is declared as public, so it can be accessed using the dot (.) operator directly, making the setter and getter useless. A workaround for this case is using more restricted access modifier such as protected and private:\n\nIn the book Effective Java, Joshua Bloch points out this problem in item 14:\n\nConsidering the following setter method:\n\nThe following code demonstrates this problem:\n\nAn array of integer numbers, , is initialized with 6 values (line 1) and the array is passed to the method (line 2). The method simply prints out all scores from the array:\n\nLine 3 will produce the following output:\n\nThese are all the elements of the array. Now, in line 4, we can modify the value of the 2nd element in the array as follows:\n\nWhat will happen if we call the method again at line 5? Well, it will produce the following output:\n\nYou realize that the value of the 2nd element is changed from 5 to 1, as a result of the assignment in line 4. Why does it matter? Well, that means the data can be modified outside the scope of the setter method, which breaks the encapsulation purpose of the setter. And why does that happen? Let’s look at the method again:\n\nThe member variable scores are assigned to the method’s parameter variable directly. That means both of the variables are referring to the same object in memory — the array object. So changes made to either the or variables are actually made on the same object.\n\nA workaround for this situation is to copy elements from the array to the array, one by one. The modified version of the setter would look like this:\n\nWhat’s the difference? Well, the member variable is no longer referring to the object referred by the variable. Instead, the array is initialized to a new one with size equals to the size of the array . Then, we copy all elements from the array to the array , using method.\n\nRun the following example again, and it will give us the following output:\n\nNow, the two invocations of produce the same output. That means the array is independent and different than the array passed into the setter, thus we have the assignment:\n\nThis does not affect the array .\n\nSo, the rule of thumb is: If you pass an object reference into a setter method, then don’t copy that reference into the internal variable directly. Instead, you should find some ways to copy values of the passed object into the internal object, like we have copied elements from one array to another using the method.\n\nConsider the following getter method:\n\nAnd then look at the following code snippet:\n\nIt will produce the following output:\n\nAs you notice, the 2nd element of the array is modified outside the setter, in line 5. Because the getter method returns the reference of the internal variable scores directly, the outside code can obtain this reference and make a change to the internal object.\n\nA workaround for this case is that, instead of returning the reference directly in the getter, we should return a copy of the object. This is so that the outside code can obtain only a copy, not the internal object. Therefore, we modify the above getter as follows:\n\nSo the rule of thumb is: Do not return a reference of the original object in the getter method. Instead, it should return a copy of the original object.\n\nWith primitive types ( , , , , …), you can freely assign/return values directly in setter/getter because Java copies the value of one primitive to another instead of copying the object reference. So, mistakes #2 and #3 can easily be avoided.\n\nFor example, the following code is safe because the setter and getter are involved in a primitive type of :\n\nSo, for primitive types, there is no special trick to correctly implement the getter and setter.\n\nString is an object type, but it is immutable, which means once a String object is created, its String literal cannot be changed. In other words, every change on that String object will result in a newly created String object. So, like primitive types, you can safely implement getter and setter for a String variable, like this:\n\nThe class implements the method from the class. The method returns a copy of the object, so we can use it for the getter and setter, as shown in the following example:\n\nThe method returns an , so we must cast it to the type.You can learn more about this in item 39 of Effective Java by Joshua Bloch:\n\nAs described in mistakes #2 and #3, it’s not good to have setter and getter methods like this:\n\nConsider the following program:\n\nAccording to the rules for implementing getter and setter, the three statements should produce the same result. However, when running the above program, it produces the following output:\n\nFor a collection of Strings, one solution is to use the constructor that takes another collection as an argument. For example, we can change the code of the above getter and setter as follows:\n\nRe-compile and run the program; it will produce the desired output:\n\nNOTE: The constructor approach above is only working with Collections of Strings, but it will not work for Collections objects. Consider the following example for a Collection of the object:\n\nIt produces the following output when running:\n\nBecause unlike String, for which new objects will be created whenever a String object is copied, other types are not. Only references are copied, so that’s why two Collections are distinct but they contain the same objects. In other words, it is because we haven’t provided any means for copying objects.\n\nLook at the Collection API; we found that , , , etc. implement their own methods. These methods return shallow copies, which do not copy elements from the source Collection to the destination. According to the Javadoc of the method of the class:\n\nThus, we cannot use the method of these Collection classes. The solution is to implement the method for our own defined object — the class in the above example. We implement the method in the class as shown below:\n\nThe setter for is modified as follows:\n\nThe corresponding getter is modified, as shown below:\n\nThat results in a new version of the class shown below:\n\nCompile and run the new version of ; it will produce the desired output:\n\nSo, the key points for implementing getter and setter for a Collection type are:\n• For a Collection of String objects, it does not need any special tweak since String objects are immutable.\n• For a Collection of custom types of an object:\n• Implement the method for the custom type.\n• For the setter, add cloned items from the source Collection to the destination one.\n• For the getter, create a new Collection, which is being returned. Add cloned items from the original Collection to the new one.\n\n8. Implementing Getters and Setters for Your Own Type\n\nIf you define a custom type of object, you should implement the method for your own type. For example:\n\nAs we can see, the class implements its method to return a cloned version of itself. Then, the setter method should be implemented like below:\n\nAnd for the getter method:\n\nSo, the rules for implementing getter and setter for a custom object type are:\n\nJava getter and setter seems to be simple, yet it can be dangerous if implemented naively. It could even be a source of problems that cause your code to misbehave. Or worse, one could easily exploit your programs by insidiously manipulating the arguments to, and returned objects from, your getters and setters. So, be careful and consider implementing the best practices mentioned above.\n\nWhy Should I Write Getters and Setters?\n\nGetter/Setter: The Most Hated Practice in Java"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/q5bu99/in_java_why_is_it_considered_good_practice_to_use",
        "document": "In Java why is it considered good practice to use getters in setters?\n\nWhat is wrong with making instance members public and using them directly instead of defining a bunch of redundant methods?\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    },
    {
        "link": "https://akadar899.medium.com/getters-and-setters-in-java-a27b39b0bb23",
        "document": "Getters and setters are an essential part of Java programming, particularly in object-oriented programming (OOP). They provide a way to access and modify the private fields of a class, ensuring encapsulation and maintaining data integrity. In this article explains what getters and setters are and how they’re used in Java development.\n\nIn Java, getters and setters are methods that allow indirect access to private fields or instance variables of a class. The getter method retrieves the current value of a field, while the setter method sets or updates the value of a field. By encapsulating the fields and providing controlled access, getters and setters help maintain the principle of information hiding and protect the integrity of the class.\n\nWhy Use Getters and Setters?\n\nThe primary benefit of using getters and setters is encapsulation. By making the fields of a class private and providing access through methods, we can control how the fields are accessed and modified. This prevents direct access to the fields from outside the class and ensures that any changes go through the appropriate methods, allowing us to enforce validation rules, perform additional logic, or update related fields as needed.\n\nUsing getters and setters offers flexibility in terms of modifying the internal implementation of a class without affecting the external code that uses the class. If the internal representation of a field changes, we only need to update the getter and setter methods, keeping the rest of the code unaffected. This improves maintainability and minimizes the risk of introducing bugs during modifications.\n\nGetters and setters provide an opportunity to add data validation and implement business logic. For example, we can add checks to ensure that the assigned value is within a specific range or meets certain criteria. We can also trigger additional actions or calculations when a value is modified, helping to maintain consistency and integrity in the application.\n\nIn this example, the setAge method checks whether the provided age is within a valid range (between 0 and 40). If the age is valid, it sets the age attribute; otherwise, it throws an IllegalArgumentException to indicate that the input is invalid.\n\nBest Practices for Using Getters and Setters\n\nUse Meaningful Names: Choose descriptive names for getter and setter methods.\n\nKeep It Simple: Avoid complex logic within getters and setters.\n\nConsistency: Maintain a consistent naming convention.\n\nValidation: Implement input validation in setters when necessary.\n\nDocumentation: Document the purpose of getters and setters.\n\nExcessive Logic: Avoid adding extensive logic in getters and setters.\n\nInconsistent Naming: Stick to a consistent naming convention.\n\nOverusing Getters/Setters: Not all variables need getters and setters.\n\nNeglecting Validation: Skip input validation in setters.\n\nExplore how Project Lombok simplifies the process of generating getters and setters.\n\nUsing Getters and Setters in Real-World Applications\n\nSee practical examples of how getters and setters enhance code maintainability and security in real-world applications.\n\nWhen submitting the form, all the variables are assigned to their respective fields, setting the values using setters. Later, to retrieve the registration information, you use getters to access the stored values.\n\nIn conclusion, getters and setters are a fundamental aspect of Java programming that promotes data encapsulation, security, and maintainability. When used wisely and following best practices, they contribute to the creation of clean and robust code.\n\nWhat is the primary purpose of using getters and setters in Java?\n\nGetters and setters in Java are primarily used to control access to the private fields of a class, ensuring data security and flexibility in data management.\n\nCan getters and setters have different access modifiers from the associated variable?\n\nYes, getters and setters can have different access modifiers from the associated variable. For example, you can have a private variable with public getter and setter methods.\n\nWhen should I use direct variable access instead of getters and setters?\n\nDirect variable access is suitable when you don’t need additional logic or validation when accessing or modifying a variable. Use getters and setters when you require control over data access.\n\nIs it necessary to implement both getters and setters for every class variable?\n\nNo, it’s not necessary to implement both getters and setters for every class variable. Implement them based on your specific requirements. Some variables may only require one or the other.\n\nWhat is Project Lombok, and how does it simplify the use of getters and setters in Java?\n\nProject Lombok is a library that simplifies Java code by automatically generating getters, setters, and other common methods. It reduces boilerplate code and enhances code readability."
    },
    {
        "link": "https://stackoverflow.com/questions/39940624/best-practices-for-implementing-setters-getters-in-subclasses",
        "document": "Overriding methods to only call their super version is what you get by default without overriding!\n\nresults absolutely the same as behavior as ... not overriding that method at all.\n\nSo, to the contrary: you should consider making those getters and setters final to prevent subclasses from overriding them! And for the record: when overriding methods, you always want to put the @Override annotation on those methods (so the compiler can tell you when you only think you are overriding a method)."
    }
]