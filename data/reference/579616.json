[
    {
        "link": "https://dioo.com/admin/api/upload/img/1703143356438.pdf",
        "document": ""
    },
    {
        "link": "https://dioo.com/diooAdmin/api/upload/img/1666095762983.pdf",
        "document": ""
    },
    {
        "link": "https://mouser.com/datasheet/2/802/dimi_s_a0009242516_1-2295248.pdf?srsltid=AfmBOooyvih_hkkL5YYf_gU3CrLyPkKO1U8dW0KosHYVMjCW10NHznSo",
        "document": ""
    },
    {
        "link": "https://static.chipdip.ru/lib/433/DOC016433084.pdf",
        "document": ""
    },
    {
        "link": "https://mouser.com/datasheet/2/802/1703143356438-3483895.pdf?srsltid=AfmBOooaNnV0SvakhLNYT1xm4j9pXgcWR_parhDh4_FvQR_dVPibpvnV",
        "document": ""
    },
    {
        "link": "https://analog.com/en/resources/analog-dialogue/articles/introduction-to-spi-interface.html",
        "document": ""
    },
    {
        "link": "https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all",
        "document": "Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Stuff that would be helpful to know before reading this tutorial: Binary is the numeral system of electronics and programming...so it must be important to learn. But, what is binary? How does it translate to other numeral systems like decimal? An introduction to shift registers and potential uses. Learn the difference between 3.3V and 5V devices and logic levels.\n\nA common serial port, the kind with TX and RX lines, is called \"asynchronous\" (not synchronous) because there is no control over when data is sent or any guarantee that both sides are running at precisely the same rate. Since computers normally rely on everything being synchronized to a single “clock” (the main crystal attached to a computer that drives everything), this can be a problem when two systems with slightly different clocks try to communicate with each other. To work around this problem, asynchronous serial connections add extra start and stop bits to each byte help the receiver sync up to data as it arrives. Both sides must also agree on the transmission speed (such as 9600 bits per second) in advance. Slight differences in the transmission rate aren't a problem because the receiver re-syncs at the start of each byte. Asynchronous serial works just fine, but has a lot of overhead in both the extra start and stop bits sent with every byte, and the complex hardware required to send and receive data. And as you've probably noticed in your own projects, if both sides aren't set to the same speed, the received data will be garbage. This is because the receiver is sampling the bits at very specific times (the arrows in the above diagram). If the receiver is looking at the wrong times, it will see the wrong bits.\n\nSPI works in a slightly different manner. It's a \"synchronous\" data bus, which means that it uses separate lines for data and a \"clock\" that keeps both sides in perfect sync. The clock is an oscillating signal that tells the receiver exactly when to sample the bits on the data line. This could be the rising (low to high) or falling (high to low) edge of the clock signal; the datasheet will specify which one to use. When the receiver detects that edge, it will immediately look at the data line to read the next bit (see the arrows in the below diagram). Because the clock is sent along with the data, specifying the speed isn't important, although devices will have a top speed at which they can operate (We'll discuss choosing the proper clock edge and speed in a bit). One reason that SPI is so popular is that the receiving hardware can be a simple shift register. This is a much simpler (and cheaper!) piece of hardware than the full-up UART (Universal Asynchronous Receiver / Transmitter) that asynchronous serial requires.\n\nNote: You may not recognize the PICO/POCI labels for SPI pins. SparkFun has joined with other members of OSHWA in a resolution to move away from using \"Master\" and \"Slave\" to describe signals between the controller and the peripheral. Check out \n\n\n\n The naming convention may vary depending on manufacturer, programming language, companies, or organizations. For more information, check out the following links. \n\n \n\n You may not recognize the PICO/POCI labels for SPI pins. SparkFun has joined with other members of OSHWA in a resolution to move away from using \"Master\" and \"Slave\" to describe signals between the controller and the peripheral. Check out this page for more on our reasoning behind this change. The terms are considered obsolete and are now replaced with the terms \"controller\" and \"peripheral,\" respectively.The naming convention may vary depending on manufacturer, programming language, companies, or organizations. For more information, check out the following links. You might be thinking to yourself, self, that sounds great for one-way communications, but how do you send data back in the opposite direction? Here's where things get slightly more complicated. In SPI, only one side generates the clock signal (usually called CLK or SCK for Serial ClocK). The side that generates the clock is called the \"controller\", and the other side is called the \"peripheral\". There is always only one controller (which is almost always your microcontroller), but there can be multiple peripherals (more on this in a bit). When data is sent from the controller to a peripheral, it's sent on a data line called PICO, for \"Peripheral In / Controller Out\". If the peripheral needs to send a response back to the controller, the controller will continue to generate a prearranged number of clock cycles, and the peripheral will put the data onto a third data line called POCI, for \"Peripheral Out / Controller In\". Notice we said \"prearranged\" in the above description. Because the controller always generates the clock signal, it must know in advance when a peripheral needs to return data and how much data will be returned. This is very different than asynchronous serial, where random amounts of data can be sent in either direction at any time. In practice this isn't a problem, as SPI is generally used to talk to sensors that have a very specific command structure. For example, if you send the command for \"read data\" to a device, you know that the device will always send you, for example, two bytes in return. (In cases where you might want to return a variable amount of data, you could always return one or two bytes specifying the length of the data and then have the controller retrieve the full amount.) Note that SPI is \"full duplex\" (has separate send and receive lines), and, thus, in certain situations, you can transmit and receive data at the same time (for example, requesting a new sensor reading while retrieving the data from the previous one). Your device's datasheet will tell you if this is possible.\n\nThere's one last line you should be aware of, called CS for Chip Select. This tells the peripheral that it should wake up and receive / send data and is also used when multiple peripherals are present to select the one you'd like to talk to. The CS line is normally held high, which disconnects the peripheral from the SPI bus. (This type of logic is known as “active low,” and you’ll often see used it for enable and reset lines.) Just before data is sent to the peripheral, the line is brought low, which activates the peripheral. When you're done using the peripheral, the line is made high again. In a shift register, this corresponds to the \"latch\" input, which transfers the received data to the output lines. There are two ways of connecting multiple peripherals to an SPI bus:\n• In general, each peripheral will need a separate CS line. To talk to a particular peripheral, you'll make that peripheral's CS line low and keep the rest of them high (you don't want two peripherals activated at the same time, or they may both try to talk on the same POCI line resulting in garbled data). Lots of peripherals will require lots of CS lines; if you're running low on outputs, there are binary decoder chips that can multiply your CS outputs.\n• On the other hand, some parts prefer to be daisy-chained together, with the POCI (output) of one going to the PICO (input) of the next. In this case, a single CS line goes to all the peripherals. Once all the data is sent, the CS line is raised, which causes all the chips to be activated simultaneously. This is often used for daisy-chained shift registers and addressable LED drivers. Note that, for this layout, data overflows from one peripheral to the next, so to send data to any one peripheral, you'll need to transmit enough data to reach all of them. Also, keep in mind that the first piece of data you transmit will end up in the last peripheral. This type of layout is typically used in output-only situations, such as driving LEDs where you don't need to receive any data back. In these cases you can leave the controller's POCI line disconnected. However, if data does need to be returned to the controller, you can do this by closing the daisy-chain loop (blue wire in the above diagram). Note that if you do this, the return data from peripheral 1 will need to pass through all the peripherals before getting back to the controller, so be sure to send enough receive commands to get the data you need.\n\nMany microcontrollers have built-in SPI peripherals that handle all the details of sending and receiving data, and can do so at very high speeds. The SPI protocol is also simple enough that you (yes, you!) can write your own routines to manipulate the I/O lines in the proper sequence to transfer data. (A good example is on the Wikipedia SPI page.) If you're using an Arduino, there are two ways you can communicate with SPI devices:\n• None You can use the shiftIn() and shiftOut() commands. These are software-based commands that will work on any group of pins, but will be somewhat slow.\n• None Or you can use the SPI Library, which takes advantage of the SPI hardware built into the microcontroller. This is vastly faster than the above commands, but it will only work on certain pins. You will need to select some options when setting up your interface. These options must match those of the device you're talking to; check the device's datasheet to see what it requires.\n• None The interface can send data with the most-significant bit (MSB) first, or least-significant bit (LSB) first. In the Arduino SPI library, this is controlled by the setBitOrder() function.\n• None The peripheral will read the data on either the rising edge or the falling edge of the clock pulse. Additionally, the clock can be considered \"idle\" when it is high or low. In the Arduino SPI library, both of these options are controlled by the setDataMode() function.\n• None SPI can operate at extremely high speeds (millions of bytes per second), which may be too fast for some devices. To accommodate such devices, you can adjust the data rate. In the Arduino SPI library, the speed is set by the setClockDivider() function, which divides the controller clock (16MHz on most Arduinos) down to a frequency between 8MHz (/2) and 125kHz (/128).\n• None If you're using the SPI Library, you must use the provided SCK, PICO, and POCI pins, as the hardware is hardwired to those pins. There is also a dedicated CS pin that you can use (which must, at least, be set to an output in order for the SPI hardware to function), but note that you can use any other available output pin(s) for CS to your peripheral device(s) as well.\n• None On older Arduinos, you'll need to control the CS pin(s) yourself, making one of them low before your data transfer and high afterward. Newer Arduinos such as the Due can control each CS pin automatically as part of the data transfer; see the Due SPI documentation page for more information. See our Engineering Essentials page for a full list of cornerstone topics surrounding electrical engineering."
    },
    {
        "link": "https://ww1.microchip.com/downloads/en/devicedoc/spi.pdf",
        "document": ""
    },
    {
        "link": "https://gettobyte.com/spi-communication-in-microcontrollers?srsltid=AfmBOoqIqBHslpkbQA62aDiAHFQUOuUoK54FZXxw0mcIoyW5uZFAkQ18",
        "document": "Today in this series, we’ll learn how SPI communication takes place in the microcontroller. For those who want to learn about SPI communication on bit-level data transmission, they can redirect to this BLOG. SPI is a common peripheral in almost every MCU, and its versatility makes it a go-to choice for many applications.\n\nIn the above-mentioned example session of SPI communication, the first thing we can see is an idle clock state before the Data Transmission began from the Master Side via MOSI. This means CPOL(Clock Polarity) = 0. We can also observe first bit is sampled at the first of the Clock, meaning the CPHA(Clock Phase) = 0 through which we can conclude the that taken example is running SPI communication in MODE 0. One more important thing to observe is that will complete data is communicated the CS pin is low, which denotes that this helps us detect a complete session of SPI communication as well as helps in choosing different slaves by pulling different CS of different slaves. We can also additionally observe how the first master transmitted 1 byte of data “0x9F” in response to which the slave responded with 3-byte of data “0xEE, 0x00 and 0x30”.\n\nSPI (Serial Peripheral Interface) is a flexible protocol with variations in its wiring setup. Let’s get into the 3-wire and 4-wire configurations to understand how they work and differ.\n• None\n• MOSI (Master Out, Slave In): Transmits data from the master to the slave.\n• MISO (Master In, Slave Out): Sends data from the slave to the master.\n• None\n• The master generates the clock (SCK) and sends/receives data on MOSI and MISO, respectively.\n• The CS/SS pin ensures only one slave communicates at a time in a multi-slave setup.\n• Communication is full-duplex (data sent and received simultaneously). –> Use Case: 4-wire SPI is widely used for devices requiring fast and reliable data transfer, such as memory chips, sensors, and displays.\n• None\n• SDA (Single Data Line): Combines data transmission and reception on one shared line.\n• None\n• The SDA line acts as a bidirectional data line, toggling between input (MISO) and output (MOSI) modes.\n• The master controls when the line switches from transmitting to receiving.\n• Communication is half-duplex (data sent and received alternately, not simultaneously). –> Use Case: 3-wire SPI is used in applications where fewer GPIO pins are available, such as compact or low-power devices.\n\n–> SPI communication can be implemented using different methods to handle data transmission and reception: Polling, Interrupts, and DMA (Direct Memory Access). Let’s break these down quickly and simply. –> In polling, the CPU constantly checks the SPI status register to see if the transmission or reception is complete.\n• None\n• The master initiates SPI communication and waits (polls) until the SPI status register indicates the operation is done.\n• Once ready, it reads or writes the data. –> Example Use Case: Small, simple applications where data transfer is occasional or time-critical (e.g., reading sensor data once per second). –> In interrupt-driven SPI, the CPU can perform other tasks while waiting for SPI events. When the transfer is complete, an interrupt is triggered to notify the CPU.\n• None\n• The SPI peripheral triggers an interrupt upon completion.\n• The CPU handles the interrupt and processes the data. –> Example Use Case: Applications needing multitasking, like managing multiple sensors or peripherals concurrently. –> With DMA, the CPU is almost entirely freed from handling data transfer. The DMA controller moves data directly between memory and the SPI peripheral without CPU intervention.\n• None\n• The CPU configures the DMA controller and starts the transfer.\n• The CPU receives a notification (via interrupt) when the transfer is complete.\n• None\n• Only available in systems with DMA support. –> Example Use Case: High-speed communication, such as transferring data to/from an SD card or LCD.\n\n–> The Chip Select (CS) pin in SPI communication determines which slave device is chosen to have communication. Different microcontrollers offer varying ways to handle the CS pin: some integrate it directly within the SPI module, while others allow it to be configured separately. Let’s explore both approaches. –> With module-managed CS, the SPI peripheral hardware takes full control of the CS pin, automatically toggling it during data transfers. This simplifies implementation, reduces timing errors, and ensures precise synchronization with the SPI clock and data signals. However, it often limits flexibility, as you must use the designated CS pin associated with the SPI module, and multi-slave configurations can be challenging. –> Manually configured CS pins offer greater flexibility by allowing any GPIO pin to serve as the CS. In this approach, the firmware controls the CS pin manually by driving it low to activate or high to deactivate, enabling custom multi-slave setups. While this approach supports more complex configurations, it requires additional coding effort and careful handling of timing to avoid errors. –> Conclusion: The choice between the two depends on the application: module-managed CS is ideal for simpler systems with fewer slaves, whereas manually configured CS is better suited for complex setups requiring multiple slaves or custom configurations."
    },
    {
        "link": "https://corelis.com/education/tutorials/spi-tutorial",
        "document": "If CPOL and CPHA are both ‘0’ (defined as Mode 0) data is sampled at the leading rising edge of the clock. Mode 0 is by far the most common mode for SPI bus slave communication. If CPOL is ‘1’ and CPHA is ‘0’ (Mode 2), data is sampled at the leading falling edge of the clock. Likewise, CPOL = ‘0’ and CPHA = ‘1’ (Mode 1) results in data sampled at on the trailing falling edge and CPOL = ‘1’ with CPHA = ‘1’ (Mode 3) results in data sampled on the trailing rising edge. Table 1 below summarizes the available modes.\n\nIn addition to the standard 4-wire configuration, the SPI interface has been extended to include a variety of IO standards including 3-wire for reduced pin count and dual or quad I/O for higher throughput. In 3-wire mode, MOSI and MISO lines are combined to a single bidirectional data line as shown in Figure 3. Transactions are half-duplex to allow for bidirectional communication. Reducing the number of data lines and operating in half-duplex mode also decreases maximum possible throughput; many 3-wire devices have low performance requirements and are instead designed with low pin count in mind.\n\nMulti I/O variants such as dual I/O and quad I/O add additional data lines to the standard for increased throughput. Components that utilize multi I/O modes can rival the read speed of parallel devices while still offering reduced pin counts. This performance increase enables random access and direct program execution from flash memory (execute-in-place). Quad I/O devices can, for example, offer up to 4 times the performance of a standard 4-wire SPI interface when communicating with a high speed device. Figure 4 shows an example of a single quad IO slave configuration.\n\nThe BusPro-S includes automatic slave select (SS) signal handling—once a slave select signal has been selected with the “SS” command or defined in the application interface, the software will assert that slave select signal at the beginning of each command and de-assert the signal to complete the transaction. In this tutorial, we will always explicitly specify the slave select state with “SSON” and “SSOFF” commands. In practical use, this is only required for grouping multiple commands into a single continuous transaction.\n\nMost SPI flash memories have a write status register command that writes one or two bytes of data, as shown in Figure 6. To write to the status register, the SPI host first enables the slave select line for the current device. The master then outputs the appropriate instruction followed by two data bytes that define the intended status register contents. Since the transaction does not need to return any data, the slave device keeps the MISO line in a high impedance state and the master masks any incoming data. Finally, slave select is de-asserted to complete the transaction.\n\nUsing the Corelis SPI Exerciser command language, this transaction can be accomplished with the following code, where Data Byte 2 is “55” and Data Byte 1 is “AA”. For brevity we are using the short version of commands; the command script language supports both full commands such as “write, read” as well as abbreviated versions “wt, rd”. For example, the code for a write transaction below activates slave select, performs a write operation, then deactivates slave select:\n\nA status register read transaction would be similar to the write transaction, but now takes advantage of data returned from the slave as shown in Figure 7. After sending the read status register instruction, the slave begins transmitting data on the MISO line at a rate of one byte per eight clock cycles. The host receives the bitstream and completes the transaction by de-asserting SS#.\n\nQuad IO is gaining popularity with flash memories for its increased performance. Instead of using a single output and single input interface, Quad IO utilizes 4 separate half-duplex data lines for both transmitting and receiving data for up to four times the performance of standard 4-wire SPI. Figure 8 shows an example read command for a Spansion S25FL016K serial NOR flash device. To read from the device, a fast read command (EBh) is first sent by the master on the first IO line while all others are tristated. Next, the host sends the address; since the interface now has 4 bidirectional data lines, it can utilize these to send a complete 24-bit address along with 8 mode bits in just 8 clock cycles. The address is then followed with 2 dummy bytes (4 clock cycles) to allow the device additional time to set up the initial address.\n\nAfter the address cycle and dummy bytes have been sent by the host, the component begins sending data bytes; each clock cycle consists of a data nibble spread across the 4 IO lines, for a total of two clock cycles per byte of data. Compare this to the 16 clock cycles required for our simple read transaction and it’s easy to see why quad mode is gaining popularity for high speed flash memory applications! To create this sequence in the SPI Exerciser command language, we would use the example code:\n\nsson // Activate slave select wt 01 55 AA // Write instruction 01h and data bytes 55h, AAh ssoff // Deactivate slave selectsson // Activate slave select wt 05 // Write instruction 05h rd 2 // Read two data bytes ssoff // Deactivate slave select4m // Start in 4-wire mode sson // Activate slave select wt EB // Write instruction EBh qm // Switch to quad mode wt AA AA AA 00 // Write 3-byte address and 8 read mode bits wt 55 55 // Write 2 dummy bytes rd 2 // Read two data bytes ssoff // Deactivate slave select"
    }
]