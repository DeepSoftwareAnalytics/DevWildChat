[
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://pypi.org/project/requests",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://requests.readthedocs.io/en/master/user/quickstart",
        "document": "Eager to get started? This page gives a good introduction in how to get started with Requests.\n\nFirst, make sure that:\n\nLet’s get started with some simple examples.\n\nMaking a request with Requests is very simple. Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline: Now, we have a object called . We can get all the information we need from this object. Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request: Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple: That’s all well and good, but it’s also only the start of what Requests can do.\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a dictionary of strings, using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL: Note that any dictionary key whose value is will not be added to the URL’s query string. You can also pass a list of items as a value:\n\nWe can read the content of the server’s response. Consider the GitHub timeline again: Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access . You can find out what encoding Requests is using, and change it, using the property: If you change the encoding, Requests will use the new value of whenever you call . You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTML and XML have the ability to specify their encoding in their body. In situations like this, you should use to find the encoding, and then set . This will let you use with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the module, you can simply use the codec name as the value of and Requests will handle the decoding for you.\n\nThere’s also a builtin JSON decoder, in case you’re dealing with JSON data: In case the JSON decoding fails, raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting raises . This wrapper exception provides interoperability for multiple exceptions that may be thrown by different python versions and json serialization libraries. It should be noted that the success of the call to does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use or check is what you expect.\n\nIn the rare case that you’d like to get the raw socket response from the server, you can access . If you want to do this, make sure you set in your initial request. Once you do, you can do this: In general, however, you should use a pattern like this to save what is being streamed to a file: Using will handle a lot of what you would otherwise have to handle when using directly. When streaming a download, the above is the preferred and recommended way to retrieve the content. Note that can be freely adjusted to a number that may better fit your use cases. An important note about using versus . will automatically decode the and transfer-encodings. is a raw stream of bytes – it does not transform the response content. If you really need access to the bytes as they were returned, use .\n\nIf you’d like to add HTTP headers to a request, simply pass in a to the parameter. For example, we didn’t specify our user-agent in the previous example: Note: Custom headers are given less precedence than more specific sources of information. For instance:\n• None Authorization headers set with will be overridden if credentials are specified in , which in turn will be overridden by the parameter. Requests will search for the netrc file at , , or at the path specified by the environment variable.\n• None Authorization headers will be removed if you get redirected off-host.\n• None Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n• None Content-Length headers will be overridden when we can determine the length of the content. Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request. Note: All header values must be a , bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values.\n\nTypically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the argument. Your dictionary of data will automatically be form-encoded when the request is made: The argument can also have multiple values for each key. This can be done by making either a list of tuples or a dictionary with lists as values. This is particularly useful when the form has multiple elements that use the same key: There are times that you may want to send data that is not form-encoded. If you pass in a instead of a , that data will be posted directly. For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data: Please note that the above code will NOT add the header (so in particular it will NOT set it to ). If you need that header set and you don’t want to encode the yourself, you can also pass it directly using the parameter (added in version 2.4.2) and it will be encoded automatically: Note, the parameter is ignored if either or is passed.\n\nYou can set the filename, content_type and headers explicitly: If you want, you can send strings to be received as files: In the event you are posting a very large file as a request, you may want to stream the request. By default, does not support this, but there is a separate package which does - . You should read the toolbelt’s documentation for more details about how to use it. For sending multiple files in one request refer to the advanced section. It is strongly recommended that you open files in binary mode. This is because Requests may attempt to provide the header for you, and if it does this value will be set to the number of bytes in the file. Errors may occur if you open the file in text mode.\n\nWe can view the server’s response headers using a Python dictionary: The dictionary is special, though: it’s made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive. So, we can access the headers using any capitalization we want: It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.\n\nYou can tell Requests to stop waiting for a response after a given number of seconds with the parameter. Nearly all production code should use this parameter in nearly all requests. Failure to do so can cause your program to hang indefinitely: is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for seconds (more precisely, if no bytes have been received on the underlying socket for seconds). If no timeout is specified explicitly, requests do not time out.\n\nIn the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a exception. will raise an if the HTTP request returned an unsuccessful status code. If a request times out, a exception is raised. If a request exceeds the configured number of maximum redirections, a exception is raised. All exceptions that Requests explicitly raises inherit from . Ready for more? Check out the advanced section."
    },
    {
        "link": "https://docs.python-requests.org/en/v2.0.0",
        "document": ""
    },
    {
        "link": "https://docs.python.org",
        "document": "What's new in Python 3.13?\n\n Or all \"What's new\" documents since Python 2.0\n\nTutorial\n\n Start here: a tour of Python's syntax and features\n\nPython setup and usage\n\n How to install, configure, and use Python"
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-python-colorama",
        "document": "In Python, when it comes to terminal output, the default experience can be somewhat monotonous—text is usually displayed in a single color, which can make it challenging to distinguish between different types of output. This is where Colorama comes into play.\n\nColorama is a Python library that simplifies the process of adding colored text and styling to terminal output. It’s particularly useful when we want to make our console applications more visually appealing or when we need to highlight certain parts of our output for better readability.\n\nIn this article, we will explore the basics of Colorama, how to install it, and how to use it to enhance your terminal output. We will cover:\n\nColorama is a Python module that simplifies the process of adding color to text in the terminal. It allows you to style your outputs with colors, bold text, and more. It's cross-platform, meaning it works seamlessly on Windows, macOS, and Linux. The module handles the complexities of making sure colors work correctly on different operating systems, allowing us to focus on creating colorful outputs.\n• Cross-Platform Compatibility: Works seamlessly on Windows, macOS, and Linux, ensuring consistent color output across different operating systems.\n• Simple API: Provides a straightforward and intuitive API for applying text colors, background colors, and text styles (like bold or underline).\n• Automatic Reset: Automatically resets the terminal color settings after printing, preventing unintended color changes in subsequent output.\n• Wide Range of Colors: Supports a variety of colors and styles, giving developers flexibility in designing their terminal interfaces.\n• Enhanced CLI Applications: Add color to terminal outputs to improve readability and user interaction in command-line tools.\n• Error Highlighting: Highlight errors or warnings in red to make them stand out from regular output.\n• Progress Indicators: Use colors to indicate progress or status, such as green for success and yellow for warnings.\n• Themed Outputs: Create themed outputs by applying consistent color schemes to different parts of the output, making the CLI more visually appealing.\n\nThe library is not included in the standard Python library and needs to be installed separately by using the following command in our command prompt or terminal window.\n\nOnce installed, we can import it into our Python script:\n\nBefore we start using colorama, it’s good practice to initialize it to ensure compatibility across different platforms:\n\nNow let us see a few different examples for a better understanding of how the Colorama Module works in Python.\n\nThe primary feature of Colorama is the ability to change the color of the text displayed in the terminal. Here are simple examples:\n\nExample 1 - In this example:\n• None changes the text color to red.\n• None changes the text color to green.\n\nWe can chain multiple colors and styles together to create more complex outputs.\n\nExample 2 - In this example:\n• Fore.RED means that the text will be red in color.\n• Back.GREEN means the text will have a green background.\n• Style.BRIGHT means that the text will have a bold effect.\n• RESET_ALL resets all the styling back to normal.\n\nColorama provides options to change both the foreground (text) and background colors. The available colors are:\n\nHere’s how we can set foreground and background colors and styles\n\nIn this example:\n\nColorama also supports various text styles, such as making the text bold, dim, or normal. The available styles are:\n\nAfter applying a style, it's a good practice to reset the styles using Style.RESET_ALL. This ensures that any subsequent text is displayed normally, without unintended color or styling.\n\nColorama can be combined with other Python libraries to create more sophisticated applications. Here are a few advanced use cases:\n\nThis code creates a simple progress bar that updates in the terminal, with the progress percentage displayed in bright cyan.\n\nColorama is a powerful and easy-to-use library that can greatly enhance the aesthetics and readability of terminal output in Python applications. By enabling colored text and styled output, you can make your terminal-based programs more engaging and user-friendly. Whether we're creating a simple script or a more complex application, Colorama provides the tools we need to add a touch of color to our console output.\n\nBy integrating Colorama into our projects, we not only improve the user experience but also make debugging and information parsing much easier. With its cross-platform support and straightforward API, Colorama is an essential library for any Python developer looking to spice up their terminal output."
    },
    {
        "link": "https://geeksforgeeks.org/print-colors-python-terminal",
        "document": "In this article, we will cover how to print colored text in Python using several methods to output colored text to the terminal in Python.\n\nThe most common ways to do this are using:\n\nColorama module is a Cross-platform printing of colored text can then be done using Colorama’s constant shorthand for ANSI escape sequences:\n\nExample 1: Python program to print red text with green background.\n\nExample 2: Python program to print green text with red background.\n\ntermcolor module is a python module for ANSII Color formatting for output in the terminal.\n\nExample: Python program to print colored text and background.\n\nThe most common way to print colored text is by printing ANSI escape sequences directly. This can be delivered in different formats such as:\n\nWe can build functions to call particular color named functions to execute the relevant ANSI Escape Sequence. The below is Python program to print colored text and background\n\nCreate a class to allot background and foreground colors and call them. The below is Python program to print colored text and background.\n\nWe can design iterating & self-generating ANSI Escape sequence, functions. The below is Python program to print colored text and background"
    },
    {
        "link": "https://codu.co/articles/adding-colour-to-python-code-lbai_0u7",
        "document": "On a recent project I was required to build a small program using Python only. I really enjoyed getting to focus on logic and solving problems, but I did miss the frontend design. In my program I needed to give feedback to the user when their text input was submitted and validated. Printing a message to the terminal was sufficient but I wondered whether I could take it further. Through a quick Google, I came across Colorama.\n\nColorama is a built-in Python module which displays text in different styles and colours. It offers three formatting options of: Back, Fore and Style, which can change the colour of the text itself, the background of the text and the thickness of the text.\n\nColorama gives an option of 8 colours - Black, Red, Green, Blue, Yellow, Magenta, Cyan and White. For providing user feedback, highlighting information or just brightening the code output up, these colours get the jobs done.\n\nHow do I use it?\n\nIn your command terminal, install Colorama using:\n\nTo ensure that Colorama allows a reset after each line of use it is important to set it's autoreset to True with this code:\n\nColorama should be ready to go! I did import the library to the top of my Python file by adding:\n\nThis allowed me to access the commands within my Python file by adding my requests after the opening bracket of my or statements.\n\nTo colour text only my code was as follows:\n\nTo adjust the thickness of the text try:\n\nAnd that's it! It's up to you how you wish to use it. I found that it cheered my Python program up to engage the user and offer guidance if an input error occurred or confirmation if their input had been recorded. It also made debugging a lot more enjoyable and easier on the eyes when I had other colours to see, rather than continuous white text on a black background. Have fun!"
    },
    {
        "link": "https://dev.to/visheshdvivedi/get-colored-console-output-in-python-using-colorama-4gci",
        "document": "In this blog I am gonna talk about a python module that can make your console based applications look much better than they normally look, the colorama module.\n\nHere's how a normal console application looks without using colorama.\n\nAnd here's how the same script would look with some color effects.\n\nAll of this was possible due to colorama module. And we are gonna learn how we can use this module in python.\n\nColorama is a python module that is used to display colored output in console. It can change both, foreground and background color of any text which is displayed in the console.\n\nThe link to its github repository is this:\n\n colorama.\n\nFirst you need to download and install colorama. Just open your command prompt and type the following:\n\nThis will automatically download and install colorama in your system.\n\nOnce your colorama is installed, you can import colorama in any of your python script and use it. Now let's learn how to use it within our scripts.\n\nFirst we have to initialize colorama by running the init method, like this:\n\nOn Windows, calling will filter ANSI escape sequences out of any text sent to or , and replace them with equivalent Win32 calls.\n\nOn other platforms, it's not of much use. So don't forget to call this function is your script runs on Windows.\n\nIt's time we write our first colored output on the screen, like this:\n\nThe output would look like this:\n\nAs you might understand, you can change the foreground letter color using the Fore class and selecting the correct color constant you want to use. You can change background color using Back class and change style of letters using Style class.\n\nHere are the possible foreground, background and style class.\n\nNote: The color effects that you will place will remain consistent, unless you call deinit() function or mention Fore.RESET, Back.RESET or Style.RESET_ALL.\n\nYou can also use termcolor (in Windows) to color a specific portion of the console output\n\njust import colored function from termcolor and use it as following:\n\nOverall this is a very awesome module and I bet you should definitely try using this module within your scripts, to give it a more professional look and feel.\n\nHope this blog helped you all :)\n\nYou can follow me on\n\n YouTube,\n\n Instagram,\n\n Linkedin."
    },
    {
        "link": "https://stackoverflow.com/questions/39473297/how-do-i-print-colored-output-with-python-3",
        "document": "I would like the output to be blue in the terminal. How can I accomplish this with Python3?\n\nIt is very simple with colorama, just do this: And here is the running result in Python3 REPL: And call this to reset the color settings: To avoid printing an empty line write this:\n\nPut these classes into Color.py file near your test.py file and run test.py. I've tested these classes on Ubuntu Server 16.04 and Linux Mint 18.2 . All classes worked very good except GColor (RGB), that, it is usable in graphical terminal like Linux Mint terminal. Also, you can use these classes like this: print(Formatting.Italic + ANSI_Compatible.Color(12) + \"This is a \" + Formatting.Bold + \"test\" + Formatting.Reset_Bold + \"!\" + ANSI_Compatible.END + Formatting.Reset) print(Color.B_DarkGray + Color.F_LightBlue + \"This is a \" + Formatting.Bold + \"test\" + Formatting.Reset_Bold + \"!\" + Base.END) Note: It's not working on Windows! class Base: # Foreground: HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' # Formatting BOLD = '\\033[1m' UNDERLINE = '\\033[4m' # End colored text END = '\\033[0m' NC ='\\x1b[0m' # No Color class ANSI_Compatible: END = '\\x1b[0m' # If Foreground is False that means color effect on Background def Color(ColorNo, Foreground=True): # 0 - 255 FB_G = 38 # Effect on foreground if Foreground != True: FB_G = 48 # Effect on background return '\\x1b[' + str(FB_G) + ';5;' + str(ColorNo) + 'm' class Formatting: Bold = \"\\x1b[1m\" Dim = \"\\x1b[2m\" Italic = \"\\x1b[3m\" Underlined = \"\\x1b[4m\" Blink = \"\\x1b[5m\" Reverse = \"\\x1b[7m\" Hidden = \"\\x1b[8m\" # Reset part Reset = \"\\x1b[0m\" Reset_Bold = \"\\x1b[21m\" Reset_Dim = \"\\x1b[22m\" Reset_Italic = \"\\x1b[23m\" Reset_Underlined = \"\\x1b[24\" Reset_Blink = \"\\x1b[25m\" Reset_Reverse = \"\\x1b[27m\" Reset_Hidden = \"\\x1b[28m\" class GColor: # Gnome supported END = \"\\x1b[0m\" # If Foreground is False that means color effect on Background def RGB(R, G, B, Foreground=True): # R: 0-255 , G: 0-255 , B: 0-255 FB_G = 38 # Effect on foreground if Foreground != True: FB_G = 48 # Effect on background return \"\\x1b[\" + str(FB_G) + \";2;\" + str(R) + \";\" + str(G) + \";\" + str(B) + \"m\" class Color: # Foreground F_Default = \"\\x1b[39m\" F_Black = \"\\x1b[30m\" F_Red = \"\\x1b[31m\" F_Green = \"\\x1b[32m\" F_Yellow = \"\\x1b[33m\" F_Blue = \"\\x1b[34m\" F_Magenta = \"\\x1b[35m\" F_Cyan = \"\\x1b[36m\" F_LightGray = \"\\x1b[37m\" F_DarkGray = \"\\x1b[90m\" F_LightRed = \"\\x1b[91m\" F_LightGreen = \"\\x1b[92m\" F_LightYellow = \"\\x1b[93m\" F_LightBlue = \"\\x1b[94m\" F_LightMagenta = \"\\x1b[95m\" F_LightCyan = \"\\x1b[96m\" F_White = \"\\x1b[97m\" # Background B_Default = \"\\x1b[49m\" B_Black = \"\\x1b[40m\" B_Red = \"\\x1b[41m\" B_Green = \"\\x1b[42m\" B_Yellow = \"\\x1b[43m\" B_Blue = \"\\x1b[44m\" B_Magenta = \"\\x1b[45m\" B_Cyan = \"\\x1b[46m\" B_LightGray = \"\\x1b[47m\" B_DarkGray = \"\\x1b[100m\" B_LightRed = \"\\x1b[101m\" B_LightGreen = \"\\x1b[102m\" B_LightYellow = \"\\x1b[103m\" B_LightBlue = \"\\x1b[104m\" B_LightMagenta = \"\\x1b[105m\" B_LightCyan = \"\\x1b[106m\" B_White = \"\\x1b[107m\" from Color import * if __name__ == '__main__': print(\"Base:\") print(Base.FAIL,\"This is a test!\", Base.END) print(\"ANSI_Compatible:\") print(ANSI_Compatible.Color(120),\"This is a test!\", ANSI_Compatible.END) print(\"Formatting:\") print(Formatting.Bold,\"This is a test!\", Formatting.Reset) print(\"GColor:\") # Gnome terminal supported print(GColor.RGB(204,100,145),\"This is a test!\", GColor.END) print(\"Color:\") print(Color.F_Cyan,\"This is a test!\",Color.F_Default)\n\nSince Python is interpreted and run in C, it is possible to set colors without a module. You can define a class for colors like this: When writing code, you can simply write: Note that the color you choose will have to be capitalized like your class definition, and that these are color choices that I personally find satisfying. For a fuller array of color choices and, indeed, background choices as well, please see: https://gist.github.com/RabaDabaDoba/145049536f815903c79944599c6f952a. This is code for C, but can easily be adapted to Python once you realize how the code is written. Take BLUE for example, since that is what you are wanting to display. \\033 tells Python to break and pay attention to the following formatting. 1 informs the code to be bold. (I prefer 1 to 0 because it pops more.) 34 is the actual color code. It chooses blue. 48m is the background color. 48m is the same shade as the console window, so it seems there is no background.\n\nI would like to show you about how to color code. There is also a game to it if you would like to play it down below. Copy and paste if you would like and make sure to have a good day everyone! Also, this is for Python 3, not 2. ( Game ) # The Color Game! # Thank you for playing this game. # Hope you enjoy and please do not copy it. Thank you! import colorama from colorama import Fore score = 0 def Check_Answer(answer): if (answer == \"no\"): print('correct') return True else: print('wrong') answer = input((Fore.RED + \"This is green.\")) if Check_Answer(answer) == True: score = score + 1 else: pass answer = input((Fore.BLACK + \"This is red.\")) if Check_Answer(answer) == True: score = score + 1 else: pass answer = input((Fore.BLUE + \"This is black.\")) if Check_Answer(answer) == True: score = score + 1 else: pass print('Your Score is ', score) Now for the color coding. It also comes with a list of colors YOU can try. # Here is how to color code in Python 3! # Some featured color codes are : RED, BLUE, GREEN, YELLOW, OR WHITE. I don't think purple or pink are not out yet. # Here is how to do it. (Example is down below!) import colorama from colorama import Fore print(Fore.RED + \"This is red..\")\n\nThe simplest, most direct answer appears to be something like: This answer is however difficult to suggest because:\n• it's written in alien code (what is ?? Not good enough for us humans)\n• it is locked to one color only, and, in practice, it is often useful to have a palete available on the spot to choose the color that feels right Installing something like or can be a way to go. However:\n• This approach does not apply to every person because there are many situations in which it is not practical to install a package from pypi. Approach 3 -- Just put it in a class Some of the answers here already suggest this approach. Basically, just dump the alien codes (e.g. , , , ...) into the attributes of a class and then build strings using the names of the class attributes. Example: This solves the problem and allows adding more alien codes for other colors if needed. In many projects, this approach is good and enough. However, in some projects, this approach doesn't work well. As we use the class over and over again, the whole process of writing string concatenations (using additions or equivalent approaches) becomes a bit problematic in terms of making your code less readable. Approach 4 -- Just put it in a metaclass A nice API could be something like this: from utils import Colors # `utils` is a fictional module where we would have our `Colors` class greeting = Colors.okblue('hello friends') print(greeting) # Or even shorter Colors.print_okblue('hello friends') In this example, the and are class methods that provide a shortcut through an automatic conversion of the method names to the respective alien codes. This type of shortcut method can be implemented using something like the customization. However, I have tried doing that in the class, but it didn't work well because I would then need to create an instance of the class ( ) in order to use the shortcut methods. Instead, I wanted to keep using these methods as class methods. Therefore, I had to go for a metaclass. Let's say we have the following : from functools import partial class _MetaColors(type): HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKCYAN = '\\033[96m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' BOLD = '\\033[1m' B = '\\033[1m' UNDERLINE = '\\033[4m' U = '\\033[4m' _ENDC = '\\033[0m' def __getattr__(cls, name): if name.startswith('print_'): key = name.lstrip('print_').upper() assert not key.startswith('_'), 'Color key cannot start with `_`' return partial(cls.print, key) else: key = name.upper() assert not key.startswith('_'), 'Color key cannot start with `_`' return partial(cls.colorize, key) @classmethod def colorize(cls, key, *args): ini = getattr(cls, key.upper(), None) assert ini != None, f'Color key \"{key}\" not recognized' string = ' '.join(str(a) for a in args) return ini + string + cls._ENDC @classmethod def print(cls, key, *args, **kwds): colorized = cls.colorize(key, *args) print(colorized, **kwds) class Colors(metaclass=_MetaColors): pass Then, you can just use colors from other modules like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/48326026/how-to-handle-http-status-codes-across-a-python-application",
        "document": "I'm trying to standardize my handling of HTTP status codes returned from various APIs in an effort to reduce the amount of code I copy across files.\n\nFor my current application, I have a set of files that each contain one class that all derive inheritance from one master class. I'm using the Python requests module to consume the APIs.\n\nSo far, I've written custom status code handling in each function to continue with a 200, log the request I sent with a 400, log the url for a 404, retry for 5xx, but it's a hassle to keep copying this code across functions and classes.\n\nI'm thinking of the following (note that I've simplified my code here to just use GETs, but in reality, I'm mostly POSTing and receiving back a json response):\n\nHowever, this still seems iffy. I don't know if it's reasonable to try to account for every status code returned by an API. And this would also require me to copy this code to any new project I start working on.\n\nIs there a better way to do this?"
    },
    {
        "link": "https://docs.chainstack.com/docs/best-practices-for-error-handling-in-api-requests",
        "document": "\n• Explains how Chainstack’s global node feature can boost your DApp’s reliability by balancing traffic automatically based on user location.\n• Demonstrates a JavaScript load balancer script using multiple Chainstack endpoints, distributing requests across different regions to avoid single-point failures.\n• Shows examples with both web3.js and ethers.js, detailing how to fail over to the next endpoint if one fails.\n• Concludes that both global nodes and custom load-balancing approaches help ensure your blockchain app can handle high traffic and unexpected downtimes.\n\nIn the world of API requests, error handling is not just a best practice—it's a necessity. Effectively handling HTTP status codes is crucial for ensuring smooth and reliable communication between clients and servers. Whether you're a seasoned developer or just starting out, understanding how to automate the retrieval of response codes from any request can help you build more robust applications, implement effective retry logic, and create comprehensive error backlogs. This guide will walk you through the best practices for error handling in API requests, with a focus on handling HTTP status codes and implementing retry logic.\n\nHTTP status codes are the server's way of telling the client about the status of the operation it requested. They play a vital role in API requests as they can indicate success, failure, or need for further action. By properly handling these status codes, you can ensure your application responds appropriately to each possible outcome of an API request. This can significantly enhance the user experience and the overall performance of your application.\n\nHTTP status codes are grouped into five major categories, each representing a specific class of responses. These include:\n• 1xx (informational) — the request has been received and understood, and the client should continue the process.\n• 2xx (success) — the action was successfully received, understood, and accepted.\n• 3xx (redirection) — the client must take additional action to complete the request.\n• 4xx (client errors) — the request contains bad syntax or cannot be fulfilled.\n• 5xx (server errors) — the server failed to fulfill an apparently valid request.\n\nUnderstanding these status codes and how to handle them is the first step toward effective error handling in API requests. In the following sections, we'll dive deeper into how to retrieve and handle these status codes in your Python code and how to implement a retry logic for temporary failures.\n\nBefore we can handle HTTP status codes, we first need to know how to retrieve them. In Python, this can be done using the attribute of the response object. This attribute holds the status code that the server returned for the HTTP request.\n\nLet's consider a scenario where we're interested in getting the logs of the latest block. We can do this using the following Python code:\n\nIf the above code is successfully run, it will output the logs for the latest block. This means that the response code received by the client (you, who made the request) was equal to 200. To retrieve the response code of the request presented above, we can simply use the following:\n\nThis will store the HTTP status code of the response in the variable. Now that we know how to retrieve the status code of a response, we can move on to handling these codes and analyzing error responses.\n\nIn addition to dealing with response codes, it's also important to analyze other information in the response to understand and deal with errors. This can be particularly useful when the server returns a 4xx or 5xx status code, indicating a client or server error.\n\nFor instance, let's consider a possible response for a request that contains an error content in the output:\n\nIn this case, the server returned a JSON object with an field, which contains further information about the error that occurred. We can extract this information in our Python code like this:\n\nIn this code, we first check if the response's status code is 200, indicating a successful request. If it is, we parse the JSON content of the response and check if it contains an field. If it does, we store the content of this field in the variable. This information can be used to implement a retry logic and keep a record of whenever those errors happen in time.\n\nIncorporating retry logic into your code can significantly enhance the reliability of your application. By leveraging the tools and techniques we have discussed, you can implement a retry mechanism that automatically handles temporary failures and retries the request when necessary. This can reduce the impact of temporary failures on you, increase system availability, and ensure data integrity. In the worst-case scenario, this enables you to keep track of the errors you face with precise timestamps for such incidents.\n\nImplementing retry logic is particularly important when dealing with 5xx server errors. These errors indicate a problem with the server and are often temporary. By implementing a retry logic, your application can automatically retry the request after a short delay, giving the server a chance to recover. This can significantly improve the user experience by reducing the number of failed requests the user has to deal with.\n\nNow that we understand the importance of implementing retry logic let's dive into how to implement it in our Python code. Our retry logic aims to automatically retry the request when a temporary failure occurs. This can be a 5xx server error, a connection error, or any other type of error that we deem temporary.\n\nHere's an example of how to implement retry logic in Python using both the response code and error messages to determine when to retry a request:\n\nThe retry logic is governed by a for loop that runs up to a predefined maximum number of attempts (the variable). For each iteration of the loop, which represents an attempt to fetch the logs, the code performs the following steps:\n• A request is sent to the Ethereum node with the defined headers and payload.\n• If the HTTP status code of the response is not 200 (indicating a successful request), the code prints a message indicating that the request failed and the current attempt number. Then, it waits for the specified delay period (the variable) before proceeding to the next iteration of the loop. This delay provides a pause before retrying, which can be helpful in cases where the server might be temporarily overloaded or experiencing other transient issues.\n• If the status code is 200 (indicating a successful request), the response is parsed into JSON format and checked for an key. If is present, the code prints a message with the error details and the current attempt number, waits for the specified delay period, and proceeds to the next iteration of the loop. This handles cases where the request was technically successful, but the response indicates an error condition that might be resolved with a retry.\n• If there's no key in the response but the is empty, the code prints a message indicating this fact and the current attempt number, waits for the specified delay period, and proceeds to the next iteration of the loop. This handles situations where the request was successful and didn't result in an error but didn't provide any logs to process.\n\nIf the function hasn't returned by the end of the loop (meaning it hasn't successfully processed a set of logs), it will have retried the request the maximum number of times. At this point, the function will exit, and the code will continue, effectively giving up on fetching logs after exhausting all the allowed attempts.\n\nUsing response code and error messages in retry logic Using response code and error messages in retry logic\n\nAs you can see in the above example, we use both the response code and error messages in our retry logic. The response code allows us to determine whether the request was successful, while the error messages provide more detailed information about what went wrong.\n\nBy using both of these pieces of information, we can make our retry logic more intelligent and effective. For example, we can decide to retry the request immediately if the error message indicates a temporary problem with the server or wait for a longer delay if the error message indicates a more serious problem.\n\nIn addition, by logging the error messages, we can keep a record of the errors that occurred, which can be useful for debugging and improving our application.\n\nWhile handling HTTP status codes and implementing retry logic can significantly improve the reliability of your application, there are a few common problems and gotchas that you should be aware of.\n\nAnother common problem is the lack of effective retry logic and robust error backlogs. Without these, your application may not be able to recover from temporary failures, resulting in poor user experience and potential data loss.\n\nAn effective retry logic should take into account the nature of the error and adjust its behavior accordingly. For example, if the error is temporary (such as a 5xx server error), the retry logic should wait for a short delay before retrying the request. If the error is permanent (such as a 4xx client error), the retry logic should not retry the request and should log the error and notify the user.\n\nA robust error backlog, on the other hand, can help you keep track of the errors that occur in your application, allowing you to debug and fix issues more effectively. It can also provide valuable insights into the performance and reliability of your application, helping you identify areas for improvement.\n\nHandling HTTP status codes and implementing retry logic are crucial aspects of working with API requests. They ensure smooth and reliable communication between clients and servers and enhance your applications' overall performance and resilience. As the volume and complexity of data continue to increase, the importance of these practices cannot be overstated.\n\nRemember, the key to effective error handling is understanding the different types of HTTP status codes and how to handle them. This includes knowing how to retrieve these codes, analyze error responses, and implement robust retry logic. By doing so, you can build applications that are capable of handling temporary failures and maintaining data integrity, even in the face of increasing data volume and complexity.\n\nHowever, it's also important to be aware of the common challenges and gotchas associated with these practices. This includes dealing with the constantly growing data in Web3, implementing effective retry logic, and maintaining robust error backlogs. By being aware of these challenges and knowing how to handle them, you can ensure that your applications remain reliable and resilient, no matter what comes their way.\n\nIn conclusion, while error handling in API requests can be complex, it's an essential skill for any developer working with APIs. By following the best practices outlined in this guide, you can ensure that your applications are well-equipped to handle any errors that may occur, resulting in a better user experience and a more reliable application."
    },
    {
        "link": "https://geeksforgeeks.org/exception-handling-of-python-requests-module",
        "document": "Python request module is a simple and elegant Python HTTP library. It provides methods for accessing Web resources via HTTP. In the following article, we will use the HTTP GET method in the Request module. This method requests data from the server and the Exception handling comes in handy when the response is not successful. Here, we will go through such situations. We will use Python’s try and except functionality to explore the exceptions that arise from the Requests module.\n• url: Returns the URL of the response\n• raise_for_status(): If an error occur, this method returns a HTTPError object\n• request: Returns the request object that requested this response\n• status_code: Returns a number that indicates the status (200 is OK, 404 is Not Found)\n\n\n\nThe first thing to know is that the response code is 200 if the request is successful.\n\nHere, we tried the following URL sequence and then passed this variable to the Python requests module using raised_for_status(). If the try part is successful, we will get the response code 200, if the page that we requested doesn’t exist. This is an HTTP error, which was handled by the Request module’s exception HTTPError and you probably got the error 404.\n\nYou could also use a general exception from the Request module. That is requests.exceptions.RequestException.\n\nNow, you may have noticed that there is an argument ‘timeout’ passed into the Request module. We could prescribe a time limit for the requested connection to respond. If this has not happened, we could catch that using the exception requests.exceptions.ReadTimeout. To demonstrate this let us find a website that responds successfully.\n\nIf we change timeout = 0.01, the same code would return, because the request could not possibly be that fast.\n\nAnother common error is that we might not specify HTTPS or HTTP in the URL. For example, We cause use requests.exceptions.MissingSchema to catch this exception.\n\nLet us say that there is a site that doesn’t exist. Here, the error will occur even when you can’t make a connection because of the lack of an internet connection\n\nHere, We put together everything we tried so far the idea is that the exceptions are handled according to the specificity.\n\nFor example, url = “https://www.gle.com”, When this code is run for this URL will produce an Exception request. Whereas, In the absence of connection requests.exceptions.ConnectionError will print the Connection Error, and when the connection is not made the general exception is handled by requests.exceptions.RequestException.\n\nNote: The output may change according to requests."
    },
    {
        "link": "https://y42.com/blog/python-requests-best-practices-for-data-engineers",
        "document": "If you're working in data engineering, you probably know Python is pretty much the Swiss Army knife for pulling data from all sorts of places. A lot of folks go straight for the requests library and try to grab everything in one go with . But, that can quickly get dicey. Holding all that data in memory is a bit like trying to cram six people in a sedan—sooner or later, you're going to run into trouble.\n\nIn this article, we'll deep dive into:\n• How you can utilize pagination and query parameters for handling large data requests.\n• Streaming responses to process data incrementally, thus avoiding the need to load everything into memory at once.\n• How we can gracefully handle exceptions and understand error status codes\n• Implementing Python requests timeout, retries, and backoff strategies to deal with network issues and API rate limits.\n\nWhen we're setting up our data ingestion pipelines, we're always looking for ways to make things run smoother and faster. Here are a few strategies to improve performance:\n\nYou can reduce the server load and client memory by breaking the data retrieval process into smaller chunks.\n\nOne option is paginating results. Say, you are collecting data on books from a large online library’s API, which contains millions of records. Fetching all records in one go isn’t feasible due to memory constraints and API rate limits. Instead, you can paginate results and have Python fetch smaller batches of results at a time:\n\nThe output will be:\n\nA similar option is to pass query parameters to filter the request. Suppose you’re developing an application that aggregates news articles. You need to fetch articles from a news API based on certain criteria, such as keywords, date ranges, or specific categories like technology or health. By using query parameters, you can tailor the API request to return only the articles that match your application's current needs.\n\nFor large data sets, you can use streaming to process data incrementally as it arrives. This minimizes memory consumption.Let’s say you are downloading a large dataset of genomic sequences, which is too large to hold in memory. Using streaming, you process the data as it arrives:\n\nYou can think of this like sipping through a straw; instead of trying to drink the whole glass of water in one gulp, you're taking it in manageable sips, making it easier to handle without overwhelming yourself.\n\nSessions are used to persist parameters across requests. For example, if you're developing a weather application that fetches the current weather, forecasts, and historical weather data for multiple locations from the same API, instead of establishing a new connection for each request, you can use a session:\n\nCaching is storing requests data temporarily so it can be instantly accessed in subsequent calls without making additional requests to the API. This helps reduce the number of requests, saves time, and improves performance. However, setting the expire_after parameter too high could lead to processing stale data.\n\nWhen talking to web APIs, lots can go wrong—like losing your internet connection or the server going down. Python requests exceptions can tell you when things go south, through errors and status codes. Catching these errors lets your app understand what went wrong and decide what to do next. You can find an example of Python requests error handling below:\n\nMany APIs impose rate limits to prevent abuse and ensure fair resource distribution among users. When your application exceeds these limits, the API may respond with a 429 Too Many Requests status code. But Python's requests library won't do this for you automatically. You can set it up to retry failed requests by using a special setup called a custom transport adapter along with some rules about when to retry. This way, your app keeps trying without you having to tell it to do so every time.\n\nOne retry mechanism is to implement an exponential backoff strategy, where the wait time increases exponentially with each retry. The wait time between retries is calculated as , where retry_number is the current retry attempt number (starting at 0). So, if the backoff factor is set to 1 second, the wait time before the first retry is 1 second, before the second retry is 2 seconds, before the third is 4 seconds, and so on.\n\nSo, you’ve armed yourself with some pretty good strategies to develop performant and reliable data extraction scripts with Python. While crafting Python scripts locally to extract data might seem like a breeze, deploying, managing secrets, dependencies and infrastructure are not. This is where Y42 comes into the picture.\n\nYAML files are auto-generated with standardized metadata based on your actions in Y42.\n\nY42 is designed to simplify the transition of your local data extraction scripts to production. Discover how our solution can assist you by removing the boilerplate code needed to load the extracted data into your data warehouse, without having to worry about infrastructure, and providing standardized metadata, lineage, and documentation right out of the box. Curious about how we make Python data ingestion look easy? Dive in to learn more about our Python ingest assets."
    },
    {
        "link": "https://apidog.com/blog/python-requests-response",
        "document": "Handling API requests and responses in Python can be a game-changer for your projects. Whether you're building a web application, a mobile app, or even a simple script, understanding how to interact with APIs is crucial. In this comprehensive guide, we'll dive deep into the world of Python requests and responses, giving you the tools you need to become an API master. And hey, don't forget to download Apidog for free - it will make your API development and testing a breeze!\n\nFirst things first, let's talk about what an API is. API stands for Application Programming Interface. It's a set of rules that allows different software entities to communicate with each other. Think of it as a waiter taking your order (your request) and bringing back your food (the response). APIs are everywhere – from weather apps to social media platforms.\n\nAPIs allow developers to access the functionality of other software programs. This can range from simple tasks, like fetching data from a web server, to more complex operations, like interacting with a machine learning model hosted on a cloud service.\n\nUsing APIs can save you a lot of time and effort. Instead of reinventing the wheel, you can leverage existing services and data. Plus, it allows your applications to be more versatile and integrated.\n\nBefore we dive in, here are some key terms you should know:\n• Endpoint: The URL where the API can be accessed.\n• Request: The message sent to the API to perform an action.\n• Response: The message the API sends back with the result of the request.\n• Status Code: A code that indicates the result of the request (e.g., 200 for success, 404 for not found).\n\nPython's library is a powerful tool for making HTTP requests. It's simple, yet very flexible, allowing you to interact with APIs effortlessly. Let's get started with installing the library.\n\nNow that we have the library installed, let's move on to making our first API request.\n\nTo make an API request, you'll need an API endpoint. For this example, we'll use the JSONPlaceholder API, a free fake online REST API for testing and prototyping.\n\nHere's a simple example of how to make a GET request:\n\nIn this example, we're sending a GET request to the endpoint. The function sends the request, and the response is stored in the variable. We then print the status code and the JSON response.\n\nThe response object contains all the information returned by the server. Here are some useful properties of the response object:\n• : The HTTP status code returned by the server.\n• : A method that parses the response body as JSON.\n\nSometimes, you'll need to send data to the API. This is where POST requests come in. Here's an example:\n\nIn this example, we're sending a POST request to the endpoint with some JSON data. The function sends the request, and the response is handled similarly to the GET request.\n\nNow that we've made some requests, let's talk about handling the responses. It's important to check the status code to ensure the request was successful.\n\nHere's a simple example of how to check the status code:\n\nIn this example, we're checking if the status code is , which indicates success. If the request was successful, we print the JSON response. Otherwise, we print an error message with the status code.\n\nMost APIs return data in JSON format. The method makes it easy to parse the JSON data. Here's an example:\n\nIn this example, we're parsing the JSON response and printing the and fields.\n\nError handling is crucial when working with APIs. You need to be prepared for various scenarios, such as network issues, invalid endpoints, and server errors.\n\nNetwork errors can occur when the server is unreachable or the connection is lost. The library provides built-in support for handling these errors using exceptions.\n\nIn this example, we're using a try-except block to catch different types of errors. The method raises an HTTPError if the status code is not 200.\n\nServer errors (status codes 500-599) indicate a problem on the server side. Here's an example of how to handle server errors:\n\nIn this example, we're checking if the status code is in the 500 range, which indicates a server error. We're also handling 404 (Not Found) and 400 (Bad Request) errors.\n\nNow that we've covered the basics, let's explore some advanced tips and tricks to make your life easier when working with APIs in Python.\n\nQuery parameters allow you to pass data to the API as part of the URL. Here's an example:\n\nIn this example, we're passing a parameter to the endpoint. The parameter of the function takes a dictionary of query parameters.\n\nHeaders are used to send additional information with the request. Here's an example:\n\nIn this example, we're setting the header to . The parameter of the function takes a dictionary of headers.\n\nMany APIs require authentication. The library supports various authentication methods, including Basic Auth and OAuth. Here's an example of how to use Basic Auth:\n\nIn this example, we're using Basic Auth to authenticate with the API. The parameter of the function takes an instance of .\n\nHow to Test Your Python POST Request\n\nApidog is a powerful tool for testing APIs. It allows you to create and save API requests, organize them into collections, and share them with your team.\n\nHere is how you can use Apidog to test your POST request:\n\n3. Enter the URL of the resource you want to update. Add any additional headers or parameters you want to include then click the “Send” button to send the request.\n\n4. Verify that the response is what you expected.\n\nIn this guide, we've covered the essentials of handling API requests and responses in Python. We've looked at making GET and POST requests, handling responses, and dealing with errors. We've also explored some advanced tips and tricks to make your life easier. Remember, APIs are a powerful tool that can open up a world of possibilities for your projects. So go ahead, experiment, and start building amazing things!\n\nAnd don't forget to download Apidog for free to streamline your API development and testing. Happy coding!"
    }
]