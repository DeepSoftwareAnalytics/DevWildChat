[
    {
        "link": "https://docs.unity3d.com/2023.2/Documentation/Manual/AwaitSupport.html",
        "document": "Unity 2023.1 introduces support for a simplified asynchronous programming model using C# async and await keywords. Most of Unity’s asynchronous API supports the async/await pattern, including:\n\nYou can also use the Awaitable class with both the await keyword and as an async return type in your own code, like this:\n\nUnity’s Awaitable class is designed to be as efficient as possible for use in Unity game or app projects, however this efficiency comes with some trade-offs compared with .NET tasks. The most significant limitation is that instances are pooled to limit allocations. For example, consider the following example:\n\nWithout pooling, each instance of this behavior would allocate an Awaitable object each frame. This would put a lot of pressure on the garbage collector causing performance to suffer. To mitigate that, once awaited, Unity returns the object to the internal Awaitable pool. This has one significant implication: you should never await more than once on an Awaitable instance. Doing so can result in undefined behavior such as an exception or a deadlock.\n\nThe following table lists the other notable differences and similarities between Unity’s class and .NET Tasks.\n\nAs shown in the table above, continuations are run synchronously when the operation completes. When not documented otherwise, all Awaitables returned by Unity APIs complete on the main thread, so there is no need to capture a synchronization context. However, you can write your code to do otherwise. See the following example:\n\nTo improve the situation, you should make sure your Awaitable-returning methods complete on the main thread by default. Here is an example where completes on the main thread by default, while allowing callers to explicitly continue on the background thread (to chain heavy compute operations on a background thread without synchronizing back to the main thread):\n\nAwaitableCompletionSource and AwaitableCompletionSource<T> allows creations of Awaitable instances where completion is raised from user code. For example this can be used to elegantly implement user prompts without having to implement a state machine to wait for the user interaction to finish:\n\nIn most cases, Awaitable should be slightly more efficient than iterator-based coroutines, especially for cases where the iterator would return non-null values (such as WaitForFixedUpdate etc).\n\nAlthough Unity’s Awaitable class is optimized for performance, you should avoid running hundreds of thousands of concurrent coroutines. Similar to coroutine-based iterators, a behavior with a loop similar to the following example attached to all your game objects is very likely to cause performance problems:\n\nFrom a performance perspective, it is very efficient to call from the main thread, or to call from a background thread. However, the synchronization mechanism switching to the main thread from a background thread causes your code to resume on the next Update event. Therefore you should avoid from switching back and forth between the main thread and background threads at a high frequency, because your code will have to wait for the next frame on each call to MainThreadAsync().\n\nAwait support compared to the C# Job System\n\nUnity’s Await support is better suited to the following scenarios than the C# Job system:\n• Simplifying code when dealing with inherently asynchronous operations such as manipulating files or performing web requests, in an non-blocking way.\n• Mixing and matching multiple kinds of async operations (frame events, unity events, third party asynchronous APIs, I/O).\n\nHowever it is not recommended for shorter-lived operations such as when parallelizing computationally-intensive algorithms. To get the most of multi-core CPUs and parallelize your algorithms, you should instead use the C# Job System.\n\nUnity’s Test Framework does not recognize Awaitable as a valid test return type. However, the following example shows how you can use Awaitable’s implementation of IEnumerator to write async tests:\n\nOne of the biggest advantage of leveraging await, is that we can mix an match any await-compatible type in the same method:"
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/async-await-support.html",
        "document": "Asynchronous programming allows your code to perform long-running tasks without blocking the main thread. This allows your application to remain responsive and perform other tasks while it waits for an asynchronous task to complete.\n\nUnity supports a simplified asynchronous programming model using the .NET async key word and await operator.\n\nBefore reading about asynchronous programming in Unity, make sure you understand the fundamental elements of asynchronous programming in .NET. For important context, refer to Asynchronous programming with async and await and Task asynchronous programming model."
    },
    {
        "link": "https://hackernoon.com/unity-20231-introduces-awaitable-class",
        "document": "In May 2022, Alexandre Mutel and Kristyna Hougaard announced in their post \"Unity and .NET, what's next?\" that Unity plans to adopt more of .NET's features, including the convenience of using async-await. And, it seems that Unity is following through on its promise. In the Unity 2023.1 alpha version, the Awaitable class has been introduced, providing more opportunities for writing asynchronous code.\n\nIn this section, I will not delve too deeply into methods that, in my opinion, have sufficient description in the official Unity documentation. They are all related to asynchronous waiting.\n\nAwaitable.WaitForSecondsAsync() allows you to wait for a specified amount of game time. Unlike Task.Delay(), which performs a wait in real-time. To help clarify the difference, I will provide a small example later in a code block.\n\nIn this example, at the beginning of the Start() method, the game time is stopped using Time.timeScale. For the sake of the experiment, a Coroutine will be used to resume its flow after 5 seconds in the RunGameplay() method. Then, we launch two one-second waiting methods. One using Awaitable.WaitForSecondsAsync(), and the other using Task.Delay(). After one second, we will receive a message in the console \"Waiting WaitWithTaskDelay() ended\". And after 5 seconds, the message \"Waiting WaitWithTaskDelay() ended\" will appear.\n\nOther convenient methods have also been added to give you more flexibility in Unity's basic Player Loop. Their purpose is clear from the name and corresponds to their analogy when using Coroutines:\n\nIf you are new to working with Coroutines, I recommend experimenting with them on your own to gain a better understanding.\n\nA method, Awaitable.FromAsyncOperation(), has also been added for backward compatibility with the old API, AsyncOperation.\n\nOne of the conveniences of using Coroutines is that they automatically stop if the component is removed or disabled. In Unity 2022.2, the destroyCancellationToken property was added to MonoBehaviour, allowing you to stop asynchronous execution at the time of object deletion. It's important to remember that stopping the task through CancellationToken cancellation throws the OperationCanceledException. If the calling method doesn't return Task or Awaitable, this exception should be caught.\n\nIn this example, the object is immediately destroyed in Start(), but before that, Awake() manages to launch the execution of DoAwaitAsync(). The command Awaitable.WaitForSecondsAsync(1, destroyCancellationToken) waits for 1 second and then should output the message \"That message won't be logged.\" Because the object is immediately deleted, the destroyCancellationToken stops the execution of the entire chain by throwing the OperationCanceledException. In this way, destroyCancellationToken relieves us from the need to create a CancellationToken manually.\n\nBut we can still do this, for example, to stop execution at the time of object deactivation. I will give an example.\n\nIn this form, the message \"This message is logged every second\" will be sent as long as the object on which this MonoBehaviour hangs is turned on. The object can be turned off and turned on again.\n\nThis code may seem redundant. Unity already contains many convenient tools such as Coroutines and InvokeRepeating() that allow you to perform similar tasks much easier. But this is just an example of use. Here we are just dealing with Awaitable.\n\nIn Unity, async method execution does not stop on its own even after exiting Play Mode in the editor. Let's add a similar script to the project.\n\nIn this example, after switching to Play Mode, the message \"This message is logged every second\" will be output to the console. It continues to be output even after the Play button is released. In this example, Task.Delay() is used instead of Awaitable.WaitForSecondsAsync(), because here, in order to show the action, a delay is needed not in game time but in real time.\n\nAnalogously to destroyCancellationToken, we can use Application.exitCancellationToken, which interrupts the execution of async methods upon exit from Play Mode. Let's fix the script.\n\nNow the script will execute as intended.\n\nIn Unity, some event functions can be Coroutines, for example, Start, OnCollisionEnter, or OnCollisionExit. But starting from Unity 2023.1, all of them can be Awaitable, including Update(), LateUpdate, and even OnDestroy().\n\nThey should be used with caution, as there is no waiting for their asynchronous execution. For example, for the following code:\n\nIn the console, we will get the following result:\n\nIt is also worth remembering that the MonoBehaviour itself or even the game object may cease to exist while the asynchronous code is still executing. In such a situation:\n\nIn the next frame, the MonoBehaviour is considered deleted. In the console, we will get the following result:\n\nThis also applies to the OnDestroy() method. If you make the method asynchronous, you should take into account that after the await statement, the MonoBehaviour is already considered deleted. When the object itself is deleted, the work of many MonoBehaviours located on it may not work correctly at this point.\n\nIt's worth noting that when working with event functions, it's important to be aware of the order of execution. Asynchronous code may not execute in the order you expect, and it's essential to keep this in mind when designing your scripts.\n\nIt's worth noting that Awaitable Event Functions catch all types of exceptions, which can be unexpected. I was expecting them to catch only OperationCanceledExceptions, which would have made more sense. But catching all types of exceptions makes them not suitable for use at this time. Instead, you can run async methods and manually catch the necessary messages, as shown in the earlier example.\n\nBecause the component is deleted immediately on start, the execution of DoAwaitAsync() will be interrupted. The message \"That message won't be logged\" will not appear in the console. Only OperationCanceledException() is caught, all other exceptions can be thrown.\n\nI hope this approach will be corrected in the future. At the moment, the use of Awaitable Event Functions is not safe.\n\nAs is known, all operations with game objects and MonoBehaviours are only allowed in the main thread. Sometimes it is necessary to make massive calculations that can lead to game freezing. It is better to perform them outside of the main thread. Awaitable offers two methods, BackgroundThreadAsync() and MainThreadAsync(), which allow moving away from the main thread and returning to it. I will provide an example.\n\nHere, when the method starts, it will switch to an additional thread. Here I output the id of this additional thread to the console. It will not be equal to 1, because 1 is the main thread.\n\nThen the thread is frozen for 10 seconds (Thread.Sleep(10000)), simulating massive calculations. If you do this in the main thread, the game will appear to freeze for the duration of its execution. But in this situation, everything continues to work stably. You can also use a CancellationToken in these calculations to stop an unnecessary operation.\n\nAfter that, we switch back to the main thread. And now all Unity functions are available to us again. For example, as in this case, disabling a game object, which was not possible to do without the main thread.\n\nIn conclusion, the new Awaitable class introduced in Unity 2023.1 provides developers with more opportunities for writing asynchronous code, making it easier to create responsive and performant games. The Awaitable class includes a variety of waiting methods, such as WaitForSecondsAsync(), EndOfFrameAsync(), FixedUpdateAsync(), and NextFrameAsync(), which allow for more flexibility in the basic Player Loop of Unity. The destroyCancellationToken and Application.exitCancellationToken properties also provide a convenient way to stop asynchronous execution at the time of object deletion or exiting Play Mode.\n\nIt is important to note that while the Awaitable class provides a new way to write asynchronous code in Unity, it should be used in conjunction with other Unity tools such as Coroutines and InvokeRepeating to achieve the best results. Additionally, it is important to understand the basics of async-await and the benefits it can bring to the game development process, such as improving performance and responsiveness.\n\nIn summary, the Awaitable class is a powerful tool for Unity developers, but it should be used with care and in conjunction with other Unity tools and concepts to achieve the best results. It is important to experiment with it to better understand its capabilities and limitations."
    },
    {
        "link": "https://docs.unity.cn/2023.2/Documentation/Manual/AwaitSupport.html",
        "document": "Unity 2023.1 introduces support for a simplified asynchronous programming model using C# async and await keywords. Most of Unity’s asynchronous API supports the async/await pattern, including:\n\nYou can also use the Awaitable class with both the await keyword and as an async return type in your own code, like this:\n\nUnity’s Awaitable class is designed to be as efficient as possible for use in Unity game or app projects, however this efficiency comes with some trade-offs compared with .NET tasks. The most significant limitation is that instances are pooled to limit allocations. For example, consider the following example:\n\nWithout pooling, each instance of this behavior would allocate an Awaitable object each frame. This would put a lot of pressure on the garbage collector causing performance to suffer. To mitigate that, once awaited, Unity returns the object to the internal Awaitable pool. This has one significant implication: you should never await more than once on an Awaitable instance. Doing so can result in undefined behavior such as an exception or a deadlock.\n\nThe following table lists the other notable differences and similarities between Unity’s class and .NET Tasks.\n\nAs shown in the table above, continuations are run synchronously when the operation completes. When not documented otherwise, all Awaitables returned by Unity APIs complete on the main thread, so there is no need to capture a synchronization context. However, you can write your code to do otherwise. See the following example:\n\nTo improve the situation, you should make sure your Awaitable-returning methods complete on the main thread by default. Here is an example where completes on the main thread by default, while allowing callers to explicitly continue on the background thread (to chain heavy compute operations on a background thread without synchronizing back to the main thread):\n\nAwaitableCompletionSource and AwaitableCompletionSource<T> allows creations of Awaitable instances where completion is raised from user code. For example this can be used to elegantly implement user prompts without having to implement a state machine to wait for the user interaction to finish:\n\nIn most cases, Awaitable should be slightly more efficient than iterator-based coroutines, especially for cases where the iterator would return non-null values (such as WaitForFixedUpdate etc).\n\nAlthough Unity’s Awaitable class is optimized for performance, you should avoid running hundreds of thousands of concurrent coroutines. Similar to coroutine-based iterators, a behavior with a loop similar to the following example attached to all your game objects is very likely to cause performance problems:\n\nFrom a performance perspective, it is very efficient to call from the main thread, or to call from a background thread. However, the synchronization mechanism switching to the main thread from a background thread causes your code to resume on the next Update event. Therefore you should avoid from switching back and forth between the main thread and background threads at a high frequency, because your code will have to wait for the next frame on each call to MainThreadAsync().\n\nAwait support compared to the C# Job System\n\nUnity’s Await support is better suited to the following scenarios than the C# Job system:\n• Simplifying code when dealing with inherently asynchronous operations such as manipulating files or performing web requests, in an non-blocking way.\n• Mixing and matching multiple kinds of async operations (frame events, unity events, third party asynchronous APIs, I/O).\n\nHowever it is not recommended for shorter-lived operations such as when parallelizing computationally-intensive algorithms. To get the most of multi-core CPUs and parallelize your algorithms, you should instead use the C# Job System.\n\nUnity’s Test Framework does not recognize Awaitable as a valid test return type. However, the following example shows how you can use Awaitable’s implementation of IEnumerator to write async tests:\n\nOne of the biggest advantage of leveraging await, is that we can mix an match any await-compatible type in the same method:"
    },
    {
        "link": "https://medium.com/my-games-company/the-complete-asynchronous-programming-primer-for-unity-e1b00d26e96b",
        "document": "In this article, we consider the main ways of asynchronous programming in Unity: discuss pros and cons, illustrate code examples, and show practical examples of where to use each of them. A great primer for newcomers and a solid resource for more experienced engineers!\n\nSome tasks in game development are not synchronous — they are asynchronous. This means they are not linearly executed within the game code. Some of these asynchronous tasks can require quite a long time to complete, while others are associated with intensive computations.\n\nSome of the most common gaming asynchronous tasks are as follows:\n\nNow, crucially, since all Unity code runs in one thread, any task like one of those mentioned above, if they were performed synchronously, would lead to the main thread being blocked, and thus, frame drops.\n\nHello everyone, my name is Dmitrii Ivashchenko and I am the Head of the Development Team at MY.GAMES. In this article, we’re going to talk about avoiding any such issues. We’ll recommend asynchronous programming techniques to perform these tasks in a separate thread, thus leaving the main thread free to perform other tasks. This will help ensure smooth and responsive gameplay, and (hopefully) satisfied gamers.\n\nFirst up, let’s talk about coroutines. They were introduced in Unity in 2011, even before async / await appeared in .NET. In Unity, coroutines allow us to perform a set of instructions over multiple frames, instead of executing them all at once. They are similar to threads, but are lightweight and integrated into Unity’s update loop, making them well suited for game development.\n\nTo create a coroutine, you need to declare a function with the return type. This function can contain any logic you want the coroutine to execute.\n\nTo start a coroutine, you need to call the method on a instance and pass the coroutine function as an argument:\n\nThere are several yield instructions available in Unity, such as , , , , as well as some others. It’s important to remember that using them leads to allocations, so they should be reused wherever possible.\n\nFor example, consider this method from the documentation:\n\nWith each iteration of the loop, a new instance of will be created. Instead of this, we can move creation outside of the loop and avoid allocations:\n\nAnother significant property to note is that can be used with all the methods provided by Unity because s are descendants of :\n\nSome possible pitfalls of coroutines\n\nThis all being said, coroutines also have a few drawbacks to note:\n• It’s impossible to return the result of a long operation. You still need callbacks that will be passed to the coroutine and called when it is finished to extract any data from it.\n• A coroutine is strictly tied to the that launches it. If the is turned off or destroyed, the coroutine stops being processed.\n• The structure cannot be used due to the presence of the yield syntax.\n• At least one frame will pass after the before the next code starts to execute.\n• Allocation of the lambda and the coroutine itself\n\nPromises are a pattern for organizing and making asynchronous operations more readable. They have become popular due to their use in many third-party JavaScript libraries, and, since ES6, have been implemented natively.\n\nWhen using Promises, we immediately return an object from your asynchronous function. This allows the caller to wait for the resolution (or an error) of the operation.\n\nEssentially, this makes it so that asynchronous methods can return values and “act” like synchronous methods: instead of returning the final value right away, they give a “promise” that they will return a value sometime in the future.\n\nThere are several Promises implementations for Unity:\n\nThe main way to interact with a Promise is via callback functions.\n\nYou can define a callback function that will be called when a Promise is resolved, and another callback function that will be called if the Promise is rejected. These callbacks receive the outcome of the asynchronous operation as arguments, which can then be used to perform further operations.\n\nAccording to these specifications from the Promises/A+ organization, a Promise can be in one of three states:\n• : the initial state, this means that the asynchronous operation is still in progress, and the outcome of the operation is not yet known.\n• ( ): the resolved state is accompanied by a value that represents the outcome of the operation.\n• : if the asynchronous operation fails for any reason, the Promise is said to be \"rejected\". The rejected state is accompanied by the reason for the failure.\n\nAdditionally, promises can be chained together, so that the outcome of one Promise can be used to determine the outcome of another Promise.\n\nFor example, you can create a Promise that fetches some data from a server, and then use that data to create another Promise that performs some calculation and other actions:\n\nHere’s an example of how to organize a method that performs an asynchronous operation:\n\nWe could also wrap coroutines in a :\n\nAnd of course, you can organize any combination of promise execution order using / and / :\n\nDespite all the convenience of use, promises also have some drawbacks:\n• Overhead: Creating Promises involves additional overhead compared to using other methods of asynchronous programming, like coroutines. In some cases, this can lead to decreased performance.\n• Debugging: Debugging Promises can be more difficult than debugging other asynchronous programming patterns. It can be difficult to trace the execution flow and identify the source of bugs.\n• Exception Handling: Exception handling can be more complex with Promises compared to other asynchronous programming patterns. It can be difficult to manage errors and exceptions that occur within a Promise chain.\n\nThe async/await feature has been a part of C# since version 5.0 (2012), and it was introduced in Unity 2017 with the implementation of the .NET 4.x runtime.\n\nIn the history of .NET, the following stages can be distinguished:\n• EAP (Event-based Asynchronous Pattern): This approach is based on events that are triggered upon completion of an operation and a regular method that invokes this operation.\n• APM (Asynchronous Programming Model): This approach is based on two methods. The method returns the interface. The method takes ; if the operation is not completed at the time of the call, the thread is blocked.\n• TAP (Task-based Asynchronous Pattern): This concept was improved by the introduction of async/await and types and .\n\nThe previous approaches were rendered obsolete due to the success of the last approach.\n\nTo create an asynchronous method, the method must be marked with the keyword , contain an inside, and the return value must be , or (not recommended).\n\nIn this example, the execution will take place like this:\n• First, the code preceding the call to the first asynchronous operation ( ) will be executed.\n• The first asynchronous operation is launched and expected to be executed. Meanwhile, the code to be called when the asynchronous operation is completed (the \"continuation\") will be saved.\n• After the first asynchronous operation is completed, the “continuation” — the code until the next asynchronous operation ( ) will start executing.\n• The second asynchronous operation ( ) is launched and expected to be executed. At the same time, the continuation — the code following the second asynchronous operation ( ) will be preserved.\n• After the completion of the second asynchronous operation, will be executed, followed by execution and waiting for the third asynchronous operation .\n\nThis is a simplified explanation, as in fact async/await is syntactic sugar to allow for convenient calling of asynchronous methods and waiting for their completion.\n\nYou can also organize any combination of execution orders using and :\n\nThe C# compiler transforms async/await calls into an state machine, which is a sequential set of actions that must be performed to complete the asynchronous operation.\n\nEvery time you call an await operation, the state machine completes its work and waits for the completion of that operation, after which it continues to execute the next operation. This allows asynchronous operations to be performed in the background without blocking the main thread, and also makes asynchronous method calls simpler and more readable.\n\nThus, the method is transformed into creating and initializing a state machine with the annotation , and the state machine itself has a number of states equal to the number of await calls.\n• Example of the transformed method\n\nIn the call, the current synchronization context will be obtained. SynchronizationContext is a concept in C# used to represent a context that controls the execution of a set of asynchronous operations. It is used to coordinate the execution of code across multiple threads and to ensure that code is executed in a specific order. The main purpose of SynchronizationContext is to provide a way to control the scheduling and execution of asynchronous operations in a multithreaded environment.\n\nIn different environments, the has different implementations. For example, in .NET, there are:\n\nUnity also has its own synchronization context, , which enables us to use asynchronous operations with binding to the PlayerLoop API. The following code example shows how to rotate an object in each frame using :\n\nAnother example of using async/await in Unity to make a network request:\n\nThanks to , we can safely use methods (such as ) right after an asynchronous operation has been completed, since the execution of this code will continue in the main Unity thread.\n\nThis class allows you to manage a object. It was created to adapt old asynchronous methods to TAP, but it’s also very useful when we want to wrap a around some long-running operation that upon some event.\n\nIn the following example, the object inside will complete after 3 seconds from start, and we’ll get its result in the method:\n\nA Cancellation Token is used in C# to signal that a task or operation should be canceled. The token is passed to the task or operation, and the code within the task or operation can check the token periodically to determine whether the task or operation should be stopped. This allows for a clean and graceful cancellation of a task or operation, instead of just abruptly killing it.\n\nCancellation Tokens are commonly used in situations where a long-running task can be cancelled by the user, or if the task is no longer needed, like a cancel button in a user interface.\n\nThe overall pattern resembles the use of . First, a is created, then its is passed to the asynchronous operation:\n\nWhen the operation is canceled, an will be thrown and the property will be set to .\n\nIt’s important to note that objects are managed by the .NET runtime, not by Unity, and if the object executing the task is destroyed (or if the game exits play mode in the editor), the task will continue to run as Unity has no means to cancel it.\n\nYou always need to accompany with the corresponding . This leads to some redundancy of code, and in Unity 2022.2 built-in tokens at the level and the entire level appeared.\n\nLet’s see how the previous example changes when using the of the object:\n\nWe no longer need to manually create a and complete the task in the method. For tasks not associated with a particular , we can use . This will terminate the task when exiting Play Mode (in Editor) or when quitting the application.\n\nDespite the convenience of using and the capabilities provided by .NET Tasks, they have significant drawbacks when used in Unity:\n• objects are too cumbersome and cause many allocations.\n• is not matched to Unity threading (single-thread).\n\nThe UniTask library bypasses these restrictions without using threads or . It achieves the absence of allocations by using the struct-based type.\n\nUniTask requires the .NET 4.x scripting runtime version, with Unity 2018.4.13f1 being the official lowest supported version.\n\nAlso you can convert all the to with extension methods:\n\nIn this example, the method uses to load an asset asynchronously. The method is then used to convert the returned by into a , which can be awaited.\n\nAs before, you can organize any combination of execution order using and :\n\nIn UniTask, there is another implementation of called which can be used to replace for better performance.\n\nIn the first alpha version of Unity 2023.1, the class was introduced. Awaitable Coroutines are async/await-compatible Task-like types designed to run in Unity. Unlike .NET Tasks, they are managed by the engine, not the runtime.\n\nThey can be awaited and used as the return type of an async method. Compared to , they are less sophisticated but take performance-enhancing shortcuts based on Unity-specific assumptions.\n\nHere are the main differences compared to .NET Tasks:\n• The object can only be awaited once; it cannot be awaited by multiple async functions.\n• won't block until completion. Calling it before the operation is finished is undefined behavior.\n• Never capture an . For security reasons, .NET Tasks capture execution contexts when awaiting in order to propagate impersonation contexts across asynchronous calls.\n• Never capture . Coroutine continuations are executed synchronously from the code that raises the completion. In most cases, this will be from the Unity main frame.\n• Awaitables are pooled objects to prevent excessive allocations. These are reference types, so they can be referenced across different stacks, copied efficiently, and so on. The has been improved to avoid bounds checks in typical get/release sequences generated by async state machines.\n\nTo obtain the result of a lengthy operation, you can use the type. You can manage the completion of an using and , similar to :\n\nSometimes it’s necessary to perform massive calculations that can lead to game freezes. For this, it is better to use Awaitable methods: and . They allow you to exit the main thread and return to it.\n\nThis way, Awaitables eliminate the drawbacks of using .NET Tasks and also allow for awaiting PlayerLoop events and AsyncOperations.\n\nAs we can see, with the development of Unity, there are more and more tools for organizing asynchronous operations:\n\nWe have considered all the main ways of asynchronous programming in Unity. Depending on the complexity of your task and the version of Unity you are using, you can use a wide range of technologies from Coroutines and Promises to Tasks and Awaitables, to ensure a smooth and seamless gameplay in your games. Thanks for reading, and we await your next masterpieces."
    },
    {
        "link": "https://docs.unity3d.com/550/Documentation/Manual/HOWTO-UICreateFromScripting.html",
        "document": "If you are creating a dynamic UI where UI elements appear, disappear, or change based on user actions or other actions in the game, you may need to make a script that instantiates new UI elements based on custom logic.\n\nIn order to be able to easily instantiate UI elements dynamically, the first step is to create a prefab for the type of UI element that you want to be able to instantiate. Set up the UI element the way you want it to look in the Scene, and then drag the element into the Project View to make it into a prefab.\n\nFor example, a prefab for a button could be a Game Object with a Image component and a Button component, and a child Game Object with a Text component. Your setup might be different depending on your needs.\n\nYou might wonder why we don’t have a API methods to create the various types of controls, including visuals and everything. The reason is that there are an infinite number of way e.g. a button could be setup. Does it use an image, text, or both? Maybe even multiple images? What is the text font, color, font size, and alignment? What sprite or sprites should the image use? By letting you make a prefab and instantiate that, you can set it up exactly the way you want. And if you later want to change the look and feel of your UI you can just change the prefab and then it will be reflected in your UI, including the dynamically created UI.\n\nPrefabs of UI elements are instantiated as normal using the Instantiate method. When setting the parent of the instantiated UI element, it’s recommended to do it using the Transform.SetParent method with the worldPositionStays parameter set to false.\n\nA UI Element is normally positioned using its Rect Transform. If the UI Element is a child of a Layout Group it will be automatically positioned and the positioning step can be skipped.\n\nWhen positioning a Rect Transform it’s useful to first determine it has or should have any stretching behavior or not. Stretching behavior happens when the anchorMin and anchorMax properties are not identical.\n\nFor a non-stretching Rect Transform, the position is set most easily by setting the anchoredPosition and the sizeDelta properties. The anchoredPosition specifies the position of the pivot relative to the anchors. The sizeDelta is just the same as the size when there’s no stretching.\n\nFor a stretching Rect Transform, it can be simpler to set the position using the offsetMin and offsetMax properties. The offsetMin property specifies the corner of the lower left corner of the rect relative to the lower left anchor. The offsetMax property specifies the corner of the upper right corner of the rect relative to the upper right anchor.\n\nIf you are instantiating multiple UI elements dynamically, it’s unlikely that you’ll want them all to look the same and do the same. Whether it’s buttons in a menu, items in an inventory, or something else, you’ll likely want the individual items to have different text or images and to do different things when interacted with.\n\nThis is done by getting the various components and changing their properties. See the scripting reference for the Image and Text components, and for how to work with UnityEvents from scripting."
    },
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/HOWTO-UICreateFromScripting.html",
        "document": "If you are creating a dynamic UI where UI elements appear, disappear, or change based on user actions or other actions in the game, you may need to make a script that instantiates new UI elements based on custom logic.\n\nIn order to be able to easily instantiate UI elements dynamically, the first step is to create a prefab for the type of UI element that you want to be able to instantiate. Set up the UI element the way you want it to look in the Scene, and then drag the element into the Project View to make it into a prefab.\n\nFor example, a prefab for a button could be a Game Object with a Image component and a Button component, and a child Game Object with a Text component. Your setup might be different depending on your needs.\n\nYou might wonder why we don't have a API methods to create the various types of controls, including visuals and everything. The reason is that there are an infinite number of way e.g. a button could be setup. Does it use an image, text, or both? Maybe even multiple images? What is the text font, color, font size, and alignment? What sprite or sprites should the image use? By letting you make a prefab and instantiate that, you can set it up exactly the way you want. And if you later want to change the look and feel of your UI you can just change the prefab and then it will be reflected in your UI, including the dynamically created UI.\n\nPrefabs of UI elements are instantiated as normal using the Instantiate method. When setting the parent of the instantiated UI element, it's recommended to do it using the Transform.SetParent method with the worldPositionStays parameter set to false.\n\nA UI Element is normally positioned using its Rect Transform. If the UI Element is a child of a Layout Group it will be automatically positioned and the positioning step can be skipped.\n\nWhen positioning a Rect Transform it's useful to first determine it has or should have any stretching behavior or not. Stretching behavior happens when the anchorMin and anchorMax properties are not identical.\n\nFor a non-stretching Rect Transform, the position is set most easily by setting the anchoredPosition and the sizeDelta properties. The anchoredPosition specifies the position of the pivot relative to the anchors. The sizeDelta is just the same as the size when there's no stretching.\n\nFor a stretching Rect Transform, it can be simpler to set the position using the offsetMin and offsetMax properties. The offsetMin property specifies the corner of the lower left corner of the rect relative to the lower left anchor. The offsetMax property specifies the corner of the upper right corner of the rect relative to the upper right anchor.\n\nIf you are instantiating multiple UI elements dynamically, it's unlikely that you'll want them all to look the same and do the same. Whether it's buttons in a menu, items in an inventory, or something else, you'll likely want the individual items to have different text or images and to do different things when interacted with.\n\nThis is done by getting the various components and changing their properties. See the scripting reference for the Image and Text components, and for how to work with UnityEvents from scripting."
    },
    {
        "link": "https://discussions.unity.com/t/is-there-an-instantiate-for-ui-elements/877975",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/new-gui-dynamically-created-from-script/548169",
        "document": ""
    },
    {
        "link": "https://docs.unity.cn/2020.2/Documentation/Manual/HOWTO-UICreateFromScripting.html",
        "document": "If you are creating a dynamic UI(User Interface) Allows a user to interact with your application. More info\n\nSee in Glossary where UI elements appear, disappear, or change based on user actions or other actions in the game, you may need to make a script that instantiates new UI elements based on custom logic.\n\nIn order to be able to easily instantiate UI elements dynamically, the first step is to create a prefabAn asset type that allows you to store a GameObject complete with components and properties. The prefab acts as a template from which you can create new object instances in the scene. More info\n\nSee in Glossary for the type of UI element that you want to be able to instantiate. Set up the UI element the way you want it to look in the SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary, and then drag the element into the Project View to make it into a prefab.\n\nFor example, a prefab for a button could be a Game Object with a Image component and a Button component, and a child Game Object with a Text component. Your setup might be different depending on your needs.\n\nYou might wonder why we don’t have a API methods to create the various types of controls, including visuals and everything. The reason is that there are an infinite number of way e.g. a button could be setup. Does it use an image, text, or both? Maybe even multiple images? What is the text font, color, font size, and alignment? What sprite or spritesA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary should the image use? By letting you make a prefab and instantiate that, you can set it up exactly the way you want. And if you later want to change the look and feel of your UI you can just change the prefab and then it will be reflected in your UI, including the dynamically created UI.\n\nPrefabs of UI elements are instantiated as normal using the Instantiate method. When setting the parent of the instantiated UI element, it’s recommended to do it using the Transform.SetParent method with the worldPositionStays parameter set to false.\n\nA UI Element is normally positioned using its Rect Transform. If the UI Element is a child of a Layout Group it will be automatically positioned and the positioning step can be skipped.\n\nWhen positioning a Rect Transform it’s useful to first determine it has or should have any stretching behavior or not. Stretching behavior happens when the anchorMin and anchorMax properties are not identical.\n\nFor a non-stretching Rect Transform, the position is set most easily by setting the anchoredPosition and the sizeDelta properties. The anchoredPosition specifies the position of the pivot relative to the anchors. The sizeDelta is just the same as the size when there’s no stretching.\n\nFor a stretching Rect Transform, it can be simpler to set the position using the offsetMin and offsetMax properties. The offsetMin property specifies the corner of the lower left corner of the rect relative to the lower left anchor. The offsetMax property specifies the corner of the upper right corner of the rect relative to the upper right anchor.\n\nIf you are instantiating multiple UI elements dynamically, it’s unlikely that you’ll want them all to look the same and do the same. Whether it’s buttons in a menu, items in an inventory, or something else, you’ll likely want the individual items to have different text or images and to do different things when interacted with.\n\nThis is done by getting the various components and changing their properties. See the scripting reference for the Image and Text components, and for how to work with UnityEvents from scripting."
    }
]