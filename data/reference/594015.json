[
    {
        "link": "https://github.com/spatie/laravel-sluggable",
        "document": "This package provides a trait that will generate a unique slug when saving any Eloquent model.\n\nThe slugs are generated with Laravels method, whereby spaces are converted to '-'.\n\nSpatie is a webdesign agency based in Antwerp, Belgium. You'll find an overview of all our open source projects on our website.\n\nWe invest a lot of resources into creating best in class open source packages. You can support us by buying one of our paid products.\n\nWe highly appreciate you sending us a postcard from your hometown, mentioning which of our package(s) you are using. You'll find our address on our contact page. We publish all received postcards on our virtual postcard wall.\n\nYou can install the package via composer:\n\nYour Eloquent models should use the trait and the class.\n\nThe trait contains an abstract method that you must implement yourself.\n\nYour models' migrations should have a field to save the generated slug to.\n\nHere's an example of how to implement the trait:\n\nTo use the generated slug in routes, remember to use Laravel's implicit route model binding:\n\nWant to use multiple field as the basis for a slug? No problem!\n\nYou can also pass a to .\n\nBy default the package will generate unique slugs by appending '-' and a number, to a slug that already exists.\n\nYou can disable this behaviour by calling .\n\nYou can also put a maximum size limit on the created slug:\n\nThe slug may be slightly longer than the value specified, due to the suffix which is added to make it unique.\n\nYou can also use a custom separator by calling\n\nTo set the language used by you may call\n\nYou can also override the generated slug just by setting it to another value than the generated slug.\n\nIf you don't want to create the slug when the model has a state, you can use the function.\n\nIf you don't want to create the slug when the model is initially created you can set use the function.\n\nSimilarly, if you want to prevent the slug from being updated on model updates, call .\n\nThis can be helpful for creating permalinks that don't change until you explicitly want it to.\n\nIf you want to explicitly update the slug on the model you can call on your model at any time to make the slug according to your other options. Don't forget to the model to persist the update to your database.\n\nYou can prevent slugs from being overwritten.\n\nIf you have a global scope that should be taken into account, you can define this as well with . For example if you have a pages table containing pages of multiple websites and every website has it's own unique slugs.\n\nBy default, suffix index starts from 1, you can set starting number.\n\nWith the default behavior (assuming that we haven't disabled slug uniqueness with ), the generated slugs for two records with the same source values would be and .\n\nWhen using this option, we are forcing the first occurence to also have a suffix so, even if the slug is unique as it is, it will be suffixed, resulting in and .\n\nBy default, the mechanism to make slugs unique is to append an autoincremental value to the slug. You can generate a custom slug suffix such as a random string or hash with .\n\nIt accepts a callable that receives the base slug (without any suffix) and the iteration number, which represents how many times the suffix generation process has been run to ensure uniqueness. This number could be useful to monitor the collision rate of the generation process.\n\nYou can use this package along with laravel-translatable to generate a slug for each locale. Instead of using the trait, you must use the trait, and add the name of the slug field to the array. For slugs that are generated from a single field or multiple fields, you don't have to change anything else.\n\nFor slugs that are generated from a callable, you need to instantiate the with the method. The callable now takes two arguments instead of one. Both the and the are available to generate a slug from.\n\nYou can also use Laravels implicit route model binding inside your controller to automatically resolve the model. To use this feature, make sure that the slug column matches the .\n\n Currently, only some database types support JSON operations. Further information about which databases support JSON can be found in the Laravel docs.\n\nFor convenience, you can use the alias to retrieve a model. The query will compare against the field passed to when defining the .\n\nalso accepts a second parameter just like the default Eloquent method.\n\nPlease see CHANGELOG for more information what has changed recently.\n\nPlease see CONTRIBUTING for details.\n\nIf you've found a bug regarding security please mail security@spatie.be instead of using the issue tracker.\n\nThe MIT License (MIT). Please see License File for more information."
    },
    {
        "link": "https://medium.com/weakly-typed/laravel-sluggable-with-in-depth-explanation-d415e13e3a4d",
        "document": "laravel itself supports slugs and have a function to build slugs ( remove spaces and illegal characters) and if you are on older versions of laravel you should have it as a helper method but but if you want to be efficient and don't reinvent the wheel its almost always a good idea to use library's . at the time i was writing two third party libraries exist for creating slug cviebrock/eloquent-sluggable and other one by spatie . i ll go with cviebrock here\n\nand now we just need to add the trait to our model and its done . it will automatically create slug every time new record is creating\n\nyou just say where should it get the text and it will do the rest for you.\n\nMore Advanced Stuff :) — now we get to the issue i had with sluggable\n\nso sluggable is use one field as a source e.g. and create the slug in the field in database .\n\nwhat i wanted to do was to pass the slug for the post as so its formatted correctly before save. but apparently the source cant be too.\n\nhopefully the package has a that helps you customize . so i used the and build a method to do this .\n\nand as i wanted to Don’t Repeat Myself :) i created a trait for that.\n\nthe sluggable method is required by package but as you may have noticed there is no need to fill the config in it as we are doing the work ourselves.\n\ntell me what you thing about it or ask me any question if you have any"
    },
    {
        "link": "https://github.com/cviebrock/eloquent-sluggable",
        "document": "Easy creation of slugs for your Eloquent models in Laravel.\n\nA slug is a simplified version of a string, typically URL-friendly. The act of \"slugging\" a string usually involves converting it to one case, and removing any non-URL-friendly characters (spaces, accented letters, ampersands, etc.). The resulting string can then be used as an identifier for a particular resource.\n\nFor example, if you have a blog with posts, you could refer to each post via the ID:\n\n... but that's not particularly friendly (especially for SEO). You probably would prefer to use the post's title in the URL, but that becomes a problem if your post is titled \"My Dinner With André & François\", because this is pretty ugly too:\n\nThe solution is to create a slug for the title and use that instead. You might want to use Laravel's built-in method to convert that title into something friendlier:\n\nA URL like that will make users happier (it's readable, easier to type, etc.).\n\nFor more information, you might want to read this description on Wikipedia.\n\nSlugs tend to be unique as well. So if you write another post with the same title, you'd want to distinguish between them somehow, typically with an incremental counter added to the end of the slug:\n\nThis keeps the URLs unique.\n\nThe Eloquent-Sluggable package for Laravel aims to handle all of this for you automatically, with minimal configuration.\n\nDepending on your version of Laravel, you should install a different version of the package.\n\nOlder versions of Laravel can use older versions of the package, although they are no longer supported or maintained. See CHANGELOG.md and UPGRADING.md for specifics, and be sure that you are reading the correct README.md for your version (GitHub displays the version in the master branch by default, which might not be what you want).\n• The package will automatically register its service provider.\n• Optionally, publish the configuration file if you want to change any defaults:\n\nYour models should use the Sluggable trait, which has an abstract method that you need to define. This is where any model-specific configuration is set (see Configuration below for details):\n\nOf course, your model and database will need a column in which to store the slug. You can use or any other appropriate name you want; your configuration array will determine to which field the data will be stored. You will need to add the column (which should be ) manually via your own migration.\n\nThat's it ... your model is now \"sluggable\"!\n\nSo is retrieving the slug:\n\nAll the logic to generate slugs is handled by the class.\n\nGenerally, you don't need to access this class directly, although there is one static method that can be used to generate a slug for a given string without actually creating or saving an associated model.\n\nThis would be useful for Ajax-y controllers or the like, where you want to show a user what the unique slug would be for a given test input, before actually creating a model. The first two arguments to the method are the model and slug field being tested, and the third argument is the source string to use for testing the slug.\n\nYou can also pass an optional array of configuration values as the fourth argument. These will take precedence over the normal configuration values for the slug field being tested. For example, if your model is configured to use unique slugs, but you want to generate the \"base\" version of a slug for some reason, you could do:\n\nCurrently, the model is slugged on Eloquent's event. This means that the slug is generated before any new data is written to the database.\n\nFor new models, this means that the primary key has not yet been set, so it could not be used as part of the slug source, e.g.:\n\nis before the model is saved. The benefit of hooking into the event, however, is that we only needed to make one database query to save all the model's data, including the slug.\n\nOptional, the model can be slugged on Eloquent's event.\n\n This means that all the other model attributes will have already been persisted to the database and are available for use as slug sources. So the above configuration would work. The only drawback is that saving the model to the database requires one extra query: the first one to save all the non-slug fields, and then a second one to update just the slug field.\n\nThis behaviour is a breaking change, and likely won't affect most users (unless you are doing some pre-saving validation on a model's slug field). We feel the benefits outweigh the drawbacks, and so this will likely become the new default behaviour in a future major release of the package. Although, to make the transition easier, you can configure this behaviour via the method the trait provides:\n\nKeep in mind that you will need to use if you want to use your model's primary key as part of the source fields for your slugs.\n\nSluggable models will fire two Eloquent model events: \"slugging\" and \"slugged\".\n\nThe \"slugging\" event is fired just before the slug is generated. If the callback from this event returns , then the slugging is not performed. If anything else is returned, including , then the slugging will be performed.\n\nThe \"slugged\" event is fired just after a slug is generated. It won't be called in the case where the model doesn't need slugging (as determined by the method).\n\nYou can hook into either of these events just like any other Eloquent model event:\n\nConfiguration was designed to be as flexible as possible. You can set up defaults for all of your Eloquent models, and then override those settings for individual models.\n\nBy default, global configuration is set in the file. If a configuration isn't set, then the package defaults are used. Here is an example configuration, with all the default settings shown:\n\nFor individual models, configuration is handled in the method that you need to implement. That method should return an indexed array where the keys represent the fields where the slug value is stored and the values are the configuration for that field. This means you can create multiple slugs for the same model, based on different source strings and with different configuration options.\n\nThis is the field or array of fields from which to build the slug. Each is concatenated (with space separation) to build the sluggable string. These can be model attributes (i.e. fields in the database), relationship attributes, or custom getters.\n\nTo reference fields from related models, use dot-notation. For example, the slug for the following book will be generated from its author's name and the book's title:\n\nAn example using a custom getter:\n\nIf is empty, false or null, then the value of is used as the source for slug generation.\n\nDefines the method used to turn the sluggable string into a slug. There are three possible options for this configuration:\n• When is null (the default setting), the package uses the default slugging engine -- cocur/slugify -- to create the slug.\n• When is a callable, then that function or class method is used. The function/method should expect two parameters: the string to process, and a separator string. For example, to use Laravel's , you could do:\n• You can also define as a closure (again, expecting two parameters):\n\nAny other values for will throw an exception.\n\nFor more complex slugging requirements, see Extending Sluggable below.\n\nBy default, updating a model will not try and generate a new slug value. It is assumed that once your slug is generated, you won't want it to change (this may be especially true if you are using slugs for URLs and don't want to mess up your SEO mojo).\n\nIf you want to regenerate one or more of your model's slug fields, you can set those fields to null or an empty string before the update:\n\nIf this is the behaviour you want every time you update a model, then set the option to true.\n\nThis defines the separator used when building a slug, and is passed to the defined above. The default value is a hyphen.\n\nThis is a boolean defining whether slugs should be unique among all models of the given type. For example, if you have two blog posts and both are called \"My Blog Post\", then they will both sluggify to \"my-blog-post\" if is false. This could be a problem, e.g. if you use the slug in URLs.\n\nBy setting to true, then the second Post model will sluggify to \"my-blog-post-1\". If there is a third post with the same title, it will sluggify to \"my-blog-post-2\" and so on. Each subsequent model will get an incremental value appended to the end of the slug, ensuring uniqueness.\n\nIf you want to use a different way of identifying uniqueness (other than auto-incrementing integers), you can set the configuration to a function or callable that generates the \"unique\" values for you.\n\nThe function should take four parameters:\n• an of all the other slug strings that start with the same slug\n• the first suffix to use (for the first slug that needs to be made unique) You can then do whatever you want to create a new suffix that hasn't been used by any of the slugs in the collection. For example, if you wanted to use letters instead of numbers as a suffix, this is one way to achieve that:\n\nWhen adding a unique suffix, we start counting at \"2\", so that the list of generated slugs would look something like:\n\nIf you want to start counting at a different number (or pass a different value into your custom function above), then you can define it here.\n\nSetting this to will also check deleted models when trying to enforce uniqueness. This only affects Eloquent models that are using the softDelete feature. Default is , so soft-deleted models don't count when checking for uniqueness.\n\nAn array of values that will never be allowed as slugs, e.g. to prevent collisions with existing routes or controller methods, etc.. This can be an array, or a closure that returns an array. Defaults to : no reserved slug names.\n\nSetting this to a positive integer will ensure that your generated slugs are restricted to a maximum length (e.g. to ensure that they fit within your database fields). By default, this value is null and no limit is enforced.\n\nIf you are truncating your slugs with the setting, than you probably want to ensure that your slugs don't get truncated in the middle of a word. For example, if your source string is \"My First Post\", and your is 10, the generated slug would end up being \"my-first-p\", which isn't ideal.\n\nBy default, the value is set to true which would trim the partial words off the end of the slug, resulting in \"my-first\" instead of \"my-first-p\".\n\nIf you want to keep partial words, then set this configuration to false.\n\nWhen is null (the default setting), the package uses the default slugging engine -- cocur/slugify -- to create the slug. If you want to pass a custom set of options to the Slugify constructor when the engine is instantiated, this is where you would define that. See the documentation for Slugify for what those options are. Also, look at customizeSlugEngine for other ways to customize Slugify for slugging.\n\nA common use for this is to turn on a different ruleset for a specific language. For example the string will slug to using the default settings. In Finnish, it really should slug to , so for that to work, you need to enable the Finnish ruleset for the attribute you are slugging:\n\nThis can also be accomplished with the customizeSlugEngine method (which, unless you add custom logic, will apply to all attributes on the model):\n\nThe package supports a really short configuration syntax, if you are truly lazy:\n\nThis will use all the default options from , use the model's method as the source, and store the slug in the field.\n\nSometimes the configuration options aren't sufficient for complex needs (e.g. maybe the uniqueness test needs to take other attributes into account).\n\nIn instances like these, the package offers hooks into the slugging workflow where you can use your own functions, either on a per-model basis, or in your own trait that extends the package's trait.\n\nIf you extend this method, the Slugify engine can be customized before slugging occurs. This might be where you change the character mappings that are used, or alter language files, etc..\n\nYou can customize the engine on a per-model and per-attribute basis (maybe your model has two slug fields, and one of them needs customization).\n\nTake a look at for an example.\n\nAlso, take a look at the slugEngineOptions configuration for other ways to customize Slugify.\n\nThis method is applied to the query that is used to determine if a given slug is unique. The arguments passed to the scope are:\n• -- the configuration array for the given model and attribute\n• -- the \"base\" slug (before any unique suffixes are applied)\n\nFeel free to use these values anyway you like in your query scope. As an example, look at where the slug is generated for a post from its title, but the slug is scoped to the author. So Bob can have a post with the same title as Pam's post, but both will have the same slug.\n\nThis is the default scope for finding \"similar\" slugs for a model. Basically, the package looks for existing slugs that are the same as the argument, or that start with plus the separator string. The resulting collection is what is passed to the handler.\n\nGenerally, this query scope (which is defined in the Sluggable trait) should be left alone. However, you are free to overload it in your models.\n\nAdding the optional trait to your model allows you to work with models and their slugs. For example:\n\nBecause models can have more than one slug, this requires a bit more configuration. See SCOPE-HELPERS.md for all the details.\n\nThanks to everyone who has contributed to this project!\n\nPlease use GitHub for reporting bugs, and making comments or suggestions.\n\nSee CONTRIBUTING.md for how to contribute changes.\n\neloquent-sluggable was written by Colin Viebrock and is released under the MIT License."
    },
    {
        "link": "https://laravel.com/docs/11.x/routing",
        "document": "WARNING You're browsing the documentation for an old version of Laravel. Consider upgrading your project to Laravel 12.x .\n\nThe most basic Laravel routes accept a URI and a closure, providing a very simple and expressive method of defining routes and behavior without complicated routing configuration files:\n\nAll Laravel routes are defined in your route files, which are located in the directory. These files are automatically loaded by Laravel using the configuration specified in your application's file. The file defines routes that are for your web interface. These routes are assigned the middleware group, which provides features like session state and CSRF protection.\n\nFor most applications, you will begin by defining routes in your file. The routes defined in may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to in your browser:\n\nIf your application will also offer a stateless API, you may enable API routing using the Artisan command:\n\nThe command installs Laravel Sanctum, which provides a robust, yet simple API token authentication guard which can be used to authenticate third-party API consumers, SPAs, or mobile applications. In addition, the command creates the file:\n\nThe routes in are stateless and are assigned to the middleware group. Additionally, the URI prefix is automatically applied to these routes, so you do not need to manually apply it to every route in the file. You may change the prefix by modifying your application's file:\n\nThe router allows you to register routes that respond to any HTTP verb:\n\nSometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the method. Or, you may even register a route that responds to all HTTP verbs using the method:\n\nYou may type-hint any dependencies required by your route in your route's callback signature. The declared dependencies will automatically be resolved and injected into the callback by the Laravel service container. For example, you may type-hint the class to have the current HTTP request automatically injected into your route callback:\n\nRemember, any HTML forms pointing to , , , or routes that are defined in the routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the CSRF documentation:\n\nIf you are defining a route that redirects to another URI, you may use the method. This method provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect:\n\nBy default, returns a status code. You may customize the status code using the optional third parameter:\n\nOr, you may use the method to return a status code:\n\nIf your route only needs to return a view, you may use the method. Like the method, this method provides a simple shortcut so that you do not have to define a full route or controller. The method accepts a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass to the view as an optional third argument:\n\nThe Artisan command can easily provide an overview of all of the routes that are defined by your application:\n\nBy default, the route middleware that are assigned to each route will not be displayed in the output; however, you can instruct Laravel to display the route middleware and middleware group names by adding the option to the command:\n\nYou may also instruct Laravel to only show routes that begin with a given URI:\n\nIn addition, you may instruct Laravel to hide any routes that are defined by third-party packages by providing the option when executing the command:\n\nLikewise, you may also instruct Laravel to only show routes that are defined by third-party packages by providing the option when executing the command:\n\nBy default, your application's routes are configured and loaded by the file:\n\nHowever, sometimes you may want to define an entirely new file to contain a subset of your application's routes. To accomplish this, you may provide a closure to the method. Within this closure, you may register any additional routes that are necessary for your application:\n\nOr, you may even take complete control over route registration by providing a closure to the method. When this argument is passed, no HTTP routes will be registered by the framework and you are responsible for manually registering all routes:\n\nSometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters:\n\nYou may define as many route parameters as required by your route:\n\nRoute parameters are always encased within braces and should consist of alphabetic characters. Underscores ( ) are also acceptable within route parameter names. Route parameters are injected into route callbacks / controllers based on their order - the names of the route callback / controller arguments do not matter.\n\nIf your route has dependencies that you would like the Laravel service container to automatically inject into your route's callback, you should list your route parameters after your dependencies:\n\nOccasionally you may need to specify a route parameter that may not always be present in the URI. You may do so by placing a mark after the parameter name. Make sure to give the route's corresponding variable a default value:\n\nYou may constrain the format of your route parameters using the method on a route instance. The method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:\n\nFor convenience, some commonly used regular expression patterns have helper methods that allow you to quickly add pattern constraints to your routes:\n\nIf the incoming request does not match the route pattern constraints, a 404 HTTP response will be returned.\n\nIf you would like a route parameter to always be constrained by a given regular expression, you may use the method. You should define these patterns in the method of your application's class:\n\nOnce the pattern has been defined, it is automatically applied to all routes using that parameter name:\n\nThe Laravel routing component allows all characters except to be present within route parameter values. You must explicitly allow to be part of your placeholder using a condition regular expression:\n\nNamed routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the method onto the route definition:\n\nYou may also specify route names for controller actions:\n\nOnce you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via Laravel's and helper functions:\n\nIf the named route defines parameters, you may pass the parameters as the second argument to the function. The given parameters will automatically be inserted into the generated URL in their correct positions:\n\nIf you pass additional parameters in the array, those key / value pairs will automatically be added to the generated URL's query string:\n\nIf you would like to determine if the current request was routed to a given named route, you may use the method on a Route instance. For example, you may check the current route name from a route middleware:\n\nRoute groups allow you to share route attributes, such as middleware, across a large number of routes without needing to define those attributes on each individual route.\n\nNested groups attempt to intelligently \"merge\" attributes with their parent group. Middleware and conditions are merged while names and prefixes are appended. Namespace delimiters and slashes in URI prefixes are automatically added where appropriate.\n\nTo assign middleware to all routes within a group, you may use the method before defining the group. Middleware are executed in the order they are listed in the array:\n\nIf a group of routes all utilize the same controller, you may use the method to define the common controller for all of the routes within the group. Then, when defining the routes, you only need to provide the controller method that they invoke:\n\nRoute groups may also be used to handle subdomain routing. Subdomains may be assigned route parameters just like route URIs, allowing you to capture a portion of the subdomain for usage in your route or controller. The subdomain may be specified by calling the method before defining the group:\n\nThe method may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with :\n\nThe method may be used to prefix each route name in the group with a given string. For example, you may want to prefix the names of all of the routes in the group with . The given string is prefixed to the route name exactly as it is specified, so we will be sure to provide the trailing character in the prefix:\n\nWhen injecting a model ID to a route or controller action, you will often query the database to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire model instance that matches the given ID.\n\nLaravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example:\n\nSince the variable is type-hinted as the Eloquent model and the variable name matches the URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated.\n\nOf course, implicit binding is also possible when using controller methods. Again, note the URI segment matches the variable in the controller which contains an type-hint:\n\nTypically, implicit model binding will not retrieve models that have been soft deleted. However, you may instruct the implicit binding to retrieve these models by chaining the method onto your route's definition:\n\nSometimes you may wish to resolve Eloquent models using a column other than . To do so, you may specify the column in the route parameter definition:\n\nIf you would like model binding to always use a database column other than when retrieving a given model class, you may override the method on the Eloquent model:\n\nWhen implicitly binding multiple Eloquent models in a single route definition, you may wish to scope the second Eloquent model such that it must be a child of the previous Eloquent model. For example, consider this route definition that retrieves a blog post by slug for a specific user:\n\nWhen using a custom keyed implicit binding as a nested route parameter, Laravel will automatically scope the query to retrieve the nested model by its parent using conventions to guess the relationship name on the parent. In this case, it will be assumed that the model has a relationship named (the plural form of the route parameter name) which can be used to retrieve the model.\n\nIf you wish, you may instruct Laravel to scope \"child\" bindings even when a custom key is not provided. To do so, you may invoke the method when defining your route:\n\nOr, you may instruct an entire group of route definitions to use scoped bindings:\n\nSimilarly, you may explicitly instruct Laravel to not scope bindings by invoking the method:\n\nTypically, a 404 HTTP response will be generated if an implicitly bound model is not found. However, you may customize this behavior by calling the method when defining your route. The method accepts a closure that will be invoked if an implicitly bound model cannot be found:\n\nPHP 8.1 introduced support for Enums. To complement this feature, Laravel allows you to type-hint a string-backed Enum on your route definition and Laravel will only invoke the route if that route segment corresponds to a valid Enum value. Otherwise, a 404 HTTP response will be returned automatically. For example, given the following Enum:\n\nYou may define a route that will only be invoked if the route segment is or . Otherwise, Laravel will return a 404 HTTP response:\n\nYou are not required to use Laravel's implicit, convention based model resolution in order to use model binding. You can also explicitly define how route parameters correspond to models. To register an explicit binding, use the router's method to specify the class for a given parameter. You should define your explicit model bindings at the beginning of the method of your class:\n\nNext, define a route that contains a parameter:\n\nSince we have bound all parameters to the model, an instance of that class will be injected into the route. So, for example, a request to will inject the instance from the database which has an ID of .\n\nIf a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.\n\nIf you wish to define your own model binding resolution logic, you may use the method. The closure you pass to the method will receive the value of the URI segment and should return the instance of the class that should be injected into the route. Again, this customization should take place in the method of your application's :\n\nAlternatively, you may override the method on your Eloquent model. This method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:\n\nIf a route is utilizing implicit binding scoping, the method will be used to resolve the child binding of the parent model:\n\nUsing the method, you may define a route that will be executed when no other route matches the incoming request. Typically, unhandled requests will automatically render a \"404\" page via your application's exception handler. However, since you would typically define the route within your file, all middleware in the middleware group will apply to the route. You are free to add additional middleware to this route as needed:\n\nLaravel includes powerful and customizable rate limiting services that you may utilize to restrict the amount of traffic for a given route or group of routes. To get started, you should define rate limiter configurations that meet your application's needs.\n\nRate limiters may be defined within the method of your application's class:\n\nRate limiters are defined using the facade's method. The method accepts a rate limiter name and a closure that returns the limit configuration that should apply to routes that are assigned to the rate limiter. Limit configuration are instances of the class. This class contains helpful \"builder\" methods so that you can quickly define your limit. The rate limiter name may be any string you wish:\n\nIf the incoming request exceeds the specified rate limit, a response with a 429 HTTP status code will automatically be returned by Laravel. If you would like to define your own response that should be returned by a rate limit, you may use the method:\n\nSince rate limiter callbacks receive the incoming HTTP request instance, you may build the appropriate rate limit dynamically based on the incoming request or authenticated user:\n\nSometimes you may wish to segment rate limits by some arbitrary value. For example, you may wish to allow users to access a given route 100 times per minute per IP address. To accomplish this, you may use the method when building your rate limit:\n\nTo illustrate this feature using another example, we can limit access to the route to 100 times per minute per authenticated user ID or 10 times per minute per IP address for guests:\n\nIf needed, you may return an array of rate limits for a given rate limiter configuration. Each rate limit will be evaluated for the route based on the order they are placed within the array:\n\nIf you're assigning multiple rate limits segmented by identical values, you should ensure that each value is unique. The easiest way to achieve this is to prefix the values given to the method:\n\nRate limiters may be attached to routes or route groups using the middleware. The throttle middleware accepts the name of the rate limiter you wish to assign to the route:\n\nBy default, the middleware is mapped to the class. However, if you are using Redis as your application's cache driver, you may wish to instruct Laravel to use Redis to manage rate limiting. To do so, you should use the method in your application's file. This method maps the middleware to the middleware class:\n\nHTML forms do not support , , or actions. So, when defining , , or routes that are called from an HTML form, you will need to add a hidden field to the form. The value sent with the field will be used as the HTTP request method:\n\nFor convenience, you may use the Blade directive to generate the input field:\n\nYou may use the , , and methods on the facade to access information about the route handling the incoming request:\n\nYou may refer to the API documentation for both the underlying class of the Route facade and Route instance to review all of the methods that are available on the router and route classes.\n\nLaravel can automatically respond to CORS HTTP requests with values that you configure. The requests will automatically be handled by the middleware that is automatically included in your application's global middleware stack.\n\nSometimes, you may need to customize the CORS configuration values for your application. You may do so by publishing the configuration file using the Artisan command:\n\nThis command will place a configuration file within your application's directory.\n\nWhen deploying your application to production, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. To generate a route cache, execute the Artisan command:\n\nAfter running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the command during your project's deployment.\n\nYou may use the command to clear the route cache:"
    },
    {
        "link": "https://laravel-news.com/package/cviebrock-eloquent-sluggable",
        "document": "Eloquent-Sluggable is a Laravel package designed to easily handle the creation and management of slugs for Eloquent models. It automates slug generation, ensuring they are SEO-friendly and unique, with minimal setup required.\n• Unique Slugs: Ensures slugs are unique and provides options to customize the uniqueness constraint.\n• Support for Multiple Slugs: Ability to handle multiple slugs per model based on different attributes.\n\nInstallation varies with Laravel versions, so ensure you install the correct package version matching your Laravel installation:\n\nImplement the trait in your model and define the method to specify the source field and other options:\n\nThe slug is then automatically generated and saved when the model is created or updated. Access it simply via .\n• Custom Slug Generation: Override default settings per model for source fields and slug generation methods.\n• Event System: Utilize and events to add custom logic during the slug lifecycle.\n• Scopes and Helpers: Use scope helpers for slug-based queries and leverage custom query scopes to refine slug generation rules.\n\nFor developers looking to streamline their application URLs and improve SEO, Eloquent-Sluggable provides a robust, flexible solution for managing slugs in Laravel applications. The package simplifies the complexity behind slug generation and ensures that slugs are both readable and unique, enhancing the overall user experience."
    },
    {
        "link": "https://stackoverflow.com/questions/37859974/laravel-how-to-properly-generate-unique-slugs-from-article-titles",
        "document": "I need to generate unique slugs based on titles of articles. For matching slugs I want to append a number to the end to make them unique. I made this function based on others work I found around:\n\nThe problem: As you can see I try to generate new slugs by using Laravel's str_slug function which will convert a string to a slug form. I then try to query the existing slugs from the databse, order them descendingly (high > low) and take essentialy the highest one within the ordered set. The problem is that MySQL orders them of course as strings and so slug-title-9 would be actually considered higher than slug-title-10 because it's ordering them as characters and not based on the value of the number at the end. How can I make this work? Is there a way to order them based on the last number or am I going in the wrong direction?\n\nI have seen other implementations where people query all the simmilar slugs at once, count them and then append count+1 to the end of the new slug. This is bad because if you delete some articles the overall count would lower and the new slug could conflict with an older one.\n\nI have seen an implementation where a person would append 1 to end of the slug and check if it exists. If it exists they would instead append 2 and try to check if that exists and so one until they find for example slug-title-9 which would not exists. IMO this is bad because you are putting unnecessary strain on the database.\n\nI need a decent solution because the project I am working on has a decend potential of encountering matching slugs often."
    },
    {
        "link": "https://medium.com/weakly-typed/laravel-sluggable-with-in-depth-explanation-d415e13e3a4d",
        "document": "laravel itself supports slugs and have a function to build slugs ( remove spaces and illegal characters) and if you are on older versions of laravel you should have it as a helper method but but if you want to be efficient and don't reinvent the wheel its almost always a good idea to use library's . at the time i was writing two third party libraries exist for creating slug cviebrock/eloquent-sluggable and other one by spatie . i ll go with cviebrock here\n\nand now we just need to add the trait to our model and its done . it will automatically create slug every time new record is creating\n\nyou just say where should it get the text and it will do the rest for you.\n\nMore Advanced Stuff :) — now we get to the issue i had with sluggable\n\nso sluggable is use one field as a source e.g. and create the slug in the field in database .\n\nwhat i wanted to do was to pass the slug for the post as so its formatted correctly before save. but apparently the source cant be too.\n\nhopefully the package has a that helps you customize . so i used the and build a method to do this .\n\nand as i wanted to Don’t Repeat Myself :) i created a trait for that.\n\nthe sluggable method is required by package but as you may have noticed there is no need to fill the config in it as we are doing the work ourselves.\n\ntell me what you thing about it or ask me any question if you have any"
    },
    {
        "link": "https://priyashpatil.com/posts/laravel-slugs-generating-and-using-slugs-for-clean-urls",
        "document": "A slug is a user-friendly URL segment that represents a page on a website. It is usually generated from the title of the page and contains only alphanumeric characters, hyphens, and underscores. Slugs are used to create cleaner and more readable URLs, which can improve a website’s search engine ranking and make it easier for users to navigate the site.\n\nIn Laravel, generating a slug is a relatively simple process. Laravel provides a helper function that can be used to generate a slug from a string. Here’s an example:\n\nThe function converts the string to lowercase, removes any non-alphanumeric characters, and replaces spaces with hyphens. The resulting slug would be .\n\nAs you know generating a slug is very simple in Laravel. However, configuring and extending the slug feature by yourself can be time-consuming. For this post, I’m going to use the package laravel-sluggable by Spatie. Spatie is a well-known developer in the Laravel Community.\n\nYou can install the package via Composer:\n\nYour Eloquent models should use the trait and the class. The trait contains an abstract method that you must implement yourself. Your models’ migrations should have a field to save the generated slug to.\n\nHere’s an example of how to implement the trait:\n\nYou can add more configurations like when or whether to create or update the slug by customising the slug generation.\n\nYou can also use slugs in Laravel models to make it easier to retrieve records based on their slugs. Here’s an example:\n\nThis method overrides the default method in the Laravel class and returns the name of the column that should be used to retrieve records based on their slugs. In this case, it returns the column.\n\nOnce you have generated a slug for a page, you can use it in Laravel routes to create clean and readable URLs. Here’s an example:\n\nThis route will match any URL that starts with and has a slug as its second segment. The method will be called to handle the request, and the slug parameter will be passed to the method.\n\nFinally, you can use slugs in Laravel views to create links to pages with clean and readable URLs. Here’s an example:\n\nThis link will point to the page with the slug that is stored in the attribute. The function will generate the URL based on the route and the slug parameter.\n\nUsing slugs is a simple and effective way to create clean and SEO-friendly URLs in Laravel. By generating slugs from page titles and using them in routes, models, and views, you can make your website more user-friendly and improve its search engine ranking. Hopefully, this blog post has provided some helpful tips for generating and using slugs in Laravel.\n\nKeep the Conversation Going\n\nI hope you found this post helpful! If you have any questions or feedback, feel free to reach out. You can also find me on X (Twitter) @_priyashpatil for additional insights and updates on my latest content."
    },
    {
        "link": "https://github.com/cviebrock/eloquent-sluggable",
        "document": "Easy creation of slugs for your Eloquent models in Laravel.\n\nA slug is a simplified version of a string, typically URL-friendly. The act of \"slugging\" a string usually involves converting it to one case, and removing any non-URL-friendly characters (spaces, accented letters, ampersands, etc.). The resulting string can then be used as an identifier for a particular resource.\n\nFor example, if you have a blog with posts, you could refer to each post via the ID:\n\n... but that's not particularly friendly (especially for SEO). You probably would prefer to use the post's title in the URL, but that becomes a problem if your post is titled \"My Dinner With André & François\", because this is pretty ugly too:\n\nThe solution is to create a slug for the title and use that instead. You might want to use Laravel's built-in method to convert that title into something friendlier:\n\nA URL like that will make users happier (it's readable, easier to type, etc.).\n\nFor more information, you might want to read this description on Wikipedia.\n\nSlugs tend to be unique as well. So if you write another post with the same title, you'd want to distinguish between them somehow, typically with an incremental counter added to the end of the slug:\n\nThis keeps the URLs unique.\n\nThe Eloquent-Sluggable package for Laravel aims to handle all of this for you automatically, with minimal configuration.\n\nDepending on your version of Laravel, you should install a different version of the package.\n\nOlder versions of Laravel can use older versions of the package, although they are no longer supported or maintained. See CHANGELOG.md and UPGRADING.md for specifics, and be sure that you are reading the correct README.md for your version (GitHub displays the version in the master branch by default, which might not be what you want).\n• The package will automatically register its service provider.\n• Optionally, publish the configuration file if you want to change any defaults:\n\nYour models should use the Sluggable trait, which has an abstract method that you need to define. This is where any model-specific configuration is set (see Configuration below for details):\n\nOf course, your model and database will need a column in which to store the slug. You can use or any other appropriate name you want; your configuration array will determine to which field the data will be stored. You will need to add the column (which should be ) manually via your own migration.\n\nThat's it ... your model is now \"sluggable\"!\n\nSo is retrieving the slug:\n\nAll the logic to generate slugs is handled by the class.\n\nGenerally, you don't need to access this class directly, although there is one static method that can be used to generate a slug for a given string without actually creating or saving an associated model.\n\nThis would be useful for Ajax-y controllers or the like, where you want to show a user what the unique slug would be for a given test input, before actually creating a model. The first two arguments to the method are the model and slug field being tested, and the third argument is the source string to use for testing the slug.\n\nYou can also pass an optional array of configuration values as the fourth argument. These will take precedence over the normal configuration values for the slug field being tested. For example, if your model is configured to use unique slugs, but you want to generate the \"base\" version of a slug for some reason, you could do:\n\nCurrently, the model is slugged on Eloquent's event. This means that the slug is generated before any new data is written to the database.\n\nFor new models, this means that the primary key has not yet been set, so it could not be used as part of the slug source, e.g.:\n\nis before the model is saved. The benefit of hooking into the event, however, is that we only needed to make one database query to save all the model's data, including the slug.\n\nOptional, the model can be slugged on Eloquent's event.\n\n This means that all the other model attributes will have already been persisted to the database and are available for use as slug sources. So the above configuration would work. The only drawback is that saving the model to the database requires one extra query: the first one to save all the non-slug fields, and then a second one to update just the slug field.\n\nThis behaviour is a breaking change, and likely won't affect most users (unless you are doing some pre-saving validation on a model's slug field). We feel the benefits outweigh the drawbacks, and so this will likely become the new default behaviour in a future major release of the package. Although, to make the transition easier, you can configure this behaviour via the method the trait provides:\n\nKeep in mind that you will need to use if you want to use your model's primary key as part of the source fields for your slugs.\n\nSluggable models will fire two Eloquent model events: \"slugging\" and \"slugged\".\n\nThe \"slugging\" event is fired just before the slug is generated. If the callback from this event returns , then the slugging is not performed. If anything else is returned, including , then the slugging will be performed.\n\nThe \"slugged\" event is fired just after a slug is generated. It won't be called in the case where the model doesn't need slugging (as determined by the method).\n\nYou can hook into either of these events just like any other Eloquent model event:\n\nConfiguration was designed to be as flexible as possible. You can set up defaults for all of your Eloquent models, and then override those settings for individual models.\n\nBy default, global configuration is set in the file. If a configuration isn't set, then the package defaults are used. Here is an example configuration, with all the default settings shown:\n\nFor individual models, configuration is handled in the method that you need to implement. That method should return an indexed array where the keys represent the fields where the slug value is stored and the values are the configuration for that field. This means you can create multiple slugs for the same model, based on different source strings and with different configuration options.\n\nThis is the field or array of fields from which to build the slug. Each is concatenated (with space separation) to build the sluggable string. These can be model attributes (i.e. fields in the database), relationship attributes, or custom getters.\n\nTo reference fields from related models, use dot-notation. For example, the slug for the following book will be generated from its author's name and the book's title:\n\nAn example using a custom getter:\n\nIf is empty, false or null, then the value of is used as the source for slug generation.\n\nDefines the method used to turn the sluggable string into a slug. There are three possible options for this configuration:\n• When is null (the default setting), the package uses the default slugging engine -- cocur/slugify -- to create the slug.\n• When is a callable, then that function or class method is used. The function/method should expect two parameters: the string to process, and a separator string. For example, to use Laravel's , you could do:\n• You can also define as a closure (again, expecting two parameters):\n\nAny other values for will throw an exception.\n\nFor more complex slugging requirements, see Extending Sluggable below.\n\nBy default, updating a model will not try and generate a new slug value. It is assumed that once your slug is generated, you won't want it to change (this may be especially true if you are using slugs for URLs and don't want to mess up your SEO mojo).\n\nIf you want to regenerate one or more of your model's slug fields, you can set those fields to null or an empty string before the update:\n\nIf this is the behaviour you want every time you update a model, then set the option to true.\n\nThis defines the separator used when building a slug, and is passed to the defined above. The default value is a hyphen.\n\nThis is a boolean defining whether slugs should be unique among all models of the given type. For example, if you have two blog posts and both are called \"My Blog Post\", then they will both sluggify to \"my-blog-post\" if is false. This could be a problem, e.g. if you use the slug in URLs.\n\nBy setting to true, then the second Post model will sluggify to \"my-blog-post-1\". If there is a third post with the same title, it will sluggify to \"my-blog-post-2\" and so on. Each subsequent model will get an incremental value appended to the end of the slug, ensuring uniqueness.\n\nIf you want to use a different way of identifying uniqueness (other than auto-incrementing integers), you can set the configuration to a function or callable that generates the \"unique\" values for you.\n\nThe function should take four parameters:\n• an of all the other slug strings that start with the same slug\n• the first suffix to use (for the first slug that needs to be made unique) You can then do whatever you want to create a new suffix that hasn't been used by any of the slugs in the collection. For example, if you wanted to use letters instead of numbers as a suffix, this is one way to achieve that:\n\nWhen adding a unique suffix, we start counting at \"2\", so that the list of generated slugs would look something like:\n\nIf you want to start counting at a different number (or pass a different value into your custom function above), then you can define it here.\n\nSetting this to will also check deleted models when trying to enforce uniqueness. This only affects Eloquent models that are using the softDelete feature. Default is , so soft-deleted models don't count when checking for uniqueness.\n\nAn array of values that will never be allowed as slugs, e.g. to prevent collisions with existing routes or controller methods, etc.. This can be an array, or a closure that returns an array. Defaults to : no reserved slug names.\n\nSetting this to a positive integer will ensure that your generated slugs are restricted to a maximum length (e.g. to ensure that they fit within your database fields). By default, this value is null and no limit is enforced.\n\nIf you are truncating your slugs with the setting, than you probably want to ensure that your slugs don't get truncated in the middle of a word. For example, if your source string is \"My First Post\", and your is 10, the generated slug would end up being \"my-first-p\", which isn't ideal.\n\nBy default, the value is set to true which would trim the partial words off the end of the slug, resulting in \"my-first\" instead of \"my-first-p\".\n\nIf you want to keep partial words, then set this configuration to false.\n\nWhen is null (the default setting), the package uses the default slugging engine -- cocur/slugify -- to create the slug. If you want to pass a custom set of options to the Slugify constructor when the engine is instantiated, this is where you would define that. See the documentation for Slugify for what those options are. Also, look at customizeSlugEngine for other ways to customize Slugify for slugging.\n\nA common use for this is to turn on a different ruleset for a specific language. For example the string will slug to using the default settings. In Finnish, it really should slug to , so for that to work, you need to enable the Finnish ruleset for the attribute you are slugging:\n\nThis can also be accomplished with the customizeSlugEngine method (which, unless you add custom logic, will apply to all attributes on the model):\n\nThe package supports a really short configuration syntax, if you are truly lazy:\n\nThis will use all the default options from , use the model's method as the source, and store the slug in the field.\n\nSometimes the configuration options aren't sufficient for complex needs (e.g. maybe the uniqueness test needs to take other attributes into account).\n\nIn instances like these, the package offers hooks into the slugging workflow where you can use your own functions, either on a per-model basis, or in your own trait that extends the package's trait.\n\nIf you extend this method, the Slugify engine can be customized before slugging occurs. This might be where you change the character mappings that are used, or alter language files, etc..\n\nYou can customize the engine on a per-model and per-attribute basis (maybe your model has two slug fields, and one of them needs customization).\n\nTake a look at for an example.\n\nAlso, take a look at the slugEngineOptions configuration for other ways to customize Slugify.\n\nThis method is applied to the query that is used to determine if a given slug is unique. The arguments passed to the scope are:\n• -- the configuration array for the given model and attribute\n• -- the \"base\" slug (before any unique suffixes are applied)\n\nFeel free to use these values anyway you like in your query scope. As an example, look at where the slug is generated for a post from its title, but the slug is scoped to the author. So Bob can have a post with the same title as Pam's post, but both will have the same slug.\n\nThis is the default scope for finding \"similar\" slugs for a model. Basically, the package looks for existing slugs that are the same as the argument, or that start with plus the separator string. The resulting collection is what is passed to the handler.\n\nGenerally, this query scope (which is defined in the Sluggable trait) should be left alone. However, you are free to overload it in your models.\n\nAdding the optional trait to your model allows you to work with models and their slugs. For example:\n\nBecause models can have more than one slug, this requires a bit more configuration. See SCOPE-HELPERS.md for all the details.\n\nThanks to everyone who has contributed to this project!\n\nPlease use GitHub for reporting bugs, and making comments or suggestions.\n\nSee CONTRIBUTING.md for how to contribute changes.\n\neloquent-sluggable was written by Colin Viebrock and is released under the MIT License."
    },
    {
        "link": "https://medium.com/@lordNeic/generate-unique-slugs-on-the-fly-for-create-and-update-in-laravel-models-87ac7e52aa1e",
        "document": "In Laravel, generating unique slugs for models is a common requirement when dealing with SEO-friendly URLs or user-friendly identifiers. Slugs are typically derived from the model’s title or name, but conflicts can arise when multiple models have the same title. In this tutorial, we’ll explore a practical solution to automatically generate unique slugs on-the-fly using Laravel’s event system and the .\n\nBy the end of this tutorial, you'll have a solid understanding of how to implement dynamic slug generation in your Laravel models.\n\nUnderstanding the Problem Before diving into the solution, let’s take a moment to understand the problem we’re trying to solve. We want to generate a unique slug for each model instance, taking into account any existing slugs in the database to prevent conflicts. If a conflict is detected, we’ll append a number to the slug and increment it until a unique slug is found.\n\nThe GenerateUniqueSlugTrait To encapsulate the logic for generating unique slugs, we’ll create a trait called . This trait will be used in our models to automatically generate and update slugs. Let's dissect the trait and understand its key methods:\n\na) : This static method will be invoked when the model is being saved. It registers a callback function that will generate a unique slug before saving the model. Inside the callback, we retrieve the current slug value and replace it with a unique slug generated by the method.\n\nb) : This method takes the original slug as an input and performs the necessary checks and modifications. It first checks if the slug already ends with a number. If so, it extracts the number and removes it from the slug. Next, it retrieves the existing slugs from the database using the method. If the modified slug doesn't exist in the table, it's considered unique and returned. Otherwise, it increments the number and continues checking until a unique slug is found. If all else fails, it appends a random number to the original slug as a fallback.\n\nc) : This private method queries the database to retrieve existing slugs that match the given slug pattern. It excludes the current model's ID to avoid conflicts when updating existing models.\n\nImplementing the GenerateUniqueSlugTrait To use the , you need to include it in your Laravel models. Simply add the following line of code within the class definition:\n\nThen, update your model class to include the trait:\n\nTesting the Solution With the added to your model, you can now create and update model instances while ensuring the slugs are unique. The trait will automatically handle the generation and modification of slugs behind the scenes.\n\nGenerating unique slugs for your Laravel models is crucial for maintaining clean and user-friendly URLs. In this tutorial, we’ve explored a practical solution using the , which allows you to generate and update slugs on-the-fly. By implementing this trait in your models, you can ensure that each model instance has a unique slug, even when conflicts arise. Now you can confidently create SEO-friendly URLs and provide a better user experience in your Laravel applications."
    }
]