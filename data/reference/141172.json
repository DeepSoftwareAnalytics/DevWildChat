[
    {
        "link": "https://reddit.com/r/Python/comments/6xs6od/best_practices_oop_in_python",
        "document": "I sure this question is nothing new but I want to hear your answers anyways. I am actually new to object-oriented programming (even though I know the theoretical concepts; OOP has a lot of resemblance in pure math, particularly in set theory).\n\nWhat are some best practices in creating OOP systems in Python? And what are some bad practices to avoid?\n\nThroughout my programming experience, I spent most of my time organizing my programs into functions/definitions, not necessarily relying much on classes. But I think OOP, as a paradigm, is pretty good for implementing mathematical structures."
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://medium.com/@poppyseedDev/mastering-object-oriented-programming-best-practices-and-design-patterns-e570d511b3b1",
        "document": "Object-oriented programming (OOP) is a paradigm that uses “objects” — data structures that consist of data fields and methods together with their interactions — to design applications and computer programs. Mastering OOP involves not just understanding the theory behind it but also adopting the best practices and design patterns that make your code efficient, reusable, and easy to maintain. This article outlines the best practices and design patterns for mastering object-oriented programming.\n\nSome best practice examples would include: encapsulation, inheritance, polymorphism, proper class design, and composition over inheritance. Here are more details about each one of them:\n• Encapsulation: This practice involves hiding the implementation details of an object. This can be done in Python using private members with double underscore prefixes.\n\nIn this example, the bank account number and balance are private to the class and can't be accessed directly from outside the class.\n• Inheritance: Inheritance is used to create a new class that has all the properties and behaviours of another class, with the potential to add or override them.\n\nHere, is a subclass of , inheriting the and properties and adding a property.\n• Polymorphism: This principle allows methods to act differently based on the object type they are acting on.\n\nIn this example, the function uses the method, which behaves differently depending on whether it's called on a or a object.\n• Proper Class Design: Each class should have a single responsibility. The following is an example of a class that only handles operations related to a bank account:\n\nIn this example, is only responsible for handling operations related to the bank account.\n• Composition over Inheritance: While inheritance can be useful, it can lead to overly complex hierarchies. Composition, on the other hand, promotes flexibility.\n\nIn this example, instead of inheriting from , the class is composed with an object, demonstrating the principle of composition over inheritance.\n\nDesign patterns provide general solutions or flexible ways to solve common design problems. These are some of the most important ones in OOP:\n• Factory Pattern: The factory pattern involves creating an object factory to abstract the object creation process.\n\nIn this example, the function is a factory function that creates and returns an instance of or depending on the input.\n• Singleton Pattern: The Singleton pattern ensures that a class has only one instance and provides a global point of access to it.\n\nIn this example, is a singleton class that always returns the same instance.\n• Strategy Pattern: The Strategy pattern enables an algorithm’s behaviour to be selected at runtime.\n\nIn this example, the class's method can be replaced with different functions at runtime.\n• Observer Pattern: The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.\n\nIn this example, the class notifies all registered observers when its method is called.\n• Decorator Pattern: The Decorator pattern allows behaviour to be added to an individual object, either statically or dynamically, without affecting the behaviour of other objects from the same class.\n\nIn this example, and are decorators that add responsibilities to without changing its interface. Decorators are a flexible alternative to subclassing for extending functionality.\n\nIn conclusion, design patterns are proven solutions to common software design problems. They are not classes or libraries that can be plugged into an application and automatically solve problems. Instead, they are templates that provide guidance on how to solve various design problems in object-oriented software.\n\nMastering object-oriented programming requires understanding the fundamental principles and best practices, as well as how and when to use common design patterns. Through careful application of encapsulation, inheritance, polymorphism, and proper class design, along with the judicious use of design patterns, you can write code that is efficient, reusable, and easy to maintain. Remember, the ultimate goal of mastering OOP is to write code that not only works, but is also clean and manageable. This makes your software easier to read, understand, and modify, leading to more robust and maintainable applications."
    },
    {
        "link": "https://arjancodes.com/blog/best-practices-for-class-design-in-object-oriented-programming",
        "document": "Creating well-designed classes not only streamlines complexity and enhances code comprehension but also significantly contributes to a system’s scalability and robustness. By adhering to principles of good class design, developers can ensure that their software remains flexible in the face of changing requirements, thereby facilitating easier updates and extensions. Today I’ll be exploring this approach which aligns with modern software development practices that prioritize adaptability, performance, and maintainability.\n\nTackling large classes that have multiple responsibilities can be quite the talk, and almost always will make it more difficult for developer to understand, test and maintain. When a class has too many responsibilities it becomes prone to errors and bugs. This complexity tends to obfuscate the implementation and intention of the class, they can also hide other issues such as those affecting performance and overall the code becomes highly delicate to change.\n\nTo tackle these issues, it’s a good idea to consider breaking down monolithic classes into smaller, more manageable components, where each component focuses on a single responsibility. This approach helps organize the code, making it clearer and reducing redundancy. Smaller classes are much easier to understand and test, which enhances the overall quality and maintainability of the code.\n\nTo enhance the user-friendliness of classes, it’s crucial to focus on developing an intuitive interface for their attributes and methods. An intuitive interface involves designing elements that clearly convey their purposes and applications. This clarity and consistency in design make the classes more accessible and contribute to a coherent code structure.\n\nAs Guido himself said, code is more often read than written. When code is well structured, includes type hints, and has a clear purpose, it becomes much easier to reason about and utilize.\n\nFurthermore, it’s essential to ensure that classes align with the overall structure of the codebase. This facilitates seamless integration with other components, improving the efficiency and maintainability of the entire system. When classes are designed to fit within a larger ecosystem, it streamlines development processes and encourages a modular approach to software construction. This modularity allows for easier updates, debugging, and scalability, as well-designed classes can be reused and adapted without compromising the system’s integrity. Hence, the emphasis on intuitive interfaces and alignment with the codebase highlights the significance of thoughtful class design in creating user-friendly and cohesive software solutions.\n\nAdopting a strategy where dependencies are passed as parameters to classes instead of being hardcoded within them can greatly enhance the modularity and adaptability of software systems. This approach, known as dependency injection, promotes a more flexible design architecture, making it easier to reuse and reconfigure components with minimal effort. This is particularly advantageous in complex systems where dependencies can vary significantly across different environments or use cases. Externalizing dependencies allows developers to swap out implementations effortlessly without needing to make changes to the class internals, resulting in a cleaner and more loosely coupled codebase.\n\nFurthermore, this shift towards dependency injection simplifies the software testing process. When dependencies are injected, it becomes much easier to introduce mock objects or stubs in place of real dependencies during testing phases. This speeds up the testing process by eliminating the need for intricate setup or access to external resources and improving test reliability and granularity. Test cases become more focused, targeting specific behaviors without being entangled in the complexities of the actual dependencies. As a result, developers can achieve more comprehensive test coverage with less effort, leading to higher-quality software that is more resilient to changes and easier to maintain over time.\n\nDesigning classes to only reveal what’s necessary for the user can be done by using _ and ** prefixes to denote private members in Python. It should be noted that the ** prefix is not a security feature; it only changes the name to avoid conflicts. Following the convention of using the _ prefix is considered good practice and relies on the community to respect these boundaries. It’s advisable to use immutable data structures for attributes that should not be modified after initialization. This approach helps prevent accidental modifications and simplifies the testing process.\n\nWhile classes are powerful, they may not always be the best choice for every programming task. Sometimes, using modules is more suitable, especially when you have a group of static functions that do not need to share or manipulate an object’s state. Modules act as containers for functions that can be reused throughout your code, allowing you to logically organize functions without the extra complexity of a class. For more complex applications you can also group modules into packages. It’s often good practice to group your modules by service or feature.\n\nMoreover, classes might be unnecessary when their sole purpose is to store data. In such cases, simpler data structures like dictionaries, sets, or tuples can often be more efficient. For example, dictionaries are perfect for storing key-value pairs, sets are great for holding an unordered collection of unique items, and tuples can store a fixed set of items. Opting for these data structures can simplify your code, making it easier to read and maintain. This approach to selecting the appropriate data structure or coding pattern can greatly improve the performance and scalability of your software.\n\nThe well-thought-out design of classes is really important when it comes to efficient software development. By following these principles, you can make your classes more user-friendly, easier to maintain, and simpler to test. If you want to learn more about improving your function design, you should definitely check out Optimize Python Code for Better Maintenance."
    },
    {
        "link": "https://codebricks.co.nz/python-oop-07",
        "document": "[Python OOP] 7. Best Practices and Tips for OOP in Python\n\n7. Best Practices and Tips for OOP in Python\n\nObject-Oriented Programming (OOP) can lead to powerful, maintainable, and scalable code. Here are best practices and tips to make the most of OOP in Python.\n\nWriting clean code is not just about aesthetics; it is about maintainability and scalability. Here are some guidelines for writing clean OOP code in Python:\n• Methods and variables should be lowercase with words separated by underscores (e.g., ).\n\nKeep It DRY (Don’t Repeat Yourself)\n• Avoid duplicate code by abstracting repetitive logic into a method or a class.\n• Each class should have one responsibility and thus only one reason to change.\n• If a class is handling too many tasks, it might be time to break it down into more specialized classes.\n• Use comments sparingly, only when the code is not self-explanatory.\n\nWhile Python is not known for raw performance, you can still design your OOP structure to be as efficient as possible.\n• By defining in a class, you can significantly reduce the memory overhead for instances.\n• Instead of loading resources when an object is created, consider loading them on-demand.\n\nHere are additional tips to refine your OOP skills in Python:\n• Use duck typing and polymorphism to write more flexible and integrated code.\n• Deep inheritance hierarchies can become very difficult to understand and maintain.\n• Favor composition over inheritance to create more decoupled and flexible designs.\n• Mixins can be a great way to reuse code across unrelated classes.\n• Write unit tests for your classes to ensure that changes do not break functionality.\n\nFollowing these best practices and tips will not only make your code cleaner and easier to maintain but also more efficient and reliable."
    },
    {
        "link": "https://docs.python.org/3/library/collections.html",
        "document": "This module implements specialized container datatypes providing alternatives to Python’s general purpose built-in containers, , , , and .\n\nA class is provided for quickly linking a number of mappings so they can be treated as a single unit. It is often much faster than creating a new dictionary and running multiple calls. The class can be used to simulate nested scopes and is useful in templating. A groups multiple dicts or other mappings together to create a single, updateable view. If no maps are specified, a single empty dictionary is provided so that a new chain always has at least one mapping. The underlying mappings are stored in a list. That list is public and can be accessed or updated using the maps attribute. There is no other state. Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping. A incorporates the underlying mappings by reference. So, if one of the underlying mappings gets updated, those changes will be reflected in . All of the usual dictionary methods are supported. In addition, there is a maps attribute, a method for creating new subcontexts, and a property for accessing all but the first mapping: A user updateable list of mappings. The list is ordered from first-searched to last-searched. It is the only stored state and can be modified to change which mappings are searched. The list should always contain at least one mapping. Returns a new containing a new map followed by all of the maps in the current instance. If is specified, it becomes the new map at the front of the list of mappings; if not specified, an empty dict is used, so that a call to is equivalent to: . If any keyword arguments are specified, they update passed map or new empty dict. This method is used for creating subcontexts that can be updated without altering values in any of the parent mappings. Changed in version 3.4: The optional parameter was added. Property returning a new containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the keyword used in nested scopes. The use cases also parallel those for the built-in function. A reference to is equivalent to: . Note, the iteration order of a is determined by scanning the mappings last to first: This gives the same ordering as a series of calls starting with the last mapping: Changed in version 3.9: Added support for and operators, specified in PEP 584.\n• None The MultiContext class in the Enthought CodeTools package has options to support writing to any mapping in the chain.\n• None Django’s Context class for templating is a read-only chain of mappings. It also features pushing and popping of contexts similar to the method and the property.\n• None The Nested Contexts recipe has options to control whether writes and other mutations apply only to the first mapping or to any mapping in the chain. This section shows various approaches to working with chained maps. Example of letting user specified command-line arguments take precedence over environment variables which in turn take precedence over default values: Example patterns for using the class to simulate nested contexts: # Child of c, independent from d # Get first key in the chain of contexts The class only makes updates (writes and deletions) to the first mapping in the chain while lookups will search the full chain. However, if deep writes and deletions are desired, it is easy to make a subclass that updates keys found deeper in the chain: 'Variant of ChainMap that allows direct updates to inner scopes' # update an existing key two levels down # new keys get added to the topmost dict # remove an existing key one level down\n\nA counter tool is provided to support convenient and rapid tallies. For example: # Find the ten most common words in Hamlet [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631), ('you', 554), ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)] A is a subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The class is similar to bags or multisets in other languages. Elements are counted from an iterable or initialized from another mapping (or counter): # a new counter from an iterable Counter objects have a dictionary interface except that they return a zero count for missing items instead of raising a : # count of a missing element is zero Setting a count to zero does not remove an element from a counter. Use to remove it entirely: Changed in version 3.7: As a subclass, inherited the capability to remember insertion order. Math operations on Counter objects also preserve order. Results are ordered according to when an element is first encountered in the left operand and then by the order encountered in the right operand. Counter objects support additional methods beyond those available for all dictionaries: Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, will ignore it. Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or , returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: Elements are subtracted from an iterable or from another mapping (or counter). Like but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. Compute the sum of the counts. The usual dictionary methods are available for objects except for two which work differently for counters. This class method is not implemented for objects. Elements are counted from an iterable or added-in from another mapping (or counter). Like but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of pairs. Counters support rich comparison operators for equality, subset, and superset relationships: , , , , , . All of those tests treat missing elements as having zero counts so that returns true. Changed in version 3.10: In equality tests, missing elements are treated as having zero counts. Formerly, and were considered distinct. Several mathematical operations are provided for combining objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Equality and inclusion compare corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. Added in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions.\n• None The class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field.\n• None The method requires only that the values be orderable.\n• None For in-place operations such as , the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for and which allow negative and zero values for both inputs and outputs.\n• None The multiset methods are designed only for use cases with positive values. The inputs may be negative or zero, but only outputs with positive values are created. There are no type restrictions, but the value type needs to support addition, subtraction, and comparison.\n• None The method requires integer counts. It ignores zero and negative counts.\n• None For mathematical operations on multisets and their use cases, see Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19.\n• None To enumerate all distinct multisets of a given size over a given set of elements, see :\n\nReturns a new deque object initialized left-to-right (using ) with data from iterable. If iterable is not specified, the new deque is empty. Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction. Though objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for and operations which change both the size and position of the underlying data representation. If maxlen is not specified or is , deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest. Add x to the right side of the deque. Add x to the left side of the deque. Remove all elements from the deque leaving it with length 0. Count the number of deque elements equal to x. Extend the right side of the deque by appending elements from the iterable argument. Extend the left side of the deque by appending elements from iterable. Note, the series of left appends results in reversing the order of elements in the iterable argument. Return the position of x in the deque (at or after index start and before index stop). Returns the first match or raises if not found. Insert x into the deque at position i. If the insertion would cause a bounded deque to grow beyond maxlen, an is raised. Remove and return an element from the right side of the deque. If no elements are present, raises an . Remove and return an element from the left side of the deque. If no elements are present, raises an . Remove the first occurrence of value. If not found, raises a . Reverse the elements of the deque in-place and then return . Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to , and rotating one step to the left is equivalent to . Maximum size of a deque or if unbounded. In addition to the above, deques support iteration, pickling, , , , , membership testing with the operator, and subscript references such as to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead. # make a new deque with three items # add a new entry to the right side # add a new entry to the left side # show the representation of the deque # list the contents of the deque # list the contents of a deque in reverse # cannot pop from an empty deque : This section shows various approaches to working with deques. Bounded length deques provide functionality similar to the filter in Unix: 'Return the last n lines of a file' Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left: A round-robin scheduler can be implemented with input iterators stored in a . Values are yielded from the active iterator in position zero. If that iterator is exhausted, it can be removed with ; otherwise, it can be cycled back to the end with the method: The method provides a way to implement slicing and deletion. For example, a pure Python implementation of relies on the method to position elements to be popped: To implement slicing, use a similar approach applying to bring a target element to the left side of the deque. Remove old entries with , add new entries with , and then reverse the rotation. With minor variations on that approach, it is easy to implement Forth style stack manipulations such as , , , , , , and .\n\nReturn a new dictionary-like object. is a subclass of the built-in class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the class and is not documented here. The first argument provides the initial value for the attribute; it defaults to . All remaining arguments are treated the same as if they were passed to the constructor, including keyword arguments. objects support the following method in addition to the standard operations: If the attribute is , this raises a exception with the key as argument. If is not , it is called without arguments to provide a default value for the given key, this value is inserted in the dictionary for the key, and returned. If calling raises an exception this exception is propagated unchanged. This method is called by the method of the class when the requested key is not found; whatever it returns or raises is then returned or raised by . Note that is not called for any operations besides . This means that will, like normal dictionaries, return as a default rather than using . This attribute is used by the method; it is initialized from the first argument to the constructor, if present, or to , if absent. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. Using as the , it is easy to group a sequence of key-value pairs into a dictionary of lists: When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the function which returns an empty . The operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the operation adds another value to the list. This technique is simpler and faster than an equivalent technique using : Setting the to makes the useful for counting (like a bag or multiset in other languages): When a letter is first encountered, it is missing from the mapping, so the function calls to supply a default count of zero. The increment operation then builds up the count for each letter. The function which always returns zero is just a special case of constant functions. A faster and more flexible way to create constant functions is to use a lambda function which can supply any constant value (not just zero): Setting the to makes the useful for building a dictionary of sets:\n\nNamed tuples assign meaning to each position in a tuple and allow for more readable, self-documenting code. They can be used wherever regular tuples are used, and they add the ability to access fields by name instead of position index. Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful method which lists the tuple contents in a format. The field_names are a sequence of strings such as . Alternatively, field_names can be a single string with each fieldname separated by whitespace and/or commas, for example or . Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a such as class, for, return, global, pass, or raise. If rename is true, invalid fieldnames are automatically replaced with positional names. For example, is converted to , eliminating the keyword and the duplicate fieldname . defaults can be or an iterable of default values. Since fields with a default value must come after any fields without a default, the defaults are applied to the rightmost parameters. For example, if the fieldnames are and the defaults are , then will be a required argument, will default to , and will default to . If module is defined, the attribute of the named tuple is set to that value. Named tuple instances do not have per-instance dictionaries, so they are lightweight and require no more memory than regular tuples. To support pickling, the named tuple class should be assigned to a variable that matches typename. Changed in version 3.6: The verbose and rename parameters became keyword-only arguments. Changed in version 3.7: Removed the verbose parameter and the attribute. Changed in version 3.7: Added the defaults parameter and the attribute. # fields also accessible by name Named tuples are especially useful for assigning field names to result tuples returned by the or modules: In addition to the methods inherited from tuples, named tuples support three additional methods and two attributes. To prevent conflicts with field names, the method and attribute names start with an underscore. Class method that makes a new instance from an existing sequence or iterable. Return a new which maps field names to their corresponding values: Changed in version 3.1: Returns an instead of a regular . Changed in version 3.8: Returns a regular instead of an . As of Python 3.7, regular dicts are guaranteed to be ordered. If the extra features of are required, the suggested remediation is to cast the result to the desired type: . Return a new instance of the named tuple replacing specified fields with new values: Named tuples are also supported by generic function . Changed in version 3.13: Raise instead of for invalid keyword arguments. Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. To retrieve a field whose name is stored in a string, use the function: To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: The subclass shown above sets to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the attribute: Docstrings can be customized by making direct assignments to the fields: 'List of authors sorted by last name'\n• None See for a way to add type hints for named tuples. It also provides an elegant notation using the keyword:\n• None See for a mutable namespace based on an underlying dictionary instead of a tuple.\n• None The module provides a decorator and functions for automatically adding generated special methods to user-defined classes.\n\nOrdered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from still remain:\n• None The regular was designed to be very good at mapping operations. Tracking insertion order was secondary.\n• None The was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.\n• None The algorithm can handle frequent reordering operations better than . As shown in the recipes below, this makes it suitable for implementing various kinds of LRU caches.\n• None The equality operation for checks for matching order. A regular can emulate the order sensitive equality test with p == q and all(k1 == k2 for k1, k2 in zip(p, q)) .\n• None The method of has a different signature. It accepts an optional argument to specify which item is popped. A regular can emulate OrderedDict’s with which is guaranteed to pop the rightmost (last) item. A regular can emulate OrderedDict’s with which will return and remove the leftmost (first) item if it exists.\n• None has a method to efficiently reposition an element to an endpoint. A regular can emulate OrderedDict’s with which will move the key and its associated value to the rightmost (last) position. A regular does not have an efficient equivalent for OrderedDict’s which moves the key and its associated value to the leftmost (first) position. Return an instance of a subclass that has methods specialized for rearranging dictionary order. The method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in order if last is true or order if false. Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises if the key does not exist: In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using . Equality tests between objects are order-sensitive and are roughly equivalent to . Equality tests between objects and other objects are order-insensitive like regular dictionaries. This allows objects to be substituted anywhere a regular dictionary is used. Changed in version 3.5: The items, keys, and values views of now support reverse iteration using . Changed in version 3.6: With the acceptance of PEP 468, order is retained for keyword arguments passed to the constructor and its method. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. It is straightforward to create an ordered dictionary variant that remembers the order the keys were last inserted. If a new entry overwrites an existing entry, the original insertion position is changed and moved to the end: 'Store items in the order the keys were last added' An would also be useful for implementing variants of : \"LRU Cache that invalidates and refreshes old entries.\" it has been requested multiple times. To avoid flushing the LRU cache with one-time requests, we don't cache until a request has been made more than once.\n\nThis class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists. The need for this class has been partially supplanted by the ability to subclass directly from ; however, this class can be easier to work with because the underlying list is accessible as an attribute. Class that simulates a list. The instance’s contents are kept in a regular list, which is accessible via the attribute of instances. The instance’s contents are initially set to a copy of list, defaulting to the empty list . list can be any iterable, for example a real Python list or a object. In addition to supporting the methods and operations of mutable sequences, instances provide the following attribute: A real object used to store the contents of the class. Subclassing requirements: Subclasses of are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source. If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://analyticsvidhya.com/blog/2021/06/working-with-lists-dictionaries-in-python",
        "document": "Working with Lists and Dictionaries in Python\n\nWorking with lists and dictionaries in Python opens up a world of possibilities for data organization and manipulation. Imagine having a virtual toolbox where you can effortlessly store, retrieve, and modify data as needed—lists are like flexible containers for sequences of items, while dictionaries offer a powerful way to manage key-value pairs, allowing for quick access and updates. Whether you’re handling a collection of cities, tracking sales information, or navigating complex data structures, mastering these fundamental concepts will elevate your programming skills and enable you to tackle real-world challenges with confidence and creativity. Let’s dive into the exciting features and functionalities that lists and dictionaries have to offer!\n\nFor Beginners, free Python tutorials and libraries like numpy and pandas, you can refer to Introduction to Python.\n• Understand the structure and properties of Python lists and dictionaries.\n• Learn how to access, update, and delete elements from lists and dictionaries in Python.\n• Explore ways to loop through dictionary elements using key-value pairs.\n• Apply Python list operations like indexing, slicing, and nested lists for complex data storage.\n• Learn advanced dictionary techniques such as accessing, updating, and iterating through items.\n\nThis article was published as a part of the Data Science Blogathon.\n\nLists are just like arrays. Python lists are mutable data types in Python. A list refers to the collection of index value pair-like arrays in C/C++/Java. Lists is a 0-based index datatype, meaning the index of the first element starts at 0. Lists are used to store multiple items in a single variable. These are one of the 4 data types present in Python, i.e., Lists, Dictionaries, Tuples & Sets. A list is created by placing elements in [ ] separated by commas ‘, ‘. We can use them to store more complex data structures other than integers, strings, or floats. A list of dictionaries is a great example.\n\nIf there is a concept that is easier and more common than accessing elements in a list in Python, I still have not come across it. Through the use of indexing and slicing you can get, set or fetch portions of the list as you work with data since it is so flexible. It has both post-positive and pre-negative indexing system whereby anyone can begin from the beginning or the end of the list.\n\nIn Python, the list indices begin with 0 implying that the first element of any list is located at its zeroth index, the second element in the list is at first index, … It is done with equal ease by typing the required index number in square brackets after the list name.\n\nPython also supports negative indexing, where refers to the last element of the list, refers to the second last element, and so on. This feature is particularly useful when you want to access elements from the end of the list.\n\nNote: If you try to access an index that is out of range, Python will raise an . So, make sure the index you’re trying to access falls within the valid range of the list.\n\nIn Python, indexing is a powerful way to access and manipulate elements within a list. It allows you to retrieve a single element or a range of elements using indices. The ability to specify a range or slice of the list is extremely useful in various data manipulation tasks, enabling you to handle different portions of your list efficiently.\n\nPython allows you to extract a sublist from an existing list using slicing. You define a range of indices, and Python will return the elements between those indices. The syntax for slicing is , where is the index of the first element you want to include, and is the index where slicing ends (excluding the element at this position).\n\nWhen slicing, if you omit the index, Python will start from the beginning of the list. Similarly, omitting the index will include all elements from the start index to the end of the list.\n\nPython’s function allows you to find the index value of a specific item in a list, provided the item exists. You can also specify an optional range ( , ) within which Python should search for the item.\n\nWorking With Operators in the List\n\nIn Python you will find many types of operators that can be used with lists, including concatenation and repetition as well as comparisons. These operators are important to successfully manipulate list data type since they can boost your coding performance and option.\n\nWithout any doubt one of the most frequently used operation which you will probably deal with when working with list is concatenation and in this case you will be glad to know that you can perform this operation using the + operator. This basic and helpful function also helps to combine multiple lists into one united collection and add the elements of one list to another without intervening between them. Just as you can tentatively compile a shopping list and your friend’s, you can instantly bring into being a new list containing what you need! For example:\n\nThe * operator aids in repetition of the contents of a list say N times to the list with simplycopying the contents. This applies where one wishes to repeat the same sequence of operations of the automated program or replicate other patterns.\n\nIn Python the comparison of two lists can be done using relational operators like ==,!=, <, >, <= and >=. These comparisons are done one feature at a time, beginning with the first feature of one list and the first feature of the other list. If first elements are equal Python try to compare the second elements and so on accordingly.\n• The operator checks if two lists have the same elements in the same order.\n• The operator checks if two lists are not the same.\n\nThe operator checks whether a specific element exists within a list, returning if the element is present and otherwise. This operator is often used to check membership in a list or search for values.\n\nPython also supports the and operators for in-place modification of lists. The operator appends the elements of another list to the existing list, and the operator repeats the list elements in place.\n\nNested list is a list that is made up of one or more other list within it. It gives an opportunity to store any kind of more complex data arrangements like matrices, tables or hierarchical structures, and in each element of such structure is a list. When it comes to operating on the data, working with nested lists makes you have the ability to easily manage multi-dimensional data.\n\nIn the example below, contains two elements, where each element is a list. The first nested list holds integers, and the second one contains strings:\n\nTo access elements within a nested list, you need to use double indexing: the first index selects the sublist, and the second index picks an item from that sublist. This process allows you to navigate through the hierarchy of lists.\n\nThe elements of a nested list can be accessed as shown below:\n\nJust like simple lists, elements within a nested list can also be modified using indexing. You can target specific items within the sublists and reassign their values.\n\nYou can also append new lists to an existing nested list or add elements to the sublists themselves.\n\nPython makes it easy to iterate through nested lists using loops, which is particularly useful when working with matrices or complex datasets. You can loop through both the parent list and the nested lists inside.\n\nStatic means that an object cannot be altered once it has been defined; whereas lists are arbitrary, which means that elements may be altered even after creation. Python offers ways on how to manipulate lists for example add elements, add list to another list, add / insert elements at particular positions, replace list, remove elements and delete list. Explored in detail below are each of these techniques:\n\nThe append() method is used to add element to the list at the end of the list. This one alters the original list and is applied if the user must add only one item at a time.\n\nIn the case where you want to append a number of elements to a list at one time then you can use the extend() method. Unlike the append () which takes only one element adds it to the list while the extend () takes a parameter that is iterable like a list and adds each element in the parameter to the list.\n\nTo update a specific element in a list, you can assign a new value to the desired index. This method replaces the element at the specified position with a new one.\n\nIn the present example inserting an item in the list at a given position is done with the help of insert() method. It takes two arguments: The indices and value as which are associated with the insert method are the index where it will insert the element and the value to be inserted.\n\nYou can delete elements from a list using the keyword. This can remove a single element by its index or a slice of elements by specifying a range of indexes.\n\nYou can also delete the complete list using the below command:\n\nIn order to delete the contents of a list but leave the variable intact, a list is assigned an empty list. This is important when you want to remake the list, but the list still serves as a good frame.\n\nIf you are aware of the value of the element which is to be removed but not its position, the remove() method is useful. It deletes the initial appearance of the value that is contained in its parameter.\n\nThe method removes and returns an element from the list, either from the end (if no index is provided) or from a specified index.\n\nPython offers several built-in methods to make list manipulation easier and more efficient. These methods allow you to perform various operations such as finding the length of a list, clearing its contents, reversing the order of elements, and sorting them. Let’s explore these methods in detail.\n\nThe function is used to determine how many elements are present in a list. This method is very useful when you need to know the size of a list, especially in loops and conditions.\n\nThe method is used to remove all elements from a list, effectively making it an empty list. It is a useful method when you want to reset a list without deleting the variable itself.\n\nThe method reverses the elements of a list in place, meaning it directly modifies the original list. This can be useful when the order of elements needs to be inverted.\n\nThe method sorts the elements of a list in ascending order by default. You can also pass the argument to sort the list in descending order. This method sorts elements in place, meaning it modifies the original list.\n\nDictionaries are mutable data types, unordered in nature, meaning they can be updated after they are created. Key and value pairs, and the keys must be unique. You can get a list of keys by calling a dictionary instance’s keys method. Syntactically they are written in a key, value pair format inside curly braces/curly brackets. We can update and delete the elements of the list of dictionaries. Dictionaries are implemented using hash tables.\n\nKeys are always unique, and there cannot be any duplicates. There is no index in the dictionary, meaning they are not ordered. The key is the default iterator and is used to retrieve the value.\n\nIn Python, a dictionary is a collection of key-value pairs, allowing for efficient data retrieval and storage. Dictionaries can be created in several ways, each serving different needs. Here are four primary methods to create dictionaries in Python.\n\nAn empty dictionary can be created using curly braces or the function. This can be useful when you want to initialize a dictionary and populate it later.\n\nDictionaries can have integer keys associated with their respective values. This is useful for storing data that requires numerical indexing.\n\nString keys are commonly used in dictionaries, especially when representing named entities or attributes.\n\nDictionaries can also contain a mix of different data types as keys and values, allowing for complex data structures.\n\nYou can easily determine how many key-value pairs are in a dictionary using the function. This can help in checking if a dictionary is empty or how many items it contains.\n\nIn Python, dictionaries are a versatile data structure that allows for efficient storage and retrieval of key-value pairs. Let’s explore various methods for accessing and manipulating dictionary elements.\n\nFirst, let’s create two dictionaries to work with:\n\nYou can access the value associated with a key using the dictionary’s indexing method. Here’s how to extract the car name based on the sales ID:\n\nYou can also update existing keys or add new ones using the assignment operator. Here’s an example of modifying the and in the dictionary:\n\nTo view all the values in a dictionary, you can use the method:\n\nYou can loop through the dictionary items using a loop, which allows you to process each key-value pair easily:\n\nA dictionary object contains key-value pairs, and the list must adhere to this format, or else it will throw an error.\n\nWhen working with dictionaries in Python, you may often need to create a copy of an existing dictionary to manipulate or reference data without altering the original. Understanding how to copy a dictionary ensures data integrity while providing the flexibility to make changes as needed.\n\nUpdating a Python dictionary allows you to modify existing key-value pairs or add new ones, making it a versatile tool for managing dynamic data. This functionality is essential for maintaining accurate and up-to-date information in your applications, enabling efficient data handling and retrieval.\n\nHow to Delete From Python Dictionary?\n\nA dictionary object can be deleted entirely using the statement, which frees up memory by removing the entire dictionary and its contents.\n\nTo delete a specific item from a dictionary, you can use the statement along with the key of the item you want to remove, as shown below:\n\nAnother way to delete a specific item is by using the pop function.\n\nLooping through a Python dictionary allows you to access each key-value pair efficiently, making it easy to process or manipulate data. This technique is essential for tasks such as data analysis, reporting, or any situation where you need to examine or modify the contents of a dictionary.\n\nIn Python, a list is a class of data structures that can store one or more objects or values. A list can store multiple items in one variable and be created using square brackets. Dictionaries are used to store data values in key:value pairs. A dictionary is an ordered, changeable collection, and does not allow duplicates. Elements of the dictionary are accessed through the keys.\n• Indexing and Slicing allow flexible element access within lists.\n• Lists can be easily modified using methods like , , and .\n• Dictionary methods like , , and simplify working with key-value pairs.\n• Lists and dictionaries are fundamental structures for efficient data manipulation in Python.\n\nThe media shown in this article is not owned by Analytics Vidhya and is used at the Author’s discretion."
    },
    {
        "link": "https://geeksforgeeks.org/python-collections-module",
        "document": "The collection Module in Python provides different types of containers. A Container is an object that is used to store different objects and provide a way to access the contained objects and iterate over them. Some of the built-in containers are Tuple, List, Dictionary, etc. In this article, we will discuss the different containers provided by the collections module.\n\nA counter is a sub-class of the dictionary. It is used to keep the count of the elements in an iterable in the form of an unordered dictionary where the key represents the element in the iterable and value represents the count of that element in the iterable.\n\nNote: It is equivalent to bag or multiset of other languages.\n\nThe counter object can be initialized using the counter() function and this function can be called in one of the following ways:\n• None With a dictionary containing keys and counts\n\nNote: For more information, refer Counters in Python.\n\nAn OrderedDict is also a sub-class of dictionary but unlike dictionary, it remembers the order in which the keys were inserted.\n\nWhile deleting and re-inserting the same key will push the key to the last to maintain the order of insertion of the key.\n\nNote: for more information, refer OrderedDict in Python\n\nA DefaultDict is also a sub-class to dictionary. It is used to provide some default values for the key that does not exist and never raises a KeyError.\n\ndefault_factory is a function that provides the default value for the dictionary created. If this parameter is absent then the KeyError is raised.\n\nDefaultDict objects can be initialized using DefaultDict() method by passing the data type as an argument.\n\nNote: For more information, refer Defaultdict in Python\n\nA ChainMap encapsulates many dictionaries into a single unit and returns a list of dictionaries.\n\nValues from ChainMap can be accessed using the key name. They can also be accessed by using the keys() and values() method.\n\nA new dictionary can be added by using the new_child() method. The newly added dictionary is added at the beginning of the ChainMap.\n\nNote: For more information, refer ChainMap in Python\n\nA NamedTuple returns a tuple object with names for each position which the ordinary tuples lack. For example, consider a tuple names student where the first element represents fname, second represents lname and the third element represents the DOB. Suppose for calling fname instead of remembering the index position you can actually call the element by using the fname argument, then it will be really easy for accessing tuples element. This functionality is provided by the NamedTuple.\n\n1. _make(): This function is used to return a namedtuple() from the iterable passed as argument.\n\n2. _asdict(): This function returns the OrdereDict() as constructed from the mapped values of namedtuple().\n\nNote: For more information, refer NamedTuple in Python\n\nDeque (Doubly Ended Queue) is the optimized list for quicker append and pop operations from both sides of the container. It provides O(1) time complexity for append and pop operations as compared to list with O(n) time complexity.\n\nThis function takes the list as an argument.\n\nElements in deque can be inserted from both ends. To insert the elements from right append() method is used and to insert the elements from the left appendleft() method is used.\n\nElements can also be removed from the deque from both the ends. To remove elements from right use pop() method and to remove elements from the left use popleft() method.\n\nNote: For more information, refer Deque in Python.\n\nUserDict is a dictionary-like container that acts as a wrapper around the dictionary objects. This container is used when someone wants to create their own dictionary with some modified or new functionality.\n\nNote: For more information, refer UserDict in Python\n\nUserList is a list like container that acts as a wrapper around the list objects. This is useful when someone wants to create their own list with some modified or additional functionality.\n\nNote: For more information, refer UserList in Python\n\nUserString is a string like container and just like UserDict and UserList it acts as a wrapper around string objects. It is used when someone wants to create their own strings with some modified or additional functionality.\n\nNote: For more information, refer UserString in Python\n\nHow to use the\n\nand its applications in Python?\n\nHow to use\n\nWhat are the benefits of using"
    },
    {
        "link": "https://medium.com/@cssjhnnamae/use-cases-of-python-lists-of-dictionaries-df6f32a4dba0",
        "document": "In Python programming, the combination of lists and dictionaries often proves to be a powerful tool for managing and manipulating data. A list of dictionaries, as the name suggests, is a data structure that allows us to store a collection of dictionaries within a single variable. Each dictionary in this list represents an individual item, with its own set of attributes or properties.\n\nLet’s break down the basics with a practical example:\n\nHere, users is a list containing three dictionaries. Each dictionary holds data about a user, including attributes like name and age. This structure is invaluable when dealing with datasets where each item (in this case, each user) has multiple associated properties.\n• Flexibility: Lists of dictionaries are flexible because each dictionary can have different keys and values. This makes them ideal for handling diverse datasets where items may vary in structure.\n• Ease of Access: Accessing individual elements is straightforward using index notation (users[0] gives the first user dictionary) or iterating through the list.\n• Data Transformation: They facilitate easy transformation and manipulation of data. For instance, filtering based on specific criteria or updating values for all items in the list.\n\nReal-life examples of when lists of dictionaries are useful\n\nusers = [\n\n{‘name’: ‘Jack’, ‘age’: ‘15’, ‘id’: 1024}\n\n]\n\n# Print the list of dictionaries\n\nprint(users)\n\n# Print the type of the list\n\nprint(type(users))\n\n# Print the type of the first dictionary in the list\n\nprint(type(users[0]))\n\nIn this example, we have a list called users that contains one dictionary. Each dictionary represents a user with attributes like ‘name’, ‘age’, and ‘id’. Here’s what each part of the code does:\n• users: It’s a list containing one dictionary of user data.\n• print(users): Prints the entire list users, which in this case is [{‘name’: ‘Jack’, ‘age’: ‘15’, ‘id’: 1024}].\n• print(type(users)): Prints the type of users, which is list.\n• print(type(users[0])): Prints the type of the first element in users, which is dict.\n\nls = [{‘car’: ‘BMW’, ‘bike’: ‘Honda’}, {‘fruit’: ‘orange’}]\n\n# Print the original list\n\nprint(“Original list:\n\n”, ls)\n\n# Dictionary to append\n\ndict_to_append = {‘language’: ‘Python’, ‘Framework’: ‘Django’}\n\n# Append the dictionary to the list\n\nls.append(dict_to_append)\n\n# Print the list after appending\n\nprint(“List after appending:\n\n”, ls)\n\nThis example shows how to add a new dictionary to an existing list of dictionaries (ls). Here’s what happens:\n• dict_to_append: This is a new dictionary { ‘language’: ‘Python’, ‘Framework’: ‘Django’ } that we want to add to ls.\n• ls.append(dict_to_append): Appends dict_to_append to the end of ls.\n• print(“List after appending:\n\n”, ls): Prints the updated ls with the new dictionary added.\n\nls = [{‘car’: ‘BMW’, ‘bike’: ‘Honda’}, {‘fruit’: ‘orange’}]\n\n# Access dictionary at index 0\n\nprint(“Dictionary at index 0:”, ls[0])\n\n# Access value of ‘car’ key in dictionary at index 0\n\nprint(“Value of key ‘car’:”, ls[0][‘car’])\n\n# Access dictionary at index 1\n\nprint(“Dictionary at index 1:”, ls[1])\n\n# Access value of ‘fruit’ key in dictionary at index 1\n\nprint(“Value of key ‘fruit’:”, ls[1][‘fruit’])\n\nThis example demonstrates how to retrieve specific data from dictionaries stored in a list (ls). Here are the details:\n• ls[0]: Retrieves and prints the first dictionary in ls.\n• ls[0][‘car’]: Retrieves and prints the value associated with the key ‘car’ in the first dictionary.\n• ls[1]: Retrieves and prints the second dictionary in ls.\n• ls[1][‘fruit’]: Retrieves and prints the value associated with the key ‘fruit’ in the second dictionary.\n• Flexibility: Lists of dictionaries adeptly handle diverse data structures, making them ideal for managing complex datasets.\n• Ease of Access: Accessing and manipulating data is straightforward using simple indexing or iteration methods.\n• Data Transformation: They facilitate effortless filtering, updates, and transformations across dictionaries within the list.\n• Python lists of dictionaries are invaluable for tasks such as managing user profiles, handling product specifications, or facilitating data exchange in formats like JSON. They empower developers to create robust and scalable applications with ease.\n\nPython lists of dictionaries are essential tools in programming for efficiently managing diverse datasets. By combining the capabilities of lists and dictionaries, this data structure provides flexibility, straightforward data access, and seamless data transformation. Mastering Python lists of dictionaries enhances your ability to efficiently manage and manipulate data across various programming tasks. This versatile data structure is crucial for developing flexible and responsive applications in diverse domains."
    }
]