[
    {
        "link": "https://discuss.logseq.com/t/using-themes-and-custom-css-together/16874",
        "document": "Atkinson Hyperlegible, named after the founder of the Braille Institute, has been developed specifically to increase legibility for readers with low vision, and"
    },
    {
        "link": "https://discuss.logseq.com/t/css-documentation/28572",
        "document": "Is there a documentation for customizing through custom.css?\n\n I am trying to change the IMPORTANT block font size, but it would be nice to have reference to other customizations."
    },
    {
        "link": "https://reddit.com/r/logseq/comments/17ath0w/any_good_resources_on_making_and_publishing",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://docs.logseq.com",
        "document": ""
    },
    {
        "link": "https://github.com/pengx17/logseq-dev-theme",
        "document": "This theme is actively maintained and used on a daily basis by the author. It should have the best UX on macOS.\n• providing bullet threading for editing blocks (also available as a standalone plugin)\n\nCheck out my published knowledge garden at https://pengx17.github.io/knowledge-garden/. Though since the graph is read-only, you cannot test the bullet threading feature with it.\n\nThis theme and bullet threading is available in the Marketplace.\n\nAnother way to adopt this theme is to use jsDelivr CDN by adding the following line to your . You can also change the part to use the latest version. This is the ONLY way to stylish your published graph for now.\n\n/* This must be the first line of the custom.css with other import rules */ ( ); /* You can also add other styles below to override the default theme values */\n\nThis theme does not provide official customization options. However, you can still change most of the colors and fonts. Please take a look this issue for guidance.\n• If your theme defines border colors for the , the bullet threading css may not work as expected.\n• This theme is guaranteed to work with the latest Logseq version WITHOUT backward compability.\n\nYou may refer to Changelog, but it might not be well organized."
    },
    {
        "link": "https://discuss.logseq.com/t/easily-change-font-properties/11405",
        "document": "The ‘Awesome Styler’ theme provides a spot within Plugin Settings to change the colors of basic elements along with a few other tweaks, and a familiarity with basic CSS principles enables you to change just about anything in Logseq via the custom.css file. You can go to any theme’s CSS file via Github or after installation on your hard drive, read the code, and copy and paste whatever you want, changing whatever you want. Google as you go if you’re confused, or feel free to ask specific questions here.\n\nYou can use CSS media queries to change styles only on specific device types. Here’s an example of what I’m preparing for use on my iPhone, you should look up what the values for iPad would be (I think it’s a max of 1167px or so): /* MOBILE styles */ @media only screen /* and (min-device-width : 375px) */ and (max-device-width : 667px) { :root { --ls-page-text-size: 10px !important; } span, .block-content, .ls-block { font-size: 10px; font-weight: 200; } a.page-title, .title, .page-title, a.page-ref, span.page-reference { font-size: 11px !important; } } I commented the minimum out because it seemed unnecessary for my smallest device, but if you want to code for iPad and also iPhone, then your min should be my max. But basically, sticking normal rules inside the @media brackets should get you what you want. Here’s a link to Logseq’s default CSS on Github, so you can copy variables from the :root and hopefully have an easier time (since I’m not sure how you’d inspect the code directly). But any rules you already have in custom.css can be copied between the @media brackets to adjust for mobile-specific usage. This code piece goes in the same file (and I’d put it close to the top, as scrolling is more annoying on mobile than desktop).\n\nI guess I can’t speak for the OP, but what if I don’t want to change the color across the whole theme? Sometimes I just want to type a block (or series of blocks) in red, or blue, or #fcb103. Sometimes I want to set just a few words to be a different color than the surrounding text. I don’t want to highlight them, and I don’t want to be limited to a pre-determined set. I just want to be able to decide, on the fly, “This text should be #fcb103” and have it be that color."
    },
    {
        "link": "https://discuss.logseq.com/t/change-text-color-for-individual-blocks-or-even-words/20508",
        "document": "![image](https://github.com/logseq/logseq/assets/10263941/51d2dcb3-79b8-4f56-bd5…7-b4c11646abe5) ![image](https://github.com/logseq/logseq/assets/10263941/b64128a8-321f-49c8-9cb7-8d2b98c74865) I created a `text-color` property to set the text color of a block, allowing builtin colors like the highlight. This property is \"hidden\" but editable. Called it `text-color` to avoid ambiguity with the page `color` property, and be more explicit differencing it with `background-color`. What do you think of these colors? Should I change them, or are they fine? - [x] Adding Tests - [x] Check that using both logseq.text-color and background-color works"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascading_variables/Using_CSS_custom_properties",
        "document": "Custom properties (sometimes referred to as CSS variables or cascading variables) are entities defined by CSS authors that represent specific values to be reused throughout a document. They are set using the at-rule or by custom property syntax (e.g., ). Custom properties are accessed using the CSS function (e.g., ). Complex websites have very large amounts of CSS, and this often results in a lot of repeated CSS values. For example, it's common to see the same color used in hundreds of different places in stylesheets. Changing a color that's been duplicated in many places requires a search and replace across all rules and CSS files. Custom properties allow a value to be defined in one place, then referenced in multiple other places so that it's easier to work with. Another benefit is readability and semantics. For example, is easier to understand than the hexadecimal color , especially if the color is used in different contexts. Custom properties defined using two dashes ( ) are subject to the cascade and inherit their value from their parent. The at-rule allows more control over the custom property and lets you specify whether it inherits its value from a parent, what the initial value is, and the type constraints that should apply. Note: Variables do not work inside media queries and container queries. You can use the function in any part of a value in any property on an element. You cannot use for property names, selectors, or anything aside from property values, which means you can't use it in a media query or container query.\n\nUsing a prefix of two dashes ( ) A custom property prefixed with two dashes begins with , followed by the property name (e.g., ), and a property value that can be any valid CSS value. Like any other property, this is written inside a ruleset. The following example shows how to create a custom property and uses a value of : The selector given to the ruleset ( elements in the example above) defines the scope in which the custom property can be used. For this reason, a common practice is to define custom properties on the pseudo-class, so that it can be referenced globally: This doesn't always have to be the case: you maybe have a good reason for limiting the scope of your custom properties. Note: Custom property names are case sensitive — will be treated as a separate custom property to .\n\nFor some CSS declarations, it is possible to declare this higher in the cascade and let CSS inheritance solve this problem. For non-trivial projects, this is not always possible. By declaring a custom property on the pseudo-class and using it where needed throughout the document, a CSS author can reduce the need for repetition: /* Define --main-bg-color here */ :root { --main-bg-color: cornflowerblue; } /* For each class, set some colors */ .one { background-color: var(--main-bg-color); } .two { color: black; background-color: aquamarine; } .three { background-color: var(--main-bg-color); } .four { background-color: var(--main-bg-color); } .five { background-color: var(--main-bg-color); } This leads to the same result as the previous example, yet allows for one canonical declaration of the desired property value ( ), which is very useful if you want to change the value across the entire project later.\n\nA custom property defined using two dashes instead of always inherits the value of its parent. This is demonstrated in the following example: div { color: black; font-family: sans-serif; width: 75%; height: 80%; margin: 4px; border: 2px black solid; display: inline-block; } p { margin: 0; } .one { height: 250px; } .two { height: 80%; } .three { height: 40%; } .four { height: 40%; } The results of depending on inheritance are as follows:\n• : invalid value, which is the default value of a custom property defined in this way One aspect of custom properties that the examples above demonstrate is that they don't behave exactly like variables in other programming languages. The value is computed where it is needed, not stored and reused in other places of a stylesheet. For instance, you cannot set a property's value and expect to retrieve the value in a sibling's descendant's rule. The property is only set for the matching selector and its descendants.\n\nThe at-rule lets you explicitly state whether the property inherits or not. The following example creates a custom property using the at-rule. Inheritance is disabled, there's a data type defined, and an initial value of . The parent element sets to a value of and uses as a value for its background color. The child element also uses , and we would expect it to have the color if inheritance was enabled (or if it was defined using the double dash syntax). Because is set in the at-rule, and a value for the property is not declared within the scope, the initial value of is used instead of that would have been inherited from the parent:\n\nUsing the function, you can define multiple fallback values when the given variable is not yet defined; this can be useful when working with Custom Elements and Shadow DOM. The first argument to the function is the name of the custom property. The second argument to the function is an optional fallback value, which is used as the substitution value when the referenced custom property is invalid. The function accepts two parameters, assigning everything following the first comma as the second parameter. If the second parameter is invalid, the fallback will fail. For example: .one { /* Red if --my-var is not defined */ color: var(--my-var, red); } .two { /* pink if --my-var and --my-background are not defined */ color: var(--my-var, var(--my-background, pink)); } .three { /* Invalid: \"--my-background, pink\" */ color: var(--my-var, --my-background, pink); } Including a custom property as a fallback, as seen in the second example above ( ), is the correct way to provide more than one fallback with . You should be aware of the performance impact of this method, however, as it takes more time to parse through the nested variables. Note: The syntax of the fallback, like that of custom properties, allows commas. For example, defines a fallback of — anything between the first comma and the end of the function is considered a fallback value.\n\nFallbacks using the initial value Aside from using , the defined in the at-rule can be used as a fallback mechanism. In fact, we've already seen this in the inheritance section. The following example sets an initial value of to using the at-rule. In the ruleset following the at-rule, we want to set to , but there's a typo in the value name. The same is true for the third where we've used for the custom property that's expecting a valid value. Both and are invalid color values, so the initial value of is applied: @property --box-color { syntax: \"<color>\"; initial-value: cornflowerblue; inherits: false; } .one { --box-color: aquamarine; background-color: var(--box-color); } .two { --box-color: aqumarine; background-color: var(--box-color); } .three { --box-color: 2rem; background-color: var(--box-color); }\n\nEach CSS property can be assigned a defined set of values. If you try to assign a value to a property that is outside its set of valid values, it's considered invalid. When the browser encounters an invalid value for a regular CSS property (for example, a value of for the property), it discards the declaration, and elements are assigned the values that they would have had if the declaration did not exist. In the following example, we see what happens when a regular CSS declaration is invalid; is discarded and the previous rule is applied instead: However, when the values of custom properties are parsed, the browser doesn't yet know where they will be used, so it must consider nearly all values as valid. Unfortunately, these valid values can be used, via the functional notation, in a context where they might not make sense. Properties and custom variables can lead to invalid CSS statements, leading to the concept of valid at computed time. When the browser encounters an invalid substitution, then the initial or inherited value of the property is used. This example is just like the last one, except we use a custom property. The browser substitutes the value of in place of , but is not a valid property value for . After substitution, the property doesn't make sense., so the browser handles this situation in two steps:\n• Check if the property is inheritable. It is, but this doesn't have any parent with the property set. So we move on to the next step.\n• Set the value to its default initial value, which is black. For such cases, the at-rule can prevent unexpected results by allowing to define the initial value of the property:"
    },
    {
        "link": "https://reddit.com/r/logseq/comments/13reh8b/change_content_font",
        "document": "What is the CSS variable to change only the content font in Logseq? `--ls-font-family` changes the whole interface, but I only want what I manually write in markdown to have a different font."
    },
    {
        "link": "https://css-tricks.com/a-complete-guide-to-custom-properties",
        "document": "Here are some basic examples that you’d expect to work, and do.\n\nSee that? They can be hex values, color functions, units of all kinds, and even strings of text.\n\nBut custom properties don’t have to be complete values like that. Let’s look at how useful it can be to break up valid CSS values into parts we can shove into custom properties.\n\nLet’s imagine you’re using a color function, say . Each color channel value in there can be its own custom property. That opens up a ton of possibilities, like changing the alpha value for a specific use case, or perhaps creating color themes.\n\nTake HSL color, for example. We can split it up into parts, then very easily adjust the parts where we want. Maybe we’re working with the background color of a button. We can update specific parts of its HSL makeup when the button is hovered, in focus, or disabled, without declaring on any of those states at all.\n\nBy breaking apart values like that, we can control parts of them in a way we never could before. Just look at how we didn’t need to declare all of the HSL arguments to style the hover, focus and disabled state of a button. We simply overrode specific HSL values when we needed to. Pretty cool stuff!\n\nAny property that supports multiple comma-separated values might be a good candidate for splitting values too, since there is no such thing as targeting just one value of a comma-separated list and changing it alone.\n\nSay you wanted to remove just one of many multiple backgrounds at a media query. You could do that with custom properties like this, making it a trivial task to swap or override backgrounds.\n\nThere are times when combining parts of values doesn’t work quite how you might hope. For example, you can’t make by smashing and together. It can be done though, by multiplying the raw number by a number value with a unit.\n\nYou’ve already seen it in action in many of the examples we’ve covered, but let’s put a point on it. Say we have a custom property set pretty “high up” (on the body), and then set again on a specific class. We use it on a specific component.\n\nThen say we’ve got practical HTML like this:\n\nThe “module” in the sidebar has a gray background because custom properties (like many other CSS properties) inherit through the HTML structure. Each module takes the value from the nearest “ancestor” where it’s been defined in CSS.\n\nSo, we have one CSS declaration but it’s doing different things in different contexts, thanks to the cascade. That’s just cool.\n\nThis plays out in other ways:\n\nMedia queries don’t change specificity, but they often come later (or lower) in the CSS file than where the original selector sets a value, which also means a custom property will be overridden inside the media query:\n\nMedia queries aren’t only for screen sizes. They can be used for things like accessibility preferences. For example, dark mode:\n\nYou’ll often see custom properties being set “at the root.” Here’s what that means:\n\nThere is no particularly compelling reason to define custom properties like that. It’s just a way of setting custom properties as high up as they can go. If you like that, that’s totally fine. I find it somehow more normal-feeling to apply them to the or selectors when setting properties I intend to make available globally, or everywhere.\n\nThere is also no reason you need to set variables at this broad of a scope. It can be just as useful, and perhaps more readable and understandable, to set them right at the level you are going to use them (or fairly close in the DOM tree).\n\nNote that setting a custom property on the module itself means that property will no longer inherit from an ancestor (unless we set the value to ). Like other inherited properties, there are sometimes reasons to specify them in place (at the global level), and other times we want to inherit them from context (at the component level). Both are useful. What’s cool about custom properties is that we can define them in one place, inherit them behind the scenes and apply them somewhere completely different. We take control of the cascade!\n\nApplying to the variable, makes it difficult to override the value of the variable, but we can still ignore it by changing the property.\n\nThe behavior of inside the values of custom properties is quite unusual. Stefan Judis documents it well, but the gist is:\n• Ultimately, is stripped from the value of the custom property.\n• But it is used when determining which value wins when it is set in multiple places.\n\nIf both of those selectors apply to an element, you might think the value would win because of the higher specificity, but really will win because of the , but then ultimately be applied without the . It’s a little funky to wrap your head around.\n\nIf applying the outside of the custom property, like the 2nd example two code blocks up, our variable remains low-specificity (easy to override), but it’s hard to change how that value will be applied to the itself because the entire declaration retains .\n\nHere we’re setting a transform function to a custom property, but there is a comma-separated second value of . That value will be used if is not set.\n\nAfter the first comma, any additional commas are part of the fallback value. That allows us to create fallbacks with comma-separated values inside them. For example, we can have one variable fall back to an entire stack of fonts:\n\nWe can also provide a series of variable fallbacks (as many as we want), but we have to nest them for that to work:\n\nIf is undefined, we try the . If that is also undefined, we finally fall back to .\n\nThis kind of thing is common:\n\nWe could also use that to calculate the hue of a complementary color:\n\ncan even be used with multiple custom properties:\n\nIt might look weird to see calculous-like math without a :\n\nThe trick is that as long as you eventually put it in a function, it works fine:\n\nThis might be useful if you’re doing quite a bit of math on your variables, and the wrapper becomes distracting or noisy in the code.\n\nIt’s sort of like you’re creating an actual CSS property and have the ability to define what it’s called, it’s syntax, how it interacts with the cascade, and its initial value.\n\nThis means that the browser knows what kind of value it is dealing with, rather than assuming everything is a string. That means you can animate things in ways you couldn’t otherwise.\n\nFor example, say you have a star-shaped icon that you want to spin around with and rotate with a . So you do this:\n\nThat actually won’t work, as the browser doesn’t know that and are valid angle values. You have to define them as an type with for that to work.\n\nThis can be a smidge confusing. Maybe not so much this:\n\nBut below, you’ll need a sharp eye to realize the fallback value is actually . The first comma separates the fallback, but all the rest is part of the value.\n\nLearn more about fallbacks above ⮑\n\nHere’s a few more favorite examples that show off advanced usage of custom properties:\n\nThink of queries and how when one thing changes (e.g. the width of the page) you can control multiple things. That’s kind of the idea with this trick. You change one custom property and control multiple things.\n\nThe trick is that the value of for a custom property will trigger a fallback, while an empty whitespace value will not. For the sake of explanation, it let’s define two globally-scoped custom properties, and :\n\nSay we have a “dark” variation class which sets a number of different properties. The default is , but can be flipped to whenever:\n\nNow you can use to conditinally set values that apply only when you’ve flipped to . Demo:\n\nLea Verou has a great writeup that covers all of this.\n\nIt’s totally legit to set a custom property in HTML with an inline style.\n\nThat will, like any inline style, have a very high level of specificity.\n\nThis can be super useful for when the HTML might have access to some useful styling information that would be too weird/difficult to put into a static CSS file. A good example of that is maintaining the aspect ratio of an element:\n\nNow I can set up some CSS to make a box of that exact size wherever I need to. The full writeup on that is here, but here’s CSS that uses trickery like the ol’ padded box applied to a pseudo element which pushes the box to the desired size:\n\nBut hey, these days, we have a native property in CSS, so setting that in the inline style might make more sense going forward.\n\nThere is no way to apply a style (or other pseudo classes/elements) with inline styles. That is, unless we get tricky with custom properties. Say we want custom hover colors on some boxes — we can pass that information in as a custom property:\n\nThen use it in CSS which, of course, can style a link’s hover state:\n\nHere’s an example of a red square that is positioned with custom properties, and JavaScript updates those custom property values with the mouse position:\n\nTypically you think of JavaScript passing values to CSS to use, which is probably 99% of usage here, but note that you can pass things from CSS to JavaScript as well. As we’ve seen, the value of a custom property can be fairly permissive. That means you could pass it a logical statement. For example:\n\nThen grab that value and execute it in JavaScript:\n\nCustom properties are different than preprocessor variables\n\nSo, do you even need to bother with native CSS custom properties then? Yes, you should. Here’s why in a nutshell:\n• Native CSS custom properties are more powerful then preprocessor variables. Their integration with the cascade in the DOM is something that preprocessor variables will never be able to do.\n• Native CSS custom properties are dynamic. When they change (perhaps via JavaScript, or with a media query), the browser repaints what it needs to. Preprocessor variables resolve to a value when they’re compiled and stay at that value.\n• Going with a native feature is good for the longevity of your code. You don’t need to preprocess native CSS.\n\nI cover this in much more detail in the article “What is the difference between CSS variables and preprocessor variables?”\n\nTo be totally fair, there are little things that preprocessor variables can do that are hard or impossible with custom properties. Say you wanted to strip the units off a value for example. You can do that in Sass but you’ll have a much harder time with custom properties in CSS alone.\n\nKinda. You can do this, with Sass just to pick one popular preprocessor:\n\nAll that’s doing is moving a Sass variable to a custom property. That could be useful sometimes, but not terribly. Sass will just make there, not process the custom property away.\n\nIf a browser doesn’t support custom properties, that’s that. You can’t force a browser to do what custom properties do by CSS syntax transformations alone. There might be some kind of JavaScript polyfill that parses your CSS and replicates it, but I really don’t suggest that.\n\nThe PostCSS Custom Properties plugin, though, does do CSS syntax transforms to help. What it does is figure out the value to the best of it’s ability, and outputs that along with the custom property. So like:\n\nWill output like this:\n\nThat means you get a value that hopefully doesn’t seem broken in browsers that lack custom property support, but does not support any of the fancy things you can do with custom properties and will not even attempt to try. I’m a bit dubious about how useful that is, but I think this is about the best you can do and I like the spirit of attempting to not break things in older browsers or newer browsers.\n\nAnother thing that is worth noting about the difference between is that with a CSS preprocessor, the variables are available only as you’re processing. Something like is meaningless in your HTML or JavaScript. But when you have custom properties in use, you can set inline styles that use those custom properties and they will work. Or you can use JavaScript to figure out their current values (in context), if needed.\n\nAside from some somewhat esoteric features of preprocessor variables (e.g. some math possibilities), custom properties are more capable and useful.\n\nThe main point of the shadow DOM is that it doesn’t “leak” styles in or out of it, offering style isolation in a way that nothing else offers, short of an . Styles do still cascade their way inside, I just can’t select my way inside. This means custom properties will slide right in there.\n\nAnother common occurrence of the shadow DOM is with SVG and the element.\n\nYou can preprocess for deeper browser support, with heavy limitations.\n\nIf you would like to write conditional CSS for when a browser supports custom properties or not:\n\nThanks to Miriam Suzanne for co-authoring this with me!"
    }
]