[
    {
        "link": "https://stackoverflow.com/questions/8886947/caesar-cipher-function-in-python",
        "document": "I'm trying to create a simple Caesar Cipher function in Python that shifts letters based on input from the user and creates a final, new string at the end. The only problem is that the final cipher text shows only the last shifted character, not an entire string with all the shifted characters.\n\nI realize that this answer doesn't really answer your question, but I think it's helpful anyway. Here's an alternative way to implementing the caesar cipher with string methods: In fact, since string methods are implemented in C, we will see an increase in performance with this version. This is what I would consider the 'pythonic' way of doing this.\n\n# See http://ascii.cl/ upper = {ascii:chr(ascii) for ascii in range(65,91)} lower = {ascii:chr(ascii) for ascii in range(97,123)} digit = {ascii:chr(ascii) for ascii in range(48,58)} def ceasar(s, k): for c in s: o = ord(c) # Do not change symbols and digits if (o not in upper and o not in lower) or o in digit: yield o else: # If it's in the upper case and # that the rotation is within the uppercase if o in upper and o + k % 26 in upper: yield o + k % 26 # If it's in the lower case and # that the rotation is within the lowercase elif o in lower and o + k % 26 in lower: yield o + k % 26 # Otherwise move back 26 spaces after rotation. else: # alphabet. yield o + k % 26 -26 x = (''.join(map(chr, ceasar(s, k)))) print (x)\n\nAs pointed by others, you were resetting the cipherText in the iteration of the for loop. Placing cipherText before the start of the for loop will solve your problem. Additionally, there is an alternate approach to solving this problem using Python's Standard library. The Python Standard Library defines a function maketrans() and a method translate that operates on strings. The function maketrans() creates translation tables that can be used with the translate method to change one set of characters to another more efficiently. (Quoted from The Python Standard Library by Example). import string def caesar(plaintext, shift): shift %= 26 # Values greater than 26 will wrap around alphabet_lower = string.ascii_lowercase alphabet_upper = string.ascii_uppercase shifted_alphabet_lower = alphabet_lower[shift:] + alphabet_lower[:shift] shifted_alphabet_upper = alphabet_upper[shift:] + alphabet_upper[:shift] alphabet = alphabet_lower + alphabet_upper shifted_alphabet = shifted_alphabet_lower + shifted_alphabet_upper table = string.maketrans(alphabet, shifted_alphabet) return plaintext.translate(table)\n\nThis solution is more intuitively without the use of function: def caesar_cipher(raw_text, key): alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" shifted_alphabet = alphabet[26-key:]+alphabet[0:(26-key)] cipher_text = \"\" for i in range(len(raw_text)): char = raw_text[i] idx = alphabet.find(char.upper()) if idx == -1: cipher_text = cipher_text + char elif char.islower(): cipher_text = cipher_text + shifted_alphabet[idx].lower() else: cipher_text = cipher_text + shifted_alphabet[idx] return(cipher_text) plain_text = \"The quick brown fox jumps over the lazy dog!\" caesar_cipher(plain_text,3) If we want to decrypt it: 'The quick brown fox jumps over the lazy dog!'"
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://stackoverflow.com/questions/18030314/python-caesar-cipher-using-ord-and-chr",
        "document": "I thought i've learned enough python to make a caesar cipher, so I started making it and i've hit a brick wall.\n\nHere is my code:\n\nAt the moment if the phrase is 'hi' and shift is 1 , the for loop just loops around the letter i, not the letter h, so my result is: j\n\nI want to loop around the whole word and shift each letter by whatever the shift int variable is.\n\nHow can I loop around the phrase variable?"
    },
    {
        "link": "https://community.ibm.com/community/user/ibmz-and-linuxone/blogs/subhasish-sarkar1/2020/07/04/caesar-cipher-implementation-in-python",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/caesar-cipher-in-cryptography",
        "document": "The Caesar Cipher is one of the simplest and oldest methods of encrypting messages, named after Julius Caesar, who reportedly used it to protect his military communications. This technique involves shifting the letters of the alphabet by a fixed number of places. For example, with a shift of three, the letter ‘A’ becomes ‘D’, ‘B’ becomes ‘E’, and so on. Despite its simplicity, the Caesar Cipher formed the groundwork for modern cryptographic techniques. In this article, we’ll explore how the Caesar Cipher works, its significance, and its impact on the development of cryptography with its advantages and disadvantages.\n\nThe Caesar cipher is a simple encryption technique that was used by Julius Caesar to send secret messages to his allies. It works by shifting the letters in the plaintext message by a certain number of positions, known as the “shift” or “key”. The Caesar Cipher technique is one of the earliest and simplest methods of encryption techniques.\n\nIt’s simply a type of substitution cipher, i.e., each letter of a given text is replaced by a letter with a fixed number of positions down the alphabet. For example with a shift of 1, A would be replaced by B, B would become C, and so on. The method is apparently named after Julius Caesar, who apparently used it to communicate with his officials.\n• None Thus to cipher a given text we need an integer value, known as a shift which indicates the number of positions each letter of the text has been moved down. \n\n The encryption can be represented using modular arithmetic by first transforming the letters into numbers, according to the scheme, A = 0, B = 1,…, Z = 25. Encryption of a letter by a shift n can be described mathematically as.\n• None For example, if the shift is 3, then the letter A would be replaced by the letter D, B would become E, C would become F, and so on. The alphabet is wrapped around so that after Z, it starts back at A.\n• None Here is an example of how to use the Caesar cipher to encrypt the message “HELLO” with a shift of 3:\n• None Write down the plaintext message: HELLO\n• None Choose a shift value. In this case, we will use a shift of 3.\n• None Replace each letter in the plaintext message with the letter that is three positions to the right in the alphabet.\n\nH becomes K (shift 3 from H) \n\n E becomes H (shift 3 from E) \n\n L becomes O (shift 3 from L) \n\n L becomes O (shift 3 from L) \n\n O becomes R (shift 3 from O)\n• None To decrypt the message, you simply need to shift each letter back by the same number of positions. In this case, you would shift each letter in “KHOOR” back by 3 positions to get the original message, “HELLO”.\n• None Easy to implement and use thus, making suitable for beginners to learn about encryption.\n• None Can be physically implemented, such as with a set of rotating disks or a set of cards, known as a scytale, which can be useful in certain situations.\n• None Can be modified easily to create a more secure variant, such as by using a multiple shift values or keywords.\n• None It is not secure against modern decryption methods.\n• None Vulnerable to known-plaintext attacks, where an attacker has access to both the encrypted and unencrypted versions of the same messages.\n• None The small number of possible keys means that an attacker can easily try all possible keys until the correct one is found, making it vulnerable to a brute force attack.\n• None It is not suitable for long text as it would be easy to crack.\n• None It is not suitable for secure communication as it is easily broken.\n• None Does not provide confidentiality, integrity, and authenticity in a message.\n• Substitution cipher: The Caesar cipher is a type of , where each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet.\n• Fixed key: The Caesar cipher uses a fixed key, which is the number of positions by which the letters are shifted. This key is known to both the sender and the receiver.\n• Symmetric encryption: technique, meaning that the same key is used for both encryption and decryption.\n• Limited keyspace: The Caesar cipher has a very limited keyspace of only 26 possible keys, as there are only 26 letters in the English alphabet.\n• Vulnerable to brute force attacks: The Caesar cipher is vulnerable to , as there are only 26 possible keys to try.\n• Easy to implement: The Caesar cipher is very easy to implement and requires only simple arithmetic operations, making it a popular choice for simple encryption tasks.\n• None Choose a number between 1 and 25. This will be your “shift” value.\n• None Write down the letters of the alphabet in order, from A to Z.\n• None Shift each letter of the alphabet by the “shift” value. For example, if the shift value is 3, A would become D, B would become E, C would become F, and so on.\n• None Encrypt your message by replacing each letter with the corresponding shifted letter. For example, if the shift value is 3, the word “hello” would become “khoor”.\n• None To decrypt the message, simply reverse the process by shifting each letter back by the same amount. For example, if the shift value is 3, the encrypted message “khoor” would become “hello”.\n• None Choose a shift value between 1 and 25.\n• None Write down the alphabet in order from A to Z.\n• None Create a new alphabet by shifting each letter of the original alphabet by the shift value. For example, if the shift value is 3, the new alphabet would be:\n• None Replace each letter of the message with the corresponding letter from the new alphabet. For example, if the shift value is 3, the word “hello” would become “khoor”.\n• None To decrypt the message, shift each letter back by the same amount. For example, if the shift value is 3, the encrypted message “khoor” would become “hello”.\n• None Traverse the given text one character at a time .\n• None For each character, transform the given character as per the rule, depending on whether we’re\n\nA program that receives a Text (string) and Shift value( integer) and returns the encrypted text.\n\nTime complexity: O(N) where N is length of the given text\n\nAuxiliary space: O(N)\n\nHow to decrypt? \n\nWe can either write another function decrypt similar to encrypt, that’ll apply the given shift in the opposite direction to decrypt the original text. However we can use the cyclic property of the cipher under modulo, hence we can simply observe\n\nHence, we can use the same function to decrypt, instead, we’ll modify the shift value such that shift = 26-shift (Refer to this for a sample run in C++).\n\nThe Caesar Cipher, with its straightforward approach of shifting letters, serves as an excellent introduction to the world of cryptography. While it is easy to understand and implement, its simplicity also makes it vulnerable to basic attacks. Despite these limitations, the Caesar Cipher’s historical role is significant, it represents the early efforts to secure communication and has made the way for the more advanced encryption methods used today. Understanding the Caesar Cipher helps us appreciate the evolution of cryptographic techniques and the ongoing quest to protect information in our digital age.\n\nWhat is the Caesar cipher in cryptography?\n\nWhat is an example of decryption in Caesar cipher?\n\nWhat are keys in Caesar cipher?"
    },
    {
        "link": "https://tutorialspoint.com/cryptography_with_python/cryptography_with_python_quick_guide.htm",
        "document": "Cryptography is the art of communication between two users via coded messages. The science of cryptography emerged with the basic motive of providing security to the confidential messages transferred from one party to another.\n\nCryptography is defined as the art and science of concealing the message to introduce privacy and secrecy as recognized in information security.\n\nThe frequently used terms in cryptography are explained here −\n\nThe plain text message is the text which is readable and can be understood by all users. The plain text is the message which undergoes cryptography.\n\nCipher text is the message obtained after applying cryptography on plain text.\n\nThe process of converting plain text to cipher text is called encryption. It is also called as encoding.\n\nThe process of converting cipher text to plain text is called decryption. It is also termed as decoding.\n\nThe diagram given below shows an illustration of the complete process of cryptography −\n\nThe basic characteristics of modern cryptography are as follows −\n• None It uses mathematical algorithms for securing the information.\n• None It requires parties interested in secure communication channel to achieve privacy.\n\nDouble strength encryption, also called as multiple encryption, is the process of encrypting an already encrypted text one or more times, either with the same or different algorithm/pattern.\n\nThe other names for double strength encryption include cascade encryption or cascade ciphering.\n\nDouble strength encryption includes various levels of encryption that are explained here under −\n\nThe cipher text is generated from the original readable message using hash algorithms and symmetric keys. Later symmetric keys are encrypted with the help of asymmetric keys. The best illustration for this pattern is combining the hash digest of the cipher text into a capsule. The receiver will compute the digest first and later decrypt the text in order to verify that text is not tampered in between.\n\nSecond layer of encryption is the process of adding one more layer to cipher text with same or different algorithm. Usually, a 32-bit character long symmetric password is used for the same.\n\nIn this process, the encrypted capsule is transmitted via SSL/TLS connection to the communication partner.\n\nHybrid cryptography is the process of using multiple ciphers of different types together by including benefits of each of the cipher. There is one common approach which is usually followed to generate a random secret key for a symmetric cipher and then encrypt this key via asymmetric key cryptography.\n\nDue to this pattern, the original message itself is encrypted using the symmetric cipher and then using secret key. The receiver after receiving the message decrypts the message using secret key first, using his/her own private key and then uses the specified key to decrypt the message.\n\nPython is an open source scripting language which is high-level, interpreted, interactive and object-oriented. It is designed to be highly readable. The syntax of Python language is easy to understand and uses English keywords frequently.\n\nPython provides the following major features −\n\nPython is processed at runtime using the interpreter. There is no need to compile a program before execution. It is similar to PERL and PHP.\n\nPython follows object-oriented style and design patterns. It includes class definition with various features like encapsulation and polymorphism.\n\nThe key points of Python programming language are as follows −\n• None It includes functional and structured programming and methods as well as object oriented programming methods.\n• None It can be used as a scripting language or as a programming language.\n• None It includes high-level dynamic data types and supports various dynamic type checking.\n• None Python includes a feature of integration with C, C++ and languages like Java.\n\nThe download link for Python language is as follows − www.python.org/downloadsIt includes packages for various operating systems like Windows, MacOS and Linux distributions.\n\nThe basic declaration of strings is shown below −\n\nThe lists of python can be declared as compound data types, separated by commas and enclosed within square brackets ([]).\n\nA tuple is dynamic data type of Python which consists of number of values separated by commas. Tuples are enclosed with parentheses.\n\nPython dictionary is a type of hash table. A dictionary key can be almost any data type of Python, which are usually numbers or strings.\n\nPython includes a package called cryptography which provides cryptographic recipes and primitives. It supports Python 2.7, Python 3.4+, and PyPy 5.3+. The basic installation of cryptography package is achieved through following command −\n\nThere are various packages with both high level recipes and low level interfaces to common cryptographic algorithms such as symmetric ciphers, message digests and key derivation functions.\n\nThroughout this tutorial, we will be using various packages of Python for implementation of cryptographic algorithms.\n\nThe previous chapter gave you an overview of installation of Python on your local computer. In this chapter you will learn in detail about reverse cipher and its coding.\n\nThe algorithm of reverse cipher holds the following features −\n• None Reverse Cipher uses a pattern of reversing the string of plain text to convert as cipher text.\n• None The process of encryption and decryption is same.\n• None To decrypt cipher text, the user simply needs to reverse the cipher text to get the plain text.\n\nThe major drawback of reverse cipher is that it is very weak. A hacker can easily break the cipher text to get the original message. Hence, reverse cipher is not considered as good option to maintain secure communication channel,.\n\nConsider an example where the statement This is program to explain reverse cipher is to be implemented with reverse cipher algorithm. The following python code uses the algorithm to obtain the output.\n\nYou can see the reversed text, that is the output as shown in the following image −\n• None Plain text is stored in the variable message and the translated variable is used to store the cipher text created.\n• None The length of plain text is calculated using for loop and with help of index number. The characters are stored in cipher text variable translated which is printed in the last line.\n\nIn the last chapter, we have dealt with reverse cipher. This chapter talks about Caesar cipher in detail.\n\nThe algorithm of Caesar cipher holds the following features −\n• None Caesar Cipher Technique is the simple and easy method of encryption technique.\n• None It is simple type of substitution cipher.\n• None Each letter of plain text is replaced by a letter with some fixed number of positions down with alphabet.\n\nThe following diagram depicts the working of Caesar cipher algorithm implementation −\n\nThe program implementation of Caesar cipher algorithm is as follows −\n\nYou can see the Caesar cipher, that is the output as shown in the following image −\n\nThe plain text character is traversed one at a time.\n• None For each character in the given plain text, transform the given character as per the rule depending on the procedure of encryption and decryption of text.\n• None After the steps is followed, a new string is generated which is referred as cipher text.\n\nThe cipher text can be hacked with various possibilities. One of such possibility is Brute Force Technique, which involves trying every possible decryption key. This technique does not demand much effort and is relatively simple for a hacker.\n\nThe program implementation for hacking Caesar cipher algorithm is as follows −\n\nConsider the cipher text encrypted in the previous example. Then, the output with possible hacking methods with the key and using brute force attack technique is as follows −\n\nTill now, you have learnt about reverse cipher and Caesar cipher algorithms. Now, let us discuss the ROT13 algorithm and its implementation.\n\nROT13 cipher refers to the abbreviated form Rotate by 13 places. It is a special case of Caesar Cipher in which shift is always 13. Every letter is shifted by 13 places to encrypt or decrypt the message.\n\nThe following diagram explains the ROT13 algorithm process pictorially −\n\nThe program implementation of ROT13 algorithm is as follows −\n\nYou can see the ROT13 output as shown in the following image −\n\nThe ROT13 algorithm uses 13 shifts. Therefore, it is very easy to shift the characters in the reverse manner to decrypt the cipher text.\n\nROT13 cipher algorithm is considered as special case of Caesar Cipher. It is not a very secure algorithm and can be broken easily with frequency analysis or by just trying possible 25 keys whereas ROT13 can be broken by shifting 13 places. Therefore, it does not include any practical use.\n\nTransposition Cipher is a cryptographic algorithm where the order of alphabets in the plaintext is rearranged to form a cipher text. In this process, the actual plain text alphabets are not included.\n\nA simple example for a transposition cipher is columnar transposition cipher where each character in the plain text is written horizontally with specified alphabet width. The cipher is written vertically, which creates an entirely different cipher text.\n\nConsider the plain text hello world, and let us apply the simple columnar transposition technique as shown below\n\nThe plain text characters are placed horizontally and the cipher text is created with vertical format as : holewdlo lr. Now, the receiver has to use the same table to decrypt the cipher text to plain text.\n\nThe following program code demonstrates the basic implementation of columnar transposition technique −\n• None Using the function split_len(), we can split the plain text characters, which can be placed in columnar or row format.\n• None encode method helps to create cipher text with key specifying the number of columns and prints the cipher text by reading characters through each column.\n\nThe program code for the basic implementation of columnar transposition technique gives the following output −\n\nNote − Cryptanalysts observed a significant improvement in crypto security when transposition technique is performed. They also noted that re-encrypting the cipher text using same transposition cipher creates better security.\n\nIn the previous chapter, we have learnt about Transposition Cipher. In this chapter, let us discuss its encryption.\n\nThe main usage of pyperclip plugin in Python programming language is to perform cross platform module for copying and pasting text to the clipboard. You can install python pyperclip module using the command as shown\n\nIf the requirement already exists in the system, you can see the following output −\n\nThe python code for encrypting transposition cipher in which pyperclip is the main module is as shown below −\n\nThe program code for encrypting transposition cipher in which pyperclip is the main module gives the following output −\n• None The function main() calls the encryptMessage() which includes the procedure for splitting the characters using len function and iterating them in a columnar format.\n• None The main function is initialized at the end to get the appropriate output.\n\nIn this chapter, you will learn the procedure for decrypting the transposition cipher.\n\nObserve the following code for a better understanding of decrypting a transposition cipher. The cipher text for message Transposition Cipher with key as 6 is fetched as Toners raiCntisippoh.\n\nThe cipher text and the mentioned key are the two values taken as input parameters for decoding or decrypting the cipher text in reverse technique by placing characters in a column format and reading them in a horizontal manner.\n\nYou can place letters in a column format and later combined or concatenate them together using the following piece of code −\n\nThe program code for decrypting transposition cipher gives the following output −\n\nIn Python, it is possible to encrypt and decrypt files before transmitting to a communication channel. For this, you will have to use the plugin PyCrypto. You can installation this plugin using the command given below.\n\nThe program code for encrypting the file with password protector is mentioned below −\n\nYou can use the following command to execute the encryption process along with password −\n\nYou can observe the following output when you execute the code given above −\n\nThe passwords are generated using MD5 hash algorithm and the values are stored in simply safe backup files in Windows system, which includes the values as displayed below −\n\nIn this chapter, let us discuss decryption of files in cryptography using Python. Note that for decryption process, we will follow the same procedure, but instead of specifying the output path, we will focus on input path or the necessary file which is encrypted.\n\nThe following is a sample code for decrypting files in cryptography using Python −\n\nYou can use the following command for executing the above code −\n\nYou can observe the following code when you execute the command shown above −\n\nNote − The output specifies the hash values before encryption and after decryption, which keeps a note that the same file is encrypted and the process was successful.\n\nBase64 encoding converts the binary data into text format, which is passed through communication channel where a user can handle text safely. Base64 is also called as Privacy enhanced Electronic mail (PEM) and is primarily used in email encryption process.\n\nPython includes a module called BASE64 which includes two primary functions as given below −\n• None base64.decode(input, output) − It decodes the input value parameter specified and stores the decoded output as an object.\n• None Base64.encode(input, output) − It encodes the input value parameter specified and stores the decoded output as an object.\n\nYou can use the following piece of code to perform base64 encoding −\n\nThe code for base64 encoding gives you the following output −\n\nYou can use the following piece of code to perform base64 decoding −\n\nThe code for base64 decoding gives you the following output −\n\nYou can observe the following differences when you work on ASCII and base64 for encoding data −\n• None When you encode text in ASCII, you start with a text string and convert it to a sequence of bytes.\n• None When you encode data in Base64, you start with a sequence of bytes and convert it to a text string.\n\nBase64 algorithm is usually used to store passwords in database. The major drawback is that each decoded word can be encoded easily through any online tool and intruders can easily get the information.\n\nIn this chapter, let us understand the XOR process along with its coding in Python.\n\nXOR algorithm of encryption and decryption converts the plain text in the format ASCII bytes and uses XOR procedure to convert it to a specified byte. It offers the following advantages to its users −\n• No difference marked in left and right side\n\nYou can use the following piece of code to perform XOR process −\n\nThe code for XOR process gives you the following output −\n• None The function xor_crypt_string() includes a parameter to specify mode of encode and decode and also the string value.\n• None The basic functions are taken with base64 modules which follows the XOR procedure/ operation to encrypt or decrypt the plain text/ cipher text.\n\nNote − XOR encryption is used to encrypt data and is hard to crack by brute-force method, that is by generating random encrypting keys to match with the correct cipher text.\n\nWhile using Caesar cipher technique, encrypting and decrypting symbols involves converting the values into numbers with a simple basic procedure of addition or subtraction.\n\nIf multiplication is used to convert to cipher text, it is called a wrap-around situation. Consider the letters and the associated numbers to be used as shown below −\n\nThe numbers will be used for multiplication procedure and the associated key is 7. The basic formula to be used in such a scenario to generate a multiplicative cipher is as follows −\n\nThe number fetched through output is mapped in the table mentioned above and the corresponding letter is taken as the encrypted letter.\n\nThe basic modulation function of a multiplicative cipher in Python is as follows −\n\nNote − The advantage with a multiplicative cipher is that it can work with very large keys like 8,953,851. It would take quite a long time for a computer to brute-force through a majority of nine million keys.\n\nAffine Cipher is the combination of Multiplicative Cipher and Caesar Cipher algorithm. The basic implementation of affine cipher is as shown in the image below −\n\nIn this chapter, we will implement affine cipher by creating its corresponding class that includes two basic functions for encryption and decryption.\n\nYou can use the following code to implement an affine cipher −\n\nYou can observe the following output when you implement an affine cipher −\n\nThe output displays the encrypted message for the plain text message Affine Cipher and decrypted message for the message sent as input abcdefg.\n\nIn this chapter, you will learn about monoalphabetic cipher and its hacking using Python.\n\nA Monoalphabetic cipher uses a fixed substitution for encrypting the entire message. A monoalphabetic cipher using a Python dictionary with JSON objects is shown here −\n\nWith help of this dictionary, we can encrypt the letters with the associated letters as values in JSON object. The following program creates a monoalphabetic program as a class representation which includes all the functions of encryption and decryption.\n\nThis file is called later to implement the encryption and decryption process of Monoalphabetic cipher which is mentioned as below −\n\nYou can observe the following output when you implement the code given above −\n\nThus, you can hack a monoalphabetic cipher with specified key value pair which cracks the cipher text to actual plain text.\n\nSimple substitution cipher is the most commonly used cipher and includes an algorithm of substituting every plain text character for every cipher text character. In this process, alphabets are jumbled in comparison with Caesar cipher algorithm.\n\nKeys for a simple substitution cipher usually consists of 26 letters. An example key is −\n\nAn example encryption using the above key is−\n\nThe following code shows a program to implement simple substitution cipher −\n\nYou can observe the following output when you implement the code given above −\n\nIn this chapter, we will focus on testing substitution cipher using various methods, which helps to generate random strings as given below −\n\nYou can observe the output as randomly generated strings which helps in generating random plain text messages, as shown below −\n\nAfter the test is successfully completed, we can observe the output message Substitution test passed!.\n\nThus, you can hack a substitution cipher in the systematic manner.\n\nIn this chapter, you can learn about simple implementation of substitution cipher which displays the encrypted and decrypted message as per the logic used in simple substitution cipher technique. This can be considered as an alternative approach of coding.\n\nYou can use the following code to perform decryption using simple substitution cipher −\n\nThe above code gives you the output as shown here −\n\nIn this chapter, you will learn in detail about various modules of cryptography in Python.\n\nIt includes all the recipes and primitives, and provides a high level interface of coding in Python. You can install cryptography module using the following command −\n\nYou can use the following code to implement the cryptography module −\n\nThe code given above produces the following output −\n\nThe code given here is used to verify the password and creating its hash. It also includes logic for verifying the password for authentication purpose.\n\nScenario 1 − If you have entered a correct password, you can find the following output −\n\nScenario 2 − If we enter wrong password, you can find the following output −\n\nHashlib package is used for storing passwords in a database. In this program, salt is used which adds a random sequence to the password string before implementing the hash function.\n\nVignere Cipher includes a twist with Caesar Cipher algorithm used for encryption and decryption. Vignere Cipher works similar to Caesar Cipher algorithm with only one major distinction: Caesar Cipher includes algorithm for one-character shift, whereas Vignere Cipher includes key with multiple alphabets shift.\n\nFor encryption the mathematical equation is as follows −\n\nFor decryption the mathematical equation is as follows −\n\nVignere cipher uses more than one set of substitutions, and hence it is also referred as polyalphabetic cipher. Vignere Cipher will use a letter key instead of a numeric key representation: Letter A will be used for key 0, letter B for key 1 and so on. Numbers of the letters before and after encryption process is shown below −\n\nThe possible combination of number of possible keys based on Vignere key length is given as follows, which gives the result of how secure is Vignere Cipher Algorithm −\n\nThe tableau used for Vignere cipher is as shown below −\n\nIn this chapter, let us understand how to implement Vignere cipher. Consider the text This is basic implementation of Vignere Cipher is to be encoded and the key used is PIZZA.\n\nYou can use the following code to implement a Vignere cipher in Python −\n\nYou can observe the following output when you implement the code given above −\n\nThe possible combinations of hacking the Vignere cipher is next to impossible. Hence, it is considered as a secure encryption mode.\n\nOne-time pad cipher is a type of Vignere cipher which includes the following features −\n• None It is an unbreakable cipher.\n• None The key is exactly same as the length of message which is encrypted.\n• None The key is made up of random symbols.\n• None As the name suggests, key is used one time only and never used again for any other message to be encrypted.\n\nDue to this, encrypted message will be vulnerable to attack for a cryptanalyst. The key used for a one-time pad cipher is called pad, as it is printed on pads of paper.\n\nWhy is it Unbreakable?\n\nThe key is unbreakable owing to the following features −\n• None The key is as long as the given message.\n• None The key is truly random and specially auto-generated.\n• None Each key should be used once and destroyed by both sender and receiver.\n• None There should be two copies of key: one with the sender and other with the receiver.\n\nTo encrypt a letter, a user needs to write a key underneath the plaintext. The plaintext letter is placed on the top and the key letter on the left. The cross section achieved between two letters is the plain text. It is described in the example below −\n\nTo decrypt a letter, user takes the key letter on the left and finds cipher text letter in that row. The plain text letter is placed at the top of the column where the user can find the cipher text letter.\n\nPython includes a hacky implementation module for one-time-pad cipher implementation. The package name is called One-Time-Pad which includes a command line encryption tool that uses encryption mechanism similar to the one-time pad cipher algorithm.\n\nYou can use the following command to install this module −\n\nIf you wish to use it from the command-line, run the following command −\n\nThe following code helps to generate a one-time pad cipher −\n\nYou can observe the following output when you run the code given above −\n\nNote − The encrypted message is very easy to crack if the length of the key is less than the length of message (plain text).\n\nIn any case, the key is not necessarily random, which makes one-time pad cipher as a worth tool.\n\nIn this chapter, let us discuss in detail about symmetric and asymmetric cryptography.\n\nIn this type, the encryption and decryption process uses the same key. It is also called as secret key cryptography. The main features of symmetric cryptography are as follows −\n• It is simpler and faster.\n• The two parties exchange the key in a secure way.\n\nThe major drawback of symmetric cryptography is that if the key is leaked to the intruder, the message can be easily changed and this is considered as a risk factor.\n\nThe most popular symmetric key algorithm is Data Encryption Standard (DES) and Python includes a package which includes the logic behind DES algorithm.\n\nThe command for installation of DES package pyDES in Python is −\n\nSimple program implementation of DES algorithm is as follows −\n\nIt calls for the variable padmode which fetches all the packages as per DES algorithm implementation and follows encryption and decryption in a specified manner.\n\nYou can see the following output as a result of the code given above −\n\nIt is also called as public key cryptography. It works in the reverse way of symmetric cryptography. This implies that it requires two keys: one for encryption and other for decryption. The public key is used for encrypting and the private key is used for decrypting.\n• Due to its key length, it contributes lower encryption speed.\n\nThe following program code in Python illustrates the working of asymmetric cryptography using RSA algorithm and its implementation −\n\nYou can find the following output when you execute the code given above −\n\nRSA algorithm is a public key encryption technique and is considered as the most secure way of encryption. It was invented by Rivest, Shamir and Adleman in year 1978 and hence name RSA algorithm.\n\nThe RSA algorithm holds the following features −\n• None RSA algorithm is a popular exponentiation in a finite field over integers including prime numbers.\n• None The integers used by this method are sufficiently large making it difficult to solve.\n• None There are two sets of keys in this algorithm: private key and public key.\n\nYou will have to go through the following steps to work on RSA algorithm −\n\nThe initial procedure begins with selection of two prime numbers namely p and q, and then calculating their product N, as shown −\n\nHere, let N be the specified large number.\n\nConsider number e as a derived number which should be greater than 1 and less than (p-1) and (q-1). The primary condition will be that there should be no common factor of (p-1) and (q-1) except 1\n\nThe specified pair of numbers n and e forms the RSA public key and it is made public.\n\nPrivate Key d is calculated from the numbers p, q and e. The mathematical relationship between the numbers is as follows −\n\nThe above formula is the basic formula for Extended Euclidean Algorithm, which takes p and q as the input parameters.\n\nConsider a sender who sends the plain text message to someone whose public key is (n,e). To encrypt the plain text message in the given scenario, use the following syntax −\n\nThe decryption process is very straightforward and includes analytics for calculation in a systematic approach. Considering receiver C has the private key d, the result modulus will be calculated as −\n\nIn this chapter, we will focus on step wise implementation of RSA algorithm using Python.\n\nThe following steps are involved in generating RSA keys −\n• None Create two large prime numbers namely p and q. The product of these numbers will be called n, where n= p*q\n• None Generate a random number which is relatively prime with (p-1) and (q-1). Let the number be called as e.\n• None Calculate the modular inverse of e. The calculated inverse will be called as d.\n\nWe need two primary algorithms for generating RSA keys using Python − Cryptomath module and Rabin Miller module.\n\nThe source code of cryptomath module which follows all the basic implementation of RSA algorithm is as follows −\n\nThe source code of RabinMiller module which follows all the basic implementation of RSA algorithm is as follows −\n\nThe complete code for generating RSA keys is as follows −\n\nThe public key and private keys are generated and saved in the respective files as shown in the following output.\n\nIn this chapter, we will focus on different implementation of RSA cipher encryption and the functions involved for the same. You can refer or include this python file for implementing RSA cipher algorithm implementation.\n\nThe modules included for the encryption algorithm are as follows −\n\nWe have initialized the hash value as SHA-256 for better security purpose. We will use a function to generate new keys or a pair of public and private key using the following code.\n\nFor encryption, the following function is used which follows the RSA algorithm −\n\nTwo parameters are mandatory: message and pub_key which refers to Public key. A public key is used for encryption and private key is used for decryption.\n\nThe complete program for encryption procedure is mentioned below −\n\nThis chapter is a continuation of the previous chapter where we followed step wise implementation of encryption using RSA algorithm and discusses in detail about it.\n\nThe function used to decrypt cipher text is as follows −\n\nFor public key cryptography or asymmetric key cryptography, it is important to maintain two important features namely Authentication and Authorization.\n\nAuthorization is the process to confirm that the sender is the only one who have transmitted the message. The following code explains this −\n\nAuthentication is possible by verification method which is explained as below −\n\nThe digital signature is verified along with the details of sender and recipient. This adds more weight age for security purposes.\n\nYou can use the following code for RSA cipher decryption −\n\nHacking RSA cipher is possible with small prime numbers, but it is considered impossible if it is used with large numbers. The reasons which specify why it is difficult to hack RSA cipher are as follows −\n• None Brute force attack would not work as there are too many possible keys to work through. Also, this consumes a lot of time.\n• None Dictionary attack will not work in RSA algorithm as the keys are numeric and does not include any characters in it.\n• None Frequency analysis of the characters is very difficult to follow as a single encrypted block represents various characters.\n• None There are no specific mathematical tricks to hack RSA cipher.\n\nWith the help of small prime numbers, we can try hacking RSA cipher and the sample code for the same is mentioned below −\n\nThe above code produces the following output −"
    },
    {
        "link": "https://scaler.com/topics/caesar-cipher-python",
        "document": "We will cover the Python implementation of the Caesar Cipher, a cryptographic technique used to encrypt and decrypt messages. If you are not familiar with this technique, it involves shifting the letters of a message by a certain number of positions. This technique was used by Julius Caesar to send confidential messages, and it is still relevant in modern cryptography. Through this article, you will learn how to implement the Caesar Cipher in Python and use it to encrypt and decrypt messages.\n\nCaesar Cipher is one of the most well-known and straightforward encryption methods in cryptography. The shift Cipher, Caesar's Cipher, Caesar shift, and Caesar's code, are some of its alternate names. Plain text is encrypted using this encryption method so that only the intended recipient can decipher it. Julius Caesar, who employed it in his communications, gave the approach its name. With this encryption method, each letter in the text must be changed for a certain difference to encrypt our data. Let's imagine there is a letter \"B,\" which becomes \"C\" with the left shift of 1, and \"A\" with the right shift of 1. Therefore, there is a difference of 1 and a text will follow the same path. Left and right shifts cannot be used simultaneously in the same text. Let's have an example here, Think about receiving the message \"IFMMP FWFSZPOF\". What to interpret that as is crazy. So let's take the help of this diagram below to understand this text. Now using this diagram drawn above we can decrypt our message \"IFMMP FWFSZPOF\" as shown below. As you can see, our Cipher message starts with the letter I. (IFMMP FWFSZPOF). After going through the above-shifted alphabets we can encrypt that the letter H is converted to the Cipher character I. So after decrypting our message** \"IFMMP FWFSZPOF\"** the output is \"HELLO EVERYONE\".\n\nThe algorithm of Caesar Cipher holds the following features :\n• Caesar Cipher Technique is a simple and easy method of encryption technique.\n• Every letter in plain text is changed to a letter that appears a certain number of positions farther down the alphabet. To understand this algorithm in a better way let's say we want to encrypt the text \"HELLO EVERYONE\". Then, what we can do is change every letter in the text with a new letter that has a fixed difference. If we want to left-shift the text by 1, we must replace each letter in the previous sentence with the letter that comes after it. As of right now, the user cannot read this text without the decryption key. The decrypt key is nothing more than the understanding of how the letters were moved during encryption. We must right shift each letter by one to decipher this. That was Caesar Cipher's fundamental idea. The algorithm to obtain an encrypted letter will be as follows if we use a mathematical approach: where e represents the encrypted letter's place value, a is the actual letter's position value, and n tells us the number of shifts to be done for each letter. On the other side, we'll use the following formula to decrypt each letter:\n\nNow after having an understanding of Caesar Cipher through proper examples and diagrams, let's take a look at the implementation part of this. Each character in plain text \"HELLO EVERYONE\" is read one at a time. Transform each character in the provided plain text by the given shift pattern and appropriate rule depending on how the text is encrypted and decrypted. Following the procedure results in the creation of a new string known as Cipher text.\n\nThere are several ways to crack the Cipher text. One such option is brute force, which includes testing every decryption key that might exist. For a hacker, this method requires little work but it is easy. The following is how the Caesar Cipher algorithm hacking algorithm works: In the above example, the hacker has used all the possible keys to fetch the relevant message among all of them. So after going through all the possible messages, the hacker found out the message \"RAW THIS SIDE\" was more relevant in comparison to all others. So we can say that 3 is used as a key to encrypt the message.\n\nHow to Decrypt Caesar Cipher in Python? To decrypt the original text, we can build a function that will shift in the opposite direction. But we can make use of the module's cyclic cipher's property. Decryption can be performed using the same function. As an alternative, we will change the shift value to shifts = 26 - shift. Function to decrypt a cipher text is given below:"
    },
    {
        "link": "https://geeksforgeeks.org/caesar-cipher-in-cryptography",
        "document": "The Caesar Cipher is one of the simplest and oldest methods of encrypting messages, named after Julius Caesar, who reportedly used it to protect his military communications. This technique involves shifting the letters of the alphabet by a fixed number of places. For example, with a shift of three, the letter ‘A’ becomes ‘D’, ‘B’ becomes ‘E’, and so on. Despite its simplicity, the Caesar Cipher formed the groundwork for modern cryptographic techniques. In this article, we’ll explore how the Caesar Cipher works, its significance, and its impact on the development of cryptography with its advantages and disadvantages.\n\nThe Caesar cipher is a simple encryption technique that was used by Julius Caesar to send secret messages to his allies. It works by shifting the letters in the plaintext message by a certain number of positions, known as the “shift” or “key”. The Caesar Cipher technique is one of the earliest and simplest methods of encryption techniques.\n\nIt’s simply a type of substitution cipher, i.e., each letter of a given text is replaced by a letter with a fixed number of positions down the alphabet. For example with a shift of 1, A would be replaced by B, B would become C, and so on. The method is apparently named after Julius Caesar, who apparently used it to communicate with his officials.\n• None Thus to cipher a given text we need an integer value, known as a shift which indicates the number of positions each letter of the text has been moved down. \n\n The encryption can be represented using modular arithmetic by first transforming the letters into numbers, according to the scheme, A = 0, B = 1,…, Z = 25. Encryption of a letter by a shift n can be described mathematically as.\n• None For example, if the shift is 3, then the letter A would be replaced by the letter D, B would become E, C would become F, and so on. The alphabet is wrapped around so that after Z, it starts back at A.\n• None Here is an example of how to use the Caesar cipher to encrypt the message “HELLO” with a shift of 3:\n• None Write down the plaintext message: HELLO\n• None Choose a shift value. In this case, we will use a shift of 3.\n• None Replace each letter in the plaintext message with the letter that is three positions to the right in the alphabet.\n\nH becomes K (shift 3 from H) \n\n E becomes H (shift 3 from E) \n\n L becomes O (shift 3 from L) \n\n L becomes O (shift 3 from L) \n\n O becomes R (shift 3 from O)\n• None To decrypt the message, you simply need to shift each letter back by the same number of positions. In this case, you would shift each letter in “KHOOR” back by 3 positions to get the original message, “HELLO”.\n• None Easy to implement and use thus, making suitable for beginners to learn about encryption.\n• None Can be physically implemented, such as with a set of rotating disks or a set of cards, known as a scytale, which can be useful in certain situations.\n• None Can be modified easily to create a more secure variant, such as by using a multiple shift values or keywords.\n• None It is not secure against modern decryption methods.\n• None Vulnerable to known-plaintext attacks, where an attacker has access to both the encrypted and unencrypted versions of the same messages.\n• None The small number of possible keys means that an attacker can easily try all possible keys until the correct one is found, making it vulnerable to a brute force attack.\n• None It is not suitable for long text as it would be easy to crack.\n• None It is not suitable for secure communication as it is easily broken.\n• None Does not provide confidentiality, integrity, and authenticity in a message.\n• Substitution cipher: The Caesar cipher is a type of , where each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet.\n• Fixed key: The Caesar cipher uses a fixed key, which is the number of positions by which the letters are shifted. This key is known to both the sender and the receiver.\n• Symmetric encryption: technique, meaning that the same key is used for both encryption and decryption.\n• Limited keyspace: The Caesar cipher has a very limited keyspace of only 26 possible keys, as there are only 26 letters in the English alphabet.\n• Vulnerable to brute force attacks: The Caesar cipher is vulnerable to , as there are only 26 possible keys to try.\n• Easy to implement: The Caesar cipher is very easy to implement and requires only simple arithmetic operations, making it a popular choice for simple encryption tasks.\n• None Choose a number between 1 and 25. This will be your “shift” value.\n• None Write down the letters of the alphabet in order, from A to Z.\n• None Shift each letter of the alphabet by the “shift” value. For example, if the shift value is 3, A would become D, B would become E, C would become F, and so on.\n• None Encrypt your message by replacing each letter with the corresponding shifted letter. For example, if the shift value is 3, the word “hello” would become “khoor”.\n• None To decrypt the message, simply reverse the process by shifting each letter back by the same amount. For example, if the shift value is 3, the encrypted message “khoor” would become “hello”.\n• None Choose a shift value between 1 and 25.\n• None Write down the alphabet in order from A to Z.\n• None Create a new alphabet by shifting each letter of the original alphabet by the shift value. For example, if the shift value is 3, the new alphabet would be:\n• None Replace each letter of the message with the corresponding letter from the new alphabet. For example, if the shift value is 3, the word “hello” would become “khoor”.\n• None To decrypt the message, shift each letter back by the same amount. For example, if the shift value is 3, the encrypted message “khoor” would become “hello”.\n• None Traverse the given text one character at a time .\n• None For each character, transform the given character as per the rule, depending on whether we’re\n\nA program that receives a Text (string) and Shift value( integer) and returns the encrypted text.\n\nTime complexity: O(N) where N is length of the given text\n\nAuxiliary space: O(N)\n\nHow to decrypt? \n\nWe can either write another function decrypt similar to encrypt, that’ll apply the given shift in the opposite direction to decrypt the original text. However we can use the cyclic property of the cipher under modulo, hence we can simply observe\n\nHence, we can use the same function to decrypt, instead, we’ll modify the shift value such that shift = 26-shift (Refer to this for a sample run in C++).\n\nThe Caesar Cipher, with its straightforward approach of shifting letters, serves as an excellent introduction to the world of cryptography. While it is easy to understand and implement, its simplicity also makes it vulnerable to basic attacks. Despite these limitations, the Caesar Cipher’s historical role is significant, it represents the early efforts to secure communication and has made the way for the more advanced encryption methods used today. Understanding the Caesar Cipher helps us appreciate the evolution of cryptographic techniques and the ongoing quest to protect information in our digital age.\n\nWhat is the Caesar cipher in cryptography?\n\nWhat is an example of decryption in Caesar cipher?\n\nWhat are keys in Caesar cipher?"
    },
    {
        "link": "https://codementor.io/python/tutorial/python-encryption-message-in-python-via-reverse-cipher",
        "document": "Let’s examine the following examples of Plaintext and Reverse Cipher\n• Every skill acquired in cyber security is hard won. It includes a wide array of prerequisites (even) to get started.\n\nWith statement (A), anybody can read and understand it clearly. What about statement B—it’s absolute gibberish, or so it seems like it. However, a cryptanalyst may be able to decrypt the concept of statement (B).\n\nIn the examples above, statement (A) is plaintext, while statement (B) is a reverse cipher text. Thus, cryptography is defined as the art of manipulating or scrambling plaintext into ciphertext.\n\nCryptography originated approximately 4000 years ago in Egypt. The word cryptography comes from the word: KRYPTOS and GRAPHEIN. KRYPTOS means “hidden”, while GRAPHEIN means “writing”.\n\nThe Egyptians used to communicate through messages written in hieroglyph. The code was known only by the scribes (referred to as writers) and recipients. It is quite similar to modern cryptography where two keys—PUBLIC and PRIVATE—are used to encrypt and decrypt the message.\n\nA cryptanalyst is someone who hacks or breaks or decrypts a ciphered text. In this context, decrypt means to convert a ciphered text into/to a plaintext.\n\nThe Caesar shift cipher is one of the earliest methods in cryptography. In this method, the message is hidden from unauthorized readers by shifting the letters of a message by an agreed number. Upon receiving the message, the recipient would then shift the letters back by the same number agreed upon earlier. A cryptanalyst may be able to decrypt the message by observing the cipher method.\n\nIn reverse cipher method, letters are not shifted. Rather, the message is encrypted in a reverse order. To decrypt a message in reverse, we just reverse the reversed message to the original form. Julius Caesar invented the reverse cipher circa 2000 years ago.\n\nApart from the reverse and Caesar shift cipher, others such as substitution shift cipher were also used in the early days of cryptography. However, most of these methods can be decrypted easily.\n\nThe primary objective of cryptography is to provide the following basic security concepts in information security.\n\nAlthough cryptography helps us to detect whether a data has been altered, it cannot prevent data alteration. For instance, let’s assume sender A drafted and encrypted a message to sender B via the reverse cipher. Remember the reverse cipher is encrypted in a reverse form. Any addition of a letter in the message may compromise integrity. Let’s check out the example below:\n\nNow let’s add the letters (i, e, and s) at the beginning of the message in its reversed format. It looks like this:\n\nThe inclusion of those three letters altered the data and made its syntax quite weird. Integrity simply helps in detecting data alteration.\n\nAuthentication helps in identifying the sender of the message or where the message originated. In addition, it also provides assurance about the date and time of transmission of data.\n\nConfidentiality is the fundamental security concept provided by cryptography. For instance, in the Caesar shift method, the sender can use an agreed number to keep the meaning of a message from unauthorized users. The recipient can decrypt the message via the agreed number.\n\nExample of a message in Caesar Shift Cipher. Our agreed number is 3:\n\nNow let’s move to the main motive of this tutorial. In this tutorial, we are going encrypt a message in Python via reverse cipher. We can also encrypt in C++/C programming but Python makes it easier and is mostly preferred.\n\nApart from reverse cipher, it is quite possible to encrypt a message in Python via substitution and Caesar shift cipher.\n\nTypically, the cryptography library and others such as PyCrypto, M2Crypto, and PyOpenSSL in Python is the main reason why the majority prefers to use Python for encryption and other related cryptographic activities.\n\nHowever, for this tutorial, we won’t focus on crypto libraries or modules. Importing libraries and modules are not really necessary for us at this moment unless, maybe, we want to encrypt files on our pen drive or hard disk drive.\n\nBefore we start our encryption project, let’s refresh our minds with some basic programming concepts in Python such as the function, Data type, Comparison operators, and the interactive shell.\n\nThe python interpreter is usually located at on machines where it is available. We can then invoke the python interpreter at the shell prompt by typing the command:\n\nAfterward, Python comes back with the version of the installed Python date and time of installation, respectively. We can try our hands on the interpreter by writing a small program like the one below:\n\nInstead of appending the at the beginning of the statement, we can just type at the command prompt for the interpreter to return our code.\n\nPlease bear in mind this is possible in Python 2 and not previous versions.\n\nNow let’s fix our attention on basic programming concepts such as the lens() , data type, comparison operators and others which we will need for our encrypting project.\n\nFirst and foremost, let’s begin with variables. Variables are technically defined as reserve memory location to store values. Thus, when you create a variable, the space is reserved for the variable in the memory. The operand to the left of the operator is the name of the variable. The operand to the right of the operator is the value stored in the variable. The equal sign (=) is used to assign values to variables.\n\nFor example, in our reverse cipher example, we can store the content in the variable named “Message”.\n\nHere, we have assigned three different data types to three different variables. Data types allow the interpreter to allocate memory and decide what can be stored in memory.\n\nThe method len() returns the number of elements in a list or the number of elements in a list. Here is the syntax for the len() method:\n\nThe list is a parameter for the number of elements to be counted. Here is an example of len() method:\n\nComparison operators are used to compare values. It either returns True or False according to the condition. Greater sign ( > ), Less than sign ( < ), Equal to sign ( == ), Not equal to sign ( != ), Greater than sign ( >= ), Less than sign ( <= ) are examples of operators that compare values.\n\nHere is an example of comparison operator:\n\nFirst and foremost, let’s create a variable named to store the string to be reversed.\n\nNext, we create another variable named to store our reversed string or message. At the start of the program, the translated variable is just a blank string.\n\nNow, let’s store a value in the variable . The expression that is evaluated and stored in the variable is . Remember, the len() method we discussed initially? The len() function accepts a string value arguments and returns an integer value of how many characters are in the string.\n\nThe len(message) finds the number of characters in the message and deducts or subtracts one(1) and afterward, stores the result in the variable i.\n\nIt looks like this:\n\nNow we will create while statement to tell Python to check what the condition evaluates to. Here is our while statement:\n\nThe in our while statement is the same as the i variable. Remember the len() function counted the number of characters in the message variable and subtracted 1. The while statements simply mean that so far as the variable I is greater or equal to zero, the code continues to execute in the block.\n\nAt the start of the program, we created a variable named translated to store the reversed string. Now we will store a value in our translated variable. The value that is stored is the current value in the translated concatenated with the character at the index I in the message.\n\nNext, our variable i is assigned the current integer value and one ( 1) is subtracted or deducted from it.\n\nFinally, the print() function prints out the content of the translated variable. It looks like this:\n\nHere is the code for our program:\n\nIn this tutorial, we learned how to simply reverse a message or sentence in Python via the reverse cipher. However, it is not a good idea to encrypt sensitive content in reverse cipher. The reverse cipher is said to be the weakest cipher ever in history. However, we can still try our hands on reverse cipher in python for trivial documents.\n\nOther tutorials you might be interested in\n• Performing a Security Audit for your Code: The Basics\n\nMichael is a budding Cybersecurity Engineer and a technical writer based in Ghana, Africa. He works with AmericanEyes Security as a part-time WordPress security consultant. He is interested in Ruby on Rails and PHP security."
    },
    {
        "link": "https://stackoverflow.com/questions/34709914/security-of-a-caesar-cipher-cascade",
        "document": "You can encrypt the ciphertext again with the second key, but the property of a Caesar cipher is that each character is encrypted on its own. You have no relation with other characters of the message. That is why you can repeatedly encrypt some plaintext with multiple keys, but this won't give you additional security, because all those keys can be compressed to a single key which does the same as the cascade in a single invocation.\n\nLet's see an example. Let the message be \"hi\", the keys be 5, 2, 20 and the alphabet of size 26. This gives us the following intermediate and final ciphertexts:\n\nWhich is of course the same as an encryption with the key . Since our alphabet has the length 26, then the final key can be computed as .\n\nYou could implement a Vigenère cipher which is a much more secure classical cipher. It still has nowhere near the same security as modern block cipher like AES."
    }
]