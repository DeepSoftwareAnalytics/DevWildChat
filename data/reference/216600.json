[
    {
        "link": "https://stackoverflow.com/questions/75223528/zoom-page-with-mouse-wheel-click-and-drag-to-pan",
        "document": "How would I go about making a scroll-and-pan effect with the mouse wheel for the entire page? Basically like any 2D editor with the scroll to zoom, click and drag to pan but for the entire body.\n\nI haven't been able to find anything online about it."
    },
    {
        "link": "https://stackoverflow.com/questions/5189968/zoom-canvas-to-mouse-cursor",
        "document": "Using gives you more performance than multiple matrix calls , , .\n\nNo need for complex transformation inversions as and expensive DOM matrix calls tp converts point between zoomed and screen coordinate systems.\n\nFlexibility as you don't need to use and if you are rendering content at using different transforms. Returning to the transform with rather than the potentially frame rate wreaking call\n\nEasy to invert the transform and get the world coordinates of a (screen) pixel position and the other way round.\n\nUsing mouse and mouse wheel to zoom in and out at mouse position\n\nAn example using this method to scale page content at a point (mouse) via CSS transform CSS Demo at bottom of answer also has a copy of the demo from the next example.\n\nAnd an example of this method used to scale canvas content at a point using setTransform\n\nGiven a scale and pixel position you can get the new scale as follow...\n\nTo position the canvas and draw content\n\nTo use if you have the mouse coordinates\n\nTo get the coordinates of a point in the zoomed coordinate system and the screen position of a point in the zoomed coordinate system"
    },
    {
        "link": "https://github.com/roblouie/canvas-pan-and-zoom",
        "document": "This is a simple vanilla JavaScript example of panning a canvas by clicking and dragging, and zooming to a point by placing your cursor on that point and scrolling the mouse wheel."
    },
    {
        "link": "https://harrisonmilbradt.com/articles/canvas-panning-and-zooming",
        "document": "To kick off my blog, I want to share something I've learned from a recent side-project, Leinwald. German for \"Canvas\", Leinwald is a next generation infinite canvas app, utilizing the latest in web technologies. It's a work in progress, but I'm excited to share what I've learned so far.\n\nThe first thing I want to talk about is panning and zooming. This is a feature that's been around for a while, but it's still a bit tricky to implement. I'm going to show you how to do it from scratch, with no dependencies, just the way we like it.\n\nBefore we jump in, I want to give you an overview of how panning and zooming works at a high-level. This foundational knowledge will help you understand the code that follows.\n\nAt a high level, zooming and panning is just a matter of transformation. We can think of what we see on our computer screen as a viewport into a larger space. When we zoom in, we see less of the larger space, and when we zoom out, we see more of it. Likewise, when we pan, we're moving our viewport around the larger space.\n\nIn order to implement this, we will need to keep track of a couple pieces of information, which will make up our :\n• The scale of our viewport ( )\n• The position of our viewport ( and )\n\nBefore we can get hacking, let's first create a simple HTML page. Feel free to integrate this in any framework you'd like, but to keep this tutorial simple, we'll just be looking at a single HTML file. Converting this to a React component is left as an exercise for the reader.\n\nIf you're familiar with HTML Canvas, then you'll recognize the element. If you're not, don't worry, we'll be using it to draw some shapes onto the context. We'll also be using a object to keep track of our panning and zooming.\n\nNext up, we need a way to draw our shapes. For the purpose of this example, we'll stick to drawing rectangles. However, everything that we're writing here can be applied to any shape, or event images.\n\nNow that we have a way to draw rectangles, let's draw a simple scene to work with. We'll draw a red rectangle, and a blue rectangle. This will help us visualize how panning and zooming works.\n\nWhen we open our browser, we'll see the following image.\n\nWith that out of the way, let's get to the good stuff.\n\nPanning is the act of moving our viewport around the larger space. In order to do this, we need to move our viewport by a certain amount. We can do this by simply adding the amount we want to move to our and values of our viewport transformation.\n\nHowever, before we can do that, we'll also need a way to interact with our viewport. To do this, we'll add a few event listeners to our canvas element.\n\nCurrently, this code won't do anything useful, as we're not actually updating our transformations. However, if you open your console, you will see that as you click and drag around the canvas our mouse events get logged.\n\nTake a moment to explore the mouse event that's being logged. We're going to be using a few parameters from this event.\n\nLet's go back to our render function, and modify it to the following code.\n\nPull up your browser, and take a look. We have panning!\n\nNow that we have panning, let's add zooming. Zooming is a bit more complicated than panning, but it's still pretty straightforward. We'll be using the mouse wheel to zoom in and out.\n\nGo ahead and add the folling function underneath your function.\n\nWe also need an event listener for this. We'll add these closer to the bottom of the script.\n\nNow, if you open your browser, you should be able to zoom in and out of your scene using the mouse wheel!\n\nWe've now covered the basics of panning and zooming in a canvas element. We've also covered how to use the mouse wheel to zoom in and out. Stay tuned to read more about my adventures in canvas!\n\nIf you'd like to see the finished code, you can find it as an all-in-one Gist here."
    },
    {
        "link": "https://docs.yworks.com/yfiles-html/dguide/customizing_interaction/customizing_interaction_canvas_navigation.html",
        "document": "The scrollable area and the zoom level can be efficiently limited using a ViewportLimiter , as discussed in the section Restricting the Viewport .\n\nCanvas navigation can be divided into two main categories: zooming and scrollbar handling, which are managed by the CanvasComponent itself, and panning, which is managed by the MoveViewportInputMode.\n\nThe GraphComponent provides properties to specify mouse wheel behavior, scroll bar policy, and zoom limits.\n\nPanning, i.e., dragging the visible area with the pointer, is handled by MoveViewportInputMode. This input mode is a child input mode of both GraphEditorInputMode and GraphViewerInputMode.\n\nMoveViewportInputMode allows customization by changing the recognizers for some gestures. This is important to avoid conflicts with input modes which share the same gesture (dragging on an empty canvas), e.g., MarqueeSelectionInputMode or LassoSelectionInputMode.\n\nThe following event recognizers are used to handle moving the viewport via mouse or stylus input:\n\nMoveViewportInputMode also supports touch gestures for panning and pinch zooming. Panning and zooming work together. As a result, some event recognizers have different effects depending on whether the MoveViewportInputMode is currently in the panning or zooming state.\n\nThe following event recognizers are used to handle panning or zooming the viewport via touch gestures:\n\nIn short, the default behavior is that moving a single touching finger pans the viewport, while pinch zooming occurs when two fingers are touching."
    },
    {
        "link": "https://threejs.org/docs",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/index.html",
        "document": ""
    },
    {
        "link": "https://codehs.com/tutorial/mattarnold/create-3d-objects-with-threejs",
        "document": "Click on one of our programs below to get started coding in the sandbox!"
    },
    {
        "link": "https://threejs.org/docs/api/en/helpers/GridHelper.html",
        "document": "The GridHelper is an object to define grids. Grids are two-dimensional arrays of lines.\n\nsize -- The size of the grid. Default is `10`. \n\n divisions -- The number of divisions across the grid. Default is `10`. \n\n colorCenterLine -- The color of the centerline. This can be a [page:Color], a hexadecimal value and an CSS-Color name. Default is 0x444444 \n\n colorGrid -- The color of the lines of the grid. This can be a [page:Color], a hexadecimal value and an CSS-Color name. Default is 0x888888\n\nCreates a new [name] of size 'size' and divided into 'divisions' segments per side. Colors are optional.\n\nSee the base [page:LineSegments] class for common methods.\n\nFrees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
    },
    {
        "link": "https://stackoverflow.com/questions/11093084/fill-three-js-scene-with-a-grid",
        "document": "So there are two bugs in your code.\n\nFirst, you're starting with the line at and then putting each line a fixed distance below the last. The relatively minor bug is that in and you're putting the line's vertices at a height of , then in\n\nyou're adding a translation to the line of , which gives a final y position of , which is one too many. If it makes sense to your program to start with lines descending from and , then you should change the line to just\n\nYou can see that the lines are now centered on jsFiddle, but they're still sized incorrectly. This is because you aren't accounting for the fact that your scene is in perspective. Your lines all have their z coordinates set to 0, so when you set , they are 1000 units away from the camera. There is no reason to assume that something with the same width as the pixel width of the canvas will have the same width when drawn in perspective from 1000 units away.\n\nInstead, we can calculate how big they need to be. I won't go in to a full explanation of perspective here, but we can figure out how big an area the lines need to cover to cover the screen. You've specified a vertical FOV of 45 degrees in your camera constructor and a distance of 1000 between the camera and your lines. Three.js basically shows the solution if you peak into how it creates the perspective matrix: makePerspective\n\nFirst, we need the vertical distance of the upper half of the screen, since 0 is at the center of the screen. (tangent of half the angle, converted to radians) gives the vertical distance divided by the distance away from the camera, so you can calculate the height with\n\nor double it to\n\nThe horizontal FOV is not the same unless the canvas is square, but the width and height ratio of the line area will be proportional to the width and height ratio of the screen. Like three.js does, you can just multiply by the aspect ratio you also provided to the camera constructor to figure out the width:\n\nThese are the values that you should use for placing your lines. All together:\n\nFinally, you'll want to spread the lines over the full area, so you should set\n\nYou can see that working here: http://jsfiddle.net/pa46hxwo/\n\nThere is another way to do this, though, which is to keep the lines the same, but move the camera closer to your lines so that the width of the lines just happens to equal the pixel width of the canvas at that distance. The formula is just a reworking of the above for , but instead of solving for height, we solve for a distance when the height equals the screen height:\n\nYou can see that here: http://jsfiddle.net/0jtykgrL/\n\nIt's a much smaller change to your code, but it means that the camera position will change depending on how big the canvas is, which could affect other content which you need to place precisely, so the choice is yours."
    }
]