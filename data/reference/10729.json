[
    {
        "link": "https://scipy-lectures.org/advanced/image_processing",
        "document": "2.6. Image manipulation and processing using Numpy and Scipy¶\n\nThis section addresses basic image manipulation and processing using the core scientific modules NumPy and SciPy. Some of the operations covered by this tutorial may be useful for other kinds of multidimensional array processing than image processing. In particular, the submodule provides functions operating on n-dimensional NumPy arrays.\n\nTools used in this tutorial:\n• None : submodule dedicated to image processing (n-dimensional images). See the documentation:\n• Image segmentation: labeling pixels corresponding to different objects\n\n# First we need to create the PNG file Need to know the shape and dtype of the image (how to separate data bytes). For large data, use for memory mapping:\n\nLocal filters: replace the value of pixels by a function of the values of neighboring pixels. increase the weight of edges by adding an approximation of the Laplacian: A Gaussian filter smoothes the noise out… and the edges as well:\n• Create a binary image (of 0s and 1s) with several objects (circles, ellipses, squares, or random shapes).\n• Try two different denoising methods for denoising the image: gaussian filtering and median filtering.\n• Compare the histograms of the two different denoised images. Which one is the closest to the histogram of the original (noise-free) image? More denoising filters are available in , see the Scikit-image: image processing tutorial. See wikipedia for a definition of mathematical morphology. Probe an image with a simple shape (a structuring element), and modify this image according to how the shape locally fits or misses the image. Erosion = minimum filter. Replace the value of a pixel by the minimal value covered by the structuring element.: Many other mathematical morphology operations: hit and miss transform, tophat, etc.\n\nUse mathematical morphology to clean up the result: Check that reconstruction operations (erosion + propagation) produce a better result than opening/closing: Check how a first denoising step (e.g. with a median filter) modifies the histogram, and check that the resulting histogram-based segmentation is more accurate. More advanced segmentation algorithms are found in the : see Scikit-image: image processing. Other Scientific Packages provide algorithms that can be useful for image processing. In this example, we use the spectral clustering function of the in order to segment glued objects. # Convert the image into a graph with the value of the gradient on # Take a decreasing function of the gradient: we take it weakly # dependant from the gradient the segmentation is close to a voronoi\n\nCompute size, mean_value, etc. of each region: Can be used outside the limited scope of segmentation applications. # note that we use broadcasting When regions are regular blocks, it is more efficient to use stride tricks (Example: fake dimensions with strides). One example with mathematical morphology: granulometry"
    },
    {
        "link": "https://numpy.org/devdocs/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    },
    {
        "link": "https://docs.scipy.org/doc/scipy/tutorial/ndimage.html",
        "document": "The functions described in this section all perform some type of spatial filtering of the input array: the elements in the output are some function of the values in the neighborhood of the corresponding input element. We refer to this neighborhood of elements as the filter kernel, which is often rectangular in shape but may also have an arbitrary footprint. Many of the functions described below allow you to define the footprint of the kernel by passing a mask through the footprint parameter. For example, a cross-shaped kernel can be defined as follows: Usually, the origin of the kernel is at the center calculated by dividing the dimensions of the kernel shape by two. For instance, the origin of a 1-D kernel of length three is at the second element. Take, for example, the correlation of a 1-D array with a filter of length 3 consisting of ones: Sometimes, it is convenient to choose a different origin for the kernel. For this reason, most functions support the origin parameter, which gives the origin of the filter relative to its center. For example: The effect is a shift of the result towards the left. This feature will not be needed very often, but it may be useful, especially for filters that have an even size. A good example is the calculation of backward and forward differences: We could also have calculated the forward difference as follows: However, using the origin parameter instead of a larger kernel is more efficient. For multidimensional kernels, origin can be a number, in which case the origin is assumed to be equal along all axes, or a sequence giving the origin along each axis. Since the output elements are a function of elements in the neighborhood of the input elements, the borders of the array need to be dealt with appropriately by providing the values outside the borders. This is done by assuming that the arrays are extended beyond their boundaries according to certain boundary conditions. In the functions described below, the boundary conditions can be selected using the mode parameter, which must be a string with the name of the boundary condition. The following boundary conditions are currently supported: use the value at the boundary reflect the array at the boundary mirror the array at the boundary use a constant value, default is 0.0 The following synonyms are also supported for consistency with the interpolation routines: * “grid-constant” and “constant” are equivalent for filtering operations, but have different behavior in interpolation functions. For API consistency, the filtering functions accept either name. The “constant” mode is special since it needs an additional parameter to specify the constant value that should be used. Note that modes mirror and reflect differ only in whether the sample at the boundary is repeated upon reflection. For mode mirror, the point of symmetry is exactly at the final sample, so that value is not repeated. This mode is also known as whole-sample symmetric since the point of symmetry falls on the final sample. Similarly, reflect is often referred to as half-sample symmetric as the point of symmetry is half a sample beyond the array boundary. The easiest way to implement such boundary conditions would be to copy the data to a larger array and extend the data at the borders according to the boundary conditions. For large arrays and large filter kernels, this would be very memory consuming, and the functions described below, therefore, use a different approach that does not require allocating large temporary buffers.\n• None The function calculates a 1-D correlation along the given axis. The lines of the array along the given axis are correlated with the given weights. The weights parameter must be a 1-D sequence of numbers.\n• None The function implements multidimensional correlation of the input array with a given kernel.\n• None The function calculates a 1-D convolution along the given axis. The lines of the array along the given axis are convoluted with the given weights. The weights parameter must be a 1-D sequence of numbers.\n• None The function implements multidimensional convolution of the input array with a given kernel. A convolution is essentially a correlation after mirroring the kernel. As a result, the origin parameter behaves differently than in the case of a correlation: the results is shifted in the opposite direction.\n• None The function implements a 1-D Gaussian filter. The standard deviation of the Gaussian filter is passed through the parameter sigma. Setting order = 0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds to convolution with the first, second, or third derivatives of a Gaussian. Higher-order derivatives are not implemented.\n• None The function implements a multidimensional Gaussian filter. The standard deviations of the Gaussian filter along each axis are passed through the parameter sigma as a sequence or numbers. If sigma is not a sequence but a single number, the standard deviation of the filter is equal along all directions. The order of the filter can be specified separately for each axis. An order of 0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds to convolution with the first, second, or third derivatives of a Gaussian. Higher-order derivatives are not implemented. The order parameter must be a number, to specify the same order for all axes, or a sequence of numbers to specify a different order for each axis. The example below shows the filter applied on test data with different values of sigma. The order parameter is kept at 0. The multidimensional filter is implemented as a sequence of 1-D Gaussian filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a lower precision, the results may be imprecise because intermediate results may be stored with insufficient precision. This can be prevented by specifying a more precise output type.\n• None The function calculates a 1-D uniform filter of the given size along the given axis.\n• None The implements a multidimensional uniform filter. The sizes of the uniform filter are given for each axis as a sequence of integers by the size parameter. If size is not a sequence, but a single number, the sizes along all axes are assumed to be equal. The multidimensional filter is implemented as a sequence of 1-D uniform filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a lower precision, the results may be imprecise because intermediate results may be stored with insufficient precision. This can be prevented by specifying a more precise output type.\n• None The function calculates a 1-D minimum filter of the given size along the given axis.\n• None The function calculates a 1-D maximum filter of the given size along the given axis.\n• None The function calculates a multidimensional minimum filter. Either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint, if provided, must be an array that defines the shape of the kernel by its non-zero elements.\n• None The function calculates a multidimensional maximum filter. Either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint, if provided, must be an array that defines the shape of the kernel by its non-zero elements.\n• None The function calculates a multidimensional rank filter. The rank may be less than zero, i.e., rank = -1 indicates the largest element. Either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint, if provided, must be an array that defines the shape of the kernel by its non-zero elements.\n• None The function calculates a multidimensional percentile filter. The percentile may be less than zero, i.e., percentile = -20 equals percentile = 80. Either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint, if provided, must be an array that defines the shape of the kernel by its non-zero elements.\n• None The function calculates a multidimensional median filter. Either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint if provided, must be an array that defines the shape of the kernel by its non-zero elements. Derivative filters can be constructed in several ways. The function , described in Smoothing filters, can be used to calculate derivatives along a given axis using the order parameter. Other derivative filters are the Prewitt and Sobel filters:\n• None The function calculates a derivative along the given axis.\n• None The function calculates a derivative along the given axis. The Laplace filter is calculated by the sum of the second derivatives along all axes. Thus, different Laplace filters can be constructed using different second-derivative functions. Therefore, we provide a general function that takes a function argument to calculate the second derivative along a given direction.\n• None The function calculates a Laplace filter using the function passed through to calculate second derivatives. The function should have the following signature It should calculate the second derivative along the dimension axis. If output is not , it should use that for the output and return , otherwise it should return the result. mode, cval have the usual meaning. The extra_arguments and extra_keywords arguments can be used to pass a tuple of extra arguments and a dictionary of named arguments that are passed to at each call. To demonstrate the use of the extra_arguments argument, we could do The following two functions are implemented using by providing appropriate functions for the second-derivative function:\n• None The function calculates the Laplace using discrete differentiation for the second derivative (i.e., convolution with ).\n• None The function calculates the Laplace filter using to calculate the second derivatives. The standard deviations of the Gaussian filter along each axis are passed through the parameter sigma as a sequence or numbers. If sigma is not a sequence but a single number, the standard deviation of the filter is equal along all directions. The gradient magnitude is defined as the square root of the sum of the squares of the gradients in all directions. Similar to the generic Laplace function, there is a function that calculates the gradient magnitude of an array.\n• None The function calculates a gradient magnitude using the function passed through to calculate first derivatives. The function should have the following signature It should calculate the derivative along the dimension axis. If output is not , it should use that for the output and return , otherwise it should return the result. mode, cval have the usual meaning. The extra_arguments and extra_keywords arguments can be used to pass a tuple of extra arguments and a dictionary of named arguments that are passed to derivative at each call. For example, the function fits the required signature See the documentation of for examples of using the extra_arguments and extra_keywords arguments. The and functions fit the required signature and can, therefore, be used directly with .\n• None The function calculates the gradient magnitude using to calculate the first derivatives. The standard deviations of the Gaussian filter along each axis are passed through the parameter sigma as a sequence or numbers. If sigma is not a sequence but a single number, the standard deviation of the filter is equal along all directions. To implement filter functions, generic functions can be used that accept a callable object that implements the filtering operation. The iteration over the input and output arrays is handled by these generic functions, along with such details as the implementation of the boundary conditions. Only a callable object implementing a callback function that does the actual filtering work must be provided. The callback function can also be written in C and passed using a (see Extending scipy.ndimage in C for more information).\n• None The function implements a generic 1-D filter function, where the actual filtering operation must be supplied as a python function (or other callable object). The function iterates over the lines of an array and calls at each line. The arguments that are passed to are 1-D arrays of the type. The first contains the values of the current line. It is extended at the beginning and the end, according to the filter_size and origin arguments. The second array should be modified in-place to provide the output values of the line. For example, consider a correlation along one dimension: The same operation can be implemented using , as follows: Here, the origin of the kernel was (by default) assumed to be in the middle of the filter of length 3. Therefore, each input line had been extended by one value at the beginning and at the end, before the function was called. Optionally, extra arguments can be defined and passed to the filter function. The extra_arguments and extra_keywords arguments can be used to pass a tuple of extra arguments and/or a dictionary of named arguments that are passed to derivative at each call. For example, we can pass the parameters of our filter as an argument\n• None The function implements a generic filter function, where the actual filtering operation must be supplied as a python function (or other callable object). The function iterates over the array and calls at each element. The argument of is a 1-D array of the type that contains the values around the current element that are within the footprint of the filter. The function should return a single value that can be converted to a double precision number. For example, consider a correlation: The same operation can be implemented using generic_filter, as follows: Here, a kernel footprint was specified that contains only two elements. Therefore, the filter function receives a buffer of length equal to two, which was multiplied with the proper weights and the result summed. When calling , either the sizes of a rectangular kernel or the footprint of the kernel must be provided. The size parameter, if provided, must be a sequence of sizes or a single number, in which case the size of the filter is assumed to be equal along each axis. The footprint, if provided, must be an array that defines the shape of the kernel by its non-zero elements. Optionally, extra arguments can be defined and passed to the filter function. The extra_arguments and extra_keywords arguments can be used to pass a tuple of extra arguments and/or a dictionary of named arguments that are passed to derivative at each call. For example, we can pass the parameters of our filter as an argument These functions iterate over the lines or elements starting at the last axis, i.e., the last index changes the fastest. This order of iteration is guaranteed for the case that it is important to adapt the filter depending on spatial location. Here is an example of using a class that implements the filter and keeps track of the current coordinates while iterating. It performs the same filter operation as described above for , but additionally prints the current coordinates: For the function, the same approach works, except that this function does not iterate over the axis that is being filtered. The example for then becomes this: The functions described in this section perform filtering operations in the Fourier domain. Thus, the input array of such a function should be compatible with an inverse Fourier transform function, such as the functions from the module. We, therefore, have to deal with arrays that may be the result of a real or a complex Fourier transform. In the case of a real Fourier transform, only half of the of the symmetric complex transform is stored. Additionally, it needs to be known what the length of the axis was that was transformed by the real fft. The functions described here provide a parameter n that, in the case of a real transform, must be equal to the length of the real transform axis before transformation. If this parameter is less than zero, it is assumed that the input array was the result of a complex Fourier transform. The parameter axis can be used to indicate along which axis the real transform was executed.\n• None The function multiplies the input array with the multidimensional Fourier transform of a shift operation for the given shift. The shift parameter is a sequence of shifts for each dimension or a single value for all dimensions.\n• None The function multiplies the input array with the multidimensional Fourier transform of a Gaussian filter with given standard deviations sigma. The sigma parameter is a sequence of values for each dimension or a single value for all dimensions.\n• None The function multiplies the input array with the multidimensional Fourier transform of a uniform filter with given sizes size. The size parameter is a sequence of values for each dimension or a single value for all dimensions.\n• None The function multiplies the input array with the multidimensional Fourier transform of an elliptically-shaped filter with given sizes size. The size parameter is a sequence of values for each dimension or a single value for all dimensions. This function is only implemented for dimensions 1, 2, and 3.\n\nThis section describes various interpolation functions that are based on B-spline theory. A good introduction to B-splines can be found in with detailed algorithms for image interpolation given in . Interpolation using splines of an order larger than 1 requires a pre-filtering step. The interpolation functions described in section Interpolation functions apply pre-filtering by calling , but they can be instructed not to do this by setting the prefilter keyword equal to False. This is useful if more than one interpolation operation is done on the same array. In this case, it is more efficient to do the pre-filtering only once and use a pre-filtered array as the input of the interpolation functions. The following two functions implement the pre-filtering:\n• None The function calculates a 1-D spline filter along the given axis. An output array can optionally be provided. The order of the spline must be larger than 1 and less than 6.\n• The multidimensional filter is implemented as a sequence of 1-D spline filters. The intermediate arrays are stored in the same data type as the output. Therefore, if an output with a limited precision is requested, the results may be imprecise because intermediate results may be stored with insufficient precision. This can be prevented by specifying a output type of high precision. The interpolation functions all employ spline interpolation to effect some type of geometric transformation of the input array. This requires a mapping of the output coordinates to the input coordinates, and therefore, the possibility arises that input values outside the boundaries may be needed. This problem is solved in the same way as described in Filter functions for the multidimensional filter functions. Therefore, these functions all support a mode parameter that determines how the boundaries are handled, and a cval parameter that gives a constant value in case that the ‘constant’ mode is used. The behavior of all modes, including at non-integer locations is illustrated below. Note the boundaries are not handled the same for all modes; reflect (aka ) and involve symmetry or repetition about a point that is half way between image samples (dashed vertical lines) while modes mirror and wrap treat the image as if it’s extent ends exactly at the first and last sample point rather than 0.5 samples past it. The coordinates of image samples fall on integer sampling locations in the range from 0 to along each axis, . The figure below illustrates the interpolation of a point at location within an image of shape . For an interpolation of order , samples are involved along each axis. The filled circles illustrate the sampling locations involved in the interpolation of the value at the location of the red x.\n• None The function applies an arbitrary geometric transform to the input. The given mapping function is called at each point in the output to find the corresponding coordinates in the input. mapping must be a callable object that accepts a tuple of length equal to the output array rank and returns the corresponding input coordinates as a tuple of length equal to the input array rank. The output shape and output type can optionally be provided. If not given, they are equal to the input shape and type. Optionally, extra arguments can be defined and passed to the filter function. The extra_arguments and extra_keywords arguments can be used to pass a tuple of extra arguments and/or a dictionary of named arguments that are passed to derivative at each call. For example, we can pass the shifts in our example as arguments The mapping function can also be written in C and passed using a . See Extending scipy.ndimage in C for more information.\n• None The function applies an arbitrary coordinate transformation using the given array of coordinates. The shape of the output is derived from that of the coordinate array by dropping the first axis. The parameter coordinates is used to find for each point in the output the corresponding coordinates in the input. The values of coordinates along the first axis are the coordinates in the input array at which the output value is found. (See also the numarray coordinates function.) Since the coordinates may be non- integer coordinates, the value of the input at these coordinates is determined by spline interpolation of the requested order. Here is an example that interpolates a 2D array at and :\n• None The function applies an affine transformation to the input array. The given transformation matrix and offset are used to find for each point in the output the corresponding coordinates in the input. The value of the input at the calculated coordinates is determined by spline interpolation of the requested order. The transformation matrix must be 2-D or can also be given as a 1-D sequence or array. In the latter case, it is assumed that the matrix is diagonal. A more efficient interpolation algorithm is then applied that exploits the separability of the problem. The output shape and output type can optionally be provided. If not given, they are equal to the input shape and type.\n• None The function returns a shifted version of the input, using spline interpolation of the requested order.\n• None The function returns a rescaled version of the input, using spline interpolation of the requested order.\n• None The function returns the input array rotated in the plane defined by the two axes given by the parameter axes, using spline interpolation of the requested order. The angle must be given in degrees. If reshape is true, then the size of the output array is adapted to contain the rotated input.\n• None The functions generates a binary structuring element for use in binary morphology operations. The rank of the structure must be provided. The size of the structure that is returned is equal to three in each direction. The value of each element is equal to one if the square of the Euclidean distance from the element to the center is less than or equal to connectivity. For instance, 2-D 4-connected and 8-connected structures are generated as follows: This is a visual presentation of in 3D: Most binary morphology functions can be expressed in terms of the basic operations erosion and dilation, which can be seen here:\n• None The function implements binary erosion of arrays of arbitrary rank with the given structuring element. The origin parameter controls the placement of the structuring element, as described in Filter functions. If no structuring element is provided, an element with connectivity equal to one is generated using . The border_value parameter gives the value of the array outside boundaries. The erosion is repeated iterations times. If iterations is less than one, the erosion is repeated until the result does not change anymore. If a mask array is given, only those elements with a true value at the corresponding mask element are modified at each iteration.\n• None The function implements binary dilation of arrays of arbitrary rank with the given structuring element. The origin parameter controls the placement of the structuring element, as described in Filter functions. If no structuring element is provided, an element with connectivity equal to one is generated using . The border_value parameter gives the value of the array outside boundaries. The dilation is repeated iterations times. If iterations is less than one, the dilation is repeated until the result does not change anymore. If a mask array is given, only those elements with a true value at the corresponding mask element are modified at each iteration. Here is an example of using to find all elements that touch the border, by repeatedly dilating an empty array from the border using the data array as the mask: The and functions both have an iterations parameter, which allows the erosion or dilation to be repeated a number of times. Repeating an erosion or a dilation with a given structure n times is equivalent to an erosion or a dilation with a structure that is n-1 times dilated with itself. A function is provided that allows the calculation of a structure that is dilated a number of times with itself:\n• None The function returns a structure by dilation of the input structure iteration - 1 times with itself. If the origin of the original structure is equal to 0, then it is also equal to 0 for the iterated structure. If not, the origin must also be adapted if the equivalent of the *iterations* erosions or dilations must be achieved with the iterated structure. The adapted origin is simply obtained by multiplying with the number of iterations. For convenience, the :func:`iterate_structure` also returns the adapted origin if the *origin* parameter is not ``None``: Other morphology operations can be defined in terms of erosion and dilation. The following functions provide a few of these operations for convenience:\n• None The function implements binary opening of arrays of arbitrary rank with the given structuring element. Binary opening is equivalent to a binary erosion followed by a binary dilation with the same structuring element. The origin parameter controls the placement of the structuring element, as described in Filter functions. If no structuring element is provided, an element with connectivity equal to one is generated using . The iterations parameter gives the number of erosions that is performed followed by the same number of dilations.\n• None The function implements binary closing of arrays of arbitrary rank with the given structuring element. Binary closing is equivalent to a binary dilation followed by a binary erosion with the same structuring element. The origin parameter controls the placement of the structuring element, as described in Filter functions. If no structuring element is provided, an element with connectivity equal to one is generated using . The iterations parameter gives the number of dilations that is performed followed by the same number of erosions.\n• None The function is used to close holes in objects in a binary image, where the structure defines the connectivity of the holes. The origin parameter controls the placement of the structuring element, as described in Filter functions. If no structuring element is provided, an element with connectivity equal to one is generated using .\n• None The function implements a binary hit-or-miss transform of arrays of arbitrary rank with the given structuring elements. The hit-or-miss transform is calculated by erosion of the input with the first structure, erosion of the logical not of the input with the second structure, followed by the logical and of these two erosions. The origin parameters control the placement of the structuring elements, as described in Filter functions. If origin2 equals , it is set equal to the origin1 parameter. If the first structuring element is not provided, a structuring element with connectivity equal to one is generated using . If structure2 is not provided, it is set equal to the logical not of structure1. Grey-scale morphology operations are the equivalents of binary morphology operations that operate on arrays with arbitrary values. Below, we describe the grey-scale equivalents of erosion, dilation, opening and closing. These operations are implemented in a similar fashion as the filters described in Filter functions, and we refer to this section for the description of filter kernels and footprints, and the handling of array borders. The grey-scale morphology operations optionally take a structure parameter that gives the values of the structuring element. If this parameter is not given, the structuring element is assumed to be flat with a value equal to zero. The shape of the structure can optionally be defined by the footprint parameter. If this parameter is not given, the structure is assumed to be rectangular, with sizes equal to the dimensions of the structure array, or by the size parameter if structure is not given. The size parameter is only used if both structure and footprint are not given, in which case the structuring element is assumed to be rectangular and flat with the dimensions given by size. The size parameter, if provided, must be a sequence of sizes or a single number in which case the size of the filter is assumed to be equal along each axis. The footprint parameter, if provided, must be an array that defines the shape of the kernel by its non-zero elements. Similarly to binary erosion and dilation, there are operations for grey-scale erosion and dilation: Grey-scale opening and closing operations can be defined similarly to their binary counterparts:\n• None The function implements grey-scale opening of arrays of arbitrary rank. Grey-scale opening is equivalent to a grey-scale erosion followed by a grey-scale dilation.\n• None The function implements grey-scale closing of arrays of arbitrary rank. Grey-scale opening is equivalent to a grey-scale dilation followed by a grey-scale erosion.\n• None The function implements a grey-scale morphological gradient of arrays of arbitrary rank. The grey-scale morphological gradient is equal to the difference of a grey-scale dilation and a grey-scale erosion.\n• None The function implements a grey-scale morphological laplace of arrays of arbitrary rank. The grey-scale morphological laplace is equal to the sum of a grey-scale dilation and a grey-scale erosion minus twice the input.\n• None The function implements a white top-hat filter of arrays of arbitrary rank. The white top-hat is equal to the difference of the input and a grey-scale opening.\n• None The function implements a black top-hat filter of arrays of arbitrary rank. The black top-hat is equal to the difference of a grey-scale closing and the input.\n\nSegmentation is the process of separating objects of interest from the background. The most simple approach is, probably, intensity thresholding, which is easily done with functions: The result is a binary image, in which the individual objects still need to be identified and labeled. The function generates an array where each object is assigned a unique number:\n• None The function generates an array where the objects in the input are labeled with an integer index. It returns a tuple consisting of the array of object labels and the number of objects found, unless the output parameter is given, in which case only the number of objects is returned. The connectivity of the objects is defined by a structuring element. For instance, in 2D using a 4-connected structuring element gives: These two objects are not connected because there is no way in which we can place the structuring element, such that it overlaps with both objects. However, an 8-connected structuring element results in only a single object: If no structuring element is provided, one is generated by calling (see Binary morphology) using a connectivity of one (which in 2D is the 4-connected structure of the first example). The input can be of any type, any value not equal to zero is taken to be part of an object. This is useful if you need to ‘re-label’ an array of object indices, for instance, after removing unwanted objects. Just apply the label function again to the index array. For instance: The structuring element used by is assumed to be symmetric. There is a large number of other approaches for segmentation, for instance, from an estimation of the borders of the objects that can be obtained by derivative filters. One such approach is watershed segmentation. The function generates an array where each object is assigned a unique label, from an array that localizes the object borders, generated, for instance, by a gradient magnitude filter. It uses an array containing initial markers for the objects:\n• None The function applies a watershed from markers algorithm, using Image Foresting Transform, as described in .\n• None The inputs of this function are the array to which the transform is applied, and an array of markers that designate the objects by a unique label, where any non-zero value is a marker. For instance: Here, two markers were used to designate an object (marker = 2) and the background (marker = 1). The order in which these are processed is arbitrary: moving the marker for the background to the lower-right corner of the array yields a different result: The result is that the object (marker = 2) is smaller because the second marker was processed earlier. This may not be the desired effect if the first marker was supposed to designate a background object. Therefore, treats markers with a negative value explicitly as background markers and processes them after the normal markers. For instance, replacing the first marker by a negative marker gives a result similar to the first example: The connectivity of the objects is defined by a structuring element. If no structuring element is provided, one is generated by calling (see Binary morphology) using a connectivity of one (which in 2D is a 4-connected structure.) For example, using an 8-connected structure with the last example yields a different object: The implementation of limits the data types of the input to and .\n\nGiven an array of labeled objects, the properties of the individual objects can be measured. The function can be used to generate a list of slices that for each object, give the smallest sub-array that fully contains the object:\n• None The function finds all objects in a labeled array and returns a list of slices that correspond to the smallest regions in the array that contains the object. The function returns slices for all objects, unless the max_label parameter is larger then zero, in which case only the first max_label objects are returned. If an index is missing in the label array, is return instead of a slice. For example: [(slice(0, 1, None),), None, (slice(2, 3, None),)] The list of slices generated by is useful to find the position and dimensions of the objects in the array, but can also be used to perform measurements on the individual objects. Say, we want to find the sum of the intensities of an object in image: Then we can calculate the sum of the elements in the second object: That is, however, not particularly efficient and may also be more complicated for other types of measurements. Therefore, a few measurements functions are defined that accept the array of object labels and the index of the object to be measured. For instance, calculating the sum of the intensities can be done by: For large arrays and small objects, it is more efficient to call the measurement functions after slicing the array: Alternatively, we can do the measurements for a number of labels with a single function call, returning a list of results. For instance, to measure the sum of the values of the background and the second object in our example, we give a list of labels: The measurement functions described below all support the index parameter to indicate which object(s) should be measured. The default value of index is . This indicates that all elements where the label is larger than zero should be treated as a single object and measured. Thus, in this case the labels array is treated as a mask defined by the elements that are larger than zero. If index is a number or a sequence of numbers it gives the labels of the objects that are measured. If index is a sequence, a list of the results is returned. Functions that return more than one result return their result as a tuple if index is a single number, or as a tuple of lists if index is a sequence.\n• None The function calculates the sum of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the mean of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the variance of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the standard deviation of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the minimum of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the maximum of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the position of the minimum of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the position of the maximum of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates the minimum, the maximum, and their positions, of the elements of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation. The result is a tuple giving the minimum, the maximum, the position of the minimum, and the position of the maximum. The result is the same as a tuple formed by the results of the functions minimum, maximum, minimum_position, and maximum_position that are described above.\n• None The function calculates the center of mass of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation.\n• None The function calculates a histogram of the object with label(s) given by index, using the labels array for the object labels. If index is , all elements with a non-zero label value are treated as a single object. If label is , all elements of input are used in the calculation. Histograms are defined by their minimum (min), maximum (max), and the number of bins (bins). They are returned as 1-D arrays of type .\n\nA few functions in take a callback argument. This can be either a python function or a containing a pointer to a C function. Using a C function will generally be more efficient, since it avoids the overhead of calling a python function on many elements of an array. To use a C function, you must write a C extension that contains the callback function and a Python function that returns a containing a pointer to the callback. An example of a function that supports callbacks is , which accepts a callback function that defines a mapping from all output coordinates to corresponding coordinates in the input array. Consider the following python example, which uses to implement a shift function. We can also implement the callback function with the following C code: More information on writing Python extension modules can be found here. If the C code is in the file , then it can be compiled after adding it to (see examples inside files) and follow what’s there. After that is done, running the script: produces the same result as the original python script. In the C version, is the callback function and the parameters and play the same role as they do in the python version, while and provide the equivalents of and . The variable is passed through instead of . Finally, the C callback function returns an integer status, which is one upon success and zero otherwise. The function wraps the callback function in a . The main steps are:\n• None Initialize a . The first argument is a pointer to the callback function.\n• None The second argument is the function signature, which must match exactly the one expected by .\n• None Above, we used to specify that we generated with . A different approach would be to supply the data in the capsule context, that can be set by PyCapsule_SetContext and omit specifying in . However, in this approach we would need to deal with allocation/freeing of the data — freeing the data after the capsule has been destroyed can be done by specifying a non-NULL callback function in the third argument of PyCapsule_New. C callback functions for all follow this scheme. The next section lists the functions that accept a C callback function and gives the prototype of the function. The functions that support low-level callback arguments are: Below, we show alternative ways to write the code, using Numba, Cython, ctypes, or cffi instead of writing wrapper code in C. Numba provides a way to write low-level functions easily in Python. We can write the above using Numba as: Functionally the same code as above can be written in Cython with somewhat less boilerplate as follows: With cffi, you can interface with a C function residing in a shared library (DLL). First, we need to write the shared library, which we do in C — this example is for Linux/OSX: Needs to be compiled with \"gcc -std=c99 -shared -fPIC -o example.so example.c\" The Python code calling the library is: # Construct the FFI object, and copypaste the function declaration You can find more information in the cffi documentation. With ctypes, the C code and the compilation of the so/DLL is as for cffi above. The Python code is different: # Ctypes has no built-in intptr type, so override the signature # instead of trying to get it via ctypes You can find more information in the ctypes documentation."
    },
    {
        "link": "https://medium.com/@debopamdeycse19/numpy-multi-dimensional-arrays-and-their-operations-b14bea16aaf6",
        "document": "Hello friends, In previous articles we talked about numpy basics, and how to install Numpy on your computer then we discussed how to create numpy arrays, slicing, indexing, and much more. In today’s article, we will discuss multi-dimensional arrays in Numpy and their essential operations.\n\nMulti-dimensional arrays also known as matrices, are crucial for processing images, analyzing sensor data, and performing simulations in data science, scientific computing, and numerical analysis.\n\nHow to create a multidimensional array in Python using numpy\n\nNumPy provides various methods to create multi-dimensional arrays effortlessly. Let’s see how to create multi-dimensional arrays (2-D and 3-D).\n\nThe output will be:\n\nThere are so many methods to create an array in numpy. See the documentation to learn more.\n\nOnce multi-dimensional arrays have been formed, you frequently need to modify them. For manipulating arrays, NumPy provides a large selection of functions let's see some of them.\n• How to concatenate multidimensional arrays in numpy\n\nTwo or more arrays are combined using concatenation along an already-existing axis. For this, you can use np.concatenate(). Let's see one example:\n\nThe output will be:\n\n2. How to access different rows of a multidimensional numpy array?\n\nIndexing and slicing multi-dimensional arrays is fundamental to accessing specific elements or subsets of your data. Indexing in multi-dimensional arrays is similar to indexing in lists but with multiple dimensions. You specify the row and column indices:\n\nThe output will be:\n\nSlicing allows you to extract a subset of elements from a multi-dimensional array. You specify a range of indices along each dimension:\n\nThe output will be:\n\nA large collection of functions in NumPy are available for working with multi-dimensional arrays. These operations may be aggregated or element-wise. You can perform addition, subtraction, multiplication, and division on multidimensional arrays in Numpy.\n\nThe output will be:\n\nThe output will be:\n\nAggregation functions are used to compute statistics on multi-dimensional arrays, such as sum, mean, median, and more. Let’s see some examples:\n\nThe output will be:\n\nThe output will be:\n\nYou were given a thorough understanding of indexing and slicing multidimensional arrays, which made it possible to effectively extract particular components or subsets. Finally, we experimented with executing operations on multi-dimensional arrays, such as aggregation operations and element-wise operations.\n\n“If you learn something new from this article, please show your support by giving it a clap. Your appreciation motivates me to create more articles for you. Thank you for your encouragement!”"
    },
    {
        "link": "https://docs.vultr.com/python/third-party/numpy/mean",
        "document": "The function in the NumPy library is pivotal for calculating the average value from an array of numbers. This function simplifies statistical data analysis, easing the process of finding central tendencies in large datasets. Its usage spans various fields, including finance, science, and machine learning where quick and accurate average calculations are crucial.\n\nIn this article, you will learn how to harness the function to compute averages effectively. The guidance provided will cover applying this function to different data structures and will explore variations in its application to enhance your data manipulation skills in Python.\n\nCalculate the Mean of a Single-Dimensional Array\n• None Calculate and print the mean of the array using . This script calculates the average of the numbers 1 through 5, resulting in .\n• None Apply the function with appropriate axis argument to compute means along different dimensions. Here, computes the overall mean, computes the mean of each column, and computes the mean of each row.\n• None Construct an array with floating-point numbers and compute the mean. The output here is a floating-point number representing the average, which reflects the greater precision in the data.\n• None Recognize that NaN (Not a Number) values can affect the average calculation.\n• None Use to correctly compute the mean by ignoring NaN values. provides the mean of the array while ignoring values. This function is essential for accurate calculations in datasets where some data points are missing or undefined.\n\nThe function from NumPy provides a robust method for calculating averages across various data structures and types. By understanding how to effectively use this function and its variants like , you enhance your ability to handle and analyze numerical data in Python. This tutorial leads you through the essential aspects, ensuring that you can implement these techniques in both simple and complex data scenarios for insightful data analysis."
    },
    {
        "link": "https://matplotlib.org/stable/tutorials/images.html",
        "document": "First, let's start IPython. It is a most excellent enhancement to the standard Python prompt, and it ties in especially well with Matplotlib. Start IPython either directly at a shell, or with the Jupyter Notebook (where IPython as a running kernel). With IPython started, we now need to connect to a GUI event loop. This tells IPython where (and how) to display plots. To connect to a GUI loop, execute the %matplotlib magic at your IPython prompt. There's more detail on exactly what this does at IPython's documentation on GUI event loops. If you're using Jupyter Notebook, the same commands are available, but people commonly use a specific argument to the %matplotlib magic: This turns on inline plotting, where plot graphics will appear in your notebook. This has important implications for interactivity. For inline plotting, commands in cells below the cell that outputs a plot will not affect the plot. For example, changing the colormap is not possible from cells below the cell that creates a plot. However, for other backends, such as Qt, that open a separate window, cells below those that create the plot will change the plot - it is a live object in memory. This tutorial will use Matplotlib's implicit plotting interface, pyplot. This interface maintains global state, and is very useful for quickly and easily experimenting with various plot settings. The alternative is the explicit, which is more suitable for large application development. For an explanation of the tradeoffs between the implicit and explicit interfaces see Matplotlib Application Interfaces (APIs) and the Quick start guide to start using the explicit interface. For now, let's get on with the implicit approach:\n\nMatplotlib relies on the Pillow library to load image data. Here's the image we're going to play with: It's a 24-bit RGB PNG image (8 bits for each of R, G, B). Depending on where you get your data, the other kinds of image that you'll most likely encounter are RGBA images, which allow for transparency, or single-channel grayscale (luminosity) images. Download stinkbug.png to your computer for the rest of this tutorial. We use Pillow to open an image (with ), and immediately convert the object into an 8-bit ( ) numpy array. Each inner list represents a pixel. Here, with an RGB image, there are 3 values. Since it's a black and white image, R, G, and B are all similar. An RGBA (where A is alpha, or transparency) has 4 values per inner list, and a simple luminance image just has one value (and is thus only a 2-D array, not a 3-D array). For RGB and RGBA images, Matplotlib supports float32 and uint8 data types. For grayscale, Matplotlib supports only float32. If your array data does not meet one of these descriptions, you need to rescale it."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-display-an-image-in-grayscale-in-matplotlib",
        "document": ""
    },
    {
        "link": "https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html",
        "document": "The Colormap instance or registered colormap name used to map scalar data to colors. This parameter is ignored if X is RGB(A).\n\nThe normalization method used to scale scalar data to the [0, 1] range before mapping to colors using cmap. By default, a linear scaling is used, mapping the lowest value to 0 and the highest to 1. If given, this can be one of the following:\n• None An instance of or one of its subclasses (see Colormap normalization).\n• None A scale name, i.e. one of \"linear\", \"log\", \"symlog\", \"logit\", etc. For a list of available scales, call . In that case, a suitable subclass is dynamically generated and instantiated. This parameter is ignored if X is RGB(A).\n\nWhen using scalar data and no explicit norm, vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. It is an error to use vmin/vmax when a norm instance is given (but using a norm name together with vmin/vmax is acceptable). This parameter is ignored if X is RGB(A).\n\nThe aspect ratio of the Axes. This parameter is particularly relevant for images since it determines whether data pixels are square. This parameter is a shortcut for explicitly calling . See there for further details.\n• None 'equal': Ensures an aspect ratio of 1. Pixels will be square (unless pixel sizes are explicitly made non-square in data coordinates using extent).\n• None 'auto': The Axes is kept fixed and the aspect is adjusted so that the data fit in the Axes. In general, this will result in non-square pixels. Normally, None (the default) means to use (default: ). However, if the image uses a transform that does not contain the axes data transform, then None means to not modify the axes aspect at all (in that case, directly call if desired).\n\nThe data X is resampled to the pixel size of the image on the figure canvas, using the interpolation method to either up- or downsample the data. If interpolation is 'none', then for the ps, pdf, and svg backends no down- or upsampling occurs, and the image data is passed to the backend as a native image. Note that different ps, pdf, and svg viewers may display these raw pixels differently. On other backends, 'none' is the same as 'nearest'. If interpolation is the default 'auto', then 'nearest' interpolation is used if the image is upsampled by more than a factor of three (i.e. the number of display pixels is at least three times the size of the data array). If the upsampling rate is smaller than 3, or the image is downsampled, then 'hanning' interpolation is used to act as an anti-aliasing filter, unless the image happens to be upsampled by exactly a factor of two or one. See Interpolations for imshow for an overview of the supported interpolation methods, and Image resampling for a discussion of image antialiasing. Some interpolation methods require an additional radius parameter, which can be set by filterrad. Additionally, the antigrain image resize filter is controlled by the parameter filternorm.\n\nPlace the [0, 0] index of the array in the upper left or lower left corner of the Axes. The convention (the default) 'upper' is typically used for matrices and images. Note that the vertical axis points upward for 'lower' but downward for 'upper'. See the origin and extent in imshow tutorial for examples and a more detailed description.\n\nThe bounding box in data coordinates that the image will fill. These values may be unitful and match the units of the Axes. The image is stretched individually along x and y to fill the box. The default extent is determined by the following conditions. Pixels have unit size in data coordinates. Their centers are on integer coordinates, and their center coordinates range from 0 to columns-1 horizontally and from 0 to rows-1 vertically. Note that the direction of the vertical axis and thus the default values for top and bottom depend on origin:\n• None For the default is .\n• None For the default is . See the origin and extent in imshow tutorial for examples and a more detailed description.\n\nA parameter for the antigrain image resize filter (see the antigrain documentation). If filternorm is set, the filter normalizes integer values and corrects the rounding errors. It doesn't do anything with the source floating point values, it corrects only integers according to the rule of 1.0 which means that any sum of pixel weights must be equal to 1.0. So, the filter function must produce a graph of the proper shape."
    },
    {
        "link": "https://stackoverflow.com/questions/3823752/display-image-as-grayscale",
        "document": "I'm trying to display a grayscale image using . My problem is that the grayscale image is displayed as a colormap. I need it to be grayscale because I want to draw on top of the image with color.\n\nI read in the image and convert to grayscale using PIL's\n\nThen I convert the image to a matrix so that I can easily do some image processing using\n\nHowever, when I do\n\nit displays the image using a colormap (i.e. it's not grayscale).\n\nWhat am I doing wrong here?"
    },
    {
        "link": "https://matplotlib.org/stable/gallery/index.html",
        "document": "For an overview of the plotting methods we provide, see Plot types\n\nThis page contains example plots. Click on any image to see the full image and source code.\n\nFor longer tutorials, see our tutorials page. You can also find external resources and a FAQ in our user guide."
    }
]