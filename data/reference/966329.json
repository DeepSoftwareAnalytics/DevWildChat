[
    {
        "link": "https://geeksforgeeks.org/md5sum-linux-command",
        "document": "The md5sum is designed to verify data integrity using\n\n(Message Digest Algorithm 5). MD5 is 128-bit cryptographic hash and if used properly it can be used to verify file authenticity and integrity. Example :\n\nSuppose, anyone wants to install an operating system , so to verify if it’s correct CD, it’s always a good idea to verify .iso file using MD5 checksum, so that you don’t end up installing wrong software (some sort of virus which can corrupt your filesystem).\n\nIt will print or check MD5(128-bit) checksum. It computes MD5 checksum for file “test.cpp” Output :\n\nread MD5 from files and check them\n\nThe options which are useful when verifying checksum :\n\ndon’t print OK for each successfully verified file\n\nExample 1: Store the MD5 checksum in file and then verify it.\n\nIt will store the MD5 checksum for test.cpp in file checkmd5.md5\n\nIt will verify the contents of file Output :\n\nAfter changing the contents of file checkmd5.md5, the output will be :\n\nExample 3: –quiet option, can be used when verifying checksum, don’t print OK when verification is successful.\n\nDon’t produce any output, means it’s successful. But if checksum don’t match, it produces warning.\n\nExample 4: –warn option, it can be used for generating a warning for improperly formatted checksum files. content of file checkmd5.md5:\n\nIt don’t produce any warning. Now, do some formatting in file checkmd5.md5\n\nand if –warn is replaced with –strict option, it will exit non-zero for improperly formatted checksum lines\n\nWhat is the md5sum command used for in Linux?\n\nHow to generate an MD5 checksum for a file using md5sum?\n\nTo generate an MD5 checksum for a file, you can use the command followed by the filename. For example, to calculate the MD5 checksum of a file named , you would use the following command: This command will output the MD5 checksum followed by the filename. The output might look something like this:\n\nHow to verify a file’s integrity with md5sum?\n\nCan md5sum check multiple files at once?\n\nYes, can check multiple files at once. To do this, generate MD5 checksums for all the files you want to check and save them in a single checksum file. Here’s an example of how to generate the checksums for all files in a directory and save them: You can then verify all files at once using: This process will check each file listed in and report on their integrity individually.\n\nWhat are the limitations of using md5sum?"
    },
    {
        "link": "https://phoenixnap.com/kb/md5sum-linux",
        "document": "When you download a file from the internet, it is a good safety practice to check whether you received the original version. Comparing checksums you received from the file creator with the ones you obtain by checking the file yourself is a reliable way to confirm your download’s integrity.\n\nThe command in Linux helps create, read, and check file checksums.\n\nIn this tutorial, you will learn how to use the command to validate the files you receive.\n\nWhen used on a file without any options, the command displays the file’s hash value alongside the filename. The syntax is:\n\nAfter obtaining the hash value, compare it with the MD5 value provided by the file creator.\n\nTo read the file in binary mode, use the option ( ):\n\nThe character before the file name means that read it in binary mode.\n\nUse the option ( ) to read the file in text mode:\n\nText mode is the default mode for reading files with .\n\nUsing the option outputs the hash value in the BSD-style format:\n\nTo check a file by comparing its hash value with the value provided in a hash file, use the option.\n\n1. As an example, create a hash file containing the output:\n\n2. Use the following syntax to compare the hash value from the file you created against the current hash value of the file:\n\n3. If you change the contents of the file and repeat the check, a warning message is displayed:\n\nUse the same procedure to check the integrity of multiple files:\n\nIn the following example, the contents of have changed, resulting in a warning message from :\n\nThe option displays only the files whose hash value has changed. It skips the output of validated files.\n\nThe command with the option does not produce any output but returns if there are no changes and if it detects changes. This argument is useful for scripting, where there is no need for standard output.\n\nThe example script below illustrates the use of the option:\n\nWhen the script executes, it shows status , meaning that detected the change made earlier in .\n\nAdd the option to exit non-zero for improperly formatted hash values:\n\nThe example shows the output of when you put invalid characters in the first line of the file containing hashes:\n\nTo display which line has an invalid hash, use ( ):\n\nThe example above shows the option displaying that the improperly formatted MD5 checksum line is line 1 of the file.\n\nBy default, shows warnings about the files it cannot find on the system. To override this behavior, use the option:\n\nIn the example below, was deleted before running the command. The output ignores the deleted file:\n\nTo get the official help for the command, type:\n\nAfter completing this tutorial, you should know how to properly use the command to create, print, or check MD5 checksums."
    },
    {
        "link": "https://ioflood.com/blog/md5sum-linux-command",
        "document": "Are you finding it challenging to verify the integrity of your files in Linux? You’re not alone. Many developers and system administrators find this task daunting, but there’s a tool in Linux that can make this process a breeze.\n\nJust like a detective uses fingerprints, you can use the md5sum command in Linux to ensure your files haven’t been tampered with. This command is a handy utility that can generate a unique ‘fingerprint’ or hash for your files. These hashes can then be used to verify the integrity of your files, even on different systems.\n\nThis guide will walk you through the basics to advanced usage of the md5sum command in Linux. We’ll explore md5sum’s core functionality, delve into its advanced features, and even discuss common issues and their solutions.\n\nSo, let’s dive in and start mastering the md5sum command in Linux!\n\nTL;DR: How Do I Use the md5sum Command in Linux?\n\nIn this example, we’ve used the command to generate an MD5 hash for the file . The output is a unique hash value, followed by the file name. This hash can be used to verify the file’s integrity on any system.\n\nOne of the primary uses of the md5sum command in Linux is to generate MD5 hashes. This is a simple yet powerful feature that allows you to create a unique ‘fingerprint’ for your files. Here’s a basic example of how you can generate an MD5 hash:\n\nIn this example, we first create a new file named with the content ‘Hello, World!’. We then use the command to generate an MD5 hash for this file. The output is a unique hash value followed by the file name.\n\nNow, what if you want to verify the integrity of this file on a different system or at a later time? You can do this by comparing the MD5 hash you’ve just generated with the hash of the file on the other system or at the later time. Here’s how you can do this:\n\nIn this example, we use the option with the command to check the MD5 hash of the file against the previously generated hash. The output ‘OK’ indicates that the file’s integrity is intact.\n\nPros and Cons of Using the md5sum Command\n\nThe command is a powerful tool, but like any tool, it has its pros and cons.\n• It’s simple and easy to use.\n• It can generate unique hashes for your files.\n• It allows you to verify the integrity of your files across different systems.\n• MD5 hashes are not collision-resistant. This means that two different files can potentially have the same MD5 hash, although this is highly unlikely.\n• MD5 is considered to be weak in terms of cryptographic security. For more secure hash algorithms, you may want to use sha256sum or sha1sum, which we’ll discuss later in this guide.\n\nAs you become more proficient with the md5sum command in Linux, you can start to explore its more advanced features. These include handling multiple files and checking hashes against a list.\n\nBefore we dive into these advanced usage scenarios, let’s familiarize ourselves with some of the command-line arguments or flags that can modify the behavior of the md5sum command. Here’s a table with some of the most commonly used md5sum arguments.\n\nNow that we have a basic understanding of md5sum command line arguments, let’s dive deeper into the advanced use of md5sum.\n\nOne of the powerful features of the md5sum command is its ability to handle multiple files at once. This can be particularly useful when you need to generate or verify hashes for a large number of files. Here’s an example:\n\nIn this example, we create two new files, and , and then use the command to generate MD5 hashes for both files at once. The output includes a unique hash for each file, followed by the file name.\n\nAnother advanced feature of the md5sum command is its ability to check hashes against a list. This can be useful when you need to verify the integrity of multiple files against their known hashes. Here’s an example:\n\nIn this example, we first create a new file named that contains the known MD5 hashes for and . We then use the command to check the hashes of these files against the listed values. The output ‘OK’ for each file indicates that their integrity is intact.\n\nWhile the md5sum command in Linux is a powerful tool for generating and verifying MD5 hashes, it’s not the only utility you can use for this purpose. In fact, there are alternative commands that can accomplish similar tasks, such as sha256sum and sha1sum. These commands use different hash algorithms that can provide stronger cryptographic security.\n\nThe sha256sum command works similarly to md5sum, but it uses the SHA-256 hash algorithm, which generates a 256-bit hash. This provides a higher level of security compared to MD5.\n\nHere’s an example of how you can use the sha256sum command:\n\nIn this example, we’ve used the command to generate a SHA-256 hash for the file . The output is a unique hash value, followed by the file name.\n\nThe sha1sum command is another alternative to md5sum. It uses the SHA-1 hash algorithm, which generates a 160-bit hash. However, SHA-1 is considered to be weaker than both MD5 and SHA-256 in terms of collision resistance.\n\nHere’s an example of how you can use the sha1sum command:\n\nIn this example, we’ve used the command to generate a SHA-1 hash for the file . The output is a unique hash value, followed by the file name.\n\nWhen choosing between md5sum, sha256sum, and sha1sum, there are several considerations to keep in mind:\n• Security: If security is your primary concern, sha256sum is the best option as it provides the strongest cryptographic security.\n• Speed: If speed is more important, md5sum is the fastest option, followed by sha1sum and sha256sum.\n• Compatibility: If you need to verify hashes on different systems, keep in mind that not all systems may support sha256sum or sha1sum.\n\nUltimately, the best command for you will depend on your specific needs and constraints.\n\nWhile the md5sum command in Linux is a powerful and versatile tool, you may encounter some common issues when using it. Let’s discuss these issues and their solutions, along with some best practices for using the md5sum command.\n\nOne of the most common issues you might encounter when using the md5sum command is a ‘file not found’ error. This typically happens when the file you’re trying to generate a hash for doesn’t exist or the file path is incorrect.\n\nHere’s an example of this issue:\n\nIn this example, we’re trying to generate an MD5 hash for a file that doesn’t exist, which results in a ‘No such file or directory’ error. To fix this issue, make sure that the file you’re trying to hash exists and that the file path is correct.\n\nAnother common issue you might encounter when using the md5sum command is a ‘permission denied’ error. This typically happens when you don’t have the necessary permissions to read the file you’re trying to generate a hash for.\n\nHere’s an example of this issue:\n\nIn this example, we’re trying to generate an MD5 hash for a file that we don’t have read permissions for, which results in a ‘Permission denied’ error. To fix this issue, you can change the file permissions using the chmod command or run the md5sum command with sudo.\n\nBest Practices for Using md5sum\n\nWhen using the md5sum command, there are a few best practices you should keep in mind:\n• Always double-check the file path and file name to avoid ‘file not found’ errors.\n• Make sure you have the necessary permissions to read the file you’re trying to generate a hash for.\n• Consider using more secure hash algorithms like sha256sum or sha1sum for sensitive data.\n• Keep your system and software updated to ensure you have the latest security patches and improvements.\n\nBefore we dive deeper into the md5sum command in Linux, it’s crucial to understand the concept of hashing and the MD5 algorithm. This background knowledge will help you appreciate the power and utility of the md5sum command.\n\nIn the world of computer science, a hash is a function that converts an input (or ‘message’) into a fixed-size string of bytes, typically a ‘digest’ that is unique to each unique input. It’s like a ‘fingerprint’ for data. No matter how large or small your input is, the output hash size remains the same.\n\nIn the code block above, we used the md5sum command to create a hash of the string ‘Hello, World!’. The output is a unique 32-character hash.\n\nMD5 (Message Digest Algorithm 5) is a widely used cryptographic hash function that produces a 128-bit (16-byte) hash value. It’s commonly used to verify data integrity. MD5 has been utilized in a wide variety of security applications and is also commonly used to check the integrity of files. However, MD5 is not collision-resistant; as more computing power becomes available, the ability to collide MD5 hashes (i.e., find two different inputs that hash to the same output) becomes easier.\n\nIn this code block, we used the md5sum command to generate an MD5 hash of the string ‘Hello, World!’. The output is a unique 32-character hash, which is the standard output size for an MD5 hash.\n\nThe Importance of File Integrity Checks in Cybersecurity\n\nFile integrity checks are crucial in the context of cybersecurity. They allow you to ensure that files have not been tampered with, which could indicate a security breach. By generating and verifying MD5 hashes, you can ensure that your files are exactly as they were when the hash was generated. This can be particularly important in situations where you’re transferring files over a network or storing files for long periods.\n\nThe md5sum command in Linux is not just a standalone tool for generating and verifying MD5 hashes. It can also be a powerful component in larger scripts or projects. For instance, you can use md5sum in your shell scripts to verify the integrity of downloaded files before using them. This can help prevent issues caused by corrupted or tampered files.\n\nHere’s a simple example of how you can use the md5sum command in a bash script:\n\nIn this script, we first define the known MD5 hash for a file. We then generate an MD5 hash for a downloaded file and compare the two hashes. If they match, the file integrity check passes; otherwise, it fails.\n\nWhile md5sum is a powerful tool for generating and verifying MD5 hashes, it’s not the only utility you can use for this purpose. If you’re working on a project that requires more secure hash algorithms, you might want to explore related commands like sha256sum.\n\nThe sha256sum command works similarly to md5sum, but it uses the SHA-256 hash algorithm, which provides stronger cryptographic security. Here’s a simple example of how you can use the sha256sum command in a bash script:\n\nIn this script, we use the sha256sum command instead of md5sum to generate and verify SHA-256 hashes, which provides stronger cryptographic security.\n\nIf you’d like to dive deeper into file integrity checks and hash algorithms, here are some resources you might find helpful:\n• GNU Core Utilities: md5sum invocation: This is the official documentation for the md5sum command in the GNU Core Utilities, which provides a detailed description of the command and its options.\n• None MDN Web Docs: Web APIs – SubtleCrypto.digest: This documentation from Mozilla Developer Network (MDN) explains how to use the SubtleCrypto.digest() method to generate cryptographic hashes in JavaScript, including MD5 and SHA-256.\n• None OpenSSL Command-Line HOWTO: This guide provides a comprehensive overview of the OpenSSL command-line tools, which can be used to generate and verify hashes, among other cryptographic operations.\n\nIn this comprehensive guide, we’ve delved into the details of the md5sum command in Linux. We’ve explored its power as a tool for generating and verifying MD5 hashes, which play a crucial role in verifying file integrity.\n\nWe started with the basics, learning how to use the md5sum command to generate and verify MD5 hashes for individual files. We then progressed to more advanced usage scenarios, such as handling multiple files and checking hashes against a list. In each case, we provided practical code examples to illustrate these concepts.\n\nAlong the way, we tackled common challenges you might encounter when using the md5sum command, such as ‘file not found’ errors and permission issues. We provided solutions for these problems, helping you to use the md5sum command more effectively.\n\nWe also explored alternative approaches to the md5sum command, introducing the sha256sum and sha1sum commands. These commands use different hash algorithms and offer various advantages and disadvantages compared to md5sum.\n\nWhether you’re just starting out with the md5sum command or looking to deepen your understanding, we hope this guide has been a valuable resource. The ability to verify file integrity is a cornerstone of data security, and with the md5sum command, you have a powerful tool at your disposal. Happy hashing!"
    },
    {
        "link": "https://man7.org/linux/man-pages/man1/md5sum.1.html",
        "document": "Pages that refer to this page: mcookie(1), pmlogmv(1), deb-md5sums(5), prelink(8)"
    },
    {
        "link": "https://autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/Checking-the-MD5-checksum-of-a-Downloaded-File.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/27993304/using-diff-with-mismatched-directories-and-filenames",
        "document": "I have two separate folder directories, which mostly contain the same files, but the directory structure is completely different between the two folders. The filenames do not correspond either\n\nSo, for example:\n\nLet's suppose that , , , And is unmatched.\n\nIs there some combination of options to the command that will identify the matches? Doing a recursive with doesn't seem to do the job."
    },
    {
        "link": "https://geeksforgeeks.org/diff-command-linux-examples",
        "document": "How to Compare Files Line by Line in Linux | diff Command\n\nIn the world of Linux, managing and comparing files is a common task for system administrators and developers alike. The ability to compare files line by line is crucial for identifying differences, debugging code, and ensuring the integrity of data. One powerful tool that facilitates this process is the command. In this article, we will explore how to use the command to compare files line by line in Linux.\n\ndiff stands for difference .The command is a versatile utility that is pre-installed on most Linux distributions. Its primary purpose is to compare the contents of two files and display the differences between them. The command provides a comprehensive way to highlight changes, additions, and deletions in a clear and readable format.\n\nThis command is used to display the differences in the files by comparing the files line by line. Unlike its fellow members, cmp and comm, it tells us which lines in one file have is to be changed to make the two files identical.\n\nThe important thing to remember is that diff uses certain special symbols and instructions that are required to make two files identical. It tells you the instructions on how to change the first file to make it match the second file.\n\nThe basic syntax of the command is as follows:\n\nHere, ` and ` are the two files you want to compare.\n\nThe ` flag allows you to customize the behavior of the ` command.\n\nPratical Implementaion of How to compare files line by line in Linux? :\n\nLets say we have two files with names a.txt and b.txt containing 5 Indian states.\n\nNow, applying diff command without any option we get the following output:\n\nLet’s take a look at what this output means. The first line of the diff output will contain:\n• None Line numbers corresponding to the first file,\n• None Line numbers corresponding to the second file.\n\nLike in our case, 0a1 which means after lines 0(at the very beginning of file) you have to add Tamil Nadu to match the second file line number 1. It then tells us what those lines are in each file preceded by the symbol:\n• < are lines from the first file.\n• > are lines from the second file.\n• 2,3c3 which means from line 2 to line 3 in the first file needs to be changed to match line number 3 in the second file. It then tells us those lines with the above symbols.\n• (“—“) merely separate the lines of file 1 and file 2.\n\nAs a summary to make both the files identical, first add Tamil Nadu in the first file at very beginning to match line 1 of second file after that change line 2 and 3 of first file i.e. Uttar Pradesh and Kolkata with line 3 of second file i.e. Andhra Pradesh. After that change line 5 of first file i.e. Jammu and Kashmir with line 5 of second file i.e. Uttar Pradesh.\n\nConsider the scenario where indicates the need to delete a line. Given two files, and :\n\nHere above output 3d2 means delete line 3rd of first file i.e. Telangana so that both the files sync up at line 2.\n\nTo view differences in context mode, use the -c option. Lets try to understand this with example, we have two files file1.txt and file2.txt:\n\nIn the above output:\n• None The first file is denoted by ` , and the second file is denoted by `\n• None The first two lines provide information about file 1 and file 2, displaying the file name, modification date, and modification time.\n• None Following that, three asterisks ` are followed by a line range from the first file (lines 1 through 4). Four asterisks ` come next. The contents of the first file are then displayed with specific indicators:\n• None If a line is unchanged, it is prefixed by two spaces.\n• None If a line needs to be changed, it is prefixed by a symbol and a space. The symbols indicate:\n• None : A line in the second file to be added to the first file for identical results.\n• None : A line in the first file to be deleted for identical results.\n• None are followed by a line range from the second file (lines 1 through 4), separated by a comma. Four dashes ` follow, and the contents of the second file are displayed.\n\nTo view differences in unified mode, use the -u option. It is similar to context mode but it doesn’t display any redundant information or it shows the information in concise form.\n\nIn the above output:\n• None The first file is indicated by ` , and the second file is indicated by `\n• None The first two lines provide information about file 1 and file 2, including the modification date and time.\n• None denotes the line range for both files. In this case, it represents lines 1 through 4 in both files.\n• None The subsequent lines represent the contents of the files with specific indicators:\n• None Unchanged lines are displayed without any prefix.\n• None Lines in the first file to be deleted are prefixed with\n• None Lines in the second file to be added are prefixed with\n\nIn this example, the output indicates that to make both files identical, the lines containing “mv” and “comm” need to be deleted from the first file ( ), and the lines containing “diff” and “comm” need to be added to it.\n\nBy default, ` is case-sensitive. To perform a case-insensitive comparison, use the ` option:\n\nThe command is then used to compare these files with the option, which makes the comparison case-insensitive.\n• None : This indicates a change in line 2 of the first file ( stands for delete, and it says to delete line 2 from the first file.\n• None : This line signifies the content of the line to be deleted. In this case, it is “mv.”\n• None : This indicates an addition in line 3 of the first file ( stands for add, and it says to add a line at position 3.\n• None : This line represents the content to be added. In this case, it is “diff.”\n\nIn summary, the output tells us that to make both files identical (ignoring case), we need to delete the line containing “mv” from the first file ( ) and add the line “diff” at the same position. The command, with the option, allows for a case-insensitive comparison, making it consider “mv” and “MV” as the same during the analysis.\n\nTo check the version of ` installed on your system, use the ` option:\n\nThis command provides information about the version, licensing, and authors of the ` utility.\n\nHow to Compare Files Line by Line in Linux | diff Command – FAQs\n\nHow do I use the command to compare two files line by line in Linux?\n\nCan I ignore whitespace differences while comparing files with the\n\nHow can I create a patch file using the\n\nWhat is the unified format in output, and how is it different from the context format?\n\nHow do I recursively compare two directories in Linux using the\n\nIn the Linux world, comparing files is a common task for system administrators and developers. The ` command is a handy tool that helps in this process. This article explores how to use ` to compare files line by line in Linux. It covers the basic syntax, important options like context mode and unified mode, and practical applications such as creating patch files and recursively comparing directories. Whether you’re debugging code or ensuring file integrity, understanding and mastering the ` command is essential for efficient file management in Linux."
    },
    {
        "link": "https://stackoverflow.com/questions/119788/how-to-compare-files-with-same-names-in-two-different-directories-using-a-shell",
        "document": "here is an example of a (somewhat messy) script of mine, dircompare.sh, which will:\n• sort files and directories in arrays depending on which directory they occur in (or both), in two recursive passes\n• The files that occur in both directories, are sorted again in two arrays, depending on if determines if they differ or not\n• for those files that claims are equal, show and compare timestamps\n\nHope it can be found useful - Cheers!\n\nEDIT2: (Actually, it works fine with remote files - the problem was unhandled Ctrl-C signal during a diff operation between local and remote file, which can take a while; script now updated with a trap to handle that - however, leaving the previous edit below for reference):\n\nEDIT: ... except it seems to crash my server for a remote ssh directory (which I tried using over )... So this is not anymore, but an alternative I guess is to use , here's an example:\n• To get the above, you mustn't forget trailing slashes at the end of directory names in\n• - verbose (but not related to file changes info)\n\nHere is a brief excerpt of that explains the information shown by (for instance, the strings above):\n\nA bit cryptic, indeed - but at least it shows basic directory comparison over . Cheers!"
    },
    {
        "link": "https://unix.com/unix-for-dummies-questions-and-answers/103217-diff-creating-special-characters-output-file.html",
        "document": ""
    },
    {
        "link": "https://hostman.com/tutorials/how-to-use-the-diff-command-linux",
        "document": "Falco is a security tool that allows you to record security events on Linux servers based on rules. It was previously developed by Sysdig and later handed over to Cloud Native Computing Foundation. This guide shows how to install Falco on Linux servers, write rules to detect malicious events executed by processes or users and eventually compares it with Linux Auditd. Prerequisites To follow this guide, you'll need access to a Debian Linux or CentOS Stream 9 server. Alternatively, you could spin up a virtual server using Hostman. The Hostman website has instructions on how to launch a virtual server. Brief Overview of Linux System Calls In Linux, the user-space is reserved for user-facing services like web browsers, text editors, etc, whilst the kernel space is reserved for the privileged services. Services provided within the kernel space include memory management, process scheduling, file system management, etc. In the context of system calls, when a user executes the cd command, the “chdir system call’’ is invoked via the chdir() wrapper function within the glibc library to change the current working directory and returns the result to the user-space program. Usually, the name of the wrapper function is the same as the invoked system call. The GNU C Library, also known as glibc, contains system functions, acting as a wrapper around the actual function provided by the Linux kernel, allowing applications to access system functionality or make system calls through a standardized C interface. For detailed information on how Linux systems calls work and roles/tasks of glibc wrapper functions, check Linux man page. What is Falco? Falco provides runtime security across hosts, containers, Kubernetes, and other cloud native environments. It relies on both default and custom rules to detect events as malicious on Linux hosts, Kubernetes applications, etc. and associates event data with contextual metadata to deliver meaningful real-time alerts to the SIEM team. Falco relies on different sources to gather events data. It natively supports Linux system call source by default. However, it’s possible to extend Falco capabilities to support other event sources like Kubernetes audit logs, AWS Cloudtrail, KeyCloak Admin/User events via the plugin system. The plugin system consists of shared libraries that allows Falco to include or add new event sources, include new fields that extract information from events, etc. As at the time of writing this guide, some of the following plugins are: K8saudit: Monitors and detects Kubernetes cluster events. Cloudtrail: Tracks events from Cloudtrail logs. Kafka: Records events from Kafka topics. Keycloak: Detects Keycloak user/admin events. Check their website for a complete list of currently supported plugins. In order to consume events at the kernel source, the following drivers are currently supported: eBPF probe modern eBPF probe kernel module Using Modern eBPF Probe eBPF means “extended Berkeley Packet Filter”. It enables us to run isolated programs within the Linux kernel space in order to extend the capabilities of the kernel without loading additional kernel modules. They are programs that execute when specific hook points are triggered or an event takes place. eBPF probe is embedded into the userspace application and works out of the box, regardless of the kernel release. To use the modern eBPF probe, set the engine.kind parameter inside the /etc/falco/falco.yaml file to modern_ebpf to activate this feature. There is no need to install other dependencies such as clang or llvm if you want to use modern eBPF. Installing Falco This section shows how to install Falco on Linux Debian and CentOS servers. Running Falco on Debian Step 1: Import Falco GPG key. curl -fsSL https://falco.org/repo/falcosecurity-packages.asc | \\sudo gpg --dearmor -o /usr/share/keyrings/falco-archive-keyring.gpg Step 2: Setup the apt repository. sudo bash -c 'cat << EOF > /etc/apt/sources.list.d/falcosecurity.listdeb [signed-by=/usr/share/keyrings/falco-archive-keyring.gpg] https://download.falco.org/packages/deb stable mainEOF' Step 3: Install the apt-transport-https package. sudo apt install apt-transport-https Step 4: Update the apt repository. sudo apt update -y Step 5: Install Falco. sudo apt install -y falco Running Falco on CentOS Stream 9 Step 1: Import the Falco GPG key. rpm --import https://falco.org/repo/falcosecurity-packages.asc Step 2: Set up the yum repository. curl -s -o /etc/yum.repos.d/falcosecurity.repo https://falco.org/repo/falcosecurity-rpm.repo Step 3: Update the yum repository. yum update -y Step 4: Install Falco. yum install -y falco Step 5: Execute the command to test whether Falco is successfully installed. falco Managing Falco with systemd In production, it's recommended to manage Falco using Systemd because it provides a centralized way to control and automate service restart instead of manually managing Falco. Systemd is the init process that starts required system services at boot time. Use the following instructions to manually configure Systemd with Falco. Step 1: Execute the following command to search for Falco services. systemctl list-units \"falco*\" Step 2: Use these commands to enable, start and check the status of falco-modern-bpf.service. The systemctl enable command ensures Falco starts at boot time systemctl enable falco-modern-bpf.service This command starts the service: systemctl start falco-modern-bpf.service And this is how you check if the service is running: systemctl status falco-modern-bpf.service Step 3: Execute the command systemctl list-units | grep falco to search for active related services The screenshot shows that both services are active. The latter is responsible for performing rules updates. If you don't want falcoctl to perform automatic rules update, use the command below to mask it. systemctl mask falcoctl-artifact-follow.service It prevents falcoctl service from being enabled automatically once an aliased falco service is enabled. Check this page for further information on using Systemd to manage Falco. Configuring Falco Settings This section shows how to configure some settings in the Falco configuration file located at /etc/falco/falco.yaml. watch_config_files: This key can be assigned true or false values. The true value ensures that anytime changes are made to the rules or configuration file, it automatically reloads itself to apply the updated configuration settings. rules_files: This key determines which rule files or directories are loaded first based on the values assigned to it. The example below ensures that rules in the /etc/falco/rules.d folder are checked first. rules_files: - /etc/falco/rules.d - /etc/falco/falco_rules.yaml - /etc/falco/falco_rules.local.yaml output_channel: Falco supports the following output channels. Syslog standard output http endpoint or webhook file output grpc service You can enable one of these channels to determine where alerts and log messages are sent to. Writing Falco Rules Basically, a rule is made up of an event and specific condition. Example of an event is a filesystem activity such as when a user accesses a file in the etc directory. Another example of an event is when someone or a service decides to connect or transfer a file to a remote host. Conditions are pragmatic expressions that define the exact details Falco should look for. It involves inspecting process arguments, network addresses, etc. Rules are written in YAML, and have a variety of required and optional keys. They are loaded at startup. Following is the structure of a rule in Falco. rule: This key defines the name of the rule, e.g. rule: Unauthorised File Access. desc: The key desc means description. It describes the purpose of the rule, e.g. Detecting unauthorized access to files in the /etc folder by regular users. condition: This key informs Falco to trigger an alert when a specific event takes place, e.g. condition: open_read and fd.name startswith /etc. output: The message that will be shown in the notification. priority: This key defines the priority level of the rule. Priority levels include WARNING, ERROR, DEBUG, NOTICE, EMERGENCY, INFORMATIONAL, CRITICAL, and ALERT. tags: This key is used to categorize rules, e.g. [\"Sensitive_Files\", and \"Unauthorized_Users\"]. For detailed information on Falco rules, check Falco’s website. The following are rules to detect specific filesystem access and outbound network connection. Creating a Rule for Filesystem Activity Use the following steps to create a custom Falco rule. Navigate to the path /etc/falco/rules.d using the cd command. cd /etc/falco/rules.d Create a custom rule file using the following command. touch custom_rules.yaml Open and edit the custom_rules.yaml file using vim or any other text editor. vim custom_rules.yaml Then copy and paste the following into the file custom_rules.yaml. - rule: reading sensitive file desc: Detects when a user reads /etc/ folder condition: open_read and fd.name startswith /etc/ output: “suspicious file read detected file=%fd.name accessed by user=%user.name” priority: WARNING tags: [network, filesystem] Start Falco in the background. falco & To stop the background process falco from running forever, use the following command to search for process ID. pgrep falco Then use the kill command to terminate it by specifying the pid. kill -9 process-pid Now test the rule we just created to check whether Falco would alert us when a user opens or accesses the file /etc/passwd. cat /etc/passwd Creating a Rule for Detecting Outbound Connection Use the following to create a rule to monitor network connection. Navigate to the folder /etc/falco/rules.d using the command: cd /etc/falco/rules.d Use a text editor like vim to create a new file for custom rules. vim custom.yaml Copy and paste the following rule into the file custom.yaml to flag outbound connections to other hosts. - rule: \"Suspicious outbound connection\" desc: detect outbound connection to other hosts condition: outbound and evt.type = connect and fd.sip != 8.8.8.8 output: \"Suspicious outbound connection detected destination=%fd.sip\" priority: WARNING tags: [network, exfiltration] Make sure you execute the falco command before testing the preceding rule via the command: ping -c 1 blacklisted_IPaddress We'll receive a warning: Comparison Between Falco and Linux Audit Framework. Auditd is a part of the Linux auditing framework. It is responsible for writing audit records to the disk. Both tools are useful in detecting events registered as malicious via rules. In addition, both tools rely on system calls as their native event source. However, there are differences between these tools: Auditd does not have multiple event sources as compared to Falco. Auditd does not allow users to customize event output but Falco allows. Conclusion Falco is useful in detecting events defined as malicious via rules. These define whether events are malicious or not. However, it's worth noting that the folder /etc/falco/ should be restricted to privileged users and also be monitored by Falco otherwise anyone can tweak rules in the file to avoid detection."
    }
]