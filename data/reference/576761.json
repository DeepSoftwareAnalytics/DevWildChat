[
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/conditional-statements-in-python",
        "document": "Conditional statements in Python are used to execute certain blocks of code based on specific conditions. These statements help control the flow of a program, making it behave differently in different situations.\n\nIf statement is the simplest form of a conditional statement. It executes a block of code if the given condition is true.\n\nShort-hand if statement allows us to write a single-line if statement.\n\nThis is a compact way to write an if statement. It executes the print statement if the condition is true.\n\nIf else Conditional Statements in Python\n\nElse allows us to specify a block of code that will execute if the condition(s) associated with an if or elif statement evaluates to False. Else block provides a way to handle all other cases that don't meet the specified conditions.\n\nThe short-hand if-else statement allows us to write a single-line if-else statement.\n\nNote: This method is also known as ternary operator. Ternary Operator essentially a shorthand for the if-else statement that allows us to write more compact and readable code, especially for simple conditions.\n\nelif statement in Python stands for \"else if.\" It allows us to check multiple conditions , providing a way to execute different blocks of code based on which condition is true. Using elif statements makes our code more readable and efficient by eliminating the need for multiple nested if statements.\n\nHere, the first condition x > 15 is False, so the elif condition x > 5 is checked next. Since it is True, the corresponding block is executed.\n\nNested if..else means an if-else statement inside another if statement. We can use nested if statements to check conditions within conditions.\n\nA ternary conditional statement is a compact way to write an if-else condition in a single line. It’s sometimes called a \"conditional expression.\"\n• None If age >= 18 is True, status is assigned \"Adult\".\n\nmatch-case statement is Python's version of a switch-case found in other languages. It allows us to match a variable's value against a set of patterns.\n• None Python If Else in One Line\n\nWhat are Conditional Statements in Python?\n\nWhat is a Conditional Expression in Python?\n\nWhat are Decision-Making Statements in Python?\n\nWhat are Conditional Selection Statements in Python?\n\nWhat are the Conditional Loops in Python?\n\nWhile Python supports loops that can incorporate conditions, the term \"conditional loops\" might specifically refer to loops that run based on a condition. Python provides two primary types of such loops:\n• None loop: Continues to execute as long as a given condition is true. It checks the condition before executing the loop body.\n• None loop: Iterates over a sequence (like a list, tuple or string) and executes the loop body for each item in the sequence. Although not traditionally a \"conditional\" loop, it can incorporate conditions using # for loop example with condition \n\n\n\n\n\n break # Exit the loop when i is 5 \n\n These explanations outline how Python uses conditional statements and expressions to manage the flow of execution and make decisions within programs, crucial for creating dynamic and responsive applications"
    },
    {
        "link": "https://docs.python.org/3/reference/compound_stmts.html",
        "document": "Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way. In general, compound statements span multiple lines, although in simple incarnations a whole compound statement may be contained in one line.\n\nThe , and statements implement traditional control flow constructs. specifies exception handlers and/or cleanup code for a group of statements, while the statement allows the execution of initialization and finalization code around a block of code. Function and class definitions are also syntactically compound statements.\n\nA compound statement consists of one or more ‘clauses.’ A clause consists of a header and a ‘suite.’ The clause headers of a particular compound statement are all at the same indentation level. Each clause header begins with a uniquely identifying keyword and ends with a colon. A suite is a group of statements controlled by a clause. A suite can be one or more semicolon-separated simple statements on the same line as the header, following the header’s colon, or it can be one or more indented statements on subsequent lines. Only the latter form of a suite can contain nested compound statements; the following is illegal, mostly because it wouldn’t be clear to which clause a following clause would belong:\n\nAlso note that the semicolon binds tighter than the colon in this context, so that in the following example, either all or none of the calls are executed:\n\nNote that statements always end in a possibly followed by a . Also note that optional continuation clauses always begin with a keyword that cannot start a statement, thus there are no ambiguities (the ‘dangling ’ problem is solved in Python by requiring nested statements to be indented).\n\nThe formatting of the grammar rules in the following sections places each clause on a separate line for clarity.\n\nThe statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object: for_stmt ::= \"for\" \"in\" \":\" [\"else\" \":\" ] The expression is evaluated once; it should yield an iterable object. An iterator is created for that iterable. The first item provided by the iterator is then assigned to the target list using the standard rules for assignments (see Assignment statements), and the suite is executed. This repeats for each item provided by the iterator. When the iterator is exhausted, the suite in the clause, if present, is executed, and the loop terminates. A statement executed in the first suite terminates the loop without executing the clause’s suite. A statement executed in the first suite skips the rest of the suite and continues with the next item, or with the clause if there is no next item. The for-loop makes assignments to the variables in the target list. This overwrites all previous assignments to those variables including those made in the suite of the for-loop: # this will not affect the for-loop # because i will be overwritten with the next Names in the target list are not deleted when the loop is finished, but if the sequence is empty, they will not have been assigned to at all by the loop. Hint: the built-in type represents immutable arithmetic sequences of integers. For instance, iterating successively yields 0, 1, and then 2. Changed in version 3.11: Starred elements are now allowed in the expression list.\n\nThe statement specifies exception handlers and/or cleanup code for a group of statements: try_stmt ::= | | try1_stmt ::= \"try\" \":\" (\"except\" [ [\"as\" ]] \":\" )+ [\"else\" \":\" ] [\"finally\" \":\" ] try2_stmt ::= \"try\" \":\" (\"except\" \"*\" [\"as\" ] \":\" )+ [\"else\" \":\" ] [\"finally\" \":\" ] try3_stmt ::= \"try\" \":\" \"finally\" \":\" Additional information on exceptions can be found in section Exceptions, and information on using the statement to generate exceptions may be found in section The raise statement. The clause(s) specify one or more exception handlers. When no exception occurs in the clause, no exception handler is executed. When an exception occurs in the suite, a search for an exception handler is started. This search inspects the clauses in turn until one is found that matches the exception. An expression-less clause, if present, must be last; it matches any exception. For an clause with an expression, the expression must evaluate to an exception type or a tuple of exception types. The raised exception matches an clause whose expression evaluates to the class or a non-virtual base class of the exception object, or to a tuple that contains such a class. If no clause matches the exception, the search for an exception handler continues in the surrounding code and on the invocation stack. If the evaluation of an expression in the header of an clause raises an exception, the original search for a handler is canceled and a search starts for the new exception in the surrounding code and on the call stack (it is treated as if the entire statement raised the exception). When a matching clause is found, the exception is assigned to the target specified after the keyword in that clause, if present, and the clause’s suite is executed. All clauses must have an executable block. When the end of this block is reached, execution continues normally after the entire statement. (This means that if two nested handlers exist for the same exception, and the exception occurs in the clause of the inner handler, the outer handler will not handle the exception.) When an exception has been assigned using , it is cleared at the end of the clause. This is as if This means the exception must be assigned to a different name to be able to refer to it after the clause. Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs. Before an clause’s suite is executed, the exception is stored in the module, where it can be accessed from within the body of the clause by calling . When leaving an exception handler, the exception stored in the module is reset to its previous value: The clause(s) are used for handling s. The exception type for matching is interpreted as in the case of , but in the case of exception groups we can have partial matches when the type matches some of the exceptions in the group. This means that multiple clauses can execute, each handling part of the exception group. Each clause executes at most once and handles an exception group of all matching exceptions. Each exception in the group is handled by at most one clause, the first that matches it. Any remaining exceptions that were not handled by any clause are re-raised at the end, along with all exceptions that were raised from within the clauses. If this list contains more than one exception to reraise, they are combined into an exception group. If the raised exception is not an exception group and its type matches one of the clauses, it is caught and wrapped by an exception group with an empty message string. An clause must have a matching expression; it cannot be . Furthermore, this expression cannot contain exception group types, because that would have ambiguous semantics. It is not possible to mix and in the same . , and cannot appear in an clause. The optional clause is executed if the control flow leaves the suite, no exception was raised, and no , , or statement was executed. Exceptions in the clause are not handled by the preceding clauses. If is present, it specifies a ‘cleanup’ handler. The clause is executed, including any and clauses. If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The clause is executed. If there is a saved exception it is re-raised at the end of the clause. If the clause raises another exception, the saved exception is set as the context of the new exception. If the clause executes a , or statement, the saved exception is discarded: The exception information is not available to the program during execution of the clause. When a , or statement is executed in the suite of a … statement, the clause is also executed ‘on the way out.’ The return value of a function is determined by the last statement executed. Since the clause always executes, a statement executed in the clause will always be the last one executed: Changed in version 3.8: Prior to Python 3.8, a statement was illegal in the clause due to a problem with the implementation.\n\nA function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function). This function object contains a reference to the current global namespace as the global namespace to be used when the function is called. The function definition does not execute the function body; this gets executed only when the function is called. A function definition may be wrapped by one or more decorator expressions. Decorator expressions are evaluated when the function is defined, in the scope that contains the function definition. The result must be a callable, which is invoked with the function object as the only argument. The returned value is bound to the function name instead of the function object. Multiple decorators are applied in nested fashion. For example, the following code except that the original function is not temporarily bound to the name . Changed in version 3.9: Functions may be decorated with any valid . Previously, the grammar was much more restrictive; see PEP 614 for details. A list of type parameters may be given in square brackets between the function’s name and the opening parenthesis for its parameter list. This indicates to static type checkers that the function is generic. At runtime, the type parameters can be retrieved from the function’s attribute. See Generic functions for more. Changed in version 3.12: Type parameter lists are new in Python 3.12. When one or more parameters have the form parameter expression, the function is said to have “default parameter values.” For a parameter with a default value, the corresponding argument may be omitted from a call, in which case the parameter’s default value is substituted. If a parameter has a default value, all following parameters up until the “ ” must also have a default value — this is a syntactic restriction that is not expressed by the grammar. Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter value is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default parameter value is in effect modified. This is generally not what was intended. A way around this is to use as the default, and explicitly test for it in the body of the function, e.g.: Function call semantics are described in more detail in section Calls. A function call always assigns values to all parameters mentioned in the parameter list, either from positional arguments, from keyword arguments, or from default values. If the form “ ” is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple. If the form “ ” is present, it is initialized to a new ordered mapping receiving any excess keyword arguments, defaulting to a new empty mapping of the same type. Parameters after “ ” or “ ” are keyword-only parameters and may only be passed by keyword arguments. Parameters before “ ” are positional-only parameters and may only be passed by positional arguments. Changed in version 3.8: The function parameter syntax may be used to indicate positional-only parameters. See PEP 570 for details. Parameters may have an annotation of the form “ ” following the parameter name. Any parameter may have an annotation, even those of the form or . (As a special case, parameters of the form may have an annotation “ ”.) Functions may have “return” annotation of the form “ ” after the parameter list. These annotations can be any valid Python expression. The presence of annotations does not change the semantics of a function. The annotation values are available as values of a dictionary keyed by the parameters’ names in the attribute of the function object. If the import from is used, annotations are preserved as strings at runtime which enables postponed evaluation. Otherwise, they are evaluated when the function definition is executed. In this case annotations may be evaluated in a different order than they appear in the source code. Changed in version 3.11: Parameters of the form “ ” may have an annotation “ ”. See PEP 646. It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions. This uses lambda expressions, described in section Lambdas. Note that the lambda expression is merely a shorthand for a simplified function definition; a function defined in a “ ” statement can be passed around or assigned to another name just like a function defined by a lambda expression. The “ ” form is actually more powerful since it allows the execution of multiple statements and annotations. Programmer’s note: Functions are first-class objects. A “ ” statement executed inside a function definition defines a local function that can be returned or passed around. Free variables used in the nested function can access the local variables of the function containing the def. See section Naming and binding for details. Support for forward references within annotations by preserving annotations in a string form at runtime instead of eager evaluation. Function and method decorators were introduced. Class decorators were introduced in PEP 3129.\n\nA class definition is an executable statement. The inheritance list usually gives a list of base classes (see Metaclasses for more advanced uses), so each item in the list should evaluate to a class object which allows subclassing. Classes without an inheritance list inherit, by default, from the base class ; hence, The class’s suite is then executed in a new execution frame (see Naming and binding), using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary. The class name is bound to this class object in the original local namespace. The order in which attributes are defined in the class body is preserved in the new class’s . Note that this is reliable only right after the class is created and only for classes that were defined using the definition syntax. Class creation can be customized heavily using metaclasses. Classes can also be decorated: just like when decorating functions, The evaluation rules for the decorator expressions are the same as for function decorators. The result is then bound to the class name. Changed in version 3.9: Classes may be decorated with any valid . Previously, the grammar was much more restrictive; see PEP 614 for details. A list of type parameters may be given in square brackets immediately after the class’s name. This indicates to static type checkers that the class is generic. At runtime, the type parameters can be retrieved from the class’s attribute. See Generic classes for more. Changed in version 3.12: Type parameter lists are new in Python 3.12. Programmer’s note: Variables defined in the class definition are class attributes; they are shared by instances. Instance attributes can be set in a method with . Both class and instance attributes are accessible through the notation “ ”, and an instance attribute hides a class attribute with the same name when accessed in this way. Class attributes can be used as defaults for instance attributes, but using mutable values there can lead to unexpected results. Descriptors can be used to create instance variables with different implementation details. The proposal that changed the declaration of metaclasses to the current syntax, and the semantics for how classes with metaclasses are constructed. The proposal that added class decorators. Function and method decorators were introduced in PEP 318.\n\nChanged in version 3.13: Support for default values was added (see PEP 696). Functions (including coroutines), classes and type aliases may contain a type parameter list: Semantically, this indicates that the function, class, or type alias is generic over a type variable. This information is primarily used by static type checkers, and at runtime, generic objects behave much like their non-generic counterparts. Type parameters are declared in square brackets ( ) immediately after the name of the function, class, or type alias. The type parameters are accessible within the scope of the generic object, but not elsewhere. Thus, after a declaration , the name is not available in the module scope. Below, the semantics of generic objects are described with more precision. The scope of type parameters is modeled with a special function (technically, an annotation scope) that wraps the creation of the generic object. Generic functions, classes, and type aliases have a attribute listing their type parameters. Type parameters come in three kinds:\n• None , introduced by a plain name (e.g., ). Semantically, this represents a single type to a type checker.\n• None , introduced by a name prefixed with a single asterisk (e.g., ). Semantically, this stands for a tuple of any number of types.\n• None , introduced by a name prefixed with two asterisks (e.g., ). Semantically, this stands for the parameters of a callable. declarations can define bounds and constraints with a colon ( ) followed by an expression. A single expression after the colon indicates a bound (e.g. ). Semantically, this means that the can only represent types that are a subtype of this bound. A parenthesized tuple of expressions after the colon indicates a set of constraints (e.g. ). Each member of the tuple should be a type (again, this is not enforced at runtime). Constrained type variables can only take on one of the types in the list of constraints. For s declared using the type parameter list syntax, the bound and constraints are not evaluated when the generic object is created, but only when the value is explicitly accessed through the attributes and . To accomplish this, the bounds or constraints are evaluated in a separate annotation scope. s and s cannot have bounds or constraints. All three flavors of type parameters can also have a default value, which is used when the type parameter is not explicitly provided. This is added by appending a single equals sign ( ) followed by an expression. Like the bounds and constraints of type variables, the default value is not evaluated when the object is created, but only when the type parameter’s attribute is accessed. To this end, the default value is evaluated in a separate annotation scope. If no default value is specified for a type parameter, the attribute is set to the special sentinel object . The following example indicates the full set of allowed type parameter declarations: Generic functions are declared as follows: This syntax is equivalent to: Here indicates an annotation scope, which is not actually bound to any name at runtime. (One other liberty is taken in the translation: the syntax does not go through attribute access on the module, but creates an instance of directly.) The annotations of generic functions are evaluated within the annotation scope used for declaring the type parameters, but the function’s defaults and decorators are not. The following example illustrates the scoping rules for these cases, as well as for additional flavors of type parameters: Except for the lazy evaluation of the bound, this is equivalent to: # In reality, BOUND_OF_T() is evaluated only on demand. The capitalized names like are not actually bound at runtime. Generic classes are declared as follows: This syntax is equivalent to: Here again (not a real keyword) indicates an annotation scope, and the name is not actually bound at runtime. Generic classes implicitly inherit from . The base classes and keyword arguments of generic classes are evaluated within the type scope for the type parameters, and decorators are evaluated outside that scope. This is illustrated by this example: The statement can also be used to create a generic type alias: Except for the lazy evaluation of the value, this is equivalent to: # In reality, the value is lazily evaluated Here, (not a real keyword) indicates an annotation scope. The capitalized names like are not actually bound at runtime."
    },
    {
        "link": "https://walker-data.com/geog30323/03-functions-and-iteration.html",
        "document": "Congratulations on completing your first Python assignment! You’ll be progressively building on those core skills throughout the semester.\n\nIn this week’s notebook, you are first going to learn about functions. Functions are in some ways the bread-and-butter of Python programming. They make code re-usable, as they allow you to apply your code in other contexts and circumstances. You can think about functions this way: while variables store elements of your code (e.g. numbers, strings, lists), functions can store entire chunks of your code, which can in turn be re-used as necessary.\n\nFunctions include a definition and parameters, and are specified with as follows:\n\nThe command allows you to introduce a function definition. You then specify the parameters within parentheses following the function name, which are like variables that operate within your function. A colon ( ) then follows the parentheses, and the contents of the function are found beginning on the next line as an indented code block (more on indentation soon).\n\nAfter you’ve defined the function, it can be called by supplying arguments to the parameters you’ve defined, again within parentheses. For example:\n\nSo how does this all work? Let’s try it out!\n\nAt a very basic level, you can define a function without parameters - an empty function. This function will return whatever you’ve specified after it is called.\n\nNow, we call the function:\n\nNotice what happened when we called our function. As the function has no parameters, it will always give us back 5. Naturally, you’re going to want your functions to get more complicated than this - which is what parameters are for. Let’s try out a function that has a parameter and performs a basic mathematical operation.\n\nThe function itself is fairly straightforward. Our new function, , takes a number, which we are calling . It divides by two, and then prints the result for us. By adding a parameter, however, our function is now re-usable. Let’s try it out:\n\nYou may have noticed that the statements that follow the function definitions above are indented. Python code obeys whitespace for code organization. In many languages, functions, loops, and conditional logic (which we’ll get to next week), etc. are organized with curly braces, like the equivalent R code below: The R code, like in many languages, is organized in relation to the position of the curly braces, not the positioning of the code itself per se. In Python, curly braces are not used in this capacity. Instead, code is organized by indentation and whitespace. Within a function definition, for example, the code to be executed by the function call should be indented with four spaces beneath the line that contains the statement. In many Python IDEs and the IPython Notebook, the software will already know this and indent your code accordingly. In addition, the Tab key is set to be equivalent to the four spaces in most of these software packages as well. Without proper indentation, however, your code will not run correctly. : expected an indented block after function definition on line 1\n\nLater in the semester, we’ll get started using external libraries to do our work, which have many pre-built functions for accomplishing data analysis tasks. Many of these functions are very flexible - which means they have a lot of parameters! It turn, it can be helpful to keep your code organized when you are working with multiple parameters in a function. There are a couple ways to supply multiple arguments to a function in Python:\n• None In the order they are specified in the function definition;\n• None As named arguments, in which both the parameter name and the argument are invoked. I’ll explain this further. Let’s define a function, , that takes two numbers and will subtract the second number from the first. Now, we call the function by supplying two arguments to it: We could get the same result by supplying named arguments to the function, which take the form of : Flipping the order of the arguments will give us a different result unless we name the arguments accordingly. Take a look: Be careful when mixing named and unnamed arguments, however. When arguments are unnamed, Python assumes that you are supplying them in the order of the corresponding parameters in the function definition. As such, you can mix named and unnamed arguments, but unnamed arguments cannot follow named arguments in a function call.\n\nYou’ve already learned how to use comments to document your code with the operator, like this: # I just commented out this line! Comments are generally best used for small descriptive statements about your code, or notes to yourself regarding something you’d like to remember. More formal documentation of your code - e.g. what you functions are supposed to do - are best handled through docstrings. Docstrings are enclosed in triple quotes ( ), and can go beneath the function definition to explain its components. Let’s try using a docstring to explain, in basic terms, the contents of our function. Subtract one number from another. x: The number you would like to subtract a quantity from (the minuend). y: The quantity you would like to subtract from x (the subtrahend). You’ve now created a new function, with associated help documentation. To view the documentation, you can use the built-in function to print the docstring, or type the function name followed by a question mark to pop up the documentation at the bottom of the screen. Try it out! Help on function subtract in module __main__: subtract(x, y) Subtract one number from another. Parameters: ----------- x: The number you would like to subtract a quantity from (the minuend). y: The quantity you would like to subtract from x (the subtrahend). # Create a new function, \"multiply\", that multiplies two numbers together. # Write a docstring in the function definition that describes what the function does, # and explains the parameters to the user. # Run your function and call it to test it out.\n\nThe above functions we’ve written perform the same operations for any input values that are passed to them. When writing programs, however, you’ll often have to design them to be flexible to user input where outcomes may vary based on what users supply to the program. In regards to data analysis, you might want to produce a particular type of chart if the data are structured a certain way, which wouldn’t work in another scenario. You can build this type of logic into your programs with conditional statements. Before we get into this, however, I want to introduce booleans in Python. You may have heard this term before in other classes. Booleans in Python are the values and ; they can be used to evaluate, understandably, if a condition is true or not. For example: In the above lines of code, we used basic mathematical operators to see if conditions are true or false. When we asked Python if 3 is greater than 2, it told us it was True; when we asked it if 2 is greater than 3, it said False. Such true/false logic can be used with conditional statements in your code. To do this, you’ll often use conditional operators, which you’ll be familiar with from basic mathematics, possibly with a couple exceptions. Conditional operators in Python are as follows:\n• None Greater than or equal to As humans, we use conditional logic all of the time without really thinking about it. For example, if I am hungry, I’ll probably go eat something; otherwise, I won’t. Such logic can be expressed in Python as a series of , (which means else if), and statements. Let’s try to express this now in code in basic terms. This is made-up code, so we don’t need to understand everything, but here are the basics of it. We define a function, , that measures the biological/psychological properties that govern hunger reflexes in the human body. We say, hypothetically, that a hunger index value encapsulating these properties that exceeds 100 means that a person is hungry; in turn, the function returns . Otherwise, it returns . We can then pass a variable , which represents my hunger index, to the function. The function then checks to see if I am hungry, and returns if I am, and otherwise. These results can then be embedded in other workflows, in which you program Python to perform different tasks depending on the function results. For example: As you can see above, this can be simplified in Python as the code checks to see if the returned value is . If I am hungry, the code calls an unseen function telling me to go eat; otherwise, it tells me to stay put with an unseen function. Simple enough, right? Not quite. I’m hungry right now, but I’m not currently eating. Why is that the case? Well… I have to get this assignment written for you! While I am hungry, my level of hunger is not so debilitating that I am unable to work, and I know that finishing my work is a higher priority than eating at the moment. In reality, there are countless conditions that influence whether we eat or not beyond simply how hungry we are. For example - is there food accessible? Are you in a place where it is socially acceptable to eat? Perhaps you are at a party where pizza is available - you aren’t hungry, but you eat it anyway? Your brain processes all of this conditional logic at once as you make decisions, so we aren’t always used to thinking explicitly about conditionals in such discrete ways. However, to get a computer to understand this, you have to make it explicit in your code! The function we defined above used conditional logic, telling Python to return or depending on the value of the hunger index. Note that the statement starts on a new indented line of code beneath the function definition, and itself is followed by a colon; the code associated with the statement then follows on another, indented line of code. The same goes for the statement beneath it. You should be getting a sense now of style rules in Python, and the importance of whitespace for code organization, which applies to conditional statements as well. Now I’d like you to try to replicate this yourself! Define a function called that checks to see if a number is greater than 2 or not. Call the function.\n\nIn programming, you will often want to do an operation multiple times, or carry out some process over a list of values that you’ve created. To do this, you will frequently turn to iterators. The most commonly used iterators in Python are and . A loop carries out an action, or set of actions, for every element that you tell it to. Let’s give it a try in very simple terms. I’ve created a list of teams in the Big 12 below; we’ll loop through this list with and concatenate another string to each element. # You can read this here as \"for every team in the Big 12.... # ... print the name of the team along with \"are in the Big 12.\" TCU Horned Frogs are in the Big 12. Baylor Bears are in the Big 12. Oklahoma Sooners are in the Big 12. Oklahoma State Cowboys are in the Big 12. Texas Longhorns are in the Big 12. Texas Tech Red Raiders are in the Big 12. West Virginia Mountaineers are in the Big 12. Kansas Jayhawks are in the Big 12. Kansas State Wildcats are in the Big 12. Iowa State Cyclones are in the Big 12. A couple notes about the above code. Notice that I’m using as a temporary variable that will successively store each value of the list as we loop through it. This variable, , takes on each value of the list in turn; and presently stores the last value of the list. As such, this is how the loop works. tells Python to evaluate every element of the list ; these elements will be represented by the variable . The loop then walks through the list and prints the specified text for every element in the list. This loop is equivalent, then, to: \"TCU Horned Frogs are in the Big 12\" \"Baylor Bears are in the Big 12\" \"Oklahoma Sooners are in the Big 12\" but you don’t really want to do that manually, especially when you might have thousands of strings to evaluate. In turn, the loop does the work for you, which is one of the main benefits of programming. Also, I’d like you to notice the structure of the loop. Like functions, loops obey whitespace rules for code organization, and will fail if your code is not properly indented. The first line of the loop - in this case - is not indented, and is followed by a colon. Everything else contained in the loop is found in an indented block on the line(s) following the loop call. As with functions, your loop will fail without proper indentation. : expected an indented block after 'for' statement on line 1 Now let’s say you want to create a new list of the “…are in the Big 12” elements. There are a couple ways to do this. In the first, you define an empty list object, then populate the list with the for loop and the method, as shown below. # The empty brackets designate an empty list, which you'll fill up with the loop. ['TCU Horned Frogs are in the Big 12.', 'Baylor Bears are in the Big 12.', 'Oklahoma Sooners are in the Big 12.', 'Oklahoma State Cowboys are in the Big 12.', 'Texas Longhorns are in the Big 12.', 'Texas Tech Red Raiders are in the Big 12.', 'West Virginia Mountaineers are in the Big 12.', 'Kansas Jayhawks are in the Big 12.', 'Kansas State Wildcats are in the Big 12.', 'Iowa State Cyclones are in the Big 12.'] You can also do the same thing with something called list comprehension. List comprehension allows for the creation of a new list with one line of code. In this case, the loop is embedded within the statement you make. Below is an example: ['TCU Horned Frogs are in the Big 12.', 'Baylor Bears are in the Big 12.', 'Oklahoma Sooners are in the Big 12.', 'Oklahoma State Cowboys are in the Big 12.', 'Texas Longhorns are in the Big 12.', 'Texas Tech Red Raiders are in the Big 12.', 'West Virginia Mountaineers are in the Big 12.', 'Kansas Jayhawks are in the Big 12.', 'Kansas State Wildcats are in the Big 12.', 'Iowa State Cyclones are in the Big 12.'] You can use methods and functions in your list comprehension as well, as in the example below: Loops also work for strings - though in this case the loop will iterate through each character contained in your string. An example: The index of T is 0 The index of e is 1 The index of x is 2 The index of a is 3 The index of s is 4 The index of is 5 The index of C is 6 The index of h is 7 The index of r is 8 The index of i is 9 The index of s is 10 The index of t is 11 The index of i is 12 The index of a is 13 The index of n is 14 The index of is 15 The index of U is 16 The index of n is 17 The index of i is 18 The index of v is 19 The index of e is 20 The index of r is 21 The index of s is 22 The index of i is 23 The index of t is 24 The index of y is 25 is not the only loop you’ll come across in Python. You can also specify a loop, which will run a loop until a given condition is satisfied. I’ll give you an example below. Let’s say you only want to return the first five elements of your list. While you could do this with indexing (which is simpler), let’s try the loop instead. Have a look at what we did. We created an empty list, and set a new variable, , to 0. We then looped through the elements of the list index by index, adding 1 to with each run of the loop, and then stopping the code when became equal to 5. In turn, we got back the elements of the list indexed 0 to 4, which are the first five elements. Be careful with while loops, however. If you don’t specify them correctly, you can get stuck in an infinite loop, which will not stop! For example, if we had not continued to add 1 to , the loop would have never stopped and would have kept iterating through the list. This can cause your computer to lock up, as it is infinitely trying to carry out an operation! I’ve been there a few times…"
    },
    {
        "link": "https://stackoverflow.com/questions/26695649/creating-if-else-statements-dependent-on-user-input",
        "document": "I'm trying to create a simple script that will will ask a question to which the user will input an answer (Or a prompt with selectable answers could appear?), and the program would output a response based on the input.\n\nFor example, if I were to say\n\nI would have something along the lines of\n\nI'm probably going about this the wrong way. Please be as descriptive as possible as this is a learning exercise for me. Thanks in advance!"
    },
    {
        "link": "https://accuweb.cloud/resource/articles/explain-loops-and-conditional-statements-in-python",
        "document": "Python, a powerful and versatile language, offers two essential tools for programmers: conditional statements and loops. These tools allow you to control the flow of your program, making it dynamic and responsive to different situations. This web tutorial will guide you through the fundamentals of using conditional statements and loops in Python, empowering you to write more efficient and effective code.\n\nWhat are Conditional Statements and Loops?\n\nConditional statements, sometimes called branching statements, let you run different parts of your code depending on whether certain conditions are true or false. For instance, you can use an if statement to figure out if a number is even or odd and then display a different message based on the answer.\n\nOn the other hand, loops allow you to repeat a block of code until a particular condition is satisfied. This is handy when you need to go through a list of items or process data until everything has been handled.\n\nIn Python, there are two main types of loops: for loops and while loops. For loops are great for going through a sequence of items like a list or a string. Meanwhile, while loops are useful when you want to keep running a block of code until a specific condition is fulfilled.\n\nWhether you’re a beginner or an experienced Python programmer, understanding how to use conditional statements and loops is crucial. They help you write more powerful and efficient code by giving you control over how your program behaves in different situations.\n\nConditional statements allow your program to make decisions based on specific conditions. The most common types of conditional statements in Python are:\n\n1) if statement: This statement executes a block of code only if a given condition is true. The basic syntax is:\n\n2) if-else statement: This statement allows you to execute different blocks of code based on whether a condition is true or false. The syntax is:\n\n3) if-elif-else statement: This statement allows you to handle multiple conditions. The syntax is:\n\nLoop statements allow your program to repeat a block of code multiple times. The two most commonly used loop statements are:\n\nfor loop: This loop iterates over a sequence of elements and executes a block of code for each element. The syntax is:\n\nwhile loop: This loop continues to execute a block of code as long as a given condition is true. The syntax is:\n\nIn Python, entry control loops rely on checking a condition before executing the loop body. If the condition evaluates to True, the loop body runs. This means the loop might not even execute if the condition is initially False.\n\nfor loop: Iterates through a sequence of elements, executing the loop body for each element.\n\nif statement: Can be used to create an entry control loop by checking a condition and running code only if it’s True.\n\nExit control loops in Python check a condition after executing the loop body. The loop continues to iterate until the condition becomes False. This guarantees the loop body runs at least once, even if the condition is initially False.\n\nwhile loop: Executes the loop body repeatedly until the condition becomes False.\n\ndo-while loop: ( ) Similar to while loop but guarantees the loop body executes at least once.\n\nYou need to iterate through a set number of times or a known sequence.\n\n The condition determines whether to execute the loop body at all.\n\nYou want to continue iterating until a specific condition becomes False.\n\n The loop body needs to execute at least once.\n\nBest Practices for Conditional and Loop Statements\n\nUse descriptive variable names and comments: This will make your code easier to understand and maintain.\n\n Break down complex logic into smaller functions: This will improve the readability and maintainability of your code.\n\n Use else and elif clauses appropriately: This will ensure that your program behaves as expected for different conditions.\n\n Use break and continue statements: These control the flow within the loop body.\n\n Avoid infinite loops: Always ensure that your loop will eventually terminate or it will continue running forever.\n\n Practice and experiment: Try different approaches to solidify your understanding.\n\nPython, a powerful and versatile language, offers two essential tools for programmers: conditional statements and loops. These tools allow you to control the flow of your program, making it dynamic and responsive to different situations. This web tutorial will guide you through the fundamentals of using conditional statements and loops in Python, empowering you to write more efficient and effective code."
    },
    {
        "link": "https://siddp6.medium.com/conditionals-and-loops-python-programming-language-part-4-6-b5b1a8c9521e",
        "document": "Conditional statements are used to make decisions based on certain conditions. They execute different blocks of code depending on whether a condition is true or false. In Python, conditional statements are created using keywords such as , , and (short for \"else if\").\n\nThe statement is the most basic type of conditional statement. It allows us to execute a block of code only if a given condition is true. Here is the syntax:\n\nLet’s consider an example where we check if a number is positive:\n\nThe statement extends the statement by providing an alternative block of code to execute when the condition is false. The syntax is as follows:\n\nLet’s modify the previous example to include the statement:\n\nThe statement allows us to check multiple conditions and execute different blocks of code accordingly. The keyword is short for \"else if\" and can be used multiple times. Here is the syntax:\n\nLet’s consider an example where we determine the grade based on the percentage obtained:\n\nPython allows nesting conditional statements within each other. This means that we can have an statement inside another statement. Here is an example:\n\nConditional statements rely on comparison operators to evaluate conditions. Here are the commonly used comparison operators in Python:\n\nLogical operators are used to combine multiple conditions in conditional statements. The three logical operators in Python are:"
    },
    {
        "link": "https://stackoverflow.com/questions/67851417/best-practices-on-python-conditionals",
        "document": "Closed. This question is . This question is opinion-based . It is not currently accepting answers. Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\n\nWhen it comes to best practices on conditionals, which of the following examples is recommended?"
    },
    {
        "link": "https://geeksforgeeks.org/loops-in-python",
        "document": "Loops in Python are used to repeat actions efficiently. The main types are For loops (counting through items) and While loops (based on conditions). Additionally, Nested Loops allow looping within loops for more complex tasks. While all the ways provide similar basic functionality, they differ in their syntax and condition-checking time. In this article, we will look at Python loops and understand their working with the help of examples.\n\nIn Python, a while loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nAll the statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\nExample of Python While Loop:\n\nUsing else statement with While Loop in Python\n\nElse clause is only executed when our while condition becomes false. If we break out of the loop or if an exception is raised then it won’t be executed.\n\nSyntax of While Loop with else statement:\n\nThe code prints “Hello Geek” three times using a ‘while’ loop and then after the loop it prints “In Else Block” because there is an “else” block associated with the ‘while’ loop.\n\nIf we want a block of code to execute infinite number of times then we can use the while loop in Python to do so.\n\nThe code given below uses a ‘while’ loop with the condition (count == 0) and this loop will only run as long as count is equal to 0. Since count is initially set to 0, the loop will execute indefinitely because the condition is always true.\n\nNote: It is suggested not to use this type of loop as it is a never-ending infinite loop where the condition is always true and we have to forcefully terminate the compiler.\n\nFor loops are used for sequential traversal. For example: traversing a list or string or array etc. In Python, there is “for in” loop which is similar to foreach loop in other languages. Let us learn how to use for loops in Python for sequential traversals with examples.\n\nExplanation: This code prints the numbers from 0 to 3 (inclusive) using a for loop that iterates over a range from 0 to n-1 (where n = 4).\n\nExample with List, Tuple, String, and Dictionary Iteration Using for Loops in Python\n\nWe can use for loop to iterate lists, tuples, strings and dictionaries in Python.\n\nIterating by the Index of Sequences\n\nWe can also use the index of elements in the sequence to iterate. The key idea is to first calculate the length of the list and in iterate over the sequence within the range of this length.\n\nExplanation: This code iterates through each element of the list using its index and prints each element one by one. The range(len(list)) generates indices from 0 to the length of the list minus 1.\n\nUsing else Statement with for Loop in Python\n\nWe can also combine else statement with for loop like in while loop. But as there is no condition in for loop based on which the execution will terminate so the else block will be executed immediately after for block finishes execution.\n\nExplanation: The code iterates through the list and prints each element. After the loop ends it prints “Inside Else Block” as the else block executes when the loop completes without a break.\n\nPython programming language allows to use one loop inside another loop which is called nested loop. Following section shows few examples to illustrate the concept.\n\nThe syntax for a nested while loop statement in the Python programming language is as follows:\n\nA final note on loop nesting is that we can put any type of loop inside of any other type of loops in Python. For example, a for loop can be inside a while loop or vice versa.\n\nExplanation: In the above code we use nested loops to print the value of i multiple times in each row, where the number of times it prints i increases with each iteration of the outer loop. The print() function prints the value of i and moves to the next line after each row.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nThe continue statement in Python returns the control to the beginning of the loop.\n\nExplanation: The continue statement is used to skip the current iteration of a loop and move to the next iteration. It is useful when we want to bypass certain conditions without terminating the loop.\n\nThe break statement in Python brings control out of the loop.\n\nExplanation: break statement is used to exit the loop prematurely when a specified condition is met. In this example, the loop breaks when the letter is either ‘e’ or ‘s’, stopping further iteration.\n\nWe use pass statement in Python to write empty loops. Pass is also used for empty control statements, functions and classes.\n\nExplanation: In this example, the loop iterates over each letter in ‘geeksforgeeks’ but doesn’t perform any operation, and after the loop finishes, the last letter (‘s’) is printed.\n\nHow for loop works internally in Python?\n\nBefore proceeding to this section, we should have a prior understanding of Python Iterators.\n\nFirstly, lets see how a simple for loops in Python looks like.\n\nExample: This Python code iterates through a list called fruits, containing “apple”, “orange” and “kiwi.” It prints each fruit name on a separate line, displaying them in the order they appear in the list.\n\nThis code iterates over each item in the fruits list and prints the item (fruit) on each iteration and the output will display each fruit on a new line.\n\nThis Python code manually iterates through a list of fruits using an iterator. It prints each fruit’s name one by one and stops when there are no more items in the list.\n\nWe can see that under the hood we are calling iter() and next() method.\n• None Difference between for loop and while loop in Python\n• None Use for Loop That Loops Over a Sequence in Python\n\nWhich loop is faster in Python?\n\nWhy is Python slow in loops?\n\nHow many loops are used in Python?\n\nIs for loop bad in Python?"
    },
    {
        "link": "https://shape.host/resources/an-in-depth-guide-to-for-and-while-loops-in-python",
        "document": "‍Python is a versatile programming language that offers two types of loop statements: the loop and the loop. These loops are essential for automating repetitive tasks and iterating through collections of data. In this comprehensive guide, we will explore the features, use cases, and best practices for both and loops in Python. Whether you’re a beginner or an experienced Python developer, this article will equip you with the knowledge and skills to leverage loops effectively in your code.\n\nThe Python loop is a control flow statement that executes a specific block of code a certain number of times. It is ideal for situations where the number of iterations is known in advance. The loop consists of a header and a code block. The header contains the following components:\n• The keyword, which initiates the loop.\n• A loop variable, also known as the iterator, which is used to track the current iteration.\n• A sequence that determines the range of the loop. This can be achieved using the function or a sequential data structure such as a list, string, or dictionary.\n\nThe syntax of a loop with the function is as follows:\n\nThe function accepts up to three integer parameters: , , and . The parameter specifies the initial value of the iterator, the parameter determines the end position of the range, and the parameter indicates the increment or decrement value for each iteration. If the and parameters are omitted, they default to and respectively.\n\nLet’s consider an example to understand how the loop works with the function:\n\nIn this example, the loop iterates five times, as specified by the function. The iterator takes on the values , , , , and in each iteration. The statement displays the current value of . Once the loop completes, the message “Loop completed” is printed.\n\nIn addition to using the function, the loop can also be used to iterate through sequential data types such as lists, strings, tuples, and dictionaries. When using a sequential data structure, the length of the structure determines the range of the loop.\n\nLet’s explore how the loop can be used to iterate through a list:\n\nIn this example, the loop iterates through each item in the list. The loop variable takes on the value of each item in the list in sequential order. The statement displays the name of each city. Once the loop completes, the message “Loop completed” is printed.\n\nSimilarly, the loop can iterate through other sequential data types such as strings, tuples, and dictionaries. The loop variable takes on the value of each item in the respective data structure.\n\nBreaking Out of a For Loop\n\nIn certain situations, it may be necessary to prematurely terminate a loop based on a specific condition. This can be achieved using the statement. When the statement is encountered within the loop, the loop immediately terminates, and control flow moves to the next statement after the loop.\n\nLet’s consider an example where we use the statement to terminate a loop:\n\nIn this example, the loop should iterate from to . However, when the value of reaches , the statement is triggered, and the statement is executed. As a result, the loop terminates, and the message “Loop completed” is not printed. The output will display the values of from to , followed by the message “Breaking out of the loop.”\n\nUsing the Else Clause with For Loops\n\nPython allows the use of the clause with loops. The code within the block is executed when the loop completes all iterations without encountering a statement. This can be useful for post-loop processing or when certain conditions are met after the loop finishes.\n\nIn this example, the loop iterates five times, displaying the value of in each iteration. Once the loop completes all iterations, the message “The loop has completed successfully” is printed.\n\nThe Python loop is another control flow statement that repeatedly executes a block of code as long as a certain condition remains true. Unlike the loop, the loop is ideal for situations where the number of iterations is not known in advance. The loop consists of a header and a code block. The header contains the following components:\n• The keyword, which initiates the loop.\n• A conditional expression, which must evaluate to either or . If the expression is , the code block is executed. If it is , the loop terminates.\n• A colon ( ), which marks the end of the header and introduces the code block.\n\nThe syntax of a loop is as follows:\n\nThe conditional expression in the loop determines whether the loop should continue or terminate. As long as the expression evaluates to , the loop will keep executing. However, if the expression becomes , the loop terminates, and control flow moves to the next statement after the loop.\n\nLet’s consider an example to understand how the loop works:\n\nIn this example, the loop iterates as long as the value of the variable is less than . In each iteration, the current value of is displayed, and the variable is incremented by . Once the value of reaches , the conditional expression becomes , and the loop terminates. The message “Loop completed” is then printed.\n\nWhen working with loops, it is crucial to ensure that the conditional expression can eventually become . Failure to do so can result in an infinite loop, where the loop keeps executing indefinitely. This can lead to system freezes, crashes, or excessive resource consumption.\n\nTo prevent infinite loops, it is essential to include logic within the loop that modifies the variables used in the conditional expression. This ensures that the expression can become at some point, allowing the loop to terminate.\n\nLet’s consider an example where a guard counter is used to limit the number of iterations in a loop:\n\nIn this example, the loop repeatedly prompts the user to enter their password. If the password entered matches the predefined string, the loop terminates, and the message “Password correct” is printed. If the password is incorrect, the loop continues, and the user is informed of the mistake. The counter keeps track of the number of failed attempts, and the loop terminates after five unsuccessful attempts. Once the loop completes, the message “Loop completed” is printed.\n\nThe Else Clause with While Loops\n\nSimilar to loops, loops in Python can also utilize the clause. The code within the block is executed when the loop completes all iterations without encountering a statement.\n\nIn this example, the loop iterates as long as the value of the variable is less than . In each iteration, the value of is displayed, and the variable is incremented. Once the value of becomes , the conditional expression becomes , and the loop terminates. The message “The loop has completed successfully” is then printed.\n\nBest Practices for Using Loops in Python\n\nNow that we have covered the basics of and loops in Python, let’s explore some best practices to ensure efficient and effective loop usage in your code.\n\nWhen faced with a repetitive task, it is important to select the appropriate loop type. Use a loop when the number of iterations is known in advance or when iterating over a collection of items. On the other hand, use a loop when the number of iterations is uncertain or when a specific condition needs to be met for the loop to terminate.\n\nTo maintain code readability and efficiency, it is recommended to keep the code block within loops concise. Avoid placing complex logic or lengthy computations directly within the loop. If necessary, encapsulate such operations within functions and call them from within the loop.\n\nAvoid duplicating code within loops whenever possible. If you find yourself repeating the same lines of code, consider refactoring them into separate functions or methods. By encapsulating reusable code, you improve code maintainability and minimize the risk of introducing bugs.\n\nChoose descriptive variable names for loop iterators and other loop-related variables. This enhances code readability and makes it easier for other developers (including your future self) to understand the purpose of the loop.\n\nIn situations where performance is critical, it is important to write efficient loops. Minimize unnecessary computations within the loop and aim for algorithms with optimal time and space complexity. Additionally, consider using built-in Python functions and libraries that offer optimized implementations for common loop operations.\n\nWhile the statement can be useful for prematurely terminating a loop, it should be used sparingly. Overuse of statements can make code harder to understand and maintain. Whenever possible, consider alternative approaches that avoid the need for statements.\n\nBefore deploying code that includes loops, thoroughly test and debug your code. Pay close attention to edge cases, boundary conditions, and situations where the loop may not execute as expected. Use debugging tools and techniques to identify and resolve any issues before they impact your application.\n\nIn this comprehensive guide, we explored the features, use cases, and best practices for and loops in Python. We learned how to use the loop to iterate over a range of values or sequential data types. We also delved into the loop, which executes a block of code as long as a certain condition remains true. By following best practices, such as choosing the appropriate loop type, keeping the code concise, and using meaningful variable names, you can effectively leverage loops in your Python code.\n\nRemember, loops are powerful tools for automating repetitive tasks, iterating through collections, and solving complex problems. With a solid understanding of and loops, you can write efficient and maintainable code that takes full advantage of Python’s capabilities.\n\nAt Shape.host, we offer reliable and secure cloud hosting solutions, including Linux SSD VPS services. Our expert team is dedicated to providing efficient and scalable hosting solutions to empower businesses. Whether you’re a beginner or an experienced developer, our services are designed to meet your specific needs. Visit Shape.host to learn more about our hosting services and start scaling your applications today!"
    }
]