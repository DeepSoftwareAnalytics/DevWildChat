[
    {
        "link": "https://stackoverflow.com/questions/6925011/multiple-selection-qtreewidget",
        "document": "Does anyone know if its possible to select multiple items on a QTreeWidget and how to go about enabling the multiple selection?\n\nAll the items I want to be selectable are top level QTreeWidgetItems and all their children are set to be disabled (i.e QTreeWidgetItem.setDisabled(True) )"
    },
    {
        "link": "https://stackoverflow.com/questions/5075741/setting-multiple-selection-in-qtreeview",
        "document": "You can use the tree view's item selection model (treeView->selectionMode(), of type QItemSelectionModel). It has a signal selectionChanged() you can connect to to receive tree view selection changes and apply them to the GL view. When receiving selection events from the GL view, you can use to propagate them to the tree view.\n\nTo enable multiselection on your treeview, call ."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QAbstractItemView.html",
        "document": "The QAbstractItemView class provides the basic functionality for item view classes. More …\n\nclass is the base class for every standard view that uses a . is an abstract class and cannot itself be instantiated. It provides a standard interface for interoperating with models through the signals and slots mechanism, enabling subclasses to be kept up-to-date with changes to their models. This class provides standard support for keyboard and mouse navigation, viewport scrolling, item editing, and selections. The keyboard navigation implements this functionality: Changes the current item and selects it. Changes the current item but does not select it. Changes the current item and selects it. The previously selected item(s) is not deselected. Changes the current item to the next/previous item. Selects the first/last item in the model. Scrolls the rows shown up/down by the number of visible rows in the view. Selects all items in the model. Note that the above table assumes that the allows the operations. For instance, you cannot select items if the selection mode is . The class is one of the Model/View Classes and is part of Qt’s model/view framework . The view classes that inherit only need to implement their own view-specific functionality, such as drawing items, returning the geometry of items, finding items, etc. provides common slots such as and . Many protected slots are also provided, including , , , , and . The root item is returned by , and the current item by . To make sure that an item is visible use . Some of ‘s functions are concerned with scrolling, for example and . To set the range of the scroll bars, you can, for example, reimplement the view’s function: Note that the range is not updated until the widget is shown. Several other functions are concerned with selection control; for example , and . This class provides a default selection model to work with ( ), but this can be replaced by using with an instance of . For complete control over the display and editing of items you can specify a delegate with . provides a lot of protected functions. Some are concerned with editing, for example, , and , whilst others are keyboard and mouse event handlers. If you inherit and intend to update the contents of the viewport, you should use viewport-> instead of as all painting operations take place on the viewport."
    },
    {
        "link": "https://doc.qt.io/qt-6/qabstractitemview.html",
        "document": "The QAbstractItemView class provides the basic functionality for item view classes. More...\n\nNote: If you inherit QAbstractItemView and intend to update the contents of the viewport, you should use viewport-> update () instead of update () as all painting operations take place on the viewport.\n\nQAbstractItemView provides a lot of protected functions. Some are concerned with editing, for example, edit (), and commitData (), whilst others are keyboard and mouse event handlers.\n\nFor complete control over the display and editing of items you can specify a delegate with setItemDelegate ().\n\nSeveral other functions are concerned with selection control; for example setSelectionMode (), and setSelectionBehavior (). This class provides a default selection model to work with ( selectionModel ()), but this can be replaced by using setSelectionModel () with an instance of QItemSelectionModel .\n\nNote that the range is not updated until the widget is shown.\n\nSome of QAbstractItemView's functions are concerned with scrolling, for example setHorizontalScrollMode () and setVerticalScrollMode (). To set the range of the scroll bars, you can, for example, reimplement the view's resizeEvent () function:\n\nThe root item is returned by rootIndex (), and the current item by currentIndex (). To make sure that an item is visible use scrollTo ().\n\nQAbstractItemView provides common slots such as edit () and setCurrentIndex (). Many protected slots are also provided, including dataChanged (), rowsInserted (), rowsAboutToBeRemoved (), selectionChanged (), and currentChanged ().\n\nThe view classes that inherit QAbstractItemView only need to implement their own view-specific functionality, such as drawing items, returning the geometry of items, finding items, etc.\n\nThe QAbstractItemView class is one of the Model/View Classes and is part of Qt's model/view framework .\n\nNote that the above table assumes that the selection mode allows the operations. For instance, you cannot select items if the selection mode is QAbstractItemView::NoSelection .\n\nQAbstractItemView class is the base class for every standard view that uses a QAbstractItemModel . QAbstractItemView is an abstract class and cannot itself be instantiated. It provides a standard interface for interoperating with models through the signals and slots mechanism, enabling subclasses to be kept up-to-date with changes to their models. This class provides standard support for keyboard and mouse navigation, viewport scrolling, item editing, and selections. The keyboard navigation implements this functionality:\n\nSee also View Classes, Model/View Programming, and QAbstractItemModel.\n\nDescribes the different states the view can be in. This is usually only interesting when reimplementing your own view.\n\nThe most commonly used modes are SingleSelection and ExtendedSelection.\n\nThis enum indicates how the view responds to user selections:\n\nDescribes how the scrollbar should behave. When setting the scroll mode to ScrollPerPixel the single step size will adjust automatically unless it was set explicitly using setSingleStep (). The automatic adjustment can be restored by setting the single step size to -1.\n\nThe EditTriggers type is a typedef for QFlags <EditTrigger>. It stores an OR combination of EditTrigger values.\n\nThis enum indicates the position of the drop indicator in relation to the index at the current mouse position:\n\nNote that the model used needs to provide support for drag and drop operations.\n\nDescribes the various drag and drop events the view can act upon. By default the view does not support dragging or dropping ( NoDragDrop ).\n\nThis enum describes the different ways to navigate between items,\n\nThis property controls how the view scroll its contents vertically. Scrolling can be done either per pixel or per item. Its default value comes from the style via the QStyle::SH_ItemView_ScrollMode style hint.\n\nhow the view scrolls its contents in the vertical direction\n\nThe default value for all item views is Qt::ElideRight .\n\nThis property holds the position of the \"...\" in elided text.\n\nThis property holds whether item navigation with tab and backtab is enabled.\n\nThis property holds whether the drop indicator is shown when dragging items and dropping.\n\nThis property controls whether the user can select one or many items and, in many-item selections, whether the selection must be a continuous range of items.\n\nThis property holds which selection mode the view operates in\n\nThis property holds whether selections are done in terms of single items, rows or columns.\n\nThis property holds which selection behavior the view uses\n\nSetting this property when the view is visible will cause the items to be laid out again.\n\nThis property controls how the view scroll its contents horizontally. Scrolling can be done either per pixel or per item. Its default value comes from the style via the QStyle::SH_ItemView_ScrollMode style hint.\n\nhow the view scrolls its contents in the horizontal direction\n\nThis property is a selection of flags defined by EditTrigger , combined using the OR operator. The view will only initiate the editing of an item if the action performed is set in this property.\n\nThis property holds whether the view supports dragging of its own items\n\nNote: This is not intended to prevent overwriting of items. The model's implementation of flags() should do that by not returning Qt::ItemIsDropEnabled .\n\nThe default value is false , as in the QListView and QTreeView subclasses. In the QTableView subclass, on the other hand, the property has been set to true .\n\nIf its value is true , the selected data will overwrite the existing item data when dropped, while moving the data will clear the item. If its value is false , the selected data will be inserted as a new item when the data is dropped. When the data is moved, the item is removed as well.\n\nThis property holds the drag and drop event the view will act upon\n\nIf the property is not set, the drop action is CopyAction when the supported actions support CopyAction.\n\nThis property holds the drop action that will be used by default in QAbstractItemView::drag().\n\nThis property controls the size of the area at the edge of the viewport that triggers autoscrolling. The default value is 16 pixels.\n\nThis property holds the size of the area when auto scrolling is triggered\n\nThis property only works if the viewport accepts drops. Autoscroll is switched off by setting this property to false.\n\nIf this property is set to true (the default), the QAbstractItemView automatically scrolls the contents of the view if the user drags within 16 pixels of the viewport edge. If the current item changes, then the view will scroll automatically to ensure that the current item is fully visible.\n\nThis property holds whether autoscrolling in drag move events is enabled\n\nIf this property is true , the item background will be drawn using QPalette::Base and QPalette::AlternateBase ; otherwise the background will be drawn using the QPalette::Base color.\n\nThis property holds whether to draw the background using alternating colors\n\nConstructs an abstract item view with the given parent.\n\nThis signal is emitted when the item specified by index is activated by the user. How to activate items depends on the platform; e.g., by single- or double-clicking the item, or by pressing the Return or Enter key when the item is current.\n\nSee also clicked(), doubleClicked(), entered(), and pressed().\n\nDeselects all selected items. The current index will not be changed.\n\nSee also setSelection() and selectAll().\n\nThis signal is emitted when a mouse button is left-clicked. The item the mouse was clicked on is specified by index. The signal is only emitted when the index is valid.\n\nSee also activated(), doubleClicked(), entered(), and pressed().\n\nCloses the given editor, and releases it. The hint is used to specify how the view should respond to the end of the editing operation. For example, the hint may indicate that the next item in the view should be opened for editing.\n\nSee also edit() and commitData().\n\nCloses the persistent editor for the item at the given index.\n\nSee also openPersistentEditor() and isPersistentEditorOpen().\n\nCommit the data in the editor to the model.\n\nThis slot is called when a new item becomes the current item. The previous current item is specified by the previous index, and the new item by the current index.\n\nIf you want to know about changes to items see the dataChanged() signal.\n\nReturns the model index of the current item.\n\nThis slot is called when items with the given roles are changed in the model. The changed items are those from topLeft to bottomRight inclusive. If just one item is changed topLeft == bottomRight.\n\nThe roles which have been changed can either be an empty container (meaning everything has changed), or a non-empty container with the subset of roles which have changed.\n\nReturns the offset of the dirty regions in the view.\n\nIf you use scrollDirtyRegion() and implement a paintEvent() in a subclass of QAbstractItemView, you should translate the area given by the paint event with the offset returned from this function.\n\nSee also scrollDirtyRegion() and setDirtyRegion().\n\nThis signal is emitted when a mouse button is double-clicked. The item the mouse was double-clicked on is specified by index. The signal is only emitted when the index is valid.\n\nSee also clicked() and activated().\n\nThis function is called with the given event when a drag and drop operation enters the widget. If the drag is over a valid dropping place (e.g. over an item that accepts drops), the event is accepted; otherwise it is ignored.\n\nSee also dropEvent() and startDrag().\n\nThis function is called when the item being dragged leaves the view. The event describes the state of the drag and drop operation.\n\nThis function is called continuously with the given event during a drag and drop operation over the widget. It can cause the view to scroll if, for example, the user drags a selection to view's right or bottom edge. In this case, the event will be accepted; otherwise it will be ignored.\n\nSee also dropEvent() and startDrag().\n\nThis function is called with the given event when a drop event occurs over the widget. If the model accepts the even position the drop event is accepted; otherwise it is ignored.\n\nReturns the position of the drop indicator in relation to the closest item.\n\nStarts editing the item corresponding to the given index if it is editable.\n\nNote that this function does not change the current index. Since the current index defines the next and previous items to edit, users may find that keyboard navigation does not work as expected. To provide consistent navigation behavior, call setCurrentIndex() before this function with the same model index.\n\nStarts editing the item at index, creating an editor if necessary, and returns if the view's State is now EditingState; otherwise returns .\n\nThe action that caused the editing process is described by trigger, and the associated event is specified by event.\n\nEditing can be forced by specifying the trigger to be QAbstractItemView::AllEditTriggers.\n\nThis function is called when the given editor has been destroyed.\n\nThis signal is emitted when the mouse cursor enters the item specified by index. Mouse tracking needs to be enabled for this feature to work.\n\nSee also viewportEntered(), activated(), clicked(), doubleClicked(), and pressed().\n\nExecutes the scheduled layouts without waiting for the event processing to begin.\n\nThis function is called with the given event when the widget obtains the focus. By default, the event is ignored.\n\nSee also setFocus() and focusOutEvent().\n\nThis function is called with the given event when the widget loses the focus. By default, the event is ignored.\n\nSee also clearFocus() and focusInEvent().\n\nReturns the horizontal offset of the view.\n\nIn the base class this is a pure virtual function.\n\nReturns the model index of the item at the viewport coordinates point.\n\nIn the base class this is a pure virtual function.\n\nReturns the widget for the item at the given index.\n\nInitialize the option structure with the view's palette, font, state, alignments etc.\n\nThis function was introduced in Qt 6.0.\n\nReturns if the item referred to by the given index is hidden in the view, otherwise returns .\n\nHiding is a view specific feature. For example in TableView a column can be marked as hidden or a row in the TreeView.\n\nIn the base class this is a pure virtual function.\n\nReturns whether a persistent editor is open for the item at index index.\n\nSee also openPersistentEditor() and closePersistentEditor().\n\nReturns the item delegate used by this view and model. This is either one set with setItemDelegate(), or the default one.\n\nReturns the item delegate used by this view and model for the given column. You can call itemDelegate() to get a pointer to the current delegate for a given index.\n\nSee also setItemDelegateForColumn(), itemDelegateForRow(), and itemDelegate().\n\nReturns the item delegate used by this view and model for the given index.\n\nThis function was introduced in Qt 6.0.\n\nSee also setItemDelegate(), setItemDelegateForRow(), and setItemDelegateForColumn().\n\nReturns the item delegate used by this view and model for the given row, or if no delegate has been assigned. You can call itemDelegate() to get a pointer to the current delegate for a given index.\n\nSee also setItemDelegateForRow(), itemDelegateForColumn(), and setItemDelegate().\n\nThis function is called with the given event when a key event is sent to the widget. The default implementation handles basic cursor movement, e.g. Up, Down, Left, Right, Home, PageUp, and PageDown; the activated() signal is emitted if the current index is valid and the activation key is pressed (e.g. Enter or Return, depending on the platform). This function is where editing is initiated by key press, e.g. if F2 is pressed.\n\nSee also edit(), moveCursor(), keyboardSearch(), and tabKeyNavigation.\n\nMoves to and selects the item best matching the string search. If no item is found nothing happens.\n\nIn the default implementation, the search is reset if search is empty, or the time interval since the last search has exceeded QApplication::keyboardInputInterval().\n\nReturns the model that this view is presenting.\n\nThis function is called with the given event when a mouse button is double clicked inside the widget. If the double-click is on a valid item it emits the doubleClicked() signal and calls edit() on the item.\n\nThis function is called with the given event when a mouse move event is sent to the widget. If a selection is in progress and new items are moved over the selection is extended; if a drag is in progress it is continued.\n\nThis function is called with the given event when a mouse button is pressed while the cursor is inside the widget. If a valid item is pressed on it is made into the current item. This function emits the pressed() signal.\n\nThis function is called with the given event when a mouse button is released, after a mouse press event on the widget. If a user presses the mouse inside your widget and then drags the mouse to another location before releasing the mouse button, your widget receives the release event. The function will emit the clicked() signal if an item was being pressed.\n\nReturns a QModelIndex object pointing to the next object in the view, based on the given cursorAction and keyboard modifiers specified by modifiers.\n\nIn the base class this is a pure virtual function.\n\nOpens a persistent editor on the item at the given index. If no editor exists, the delegate will create a new editor.\n\nSee also closePersistentEditor() and isPersistentEditorOpen().\n\nThis signal is emitted when a mouse button is pressed. The item the mouse was pressed on is specified by index. The signal is only emitted when the index is valid.\n\nUse the QGuiApplication::mouseButtons() function to get the state of the mouse buttons.\n\nSee also activated(), clicked(), doubleClicked(), and entered().\n\nReset the internal state of the view.\n\nThis function is called with the given event when a resize event is sent to the widget.\n\nReturns the model index of the model's root item. The root item is the parent item to the view's toplevel items. The root can be invalid.\n\nThis slot is called when rows are about to be removed. The deleted rows are those under the given parent from start to end inclusive.\n\nThis slot is called when rows are inserted. The new rows are those under the given parent from start to end inclusive. The base class implementation calls fetchMore() on the model to check for more data.\n\nSchedules a layout of the items in the view to be executed when the event processing starts.\n\nEven if scheduleDelayedItemsLayout() is called multiple times before events are processed, the view will only do the layout once.\n\nPrepares the view for scrolling by (dx,dy) pixels by moving the dirty regions in the opposite direction. You only need to call this function if you are implementing a scrolling viewport in your view subclass.\n\nIf you implement scrollContentsBy() in a subclass of QAbstractItemView, call this function before you call QWidget::scroll() on the viewport. Alternatively, just call update().\n\nSee also scrollContentsBy(), dirtyRegionOffset(), and setDirtyRegion().\n\nScrolls the view if necessary to ensure that the item at index is visible. The view will try to position the item according to the given hint.\n\nIn the base class this is a pure virtual function.\n\nScrolls the view to the bottom.\n\nSee also scrollTo() and scrollToTop().\n\nScrolls the view to the top.\n\nSee also scrollTo() and scrollToBottom().\n\nSelects all items in the view. This function will use the selection behavior set on the view when selecting.\n\nSee also setSelection(), selectedIndexes(), and clearSelection().\n\nThis convenience function returns a list of all selected and non-hidden item indexes in the view. The list contains no duplicates, and is not sorted.\n\nThis slot is called when the selection is changed. The previous selection (which may be empty), is specified by deselected, and the new selection by selected.\n\nReturns the SelectionFlags to be used when updating a selection model for the specified index. The result depends on the current selectionMode(), and on the user input event event, which can be .\n\nReimplement this function to define your own selection behavior.\n\nSee also setSelectionModel() and selectedIndexes().\n\nSets the current item to be the item at index.\n\nUnless the current selection mode is NoSelection, the item is also selected. Note that this function also updates the starting position for any new selections the user performs.\n\nTo set an item as the current item without selecting it, call\n\nSee also currentIndex(), currentChanged(), and selectionMode.\n\nMarks the given region as dirty and schedules it to be updated. You only need to call this function if you are implementing your own view subclass.\n\nSee also scrollDirtyRegion() and dirtyRegionOffset().\n\nSets the given widget on the item at the given index, passing the ownership of the widget to the viewport.\n\nIf index is invalid (e.g., if you pass the root index), this function will do nothing.\n\nThe given widget's autoFillBackground property must be set to true, otherwise the widget's background will be transparent, showing both the model data and the item at the given index.\n\nThis function should only be used to display static content within the visible area corresponding to an item of data. If you want to display custom dynamic content or implement a custom editor widget, subclass QStyledItemDelegate instead.\n\nSee also indexWidget() and Delegate Classes.\n\nSets the item delegate for this view and its model to delegate. This is useful if you want complete control over the editing and display of items.\n\nAny existing delegate will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSets the given item delegate used by this view and model for the given column. All items on column will be drawn and managed by delegate instead of using the default delegate (i.e., itemDelegate()).\n\nAny existing column delegate for column will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSee also itemDelegateForColumn(), setItemDelegateForRow(), and itemDelegate().\n\nSets the given item delegate used by this view and model for the given row. All items on row will be drawn and managed by delegate instead of using the default delegate (i.e., itemDelegate()).\n\nAny existing row delegate for row will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSee also itemDelegateForRow(), setItemDelegateForColumn(), and itemDelegate().\n\nSets the model for the view to present.\n\nThis function will create and set a new selection model, replacing any model that was previously set with setSelectionModel(). However, the old selection model will not be deleted as it may be shared between several views. We recommend that you delete the old selection model if it is no longer required. This is done with the following code:\n\nIf both the old model and the old selection model do not have parents, or if their parents are long-lived objects, it may be preferable to call their deleteLater() functions to explicitly delete them.\n\nThe view does not take ownership of the model unless it is the model's parent object because the model may be shared between many different views.\n\nSee also model(), selectionModel(), and setSelectionModel().\n\nSets the root item to the item at the given index.\n\nApplies the selection flags to the items in or touched by the rectangle, rect.\n\nWhen implementing your own itemview setSelection should call selectionModel()->select(selection, flags) where selection is either an empty QModelIndex or a QItemSelection that contains all items that are contained in rect.\n\nSee also selectionCommand() and selectedIndexes().\n\nSets the current selection model to the given selectionModel.\n\nNote that, if you call setModel() after this function, the given selectionModel will be replaced by one created by the view.\n\nSee also selectionModel(), setModel(), and clearSelection().\n\nSets the item view's state to the given state.\n\nReturns the width size hint for the specified column or -1 if there is no model.\n\nThis function is used in views with a horizontal header to find the size hint for a header section based on the contents of the given column.\n\nReturns the size hint for the item with the specified index or an invalid size for invalid indexes.\n\nSee also sizeHintForRow() and sizeHintForColumn().\n\nReturns the height size hint for the specified row or -1 if there is no model.\n\nThe returned height is calculated using the size hints of the given row's items, i.e. the returned value is the maximum height among the items. Note that to control the height of a row, you must reimplement the QAbstractItemDelegate::sizeHint() function.\n\nThis function is used in views with a vertical header to find the size hint for a header section based on the contents of the given row.\n\nStarts a drag by calling drag->exec() using the given supportedActions.\n\nThis function is called with the given event when a timer event is sent to the widget.\n\nUpdates the area occupied by the given index.\n\nUpdates the geometry of the child widgets of the view.\n\nReturns the vertical offset of the view.\n\nIn the base class this is a pure virtual function.\n\nThis signal is emitted when the mouse cursor enters the viewport. Mouse tracking needs to be enabled for this feature to work.\n\nThis function is used to handle tool tips, and What's This? mode, if the given event is a QEvent::ToolTip,or a QEvent::WhatsThis. It passes all other events on to its base class viewportEvent() handler.\n\nReturns if event has been recognized and processed; otherwise, returns .\n\nReturns the rectangle on the viewport occupied by the item at index.\n\nIf your item is displayed in several areas then visualRect should return the primary area that contains index and not the complete area that index might encompasses, touch or cause drawing.\n\nIn the base class this is a pure virtual function.\n\nSee also indexAt() and visualRegionForSelection().\n\nReturns the region from the viewport of the items in the given selection.\n\nIn the base class this is a pure virtual function.\n\nSee also visualRect() and selectedIndexes()."
    },
    {
        "link": "https://qtcentre.org/threads/69328-QTreeView-Multiline-selection-using-Ctrl-and-mouse-click",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/23993895/python-pyqt-qtreeview-example-selection",
        "document": "I'm using Python 2.7 and Qt designer and I'm new to MVC: I have a View completed within Qt to give me a directory tree list, and the controller in place to run things. My question is:\n\nGiven a Qtree view, how may I obtain a directory once a dir is selected?\n\nCode snap shot is below, I suspect it's SIGNAL(..) though I'm unsure:"
    },
    {
        "link": "https://stackoverflow.com/questions/5075741/setting-multiple-selection-in-qtreeview",
        "document": "You can use the tree view's item selection model (treeView->selectionMode(), of type QItemSelectionModel). It has a signal selectionChanged() you can connect to to receive tree view selection changes and apply them to the GL view. When receiving selection events from the GL view, you can use to propagate them to the tree view.\n\nTo enable multiselection on your treeview, call ."
    },
    {
        "link": "https://forum.qt.io/topic/119210/treeview-qfilesystemmodel-how-can-i-retrieve-multi-selection-list",
        "document": "\n• Hello Guys,\n\n I have alot of queries, this is just tip of the iceberg.\n\n I create a treeview with qfilesystemmodel for folder icons visibility all worked fine.(any better approach please let me know)\n\n What i want, is there by any chance we can get multiselection list(drag select list of items from tree view), because i was successful with single toggle, below is test code index = self.qtreeview.currentIndex() for ix in self.qtreeview.selectionModel().selectedIndexes(): text = ix.data(QtCore.Qt.DisplayRole) # or ix.data() print(text) print(self.model.filePath(index)) as you can see above for loop, yes it still considers only single click item\n\n and if possible can you provide an eg.\n• @blossomsg Using instead of I have updated my previous post to display data. Note with QFileSystemModel you probably need to use role instead of default Qt.DisplayRole. see https://doc.qt.io/qt-5/qfilesystemmodel.html#Roles-enum So instead of , it will be def selectionChanged(selected, deselected): ... # Displaying Row index print('full selection: {}'.format(','.join(str(i.row()) for i in selectionModel.selectedIndexes()))) # Displaying data print('full selection text: {}'.format(','.join(str(i.data()) for i in selectionModel.selectedIndexes()))) For converting list of QModelIndex to string list: stringlist = [str(i.data()) for i in selectionModel.selectedIndexes()] # or simpler stringlist = [] for i in selectionModel.selectedIndexes(): stringlist.append(str(i.data()))\n• @Gojir4\n\n No need to apologise, it's good style. The last time I first looked at Python at Python 3.something-less-than-7/6/5??, it had the for method parameters, and the for returns, but for variables, and it barfed if you tried one. So I wrote all my code using method param types (which personally I highly recommend, but then I like C++ and not Python!), and never could do anything about variables. So that support must have arrived at some more recent Python 3 version? (Or, it's just possible that it was PyCharm which didn't yet understand it, but I thought I saw it only arrived in a recent Python 3?)\n• @JonB I did start using Python 3.6 and switched quickly to 3.8. Taking inspiration from PySide2 functions declaration it was natural for me to use this type hinting also in the code, without even knowing it was something new :). I agree with your I also use method param types, that's make code more clear and understandable, especially with custom types, and probably also because of ten years of C++ :D."
    },
    {
        "link": "https://gist.github.com/promto-c/104ba81ba888e7fbb56e6dff5dfeee86",
        "document": "You can’t perform that action at this time."
    },
    {
        "link": "https://doc.qt.io/qt-6/qabstractitemview.html",
        "document": "The QAbstractItemView class provides the basic functionality for item view classes. More...\n\nNote: If you inherit QAbstractItemView and intend to update the contents of the viewport, you should use viewport-> update () instead of update () as all painting operations take place on the viewport.\n\nQAbstractItemView provides a lot of protected functions. Some are concerned with editing, for example, edit (), and commitData (), whilst others are keyboard and mouse event handlers.\n\nFor complete control over the display and editing of items you can specify a delegate with setItemDelegate ().\n\nSeveral other functions are concerned with selection control; for example setSelectionMode (), and setSelectionBehavior (). This class provides a default selection model to work with ( selectionModel ()), but this can be replaced by using setSelectionModel () with an instance of QItemSelectionModel .\n\nNote that the range is not updated until the widget is shown.\n\nSome of QAbstractItemView's functions are concerned with scrolling, for example setHorizontalScrollMode () and setVerticalScrollMode (). To set the range of the scroll bars, you can, for example, reimplement the view's resizeEvent () function:\n\nThe root item is returned by rootIndex (), and the current item by currentIndex (). To make sure that an item is visible use scrollTo ().\n\nQAbstractItemView provides common slots such as edit () and setCurrentIndex (). Many protected slots are also provided, including dataChanged (), rowsInserted (), rowsAboutToBeRemoved (), selectionChanged (), and currentChanged ().\n\nThe view classes that inherit QAbstractItemView only need to implement their own view-specific functionality, such as drawing items, returning the geometry of items, finding items, etc.\n\nThe QAbstractItemView class is one of the Model/View Classes and is part of Qt's model/view framework .\n\nNote that the above table assumes that the selection mode allows the operations. For instance, you cannot select items if the selection mode is QAbstractItemView::NoSelection .\n\nQAbstractItemView class is the base class for every standard view that uses a QAbstractItemModel . QAbstractItemView is an abstract class and cannot itself be instantiated. It provides a standard interface for interoperating with models through the signals and slots mechanism, enabling subclasses to be kept up-to-date with changes to their models. This class provides standard support for keyboard and mouse navigation, viewport scrolling, item editing, and selections. The keyboard navigation implements this functionality:\n\nSee also View Classes, Model/View Programming, and QAbstractItemModel.\n\nDescribes the different states the view can be in. This is usually only interesting when reimplementing your own view.\n\nThe most commonly used modes are SingleSelection and ExtendedSelection.\n\nThis enum indicates how the view responds to user selections:\n\nDescribes how the scrollbar should behave. When setting the scroll mode to ScrollPerPixel the single step size will adjust automatically unless it was set explicitly using setSingleStep (). The automatic adjustment can be restored by setting the single step size to -1.\n\nThe EditTriggers type is a typedef for QFlags <EditTrigger>. It stores an OR combination of EditTrigger values.\n\nThis enum indicates the position of the drop indicator in relation to the index at the current mouse position:\n\nNote that the model used needs to provide support for drag and drop operations.\n\nDescribes the various drag and drop events the view can act upon. By default the view does not support dragging or dropping ( NoDragDrop ).\n\nThis enum describes the different ways to navigate between items,\n\nThis property controls how the view scroll its contents vertically. Scrolling can be done either per pixel or per item. Its default value comes from the style via the QStyle::SH_ItemView_ScrollMode style hint.\n\nhow the view scrolls its contents in the vertical direction\n\nThe default value for all item views is Qt::ElideRight .\n\nThis property holds the position of the \"...\" in elided text.\n\nThis property holds whether item navigation with tab and backtab is enabled.\n\nThis property holds whether the drop indicator is shown when dragging items and dropping.\n\nThis property controls whether the user can select one or many items and, in many-item selections, whether the selection must be a continuous range of items.\n\nThis property holds which selection mode the view operates in\n\nThis property holds whether selections are done in terms of single items, rows or columns.\n\nThis property holds which selection behavior the view uses\n\nSetting this property when the view is visible will cause the items to be laid out again.\n\nThis property controls how the view scroll its contents horizontally. Scrolling can be done either per pixel or per item. Its default value comes from the style via the QStyle::SH_ItemView_ScrollMode style hint.\n\nhow the view scrolls its contents in the horizontal direction\n\nThis property is a selection of flags defined by EditTrigger , combined using the OR operator. The view will only initiate the editing of an item if the action performed is set in this property.\n\nThis property holds whether the view supports dragging of its own items\n\nNote: This is not intended to prevent overwriting of items. The model's implementation of flags() should do that by not returning Qt::ItemIsDropEnabled .\n\nThe default value is false , as in the QListView and QTreeView subclasses. In the QTableView subclass, on the other hand, the property has been set to true .\n\nIf its value is true , the selected data will overwrite the existing item data when dropped, while moving the data will clear the item. If its value is false , the selected data will be inserted as a new item when the data is dropped. When the data is moved, the item is removed as well.\n\nThis property holds the drag and drop event the view will act upon\n\nIf the property is not set, the drop action is CopyAction when the supported actions support CopyAction.\n\nThis property holds the drop action that will be used by default in QAbstractItemView::drag().\n\nThis property controls the size of the area at the edge of the viewport that triggers autoscrolling. The default value is 16 pixels.\n\nThis property holds the size of the area when auto scrolling is triggered\n\nThis property only works if the viewport accepts drops. Autoscroll is switched off by setting this property to false.\n\nIf this property is set to true (the default), the QAbstractItemView automatically scrolls the contents of the view if the user drags within 16 pixels of the viewport edge. If the current item changes, then the view will scroll automatically to ensure that the current item is fully visible.\n\nThis property holds whether autoscrolling in drag move events is enabled\n\nIf this property is true , the item background will be drawn using QPalette::Base and QPalette::AlternateBase ; otherwise the background will be drawn using the QPalette::Base color.\n\nThis property holds whether to draw the background using alternating colors\n\nConstructs an abstract item view with the given parent.\n\nThis signal is emitted when the item specified by index is activated by the user. How to activate items depends on the platform; e.g., by single- or double-clicking the item, or by pressing the Return or Enter key when the item is current.\n\nSee also clicked(), doubleClicked(), entered(), and pressed().\n\nDeselects all selected items. The current index will not be changed.\n\nSee also setSelection() and selectAll().\n\nThis signal is emitted when a mouse button is left-clicked. The item the mouse was clicked on is specified by index. The signal is only emitted when the index is valid.\n\nSee also activated(), doubleClicked(), entered(), and pressed().\n\nCloses the given editor, and releases it. The hint is used to specify how the view should respond to the end of the editing operation. For example, the hint may indicate that the next item in the view should be opened for editing.\n\nSee also edit() and commitData().\n\nCloses the persistent editor for the item at the given index.\n\nSee also openPersistentEditor() and isPersistentEditorOpen().\n\nCommit the data in the editor to the model.\n\nThis slot is called when a new item becomes the current item. The previous current item is specified by the previous index, and the new item by the current index.\n\nIf you want to know about changes to items see the dataChanged() signal.\n\nReturns the model index of the current item.\n\nThis slot is called when items with the given roles are changed in the model. The changed items are those from topLeft to bottomRight inclusive. If just one item is changed topLeft == bottomRight.\n\nThe roles which have been changed can either be an empty container (meaning everything has changed), or a non-empty container with the subset of roles which have changed.\n\nReturns the offset of the dirty regions in the view.\n\nIf you use scrollDirtyRegion() and implement a paintEvent() in a subclass of QAbstractItemView, you should translate the area given by the paint event with the offset returned from this function.\n\nSee also scrollDirtyRegion() and setDirtyRegion().\n\nThis signal is emitted when a mouse button is double-clicked. The item the mouse was double-clicked on is specified by index. The signal is only emitted when the index is valid.\n\nSee also clicked() and activated().\n\nThis function is called with the given event when a drag and drop operation enters the widget. If the drag is over a valid dropping place (e.g. over an item that accepts drops), the event is accepted; otherwise it is ignored.\n\nSee also dropEvent() and startDrag().\n\nThis function is called when the item being dragged leaves the view. The event describes the state of the drag and drop operation.\n\nThis function is called continuously with the given event during a drag and drop operation over the widget. It can cause the view to scroll if, for example, the user drags a selection to view's right or bottom edge. In this case, the event will be accepted; otherwise it will be ignored.\n\nSee also dropEvent() and startDrag().\n\nThis function is called with the given event when a drop event occurs over the widget. If the model accepts the even position the drop event is accepted; otherwise it is ignored.\n\nReturns the position of the drop indicator in relation to the closest item.\n\nStarts editing the item corresponding to the given index if it is editable.\n\nNote that this function does not change the current index. Since the current index defines the next and previous items to edit, users may find that keyboard navigation does not work as expected. To provide consistent navigation behavior, call setCurrentIndex() before this function with the same model index.\n\nStarts editing the item at index, creating an editor if necessary, and returns if the view's State is now EditingState; otherwise returns .\n\nThe action that caused the editing process is described by trigger, and the associated event is specified by event.\n\nEditing can be forced by specifying the trigger to be QAbstractItemView::AllEditTriggers.\n\nThis function is called when the given editor has been destroyed.\n\nThis signal is emitted when the mouse cursor enters the item specified by index. Mouse tracking needs to be enabled for this feature to work.\n\nSee also viewportEntered(), activated(), clicked(), doubleClicked(), and pressed().\n\nExecutes the scheduled layouts without waiting for the event processing to begin.\n\nThis function is called with the given event when the widget obtains the focus. By default, the event is ignored.\n\nSee also setFocus() and focusOutEvent().\n\nThis function is called with the given event when the widget loses the focus. By default, the event is ignored.\n\nSee also clearFocus() and focusInEvent().\n\nReturns the horizontal offset of the view.\n\nIn the base class this is a pure virtual function.\n\nReturns the model index of the item at the viewport coordinates point.\n\nIn the base class this is a pure virtual function.\n\nReturns the widget for the item at the given index.\n\nInitialize the option structure with the view's palette, font, state, alignments etc.\n\nThis function was introduced in Qt 6.0.\n\nReturns if the item referred to by the given index is hidden in the view, otherwise returns .\n\nHiding is a view specific feature. For example in TableView a column can be marked as hidden or a row in the TreeView.\n\nIn the base class this is a pure virtual function.\n\nReturns whether a persistent editor is open for the item at index index.\n\nSee also openPersistentEditor() and closePersistentEditor().\n\nReturns the item delegate used by this view and model. This is either one set with setItemDelegate(), or the default one.\n\nReturns the item delegate used by this view and model for the given column. You can call itemDelegate() to get a pointer to the current delegate for a given index.\n\nSee also setItemDelegateForColumn(), itemDelegateForRow(), and itemDelegate().\n\nReturns the item delegate used by this view and model for the given index.\n\nThis function was introduced in Qt 6.0.\n\nSee also setItemDelegate(), setItemDelegateForRow(), and setItemDelegateForColumn().\n\nReturns the item delegate used by this view and model for the given row, or if no delegate has been assigned. You can call itemDelegate() to get a pointer to the current delegate for a given index.\n\nSee also setItemDelegateForRow(), itemDelegateForColumn(), and setItemDelegate().\n\nThis function is called with the given event when a key event is sent to the widget. The default implementation handles basic cursor movement, e.g. Up, Down, Left, Right, Home, PageUp, and PageDown; the activated() signal is emitted if the current index is valid and the activation key is pressed (e.g. Enter or Return, depending on the platform). This function is where editing is initiated by key press, e.g. if F2 is pressed.\n\nSee also edit(), moveCursor(), keyboardSearch(), and tabKeyNavigation.\n\nMoves to and selects the item best matching the string search. If no item is found nothing happens.\n\nIn the default implementation, the search is reset if search is empty, or the time interval since the last search has exceeded QApplication::keyboardInputInterval().\n\nReturns the model that this view is presenting.\n\nThis function is called with the given event when a mouse button is double clicked inside the widget. If the double-click is on a valid item it emits the doubleClicked() signal and calls edit() on the item.\n\nThis function is called with the given event when a mouse move event is sent to the widget. If a selection is in progress and new items are moved over the selection is extended; if a drag is in progress it is continued.\n\nThis function is called with the given event when a mouse button is pressed while the cursor is inside the widget. If a valid item is pressed on it is made into the current item. This function emits the pressed() signal.\n\nThis function is called with the given event when a mouse button is released, after a mouse press event on the widget. If a user presses the mouse inside your widget and then drags the mouse to another location before releasing the mouse button, your widget receives the release event. The function will emit the clicked() signal if an item was being pressed.\n\nReturns a QModelIndex object pointing to the next object in the view, based on the given cursorAction and keyboard modifiers specified by modifiers.\n\nIn the base class this is a pure virtual function.\n\nOpens a persistent editor on the item at the given index. If no editor exists, the delegate will create a new editor.\n\nSee also closePersistentEditor() and isPersistentEditorOpen().\n\nThis signal is emitted when a mouse button is pressed. The item the mouse was pressed on is specified by index. The signal is only emitted when the index is valid.\n\nUse the QGuiApplication::mouseButtons() function to get the state of the mouse buttons.\n\nSee also activated(), clicked(), doubleClicked(), and entered().\n\nReset the internal state of the view.\n\nThis function is called with the given event when a resize event is sent to the widget.\n\nReturns the model index of the model's root item. The root item is the parent item to the view's toplevel items. The root can be invalid.\n\nThis slot is called when rows are about to be removed. The deleted rows are those under the given parent from start to end inclusive.\n\nThis slot is called when rows are inserted. The new rows are those under the given parent from start to end inclusive. The base class implementation calls fetchMore() on the model to check for more data.\n\nSchedules a layout of the items in the view to be executed when the event processing starts.\n\nEven if scheduleDelayedItemsLayout() is called multiple times before events are processed, the view will only do the layout once.\n\nPrepares the view for scrolling by (dx,dy) pixels by moving the dirty regions in the opposite direction. You only need to call this function if you are implementing a scrolling viewport in your view subclass.\n\nIf you implement scrollContentsBy() in a subclass of QAbstractItemView, call this function before you call QWidget::scroll() on the viewport. Alternatively, just call update().\n\nSee also scrollContentsBy(), dirtyRegionOffset(), and setDirtyRegion().\n\nScrolls the view if necessary to ensure that the item at index is visible. The view will try to position the item according to the given hint.\n\nIn the base class this is a pure virtual function.\n\nScrolls the view to the bottom.\n\nSee also scrollTo() and scrollToTop().\n\nScrolls the view to the top.\n\nSee also scrollTo() and scrollToBottom().\n\nSelects all items in the view. This function will use the selection behavior set on the view when selecting.\n\nSee also setSelection(), selectedIndexes(), and clearSelection().\n\nThis convenience function returns a list of all selected and non-hidden item indexes in the view. The list contains no duplicates, and is not sorted.\n\nThis slot is called when the selection is changed. The previous selection (which may be empty), is specified by deselected, and the new selection by selected.\n\nReturns the SelectionFlags to be used when updating a selection model for the specified index. The result depends on the current selectionMode(), and on the user input event event, which can be .\n\nReimplement this function to define your own selection behavior.\n\nSee also setSelectionModel() and selectedIndexes().\n\nSets the current item to be the item at index.\n\nUnless the current selection mode is NoSelection, the item is also selected. Note that this function also updates the starting position for any new selections the user performs.\n\nTo set an item as the current item without selecting it, call\n\nSee also currentIndex(), currentChanged(), and selectionMode.\n\nMarks the given region as dirty and schedules it to be updated. You only need to call this function if you are implementing your own view subclass.\n\nSee also scrollDirtyRegion() and dirtyRegionOffset().\n\nSets the given widget on the item at the given index, passing the ownership of the widget to the viewport.\n\nIf index is invalid (e.g., if you pass the root index), this function will do nothing.\n\nThe given widget's autoFillBackground property must be set to true, otherwise the widget's background will be transparent, showing both the model data and the item at the given index.\n\nThis function should only be used to display static content within the visible area corresponding to an item of data. If you want to display custom dynamic content or implement a custom editor widget, subclass QStyledItemDelegate instead.\n\nSee also indexWidget() and Delegate Classes.\n\nSets the item delegate for this view and its model to delegate. This is useful if you want complete control over the editing and display of items.\n\nAny existing delegate will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSets the given item delegate used by this view and model for the given column. All items on column will be drawn and managed by delegate instead of using the default delegate (i.e., itemDelegate()).\n\nAny existing column delegate for column will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSee also itemDelegateForColumn(), setItemDelegateForRow(), and itemDelegate().\n\nSets the given item delegate used by this view and model for the given row. All items on row will be drawn and managed by delegate instead of using the default delegate (i.e., itemDelegate()).\n\nAny existing row delegate for row will be removed, but not deleted. QAbstractItemView does not take ownership of delegate.\n\nSee also itemDelegateForRow(), setItemDelegateForColumn(), and itemDelegate().\n\nSets the model for the view to present.\n\nThis function will create and set a new selection model, replacing any model that was previously set with setSelectionModel(). However, the old selection model will not be deleted as it may be shared between several views. We recommend that you delete the old selection model if it is no longer required. This is done with the following code:\n\nIf both the old model and the old selection model do not have parents, or if their parents are long-lived objects, it may be preferable to call their deleteLater() functions to explicitly delete them.\n\nThe view does not take ownership of the model unless it is the model's parent object because the model may be shared between many different views.\n\nSee also model(), selectionModel(), and setSelectionModel().\n\nSets the root item to the item at the given index.\n\nApplies the selection flags to the items in or touched by the rectangle, rect.\n\nWhen implementing your own itemview setSelection should call selectionModel()->select(selection, flags) where selection is either an empty QModelIndex or a QItemSelection that contains all items that are contained in rect.\n\nSee also selectionCommand() and selectedIndexes().\n\nSets the current selection model to the given selectionModel.\n\nNote that, if you call setModel() after this function, the given selectionModel will be replaced by one created by the view.\n\nSee also selectionModel(), setModel(), and clearSelection().\n\nSets the item view's state to the given state.\n\nReturns the width size hint for the specified column or -1 if there is no model.\n\nThis function is used in views with a horizontal header to find the size hint for a header section based on the contents of the given column.\n\nReturns the size hint for the item with the specified index or an invalid size for invalid indexes.\n\nSee also sizeHintForRow() and sizeHintForColumn().\n\nReturns the height size hint for the specified row or -1 if there is no model.\n\nThe returned height is calculated using the size hints of the given row's items, i.e. the returned value is the maximum height among the items. Note that to control the height of a row, you must reimplement the QAbstractItemDelegate::sizeHint() function.\n\nThis function is used in views with a vertical header to find the size hint for a header section based on the contents of the given row.\n\nStarts a drag by calling drag->exec() using the given supportedActions.\n\nThis function is called with the given event when a timer event is sent to the widget.\n\nUpdates the area occupied by the given index.\n\nUpdates the geometry of the child widgets of the view.\n\nReturns the vertical offset of the view.\n\nIn the base class this is a pure virtual function.\n\nThis signal is emitted when the mouse cursor enters the viewport. Mouse tracking needs to be enabled for this feature to work.\n\nThis function is used to handle tool tips, and What's This? mode, if the given event is a QEvent::ToolTip,or a QEvent::WhatsThis. It passes all other events on to its base class viewportEvent() handler.\n\nReturns if event has been recognized and processed; otherwise, returns .\n\nReturns the rectangle on the viewport occupied by the item at index.\n\nIf your item is displayed in several areas then visualRect should return the primary area that contains index and not the complete area that index might encompasses, touch or cause drawing.\n\nIn the base class this is a pure virtual function.\n\nSee also indexAt() and visualRegionForSelection().\n\nReturns the region from the viewport of the items in the given selection.\n\nIn the base class this is a pure virtual function.\n\nSee also visualRect() and selectedIndexes()."
    }
]