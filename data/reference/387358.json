[
    {
        "link": "https://stackoverflow.com/questions/2262386/generate-sha256-with-openssl-and-c",
        "document": "I'm looking to create a hash with sha256 using openssl and C++. I know there's a similar post at Generate SHA hash in C++ using OpenSSL library, but I'm looking to specifically create sha256.\n\nSeems to be a problem with the include paths. It can't find any OpenSSL functions even though I included\n\nand I included the paths in my build"
    },
    {
        "link": "https://openssl.org/docs/man3.1/man3/SHA256.html",
        "document": ""
    },
    {
        "link": "https://github.com/openssl/openssl/blob/master/crypto/sha/sha256.c",
        "document": "* Licensed under the Apache License 2.0 (the \"License\"). You may not use\n\n* this file except in compliance with the License. You can obtain a copy\n\n* in the file LICENSE in the source distribution or at\n\n* SHA256 low level APIs are deprecated for public use, but still ok for\n\n* Note that FIPS180-2 discusses \"Truncation of the Hash Function Output.\"\n\n* default: case below covers for it. It's not clear however if it's\n\n* permitted to truncate to amount of bytes not divisible by 4. I bet not,\n\n* but if it is, then default: case shall be extended. For reference.\n\n* Idea behind separate cases for pre-defined lengths is to let the\n\n* compiler decide if it's appropriate to unroll small loops."
    },
    {
        "link": "https://stackoverflow.com/questions/18541046/openssl-sha256-difference-between-two-way-of-calculating",
        "document": "I am using openssl sha256 function with C++. What is the difference between the below two way of calculating sha256 ?\n\nWay1: Just call SHA256 method like below\n\nWay2: Use SHA256_CTX, SHA256_Init, SHA256_Update and SHA256_Final. As mentioned here generate sha256 with openssl and C++\n\nBoth the programs produce the same result\n\nExample for both methods have been mentioned here"
    },
    {
        "link": "https://bitcoin.stackexchange.com/questions/111506/proper-way-to-get-sha256-hash-in-c-using-openssl",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/674904/salting-your-password-best-practices",
        "document": "I've always been curious... Which is better when salting a password for hashing: prefix, or postfix? Why? Or does it matter, so long as you salt?\n\nTo explain: We all (hopefully) know by now that we should salt a password before we hash it for storage in the database [Edit: So you can avoid things like what happened to Jeff Atwood recently]. Typically this is done by concatenating the salt with the password before passing it through the hashing algorithm. But the examples vary... Some examples prepend the salt before the password. Some examples add the salt after the password. I've even seen some that try to put the salt in the middle.\n\nSo which is the better method, and why? Is there a method that decreases the chance of a hash collision? My Googling hasn't turned up a decent analysis on the subject.\n\nEdit: Great answers folks! I'm sorry I could only pick one answer. :)"
    },
    {
        "link": "https://stackoverflow.com/questions/16891729/best-practices-salting-peppering-passwords",
        "document": "Ok. Seeing as I need to write about this over and over, I'll do one last canonical answer on pepper alone.\n\nIt seems quite obvious that peppers should make hash functions more secure. I mean, if the attacker only gets your database, then your users passwords should be secure, right? Seems logical, right?\n\nThat's why so many people believe that peppers are a good idea. It \"makes sense\".\n\nIn the security and cryptography realms, \"make sense\" isn't enough. Something has to be provable and make sense in order for it to be considered secure. Additionally, it has to be implementable in a maintainable way. The most secure system that can't be maintained is considered insecure (because if any part of that security breaks down, the entire system falls apart).\n\nAnd peppers fit neither the provable or the maintainable models...\n\nNow that we've set the stage, let's look at what's wrong with peppers.\n• None Feeding one hash into another can be dangerous. In your example, you do . We know from past experience that \"just feeding\" one hash result into another hash function can decrease the overall security. The reason is that both hash functions can become a target of attack. That's why algorithms like PBKDF2 use special operations to combine them (hmac in that case). The point is that while it's not a big deal, it is also not a trivial thing to just throw around. Crypto systems are designed to avoid \"should work\" cases, and instead focus on \"designed to work\" cases. While this may seem purely theoretical, it's in fact not. For example, Bcrypt cannot accept arbitrary passwords. So passing can indeed result in a far weaker hash than if returns a binary string.\n• The way bcrypt (and other password hashing algorithms) were designed is to work with a salt. The concept of a pepper was never introduced. This may seem like a triviality, but it's not. The reason is that a salt is not a secret. It is just a value that can be known to an attacker. A pepper on the other hand, by very definition is a cryptographic secret. The current password hashing algorithms (bcrypt, pbkdf2, etc) all are designed to only take in one secret value (the password). Adding in another secret into the algorithm hasn't been studied at all. That doesn't mean it is not safe. It means we don't know if it is safe. And the general recommendation with security and cryptography is that if we don't know, it isn't. So until algorithms are designed and vetted by cryptographers for use with secret values (peppers), current algorithms shouldn't be used with them.\n• None Complexity Is The Enemy Of Security Believe it or not, Complexity Is The Enemy Of Security. Making an algorithm that looks complex may be secure, or it may be not. But the chances are quite significant that it's not secure.\n• Your implementation of peppers precludes the ability to rotate the pepper key. Since the pepper is used at the input to the one way function, you can never change the pepper for the lifetime of the value. This means that you'd need to come up with some wonky hacks to get it to support key rotation. This is extremely important as it's required whenever you store cryptographic secrets. Not having a mechanism to rotate keys (periodically, and after a breach) is a huge security vulnerability. And your current pepper approach would require every user to either have their password completely invalidated by a rotation, or wait until their next login to rotate (which may be never)... Which basically makes your approach an immediate no-go.\n• None It Requires You To Roll Your Own Crypto Since no current algorithm supports the concept of a pepper, it requires you to either compose algorithms or invent new ones to support a pepper. And if you can't immediately see why that's a really bad thing: Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can't break. NEVER roll your own crypto...\n\nThe Better Way\n\nSo, out of all the problems detailed above, there are two ways of handling the situation.\n• None Just Use The Algorithms As They Exist If you use bcrypt or scrypt correctly (with a high cost), all but the weakest dictionary passwords should be statistically safe. The current record for hashing bcrypt at cost 5 is 71k hashes per second. At that rate even a 6 character random password would take years to crack. And considering my minimum recommended cost is 10, that reduces the hashes per second by a factor of 32. So we'd be talking only about 2200 hashes per second. At that rate, even some dictionary phrases or modificaitons may be safe. Additionally, we should be checking for those weak classes of passwords at the door and not allowing them in. As password cracking gets more advanced, so should password quality requirements. It's still a statistical game, but with a proper storage technique, and strong passwords, everyone should be practically very safe...\n• There exists in the security realm an algorithm designed to handle everything we've said above. It's a block cipher. It's good, because it's reversible, so we can rotate keys (yay! maintainability!). It's good because it's being used as designed. It's good because it gives the user no information. Let's look at that line again. Let's say that an attacker knows your algorithm (which is required for security, otherwise it's security through obscurity). With a traditional pepper approach, the attacker can create a sentinel password, and since he knows the salt and the output, he can brute force the pepper. Ok, that's a long shot, but it's possible. With a cipher, the attacker gets nothing. And since the salt is randomized, a sentinel password won't even help him/her. So the best they are left with is to attack the encrypted form. Which means that they first have to attack your encrypted hash to recover the encryption key, and then attack the hashes. But there's a lot of research into the attacking of ciphers, so we want to rely on that.\n\nDon't use peppers. There are a host of problems with them, and there are two better ways: not using any server-side secret (yes, it's ok) and encrypting the output hash using a block cipher prior to storage."
    },
    {
        "link": "https://projectai.in/projects/a559a87b-2bab-4453-8c93-78ce2c3e01f4/tasks/b49db938-ca34-4a21-a617-c27fd4b38e9c",
        "document": "⚙️ We are optimizing all the projects, removing redundant steps and task, and even more elaborated task details for you to follow. In a few weeks all the projects will be replaced with the new/better tasks. Stay tuned!\n\nMulti-Client Chat Server Implementing Secure Password Storage in C++ Using OpenSSL Hashing Implement user authentication: Add a system for clients to log in with usernames and passwords, and maintain a list of connected users."
    },
    {
        "link": "https://reddit.com/r/cryptography/comments/1h31zcx/hashing",
        "document": "Im new to IT and even basic levels of cryptography and have been recently learning about how hashing and salting work. I wanted to hash a certain password but I’m not sure where to actually perform this function. Is it a certain program or website I use? Sorry if this is a dumb question, I still have a lot to learn."
    },
    {
        "link": "https://security.stackexchange.com/questions/100843/is-it-possible-to-salt-the-sha1-or-sha256-hash-function-of-openssl",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]