[
    {
        "link": "https://svelte.dev/docs/kit/routing",
        "document": "At the heart of SvelteKit is a filesystem-based router. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase:\n• creates a route with a parameter, , that can be used to load data dynamically when a user requests a page like\n\nEach route directory contains one or more route files, which can be identified by their prefix.\n\nWe’ll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit’s routing works:\n• All files can run on the server\n• All files run on the client except files\n• and files apply to subdirectories as well as the directory they live in\n\nA component defines a page of your app. By default, pages are rendered both on the server (SSR) for the initial request and in the browser (CSR) for subsequent navigation.\n\nPages can receive data from functions via the prop.\n\nOften, a page will need to load some data before it can be rendered. For this, we add a module that exports a function:\n\nThis function runs alongside , which means it runs on the server during server-side rendering and in the browser during client-side navigation. See for full details of the API.\n\nAs well as , can export values that configure the page’s behaviour:\n\nYou can find more information about these in page options.\n\nIf your function can only run on the server — for example, if it needs to fetch data from a database or you need to access private environment variables like API keys — then you can rename to and change the type to .\n\nDuring client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using devalue. See for full details of the API.\n\nLike , can export page options — , and .\n\nA file can also export actions. If lets you read data from the server, let you write data to the server using the element. To learn how to use them, see the form actions section.\n\nIf an error occurs during , SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an file:\n\nSvelteKit will ‘walk up the tree’ looking for the closest error boundary — if the file above didn’t exist it would try and then before rendering the default error page. If that fails (or if the error was thrown from the function of the root , which sits ‘above’ the root ), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a file.\n\nIf the error occurs inside a function in , the closest error boundary in the tree is an file above that layout (not next to it).\n\nIf no route can be found (404), (or the default error page, if that file does not exist) will be used.\n\nYou can read more about error handling here.\n\nSo far, we’ve treated pages as entirely standalone components — upon navigation, the existing component will be destroyed, and a new one will take its place.\n\nBut in many apps, there are elements that should be visible on every page, such as top-level navigation or a footer. Instead of repeating them in every , we can put them in layouts.\n\nTo create a layout that applies to every page, make a file called . The default layout (the one that SvelteKit uses if you don’t bring your own) looks like this...\n\n...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a tag for the page content. For example, let’s add a nav bar:\n\nIf we create pages for , and ...\n\n...the nav will always be visible, and clicking between the three pages will only result in the being replaced.\n\nLayouts can be nested. Suppose we don’t just have a single page, but instead have nested pages like and with a shared submenu (for a real-life example, see github.com/settings).\n\nWe can create a layout that only applies to pages below (while inheriting the root layout with the top-level nav):\n\nYou can see how is populated by looking at the example in the next section just below.\n\nBy default, each layout inherits the layout above it. Sometimes that isn’t what you want - in this case, advanced layouts can help you.\n\nJust like loading data from , your component can get data from a function in .\n\nIf a exports page options — , and — they will be used as defaults for child pages.\n\nData returned from a layout’s function is also available to all its child pages:\n\nTo run your layout’s function on the server, move it to , and change the type to .\n\nLike , can export page options — , and .\n\nAs well as pages, you can define routes with a file (sometimes referred to as an ‘API route’ or an ‘endpoint’), which gives you full control over the response. Your file exports functions corresponding to HTTP verbs like , , , , , , and that take a argument and return a object.\n\nFor example we could create an route with a handler:\n\nThe first argument to can be a , making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).\n\nYou can use the , and methods from for convenience (but you don’t have to).\n\nIf an error is thrown (either or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via — depending on the header. The component will not be rendered in this case. You can read more about error handling here.\n\nBy exporting / / / / / handlers, files can be used to create a complete API:\n\nExporting the handler will match any unhandled request methods, including methods like which have no dedicated export from .\n\nfiles can be placed in the same directory as files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:\n• / / / requests are always handled by since they do not apply to pages\n• / / requests are treated as page requests if the header prioritises (in other words, it’s a browser page request), else they are handled by .\n• Responses to requests will include a header, so that proxies and browsers cache HTML and JSON responses separately.\n\nThroughout the examples above, we’ve been importing types from a file. This is a file SvelteKit creates for you in a hidden directory if you’re using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.\n\nFor example, annotating with (or , for a file) tells TypeScript that the type of is whatever was returned from :\n\nIn turn, annotating the function with , , or (for , , and respectively) ensures that and the return value are correctly typed.\n\nIf you’re using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types entirely! Svelte’s IDE tooling will insert the correct types for you, so you’ll get type checking without writing them yourself. It also works with our command line tool .\n\nYou can read more about omitting in our blog post about it.\n\nAny other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.\n\nIf components and modules are needed by multiple routes, it’s a good idea to put them in ."
    },
    {
        "link": "https://svelte.dev/docs/kit/advanced-routing",
        "document": "If the number of route segments is unknown, you can use rest syntax — for example you might implement GitHub’s file viewer like so...\n\n...in which case a request for would result in the following parameters being available to the page:\n\nRest parameters also allow you to render custom 404s. Given these routes...\n\n...the file will not be rendered if you visit , because no route was matched. If you want to render the nested error page, you should create a route that matches any request, and return a 404 from it:\n\nA route like contains a parameter named which is required. Sometimes it’s beneficial to make these parameters optional, so that in this example both and point to the same page. You can do that by wrapping the parameter in another bracket pair:\n\nNote that an optional route parameter cannot follow a rest parameter ( ), since parameters are matched ‘greedily’ and the optional parameter would always be unused.\n\nA route like would match , but it would also match . We don’t want that. You can ensure that route parameters are well-formed by adding a matcher — which takes the parameter string ( or ) and returns if it is valid — to your directory...\n\nIf the pathname doesn’t match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.\n\nEach module in the directory corresponds to a matcher, with the exception of and files which may be used to unit test your matchers.\n\nIt’s possible for multiple routes to match a given path. For example each of these routes would match :\n\nSvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...\n• More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)\n• Parameters with matchers ( ) are higher priority than those without ( )\n• and parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words is treated equivalently to for the purposes of sorting\n\n...resulting in this ordering, meaning that will invoke , and will invoke rather than less specific routes:\n\nSome characters can’t be used on the filesystem — on Linux and Mac, on Windows. The and characters have special meaning in URLs, and the characters have special meaning to SvelteKit, so these also can’t be used directly as part of your route.\n\nTo use these characters in your routes, you can use hexadecimal escape sequences, which have the format where is a hexadecimal character code:\n\nFor example, to create a route, you would create a file.\n\nYou can determine the hexadecimal code for a character with JavaScript:\n\nYou can also use Unicode escape sequences. Generally you won’t need to as you can use the unencoded character directly, but if — for some reason — you can’t have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:\n\nThe format for a Unicode escape sequence is where is a valid value between and . (Unlike JavaScript string escaping, there’s no need to use surrogate pairs to represent code points above .) To learn more about Unicode encodings, consult Programming with Unicode.\n\nBy default, the layout hierarchy mirrors the route hierarchy. In some cases, that might not be what you want.\n\nPerhaps you have some routes that are ‘app’ routes that should have one layout (e.g. or ), and others that are ‘marketing’ routes that should have a different layout ( or ). We can group these routes with a directory whose name is wrapped in parentheses — unlike normal directories, and do not affect the URL pathname of the routes inside them:\n\nYou can also put a directly inside a , for example if should be an or a page.\n\nThe root layout applies to every page of your app — if omitted, it defaults to . If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups except the routes that should not inherit the common layouts.\n\nIn the example above, the route does not inherit either the or layouts.\n\nPages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an route inside the group from the previous example:\n\nOrdinarily, this would inherit the root layout, the layout, the layout and the layout. We can reset to one of those layouts by appending followed by the segment name — or, for the root layout, the empty string. In this example, we can choose from the following options:\n\nLike pages, layouts can themselves break out of their parent layout hierarchy, using the same technique. For example, a component would reset the hierarchy for all its child routes.\n\nWhen to use layout groups\n\nNot all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex nesting, or that you don’t want to introduce a for a single outlier. It’s perfectly fine to use other means such as composition (reusable functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:"
    },
    {
        "link": "https://stackoverflow.com/questions/70826406/dynamic-routing-svelte",
        "document": "I am trying to build a simple blog with Svelte and Strapi v4 as backend. I have 2 pages : list of all posts page (no problem here) and the post page (problem here). For the list of posts, I manage to fetch my datas from Strapi using onMount. Works fine.\n\nThe link to go to the specific post page [id].svelte works :\n\nBut I get then an error. I don't manage to tell Svelte : fetch this specific id datas in the [id].svelte page. Using the below code in [id].svelte does not work, I get a 404 in the console.\n\nI also tried with this method with no success :\n\nI am blocked and don't know how to move forward. Getting also lost between SvelteKit, Svelte... Thanks for your great help.\n\nHere is the file tree of the route :\n\nI am also using svelte-routing in my App.svelte file. I use this below code trying to tell Svelte to find my [id] page. But I always get a return saying the page is not found on the server..."
    },
    {
        "link": "https://builder.io/blog/sveltekit-routing-visual-guide",
        "document": "When you visit the root URL, , the home page is still= displayed. However, if you navigate to , the About me page displays. Similarly, changing the URL to renders the My profile page. This demonstrates that routes are associated with a file based on the containing folder's name within the folder. The file within the folder corresponds to , while the file within the folder corresponds to .\n\nNow, navigating to displays the first blog post, and shows the second blog post. By creating a nested folder structure, SvelteKit automatically routes the files accordingly. This simplifies the process of creating nested routes and enhances the organization and structure of your application.\n\nNow, when you navigate to , the product details page displays. Similarly, accessing , , or even displays the same details page. is the dynamic route segment that can accommodate values like 1, 2, 3, and so on. To display the specific product ID, you can make use of the module from SvelteKit. Modify the component as follows:\n\nNow, when you navigate to , the details about product 1 displays. Similarly, visiting will display details about product 100. Dynamic routes are beneficial when implementing the list-detail pattern in any UI application. By understanding how to create dynamic routes in SvelteKit, you can build flexible and scalable applications that adapt to varying user interactions.\n\nIn the previous section, we learned about dynamic routes. Now, let's take it a step further and explore nested dynamic routes. Complex applications often require multiple dynamic route segments. For instance, when navigating to , the user expects the details for product 1. Similarly, visiting should display the first review for that product. Let's find out how we can achieve this.\n• Create a folder. This structure takes us to the route /products/productId/reviews. However, we also need a dynamic .\n• Within the folder, create a new folder named . Once again, the square brackets indicate a dynamic route segment.\n• Inside the folder, create a file where we'll define a Svelte component to display both the and the .\n\nNow, if we navigate to in the browser, the expected text displays. Similarly, navigating to 100 and 5 reflects the corresponding IDs in the UI. The key takeaway from this section is that it is possible to create nested dynamic routes by having dynamic segments in the folder names.\n\nRouting is an integral part of web development, so users can navigate between different pages within an application. SvelteKit simplifies routing through its file-system-based routing mechanism. In this blog post, we explored the basics of routing in SvelteKit. We discussed routing conventions, created routes for different scenarios, and highlighted SvelteKit’s convention over configuration approach for routing. With SvelteKit, you can easily define and manage routes by leveraging the file and folder structure of your codebase, eliminating the need for additional routing configuration."
    },
    {
        "link": "https://github.com/ItalyPaleAle/svelte-spa-router/blob/main/Advanced%20Usage.md",
        "document": "svelte-spa-router is simple by design. A minimal router is easy to learn and implement, adds minimum overhead, and leaves more control in the hands of the developers.\n\nThanks to the many features of Svelte or other components in the ecosystem, svelte-spa-router can be used to get many more \"advanced\" features. This document explains how to achieve certain results with svelte-spa-router beyond what's offered by the component itself.\n\nAs shown in the intro documentation, the method allows defining components that need to be dynamically-imported at runtime, which makes it possible to support code-splitting.\n\nThe method allows a few more interesting features, however:\n• In addition to dynamically-importing components, you can define a component to be shown while a dynamically-imported one is being requested\n• You can add pre-conditions to routes (sometimes called \"route guards\")\n• You can add custom user data that is then used with the and events\n• You can set static props, which are passed to the component as mounted by the router\n\nThe method is imported from :\n\nIt accepts a single argument that is an object with the following properties:\n• : Svelte component to use, statically-included in the bundle. This is a Svelte component, such as , with that previously imported with .\n• : Used to dynamically-import components. This must be a function definition that returns a dynamically-imported component, such as:\n• : Used together with , this is a Svelte component, that must be part of the bundle, which is displayed while is being downloaded. If this is empty, then the router will not display any component while the request is in progress.\n• : When using a , this is an optional dictionary that will be passed to the component as the prop.\n• : Optional dictionary that will be passed to events such as , , .\n• : Optional array of route pre-condition functions to add, which will be executed in order.\n• : Optional dictionary of props that are passed to the component when mounted. The props are expanded with the spread operator ( ), so the key of each element becomes the name of the prop.\n\nOne and only one of or must be set; all other properties are optional.\n\nYou use the method in your route definition, such as:\n\nAs mentioned in the main readme, starting with version 3 the method is used with dynamically-imported components. This allows (when the bundler supports that, such as with Vite, Rollup or Webpack) code-splitting too, so code for less-common routes can be downloaded on-demand from the server rather than shipped in the app's core bundle.\n\nThis is done by setting the property to a function that returns a dynamically-imported module. For example:\n\nNote that the value of must be a function definition, such as , and not (which is a function invocation). The latter would in fact request the module right away (albeit asynchronously), rather than on-demand when needed.\n\nBy default, while a module is being downloaded, the router does not display any component. You can however define a component (which must be statically-included in the app's bundle) to be displayed while the router is downloading a module. This is done with the property. Additionally, with you can define a JavaScript object/dictionary that is passed to the loading placeholder component as the prop.\n\nFor example, with a component:\n\nYou can define the route as:\n\nThe method can also be used to add a dictionary with custom user data, that will be passed to all pre-condition functions (more on that below), and to the , , and events.\n\nThis is useful to pass custom callbacks (as properties inside the dictionary) that can be used by the , , and event listeners to take specific actions.\n\nYou can define pre-conditions on routes, also known as \"route guards\". You can define one or more functions that the router will execute before loading the component that matches the current path. Your application can use pre-conditions to implement custom checks before routes are loaded, for example ensuring that users are authenticated.\n\nPre-conditions are defined in the argument for the function, which is an array of callbacks.\n\nEach pre-condition function receives a dictionary with the same structure as the event (more information below):\n• : the route that was matched, exactly as defined in the route definition object\n• : the current path (just like the readable store)\n• : the current \"querystring\" parameters from the page's hash (just like the readable store)\n• : custom user data passed with the function (see above)\n\nThe pre-condition functions must return a boolean indicating wether the condition succeeded (true) or failed (false).\n\nYou can define any number of pre-conditions for each route, and they're executed in order. If all pre-conditions succeed (returning true), the route is loaded. If one condition fails, the router stops executing pre-conditions and does not load any route.\n\nPre-conditions can be applied to dynamically-loaded routes too.\n\nAdditionally, starting with version 3 of svelte-spa-router, pre-conditions can be asynchronous function too. This is helpful, for example, to request authentication data, user profiles… For example:\n\nIn case a condition fails, the router emits the event, with the same dictionary.\n\nYou can listen to the event and perform actions in case no route wasn't loaded because of a failed pre-condition:\n\nIn certain cases, you might need to pass static props to a component within the router.\n\nFor example, assume this component :\n\nIf is a route in your application, you can pass a series of props to it through the router, using :\n\nThe custom event can be used to bubble events from a component displayed by the router, to the router's parent component.\n\nFor example, assume that your Svelte component contains the router's component . Inside the router, the current view is displaying the component. If emitted an event, would receive it and would ignore it by default\n\nUsing the custom event , instead, allows your components within the router (such as ) to bubble an event to the component's parent.\n\nThese two events are used by the router to notify the application when routes are being mounted. You can optionally listen to these events and trigger any custom logic.\n\nFirst, the router emits when it's about to mount a new component. If the component is dynamically-imported and needs to be requested, this event is fired when the component is being requested. In all other cases, such as if the dynamically-imported component has already been loaded, or if the component is statically included in the bundle, the event is still fired right before .\n\nEventually, the router emits the event after a route has been successfully loaded (and injected in the DOM).\n\nThe event listener for receives an object that contains the following object:\n\nFor the event, the argument contains the four properties above in addition to:\n\nFor help with the function, check the route wrapping section.\n\nAs the main documentation for svelte-spa-router mentions, you can extract parameters from the \"querystring\" in the hash of the page. This allows you to build apps that navigate to pages such as .\n\nThe router has built-in support for returning the value of the \"querystring\", but it only returns the full string and doesn't perform any parsing. Components can access the \"querystring\" part of the hash from the store in the svelte-spa-router component. For example:\n\nWhen visiting the page , this would generate:\n\nMost times, however, you might want to parse the \"querystring\" into a dictionary, to be able to use those values inside your application easily. There are multiple ways of doing that. The simplest one is using URLSearchParams which is available in all modern browsers. If you need support for older browsers, a safe solution is to rely on the popular qs library.\n\nHere's an example on using by changing the component above to:\n\nWith the same URL as before, the result would be:\n\nsupports advanced things such as arrays, nested objects, etc. Check out their README for more information.\n\nIt's easy to add a nice transition between routes, leveraging the built-in transitions of Svelte.\n\nFor example, to make your components fade in gracefully, you can wrap the markup in a container (e.g. , or , etc) and attach a Svelte transition to that. For example:\n\nWhen you apply the transition to multiple components, you can get a smooth transition effect:\n\nFor more details: official documentation on Svelte transitions.\n\nThe component of svelte-spa-router can be nested without issues.\n\nFor example, consider an app with these four components:\n\n< { }/> < > We need to define both '/hello' and '/hello/*' in two separate lines to ensure that both '/hello' (with nothing else) and sub-paths are matched Note: If defining routes using a Map object, you could use a custom regular expression instead of having to define the route twice: </ > < >Hello!</ > < { } { } /> < > Routes for the \"inner router\" Note that we have a \"prefix\" property for this nested router </ > < >You gave us both a first name and last name!</ > < >First: { . }</ > < >Last: { . }</ > < > </ > < >You shy person, giving us a first name only!</ > < >First: { . }</ > < > </ >\n\nThis works as you would expect:\n• will show the component and pass \"John\" as\n• will show the component, pass \"Jane\" as , and \"Doe\" as\n• Both routes will also display the header.\n\nBoth routes first load the route, as they both match in the outer router. The inner router then loads the separate components based on the path.\n\nFeatures like highlighting active links will still work, regardless of where those links are placed in the page (in which component).\n\nNote that if your parent router uses a route that contains parameters, such as , then you must define a regular expression for . For example: . This is available in svelte-spa-router 3 or higher.\n\nYou can get route groups by creating a Svelte component which nests the other components. For example:\n\nWhen you add as a component in your router, you will render both and .\n\nStarting with svelte-spa-router 3.0, there is a new option in the component to restore the scroll position when the user navigates to the previous page.\n\nTo enable that, set the property to in the router (it's disabled by default):\n\nImportant: In order for the scroll position to be restored, you need to trigger a page navigation using either the action or the method. Navigating using links starting with (such as ) will not allow restoring the scroll position."
    },
    {
        "link": "https://svelte.dev/docs/kit/state-management",
        "document": "If you’re used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.\n\nBrowsers are stateful — state is stored in memory as the user interacts with the application. Servers, on the other hand, are stateless — the content of the response is determined entirely by the content of the request.\n\nConceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it’s important not to store data in shared variables. For example, consider this code:\n\nThe variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice’s secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.\n\nInstead, you should authenticate the user using and persist the data to a database.\n\nFor the same reason, your functions should be pure — no side-effects (except maybe the occasional ). For example, you might be tempted to write to a store or global state inside a function so that you can use the value in your components:\n\nAs with the previous example, this puts one user’s information in a place that is shared by all users. Instead, just return the data...\n\n...and pass it around to the components that need it, or use .\n\nIf you’re not using SSR, then there’s no risk of accidentally exposing one user’s data to another. But you should still avoid side-effects in your functions — your application will be much easier to reason about without them.\n\nUsing state and stores with context\n\nYou might wonder how we’re able to use and other app state (or app stores) if we can’t use global state. The answer is that app state and app stores on the server use Svelte’s context API — the state (or store) is attached to the component tree with , and when you subscribe you retrieve it with . We can do the same thing with our own state:\n\nUpdating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values ‘flashing’ during state updates during hydration, it is generally recommended to pass state down into components rather than up.\n\nIf you’re not using SSR (and can guarantee that you won’t need to use SSR in future) then you can safely keep state in a shared module, without using the context API.\n\nWhen you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...\n\n...then navigating from to won’t cause the layout, page and any other components within to be destroyed and recreated. Instead the prop (and by extension and ) will update (as it would with any other Svelte component) and, because the code isn’t rerunning, lifecycle methods like and won’t rerun and won’t be recalculated.\n\nInstead, we need to make the value reactive:\n\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:\n\nIf you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like ) are a good place to put them. You can put them in or attributes, or set them programmatically via . They can be accessed inside functions via the parameter, and inside components via .\n\nSome UI state, such as ‘is the accordion open?’, is disposable — if the user navigates away or refreshes the page, it doesn’t matter if the state is lost. In some cases, you do want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides snapshots, which let you associate component state with a history entry."
    },
    {
        "link": "https://reddit.com/r/sveltejs/comments/zwntvc/handling_authentication_with_sveltekit",
        "document": "I know this has probably been asked a thousand times but I'm really struggling with authentication and I haven't found a solution that works for my use case yet. I'm managing auth state in a readable store which is grouped with a promise that resolves when the auth state is known (either signed in our out). I'm using Firebase, so the store is set internally by the handler.\n\nMy first solution for auth was to, in , await the promise, then render a login form if the user is null or a otherwise. This worked great from a UX perspective and allowed me to render a loading icon while waiting on the auth state to resolve, which was neat.\n\nI'm now running into issues however, as I need to load user-privileged stuff from a database in the load function in . There is no way for me to wait on a valid login before running this load function, causing an invalid database access.\n\nTo solve, I need an actual sign-in page, which I added, but I'm running into issues here too. In , the user store seems to always be null (I think because it's being rendered on the server?) so I can't really add logic there to redirect to the signin page. In , the user store is being updated as expected. Is there any way for me to access the store in ?"
    },
    {
        "link": "https://loginradius.com/blog/engineering/guest-post/authenticating-svelte-apps",
        "document": "Google Chrome has planned to phase out third-party cookies, which will affect different website functionalities depending on third-party cookies. This blog focuses on how this phase-out affects identity and user authentication and discusses alternatives for overcoming challenges."
    },
    {
        "link": "https://tropicolx.hashnode.dev/mastering-state-management-in-svelte",
        "document": ""
    },
    {
        "link": "https://auth0.com/blog/authenticating-svelte-apps",
        "document": "TL;DR: As at the time of this writing, the Svelte frontend framework has overtaken Vue in popularity according to the State of JS 2019, disrupting the framework \"Equilibrium\" that frontend developers have enjoyed for a while with React, Vue, and Angular. Unlike other frameworks, Svelte does not do its DOM-updating work in the browser using the Virtual DOM but instead compiles efficient JavaScript code in its build step that updates your DOM when a state change occurs. This paradigm-changing strategy has led to the fast-rising popularity and adoption of Svelte.\n\nIn this post, you will learn how to implement authentication in Svelte applications using Auth0.\n\nWhat You Are Going to Build\n\nIn this tutorial, you will build a simple task list manager using the Svelte framework. Users will be able to sign into this application to have authenticated access and create task items. When a user completes a task, the task can then be ticked off as \"completed\" on the list. By the end of this exercise, you will be fully armed with all you need to authenticate Svelte apps with Auth0. You can find the complete code for this tutorial at this Github repository. You can see a preview of what you are going to build below.\n\nTo get started building this application, you will need to have a few things set up:\n• Node.js installed on your system ( is recommended)\n\nSurprised? Svelte is a very minimalistic framework. With these two, you are good to go.\n\nNext up, you will set up your Auth0 application to handle authentication in your Svelte application. If you don't already have an Auth0 account, you can sign up for a free account here.\n\nOnce logged in, click on Applications on the left-hand side menu. On the Applications page, click on the big orange CREATE APPLICATION button.\n\nOn the Create Application dialog that pops up, enter an appropriate name for your application and select Single Page Web Applications from the options below the application name field.\n\nNow click the Create button to complete the process.\n\nAfter the successful creation of the application, go to the Settings section of your newly created app. In the Allowed Callback URLs, Allowed Web Origins, Allowed Logout URLs, and Allowed Origins (CORS) fields, enter\n\n. This address is the default address of the Svelte application you will be creating later on. Make sure you update these settings once your application moves to production.\n\nOnce you're done entering these values, scroll down and hit the SAVE CHANGES button.\n\nYour next task is to scaffold a new Svelte project. You can do this by cloning the standard Svelte project template using degit at any preferred location on your system as follows:\n\nIn the command above,\n\ninvokesto clone the standard template in your current working directory.is the folder in which the project code will be cloned. Once this process is complete, go into the root of your project by running:\n\nNext, you need to install the project dependencies with the following command:\n\nWhen all dependencies have been installed, run the following command to boot up a development server to run your app in:\n\nOnce the above command is done, you will see the development URL of your application printed to the console, i.e. . Load this URL in your browser, you will see a page similar to the one below:\n\nThe next task is to set up all the application needs to authenticate users. To begin, you will need to install Auth0's SDK for authenticating Single Page Applications, the @auth0/auth0-spa-js package. Install this package by running the following command at the root of your project:\n\nThe next step is to create a Svelte store to hold the application state and, most importantly, the authentication state. Within the\n\nfolder, create a new fileand enter the following code:\n\nThe above code consists of five writable and one derived state properties:\n• : Defines the authenticated state of the user, when a user is authenticated, by default.\n• : Holds the details of an authenticated user returned by Auth0 after successful authentication.\n• : The sign-in process will be initiated using Auth0's popup authentication modal. This is to monitor the visible state of the popup modal.\n• : Holds the error information if the authentication process fails.\n• : Holds all tasks created in the application\n• : A derived state property that filters the in the application to only return the ones created by the logged-in user.\n\nThe next step is to create an authentication service to hold the authentication functions that the application will require. To begin, you first need to create a configuration file to hold your Auth0 application details. At the root of the project, create a new file,\n\n, and enter the following code:\n\nwith your own Auth0 domain andwith the Client ID of your application.\n\nTo find these values, go back into the Applications page of your Auth0 dashboard. Find the application you created at the beginning of the tutorial, and click on \"Settings\". You'll find Domain and Client ID listed there.\n\nMake sure you also add this file to your\n\nfile so that you don't mistakenly push your details to a public repository.\n\nWith this file in place, you can now create the authentication service. Create the file\n\ninside thefolder and place the following code in it:\n\nThe file above begins by importing the required objects from the\n• : Uses Auth0's function and the authentication configuration to create a new authentication client and returns it.\n• : Takes in an authentication instance with defined options and uses these to call the on the client to sign-in and user. It then sets to and to the user details returned by the logged-in client.\n• : This is simply a proxy to the Auth0 's method that ends a logged-in user's session.\n\npackage, the application store (), and the authentication configurations from. Three authentication functions are then defined as follows:\n\nFinally, these three functions are exported from the module.\n\nA task in the application has the following interface:\n\nThe properties are described as follows:\n• : An auto-generated identifier for each task\n• : A description of the task e.g. Take out the trash\n• : A boolean representing whether the task has been completed or not\n• : The email of the user that created the task\n\nYou will create a task list item component that will display and control the behavior of a task item in the application. Inside the\n\nfolder, create a new folder with the name. Inside this folder, create the file, and input the following code:\n\nThe component above takes in a\n\nprop and displays a list itemwith the taskand a checkbox for the user to tick when the task is complete. When the checkbox is ticked, themethod is called, which uses thelocal variable to update the task'sproperty.\n\nStyles are also added for a completed task by applying the\n\nclass when theproperty of the task is\n\nFor some basic styling, the Bootstrap library will be used. To apply Bootstrap, go into the\n\nfile and add the library (using a CDN link) in thesection under thetags as shown below:\n\nNext, remove the reference to\n\n. You will not be needing it, and some of the styles in the file clash with those you will define later on.\n\nWith all the components/services required in place, you can now start building the Task List page. You will be replacing all the code currently in the\n\nfile, so go into this file and clear any existing code in it.\n\nThis file will consist of three sections: the script section, the styles section, and the template. To begin, add the script section by adding the following code in the file:\n\nThe script begins by importing all required objects (\n\nfrom, andfrom the store), services (themodule), and components ().\n\nand, are defined to hold the Auth0 client created during application startup and a task item typed into the form field (to be created later) respectively.\n• : Calls the method from the authentication service\n• : Calls the method from the authentication service\n• : Creates a new item object according to the interface and adds it to the in the application's state.\n\nSvelte lifecycle method is then called with a callback that creates a new Auth0 client once the page loads and sets the authentication state. Lastly, in this script section, four (4) component methods are defined, which do the following:\n\nNext, add the styles section by placing the following code below the\n\nat the top of the application's template for the authenticated screen, which will be defined next.\n\nThe next step is to create the application screen by defining the template. The screen will consist of a Bootstrap navigation bar that will display the application name and, based on the authentication state, will display the email of the name and email of the logged-in user. It will also conditionally display a \"Log In\" or \"Log Out\" link.\n\nBelow the navigation bar, the application will also display a Welcome Screen or the task list and the task creation form based on the authenticated state.\n\nsection, add the following code for the application template:\n\nWith the template in place, you can now run the application. If the application is currently running, terminate the process with the\n\ncommand and rerun it using. Return to your browser and reload theaddress. You will see the Welcome screen below loaded in your browser:\n\nNow click on any of the \"Log In\" links to sign in to the application. This will pop up the Auth0 log-in screen as shown below:\n\nYou can use any of the authentication options displayed, but for this demo, use the Google login button. Once the process is completed, you will be authenticated, and the task list page will be displayed as shown below:\n\nAs seen, the task list is empty. That is because you have not added any task items, so go ahead add new tasks and tick some off. You should now have a screen similar to the one below:\n\nWhen you click the \"Log Out\", you will be returned to the application welcome screen as the user is automatically logged out.\n\nSvelte is a very fast and easy-to-use frontend framework with a simple API that does not cheat you on any features of modern frontend frameworks, but rather does it efficiently. With Auth0, you have one less thing to worry about, as you can now easily authenticate your Svelte apps as demonstrated in this tutorial.\n\nIf any part of your code is not working as expected, I advise that you go through the article once again to see if there's anything you may have missed. You can also check out the final code in this GitHub repository."
    },
    {
        "link": "https://samvcodes.medium.com/what-are-reactive-statements-in-svelte-and-why-are-they-useful-ead4ba013864",
        "document": "What I’ll cover in this tutorial:\n• What actually are reactive statements?\n• Why they are so useful?\n• Plenty of example use cases\n\nWhat actually are reactive statements in Svelte?\n\nTake the below snippet of code, this is a simple example of how you can use reactive statements. So what we’re doing here is assigning the string to when the component is mounted using . We're also logging the value using a in a reactive block, meaning the value will be logged to the console whenever the state is reassigned. This is because the state is a dependency of the reactive block. This means that reactive blocks will run based on their dependencies. The exact example below with the is actually a very handy thing to do when debugging state; it's something I use all of the time.\n\nWhat you’re probably wondering is how they work within Svelte? Well, Svelte uses JavaScript labels to declare blocks of code that can reactively run based on state dependencies. So anything after will be your reactive block, this could be a one-line assignment or a function call that returns something. Let’s go over some examples:\n\nWhy are reactive statements useful?\n\nReactive statements are useful for a number of cases. Firstly you can use them to declare variables based on the state in your component, such as something simple like below. The below takes two variables and will keep our declared reactive statement up to date by its dependencies, no matter how many times you reassign and\n\nAs you can probably guess reactivity is what makes this Svelte feature so powerful. You could have all of your form validation as a reactive statement, you could call functions based on if a value is set, and tons more. But one thing that I think should be discussed is that reactive statements can also be used to react to the global app state, meaning any store you have access to in your component can be read and used as a dependency within a reactive statement. I’ll put an example below:\n\nLet’s go over a couple more simple cases where you may want to use reactive statements. First, you may have a function that returns a value, and you may want this function to be called every time some specific state updates in your component. Well, this is entirely possible, all you need to do is use a reactive declaration.\n\nSo in this example, and are our dependencies. So whenever these dependencies change, will be called returning the sum of + , and assigning the value to .\n\nFor me, this feature is something that stands out from other frameworks. Vue has methods that can watch values, and I’m sure React also has something very similar. But Svelte just makes it nice, easy, and with minimal boilerplate. So if you’re currently looking into Svelte features, make sure you give this one a go!"
    },
    {
        "link": "https://svelte.dev/tutorial/svelte/effects",
        "document": "So far we’ve talked about reactivity in terms of state. But that’s only half of the equation — state is only reactive if something is reacting to it, otherwise it’s just a sparkling variable.\n\nThe thing that reacts is called an effect. You’ve already encountered effects — the ones that Svelte creates on your behalf to update the DOM in response to state changes — but you can also create your own with the rune.\n\nMost of the time, you shouldn’t. is best thought of as an escape hatch, rather than something to use frequently. If you can put your side effects in an event handler, for example, that’s almost always preferable.\n\nLet’s say we want to use to keep track of how long the component has been mounted. Create the effect:\n\nClick the ‘speed up’ button a few times and notice that ticks up faster, because we’re calling each time gets smaller.\n\nIf we then click the ‘slow down’ button... well, it doesn’t work. That’s because we’re not clearing out the old intervals when the effect updates. We can fix that by returning a cleanup function:\n\nThe cleanup function is called immediately before the effect function re-runs when changes, and also when the component is destroyed.\n\nIf the effect function doesn’t read any state when it runs, it will only run once, when the component mounts."
    },
    {
        "link": "https://bejamas.com/hub/tutorials/building-reactive-uis-with-sveltekit-reactive-statements",
        "document": "In contemporary web development, creating reactive user interfaces (UIs) is essential to offering a smooth and dynamic user experience. An interactive and captivating application is produced by reactive user interfaces, which react in real-time to user actions and modifications in the underlying data. However, employing traditional methods to create and manage reactive user interfaces can be difficult.\n\nIn this article, you will explore how to build reactive UIs with SvelteKit, a framework that offers a creative and sophisticated method of creating reactive UI elements from reactive statements using JSONPlaceholder API. You will explore SvelteKit's salient features, analyze the notion of reactive statements, and receive guidance in building a project that showcases its capabilities. To view the project's source code, head over to Bejamas' GitHub profile.\n\nWhat is reactive UI, and why is it important\n\nReactive UI describes user interfaces that spontaneously update in response to modifications in the fundamental data or user behaviors. It is necessary because it improves the user experience by lowering the need for manual updates, giving real-time feedback, and building a more dynamic and seamless interface. Reactive user interfaces (UIs) offer advantages to developers as well. They can streamline the logic and code of user interface components, minimize complexity and defects, and enhance the applications' scalability and performance.\n\nIt's not simple to create and maintain reactive user interfaces (UIs), especially when using traditional approaches that depend on event-driven techniques like callbacks, promises, observables, etc. These techniques frequently include multiple boilerplate code, tedious state management, and manual DOM manipulation, which make the user interface components challenging to comprehend, troubleshoot, and test.\n\nSvelteKit offers a declarative and reactive method for creating user interfaces in order to overcome these obstacles.\n\nSvelteKit is a cutting-edge web framework that utilizes reactive programming to streamline the user interface development process. Svelte, a component-based framework, serves as its foundation and converts components into highly efficient JavaScript during build time. SvelteKit aims to offer a more versatile and robust framework that can support a range of use cases and scenarios, such as server-side rendering (SSR), static site generation (SSG), single-page applications (SPAs), hybrid applications, etc. It has excellent performance optimization, reactivity, and simplicity.\n\nSvelteKit is a fantastic option for creating reactive user interfaces because of a number of important features, including:\n\nSvelteKit has a lot to offer web app developers and users. Among the advantages are:\n\nWhat are reactive statements in SvelteKit\n\nReactive statements are expressions that immediately update when the underlying data is modified. It is a fundamental feature of Svelte and SvelteKit. Compared to conventional event-driven techniques, they offer a simpler means of managing state and updates by enabling components to automatically update in response to changes in their dependencies. SvelteKit uses automatic dependency tracking to achieve reactivity. SvelteKit monitors the dependency between a component and a variable or store used by reactive statements, updating the component automatically when the variable or store changes.\n\nReactive statements in SvelteKit are distinct from the traditional event-driven approach—which makes use of promises, observables, event listeners, callbacks, etc.— to updating the user interface. Due to the manual management of state changes and UI updates, the event-driven approach can be verbose, complex, and prone to errors. Conversely, reactive statements in SvelteKit allow you to specify the logic for UI updates and let Svelte take care of the rest. They are straightforward, elegant, and dependable. Because they only execute when the data they depend on changes and only update the impacted areas of the user interface, reactive statements in SvelteKit are also more efficient.\n\nReactive statements and the traditional event-driven approach are two distinct approaches to managing UI updates and data changes in web applications. They can be applied to various scenarios and goals, and they each have unique benefits and drawbacks.\n\nThe foundation of reactive statements is the declarative syntax, which updates the user interface (UI) automatically when the data depends on changes. With reactive statements, the developer can write elegant and succinct code that specifies how the user interface should respond to changes in the data, and Svelte will take care of the rest. Because reactive statements only run when the data changes and only update the affected areas of the user interface, they are straightforward, dependable, and efficient. They do this by doing away with the need for event listeners, callbacks, promises, observables, and other mechanisms.\n\nThe traditional event-driven approach relies on reacting to application events—like user interactions, network requests, timers, and others—by means of event listeners, callbacks, promises, observables, and other mechanisms. The developer must manually oversee state changes, UI updates, and communication between various application components when using the event-driven approach. Due to the need to manage asynchronous operations, avoid race conditions, write a lot of boilerplate code, and deal with callback hell, the event-driven approach can be verbose, complex, and prone to errors.\n\nThe control flow of the application is the primary distinction between reactive statements and the traditional event-driven method. The developer must write code to handle each event and its effects when using the event-driven approach, which bases control flow on the events that take place in the application. The developer only needs to write code to declare the logic of the UI updates in reactive statements, where the control flow is dictated by the data that changes in the application.\n\nIn your terminal, type the following commands to start a new SvelteKit project:\n\nProceed to create a component inside the then create the user list component.\n\nThis is an elementary Svelte component that shows user information and includes a detail view button. The HTML in the main section specifies the structure, and the logic for the component will be contained in the script section.\n\nImportance of variables and state in building reactive UIs\n\nIn SvelteKit, variables and states are essential for creating responsive user interfaces (UIs). They are the cornerstone for handling dynamic data, reacting to user input, and making sure that the user experience is smooth and quick.\n\nA recent addition to Svelte is Runes, which gives you a succinct and expressive syntax for generating reactive variables and statements. Inspired by Solid, Svelte sister project, Runes uses a signal-based reactivity model.\n\nWith the help of Svelte load functions and reactive statements, SvelteKit offers a straightforward and user-friendly method for retrieving and displaying data in a reactive manner.\n\nLoad functions are unique functions that can be created in the folder's or files that go with the files. When a load function returns an object that the page component can use to access the data, it means that the function has successfully fetched the data the page requires. Additionally, load functions can return other properties to control the page's response, like status, error, headers, etc.\n\nInside the folder create a where you would like to fetch the data to.\n\nSo looks as so:\n\nThis SvelteKit code above defines a function, which is a unique function used to fetch data prior to rendering the page. This enables you to retrieve information from the server side, making it accessible for search engine optimization or enhancing the speed of the initial load.\n\nA request is sent to the designated API endpoint—in this case, https://jsonplaceholder.typicode.com/users—using the fetch function. Since it is an function, after submitting the request it awaits the response before parsing the JSON data. The data variable is then used to hold the parsed data. The retrieved data is returned by the function as an object with a user's property. The Svelte component that makes use of this object will have it available as a prop.\n\nA block encloses the code to handle any errors that might arise during the fetch or data parsing procedure. An error is reported to the console if it happens.\n\nThis code component displays a list of users by using the data that was fetched in the previous function. The section makes variable accessible to the parent component by exporting it using Svelte's export keyword. Next, the is assigned to a newly created local variable called .\n\nThe component's functionality involves presenting a list of users in a card format, enabling users to click on the \"See Details\" button and be taken to a page that is unique to each individual. Iterating over the array of users is done using the block, which receives the data as a (data) from a parent component.\n\nReactive user interactions can be handled easily and naturally with SvelteKit by utilizing the reactive statements and event directives offered by Svelte. To listen for and handle particular events, like , , , etc., event directives are special attributes that can be added to any HTML element. Regular JavaScript expressions that update data or call functions when the event takes place can be passed through to event directives.\n\nInside the folder, create the folder along with the and to handle the user details.\n\nIn the add the following code:\n\nAn asynchronous function called is exported by the code. SvelteKit calls this function automatically when rendering occurs on the server. An object with the properties and is given to the function. HTTP requests are made with the fetch function, and the parameters from the route are contained in .\n\nUsing the parameter, the load function retrieves user information from the JSONPlaceholder API. Following the fetching process, the user details are returned as an object, which the Sveltekit component can use as rendering props.\n\nProceed to add the code for the as follows:\n\nThe user object is extracted from a data prop by the SvelteKit component, which then shows the user's details in a Bootstrap card. It's a neat and tidy method of displaying user data in an ordered manner.\n\nIn SvelteKit, conditional rendering allows you to manage an element or component's visibility according to predetermined criteria. This gives you an adaptable method to show or hide content based on changes in the application's state. SvelteKit's syntax simplifies the implementation and maintenance of conditional rendering in your components, whether you're dealing with straightforward visibility toggles or intricate multi-condition scenarios.\n\nLogic blocks from Svelte, like , , , , and , can be used with SvelteKit to enable conditional rendering. The rendering of the elements or components can be managed by using logic blocks, which are unique syntax that can be used inside component markup. Normal JavaScript expressions that return true or false, as well as other values that can be forced to be boolean, can be passed into logic blocks.\n\nThe Svelte component checks to see if the users array contains any elements before dynamically rendering a message stating that \"no users are available\" or a list of users. When working with data that may or may not be present, this is a great way to make the user experience more user-friendly. verifies whether there are any elements in the users array; If this is the case, it enters the block and shows the user list. It moves into the block if the condition in is not satisfied, that is, if the users array is empty.\n\nBest practices for building reactive UIs with SvelteKit’s reactive statements\n\nTo create effective and responsive user interfaces, there are numerous best practices for utilizing SvelteKit's reactive statements.\n\nIt's crucial to optimize performance when developing reactive user interfaces (UIs) using SvelteKit's reactive statements in order to develop web applications that run quickly and smoothly.\n\nIn this article, you learned about building reactive UIs with SvelteKit reactive statements, its features, and benefits. You also learned how it works better than traditional methods. To get more information about Sveltekit and working with reactive statements, visit their documentation."
    },
    {
        "link": "https://medium.com/@dineshbyte/mastering-svelte-reactive-declarations-a-comprehensive-guide-f904db24d4ae",
        "document": "Svelte has garnered attention in the web development community for its innovative approach to building frontend applications. One of the standout features of Svelte is its Reactive Declarations, which enable developers to write concise, clean, and reactive code with minimal boilerplate. Reactive Declarations simplify the process of updating component state when dependencies change, resulting in a more maintainable codebase. In this article, we will explore the Reactive Declarations feature in depth, and walk through a comprehensive example to demonstrate its power and flexibility.\n\nReactive Declarations in Svelte allow you to automatically update variables when their dependencies change. By using the syntax followed by an expression, Svelte creates a reactive statement that listens for changes in the dependent variables and automatically updates the target variable.\n\nThis feature eliminates the need for complex state management libraries or cumbersome event listeners. Svelte’s compiler takes care of creating the appropriate reactive code, keeping your components lean and efficient.\n\nLet’s begin with a simple example to illustrate the basics of Reactive Declarations. We will create a counter component that tracks the number of clicks and calculates the squared value of the count.\n\nIn this example, we use the syntax to create a reactive declaration for the variable. When the variable changes, the value of is automatically updated, and the component re-renders as necessary.\n\nSvelte allows you to use conditional reactive declarations by combining the syntax with statements. This feature enables you to apply reactive updates only when certain conditions are met.\n\nExample: Updating a Counter Only When the Value is Even\n\nIn this example, the reactive declaration for updates only when the value is even. This demonstrates how you can use conditional logic within reactive declarations to create more sophisticated behavior.\n\nSvelte Reactive Declarations can have multiple dependencies, allowing you to create complex expressions that react to changes in multiple variables.\n\nIn this example, we create a simple currency conversion component that updates the based on the and the . The reactive declaration for automatically recalculates the value when either or changes.\n\nSvelte Reactive Declarations offer a powerful and intuitive way to create reactive components that automatically update in response to changes in their dependencies. This feature simplifies the process of managing component state and allows developers to write clean, maintainable code with minimal boilerplate.\n\nIn this article, we have explored Reactive Declarations in depth, covering their basic usage, conditional logic, and handling multiple dependencies. We also provided comprehensive examples to demonstrate their power and flexibility in various scenarios.\n\nAs you continue to develop with Svelte, mastering Reactive Declarations will enable you to create highly efficient and responsive applications with ease. Embracing this innovative feature will help streamline your development process and improve the overall quality of your frontend projects."
    },
    {
        "link": "https://flaviocopes.com/svelte-reactive-statements",
        "document": "How to work with Reactive Statements in Svelte\n\nIn Svelte you can listen for changes in the component state, and update other variables.\n\nFor example if you have a variable:\n\nand you update it by clicking a button:\n\nYou can listen for changes on using the special syntax which defines a new block that Svelte will re-run when any variable referenced into it changes.\n\nYou can write more than one of them:\n\nAnd you can also add a block to group more than one statement:\n\nI used a console.log() call in there, but you can update other variables too:"
    }
]