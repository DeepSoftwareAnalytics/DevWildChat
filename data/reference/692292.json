[
    {
        "link": "https://reddit.com/r/C_Programming/comments/1b2mj3a/best_practice_on_allocating_memory_for_a_struct",
        "document": "Hi all! I am very new to C but am familiar with Python & Go quite a bit. Memory allocation is a new concept to me, but I want to start with best practices.\n\nLets say I want to create a struct that has some members, where one of them happens to be a pointer which I will size dynamically as an array.\n\nHere is what I am doing in my function. I want to understand if I am doing something that is bad practice here\n\nAny pointers or tips would be great! Thank you!"
    },
    {
        "link": "https://stackoverflow.com/questions/15017271/how-to-dynamically-allocate-memory-within-structs",
        "document": "For this week's assignment in my CS class, we have to revise our current program to dynamically allocate memory for all arrays. We have to ensure that no memory is wasted on empty elements. We have to do this by assignment character arrays to temp arrays, size checking the temp, and then allocating an array of that size.\n\nAnyway, I don't get how to do it with a struct. I know how to dynamically allocate memory, for example\n\nBut how do I do that for struct members? It seems like unless you define the size up front, the computer wouldn't know how much space to allocate when you declare a struct of that type.\n\nRight now, my struct definition is like so:\n\nHow do I change all the arrays to be declared dynamically, without specifying size?"
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-declare-dynamic-array-in-struct-418570",
        "document": "In modern C++ programming, declaring dynamic arrays within structs is a powerful technique for creating flexible and memory-efficient data structures. This tutorial explores comprehensive strategies for implementing dynamic arrays, focusing on proper memory management and performance optimization techniques in C++ development.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL cpp((\"C++\")) -.-> cpp/BasicsGroup([\"Basics\"]) cpp((\"C++\")) -.-> cpp/OOPGroup([\"OOP\"]) cpp((\"C++\")) -.-> cpp/AdvancedConceptsGroup([\"Advanced Concepts\"]) cpp/BasicsGroup -.-> cpp/arrays(\"Arrays\") cpp/OOPGroup -.-> cpp/classes_objects(\"Classes/Objects\") cpp/AdvancedConceptsGroup -.-> cpp/pointers(\"Pointers\") cpp/AdvancedConceptsGroup -.-> cpp/references(\"References\") cpp/AdvancedConceptsGroup -.-> cpp/structures(\"Structures\") subgraph Lab Skills cpp/arrays -.-> lab-418570{{\"How to declare dynamic array in struct\"}} cpp/classes_objects -.-> lab-418570{{\"How to declare dynamic array in struct\"}} cpp/pointers -.-> lab-418570{{\"How to declare dynamic array in struct\"}} cpp/references -.-> lab-418570{{\"How to declare dynamic array in struct\"}} cpp/structures -.-> lab-418570{{\"How to declare dynamic array in struct\"}} end"
    },
    {
        "link": "https://stackoverflow.com/questions/10872559/c-allocation-of-array-of-struct",
        "document": "I have to allocate in C++ an array of struct, any struct contains two vector of int. This is my struct:\n\nTo allocate this array I write the following code:\n\nWhen I try to assign a Sample element to data[0] I have an error a runtime. Where is the problem?"
    },
    {
        "link": "https://itsfuad.medium.com/how-dynamic-arrays-actually-work-bff5bb5749bb",
        "document": "Dynamic arrays, with their ability to handle an arbitrary number of elements, are indispensable tools in modern programming. In this section, we’ll embark on a journey to create our own dynamic array implementation using C++ classes. By doing so, we’ll gain insights into the inner workings of dynamic arrays, including memory allocation and element copying.\n\nLet’s learn how it works by creating our own Dynamic Array\n\nLet’s start by defining a class named to encapsulate the functionality of our custom dynamic array. This class will manage the storage of elements and handle dynamic resizing as needed.\n\n#include <iostream>\n\n\n\nclass DynamicArray {\n\nprivate:\n\n int* data; // Pointer to dynamically allocated array\n\n int size; // Number of elements currently stored\n\n int capacity; // Current capacity of the array\n\n\n\npublic:\n\n // Constructor\n\n DynamicArray() : data(nullptr), size(0), capacity(0) {}\n\n\n\n // Destructor\n\n ~DynamicArray() {\n\n delete[] data; // Release dynamically allocated memory\n\n }\n\n\n\n // Method to add an element to the end of the array\n\n void push_back(int element) {\n\n // If the array is full, resize it\n\n if (size == capacity) {\n\n // Double the capacity (resize strategy)\n\n capacity = (capacity == 0) ? 1 : capacity * 2;\n\n\n\n // Allocate new memory\n\n int* newData = new int[capacity];\n\n\n\n // Copy existing elements to the new memory\n\n for (int i = 0; i < size; ++i) {\n\n newData[i] = data[i];\n\n }\n\n\n\n // Release the old memory\n\n delete[] data;\n\n\n\n // Update the pointer to the new memory\n\n data = newData;\n\n }\n\n\n\n // Add the new element at the end\n\n data[size++] = element;\n\n }\n\n\n\n // Method to display elements of the array\n\n void display() {\n\n std::cout << \"Dynamic Array Elements:\" << std::endl;\n\n for (int i = 0; i < size; ++i) {\n\n std::cout << data[i] << \" \";\n\n }\n\n std::cout << std::endl;\n\n }\n\n\n\n // Return the capacity\n\n int get_capacity() {\n\n return capacity;\n\n }\n\n};\n\nNow that we have our class defined, let's put it to use by adding elements and observing the allocation and copying processes.\n\nAs we run the code, we’ll observe the following:\n• Memory Allocation: When the array reaches its capacity limit, a new, larger block of memory is allocated using the resizing strategy implemented in the method.\n• Copying Elements: Existing elements from the old array are copied to the new array during the resizing process to ensure data integrity.\n• Capacity Expansion: The capacity of the dynamic array increases dynamically as elements are added, reflecting the resizing of the underlying memory.\n\nWhile dynamic arrays offer unparalleled flexibility and convenience, they come with their own set of drawbacks that warrant careful consideration. In this section, we’ll explore two significant drawbacks of custom dynamic arrays implemented in C++: the slow nature of heap allocation and the performance impact of copying elements during resizing.\n\nDynamic arrays rely on heap memory allocation to expand and contract dynamically, which can incur overhead due to the overhead of managing memory on the heap.\n\nHeap allocation involves interacting with the operating system’s memory manager, which introduces overhead in terms of time and resources. Each allocation request may involve traversing data structures maintained by the memory manager to find a suitable block of memory, leading to variable allocation times.\n\nAdditionally, heap allocation may result in memory fragmentation over time, where the memory is divided into small, non-contiguous blocks, making it challenging to allocate large contiguous blocks efficiently.\n\nWhen resizing a dynamic array, existing elements must be copied from the old array to the new array to ensure data integrity. This process can be time-consuming, especially for large arrays or arrays containing complex objects.\n\nCopying elements involves iterating over each element in the old array and copying it to the corresponding position in the new array. For arrays with a large number of elements, this operation can become a performance bottleneck, impacting the overall efficiency of operations such as insertion and deletion.\n\nFurthermore, copying elements may lead to unnecessary memory churn, where memory is allocated and deallocated frequently, potentially fragmenting the heap and degrading performance over time.\n\nWhile the drawbacks of heap allocation and copying elements are inherent to dynamic arrays, there are strategies to mitigate their impact:\n• Preallocation: Preallocating memory for the dynamic array based on an estimated size can reduce the frequency of resizing operations, minimizing the overhead of heap allocation and copying.\n• Capacity Management: Implementing a smart resizing strategy, such as increasing the capacity by a constant factor or using exponential resizing, can reduce the frequency of resizing operations, mitigating the performance impact of copying elements.\n• Memory Pools: Using custom memory pools or memory allocators tailored to the specific requirements of the application can improve memory allocation performance by reducing fragmentation and overhead associated with heap allocation.\n\nWhile dynamic arrays offer unparalleled flexibility and convenience, they come with inherent drawbacks such as the slow nature of heap allocation and the performance impact of copying elements during resizing. By understanding these drawbacks and employing mitigation strategies, developers can make informed decisions when designing and using dynamic arrays in C++ applications, striking a balance between flexibility and performance."
    },
    {
        "link": "https://stackoverflow.com/questions/23483845/how-to-initialize-a-dynamic-array-of-customized-struct-in-c",
        "document": "You cannot create an array of a type unless it has a default constructor, and then you can't initialize each of them. However, you can initialize a vector with a default object, which is pretty much what you're asking for here.\n\nNote that you need a copy constructor to handle the copying of ...\n\n... but you can use the default copy constructor if you simply replace your pointer with a vector, too, since vectors handle copy (that would fix a leak, too)."
    },
    {
        "link": "https://stackoverflow.com/questions/1979879/dynamically-allocate-c-struct",
        "document": "How can I dynamically allocate memory for my struct and the struct's arrays?\n\nBoth 'offset' and 'values' are supposed to be arrays, but their size is unknown until runtime.\n\ntry { swc *s = new swc; s->offset = new short[number_of_offset_elements]; s->values = new char[number_of_value_elements]; } catch(...) { ... } Note that in C++, you might be better off using vectors as opposed to dynamically allocated buffers: Question: is values supposed to be an array of individual characters or an array of strings? That would change things a bit. The more I think about it, the less satisfied I am with the C++ answer; the right way to do this sort of thing in C++ (assuming you need dynamically allocated buffers as opposed to vectors, which you probably don't) is to perform the memory allocation for offset and values as part of a constructor within the struct type, and have a destructor deallocate those elements when the struct instance is destroyed (either by a or by going out of scope). struct swc { swc(size_t numOffset = SOME_DEFAULT_VALUE, size_t numValues = SOME_OTHER_DEFAULT_VALUE) { m_offset = new short[numOffset]; m_values = new char[numValues]; } ~swc() { delete[] m_offset; delete[] m_values; } short *m_offset; char *m_values; }; void foo(void) { swc *a = new swc(10,20); // m_offset and m_values allocated as // part of the constructor swc b; // uses default sizes for m_offset and m_values ... a->m_offset[0] = 1; a->m_values[0] = 'a'; b.m_offset[0] = 2; b.m_values[0] = 'b'; ... delete a; // handles freeing m_offset and m_values // b's members are deallocated when it goes out of scope }\n\nYou will need a function to do this. Something like (my C/C++ is rusty) swc* makeStruct(int offsetCount, int valuesCount) { swc *ans = new swc(); ans->offset = new short[offsetCount]; ans->values = new char[valuesCount]; return ans; } myNewStruct = makeStruct(4, 20); Syntax may be a bit off but that is generally what you are going to need. If you're using C++ then you probably want a class with a constructor taking the 2 args instead of the makeStruct but doing something very similar.\n\nOne thing to add to the many correct answers here: you can an over-sized structure to accommodate a variable sized array in the last member. to get room for 30 objects in the array. You would still need to do if you want them to use the same size arrays. I generally wouldn't actually do this (maintenance nightmare if the structure ever needs to expand), but it is a tool in the kit. [code here in c. You'll need to cast the 's (or better use and RAII idioms) in c++]\n\nSince nobody has mentioned it yet, sometimes it is nice to grab this chunk of memory in one allocation so you only have to call free() on one thing: swc* AllocSWC(int items) { int size = sizeof(swc); // for the struct itself size += (items * sizeof(short)); // for the array of shorts size += (items * sizeof(char)); // for the array of chars swc* p = (swc*)malloc(size); memset(p, 0, size); p->offset = (short*)((char*)swc + sizeof(swc)); // array of shorts begins immediately after the struct p->values = (char*)((char*)swc + sizeof(swc) + items * sizeof(short)); // array of chars begins immediately after the array of shorts return p; } Of course this is a bit more difficult to read and maintain (especially if you dynamically resize the arrays after it is first allocated). Just an alternative method I've seen used in a number of places.\n\nMost of the answers are correct. I would like to add something that you haven't explicitly asked but might also be important. C / C++ arrays don't store their own size in memory. Thus, unless you want and to have compile-time defined values (and, in that case, it's better to use fixed-size arrays), you might want to store the sizes of both arrays in the . typedef struct tagswc { short *offset; char *values; // EDIT: Changed int to size_t, thanks Chris Lutz! size_t offset_count; size_t values_count; // You don't need this one if values is a C string. } swc; DISCLAIMER: I might be wrong. For example, if all s of all instances have the same size, it would be better to store as a global member, not as a member of the . The same can be said about and . Also, if is a C string, you don't need to store its size, but beware of Schlemiel the painter-like problems.\n\n**If** you will not be resizing the arrays, then you can get away with a single call to . You can then free it with a single call to ."
    },
    {
        "link": "https://geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory",
        "document": "Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap, and non-static and local variables get memory allocated on Stack (Refer to Memory Layout C Programs for details).\n• None One use of dynamically allocated memory is to allocate memory of variable size, which is not possible with compiler allocated memory except for\n• None The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore. There are many cases where this flexibility helps. Examples of such cases are\n\nHow is it different from memory allocated to normal variables?\n\nFor normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is the programmer’s responsibility to deallocate memory when no longer needed. If the programmer doesn’t deallocate memory, it causes a memory leak (memory is not deallocated until the program terminates).\n\nHow is memory allocated/deallocated in C++? \n\nC uses the malloc() and calloc() function to allocate memory dynamically at run time and uses a free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete, that perform the task of allocating and freeing the memory in a better and easier way.\n\nThe new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, a new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\n\nSyntax to use new operator\n\nHere, the pointer variable is the pointer of type data-type. Data type could be any built-in data type including array or any user-defined data type including structure and class. \n\nExample:\n\nInitialize memory: We can also initialize the memory for built-in data types using a new operator. For custom data types, a constructor is required (with the data type as input) for initializing the value. Here’s an example of the initialization of both data types :\n\nAllocate a block of memory: a new operator is also used to allocate a block(an array) of memory of type data type.\n\nwhere size(a variable) specifies the number of elements in an array.\n\nDynamically allocates memory for 10 integers continuously of type int and returns a pointer to the first element of the sequence, which is assigned top(a pointer). p[0] refers to the first element, p[1] refers to the second element, and so on.\n\nNormal Array Declaration vs Using new \n\nThere is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, that normal arrays are deallocated by the compiler (If the array is local, then deallocated when the function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by the programmer or the program terminates.\n\nWhat if enough memory is not available during runtime? \n\nIf enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be a good idea to check for the pointer variable produced by the new before using its program.\n\nSince it is the programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator in C++ language.\n\nHere, the pointer variable is the pointer that points to the data object created by new.\n\nTo free the dynamically allocated array pointed by pointer variable, use the following form of delete:\n\nTime Complexity: O(n), where n is the given memory size.\n• None Quiz on new and delete"
    },
    {
        "link": "https://quora.com/How-do-I-initialize-a-dynamically-allocated-struct-object-in-C++",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://en.cppreference.com/w/c/language/struct_initialization",
        "document": "When initializing an object of struct or union type, the initializer must be a non-empty,(until C23) brace-enclosed, comma-separated list of initializers for the members:\n\nwhere the designator is a sequence (whitespace-separated or adjacent) of individual member designators of the form member and array designators of the form index .\n\nAll members that are not initialized explicitly are empty-initialized.\n\nWhen initializing a union, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).\n\nWhen initializing a struct, the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.\n\nIt's an error to provide more initializers than members.\n\nIf the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n\nIf the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new current object. The members of the current object are initialized in their natural order, unless designators are used(since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that are not explicitly initialized by the closing brace are empty-initialized.\n\nIf the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:\n\nWhen designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the current object and selects the subobject to be initialized within the current object only. example ex2 // current object is ex2, designators are for members of example . . , , , , . example ex3 , . // changes current object to the union ex.in_u , . // this designator refers to the member of in_u If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated): n s , // this may be printed or skipped . Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list (choose clang to observe the correct output): k l a T i T t S T x . , . , . , . main S l , . x, . . , . . , l. . // .t.l = 41 would zero out l.t.k implicitly However, when an initializer begins with a left open brace, its current object is fully re-initialized and any prior explicit initializers for any of its subobjects are ignored: fred s n fred x , , . fred y , , // current object is now the entire y[0] object .\n\nThe initializer list may have a trailing comma, which is ignored.\n\nEvery expression in the initializer list must be a constant expression when initializing aggregates of any storage duration. As with all other initialization, every expression in the initializer list must be a constant expression when initializing aggregates of static or thread-local(since C11) storage duration: The order of evaluation of the subexpressions in any initializer is indeterminately sequenced (but not in C++ since C++11): n x,y p n , n // n is incremented twice in arbitrary order // p equal {1,2} and {2,1} are both valid"
    }
]