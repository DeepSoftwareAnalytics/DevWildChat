[
    {
        "link": "https://stackoverflow.com/questions/9842917/field-vs-property-optimisation-of-performance",
        "document": "Please note this question related to performance only. Lets skip design guidelines, philosophy, compatibility, portability and anything what is not related to pure performance. Thank you.\n\nNow to the question. I always assumed that because C# getters/setters are really methods in disguise then reading public field must be faster than calling a getter.\n\nSo to make sure I did a test (the code below). However this test only produces expected results (ie fields are faster than getters at 34%) if you run it from inside Visual Studio.\n\nOnce you run it from command line it shows pretty much the same timing...\n\nThe only explanation could be is that the CLR does additional optimisation (correct me if I am wrong here).\n\nI do not believe that in real application where those properties being used in much more sophisticated way they will be optimised in the same way.\n\nPlease help me to prove or disprove the idea that in real life properties are slower than fields.\n\nThe question is - how should I modify the test classes to make the CLR change behaviour so the public field outperfroms the getters. OR show me that any property without internal logic will perform the same as a field (at least on the getter)\n\nEDIT: I am only talking about Release x64 build."
    },
    {
        "link": "https://csharpindepth.com/articles/PropertiesMatter",
        "document": "In chapter 8, I blithely assume that readers regard using properties instead of fields as best practice. Eric suggested that I mention why it's good practice. I felt it didn't quite fit into the chapter, but it's something which comes up every so often in newsgroups and mailing lists, so I thought I'd turn it into an article.\n\nWhat choices are we considering?\n\nIt's worth being clear that this article does not address the question of whether something should be a method or a property. Sometimes it's not a clear-cut decision, and a discussion of the merits each way would be interesting but distract from the purpose of this article.\n\nThe choice I'm talking about in this article is how you expose data: as a property or as a non-private field. It's as simple as that. My personal view is that almost no fields should ever be non-private. I'll make a small exception for static readonly fields such as , but that's (nearly) all.\n\nSo, if you've got a non-private field, why should you make it private and expose a property instead? I've split my points into three categories: compatibility problems, practical benefits of using properties, and the more philosophical considerations. Although the philosophical aspects sound less important, in fact they're the ones which give me more cause for concern.\n\nOften people say it's fine to use fields for simple data, and then change them to properties when you need to. But...\n\nThis one isn't much of an issue if you're working on a project which always ships all of its binaries in one go, or if your field is currently internal and you don't expose the internals to any other assemblies. However, if you're writing a class library which may need to be updated without recompiling the code which uses it, you should understand that changing a field into a property is a breaking change. This includes serialization, too.\n\nYou can use a property everywhere you can use a field, right? Wrong. You can use a field for parameters, whereas you can't (in C# at least) use a property in the same way. There are other subtle areas where there's a difference between fields and properties. Admittedly some (most?) of these involve mutable structs - another design decision to be avoided in almost all situations - but changing a field to a property in some cases can change the behaviour of code without even generating a warning or error. Here's an example showing that, admittedly involving a mutable struct:\n\nThe results are different: 10 for the first line, showing that the call to changed the value within ; 0 for the second line, showing that the call to didn't change the value of .\n\nIf the mutating lines were just and then the change from field to property would be a breaking one - the latter wouldn't compile, because the expression isn't classified as a variable. That's nicer than silently changing behaviour, but it's still an unwelcome change!\n\nMost of the time we don't use reflection to access members we can already get at directly. However, if someone does, that code will break if it's expecting a field to be present and it's been turned into a property unexpectedly.\n\nThere are times when you could use non-private fields, because for whatever reason you don't care about the compatibility reasons above. However, there are still benefits to using properties even for trivial situations:\n• There's more fine-grained access control with properties. Need it to be publicly gettable but really only want it set with protected access? No problem (from C# 2 onwards, at least).\n• Want to break into the debugger whenever the value changes? Just add a breakpoint in the setter.\n• Want to log all access? Just add logging to the getter.\n• Properties are used for data binding; fields aren't.\n\nNone of these are traditional \"adding real logic\" uses of properties, but all are tricky/impossible with plain fields. You could do this on an \"as and when I need it\" basis, but why not just be consistent to start with? It's even more of a no-brainer with the automatic properties of C# 3.\n\nThe philosophical reason for only exposing properties\n\nFor every type you write, you should consider its interface to the rest of the world (including classes within the same assembly). This is its description of what it makes available, its outward persona. Implementation shouldn't be part of that description, any more than it absolutely has to be. (That's why I prefer composition to inheritance, where the choice makes sense - inheritance generally exposes or limits possible implementations.)\n\nA property communicates the idea of \"I will make a value available to you, or accept a value from you.\" It's not an implementation concept, it's an interface concept. A field, on the other hand, communicates the implementation - it says \"this type represents a value in this very specific way\". There's no encapsulation, it's the bare storage format. This is part of the reason fields aren't part of interfaces - they don't belong there, as they talk about how something is achieved rather than what is achieved.\n\nI quite agree that a lot of the time, fields could actually be used with no issues in the lifetime of the application. It's just not clear beforehand which those times are, and it still violates the design principle of not exposing implementation.\n\nThere are exceptions to every rule, of course. Rico Mariani is a very smart guy who knows performance inside out and certainly knows design principles too. In a blog post about graphics primitives he details why he wrote a mutable struct with a size larger than 16 bytes, which exposes its fields publicly - breaking three fairly strong design guidelines with a single type. Don't just use this example as a reason to expose fields publicly - at least, not unless the same justifications apply too. Experts get to break rules in a very few cases, because they know exactly what they're getting themselves into. Mere mortals like myself - and like most readers of this page, I suspect - should at least spend a sleepless night thinking about their reasons before breaking such guidelines.\n\nIt's interesting to note that one of Rico's reasons for exposing fields is actually the same as my reason for normally preferring properties above - it exposes the implementation. Just occasionally, you want to give callers the confidence that the implementation will remain in a particular way for ever and a day - and that was the case here. I can't say that I've ever had to give that kind of guarantee in any code I've written, but we know that situations vary a lot.\n\nA separate exceptional case I occasionally have used is making fields internal within a private nested type. As the type is private, this means the fact that it's a field still won't be exposed to any types other than the one it's nested in - which effectively \"owns\" the code for the nested type anyway. With C# 3 I'll probably use automatic properties for these situations anyway from now on - it was only ever a matter of convenience.\n\nIn almost all cases, fields should be private. Not just non-public, but private. With automatic properties in C# 3, there's basically no cost in readability or the amount of code involved to use a property instead of a field. Very occasionally you might find a genuinely good reason, but think long and hard about it before committing to that choice, particularly if you'll be exposing it beyond access."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/ye4kmz/why_exactly_is_it_bad_to_have_public_fields",
        "document": "I've been learning C# since around the start of 2020 and something that's always confused me about the language is that it seems that having public fields on a type is bad and that properties should be used instead. I haven't been able to figure out exactly why that's the case, The only time I've understood the need for properties encapsulating private fields is that they can be used to ensure that the field is never set to an invalid value, but most of the time it just seems to work identically to if it was just a public field. Why exactly is that bad?"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/161303/is-it-bad-practice-to-use-public-fields",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/632831/why-are-public-fields-faster-than-properties",
        "document": "I was poking around in XNA and saw that the class in it was using public fields instead of properties. I tried a quick benchmark and found that, for a the difference is quite dramatic (adding two Vectors together a 100 million times took 2.0s with properties and 1.4s with fields). For a reference type, the difference doesn't seem to be that large but it is there.\n\nSo why is that? I know that a property is compiled into and methods, which would incur a method call overhead. However, don't these simple getters/setters always get in-lined by the JIT? I know you can't guarantee what the JIT decides to do, but surely this is fairly high on the list of probability? What else is there that separates a public field from a property at the machine level?\n\nAnd one thing I've been wondering: how is an auto-implemented property ( ) 'better' OO-design than a public field? Or better said: how are those two different? I know that making it a property is easier with reflection, but anything else? I bet the answer to both questions is the same thing.\n\nBTW: I am using .NET 3.5 SP1 which I believe fixed issues where methods with structs (or methods of structs, I'm not sure) weren't in-lined, so that isn't it. I think I am using it at least, it's certainly installed but then again, I'm using Vista 64-bit with SP1 which should have DX10.1 except that I don't have DX10.1 ..\n\nEDIT: I appreciate the quick answers guys, but I indicated that I do know that a property access is a method call, but that I don't know why the, presumably, in-lined method is slower than a direct field access.\n\nEDIT 2: So I created another that used explicit GetX() methods (o how I don't miss my Java days at all) and that performed the same whether I disabled in-lining on it (through ) or not, so conclusion: non-static methods are apparently never inlined, not even on structs.\n\nI thought that there were exceptions, where the JIT could optmize the virtual method call away. Why can't this happen on structs which know no inheritance and thus a method call can only point to one possible method, right? Or is that because you can implement an interface on it?\n\nThis is kind of a shame, since it will really make me think about using properties on performance critical stuff, yet using fields makes me feel dirty and I might as well write what I'm doing in C.\n\nEDIT 3: I found this posting about the exact same subject. His end conclusion is that the property call did get optimized away. I also could've sworn that I've read plenty of times that simple getter/setter properties will get in-lined, despite being in the IL. So am I going insane?\n\nEDIT 4: Reed Copsey posted the answer in a comment below:\n\nAnd my response to his answer:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/deserialization",
        "document": "How to read JSON as .NET objects (deserialize)\n\nThis article shows how to use the System.Text.Json namespace to deserialize from JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nA common way to deserialize JSON is to have (or create) a .NET class with properties and fields that represent one or more of the JSON properties. Then, to deserialize from a string or a file, call the JsonSerializer.Deserialize method. For the generic overloads, the generic type parameter is the .NET class. For the non-generic overloads, you pass the type of the class as a method parameter. You can deserialize either synchronously or asynchronously.\n\nAny JSON properties that aren't represented in your class are ignored by default. Also, if any properties on the type are required but not present in the JSON payload, deserialization will fail.\n\nThe following example shows how to deserialize a JSON string:\n\nTo deserialize from a file by using synchronous code, read the file into a string, as shown in the following example:\n\nTo deserialize from a file by using asynchronous code, call the DeserializeAsync method:\n\nThe following behaviors apply when deserializing JSON:\n• By default, property name matching is case-sensitive. You can specify case-insensitivity.\n• Non-public constructors are ignored by the serializer.\n• Deserialization to immutable objects or properties that don't have public accessors is supported but not enabled by default. See Immutable types and records.\n• By default, enums are supported as numbers. You can deserialize string enum fields.\n• By default, fields are ignored. You can include fields.\n• By default, comments or trailing commas in the JSON throw exceptions. You can allow comments and trailing commas.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n\nYou can implement custom converters to provide functionality that isn't supported by the built-in converters.\n\nIf you have JSON that you want to deserialize, and you don't have the class to deserialize it into, you have options other than manually creating the class that you need:\n• None Deserialize into a JSON DOM (document object model) and extract what you need from the DOM. The DOM lets you navigate to a subsection of a JSON payload and deserialize a single value, a custom type, or an array. For information about the JsonNode DOM, see Deserialize subsections of a JSON payload. For information about the JsonDocument DOM, see How to search a JsonDocument and JsonElement for sub-elements.\n• None Use Visual Studio 2022 to automatically generate the class you need:\n• Copy the JSON that you need to deserialize. The result is a class that you can use for your deserialization target.\n\nTo deserialize from UTF-8, call a JsonSerializer.Deserialize overload that takes a or a , as shown in the following examples. The examples assume the JSON is in a byte array named jsonUtf8Bytes.\n\nYou can use GitHub Copilot in your IDE to generate code that uses to deserialize from JSON. You can customize the prompt to use a JSON string with property names and values that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://stackoverflow.com/questions/67068454/using-jsonconvert-deserializeobject-method-for-nested-attributes-in-c-sharp",
        "document": "Option 1 is to parse or query json. please see the official Querying JSON with LINQ or Querying JSON with SelectToken for Json.NET or JsonDocument.Parse for the new System.Text.Json serialiser.\n\nIf you want/need to use then you will need to create a set of classes that represents your data."
    },
    {
        "link": "https://newtonsoft.com/json/help/html/Overload_Newtonsoft_Json_JsonConvert_DeserializeObject.htm",
        "document": "Deserializes the JSON to the specified .NET type.\n\nDeserializes the JSON to the specified .NET type using a collection of JsonConverter\n\nDeserializes the JSON to a .NET object using JsonSerializerSettings\n\nDeserializes the JSON to the specified .NET type using JsonSerializerSettings\n\nDeserializes the JSON to the specified .NET type.\n\nDeserializes the JSON to the specified .NET type using a collection of JsonConverter\n\nDeserializes the JSON to the specified .NET type using JsonSerializerSettings"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview",
        "document": "The System.Text.Json namespace provides functionality for serializing to and deserializing from (or marshalling and unmarshalling) JavaScript Object Notation (JSON). Serialization is the process of converting the state of an object, that is, the values of its properties, into a form that can be stored or transmitted. The serialized form doesn't include any information about an object's associated methods. Deserialization reconstructs an object from the serialized form.\n\nThe library design emphasizes high performance and low memory allocation over an extensive feature set. Built-in UTF-8 support optimizes the process of reading and writing JSON text encoded as UTF-8, which is the most prevalent encoding for data on the web and files on disk.\n\nThe library also provides classes for working with an in-memory document object model (DOM). This feature enables random access to the elements in a JSON file or string.\n\nFor Visual Basic, there are some limitations on what parts of the library you can use. For more information, see Visual Basic support.\n\nHow to get the library\n\nThe library is built-in as part of the shared framework for .NET Core 3.0 and later versions. The source generation feature is built-in as part of the shared framework for .NET 6 and later versions.\n\nFor framework versions earlier than .NET Core 3.0, install the System.Text.Json NuGet package. The package supports:\n• The System.Text.Json namespace contains all the entry points and the main types.\n• The System.Text.Json.Serialization namespace contains attributes and APIs for advanced scenarios and customization specific to serialization and deserialization.\n• The System.Net.Http.Json namespace contains extension methods for serializing and deserializing JSON payloads from the network.\n\nBy default, gathers the metadata it needs to access properties of objects for serialization and deserialization at run time using reflection. As an alternative, can use the C# source generation feature to improve performance, reduce private memory usage, and facilitate assembly trimming, which reduces app size.\n\nFor more information, see Reflection versus source generation.\n\nFor information about security threats that were considered when designing JsonSerializer, and how they can be mitigated, see Threat Model.\n\nThe serializer was designed with thread safety in mind. Practically, this means that once locked, JsonSerializerOptions instances can be safely shared across multiple threads. JsonDocument provides an immutable, and in .NET 8 and later versions, thread-safe, DOM representation for JSON values.\n• How to use the library"
    },
    {
        "link": "https://newtonsoft.com/json/help/html/introduction.htm",
        "document": "\n• None Flexible JSON serializer for converting between .NET objects and JSON\n• None LINQ to JSON for manually reading and writing JSON\n• None Convert JSON to and from XML The JSON serializer in Json.NET is a good choice when the JSON you are reading or writing maps closely to a .NET class. LINQ to JSON is good for situations where you are only interested in getting values from JSON, you don't have a class to serialize or deserialize to, or the JSON is radically different from your class and you need to manually read and write from your objects.\n\nJson.NET grew out of projects I was working on in late 2005 involving JavaScript, AJAX, and .NET. At the time there were no libraries for working with JavaScript in .NET, so I made my own. Starting out as a couple of static methods for escaping JavaScript strings, Json.NET evolved as features were added. To add support for reading JSON a major refactor was required, and Json.NET was split into the three major classes it still uses today: JsonReader, JsonWriter and JsonSerializer. Json.NET was first released in June 2006. Since then Json.NET has been downloaded hundreds of thousands of times by developers from around the world. It is used in many major open source projects, including: Mono, an open source implementation of the .NET framework; RavenDB, a JSON based document database; ASP.NET SignalR, an async library for building real-time, multi-user interactive web applications; and ASP.NET Core, Microsoft's web app and service framework."
    }
]