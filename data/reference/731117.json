[
    {
        "link": "https://go.dev/tour/moretypes/13",
        "document": ""
    },
    {
        "link": "https://tip.golang.org/doc/go1.19",
        "document": "The latest Go release, version 1.19, arrives five months after Go 1.18. Most of its changes are in the implementation of the toolchain, runtime, and libraries. As always, the release maintains the Go 1 promise of compatibility. We expect almost all Go programs to continue to compile and run as before.\n\nChanges to the language\n\nThere is only one small change to the language, a very small correction to the scope of type parameters in method declarations. Existing programs are unaffected.\n\nThe Go memory model has been revised to align Go with the memory model used by C, C++, Java, JavaScript, Rust, and Swift. Go only provides sequentially consistent atomics, not any of the more relaxed forms found in other languages. Along with the memory model update, Go 1.19 introduces new types in the package that make it easier to use atomic values, such as atomic.Int64 and atomic.Pointer[T].\n\nGo 1.19 adds support for the Loongson 64-bit architecture LoongArch on Linux ( , ). The implemented ABI is LP64D. Minimum kernel version supported is 5.19.\n\nNote that most existing commercial Linux distributions for LoongArch come with older kernels, with a historical incompatible system call ABI. Compiled binaries will not work on these systems, even if statically linked. Users on such unsupported systems are limited to the distribution-provided Go package.\n\nThe port now supports passing function arguments and result using registers. Benchmarking shows typical performance improvements of 10% or more on .\n\nGo 1.19 adds support for links, lists, and clearer headings in doc comments. As part of this change, now reformats doc comments to make their rendered meaning clearer. See “Go Doc Comments” for syntax details and descriptions of common mistakes now highlighted by . As another part of this change, the new package go/doc/comment provides parsing and reformatting of doc comments as well as support for rendering them to HTML, Markdown, and text.\n\nThe build constraint is now recognized in lines. The constraint is satisfied if the target operating system, also known as , is a Unix or Unix-like system. For the 1.19 release it is satisfied if is one of , , , , , , , , , , , or . In future releases the constraint may match additional newly supported operating systems.\n\nThe flag, if set, is now included in the build settings stamped into Go binaries by , and can be examined using or .\n\nnow sets the environment variable explicitly in the generator’s environment, so that generators can locate the correct even if built with .\n\nand now place at the beginning of the used for the subprocess, so tests and generators that execute the command will resolve it to same .\n\nnow quotes entries that contain spaces in the , , , , , and variables it reports.\n\nnow accepts a comma-separated list of JSON fields to populate. If a list is specified, the JSON output will include only those fields, and may avoid work to compute fields that are not included. In some cases, this may suppress errors that would otherwise be reported.\n\nThe command now caches information necessary to load some modules, which should result in a speed-up of some invocations.\n\nThe checker “errorsas” now reports when is called with a second argument of type , a common mistake.\n\nThe runtime now includes support for a soft memory limit. This memory limit includes the Go heap and all other memory managed by the runtime, and excludes external memory sources such as mappings of the binary itself, memory managed in other languages, and memory held by the operating system on behalf of the Go program. This limit may be managed via or the equivalent environment variable. The limit works in conjunction with / , and will be respected even if , allowing Go programs to always make maximal use of their memory limit, improving resource efficiency in some cases. See the GC guide for a detailed guide explaining the soft memory limit in more detail, as well as a variety of common use-cases and scenarios. Please note that small memory limits, on the order of tens of megabytes or less, are less likely to be respected due to external latency factors, such as OS scheduling. See issue 52433 for more details. Larger memory limits, on the order of hundreds of megabytes or more, are stable and production-ready.\n\nIn order to limit the effects of GC thrashing when the program’s live heap size approaches the soft memory limit, the Go runtime also attempts to limit total GC CPU utilization to 50%, excluding idle time, choosing to use more memory over preventing application progress. In practice, we expect this limit to only play a role in exceptional cases, and the new runtime metric reports when this last occurred.\n\nThe runtime now schedules many fewer GC worker goroutines on idle operating system threads when the application is idle enough to force a periodic GC cycle.\n\nThe runtime will now allocate initial goroutine stacks based on the historic average stack usage of goroutines. This avoids some of the early stack growth and copying needed in the average case in exchange for at most 2x wasted space on below-average goroutines.\n\nOn Unix operating systems, Go programs that import package os now automatically increase the open file limit ( ) to the maximum allowed value; that is, they change the soft limit to match the hard limit. This corrects artificially low limits set on some systems for compatibility with very old C programs using the select system call. Go programs are not helped by that limit, and instead even simple programs like often ran out of file descriptors on such systems when processing many files in parallel. One impact of this change is that Go programs that in turn execute very old C programs in child processes may run those programs with too high a limit. This can be corrected by setting the hard limit before invoking the Go program.\n\nUnrecoverable fatal errors (such as concurrent map writes, or unlock of unlocked mutexes) now print a simpler traceback excluding runtime metadata (equivalent to a fatal panic) unless or . Runtime-internal fatal error tracebacks always include full metadata regardless of the value of\n\nSupport for debugger-injected function calls has been added on ARM64, enabling users to call functions from their binary in an interactive debugging session when using a debugger that is updated to make use of this functionality.\n\nThe address sanitizer support added in Go 1.18 now handles function arguments and global variables more precisely.\n\nThe compiler now uses a jump table to implement large integer and string switch statements. Performance improvements for the switch statement vary but can be on the order of 20% faster. ( and only)\n\nThe Go compiler now requires the flag to build a linkable object file. This is already supplied by the command and by Bazel. Any other build systems that invoke the Go compiler directly will need to make sure they pass this flag as well.\n\nThe Go compiler no longer accepts the flag. Build systems that invoke the Go compiler directly must use the flag instead.\n\nLike the compiler, the assembler now requires the flag to build a linkable object file. This is already supplied by the command. Any other build systems that invoke the Go assembler directly will need to make sure they pass this flag as well.\n\nOn ELF platforms, the linker now emits compressed DWARF sections in the standard gABI format ( ), instead of the legacy format.\n\nThe package defines new atomic types , , , , , , and . These types hide the underlying values so that all accesses are forced to use the atomic APIs. also avoids the need to convert to at call sites. and are automatically aligned to 64-bit boundaries in structs and allocated data, even on 32-bit systems.\n\nand no longer allow results from a PATH search to be found relative to the current directory. This removes a common source of security problems but may also break existing programs that depend on using, say, to run a binary named (or, on Windows, ) in the current directory. See the package documentation for information about how best to update such programs.\n\nOn Windows, and now respect the environment variable, making it possible to disable the default implicit search of “ ” in PATH lookups on Windows systems.\n\nMinor changes to the library\n\nAs always, there are various minor changes and updates to the library, made with the Go 1 promise of compatibility in mind. There are also various performance improvements, not enumerated here.\n\nnow ignores non-ZIP data at the start of a ZIP file, matching most other implementations. This is necessary to read some Java JAR files, among other uses.\n\nOperating on invalid curve points (those for which the method returns false, and which are never returned by or by a method operating on a valid point) has always been undefined behavior and can lead to key recovery attacks. If an invalid point is supplied to , , , , or , they will now panic.\n\noperations on the , , and curves are now up to three times faster, leading to similar speedups in some ECDSA operations. The generic (not platform optimized) implementation was replaced with one derived from a formally verified model; this might lead to significant slowdowns on 32-bit platforms.\n\nno longer buffers random data obtained from the operating system between calls. Applications that perform many small reads at high frequency might choose to wrap in a for performance reasons, taking care to use to ensure no partial reads occur.\n\nOn Plan 9, has been reimplemented, replacing the ANSI X9.31 algorithm with a fast key erasure generator.\n\nThe implementation was changed to use only rejection sampling, which removes a bias when generating small primes in non-cryptographic contexts, removes one possible minor timing leak, and better aligns the behavior with BoringSSL, all while simplifying the implementation. The change does produce different outputs for a given random source stream compared to the previous implementation, which can break tests written expecting specific results from specific deterministic random sources. To help prevent such problems in the future, the implementation is now intentionally non-deterministic with respect to the input stream.\n\nThe option has been removed. It is still possible to enable TLS 1.0 client-side by setting .\n\nThe TLS server and client now reject duplicate extensions in TLS handshakes, as required by RFC 5246, Section 7.4.1.4 and RFC 8446, Section 4.2.\n\nno longer supports creating certificates with set to .\n\nwill not emit an empty SEQUENCE anymore when the produced certificate has no extensions.\n\nRemoval of the option , originally planned for Go 1.19, has been rescheduled to a future release. Applications using it should work on migrating. Practical attacks against SHA-1 have been demonstrated since 2017 and publicly trusted Certificate Authorities have not issued SHA-1 certificates since 2015.\n\nand now reject certificates and CSRs which contain duplicate extensions.\n\nThe new and methods allow cloning a and checking the equivalence of two s respectively.\n\nThe new function provides a faster, safer to use CRL parser which returns a . Parsing a CRL also populates the new fields , , , and , which are ignored by .\n\nThe new method checks that the signature on a CRL is a valid signature from a .\n\nThe and functions are now deprecated in favor of . The method is deprecated in favor of .\n\nThe path builder of was overhauled and should now produce better chains and/or be more efficient in complicated scenarios. Name constraints are now also enforced on non-leaf certificates.\n\nThe types and have been deprecated. The new CRL functionality should be used instead.\n\nThe new and constants support the loong64 port.\n\nThe new method, which returns a , provides access to COMDAT information in PE file sections. These are supported by new and constants.\n\nThe new interface provides efficient methods for appending a , , or to a byte slice. and now implement this interface.\n\nSimilarly, the new functions and are efficient appending versions of and .\n\nThe new method reports the reader’s current input position as a byte offset, analogous to ’s .\n\nThe new method reports the reader’s current input position as a line and column, analogous to ’s .\n\nThe new function defines a flag with a value implementing , allowing command-line flag variables to have types such as , , and .\n\nThe new functions , , and append formatted data to byte slices.\n\nThe parser now recognizes as a unary expression with operator token.TILDE, allowing better error recovery when a type constraint such as is used in an incorrect context.\n\nThe new methods and return the corresponding of the generic type for synthetic and objects created during type instantiation.\n\nIt is no longer possible to produce an infinite number of distinct-but-identical type instantiations via recursive calls to or .\n\nThe new functions and provide an efficient way hash a single byte slice or string. They are equivalent to using the more general with a single write, but they avoid setup overhead for small inputs.\n\nThe type is now an alias for ’s instead of its own named type. This allows writing code that operates on a from either setting.\n\nGo 1.19.8 and later disallow actions in ECMAScript 6 template literals. This behavior can be reverted by the setting.\n\nwith the operator preserves non-premultiplied-alpha colors when destination and source images are both or both . This reverts a behavior change accidentally introduced by a Go 1.18 library optimization; the code now matches the behavior in Go 1.17 and earlier.\n\n’s result now implements whenever its input does.\n\n’s result now implements unconditionally. If any underlying reader does not implement , it is simulated appropriately.\n\nOn Windows only, the mime package now ignores a registry entry recording that the extension should have MIME type . This is a common unintentional misconfiguration on Windows systems. The effect is that will have the default MIME type . Applications that expect on Windows must now explicitly call .\n\nIn Go 1.19.8 and later, this package sets limits the size of the MIME data it processes to protect against malicious inputs. and limit the number of headers in a part to 10000 and limits the total number of headers in all to 10000. These limits may be adjusted with the setting. further limits the number of parts in a form to 1000. This limit may be adjusted with the setting.\n\nThe pure Go resolver will now use EDNS(0) to include a suggested maximum reply packet length, permitting reply packets to contain up to 1232 bytes (the previous maximum was 512). In the unlikely event that this causes problems with a local DNS resolver, setting the environment variable to use the cgo-based resolver should work. Please report any such problems on the issue tracker.\n\nWhen a net package function or method returns an “I/O timeout” error, the error will now satisfy . When a net package function returns an “operation was canceled” error, the error will now satisfy . These changes are intended to make it easier for code to test for cases in which a context cancellation or timeout causes a net package function or method to return an error, while preserving backward compatibility for error messages.\n\nis now implemented on Windows and Plan 9. It previously only worked on Unix platforms. Combined with and , it’s now possible to write portable programs and be in control of all DNS name lookups when dialing.\n\nThe package now has initial support for the build tag on Windows. When used, the package uses the Go DNS client (as used by ) instead of asking Windows for DNS results. The upstream DNS server it discovers from Windows may not yet be correct with complex system network configurations, however.\n\nThe returned by will now return the defined error type when its read limit is exceeded.\n\nThe HTTP client will handle a 3xx response without a header by returning it to the caller, rather than treating it as an error.\n\nThe new function and method create a new by joining a list of path elements.\n\nThe type now distinguishes between URLs with no authority and URLs with an empty authority. For example, has an empty authority (host), while has none.\n\nThe new field is set to when a has an empty authority.\n\nA with a non-empty field and nil now implicitly sets the environment variable for the subprocess to match .\n\nThe new method reports the environment that would be used to run the command, including the implicitly set variable.\n\nThe method now accepts addressable arrays in addition to slices.\n\nThe methods and now successfully operate on a pointer to an array and return the length of that array, to match what the builtin and functions do.\n\nGo 1.18 release candidate 1, Go 1.17.8, and Go 1.16.15 included a security fix to the regular expression parser, making it reject very deeply nested expressions. Because Go patch releases do not introduce new API, the parser returned in this case. Go 1.19 adds a more specific error, , which the parser now returns instead.\n\nThe function now returns the empty string (instead of ) when the binary was built with the flag set and the variable is not set in the process environment.\n\nThe new metric reports the current value.\n\nThe new metric reports the total number of calls made from Go to C. This metric is identical to the function.\n\nThe new metric reports the last GC cycle when the GC CPU limiter was enabled. See the runtime notes for details about the GC CPU limiter.\n\nStop-the-world pause times have been significantly reduced when collecting goroutine profiles, reducing the overall latency impact to the application.\n\nis now reported in heap profiles for all Unix operating systems (it was previously only reported for , , , and ).\n\nThe race detector has been upgraded to use thread sanitizer version v3 on all supported platforms except and , which remain on v2. Compared to v2, it is now typically 1.5x to 2x faster, uses half as much memory, and it supports an unlimited number of goroutines. On Linux, the race detector now requires at least glibc version 2.17 and GNU binutils 2.26.\n\nThe race detector is now supported on .\n\nRace detector support for has been removed from thread sanitizer upstream, so it is unlikely to ever be updated from v2.\n\nWhen tracing and the CPU profiler are enabled simultaneously, the execution trace includes CPU profile samples as instantaneous events.\n\nThe sorting algorithm has been rewritten to use pattern-defeating quicksort, which is faster for several common scenarios.\n\nThe new function is like but often easier to use: it returns an additional boolean reporting whether an equal value was found.\n\nand related functions now quote the rune U+007F as , not , for consistency with other ASCII values.\n\nOn PowerPC ( , ), , , , and now always return 0 for return value instead of an undefined value.\n\nOn AIX and Solaris, is now defined.\n\nThe new method provides a convenient and safe way to take the absolute value of a duration, converting −2⁶³ to 2⁶³−1. (This boundary case can happen as the result of subtracting a recent time from the zero time.)\n\nThe new method returns the start and end times of the time zone in effect at a given time. It can be used in a loop to enumerate all the known time zone transitions at a given location."
    },
    {
        "link": "https://reddit.com/r/golang/comments/ybw3l0/go_119_overview_and_plans_for_q1_2023_120_version",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://pkg.go.dev/slices",
        "document": "Package slices defines various functions useful with slices of any type.\n\nBinarySearch searches for target in a sorted slice and returns the earliest position where target is found, or the position where target would appear in the sort order; it also returns a bool saying whether the target is really found in the slice. The slice must be sorted in increasing order.\n\nBinarySearchFunc works like BinarySearch, but uses a custom comparison function. The slice must be sorted in increasing order, where \"increasing\" is defined by cmp. cmp should return 0 if the slice element matches the target, a negative number if the slice element precedes the target, or a positive number if the slice element follows the target. cmp must implement the same ordering as the slice, such that if cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.\n\nChunk returns an iterator over consecutive sub-slices of up to n elements of s. All but the last sub-slice will have size n. All sub-slices are clipped to have no capacity beyond the length. If s is empty, the sequence is empty: there is no empty slice in the sequence. Chunk panics if n is less than 1. package main import ( \"fmt\" \"slices\" ) func main() { type Person struct { Name string Age int } type People []Person people := People{ {\"Gopher\", 13}, {\"Alice\", 20}, {\"Bob\", 5}, {\"Vera\", 24}, {\"Zac\", 15}, } // Chunk people into []Person 2 elements at a time. for c := range slices.Chunk(people, 2) { fmt.Println(c) } }\n\nCompare compares the elements of s1 and s2, using cmp.Compare on each pair of elements. The elements are compared sequentially, starting at index 0, until one element is not equal to the other. The result of comparing the first non-matching elements is returned. If both slices are equal until one of them ends, the shorter slice is considered less than the longer one. The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.\n\nDelete removes the elements s[i:j] from s, returning the modified slice. Delete panics if j > len(s) or s[i:j] is not a valid slice of s. Delete is O(len(s)-i), so if many items must be deleted, it is better to make a single call deleting them all together than to delete one at a time. Delete zeroes the elements s[len(s)-(j-i):len(s)].\n\nEqual reports whether two slices are equal: the same length and all elements equal. If the lengths are different, Equal returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first unequal pair. Empty and nil slices are considered equal. Floating point NaNs are not considered equal.\n\nSortFunc sorts the slice x in ascending order as determined by the cmp function. This sort is not guaranteed to be stable. cmp(a, b) should return a negative number when a < b, a positive number when a > b and zero when a == b or a and b are incomparable in the sense of a strict weak ordering. SortFunc requires that cmp is a strict weak ordering. See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings. The function should return 0 for incomparable items. package main import ( \"cmp\" \"fmt\" \"slices\" \"strings\" ) func main() { type Person struct { Name string Age int } people := []Person{ {\"Gopher\", 13}, {\"Alice\", 55}, {\"Bob\", 24}, {\"Alice\", 20}, } slices.SortFunc(people, func(a, b Person) int { if n := strings.Compare(a.Name, b.Name); n != 0 { return n } // If names are equal, order by age return cmp.Compare(a.Age, b.Age) }) fmt.Println(people) }"
    },
    {
        "link": "https://stackoverflow.com/questions/27938177/golang-slice-slicing-a-slice-with-sliceabc",
        "document": "I read go slice usage and internals and Slice and Effective go#slice but there is nothing about slicing a slice with 3 number like this :\n\nFor example this code :\n\ngo playground result is this :\n\nI can understand that the third one is something about capacity, but what is the exact meaning of this?\n\n Do I miss something in documents?"
    },
    {
        "link": "https://pkg.go.dev/fmt",
        "document": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\n\nString and slice of bytes (treated equivalently with these verbs):\n\nThe default format for %v is:\n\nFor compound objects, the elements are printed using these rules, recursively, laid out like this:\n\nWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:\n\nWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in strconv.QuoteRune.\n\nFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:\n\nExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\nconvert the value before recurring:\n\nInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:\n\nIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:\n\nAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error, String, or GoString method, however, the output is the undecorated string, \"<nil>\".\n\nAn analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,\n\nwill set s to \"12345\" and i to 67 while\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\n\n means the same as \n\n).\n\nIn all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.\n\nThese examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details. package main import ( \"fmt\" \"math\" \"time\" ) func main() { // A basic set of examples showing that %v is the default format, in this // case decimal for integers, which can be explicitly requested with %d; // the output is just what Println generates. integer := 23 // Each of these prints \"23\" (without the quotes). fmt.Println(integer) fmt.Printf(\"%v\n\n\", integer) fmt.Printf(\"%d\n\n\", integer) // The special verb %T shows the type of an item rather than its value. fmt.Printf(\"%T %T\n\n\", integer, &integer) // Result: int *int // Println(x) is the same as Printf(\"%v\n\n\", x) so we will use only Printf // in the following examples. Each one demonstrates how to format values of // a particular type, such as integers or strings. We start each format // string with %v to show the default output and follow that with one or // more custom formats. // Booleans print as \"true\" or \"false\" with %v or %t. truth := true fmt.Printf(\"%v %t\n\n\", truth, truth) // Result: true true // Integers print as decimals with %v and %d, // or in hex with %x, octal with %o, or binary with %b. answer := 42 fmt.Printf(\"%v %d %x %o %b\n\n\", answer, answer, answer, answer, answer) // Result: 42 42 2a 52 101010 // Floats have multiple formats: %v and %g print a compact representation, // while %f prints a decimal point and %e uses exponential notation. The // format %6.2f used here shows how to set the width and precision to // control the appearance of a floating-point value. In this instance, 6 is // the total width of the printed text for the value (note the extra spaces // in the output) and 2 is the number of decimal places to show. pi := math.Pi fmt.Printf(\"%v %g %.2f (%6.2f) %e\n\n\", pi, pi, pi, pi, pi) // Result: 3.141592653589793 3.141592653589793 3.14 ( 3.14) 3.141593e+00 // Complex numbers format as parenthesized pairs of floats, with an 'i' // after the imaginary part. point := 110.7 + 22.5i fmt.Printf(\"%v %g %.2f %.2e\n\n\", point, point, point, point) // Result: (110.7+22.5i) (110.7+22.5i) (110.70+22.50i) (1.11e+02+2.25e+01i) // Runes are integers but when printed with %c show the character with that // Unicode value. The %q verb shows them as quoted characters, %U as a // hex Unicode code point, and %#U as both a code point and a quoted // printable form if the rune is printable. smile := '😀' fmt.Printf(\"%v %d %c %q %U %#U\n\n\", smile, smile, smile, smile, smile, smile) // Result: 128512 128512 😀 '😀' U+1F600 U+1F600 '😀' // Strings are formatted with %v and %s as-is, with %q as quoted strings, // and %#q as backquoted strings. placeholders := `foo \"bar\"` fmt.Printf(\"%v %s %q %#q\n\n\", placeholders, placeholders, placeholders, placeholders) // Result: foo \"bar\" foo \"bar\" \"foo \\\"bar\\\"\" `foo \"bar\"` // Maps formatted with %v show keys and values in their default formats. // The %#v form (the # is called a \"flag\" in this context) shows the map in // the Go source format. Maps are printed in a consistent order, sorted // by the values of the keys. isLegume := map[string]bool{ \"peanut\": true, \"dachshund\": false, } fmt.Printf(\"%v %#v\n\n\", isLegume, isLegume) // Result: map[dachshund:false peanut:true] map[string]bool{\"dachshund\":false, \"peanut\":true} // Structs formatted with %v show field values in their default formats. // The %+v form shows the fields by name, while %#v formats the struct in // Go source format. person := struct { Name string Age int }{\"Kim\", 22} fmt.Printf(\"%v %+v %#v\n\n\", person, person, person) // Result: {Kim 22} {Name:Kim Age:22} struct { Name string; Age int }{Name:\"Kim\", Age:22} // The default format for a pointer shows the underlying value preceded by // an ampersand. The %p verb prints the pointer value in hex. We use a // typed nil for the argument to %p here because the value of any non-nil // pointer would change from run to run; run the commented-out Printf // call yourself to see. pointer := &person fmt.Printf(\"%v %p\n\n\", pointer, (*int)(nil)) // Result: &{Kim 22} 0x0 // fmt.Printf(\"%v %p\n\n\", pointer, pointer) // Result: &{Kim 22} 0x010203 // See comment above. // Arrays and slices are formatted by applying the format to each element. greats := [5]string{\"Kitano\", \"Kobayashi\", \"Kurosawa\", \"Miyazaki\", \"Ozu\"} fmt.Printf(\"%v %q\n\n\", greats, greats) // Result: [Kitano Kobayashi Kurosawa Miyazaki Ozu] [\"Kitano\" \"Kobayashi\" \"Kurosawa\" \"Miyazaki\" \"Ozu\"] kGreats := greats[:3] fmt.Printf(\"%v %q %#v\n\n\", kGreats, kGreats, kGreats) // Result: [Kitano Kobayashi Kurosawa] [\"Kitano\" \"Kobayashi\" \"Kurosawa\"] []string{\"Kitano\", \"Kobayashi\", \"Kurosawa\"} // Byte slices are special. Integer verbs like %d print the elements in // that format. The %s and %q forms treat the slice like a string. The %x // verb has a special form with the space flag that puts a space between // the bytes. cmd := []byte(\"a⌘\") fmt.Printf(\"%v %d %s %q %x % x\n\n\", cmd, cmd, cmd, cmd, cmd, cmd) // Result: [97 226 140 152] [97 226 140 152] a⌘ \"a⌘\" 61e28c98 61 e2 8c 98 // Types that implement Stringer are printed the same as strings. Because // Stringers return a string, we can print them using a string-specific // verb such as %q. now := time.Unix(123456789, 0).UTC() // time.Time implements fmt.Stringer. fmt.Printf(\"%v %q\n\n\", now, now) // Result: 1973-11-29 21:33:09 +0000 UTC \"1973-11-29 21:33:09 +0000 UTC\" }"
    },
    {
        "link": "https://go.dev/pkg/fmt?m=old",
        "document": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\n\nString and slice of bytes (treated equivalently with these verbs):\n\nThe default format for %v is:\n\nFor compound objects, the elements are printed using these rules, recursively, laid out like this:\n\nWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:\n\nWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in strconv.QuoteRune.\n\nFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:\n\nExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\nconvert the value before recurring:\n\nInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:\n\nIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:\n\nAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error, String, or GoString method, however, the output is the undecorated string, \"<nil>\".\n\nAn analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,\n\nwill set s to \"12345\" and i to 67 while\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\n\n means the same as \n\n).\n\nIn all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.\n\nThese examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details. package main import ( \"fmt\" \"math\" \"time\" ) func main() { // A basic set of examples showing that %v is the default format, in this // case decimal for integers, which can be explicitly requested with %d; // the output is just what Println generates. integer := 23 // Each of these prints \"23\" (without the quotes). fmt.Println(integer) fmt.Printf(\"%v\n\n\", integer) fmt.Printf(\"%d\n\n\", integer) // The special verb %T shows the type of an item rather than its value. fmt.Printf(\"%T %T\n\n\", integer, &integer) // Result: int *int // Println(x) is the same as Printf(\"%v\n\n\", x) so we will use only Printf // in the following examples. Each one demonstrates how to format values of // a particular type, such as integers or strings. We start each format // string with %v to show the default output and follow that with one or // more custom formats. // Booleans print as \"true\" or \"false\" with %v or %t. truth := true fmt.Printf(\"%v %t\n\n\", truth, truth) // Result: true true // Integers print as decimals with %v and %d, // or in hex with %x, octal with %o, or binary with %b. answer := 42 fmt.Printf(\"%v %d %x %o %b\n\n\", answer, answer, answer, answer, answer) // Result: 42 42 2a 52 101010 // Floats have multiple formats: %v and %g print a compact representation, // while %f prints a decimal point and %e uses exponential notation. The // format %6.2f used here shows how to set the width and precision to // control the appearance of a floating-point value. In this instance, 6 is // the total width of the printed text for the value (note the extra spaces // in the output) and 2 is the number of decimal places to show. pi := math.Pi fmt.Printf(\"%v %g %.2f (%6.2f) %e\n\n\", pi, pi, pi, pi, pi) // Result: 3.141592653589793 3.141592653589793 3.14 ( 3.14) 3.141593e+00 // Complex numbers format as parenthesized pairs of floats, with an 'i' // after the imaginary part. point := 110.7 + 22.5i fmt.Printf(\"%v %g %.2f %.2e\n\n\", point, point, point, point) // Result: (110.7+22.5i) (110.7+22.5i) (110.70+22.50i) (1.11e+02+2.25e+01i) // Runes are integers but when printed with %c show the character with that // Unicode value. The %q verb shows them as quoted characters, %U as a // hex Unicode code point, and %#U as both a code point and a quoted // printable form if the rune is printable. smile := '😀' fmt.Printf(\"%v %d %c %q %U %#U\n\n\", smile, smile, smile, smile, smile, smile) // Result: 128512 128512 😀 '😀' U+1F600 U+1F600 '😀' // Strings are formatted with %v and %s as-is, with %q as quoted strings, // and %#q as backquoted strings. placeholders := `foo \"bar\"` fmt.Printf(\"%v %s %q %#q\n\n\", placeholders, placeholders, placeholders, placeholders) // Result: foo \"bar\" foo \"bar\" \"foo \\\"bar\\\"\" `foo \"bar\"` // Maps formatted with %v show keys and values in their default formats. // The %#v form (the # is called a \"flag\" in this context) shows the map in // the Go source format. Maps are printed in a consistent order, sorted // by the values of the keys. isLegume := map[string]bool{ \"peanut\": true, \"dachshund\": false, } fmt.Printf(\"%v %#v\n\n\", isLegume, isLegume) // Result: map[dachshund:false peanut:true] map[string]bool{\"dachshund\":false, \"peanut\":true} // Structs formatted with %v show field values in their default formats. // The %+v form shows the fields by name, while %#v formats the struct in // Go source format. person := struct { Name string Age int }{\"Kim\", 22} fmt.Printf(\"%v %+v %#v\n\n\", person, person, person) // Result: {Kim 22} {Name:Kim Age:22} struct { Name string; Age int }{Name:\"Kim\", Age:22} // The default format for a pointer shows the underlying value preceded by // an ampersand. The %p verb prints the pointer value in hex. We use a // typed nil for the argument to %p here because the value of any non-nil // pointer would change from run to run; run the commented-out Printf // call yourself to see. pointer := &person fmt.Printf(\"%v %p\n\n\", pointer, (*int)(nil)) // Result: &{Kim 22} 0x0 // fmt.Printf(\"%v %p\n\n\", pointer, pointer) // Result: &{Kim 22} 0x010203 // See comment above. // Arrays and slices are formatted by applying the format to each element. greats := [5]string{\"Kitano\", \"Kobayashi\", \"Kurosawa\", \"Miyazaki\", \"Ozu\"} fmt.Printf(\"%v %q\n\n\", greats, greats) // Result: [Kitano Kobayashi Kurosawa Miyazaki Ozu] [\"Kitano\" \"Kobayashi\" \"Kurosawa\" \"Miyazaki\" \"Ozu\"] kGreats := greats[:3] fmt.Printf(\"%v %q %#v\n\n\", kGreats, kGreats, kGreats) // Result: [Kitano Kobayashi Kurosawa] [\"Kitano\" \"Kobayashi\" \"Kurosawa\"] []string{\"Kitano\", \"Kobayashi\", \"Kurosawa\"} // Byte slices are special. Integer verbs like %d print the elements in // that format. The %s and %q forms treat the slice like a string. The %x // verb has a special form with the space flag that puts a space between // the bytes. cmd := []byte(\"a⌘\") fmt.Printf(\"%v %d %s %q %x % x\n\n\", cmd, cmd, cmd, cmd, cmd, cmd) // Result: [97 226 140 152] [97 226 140 152] a⌘ \"a⌘\" 61e28c98 61 e2 8c 98 // Types that implement Stringer are printed the same as strings. Because // Stringers return a string, we can print them using a string-specific // verb such as %q. now := time.Unix(123456789, 0).UTC() // time.Time implements fmt.Stringer. fmt.Printf(\"%v %q\n\n\", now, now) // Result: 1973-11-29 21:33:09 +0000 UTC \"1973-11-29 21:33:09 +0000 UTC\" }"
    },
    {
        "link": "https://golang.google.cn/pkg/fmt",
        "document": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\n\nString and slice of bytes (treated equivalently with these verbs):\n\nThe default format for %v is:\n\nFor compound objects, the elements are printed using these rules, recursively, laid out like this:\n\nWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:\n\nWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in strconv.QuoteRune.\n\nFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:\n\nExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\nconvert the value before recurring:\n\nInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:\n\nIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:\n\nAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error, String, or GoString method, however, the output is the undecorated string, \"<nil>\".\n\nAn analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,\n\nwill set s to \"12345\" and i to 67 while\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\n\n means the same as \n\n).\n\nIn all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.\n\nThese examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details. package main import ( \"fmt\" \"math\" \"time\" ) func main() { // A basic set of examples showing that %v is the default format, in this // case decimal for integers, which can be explicitly requested with %d; // the output is just what Println generates. integer := 23 // Each of these prints \"23\" (without the quotes). fmt.Println(integer) fmt.Printf(\"%v\n\n\", integer) fmt.Printf(\"%d\n\n\", integer) // The special verb %T shows the type of an item rather than its value. fmt.Printf(\"%T %T\n\n\", integer, &integer) // Result: int *int // Println(x) is the same as Printf(\"%v\n\n\", x) so we will use only Printf // in the following examples. Each one demonstrates how to format values of // a particular type, such as integers or strings. We start each format // string with %v to show the default output and follow that with one or // more custom formats. // Booleans print as \"true\" or \"false\" with %v or %t. truth := true fmt.Printf(\"%v %t\n\n\", truth, truth) // Result: true true // Integers print as decimals with %v and %d, // or in hex with %x, octal with %o, or binary with %b. answer := 42 fmt.Printf(\"%v %d %x %o %b\n\n\", answer, answer, answer, answer, answer) // Result: 42 42 2a 52 101010 // Floats have multiple formats: %v and %g print a compact representation, // while %f prints a decimal point and %e uses exponential notation. The // format %6.2f used here shows how to set the width and precision to // control the appearance of a floating-point value. In this instance, 6 is // the total width of the printed text for the value (note the extra spaces // in the output) and 2 is the number of decimal places to show. pi := math.Pi fmt.Printf(\"%v %g %.2f (%6.2f) %e\n\n\", pi, pi, pi, pi, pi) // Result: 3.141592653589793 3.141592653589793 3.14 ( 3.14) 3.141593e+00 // Complex numbers format as parenthesized pairs of floats, with an 'i' // after the imaginary part. point := 110.7 + 22.5i fmt.Printf(\"%v %g %.2f %.2e\n\n\", point, point, point, point) // Result: (110.7+22.5i) (110.7+22.5i) (110.70+22.50i) (1.11e+02+2.25e+01i) // Runes are integers but when printed with %c show the character with that // Unicode value. The %q verb shows them as quoted characters, %U as a // hex Unicode code point, and %#U as both a code point and a quoted // printable form if the rune is printable. smile := '😀' fmt.Printf(\"%v %d %c %q %U %#U\n\n\", smile, smile, smile, smile, smile, smile) // Result: 128512 128512 😀 '😀' U+1F600 U+1F600 '😀' // Strings are formatted with %v and %s as-is, with %q as quoted strings, // and %#q as backquoted strings. placeholders := `foo \"bar\"` fmt.Printf(\"%v %s %q %#q\n\n\", placeholders, placeholders, placeholders, placeholders) // Result: foo \"bar\" foo \"bar\" \"foo \\\"bar\\\"\" `foo \"bar\"` // Maps formatted with %v show keys and values in their default formats. // The %#v form (the # is called a \"flag\" in this context) shows the map in // the Go source format. Maps are printed in a consistent order, sorted // by the values of the keys. isLegume := map[string]bool{ \"peanut\": true, \"dachshund\": false, } fmt.Printf(\"%v %#v\n\n\", isLegume, isLegume) // Result: map[dachshund:false peanut:true] map[string]bool{\"dachshund\":false, \"peanut\":true} // Structs formatted with %v show field values in their default formats. // The %+v form shows the fields by name, while %#v formats the struct in // Go source format. person := struct { Name string Age int }{\"Kim\", 22} fmt.Printf(\"%v %+v %#v\n\n\", person, person, person) // Result: {Kim 22} {Name:Kim Age:22} struct { Name string; Age int }{Name:\"Kim\", Age:22} // The default format for a pointer shows the underlying value preceded by // an ampersand. The %p verb prints the pointer value in hex. We use a // typed nil for the argument to %p here because the value of any non-nil // pointer would change from run to run; run the commented-out Printf // call yourself to see. pointer := &person fmt.Printf(\"%v %p\n\n\", pointer, (*int)(nil)) // Result: &{Kim 22} 0x0 // fmt.Printf(\"%v %p\n\n\", pointer, pointer) // Result: &{Kim 22} 0x010203 // See comment above. // Arrays and slices are formatted by applying the format to each element. greats := [5]string{\"Kitano\", \"Kobayashi\", \"Kurosawa\", \"Miyazaki\", \"Ozu\"} fmt.Printf(\"%v %q\n\n\", greats, greats) // Result: [Kitano Kobayashi Kurosawa Miyazaki Ozu] [\"Kitano\" \"Kobayashi\" \"Kurosawa\" \"Miyazaki\" \"Ozu\"] kGreats := greats[:3] fmt.Printf(\"%v %q %#v\n\n\", kGreats, kGreats, kGreats) // Result: [Kitano Kobayashi Kurosawa] [\"Kitano\" \"Kobayashi\" \"Kurosawa\"] []string{\"Kitano\", \"Kobayashi\", \"Kurosawa\"} // Byte slices are special. Integer verbs like %d print the elements in // that format. The %s and %q forms treat the slice like a string. The %x // verb has a special form with the space flag that puts a space between // the bytes. cmd := []byte(\"a⌘\") fmt.Printf(\"%v %d %s %q %x % x\n\n\", cmd, cmd, cmd, cmd, cmd, cmd) // Result: [97 226 140 152] [97 226 140 152] a⌘ \"a⌘\" 61e28c98 61 e2 8c 98 // Types that implement Stringer are printed the same as strings. Because // Stringers return a string, we can print them using a string-specific // verb such as %q. now := time.Unix(123456789, 0).UTC() // time.Time implements fmt.Stringer. fmt.Printf(\"%v %q\n\n\", now, now) // Result: 1973-11-29 21:33:09 +0000 UTC \"1973-11-29 21:33:09 +0000 UTC\" }"
    },
    {
        "link": "https://stackoverflow.com/questions/20895552/how-can-i-read-from-standard-input-in-the-console",
        "document": "Always try to use the bufio.NewScanner for collecting input from the console. As others mentioned, there are multiple ways to do the job, but Scanner is originally intended to do the job. Dave Cheney explains why you should use Scanner instead of bufio.Reader's ReadLine.\n\nHere is the code snippet answer for your question\n\nIf you don't want to programmatically collect the inputs, just add these lines\n\nThe output of above program will be:\n\nThe above program collects the user input and saves them to an array. We can also break that flow with a special character. Scanner provides API for advanced usage like splitting using a custom function, etc., scanning different types of I/O streams (standard , ), etc.\n\nEdit: The tweet linked in original post is not accesible. But, one can find official reference of using Scanner from this standard library documentation: https://pkg.go.dev/[email protected]#example-Scanner-Lines"
    },
    {
        "link": "https://golang.bg/pkg/fmt",
        "document": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.\n\nString and slice of bytes (treated equivalently with these verbs):\n\nThe default format for %v is:\n\nFor compound objects, the elements are printed using these rules, recursively, laid out like this:\n\nWidth is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:\n\nWidth and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in strconv.QuoteRune.\n\nFlags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:\n\nExcept when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\nconvert the value before recurring:\n\nInfinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:\n\nIf an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:\n\nAll errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error, String, or GoString method, however, the output is the undecorated string, \"<nil>\".\n\nAn analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,\n\nwill set s to \"12345\" and i to 67 while\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\n\n means the same as \n\n).\n\nIn all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader."
    }
]