[
    {
        "link": "https://w3schools.com/howto/howto_css_menu_horizontal_scroll.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/76179318/scroll-menu-in-html-css",
        "document": "This is the current code I have, but instead of becoming a scroll menu at a certain size, it is just making the page longer. The link is posted over and over many times to make sure it fills the page and more, I just didn't paste those divs in here for clarity/length.\n\njust sets the spacing on the page, for reference. I used overflow:scroll and set a fixed height at to make it shorter than the page to force a scroll, but it just continues to be very long."
    },
    {
        "link": "https://stackoverflow.com/questions/47986046/how-to-scroll-follow-menu-with-css-and-javascript",
        "document": "How to Scroll/Follow Menu with CSS and Javascript?\n\nI am testing a scroll/follow menu on this page, http://www.pablitogreco.com/xtango/#x. The menu exists inside a modal window. After studying numerous examples from stackoverflow this is the one that came closer:\n\nBut scrolling up has several flaws, and I think I am missing a lot. I have done extensive research on Stackoverflow and other platforms, and tried many implementations. Please, can you assist with my below code, and point me to the right direction?"
    },
    {
        "link": "https://forum.freecodecamp.org/t/how-to-apply-the-scroll-bar-in-the-menu-items/214327",
        "document": "I am doing the :Technical Documentation Page\" assignment. I have created a Grid for the left navigation menu. How do i add a scroll bar to it. Using\n\ncreates a scroll bar for the whole page.\n\nI also want to insert the horizontal lines under each menu item. I tried:\n\nbut it didn’t work. Kindly help. Here’s my page:\n\n https://codepen.io/umairhp/full/XBqLdM/"
    },
    {
        "link": "https://w3schools.com/howto/howto_css_fixed_menu.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/Accessibility/Guides/Keyboard-navigable_JavaScript_widgets",
        "document": "Web applications often use JavaScript to mimic desktop widgets such as menus, tree views, rich text fields, and tab panels. These widgets are typically composed of and elements that do not, by nature, offer the same keyboard functionality that their desktop counterparts do. This document describes techniques to make JavaScript widgets accessible with the keyboard.\n\nBy default, when people use the tab key to browse a webpage, only interactive elements (like links, form controls) get focused. With the global attribute, authors can make other elements focusable, too. When set to , the element becomes focusable by keyboard and script. When set to , the element becomes focusable by script, but it does not become part of the keyboard focus order. The order in which elements gain focus when using a keyboard, is the source order by default. In exceptional circumstances, authors may want to redefine the order. To do this, authors can set to any positive number. Warning: Avoid using positive values for . Elements with a positive are put before the default interactive elements on the page, which means page authors will have to set (and maintain) values for all focusable elements on the page whenever they use one or more positive values for . The following table describes behavior in modern browsers: Focusable with mouse or JavaScript via Follows the platform convention of the element (yes for form controls, links, etc.). Follows the platform convention of the element. No; author must focus the element with in response to arrow or other key presses. In tab order relative to element's position in document (note that interactive elements like have this behavior by default, they don't need the attribute). value determines where this element is positioned in the tab order: smaller values will position elements earlier in the tab order than larger values (for example, will be positioned before ).\n\nNative HTML elements that are interactive, like , and , are already accessible by keyboards, so to use one of them is the fastest path to make components work with keyboards. Authors can also make a or keyboard accessible by adding a of . This is particularly useful for components that use interactive elements that do not exist in HTML.\n\nFor grouping widgets such as menus, tablists, grids, or tree views, the parent element should be in the tab order ( ), and each descendant choice/tab/cell/row should be removed from the tab order ( ). Users should be able to navigate the descendant elements using arrow keys. (For a full description of the keyboard support that is normally expected for typical widgets, see the WAI-ARIA Authoring Practices.) The example below shows this technique used with a nested menu control. Once keyboard focus lands on the containing element, the JavaScript developer must programmatically manage focus and respond to arrow keys. For techniques for managing focus within widgets, see \"Managing focus inside groups\" below. When a custom control becomes disabled, remove it from the tab order by setting . Note that disabled items within a grouped widget (such as menu items in a menu) should remain navigable using arrow keys.\n\nSetting the of the focused element to \"0\" ensures that if the user tabs away from the widget and then returns, the selected item within the group retains focus. Note that updating the to \"0\" requires also updating the previously selected item to . This technique involves programmatically moving focus in response to key events and updating the to reflect the currently focused item. To do this: Bind a key down handler to each element in the group, and when an arrow key is used to move to another element:\n• programmatically apply focus to the new element,\n• update the of the focused element to \"0\", and\n• update the of the previously focused element to \"-1\". Here's an example of a WAI-ARIA tree view using this technique.\n\nThis technique involves binding a single event handler to the container widget and using the to track a \"virtual\" focus. (For more information about ARIA, see this overview of accessible web applications and widgets.) The property identifies the ID of the descendant element that currently has the virtual focus. The event handler on the container must respond to key and mouse events by updating the value of and ensuring that the current item is styled appropriately (for example, with a border or background color).\n\nIf your widget handles a key event, prevent the browser from also handling it (for example, scrolling in response to the arrow keys) by using your event handler's return code. If your event handler returns , the event will not be propagated beyond your handler. If returns , the event will be consumed, preventing the browser from performing any action based on the keystroke."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nobjects describe a user interaction with the keyboard; each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard. The event type ( , , or ) identifies what kind of keyboard activity occurred. Note: events just indicate what interaction the user had with a key on the keyboard at a low level, providing no contextual meaning to that interaction. When you need to handle text input, use the event instead. Keyboard events may not be fired if the user is using an alternate means of entering text, such as a handwriting system on a tablet or graphics tablet.\n\nThe following constants identify which part of the keyboard the key event originates from. They are accessed as and so forth. The key described by the event is not identified as being located in a particular area of the keyboard; it is not located on the numeric keypad (unless it's the NumLock key), and for keys that are duplicated on the left and right sides of the keyboard, the key is, for whatever reason, not to be associated with that location. Examples include alphanumeric keys on the standard PC 101 US keyboard, the NumLock key, and the space bar. The key is one which may exist in multiple locations on the keyboard and, in this instance, is on the left side of the keyboard. Examples include the left Control key, the left Command key on a Macintosh keyboard, or the left Shift key. The key is one which may exist in multiple positions on the keyboard and, in this case, is located on the right side of the keyboard. Examples include the right Shift key and the right Alt key (Option on a Mac keyboard). The key is located on the numeric keypad, or is a virtual key associated with the numeric keypad if there's more than one place the key could originate from. The NumLock key does not fall into this group and is always encoded with the location . Examples include the digits on the numeric keypad, the keypad's Enter key, and the decimal point on the keypad.\n\nThis interface also inherits properties of its parents, and . Returns a boolean value that is if the ( or on macOS) key was active when the key event was generated. Returns a string with the code value of the physical key represented by the event. Warning: This ignores the user's keyboard layout, so that if the user presses the key at the \"Y\" position in a QWERTY keyboard layout (near the middle of the row above the home row), this will always return \"KeyY\", even if the user has a QWERTZ keyboard (which would mean the user expects a \"Z\" and all the other properties would indicate a \"Z\") or a Dvorak keyboard layout (where the user would expect an \"F\"). If you want to display the correct keystrokes to the user, you can use . Returns a boolean value that is if the key was active when the key event was generated. Returns a boolean value that is if the event is fired between after and before . Returns a string representing the key value of the key represented by the event. Returns a number representing the location of the key on the keyboard or other input device. A list of the constants identifying the locations is shown above in Keyboard locations. Returns a boolean value that is if the key (on Mac keyboards, the key; on Windows keyboards, the Windows key ( )) was active when the key event was generated. Returns a boolean value that is if the key is being held down such that it is automatically repeating. Returns a boolean value that is if the key was active when the key event was generated.\n\nSome keys toggle the state of an indicator light; these include keys such as Caps Lock, Num Lock, and Scroll Lock. On Windows and Linux, these keys dispatch only the and events. Note: On Linux, Firefox 12 and earlier also dispatched the event for these keys. However, a limitation of the macOS event model causes Caps Lock to dispatch only the event. Num Lock was supported on some older laptop models (2007 models and older), but since then, macOS hasn't supported Num Lock even on external keyboards. On older MacBooks with a Num Lock key, that key doesn't generate any key events. Gecko does support the Scroll Lock key if an external keyboard which has an F14 key is connected. In certain older versions of Firefox, this key generated a event; this inconsistent behavior was Firefox bug 602812."
    },
    {
        "link": "https://advancedbytez.com/keyboard-accessibility-in-javascript",
        "document": "Keyboard accessibility is a crucial aspect of web accessibility. A lot of internet users surf the web and navigate web pages using only their keyboard. This is done either for convenience, personal preference or due to a motor disability; making sure that your website is keyboard navigable benefits a wide range of users.\n\nThere are multiple ways you can optimize your websites for accessibility, one simple way is by implementing event listeners using JavaScript. This provides a number of ways to present, update, and enhance content on a web page on the fly without having the user refresh the page, which is especially useful to users using assistive technology.\n\nAssistive technologies rely on interactive elements(i.e forms, buttons) to understand and interact with elements on a web page.\n\nWhich implies that any discrepancy in how interactive elements are presented can negatively affect users and assistive technologies such as screen readers and speech-input software.\n\nIncorrect element properties can also cause issues with assistive technologies because they use attributes such as Name, Role and Value of UI elements to parse controls and structure properly. This is also part of the WCAG criterion WCAG 4.1.2 Name, Role, Value.\n\nMost of the time you don’t need custom focus management for simple native HTML elements such as , the <button> tag for buttons, the <input> tag for user input and the anchor <a> tag for links. Native HTML elements are accessible out-of-the-box and have predefined roles and global tab index attributes of “0”. This allows the elements to be focusable with the tab key and establish a sequential focus order.\n\nThe only time focus order can be an issue is when you’re building custom components or designs that require manual focus management. In this case, focus order can end up being inconsistent with the design and sequential logic of the content on the website. An example of such a design pattern is the use of modal popup dialogs, when activated require the focus to be trapped inside the overlay and not move to the elements in the background.\n\nIn some cases, you might want to apply focus to an element that is not focusable by default. You can do that by using the tabindex attribute which makes unfocusable elements focusable. Remember that you shouldn’t be using tabindex on elements that don’t need it such as buttons.\n\nThere are three methods you can use with tabindex:\n• tabindex= ”0” allows custom elements other native HTML elements to receive keyboard focus.<div> and < span > are examples of such elements that may require a tabindex=”0”. It works by placing the element in the logical navigation flow and doesn’t change the tab order.\n• tabindex= “-1” will remove the element from the navigation order, meaning that you won’t be able to access it via <TAB>, but can be focusable using JavaScript. This is useful when creating accessible interactive widgets in JavaScript. Take the example of the modal again. The button that activates the modal should have tabindex=”0” but the modal itself will have a tabindex=”-1” to remove it from the tab order and prevent a user from tabbing through the contents of the modal that isn’t active yet.\n• tabindex= ”1” and above will be the first elements to be focused starting from one. This would be useful if you wanted a focusable element removed from the tab sequence. Keep in mind that using a positive integer when using tabindex is not advisable and bad practice for accessibility. This can break the expected tab order and create a confusing user experience when tabbing across interactive elements on your website, especially if content is dynamically added to the website.\n\nUsers who are unable to navigate the web using a mouse or a trackpad, will often rely on the tab key. Making it one of the most important keys on a keyboard for users with motor disabilities. The Tab key is often used to navigate through focusable elements like forms and buttons on a web page.\n\nThe HTML DOM which regroups all the properties, methods and events of HTML elements on a web page can end up having a broken tab order if focusable elements aren’t in a correct order relative to how a website is designed.\n\nBecause the Tab key will jump to Interactive elements in the order they appear in the DOM, not how they appear visually. You can easily solve that by having your source code match the visual hierarchy of your website front-end design.\n\nThe default Tab order should be logical, intuitive and follow the visual flow of the web page. Similar to a book, it should be going from left to right, top to bottom.\n\nHow focus is styled is as important as focus order, it doesn’t matter how good focus is managed if the user doesn’t know which button or link is currently being selected as he tabs through the page.\n\nModern web browsers have different visual stylings for how focusable elements are selected, some more visible than others. To avoid having issues with styling, within your stylesheet you should avoid setting the focus outline to none or 0, because this will override the browser’s default focus indicator if you’re using a custom theme.\n\nHow To Improve Accessibility Using JavaScript?\n\nWe can improve accessibility using HTML and CSS, they can do the job most of the time. But when dealing with more complex designs and components then JavaScript is the solution.\n\nJavaScript, unlike HTML and CSS, can trigger events based on the user’s actions.\n\nLet’s have a look at some useful methods we can use in JavaScript:\n\nThis method allows us to bring the keyboard focus to an element that’s either tabbable or focusable. This is a quite useful method for keyboard accessibility.\n\nHere’s an example where focus is set to the input as soon as the page loads:\n\nHere when the page loads the .focus() selector is used to focus on the input field called myInput.\n\nThe OnKeyDown() method will listen to whether a key was pressed or not, in this case we will be enabling a user to click a button with either the <space> or <enter> key.\n\nA common practice we see in today’s web development practices is to style a link to look like a button.\n\nI am a power keyboard user and expect that if I come across a button, it will be activated with either the Enter or Space key. If it is actually a link made to look like a button and I use my Space key to activate it, there is a page scroll. This raises important accessibility issues when a user expects a known interaction to take place and the opposite happens. This can be fixed by adding a keydown event to the link to allow it to be fired with the Space key.\n\nLet’s have a look at an example:\n\nWhen the button is brought into focus and the <space> or <enter> key are pressed the HandleKeyDown() function is called through the OnKeyDown() method.\n\nThe HandleKeyDown() method will check if the <enter> or <space> key were pressed using their key code which are 13 and 32 respectively.\n\nIt then calls the PerformAction() function which triggers an alert box.\n\nThis method is used to set attributes to elements, while not directly related to focus and accessibility it can be used to enhance user experience, such as dynamically changing attribute values of elements relative to their change in states.\n\nLet’s have a look at an example where the SetAttribute() method is used to toggle the aria-expanded attribute of a dropdown menu:\n\nThe toggle button’s aria-expanded attribute is set to false by default when the menu is collapsed. When it’s clicked the toggleDropdown() function is called using the OnClick() method.\n\nThe toggleDropDown() function expands the dropdown and changes the value of aria-expanded to ‘true’.\n\nWhen it’s clicked a second time, the drop-down collapses and the aria-expanded attribute is set to ‘false’.\n\nKeyboard accessibility is still an issue today as websites become increasingly complex in terms of features and designs which are often not optimized for keyboard accessibility, navigation and focus management.\n\nAnd this requires us to devise ways to solve those accessibility issues using JavaScript’s event handlers and various other techniques. Allowing us to detect a user’s actions on a web page and perform certain modifications enhancing focus, navigation and accessibility."
    },
    {
        "link": "https://stackoverflow.com/questions/6633248/how-to-grab-keyboard-events-on-an-element-which-doesnt-accept-focus",
        "document": "I know that for handling keyboard events in an input field you can use:\n\nBut, now, I have some and elements, and I don't have a element, and none of my elements are considered to be form elements and none of them accept focus or tab and stuff like that.\n\nBut now I need to handle the (or , or , doesn't matter) event in a div element. I tried:\n\nBut the problem is, it doesn't work. What should I do?"
    },
    {
        "link": "https://metana.io/blog/event-handling-in-javascript-adding-interactivity-to-web-pages",
        "document": "\n• Event handling in JavaScript enables developers to create interactive web pages by responding to user actions like clicks, key presses, and mouse movements.\n• Common methods for adding event listeners include addEventListener for modern browsers and assigning functions directly to event properties for older ones.\n• Understanding event propagation (capturing and bubbling) is crucial for managing how events are handled within nested elements.\n• Preventing default behaviors and stopping propagation allow for customized responses to user interactions.\n• Efficient event handling enhances user experience and performance, especially in complex web applications.\n\nImagine a website that’s just a static image, like a printed page. No clicking, no animations, no dynamic content – just… there. Boring, right? That’s where event handling in JavaScript comes in, like a spark that brings your web pages to life. It lets them respond to user interactions and events, creating a truly interactive experience.\n\nThink of events as signals sent by the user or the browser. Clicking a button, hovering over an image, even the page fully loading – these are all events. JavaScript’s Event Handling is about capturing these signals and making your web page react accordingly.\n\nHere are some common events you might use:\n• Click: When a user clicks on an element (button, image, etc.)\n• Hover: When a user moves their mouse over an element\n• Load: When the entire page or an element (like an image) finishes loading\n• Keypress: When a user presses a key on their keyboard\n\nThis is just a small list of the most commonly used events, there are many more events available!\n\nEvent handlers are like the backstage crew of your web page’s performance. They are JavaScript functions that wait for specific events to happen and then execute a block of code in response. This code can do anything you can imagine – change the content of an element, display a message, trigger an animation, or even send data to a server.\n\nThere are two main ways to assign event handlers in JavaScript:\n• Using HTML Event Attributes: This is the simpler approach. You can directly assign a JavaScript function name to an HTML element’s on attribute, followed by the event name (e.g., onclick, onmouseover). Here’s an example:\n\n\n\nIn this example, clicking the button calls the changeColor() function, which changes the background color of the element with the ID “myDiv” to red.\n• Using addEventListener() Method: This method offers more flexibility. You can attach multiple event handlers to the same element, specify different event types, and even remove event handlers later. Here’s how it works:\n\n\n\nHere, we use addEventListener() on the button element. The first argument is the event type (“click” in this case), and the second is the function to be executed. Now, clicking the button displays an alert message.\n\n\n\nBringing Your Web Pages to Life with Event Handling\n\nLet’s explore some real-world examples of how event handling can transform your web pages:\n• Interactive Forms: Imagine a form where the error message appears only when the user tries to submit the form with an empty field. Event handlers on the submit event can validate the form data and display appropriate messages.\n• Image Galleries: Create a dynamic image gallery where hovering over an image displays a caption or highlights the image border. Event handlers on the mouseover event can achieve this with ease.\n• Accordions and Tabs: Build collapsable sections or tabbed content that reveals information upon user interaction. Event handlers on the click event can toggle the visibility of these sections.\n• Interactive Games: Develop simple games where user actions like clicking or pressing keys trigger game logic. Event handlers on these events become the core of your game’s interactivity.\n\nThese are just a few examples. With event handling, the possibilities are endless!\n\nBest Practices for Event Handling in JavaScript\n\nAs you dive deeper into event handling, here are some tips to keep in mind:\n• Separate Event Handlers from HTML: For better code organization, consider attaching event handlers using JavaScript instead of relying on inline HTML attributes.\n• Use Meaningful Event Handler Names: Choose function names that clearly describe the action they perform (e.g., showDetails(), validateForm()).\n• Prevent Default Behavior (When Necessary): In some cases, events like form submission might have default actions. Use event.preventDefault() to stop these defaults if your event handler wants to do something different.\n• Handle Event Bubbling: When an event occurs on an element, it can “bubble up” to its parent elements. Be mindful of this behavior and use event.stopPropagation() if you only want the event to be handled by the element where it originated.\n\nImagine attaching a click handler to both the button and the div. Clicking the button would trigger the click event on both elements. This might not be what you want. To prevent the event from bubbling up to the div, you can use event.stopPropagation() within the button’s click handler.\n• Remove Event Listeners When Necessary: Event listeners can accumulate over time, especially on dynamic content. To prevent memory leaks and improve performance, consider removing event listeners when they are no longer needed. You can use the removeEventListener() method.\n• Use Event Delegation for Performance: As discussed earlier, delegation is a powerful technique for handling events on a group of elements with a single event listener attached to a parent element. This improves performance compared to attaching individual handlers to each element.\n• Consider Cross-Browser Compatibility: While most event handling concepts work consistently across major browsers, there might be slight variations in behavior for certain events or properties. It’s always a good practice to test your code in different browsers to ensure a smooth user experience.\n\nEarlier we explored the fundamentals of event handling in JavaScript. Now, let’s diver deeper into some advanced concepts to create even more refined web interactions.\n\nRemember event bubbling? When an event occurs on an element, it “bubbles up” to its parent elements in the HTML hierarchy. For example, clicking a button inside a div will trigger the click event on both the button and the div (unless stopped).\n\nThis can be useful, but sometimes you might want the opposite behavior – for the event to “capture” down the hierarchy instead. This is where event capturing comes in.\n\nHere’s how to control bubbling and capturing:\n• Default Behavior (Bubbling): This is the standard behavior. Events propagate up the DOM tree.\n• event.stopPropagation(): This method stops the event from bubbling further up the hierarchy.\n• addEventListener(event, handler, useCapture): The third argument, useCapture, is a boolean. Set it to true to make the event listener capture events instead of bubbling.\n\nImagine a nested menu structure. Clicking a sub-menu item might unintentionally trigger a click event on the main menu as well. Using event.stopPropagation() in the sub-menu’s click handler can prevent this unwanted behavior.\n\nWith a complex web page containing many elements, attaching individual event handlers to each one can become inconvenient and can slow down performance. This is where the event delegation comes to the rescue.\n\nDelegation involves attaching an event handler to a parent element and then checking within the handler function to see which child element triggered the event. This way, you have a single handler for a group of elements.\n\nIn this example, we attach a click handler to the myList element. Inside the handler, we check if the clicked element (event.target) is a list item (LI). If so, we display an alert message with the item’s text content.\n\nDelegation is a powerful technique for handling events on dynamically generated content or large lists of elements.\n\nEvent handling isn’t just about mouse interactions. JavaScript provides ways to capture keyboard events as well. This makes your web pages more accessible for users who rely on keyboards for navigation.\n\nHere are some common keyboard events:\n• keydown: Triggered when a key is pressed down\n• keypress: Triggered when a character is pressed (may not work in all browsers)\n\nImagine a website with a search bar. Using the keydown event, you can detect when the user presses the Enter key and trigger a search based on the entered text. This enhances the user experience for those who prefer keyboard navigation.\n\nWhen an event occurs, JavaScript provides an event object as an argument to the event handler function. This object contains valuable information about the event, such as:\n• event.type: The type of event that occurred (e.g., “click”, “keydown”)\n• event.target: The element that triggered the event\n• event.currentTarget: The element the event listener is attached to (can be different from event.target in some cases)\n• event.keyCode: Key code of the pressed key (for keyboard events)\n\nBy accessing these properties within your event handler, you can tailor your code’s response based on the specifics of the event.\n\nEvent handling in JavaScript is a powerful tool that forms the foundation for creating dynamic and interactive web pages. By understanding events, event handlers, and best practices, you can transform your web applications into engaging experiences for your users.\n\nWhat is event handling in JavaScript?\n• Event handling involves responding to user actions like clicks, mouse movements, and keyboard inputs on a web page.\n\nHow do you add an event listener in JavaScript?\n• Use the method, specifying the event type and the function to be executed when the event occurs.\n\nCan you remove an event listener?\n• Yes, using the method, specifying the same event type and function used to add it.\n\nWhat are common event types in JavaScript?\n\nHow does event propagation work in JavaScript?\n• Event propagation in JavaScript can work in two ways: bubbling (default) and capturing, determining the order event handlers are executed.\n• JavaScript is a programming language used to create dynamic content on websites, enhancing user interfaces and experiences.\n\nWhy is JavaScript important for web development?\n• It enables interactive elements on web pages, making sites more engaging and responsive to user actions.\n• By allowing dynamic updates without reloading the page, handling form validations, and managing user interactions.\n\nWhat are some best practices for JavaScript event handling?\n• Use event delegation, avoid excessive or events, and remove unneeded event listeners to improve performance.\n\nAre there any tools to help debug event listeners in JavaScript?\n• Yes, most modern browsers have built-in developer tools that can inspect and debug event listeners attached to page elements."
    }
]