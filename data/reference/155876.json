[
    {
        "link": "https://ardalis.com/how-to-easily-format-tables-in-markdown",
        "document": "I'm a big fan of Markdown. It provides a simple way to richly format text without the complexity or security issues that would come from using HTML. Support for Markdown is ubiquitous within the software development industry, with native support everywhere from GitHub to StackOverflow. I've written everything from short documentation articles to several entire ebooks for Microsoft using Markdown. I've even recently moved my blog to GatsbyJS/Netlify/Github using Markdown (you can see this article's source here)! But one thing that has always been a real pain with Markdown is table formatting.\n\nTables are often the best way to present some data. I learned about HTML tables early in my career, before CSS really was a thing, and we used them not just for data presentation but also layout. I got pretty good at defining TR and TD tags and spanning this or that cell across multiple rows or columns to make it fit where I wanted. Markdown doesn't do any of that. There are no tags. Instead, you basically draw the tables as ASCII art by using | and - characters. In my experience it's quite tedious and easy to get wrong when doing it by hand.\n\nFortunately, you don't have to.\n\nThere's a really nice tool I found recently called Tables Generator. It's a web site that will let you author your table and then click a button to generate the Markdown needed to produce it. It also supports LaTeX and HTML table syntax if you prefer. Just click on the sample table and start adding text. When you're ready, click Generate to see the resulting Markdown. Then copy/paste it into your markdown file and you're done!\n\nThat's really all there is to it. The tool supports some basic formatting and makes it easy to build the table you need. It was a big help to me recently on some work I was doing that involved a few complex tables. I hope you find it useful."
    },
    {
        "link": "https://docs.retool.com/mobile/guides/custom/table",
        "document": "Retool Mobile supports advanced formatting by using Markdown within a Text component. While Retool Mobile doesn't have a table component, you can display tabular data using Markdown tables.\n\nTables can be displayed with Markdown using pipe and dash symbols, for example:\n\nThe above Markdown renders as a table.\n\nData returned from a resource query can also be rendered in a table by dynamically building the Markdown. For example, you might have a resource query named which returns the following array.\n\nIn the Text component's Value field, the following would render the same table.\n\nThis code uses the method of the array instance to iterate over each object in the array and format it into a string in the correct Markdown format. It then joins the new array of strings into a single string using . The same approach could be used in a transformer."
    },
    {
        "link": "https://htmlmarkdown.com/syntax/markdown-tables",
        "document": "Markdown, the lightweight markup language beloved for its simplicity and readability, excels at formatting text for online environments. While not originally designed for tables, various implementations, most notably GitHub Flavored Markdown (GFM), have embraced this functionality.\n\nThis guide delves into the nuances of creating and utilizing Markdown tables, empowering you to present data effectively within your Markdown documents.\n\nCrafting a Markdown table hinges on a clear understanding of its basic syntax. Remember, pipes ( ) separate columns, and hyphens ( ) define the header row, acting as a visual delimiter. Here’s the core structure:\n\nThe basic Markdown table syntax looks like this:\n\nTo break it down:\n• Tables are made up of rows separated by newlines.\n• The first row is the header, which defines the column names.\n• The second row is a separator between the header and data rows. Colons are used to align columns.\n\nThat covers the basics, but there’s more you can do to customize Markdown tables.\n\nGFM empowers you to control how text aligns within table cells. Use colons strategically:\n\nInside Markdown table cells, you can apply other Markdown formatting like italics, bold, links, and inline code.\n\nKeep your tables neat and readable, but use bold/italics when it makes sense to highlight important content.\n\nFor longer tables, it’s helpful to add a header row to distinguish column names. Simply add another separator row below the first:\n\nThe header row helps orient readers when you have lots of columns.\n\nYou can make cells span multiple columns by adding extra pipes .\n\nSpanning cells allow you to customize the structure of your tables.\n\nIf you need to display a pipe character in a cell, escape it with a backslash :\n\nUse escaping for full control of table content.\n\nYou can add a caption below your Markdown table with regular Markdown syntax:\n\nContent Craftmanship: What Goes Inside the Cells\n\nMarkdown’s core formatting tools shine within table cells. You can leverage bold, italics, links, code blocks, and even basic HTML tags (like for line breaks) to enhance your data’s presentation. Remember, escape pipes ( ) with backslashes if they’re part of your content to avoid confusion.\n\nWhile the core syntax empowers you to create functional tables, here are some advanced tips:\n• Column Width: Markdown doesn’t enforce fixed column widths, but you can achieve a consistent look by manually adjusting cell content length or using CSS in some Markdown processors.\n• Footnotes: Utilize the syntax within a cell to create footnotes. Reference them elsewhere in the table using numbers within square brackets (e.g., ).\n• Long-Tail Keywords: Consider strategically incorporating relevant keywords within your table headers and content to boost search engine visibility.\n\nHere are some handy Markdown table resources:\n• Markdown Tables Assistant – generates Markdown tables from the clipboard on iOS\n\nWith the power of Markdown tables and these handy tools, you can include simple yet powerful tables in your Markdown documents.\n\nAdditionally, many Markdown editors, like Typora and Zettlr, offer built-in table editors, allowing you to visually create and edit tables directly within your Markdown documents.\n\nIf you work with VSCode, give the extension Markdown Table Prettifier a try.\n\n➽ Check out my post about Markdown Link.\n\nIn Conclusion: The Power of Markdown Tables\n\nBy mastering Markdown tables, you unlock a versatile tool for presenting data clearly and concisely within your Markdown projects. Embrace the simplicity and flexibility of this approach, and don’t hesitate to experiment with the formatting options to create visually appealing and informative tables. Remember, practice makes perfect, so start crafting your Markdown tables today!\n\nI hope this comprehensive guide empowers you to master Markdown tables and elevate your data presentation skills. Feel free to ask if you have any further questions!"
    },
    {
        "link": "https://psyteachr.github.io/ads-v2/02-reports.html",
        "document": "Before we write any code, first, we need to get organised. Projects in RStudio are a way to group all the files you need for one project. Most projects include scripts, data files, and output files like the PDF report created by the script or images. First, make a new directory (i.e., folder) on your computer where you will keep all of your R projects. Name it something like “R-projects” (avoid spaces and other special characters). Make sure you know how to get to this directory using your computer’s Finder or Explorer. If possible, don’t use a network or cloud drive (e.g., OneDrive or Dropbox), as this can sometimes cause problems. If you’re working from a networked drive and you are having issues, a helpful test is to try moving your project folder to the desktop to see if that solves the problem. Next, open , navigate to the pane, and set the “Default working directory (when not in a project)” to this directory. Now, if you’re not working in a project, any files or images you make will be saved in this working directory. On some versions of Windows 10 and 11, it can cause problems if path names are longer than 260 characters. Set your default working directory to a path with a length well below that to avoid problems when R creates temporary files while rendering a report. If you are having issues, a helpful test is to try moving your project folder to the desktop to see if that solves the problem as this will likely have a much short path name than most other folders on your computer. You can set the working directory to another location manually with menu commands: However, there’s a better way of organising your files by using Projects in RStudio. Start by making a directory inside your default project directory where you will keep all of your materials for this class; we’d suggest naming it something like . To create a new project for the work we’ll do in this chapter: RStudio will restart itself and open with this new project directory as the working directory. Click on the Files tab in the lower right pane to see the contents of the project directory. You will see a file called , which is a file that contains all of the project information. When you’re in the Finder/Explorer, you can double-click on it to open up the project. Depending on your settings, you may also see a directory called , which contains your specific user settings. You can ignore this and other “invisible” files that start with a full stop. Don’t ever save a new project inside another project directory. This can cause some hard-to-resolve problems. Before we start creating new files, it’s important to review how to name your files. This might seem a bit pedantic, but following clear naming rules so that both people and computers can easily find things will make your life much easier in the long run. Here are some important principles:\n• file and directory names should only contain letters, numbers, dashes, and underscores, with a full stop ( ) between the file name and extension (that means no spaces!)\n• be consistent with capitalisation (set a rule to make it easy to remember, like always use lowercase)\n• use underscores ( ) to separate parts of the file name, like the title and date, and dashes ( ) to separate words in each part (e.g., )\n• name files with a pattern that alphabetises in a sensible order and makes it easy for you to find the file you’re looking for\n• prefix a file name with an underscore to move it to the top of the list, or prefix all files with numbers to control their order For example, these file names are a mess: Here is one way to structure them so that similar files have the same structure and it’s easy for a human to scan the list or to use code to find relevant files. See if you can figure out what the last one should be. Think of other ways to name the files above. Look at some of your own project files and see what you can improve.\n\nThroughout this course we will use R Markdown to create reproducible reports with a table of contents, text, tables, images, and code. The text can be written using markdown, which is a way to specify formatting, such as headers, paragraphs, lists, bolding, and links. To open a new R Markdown document, click . You will be prompted to give it a title; title it . You can also change the author name. Keep the output format as HTML. Once you’ve opened a new document be sure to save it by clicking . You should name this file (if you are on a Mac and can see the file extension, name it ). This file will automatically be saved in your project folder (i.e., your working directory) so you should now see this file appear in your file viewer pane. When you first open a new R Markdown document you will see a bunch of welcome text that looks like this:\n• Change the title to “Important Information” and the author to your name\n• Delete everything after the setup chunk\n• Skip a line after the setup chunk and type “## My info” (with the hashes but without the quotation marks); make sure there are no spaces before the hashes and at least one space after the hashes before the subtitle\n• Skip a line and click the insert new code menu (a green box with a C and a plus sign) then choose Your Markdown document should now look something like this: What you have created is a subtitle and a code chunk. In R Markdown, anything written in a grey code chunk is assumed to be code, and anything written in the white space (between the code chunks) is regarded as normal text (the actual colours will depend on which theme you have applied, but we will refer to the default white and grey). This makes it easy to combine both text and code in one document. When you create a new code chunk you should notice that the grey box starts and ends with three back ticks ```. One common mistake is to accidentally delete these back ticks. Remember, code chunks and text entry are different colours - if the colour of certain parts of your Markdown doesn’t look right, check that you haven’t deleted the back ticks. In your code chunk, write the code you created in Section 1.4. In Chapter 1, we asked you to type code into the console. Now, we want you to put code into code chunks in R Markdown files to make the code reproducible. This way, you can re-run your code any time the data changes to update the report, and you or others can inspect the code to identify and fix any errors. However, there will still be times that you need to put code in the console instead of in a script, such as when you install a new package. In this book, code chunks will be labelled with whether you should run them in the console or add the code to a script. When you’re working in an R Markdown document, there are several ways to run your lines of code. First, you can highlight the code you want to run and then click , however this is tedious and can cause problems if you don’t highlight exactly the code you want to run. Alternatively, you can press the green “play” button at the top-right of the code chunk and this will run all lines of code in that chunk. Figure 2.4: Click the green arrow to run all the code in the chunk. Even better is to learn some of the keyboard short cuts for R Studio. To run a single line of code, make sure that the cursor is in the line of code you want to run (it can be anywhere) and press or . If you want to run all of the code in the code chunk, press or . Learn these short cuts; they will make your life easier! Figure 2.5: Use the keyboard shortcut to run only highlighted code, or run one line at a time by placing the cursor on a line without highlighting anything. Run your code using each of the methods above. You should see the variables , , , and appear in the environment pane. (Restart R to reset.) We keep talking about using R Markdown for reproducible reports, but it’s easier to show you than tell you why this is so powerful and to give you an insight into how this course will (hopefully!) change the way you work with data forever! One important feature of R Markdown is that you can combine text and code to insert values into your writing using inline coding. If you’ve ever had to copy and paste a value or text from one file to another, you’ll know how easy it can be to make mistakes. Inline code avoids this. Again it’s easier to show you what inline code does rather than to explain it so let’s have a go. First, copy and paste this text to the white space underneath your code chunk. If you used a different variable name than , you should update this with the name of the object you created, but otherwise don’t change anything else. My name is and I am years old. My name isand I amyears old. It is days until Christmas, which is my favourite holiday. which is my favourite holiday. You cannot display a plot using inline R. Plots should be displayed from code chunks. We’ll come back to how to do this soon. Now we are going to knit, or compile, the file into a document type of our choosing. In this case we’ll create a default html file, but you will learn how to create other files like Word and PDF throughout this course. To knit your file, click . R Markdown will create and display a new HTML document, but it will also automatically save this file in your working directory. As if by magic, that slightly odd bit of text you copied and pasted now appears as a normal sentence with the values pulled in from the objects you created. My name is Emily and I am 36 years old. It is 325 days until Christmas, which is my favourite holiday. You can also knit by typing the following code into the console. Never put this in an Rmd script itself, or it will try to knit itself in an infinite loop. # alternatively, you can use this, but may get a warning\n\nNow let’s try another example of using Markdown, but this time rather than using objects we have created from scratch, we will read in a data file. Save and close your document. Then open and save a new Markdown document, this time named . You can again get rid of everything after the setup chunk. Add to the setup chunk so that tidyverse functions are available to your script. First, let’s try loading data that is stored online. Create a code chunk in your document and copy, paste, and run the below code. This code loads some simulated sales data.\n• The data is stored in a file so we’re going to use the function to load it in.\n• Note that the url is contained within double quotation marks - it won’t work without this. If you get an error message that looks like: Error in read_csv(“https://psyteachr.github.io/ads-v2/data/sales_data_sample.csv”) :\n\n could not find function “read_csv” This means that you have not loaded tidyverse. Check that is in the setup chunk and that you have run the setup chunk. This dataset is simulated sales data for different types of vehicles (originally from Kaggle) where each line of data is a single order. There are multiple ways to view and check a dataset in R. Do each of the following and make a note of what information each approach seems to give you. If you’d like more information about each of these functions, you can look up the help documentation with :\n• Click on the object in the environment pane More commonly, you will be working from data files that are stored locally on your computer. But where should you put all of your files? You usually want to have all your scripts and data files for a single project inside one folder on your computer, that project’s working directory, and we have already set up the main directory for this chapter. You can organise files in subdirectories inside this main project directory, such as putting all raw data files in a subdirectory called and saving any image files to a subdirectory called . Using subdirectories helps avoid one single folder becoming too cluttered, which is important if you’re working on big projects. In your directory, create a new folder named , download a copy of the sales data file, and save it in this new subdirectory. To load in data from a local file, again we can use the function, but this time rather than specifying a url, give it the subdirectory and file name. Use tab auto-complete when typing file names in a code chunk. After you type the first quote, hit tab to see a drop-down menu of the files in your working directory. You can start typing the name of the subdirectory or file to narrow it down. This is really useful for avoiding annoying errors because of typos or files not being where you expect.\n• You must include the file extension (in this case )\n• The subdirectory folder name ( ) and the file name are separated by a forward slash\n• Precision is important, if you have a typo in the file name it won’t be able to find your file; remember that R is case sensitive - is a completely different file to as far as R is concerned. Run , , , and on to confirm that the data is the same as .\n\nWe’re going to write a basic report for this sales dataset using R Markdown to show you some of the features. We’ll be expanding on almost every bit of what we’re about to show you throughout this course; the most important outcome is that you start to get comfortable with how R Markdown works and what you can use it to do. For this report we’re just going to present some simple sales stats for three types of vehicles: planes, motorcycles, and classic cars. We’ll come back to how to write this kind of code yourself in Chapter 5. For now, see if you can follow the logic of what the code is doing via the code comments. Create a new code chunk, then copy, paste and run the following code and then view by clicking on the object in the environment pane. Note that it doesn’t really matter whether you use or in the first line as they’re identical. # keep only the data from planes, motorcycles, and cars # count how many are in each PRODUCTLINE Because each row of the dataset is a sale, this code gives us a nice and easy way of seeing how many sales were made of each type of vehicle; it just counts the number of rows in each group. Just putting an object by itself on a line “prints” it. Section 2.5.5 will show you how to print the table in different formats for your report. You can use the visual markdown editor if you have RStudio version 1.4 or higher. This will be a button at the top of the source pane and the menu options should be very familiar to anyone who has worked with software like Microsoft Word. This is useful for complex styling, but you can also use these common plain-text style markups:\n• Headers are created by prefacing subtitles with one or more hashes ( ) and a space (do not exclude the space). If you include a table of contents, this will be created from your document headers.\n• Format text with italics or bold by surrounding the text with one or two asterisks or underscores.\n• Make lists using numbers, asterisks or dashes before items. Indent items to make nested lists.\n• Download the R Markdown Cheat Sheet to learn more. Copy and paste the below text into the white space below the code chunk that loads in the data. Save the file and then click knit to view the results. It will look a bit messy for now as it contains the code and messages from loading the data but don’t worry, we’ll get rid of that soon. This report summarises the sales data for different types of vehicles sold between 2003 and 2005. This data is from . This report summarises the sales data for different types of vehicles sold between 2003 and 2005. This data is from The *total* number of **planes** sold was The *total* number of **planes** sold was The *total* number of **classic cars** sold was . The *total* number of **classic cars** sold was The example markdown above (and in the rest of this book) is shown for the regular editor, not the visual editor. In the visual editor, you won’t see the hashes that create headers, or the asterisks that create bold and italic text. You also won’t see the backticks that demarcate inline code. The example code above shown in the visual editor. If you try to add the hashes, asterisks and backticks to the visual editor, you will get frustrated as they disappear. If you succeed, your code in the regular editor will look mangled like this: The total number of planes sold was r sales_counts\\$n 3] Try and match up the inline code with what is in the table. Of note:\n• The sign is used to indicate specific variables (or columns) in an object using the syntax.\n• Square brackets with a number e.g., indicate a particular observation\n• So asks the inline code to display the third observation of the variable in the dataset . Add another line that reports the total numbers of motorcycles using inline code. Using either the visual editor or text markups, add in bold and italics so that it matches the others. The *total* number of **motorcycles** sold was . The *total* number of **motorcycles** sold was As the saying goes, a picture paints a thousand words and sometimes you will want to communicate your data using visualisations. Create a code chunk to display a graph of the data in your document after the text we’ve written so far. We’ll use some code that you’ll learn more about in Chapter 3 to make a simple bar chart that represents the sales data – focus on trying to follow how bits of the code map on to the plot that is created. Copy and paste the below code. Run the code in your Markdown to see the plot it creates and then knit the file to see how it is displayed in your document. You can also include images that you did not create in R using the markdown syntax for images or . This is very similar to loading data in that you can either use an image that is stored on your computer, or via a url. Create a new code chunk underneath each of the sales figures for planes, classic cars, and motorcycles and add in an image from Google or Wikipedia for each (right click on an image and select copy image address to get a url). See the section on chunk defaults to see how to change the display size. Most images on Wikipedia are public domain or have an open license. You can search for images by license on Google Images by clicking on the button and choosing “Creative Commons licenses” from the “Usage Rights” menu. Alternatively, you can use the markdown notation to show an image. This goes in the markdown text section of the document, not inside is grey code block. The caption is optional; you can omit it like this: Rather than a figure, we might want to display our data in a table.\n• Add a new level 2 heading (two hashtags) to your document, name the heading “Data in table form” and then create a new code chunk below this. First, let’s see what the table looks like if we don’t make any edits. Simply write the name of the table you want to display in the code chunk (in our case ) and then click knit to see what it looks like. It’s just about readable but it’s not great. Another way to customise tables uses the function from the package. Amend your code to load the package and apply the function to the table. Once you’ve done this, knit the file again to see the output. It’s better, but it’s still not amazing. So let’s make a few adjustments. We can change the names of the columns, add a caption, and also change the alignment of the cell contents using arguments to . We can also add a theme to change the overall style. In this example we’ve used but there are 5 others: , , , and . Try them all and see which one you prefer. Finally, we can change the formatting of the first row using . Look up the help documentation for to see what other options are available. Try changing the value of any of the arguments below to figure out what they do. The appearance and placement of the table caption depends on the type of document you are creating. Your captions may look different to those in this book because you are creating a single-page , while this book uses the style from quarto, which is a newer alternative to R Markdown. You’ll learn more about other document output types in Section 10.2. If you’re feeling confident with what we have covered so far, the kableExtra vignette gives a lot more detail on how you can edit your tables using . You can also explore the gt package, which is complex, but allows you to create beautiful customised tables. Riding tables with {gt} and {gtExtras} is an outstanding tutorial.\n\nLet’s finish by tidying up the report and organising our code a bit better. When you create a new R Markdown file in RStudio, a setup chunk is automatically created - we’ve mostly ignored this chunk until now. You can set more default options for your document here. Type the following code into the console to see the full list of options that you can set and their default values. However, the most useful and common options to change for the purposes of writing reports revolve around whether you want to show your code and the size of your images. Replace the code in your setup chunk with the below code and then try changing each option from to and changing the numeric values then knit the file again to see the difference it makes. , # whether to show messages from your code , # whether to show warnings from your code Note that and control the original size and aspect ratio of images generated by R, such as plots. This will affect the relative size of text and other elements in plots. It does not affect the size of existing images at all. However, controls the display size of both existing images and figures generated by R. This is usually set as a percentage of the page width. Figure 2.7: A plot with the default values of fig.width = 8, fig.height = 5, out.width = “100%” Figure 2.8: The same plot with half the default width and height: fig.width = 4, fig.height = 2.5, out.width = “100%” Figure 2.9: The same plot as above at half the output width: fig.width = 4, fig.height = 2.5, out.width = “50%” These setup options change the behaviour for the entire document, however, you can override the behaviour for individual code chunks. For example, by default you might want to hide your code but there also might be an occasion where you want to show the code you used to analyse your data. You can set in your setup chunk to make hiding code the default but in the individual code chunk for your plot set . Try this now and knit the file to see the results. Additionally, you can also override the default image display size or dimensions. You should add the packages you need in your setup chunk using . Often when you are working on a script, you will realize that you need to load another add-on package. Don’t bury the call to way down in the script. Put it in the setup chunk so the user has an overview of what packages are needed. Move the code that loads the and to the setup chunk. Finally, the YAML header is the bit at the very top of your Markdown document. You can set several options here as well. Try changing the values from to to see what the options do. The option prints data frames using automatically. You can use to default to the simple kable style, but you will need the code from Section 2.5.5 for more complex tables with kableExtra. The built-in bootswatch themes are: default, cerulean, cosmo, darkly, flatly, journal, lumen, paper, readable, sandstone, simplex, spacelab, united, and yeti. You can view and download more themes. Try changing the theme to see which one you like best. YAML headers can be very picky about spaces and semicolons (the rest of R Markdown is much more forgiving). For example, if you put a space before “author”, you will get an error that looks like: Error in yaml::yaml.load(..., eval.expr = TRUE) : Parser error: while parsing a block mapping at line 1, column 1 did not find expected key at line 2, column 2 The error message will tell you exactly where the problem is (the second character of the second line of the YAML header), and it’s usually a matter of fixing typos or making sure that the indenting is exactly right. The table of contents is created by setting . It will be displayed at the top of your document unless you set or include with its options and (options for a setting are indented under it). This will use the markdown header structure to create the table of contents. means that the table of contents will only display headers up to level 3 (i.e., those that start with three hashes: ). Add after the header title to remove it from the table of contents (e.g., ). If your table of contents isn’t showing up correctly, this probably means that your headers are not set up right. Make sure that headers have no spaces before the hashes and at least one space after the hashes. For example, won’t display as a header and be added to the table of contents, but will. So far we’ve just knitted to html. To generate PDF reports, you need to install (Xie, 2021) and run the following code in the console (do not add this to your Rmd file): Once you’ve done this, update your YAML heading to add a section and knit a PDF document. The options for PDFs are more limited than for HTML documents, so if you just replace with , you may need to remove some options, such as if you get an error that looks like “Functions that produce HTML output found in document targeting PDF output.” As an alternative, you can also knit to a Word document. When you click the button, the first format will knit by default, but you can use the drop-down menu under the Knit button to choose another format. If you encounter errors, ask on Teams for help - knitting to PDF or Word can be tricky. This chapter has covered a lot but hopefully now you have a much better idea of what Markdown is able to do. Whilst working in Markdown takes longer in the initial set-up stage, once you have a fully reproducible report you can plug in new data each week or month and simply click knit, reducing duplication of effort, and the human error that comes with it. You can access a working R Markdown file with the code from the example above to compare to your own code. As you continue to work through the book you will learn how to wrangle and analyse your data and how to use Markdown to present it. We’ll slowly build on the available customisation options so over the course of next few weeks, you’ll find your Markdown reports start to look more polished and professional."
    },
    {
        "link": "https://clouddefense.ai/code/javascript/example/markdown-table",
        "document": "Dive into secure and efficient coding practices with our curated list of the top 10 examples showcasing ' markdown-table ' in functional components in JavaScript. Our advanced machine learning engine meticulously scans each line of code, cross-referencing millions of open source libraries to ensure your implementation is not just functional, but also robust and secure. Elevate your React applications to new heights by mastering the art of handling side effects, API calls, and asynchronous operations with confidence and precision."
    },
    {
        "link": "https://linkedin.com/pulse/markdown-tables-howto-jochen-gererstorfer-5hhjf",
        "document": "If you are a writer or a programmer who frequently works with Markdown, you've probably encountered the need to create tables in your documents. In this comprehensive guide, we will explore the intricacies of Markdown tables, including their syntax, formatting, alignment, and some valuable tips and tools to streamline the table creation process.\n\nMarkdown tables are a powerful tool for organizing and presenting data in a structured format. To create a table, you use a combination of hyphens and pipes to define the columns and rows. Let's delve into the specifics of creating and formatting Markdown tables.\n\nTo add a table, you'll use three or more hyphens (---) to create each column's header and use pipes (|) to separate each column. It's important to note that you should also add a pipe on either end of the row for compatibility.\n\nYou have the flexibility to align text in the columns to the left, right, or center by adding a colon (:) to the left, right, or on both sides of the hyphens within the header row.\n\nIn addition to basic data, you can also format the text within tables. This includes adding links, inline code, and emphasis, providing you with a versatile platform for presenting diverse content.\n\nMarkdown tables are known for their limitations, especially when it comes to formatting the text within table cells. However, there are workarounds for common table issues such as line breaks and lists.\n\nGitHub has expanded the standard Markdown syntax with additional features, including tables. The syntax for creating tables in GitHub Flavored Markdown (GFM) involves using vertical pipes to separate columns and hyphens to demarcate the table header from the table body.\n\nMarkdown tables are a valuable asset for writers and programmers alike, providing a straightforward means of organizing and presenting tabular data within your documents. While they may have some limitations, the flexibility and ease of use make them a worthwhile addition to your Markdown toolkit.\n\nRemember, if you find the manual creation of Markdown tables to be a cumbersome process, there are several Markdown table generators available that can streamline the task for you. By leveraging these tools and understanding the nuances of Markdown table syntax, you can enhance the visual appeal and organization of your content, ultimately improving the overall readability and comprehension for your audience.\n\nWhether you are creating technical documentation, project notes, or any other type of content, mastering the art of Markdown tables can significantly elevate the quality and impact of your work.\n\nRemember, the key to mastering Markdown tables is practice, experimentation, and the utilization of helpful resources and tools. By incorporating Markdown tables into your workflow, you can enhance the visual appeal and organization of your content, ultimately improving the overall readability and comprehension for your audience."
    },
    {
        "link": "https://ardalis.com/how-to-easily-format-tables-in-markdown",
        "document": "I'm a big fan of Markdown. It provides a simple way to richly format text without the complexity or security issues that would come from using HTML. Support for Markdown is ubiquitous within the software development industry, with native support everywhere from GitHub to StackOverflow. I've written everything from short documentation articles to several entire ebooks for Microsoft using Markdown. I've even recently moved my blog to GatsbyJS/Netlify/Github using Markdown (you can see this article's source here)! But one thing that has always been a real pain with Markdown is table formatting.\n\nTables are often the best way to present some data. I learned about HTML tables early in my career, before CSS really was a thing, and we used them not just for data presentation but also layout. I got pretty good at defining TR and TD tags and spanning this or that cell across multiple rows or columns to make it fit where I wanted. Markdown doesn't do any of that. There are no tags. Instead, you basically draw the tables as ASCII art by using | and - characters. In my experience it's quite tedious and easy to get wrong when doing it by hand.\n\nFortunately, you don't have to.\n\nThere's a really nice tool I found recently called Tables Generator. It's a web site that will let you author your table and then click a button to generate the Markdown needed to produce it. It also supports LaTeX and HTML table syntax if you prefer. Just click on the sample table and start adding text. When you're ready, click Generate to see the resulting Markdown. Then copy/paste it into your markdown file and you're done!\n\nThat's really all there is to it. The tool supports some basic formatting and makes it easy to build the table you need. It was a big help to me recently on some work I was doing that involved a few complex tables. I hope you find it useful."
    },
    {
        "link": "https://umbrex.com/resources/industry-analyses/how-to-analyze-a-retail-company/markdown-strategy-and-effectiveness",
        "document": "Gather data on product sales, inventory levels, and pricing before, during, and after markdown periods. This will provide insights into the sales lift and inventory movement driven by markdowns.\n\nFor each product, calculate the markdown percentage to understand the depth of the discount offered:\n\n\n\nThis metric shows how much of a price reduction was applied.\n\nThe sell-through rate helps measure how much of the inventory was sold during the markdown period:\n\n\n\nSell-Through Rate (%) = (Units Sold During Markdown / Total Units Available Before Markdown) x 100\n\n\n\nA high sell-through rate indicates that the markdown successfully moved inventory, while a low rate may indicate a need for deeper discounts.\n\nCompare the sales volume and revenue generated before, during, and after the markdown.\n\nUse the following equation to calculate the sales lift during the markdown:\n\n\n\nSales Lift (%) = ((Sales During Markdown – Sales Before Markdown) / Sales Before Markdown) x 100\n\n\n\nThis helps assess the effectiveness of the markdown in boosting sales.\n\nTo assess the profitability of the markdown, calculate the gross profit margin both before and during the markdown period:\n\n\n\nA significant drop in the profit margin may indicate that the markdown was too deep, while a slight reduction may indicate that the markdown was well-targeted.\n\nExamine whether markdowns were applied at the optimal time, such as before product obsolescence or seasonality shifts. Assess inventory levels before and after the markdown to ensure that markdowns are being used effectively to clear out slow-moving products.\n\nIf foot traffic and conversion data are available, analyze how markdowns affect customer behavior. Increased foot traffic or higher conversion rates during markdowns suggest that the discounts are effectively driving customer demand."
    },
    {
        "link": "https://retalon.com/blog/retail-markdown-strategy",
        "document": "Finding the Right Markdown Strategy for Your Retail Business\n\nRetailers need to consider many markdown strategies to find the one(s) that align with their products, their markets, and their overall business. It’s imperative that they understand not only the nuances of their retail business\n\nLet’s take a look at five effective retail markdown strategies;\n\n1. Develop clear KPIs and goals for your markdown strategy\n\nAnd you know what they say — “What gets measured gets managed.”\n\nDeveloping specific, measurable key performance indicators (KPIs) for your markdown pricing ensures your decisions align with company objectives.\n\nYou can use your KPI performance to inform future markdown plans as you start planning for the next product. The KPI could be something as simple as a target date for zero inventory. Or you could track the markdown’s impact on ROI.\n\nThe important thing is to monitor that KPI before, during, and after you set the markdown so you have time to react if necessary.\n\nOnline stores often adopt an agile pricing strategy that uses predetermined triggers to respond to changing inventory and market conditions. For example, they can keep their prices high when competitors are out of stock.\n\nIn more competitive markets, retailers can also use price matching to boost sales without cutting prices permanently.\n\nAgile pricing can help you set pre-meditated markdown points (either by date, sales, or some other trigger) to ensure that you don’t wait too long for your markdowns and miss the chance to clear your inventories with maximum margins.\n\nAgile markdowns are not limited to online sales, retailers can adopt this strategy with their brick-and-mortar stores. In either case, retailers must have clear, data-driven criteria for what triggers the price actions.\n\nClustering stores by particular attributes lets you introduce markdowns selectively.\n\nStore geography is one option to form localized store clusters that respond to weather-related sales cycles.\n\nThe summer selling season ends at different times in Maine and Arizona, so company-wide markdowns on cargo shorts are counter-productive.\n\nLocalized markdowns let you preserve profits in stores where products remain in high demand while accelerating sales in stores with fading demand.\n\nTo use this retail markdown strategy to its maximum effectiveness, you can also localize markdowns based on other attributes like store formats, shared demographics, and other factors that impact demand (provided you have visibility into these criteria and a method to act on this data).\n\nIn an effort to avoid last-minute drastic price cuts, retailers pre-plan markdown timing (and amounts) for products with specific lifecycles. In this way, retailers can leverage increased demand while maintaining higher margins.\n\nNew television SKUs maintain demand for up to twelve months while fast fashion SKUs need to disappear in sixty days. Knowing their assortment and the seasonality of their categories, retailers can plan a series of markdowns rather than waiting for end-of-life.\n\nIn the case of TVs, the retailer may mark prices in month six, again in month nine, and make the steepest cut in month twelve — just as the new model is around the corner. However, the retailer may adjust the timing and size of the markdowns based on holidays and major sporting events.\n\nMarkdown timing is not a precise strategy and will vary by product, by market, and even by store.\n\n5. Use alternative pricing strategies in your markdowns\n\nA straight price cut may not be the best way to mark down end-of-life products.\n\nRetailers have many other pricing strategies to choose from.\n\nBuy-One-Get-One bundle pricing has the financial impact of a 50% price cut, but it doubles the number of units customers buy. Similarly, you can use optional pricing to pair an end-of-life accessory with a related product at full price.\n\nIt should go without saying that this doesn’t work across the board in every situation. Pairing a winter jacket with a TV purchase may not work particularly well. But pairing an end-of-life Blu-ray movie with a TV makes a lot of sense.\n\nEach type of markdown works best with certain products in certain situations. The key is to know whether these options are better than a simple price drop.\n\nUsed properly, these retail markdown strategies can work wonders for your margins.\n\nBut when they fail, it is often because retailers did not fully consider these common issues:\n\nManually planning markdowns for every SKU in an assortment is impossible (without specialized markdown software) for all but the smallest retailers. Everyone else must focus resources on high-impact products.\n\nFor the vast majority of SKUs, general markdown policies within each product category will apply.\n\nAt best, this leaves money on the table. But when things go wrong, the costs quickly mount.\n\nMarkdowns look straightforward on paper, but the in-store reality is always different.\n\nThe response to a markdown will vary due to timing, seasonality, markdown type, price elasticity of demand, and many other variables. When retailers do not account for these variables fully, their markdown strategies fall apart.\n\nDetermining a retail markdown strategy without considering a product’s entire price strategy throughout its life cycle will be ineffective.\n\nAn optimal markdown strategy should be a part of a larger pricing strategy which begins with initial pricing and accounts for all promotional events.\n\nFurthermore, your pricing strategies should work in tandem with your assortment strategies, because if you don’t consider other products in your categories and families when setting pricing, you may run into issues of product cannibalization.\n\nThe need for markdowns does not appear out of thin air. It must be considered at the top of the product lifecycle.\n\nRetailers may execute the product introduction perfectly and get solid results from their promotional plans only to see the product’s profit margins erased by end-of-life markdowns.\n\nIn this example, offering a hat-and-gloves bundle may boost demand enough to clear inventory without the steep markdown. But this cannot happen unless the retailer plans to have enough gloves in stock.\n\nWithout early planning, a retailer’s markdown options will be severely constrained.\n\nThe only way to gain actionable insights into markdown pricing is by digging deep into a retailer’s data while considering a number of other relevant factors. Basing a pricing strategy on previous years’ sales data alone causes baked-in steep markdowns and miscalculations."
    },
    {
        "link": "https://medium.com/intel-tech/tabular-data-rag-llms-improve-results-through-data-table-prompting-bcb42678914b",
        "document": "How to ingest small tabular data when working with LLMs.\n\nSay you’re a financial analyst working for an investment firm. Your job involves staying ahead of market trends and identifying potential investment opportunities for your clients, who are often curious about the world’s richest people and their sources of wealth. You might consider using a retrieval augmented generation (RAG) system to easily and quickly identify market trends, investment opportunities, and economic risks as well as answer questions like, “Which industry has the highest number of billionaires?” or “How does the gender distribution of billionaires compare across different regions?”\n\nYour first step is to go to the source to get that information. However, as you do an initial inspection, you discover a possible obstacle. The document contains not only text but also TABLES!\n\nIn this post, we’ll demonstrate how to use a large language model (LLM) model to consume tabular data in different formats.\n\nLLMs and the Challenge of Structured Data\n\nFor us humans, it’s straightforward to connect the dots between the text and the table. But for LLMs, it’s like trying to solve a puzzle without all the pieces.\n\nLLMs are designed to process text in a sequential manner, meaning they read and understand information one word or sentence at a time. This sequential processing is how they’ve been trained on vast amounts of text data. However, tables present information in a different format. They organize data into rows and columns, which creates a multidimensional structure.\n\nUnderstanding this structure requires a different approach for LLMs than sequential text. LLMs need to recognize patterns across rows and columns, understand relationships between different data points, and interpret the meaning of headers and cell values. Because LLMs are primarily trained on sequential text, they might struggle to interpret and process tabular data. It’s like asking someone who’s used to reading novels to suddenly understand and interpret graphs or charts; they might find it challenging because it’s outside their usual mode of processing information.\n\nWe can find tabular data more commonly than we might think. Below are three scenarios ranging from small, medium, to large:\n• Small: Every day, users of our RAG platform will need to support their queries with documents that contain embedded small tabular data, as the example shown in Image 1. where the document contains mostly text and some tables. An industry report on global sales is another good example of small tabular data as it features textual analysis alongside tables detailing sales figures, which are often broken down by region and manufacturer. We can’t remove that tabular data to make it easy for our model to consume because it provides critical context.\n• Medium: For some situations, you may need to analyze a greater amount of tabular data, such as spreadsheets, CSV files (comma-separated values), or data preformatted by our preferred reporting tools, such as Power BI. Say, for example, you’re working on a marketing team at a retail company, which is analyzing sales data from the past quarter to identify trends and opportunities for growth. This data would likely come in the form of multiple database files containing information on product sales, customer demographics, and regional sales performance.\n• Large: A third scenario in which our users might wish to perform data analysis involves transaction databases and multidimensional datasets, such as OLAP cubes, because they offer advantages over spreadsheets for analyzing large amounts of complex data. OLAP provides fast query performance, support for complex calculations, and the ability to slice and dice data across multiple dimensions. OLAP cubes are better suited for handling the complexity and volume of data typically found in transaction databases or other large datasets, which require an understanding of the data information domain. For example, if you’re a retail chain analyzing data to enhance sales performance, you’ll need SQL for querying and OLAP cubes for analysis to garner insights from sales trends and customer segmentation to inform inventory management and marketing strategies. These tables can be large to analyze and understand.\n\nIn this article, we’ll explore the scenario where tabular data is embedded within textual information. We’ll work with small tables containing a dozen rows and a few columns, all within the model’s context window capacity.\n\nLet’s See It in Action\n\nOur example will be based on Figure 1, which shows the world billionaires list, to feed into our future RAG framework and answer questions about that billionaire list. With just four steps, we can demonstrate the use of tabular data as context for our users’ questions and even verify whether it’s possible to make the model incur errors.\n\nTo facilitate the tabular display of the results, we will use the “BeautifulTable” library, which provides a visually attractive format in a terminal (beautifultable’s documentation).\n\nSince we will only be working with tables, let’s explore the capabilities of camelot-py, another useful python library. We can follow the installation instructions at Installation of dependencies and Ghostscript dependency from Ghostscript Downloads.\n\nWe will save the list (the world’s billionaires) as a PDF to facilitate our exploration.\n\nThe code below will allow us, in a basic way, to clean the data once it has been extracted as a Pandas dataframe. This routine processes page by page from a preselected list and will allow us to have access to a structure that is easy to manipulate.\n\nNote: The below code was adapted by the author from Recursive Retriever + Query Engine Demo\n\nNow, let’s convert our tabular data from data frame into multiple formats, such as: Json, CSV or Markdown, among others.\n\nIt’s time to explore our test data. We have configured a dataset where each row represents an output format from dataframe and the data in “Data raw” corresponds to the tabular data that we will use with the generative model."
    }
]