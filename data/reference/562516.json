[
    {
        "link": "https://docs.unity3d.com/Manual/CollidersOverview.html",
        "document": "In Unity, a collision happens when two GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary that are configured for collision occupy the same physical space. Collision is a foundational part of most games, and many interactive applications and simulators.\n\nTo handle collision between GameObjects, Unity uses colliders. A collider is a Unity component that defines the shape of a GameObject for the purposes of physical collisions. Colliders are invisible, and do not need to be the same shape as the GameObject’s mesh.\n\nFor guidance on how to add components to a GameObject, see Use Components.\n\nEach 3D collider has a 2D equivalent. In Unity, 2D and 3D physics run on different physics simulation systems. For guidance on 2D physics colliders, see Collider 2D.\n\nA collider’s type is based on the configuration of its GameObject’s Collider and RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary components. This configuration determines how a collider behaves, and how it interacts with other colliders.\n• Static colliders: The GameObject has a collider but no Rigidbody.\n• Rigidbody colliders: The GameObject has a collider and a Rigidbody.\n• Dynamic colliders: The Rigidbody is dynamic (that is, it has Is Kinematic disabled).\n• Kinematic colliders: The Rigidbody is kinematic (that is, it has Is Kinematic enabled).\n\nThere is also a sub-type of collider called a Trigger collider. Trigger colliders do not physically collide with other colliders; instead, Unity calls a function when other colliders pass through them.\n\nTrigger colliders don’t cause collisions. Instead, they detect other Colliders that pass through them, and call functions that you can use to initiate events (see Use collisions to trigger other events).\n\nTo turn a collider into a trigger collider, enable the Is Trigger property on the Collider component. A trigger collider does not collide with other colliders; instead, other colliders pass through it.\n\nFor a trigger collider to work, at least one GameObject involved in the collision must have a Rigidbody. Trigger colliders can be any collider type (static or Rigidbody), but in most cases it’s good practice to make the trigger collider a static collider. and add a Rigidbody to the GameObject that passes through the trigger. If several GameObjects are passing through one trigger, there must be a Rigidbody on at least one GameObject in each collision pair.\n\nTriggers can be any collider shape (see Collider shapes), and they can be visible or invisible. To make a trigger invisible, add the collider to an empty GameObject. Only add a trigger to a visible GameObject if it is okay for other GameObjects to visibly pass through it.\n\nFor gameplay and simulation, triggers might need some adjustment to make them feel intuitive for the player. For example, you could experiment with making a trigger collider slightly larger than its associated visible GameObject, so that it has a wider radius.\n\nFor information on how different collider types interact with each other on collision, see Interaction between collider types.\n\nCollider components are available in different shape configurations. There are three main shape types for colliders:\n\nPrimitive colliders are built-in simple shapes that you can attach to your GameObject and scale to approximately the same size and shape. You can also combine several primitive collider shapes to create compound colliders. Mesh collidersA free-form collider component which accepts a mesh reference to define its collision surface shape. More info\n\nSee in Glossary exactly match the shape of the GameObject’s MeshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary. They are more accurate than primitive colliders for complex shapes, but require more computational resources. Wheel collidersA special collider for grounded vehicles. It has built-in collision detection, wheel physics, and a slip-based tire friction model. It can be used for objects other than wheels, but it is specifically designed for vehicles with wheels. More info\n\nSee in Glossary are raycast-based Colliders specifically for in-game items that have physics-simulated wheels (for example, vehicles). They have built-in wheel physics, and controls for friction.\n\nYou can control the friction and bounciness of a collider’s surface. When two colliders meet, the physics system uses the properties of each surface to calculate the friction and bounce between them.\n\nFor more information, see Collider surfaces."
    },
    {
        "link": "https://discussions.unity.com/t/race-track-section-colliders/392590",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/collision-detection.html",
        "document": "Collision detection is the physics engineA system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info\n\nSee in Glossary’s process for detecting when a physics body (Rigidbody or ArticulationBody) comes into contact with a colliderAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary. Unity provides different collisionA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary detection algorithms for different situations, so that you can choose the most efficient approach for each individual physics body (Rigidbody or Articulation Body) in your sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/laubty/how_does_collision_really_work_in_games",
        "document": "I am using unity for over a year now... The collision system seems pretty good for making the player staying on top of the ground and collide with terrain in general.\n\nIn some other case, you would also wanna use raycasting, for faster-moving objects, which is also a form of collision\n\nThis is what I want to learn:\n• Is the box collider that is used in many game engines like unity just a raycast?\n• When it does detect a collision, how does it make sure the player stays out of the collided object? Does it apply a force? Does it change the velocity of, does it change the position of the player?\n• (optional) How would you build a collision system? Is it worth it? Is it too difficult to do?"
    },
    {
        "link": "https://discussions.unity.com/t/collision-systems-what-approach-do-you-use/711037",
        "document": ""
    },
    {
        "link": "https://construct.net/en/tutorials/bite-sized-game-development-670",
        "document": "In this tutorial, I'm going to attempt to create a simple top-down racing protoype. In this game, the other cars in the race will be played by the computer who will attempt to go around the track faster than the player.\n\nWe're going to build this up from scratch, starting with building the track and the game rules for one player, and then adding in the computer players near the end. The computer players will have relatively simple behaviour so this tutorial is good for beginners.\n\nGetting started on a racing game in construct 2 is quite simple, there are a couple of examples out there, and there's a car object behaviour which handles most of what we need to get going. First lets find some assets.\n\nI have used two sprites from opengameart.org for this. The track sprite is from a small pack by TRBRY and the car sprite is made by sheikh_tuhin & qubodup. Remember the GOLDEN RULE if you use assets someone created and posted on an open source platform : Provide credit in your games and comment on the creator's work!\n\nWe'll also need some sort of sprite to give the 'solid' behaviour to act as a wall, and a background of some sort to give the game a little colour. Once our sprites are imported we can start using the track pieces to build our race course, which thanks to construct 2's editor should be relatively simple. Place the background, walls, car and track wherever works, but make sure you give the car sprite the 'car' and 'scroll to' behaviours, and the walls the 'solid' behaviour, and ensure you have the entire game area bordered by walls so theres no chance of the player 'escaping'.\n\nThe last thing we need to do to make this little prototype a bit of extra life is to make the car go faster when its on track, and slower when its off track. Ensure the track's collision polygons are correct, and use the events below to make the car's speed faster when its on the track, making sure you have all track sprites in a family :\n\nOf course, you can adjust these values as you find appropriate. Heres a playable prototype of the track which has all the turns and straights in it I plan to use, and a few walls to crash into, for testing purposes :\n\nSo we have a basic track the player can drive around, lets look at a way we can create a computer controlled car for the player to race against. Lets add another sprite in for the computer to control, with slightly different colours, and create a family between the two car sprites as they will share many of the same behaviours, however, make sure you disable the 'default controls' for the AI cars, otherwise the player will also control them!\n\nHeres the big question : How do we get the computer to drive around the track? AI is always a tricky task for any game, and for each game theres plenty of options available to create a viable and fun compuer opponent to play against. Here's how I've gone about tackling this specific problem:\n\nI've placed a waypoint sprite at each turn in the track. Each waypoint has an instance variable that states what number waypoint it is in the track. We are going to get the computer to drive their car towards each waypoint, moving them on to the next after they reach each one. When they complete a lap by reaching the last waypoint in the track, it will simply loop them back to the first waypoint again and they will start another lap.\n\nIm going to create another sprite, a simple line, and put the origin point at one end of it. For every tick, place the line on the front of the AI car, and use the 'set angle towards' action to get it to point at the next waypoint (the value of which is kept as an instance variable in the AI car, and is increased every time the car passes over a waypoint), we can use this to determine what angle the AI car should be pointing towards. If the AI car's angle is not within 10 degrees of the target angle, we simulate control and make it turn until it does hit the target angle, otherwise, we simulate control 'accellerate'.\n\nLike before, you can alter the amount of degrees the computer can be off before it corrects itself, and you can move the waypoints around to tweak the behaviour. Here is the current prototype of this early stage of AI in action, it shows all the waypoints and the guide line for the AI car :\n\nPart 3 : A more complex track and better AI\n\nOk, we have a track and a computer opponent to race around it, but the track right now is a little dull. Lets change some track pieces and add some extra walls, but be sure to add a waypoint at every turn, and make sure the waypoints instance variables are numbered correctly. Also dont forget to update the 'total waypoints' variable!\n\nHeres a screenshot of the new track :\n\nLets test our AI out on this new track, I wonder if you can guess what happens?\n\nUse this link if the above gif does not animate : scirra.com/images/articles/AICrash2.gif\n\nDisaster! The AI car will make it round the track, but as we have only implemented turning right, when a left turn comes up, the car drives around in almost a full circle to get to its destination!\n\nHow can we fix this? We simply need to add a new pair of events in our event sheet that take place after we compute wether the car has to turn or not. The events in the screenshot below basically asks if the angle the car is facing on is to the left or to the right of the angle of the pointer, and then simulates control for the car dependant on the answer.\n\nThe car should now drive around the track, completing both left and right turns successfully. To fully test this AI works, im going to edit the track further, making half of the track slower with lots of turns, and the other half out of long straights. It might have some dodgy looking walls and track in places, but the result is linked below. The first link is with the waypoint markers and lines in place, the second link is without.\n\nLets make the race more exciting! Instead of just having one opponent, lets have three! Create two additional car sprites, and two additional AI pointers for the cars to use. Create an instance variable for the AI Cars object called AICarNumber, and an instance variable for the pointers called assigned to car. We are going to use these instance variables to 'pair' each car with a pointer.\n\nSo how do we make sure the AI events pair the correct car with the correct pointer each tick? This is more simple than it looks, just use a for loop, with an added condition to select the right pointer, and make the rest of the AI a sub event of this event :\n\nThats pretty much it! The computer controlled racers will now race around the track and jostle for position, and if they crash or get thrown off course they will do their best to recover and get back on track.\n\nSo, we have a decent track and three computer drivers that can race around the track and correct themselves if they are pushed off their racing line. The AI and some of the game mechanics could use some work, but for now I will save that for a more advanced tutorial.\n\nIf you would like to use what I have made currently, without any further improvements or additions, I have released the .capx file and the game in its current state on the arcade to be used as an example. When playing the game, you can hold space to see the AI helpers. The arcade link is here : AI Racer example\n\nBefore I could release this as a full game, I'd have to add some touches to make this into a real game, such as :\n\n- A simple menu screen that starts the game up, and clicking start on the menu screen starts a countdown which gives the player time to get ready before the race starts.\n\n- Sound effects for accelleration, braking, crashing, the start of race countdown and the finish.\n\n- A way to keep hold of the lap count and display it during the race, so that we know how many laps have passed while the race is going on and when it is finished.\n\n- A timer that shows how much time has passed since the race started.\n\n- Win/Loss screen after race ends depending on wether the player or the computer has won.\n\n- Play again button which either restarts the layout or resets everything to their original values and positions.\n\nThese additions should put the game into a releaseable state.\n\nThats the end of this tutorial! There's a good platform for expansion here, so I'll likely come back to this, perhaps to write a tutorial for improved AI. Hope this helps someone!\n\nPlease leave a comment or any feedback you have in the usual place, thanks!"
    },
    {
        "link": "https://wiki.gdevelop.io/gdevelop5/tutorials/roadrider",
        "document": "This tutorial will help you get more familiar with GDevelop. Our primary focus in this tutorial will be to make an endless car game. The player should dodge the cars on the road. The game will also have a score such that it is automatically updated as we get past the cars.\n\nIf you do not have GDevelop yet, you can download it from GDevelop's official website. It is available for Windows, macOS as well as Linux.\n\nAfter downloading GDevelop you can proceed with the installation/extraction followed by the launching of GDevelop.\n\nClick on on the Start Page.\n\nClick on (you might have to scroll down to find this option) in the dialog box that appears and choose the location where you want to save your project.\n\nis the area where we'll work for most of our time while creating the game. A scene is basically a level in your game (or a menu, inventory, etc...). It contains objects that can be put on the screen.\n\nAs soon as we click on Empty game we see a panel on the left side of our screen. This is the . Click on the option in the Project Manager.\n\nCreate a new scene using the option from the drop-down that appears. Our new scene has been created. Go to your new scene by clicking on .\n\nChoose the option from the panel on the right side.\n\nChoose from the pop-up. This will be followed by the appearance of a dialog box.\n\nThe object is called NewObject by default - you can see the name at the top of the dialog. It's a good idea to give a descriptive name to each object so that you can understand what they are when dealing with them in events. In our case, use the field to set the name to Car.\n\nLet's add an animation to the object. Animations are containing images that are displayed on screen for Sprite objects.\n\nTo add an animation to the object, click on the + symbol beside .\n\nAdd the image named 'car.png' as animation and click on the option.\n\nSimilarly, add a new Sprite object Highway which consists of the image 'highway.png' as the animation.\n\nOur next step will be to add the 4 cars as different Sprite objects. These will be the objects that we need to dodge. We can name them Blue, Gray, Green and Pink which would have the image 'blue-car.png', 'gray-car.png', 'green-car.png' and 'pink-car.png' for their respective animations. From now on, we will address these cars as 'Traffic cars'.\n\nCreate a new Sprite object Tree which has 'tree.png' for its animation. This object will be used for the trees that will be created on either side of the road as we're progressing in the game.\n\nCreate a new Sprite object Explosion and select all the images from 'Explosion1.png' to 'Explosion8.png'.\n\nYour scene by the end of this step should contain 8 objects.\n\nAdding a top-down movement behavior to the car will allow us to set its maximum speed as well as the acceleration and deceleration of the car. This will allow the car to slowly gain the speed rather than starting with the maximum speed. For this, we will have to open the .\n\nTo do this, you can either double-click on the Car object from the object side panel or click on the three-dot-menu beside the object and click on edit object.\n\nClick on the tab at the top of the panel and click on the + button beside Click to add a behavior to the object .\n\nChoose in the Add a new behavior to the object pop-up.\n\nThis opens a wide variety of options to alter. You can see the default values for the related to the behavior. Set the deceleration to 400 and untick the boxes having the options and and click . Rest of the default values are fine for our game.\n\nAn event is a pair of conditions and actions. When a given set of conditions is true, the corresponding action or set of actions is performed.\n\nWhile making this game we will encounter a few events with no conditions and one or more actions assigned to them. In such a case, the action is performed on every frame created.\n\nTo add a new event, open the tab from the top\n\nFrom the events editor toolbar choose the option that says .\n\nThis will create a new event with an empty condition and an empty action.\n\nTo create an instance of the Car object we can drag and drop the object from the Objects panel to the scene and give it the coordinates of our choice.\n\nIf you need to alter the coordinates of the object after getting it on the scene, you can do so by the drag and drop method, but by dragging the object on the scene.\n\nAnother method to move the object is by changing the X and Y-coordinates in the Object properties panel on the left side.\n\nYou can choose the values of your choice but if you want results similar to that of the tutorial, you are expected to have the same values.\n\nSimilarly, to create an instance of Highway you can drag and drop the object to the scene and set its X and Y-coordinates.\n\nA user can use the preview feature provided by GDevelop. Using this feature, you can see how the game behaves in the real world. You can preview your project by clicking on icon above the scene.\n\nYou should see something similar to the image shown below.\n\nWe see a few problems:\n• The Car is not fully visible.\n• The part of the screen below the Highway is empty.\n• The Highway is too far away from the center of the screen.\n\nTo make the car visible, we need to know the reason for it being hidden under the Highway. The answer is, .\n\nIn our case, we can assign a Z Order of 1 to the Highway and 2 to the Car.\n\nCreating the bottom part of the Highway\n\nTo create the bottom part of the Highway, we can elongate the height of our object Highway.\n\nTo do this, you can click and drag the white box at the corner of the Highway.\n\nAnother way to do this is to tick the box beside option in the Properties panel and enter the height and width of your choice.\n\nGetting our game to the center of the window\n\nTo get our game to the center of the preview window, we will create our first event.\n\nBut before that, we need to determine the X position and Y position of the camera.\n\nFor the X position, the camera has to be at the center of the window/highway. The width of the Highway is 535 pixels. So the center of the Highway will lie at 267.5 pixels.\n\nSimilarly, to set the Y position of the camera, we can keep it a little above the Car so that the player can get a better view of the cars approaching. set it at 350 pixels.\n\nFirst, create a new empty event using the explanation above.\n\nWe need to make an event such that the game lies in the center of the screen. Therefore, setting the X and Y-coordinates will be our action.\n\nThis action needs to be true for all frames, i.e. for all conditions. And so that the action is true for all conditions, we enter no condition.\n\nTo add an action, click on the option.\n\nTo choose an action, you can either choose it from the various drop-down menus available or you can use the search bar at the top.\n\nFor example, to change the position of the camera, you can go to Layers and Cameras followed by . The right part of the window will now display configurable parameters.\n\nBecause we want to set the X position equal - neither less nor more - to 267.5, choose the = (set to) option in . In the field, you can enter the desired X coordinate of the camera.\n\nElse, you can search for the action in the top bar.\n\nYou can now see the added action in the Events Editor.\n\nTo set the Y position of the camera center, click on in the same event.\n\nYou can now follow a similar procedure for Y position as you did for X position but make sure that this time you choose the option and enter the Y coordinate.\n\nTo make sure that all your progress has been saved, click on in the menu or press Ctrl + S.\n\nTo move the Car, we need to create an event such that the car translates as well as rotates to some degree when left or right key is pressed.\n\nAs we can deduce from the above statement, the condition of the events will be left key press and right key press.\n\nWe will start with the event that has the condition of left key press.\n\nFor the action, when the left key is pressed, the Car should have a movement on the left side. This can be easily done using an action that would simulate the left side movement for the object selected (Car).\n\nBut make sure to use the action with the same behavior as your object (top-down movement). So, we need to choose it from the drop-down.\n\nNow we need to give our Car the desired rotation for a better visual experience. If we just give rotation to the object it will rotate up to 180 degrees.\n\nTo avoid such a result, we need to set a final angle too. We will assume it to be 30 degrees on both sides, i.e. -30 degrees for the left key press and 30 degrees for the right key press.\n\nBut before we move ahead, we also need to assign the for the rotation. We will be using a value of 60 degrees/second for the same.\n\nRemember that the angular speed will be the same for both the key presses. It cannot be negative because it is the \"Angular speed\", and speed cannot be negative.\n\nWe can repeat a similar event for right key press.\n\nIf you preview your project, you should be able to control your Car using the left and right arrow keys.\n\nBut we still encounter one problem, the car does not return to its original state when we leave the keys. Instead, it stays oriented at an angle. Let's solve this problem now.\n\nReturning the car to its original orientation\n\nWe need to return the car to an angle of 0 degrees when none of the arrow keys are pressed. In other words, we need to return the car to an angle of 0 degrees when the conditions, right key press and left key press are inverted.\n\nTo achieve this, we add a new event and try to add the above 2 conditions, i.e. right key press inverted and left key press inverted. We add a condition and turn on the switch below that says .\n\nIn the same event, we add a similar inverted condition for right key press.\n\nFor the action, we will make an action for rotating it towards 0 degrees with an angular velocity of choice similar to what we did for the non-inverted conditions of key press.\n\nNow, the car moves and rotates to an extent when an arrow key is pressed and rotates back to the original angle when the keys are released.\n\nAdding traffic cars to be dodged to the scene\n\nNow, we need to begin creating traffic cars which should be dodged by the Car. To maintain uniformity and simplicity in the game, we will create the objects at a fixed Y position and a random X position within a fixed time interval such that all the traffic cars created lie between the yellow lines of the Highway.\n\nFor a fixed time interval, we can use the feature that GDevelop provides. To set a timer, we will create an event with the condition . Now, you need to fill the desired time interval between the creation of two consecutive instances of traffic cars on each side in the field.\n\nAfter entering the time you need to enter the name of the timer. It can be any name of your choice but remember to fill it within quotes.\n\nFor the first action, we can make use of a . A variable allows you to store number or text in the computer memory and a scene variable allows you to store a number or text only when a particular scene is active. You can read more about variables here.\n\nTo create a new variable, go to the Scene Editor, right-click on the background and click on . From the pop-up that appears, click on the button.\n\nNow click on the + button on the bottom-right of the new dialog, enter a name for your variable and click .\n\nWe will name our scene variable 'CarLeft'. To assign a value to your scene variable, use the action . Enter the name of the variable you created in the field.\n\nTo create the cars at random, we can assign a value using the expression \"RandomInRange\". is used to return a random integer between the minimum and maximum specified in the expression.\n\nWe'll use the expression such that whenever the expression returns 1, we will create a blue car in the first (leftmost) lane and whenever it returns 2, we will create a gray car in the second lane. Therefore, set the to = (set to) and the value to \"RandomInRange(1, 2)\".\n\nYou can add a similar action for a variable CarRight which can be used to create traffic cars on the right side of the highway.\n\nBefore adding events to check the value of our scene variable Car1, we will add one more action in the same event which will set the value of our timer to 0. To do this, we will use the action.\n\nThis is what our Events Editor should look like:\n\nTo check the value of Car1 and to create the corresponding traffic cars at the same moment as the CarTimer is reset, we will add a sub-event for each condition. A sub-event is performed only if the parent event's condition is true. You can read more about events here.\n\nYou can create a sub-event by clicking on the button at the top.\n\nThis will create a sub-event for the selected event.\n\nIn the condition of the sub-event, we will check if the value of CarLeft is equal to 1. To do this, we will add the condition. Enter the variable name CarLeft in the field, set the to = (equal to) and fill '1' in the field.\n\nFor the action, you can create the object Blue at the X coordinate of the first lane (70) and Y coordinate such that the object is created well above the window so that by the time it reaches the window with an acceleration of 1000 it reaches its constant maximum speed else the user might see the car accelerating in the window.\n\nYou can add a similar sub-event for Gray with the condition checking if the value of Car1 is 2.\n\nIf the condition is true, we will add an action to create Gray at the X position of the second lane (175) and Y coordinate -500.\n\nSimilar to what we did for variable CarLeft, we will now check the value of CarRight and create Green at (280, -500) if the value of CarRight is 1. If the value is 2, we will create Pink at the position (385, -500).\n\nHere is the resulting events sheet so far. If you are on the same page as the tutorial, you can save your game and proceed.\n\nAfter adding the traffic cars to be dodged, we will now add the surrounding trees which will simulate a moving background. We will use the object Tree for this purpose.\n\nTo create object Tree we use another timer TreeTimer, similar to how we used TrafficTimer. We will use these trees for moving background simulation by moving them in the backwards direction on both sides of the road.\n\nWe will set their Y coordinates such that they are created above the screen and for better viewing experience, you can create them at different Y positions so that they are not perfectly aligned.\n\nWe will set the X coordinates for both trees on both the sides such that the trees are right beside the Highway. The dimensions of the tree are 150×150 pixels.\n\nFor the left side of the Highway we will set the X position to -150 pixels and the Y position to -400 pixels.\n\nFor the right side, the X position will be set to 535 pixels and Y position to -500 pixels.\n\nWe need to add one more action to reset the TreeTimer to 0 when it is greater than 1 second.\n\nIn the game, we need to move the trees such that they never stop, i.e. without any condition. So we add an event and add action to that event without any conditions.\n\nOur trees should move in the direction opposite to that of the Car so that we can simulate a moving background. To do this, the event we add should add a downward force to the object Tree.\n\nAdd the action to the Tree. The movement of the car should be in the vertical direction only. There should not be a horizontal component of the force applied to it. So the speed on the X axis should be set to 0 and the speed on the Y axis will be set to 300 pixels/second.\n\nTo move the traffic cars, we can add events with no conditions and add a vertical force. But if we try to do it in a way similar to what we did for Tree, we will have to add these events for each and every car individually. To simplify this, we can use the feature provided by GDevelop.\n\nAn object group is a collection of objects. You can classify similar types of objects in an object group. You can then use the conditions and actions on a group object rather than repeating it for each and every object separately.\n\nBlue and Gray that should move on the left side of the highway will have the same motion for each object created. Similarly, Green and Pink should also have the same motion. So we can classify the 4 traffic cars to 2 object groups.\n\nTo open the , click on the icon in the toolbar.\n\nThis will open the object groups list. All the object groups in the scene will be visible on the list. To add a new object group to the list, click on the + sign beside . This will add a new group to the list.\n\nTo rename the group name, click on the three-dot-menu or right click on the object group name and choose \"Rename\". We will name the group TrafficLeft. Now add another group and rename it to TrafficRight.\n\nTo add objects to TrafficLeft, click on the group name. A new dialog will appear.\n\nClick on the Choose an object to add to the group field and choose the object Blue followed by Gray and click APPLY. This object group represents the cars on the left side of the highway.\n\nSimilarly, add Green and Pink to the group TrafficRight.\n\nTo move the cars we will now add an event with no conditions. We will now add a downward acting force to TrafficLeft and TrafficRight.\n\nObjects in TrafficLeft are cars that move in the same direction as Car. So these cars should move at a pace slower than Tree so it looks like the cars are moving faster than the background but slower than Car. We will apply a force of 100 pixels/second in the Y direction for TrafficLeft. The X component should be 0.\n\nOn the other hand, objects in TrafficRight move in the direction opposite to that of Car. So these cars should move faster than Tree so that they look like moving in the backward direction. We will apply a force of 500 pixels/second in the Y direction for TrafficRight.\n\nOn starting a preview of the project, you might not be able to see the traffic cars yet. You can solve this problem by setting a Z order for the objects in the same event. To use the action for all the objects at once, create a new object group Traffic. Add all the objects to the group.\n\nSet the Z order of Traffic higher than the Z order for Highway.\n\nYou may now check the events we have created so far and then save your game.\n\nBefore moving on to the event for a collision between Car and Traffic, we notice that the car's motion is not limited to the road.\n\nLimiting the car's motion between the yellow lines\n\nTo limit the car's motion between the yellow lines, we need to add a new event to check the X position of the Car.\n\nWe will add two different events for each side because the force applied should be positive when Car is on the left side and negative when Car is on the right side.\n\nThe distance of the yellow lines from both ends is 60 px while the width of the Car is 80 px, so its motion has to be limited between 60 px and (535 - 60 - 80), i.e. 395 px.\n\nThe force applied to the car should be greater than or equal to the maximum speed of the Car, set in its behavior (200, in our case).\n\nOur first event will include a condition that checks if the X position of the Car is less than 60 px.\n\nIf the condition is satisfied, a force greater than or equal to the maximum speed of the car should be applied in the opposite direction. Therefore, a force greater than or equal to 200 pixels/second should be applied on the Car along the X-axis.\n\nSimilarly, we need to add another event, with the condition to check if the X position of the Car is more than 395 px.\n\nIf the condition is true, a force with a magnitude higher than 200 pixels/second should be applied in the negative X direction.\n\nIf you preview the game, you should now be able to see Tree and all the objects in the group Traffic and the motion of the car should be constrained between the yellow lines.\n\nNow, we need to set how the game behaves when there's a collision between Car and Traffic.\n\nIn the next event we create, we need to set the condition such that it checks a collision between Car and Traffic.\n\nFor this, you can use the condition and set the objects to Car and Traffic.\n\nIn case of this condition being true, we need to create an object Explosion. You can use the action and fill Explosion in the field.\n\nWe need to create this object at the coordinates same as that for Car. To achieve this, you can use \"Car.X()\" and \"Car.Y()\" in the X position and Y position respectively.\n\nIf you watch the preview, there encounter a few minor issues:\n• Explosion cannot be seen.\n\nWe will now solve these problems. Make sure that you add these actions for the same condition.\n• To make the Explosion visible, add an event to set the Z Order of the object Explosion so that it is higher than that of the Highway\n• To remove the instance of Car we shall now add an event to delete the object Car.\n• Similar to what we did for Car, to remove an instance of Traffic we can delete the object Traffic too.\n\nYou can watch the preview now. Our game is ALMOST complete. We cannot say that the game is complete until we can see the score made by an individual.\n\nThe gray background does not really suit the game. As there will be trees on both sides of the road, the green color might be the best. To do so, you can right-click anywhere on the scene and select . Click on the box below that says .\n\nYou can choose the color of your choice and click in the .\n\nTo display the score, we will make an event such that when any object in the group Traffic passes a predefined position, the value of the score is updated. To do this, we need to use the help of a scene variable.\n\nFor this, you need to go to the Scene Editor and create a new object and choose from the table.\n\nYou can rename the object to Score and choose the text properties from the panel.\n\nYou can now drag and drop the Score object on the screen. You can also change the coordinates of the object from the panel.\n\nThe score in our game will be shown as a number. You cannot directly add a number to a number stored in .\n\nBut you can do it using a variable. To update the score, we need to add a number to the variable defined every time a tree crosses a predefined position and then send that value to the text object.\n\nTo repeat it for each object in Traffic, we will make a event. To make a condition, click on the icon at the top.\n\nFrom the menu that appears, choose the option.\n\nWe need to repeat this event for each Traffic, so choose Traffic for the object to be repeated.\n\nBecause we want to update our variable every time Traffic crosses a position, we will have to add a condition to check if the position of Traffic is greater than or equal to 700.\n\nOur action will be to create and change the value of a scene variable. Create a new scene variable Points similar to how we created variables CarLeft and CarRight.\n\nNow, we will add an action . Enter the variable you created in the field.\n\nEvery time the Traffic passes the Y-position of 700, we will add 100 to the Score. Therefore, we set the to + (add) and the to 100.\n\nTo send this value to our Score we will make an event with no condition because our score should always denote the value of our variable.\n\nWe will use the action . Enter Score in the field and set the to = (set to).\n\nOur text should display \"Score: \" followed by the value of the variable. But, the problem is that a can only display a string/text, not a number.\n\nTo counter this problem, we will first convert the variable to string and then send it to the text.\n\nTo do this, we will write \"\"Score: \" + ToString(Variable(Points))\" in the field. Note the quotes and + sign in the text. Quotes help us to distinguish a string and a function while + is used to concatenate two strings.\n\nIf we now preview the game, we'll see that the Score keeps on updating with every frame. This is because the condition checks if the Y position of Traffic is greater than or equal to 700.\n\nTo solve this problem as well as to optimize the game by freeing up memory, we will add another action to the event which will delete the object Traffic.\n\nThis action will free up some amount of memory as well as help us solve the Score problem by deleting the tree in the very next frame of Traffic crossing a Y position of 700.\n\nNow if you preview the game, you will see that the score keeps updating even after the collision between Car and Traffic takes place. For this, we can add another condition in the tree deleting event that would check if the object Car is visible.\n\nTo optimize our game for the long run, we can also use a similar event for deleting Tree\n\nThe condition of the event will be to check if Y position of Tree is more than 700 while the action would be to delete the object Tree.\n\nThis is what our Event Editor should look like:\n\nYou have now created an infinite car game in which the score gets updated as we pass by the trees.\n\nYou can now pose new challenges in front of yourself like allowing the car to go off the highway or allowing the movement of the car in front and back too.\n\nGDevelop offers many tutorials for users to get more familiar with it. You can see them here."
    },
    {
        "link": "https://d197for5662m48.cloudfront.net/documents/publicationstatus/71302/preprint_pdf/ce2e790fe264fa543705fda99cc7d9ec.pdf",
        "document": ""
    },
    {
        "link": "https://semanticscholar.org/paper/Game-AI%3A-Simulating-Car-Racing-Game-by-Applying-Wang-Lin/03a00a000b25239c0c08d1138326fcd468e9b17d",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/howdidtheycodeit/comments/dtvut9/how_does_car_ai_in_racing_games_work_what_is_the",
        "document": "\"Wow, how did they do THAT?\" - Ask here, get enlightened!"
    }
]