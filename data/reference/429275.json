[
    {
        "link": "https://docs.python.org/3/library/venv.html",
        "document": "The module supports creating lightweight “virtual environments”, each with their own independent set of Python packages installed in their directories. A virtual environment is created on top of an existing Python installation, known as the virtual environment’s “base” Python, and may optionally be isolated from the packages in the base environment, so only those explicitly installed in the virtual environment are available.\n\nWhen used from within a virtual environment, common installation tools such as pip will install Python packages into a virtual environment without needing to be told to do so explicitly.\n\nA virtual environment is (amongst other things):\n• None Used to contain a specific Python interpreter and software libraries and binaries which are needed to support a project (library or application). These are by default isolated from software in other virtual environments and Python interpreters and libraries installed in the operating system.\n• None Contained in a directory, conventionally named or in the project directory, or under a container directory for lots of virtual environments, such as .\n• None Not checked into source control systems such as Git.\n• None Considered as disposable – it should be simple to delete and recreate it from scratch. You don’t place any project code in the environment.\n• None Not considered as movable or copyable – you just recreate the same environment in the target location.\n\nSee PEP 405 for more background on Python virtual environments.\n\nVirtual environments are created by executing the module: This creates the target directory (including parent directories as needed) and places a file in it with a key pointing to the Python installation from which the command was run. It also creates a (or on Windows) subdirectory containing a copy or symlink of the Python executable (as appropriate for the platform or arguments used at environment creation time). It also creates a subdirectory (on Windows, this is ). If an existing directory is specified, it will be re-used. Changed in version 3.5: The use of is now recommended for creating virtual environments. Deprecated since version 3.6, removed in version 3.8: pyvenv was the recommended tool for creating virtual environments for Python 3.3 and 3.4, and replaced in 3.5 by executing directly. On Windows, invoke the command as follows: The command, if run with , will show the available options: usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps] [--without-scm-ignore-files] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. options: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. --upgrade-deps Upgrade core dependencies (pip) to the latest version in PyPI --without-scm-ignore-files Skips adding SCM ignore files to the environment directory (Git is supported by default). Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. Changed in version 3.4: Installs pip by default, added the and options. Changed in version 3.4: In earlier versions, if the target directory already existed, an error was raised, unless the or option was provided. Changed in version 3.9: Add option to upgrade pip + setuptools to the latest on PyPI. Changed in version 3.12: is no longer a core venv dependency. Changed in version 3.13: now creates a file for Git by default. While symlinks are supported on Windows, they are not recommended. Of particular note is that double-clicking in File Explorer will resolve the symlink eagerly and ignore the virtual environment. On Microsoft Windows, it may be required to enable the script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: See About Execution Policies for more information. The created file also includes the key, set to if is run with the option, otherwise. Unless the option is given, will be invoked to bootstrap into the virtual environment. Multiple paths can be given to , in which case an identical virtual environment will be created, according to the given options, at each provided path.\n\nWhen a Python interpreter is running from a virtual environment, and point to the directories of the virtual environment, whereas and point to those of the base Python used to create the environment. It is sufficient to check to determine if the current interpreter is running from a virtual environment. A virtual environment may be “activated” using a script in its binary directory ( on POSIX; on Windows). This will prepend that directory to your , so that running python will invoke the environment’s Python interpreter and you can run installed scripts without having to use their full path. The invocation of the activation script is platform-specific ( must be replaced by the path to the directory containing the virtual environment): Added in version 3.8: PowerShell activation scripts installed under POSIX for PowerShell Core support. You don’t specifically need to activate a virtual environment, as you can just specify the full path to that environment’s Python interpreter when invoking Python. Furthermore, all scripts installed in the environment should be runnable without activating it. In order to achieve this, scripts installed into virtual environments have a “shebang” line which points to the environment’s Python interpreter, . This means that the script will run with that interpreter regardless of the value of . On Windows, “shebang” line processing is supported if you have the Python Launcher for Windows installed. Thus, double-clicking an installed script in a Windows Explorer window should run it with the correct interpreter without the environment needing to be activated or on the . When a virtual environment has been activated, the environment variable is set to the path of the environment. Since explicitly activating a virtual environment is not required to use it, cannot be relied upon to determine whether a virtual environment is being used. Because scripts installed in environments should not expect the environment to be activated, their shebang lines contain the absolute paths to their environment’s interpreters. Because of this, environments are inherently non-portable, in the general case. You should always have a simple means of recreating an environment (for example, if you have a requirements file , you can invoke using the environment’s to install all of the packages needed by the environment). If for any reason you need to move the environment to a new location, you should recreate it at the desired location and delete the one at the old location. If you move an environment because you moved a parent directory of it, you should recreate the environment in its new location. Otherwise, software installed into the environment may not work as expected. You can deactivate a virtual environment by typing in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically, a script or shell function will be used).\n\nThe high-level method described above makes use of a simple API which provides mechanisms for third-party virtual environment creators to customize environment creation according to their needs, the class. The class accepts the following keyword arguments on instantiation:\n• None system_site_packages – a boolean value indicating that the system Python site-packages should be available to the environment (defaults to ).\n• None clear – a boolean value which, if true, will delete the contents of any existing target directory, before creating the environment.\n• None symlinks – a boolean value indicating whether to attempt to symlink the Python binary rather than copying.\n• None upgrade – a boolean value which, if true, will upgrade an existing environment with the running Python - for use when that Python has been upgraded in-place (defaults to ).\n• None with_pip – a boolean value which, if true, ensures pip is installed in the virtual environment. This uses with the option.\n• None prompt – a string to be used after virtual environment is activated (defaults to which means directory name of the environment would be used). If the special string is provided, the basename of the current directory is used as the prompt.\n• None upgrade_deps – Update the base venv modules to the latest on PyPI\n• None scm_ignore_files – Create ignore files based for the specified source control managers (SCM) in the iterable. Support is defined by having a method named . The only value supported by default is via . may be used as a base class. Create a virtual environment by specifying the target directory (absolute or relative to the current directory) which is to contain the virtual environment. The method will either create the environment in the specified directory, or raise an appropriate exception. The method of the class illustrates the hooks available for subclass customization: env_dir is the target directory to create an environment in. Each of the methods , , , and can be overridden. Creates the environment directory and all necessary subdirectories that don’t already exist, and returns a context object. This context object is just a holder for attributes (such as paths) for use by the other methods. If the is created with the arg , contents of the environment directory will be cleared and then all necessary subdirectories will be recreated. The returned context object is a with the following attributes:\n• None - The location of the virtual environment. Used for in activation scripts (see ).\n• None - The name of the virtual environment. Used for in activation scripts (see ).\n• None - The prompt to be used by the activation scripts. Used for in activation scripts (see ).\n• None - The underlying Python executable used by the virtual environment. This takes into account the case where a virtual environment is created from another virtual environment.\n• None - The include path for the virtual environment.\n• None - The purelib path for the virtual environment.\n• None - The script path for the virtual environment.\n• None - The name of the script path relative to the virtual environment location. Used for in activation scripts (see ).\n• None - The name of the Python interpreter in the virtual environment. Used for in activation scripts (see ).\n• None - The name of the Python interpreter, taking into account filesystem redirections. This can be used to run Python in the virtual environment. Changed in version 3.11: The venv sysconfig installation scheme is used to construct the paths of the created directories. Changed in version 3.12: The attribute was added to the context, and the context object was documented. Creates the configuration file in the environment. Creates a copy or symlink to the Python executable in the environment. On POSIX systems, if a specific executable was used, symlinks to and will be created pointing to that executable, unless files with those names already exist. Installs activation scripts appropriate to the platform into the virtual environment. Upgrades the core venv dependency packages (currently pip) in the environment. This is done by shelling out to the executable in the environment. Changed in version 3.12: setuptools is no longer a core venv dependency. A placeholder method which can be overridden in third party implementations to pre-install packages in the virtual environment or perform other post-creation steps. This method can be called from or in subclasses to assist in installing custom scripts into the virtual environment. path is the path to a directory that should contain subdirectories , , ; each containing scripts destined for the directory in the environment. The contents of and the directory corresponding to are copied after some text replacement of placeholders:\n• None is replaced with the absolute path of the environment directory.\n• None is replaced with the environment name (final path segment of environment directory).\n• None is replaced with the prompt (the environment name surrounded by parentheses and with a following space)\n• None is replaced with the name of the bin directory (either or ).\n• None is replaced with the absolute path of the environment’s executable. The directories are allowed to exist (for when an existing environment is being upgraded). Creates a file within the virtual environment that causes the entire directory to be ignored by the Git source control manager. Changed in version 3.7.2: Windows now uses redirector scripts for instead of copying the actual binaries. In 3.7.2 only does nothing unless running from a build in the source tree. Changed in version 3.7.3: Windows copies the redirector scripts as part of instead of . This was not the case in 3.7.2. When using symlinks, the original executables will be linked. There is also a module-level convenience function: Create an with the given keyword arguments, and call its method with the env_dir argument.\n\nAn example of extending ¶ The following script shows how to extend by implementing a subclass which installs setuptools and pip into a created virtual environment: This builder installs setuptools and pip so that you can pip or easy_install other packages into the created virtual environment. :param nodist: If true, setuptools and pip are not installed into the :param nopip: If true, pip is not installed into the created :param progress: If setuptools or pip are installed, the progress of the installation can be monitored by passing a progress callable. If specified, it is called with two context indicating where the string is coming from. The context argument can have one of three values: 'main', indicating that it is called from virtualize() itself, and 'stdout' and 'stderr', which are obtained by reading lines from the output streams of a subprocess which is used to install the app. If a callable is not specified, default progress Set up any packages which need to be pre-installed into the :param context: The information for the virtual environment Read lines from a subprocess' output stream and either pass to a progress callable (if specified) or write progress information to sys.stderr. :param context: The information for the virtual environment # clear up the setuptools archive which gets downloaded :param context: The information for the virtual environment 'environments in one or ' 'A directory in which to create the ' \"Don't install setuptools or pip in the \" 'Give the virtual environment access to the ' 'Try to use symlinks rather than copies, ' 'when symlinks are not the default for ' 'Delete the contents of the ' 'directory if it already ' 'from the scripts which ' 'you cannot supply --upgrade and --clear together.' This script is also available for download online."
    },
    {
        "link": "https://packaging.python.org/guides/installing-using-pip-and-virtual-environments",
        "document": "Install packages in a virtual environment using pip and venv¶\n\nThis guide discusses how to create and activate a virtual environment using the standard library’s virtual environment tool venv and install packages. The guide covers how to:\n• None Install packages into a virtual environment using the command\n\nThis guide has the prerequisite that you are using an official Python version obtained from <https://www.python.org/downloads/>. If you are using your operating system’s package manager to install Python, please ensure that Python is installed before proceeding with these steps.\n\nvenv (for Python 3) allows you to manage separate package installations for different projects. It creates a “virtual” isolated Python installation. When you switch projects, you can create a new virtual environment which is isolated from other virtual environments. You benefit from the virtual environment since packages can be installed confidently and will not interfere with another project’s environment. It is recommended to use a virtual environment when working with third party packages. To create a virtual environment, go to your project’s directory and run the following command. This will create a new virtual environment in a local folder named : The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it . will create a virtual Python installation in the folder. You should exclude your virtual environment directory from your version control system using or similar. Before you can start installing or using packages in your virtual environment you’ll need to it. Activating a virtual environment will put the virtual environment-specific and executables into your shell’s . To confirm the virtual environment is activated, check the location of your Python interpreter: While the virtual environment is active, the above command will output a filepath that includes the directory, by ending with the following: While a virtual environment is activated, pip will install packages into that specific environment. This enables you to import and use packages in your Python application. If you want to switch projects or leave your virtual environment, the environment: Closing your shell will deactivate the virtual environment. If you open a new shell window and want to use the virtual environment, reactivate it. If you want to reactivate an existing virtual environment, follow the same instructions about activating a virtual environment. There’s no need to create a new virtual environment.\n\npip is the reference Python package manager. It’s used to install and update packages into a virtual environment. The Python installers for macOS include pip. On Linux, you may have to install an additional package such as . You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip installed in your user site: The Python installers for Windows include pip. You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip:\n\nWhen your virtual environment is activated, you can install packages. Use the command to install packages. For example,let’s install the Requests library from the Python Package Index (PyPI): pip should download requests and all of its dependencies and install them: Collecting requests Using cached requests-2.18.4-py2.py3-none-any.whl Collecting chardet<3.1.0,>=3.0.2 (from requests) Using cached chardet-3.0.4-py2.py3-none-any.whl Collecting urllib3<1.23,>=1.21.1 (from requests) Using cached urllib3-1.22-py2.py3-none-any.whl Collecting certifi>=2017.4.17 (from requests) Using cached certifi-2017.7.27.1-py2.py3-none-any.whl Collecting idna<2.7,>=2.5 (from requests) Using cached idna-2.6-py2.py3-none-any.whl Installing collected packages: chardet, urllib3, certifi, idna, requests Successfully installed certifi-2017.7.27.1 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22 pip allows you to specify which version of a package to install using version specifiers. For example, to install a specific version of : To install the latest release of requests: To install pre-release versions of packages, use the flag: Some packages have optional extras. You can tell pip to install these by specifying the extra in brackets: pip can install a package directly from its source code. For example, to install the source code in the directory: Additionally, pip can install packages from source in development mode, meaning that changes to the source directory will immediately affect the installed package without needing to re-install: pip can install packages directly from their version control system. For example, you can install directly from a git repository: For more information on supported version control systems and syntax, see pip’s documentation on VCS Support. If you have a local copy of a Distribution Package’s archive (a zip, wheel, or tar file) you can install it directly with pip: If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the Python Package Index (PyPI) at all: This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages. If you want to download packages from a different index than the Python Package Index (PyPI), you can use the flag: If you want to allow packages from both the Python Package Index (PyPI) and a separate index, you can use the flag instead:\n\nPip can export a list of all installed packages and their versions using the command: Which will output a list of package specifiers such as: The command is useful for creating Requirements Files that can re-create the exact versions of all packages installed in an environment."
    },
    {
        "link": "https://stackoverflow.com/questions/43069780/how-to-create-virtual-env-with-python-3",
        "document": "I am using Python 2.7 + virtualenv version 1.10.1 for running project. Due to some other projects requirement I have to work with another version of Python (3.5). For this I have installed Python in my user directory. Also I have downloaded and installed (version 15.1.0) into my user directory.\n\nBut whenever I am trying to create virtual I am getting the below error\n\nWhat am I doing wrong here and how do I solve it?"
    },
    {
        "link": "https://virtualenv.pypa.io/en/stable/user_guide.html",
        "document": "This will create a python virtual environment of the same version as virtualenv, installed into the subdirectory . The command line tool has quite a few of flags that modify the tool’s behavior, for a full list make sure to check out CLI flags. The tool works in two phases:\n• None Phase 1 discovers a python interpreter to create a virtual environment from (by default this is the same python as the one is running from, however we can change this via the option).\n• None Phase 2 creates a virtual environment at the specified destination ( ), this can be broken down into four further sub-steps:\n• None create a python that matches the target python interpreter from phase 1,\n• None install (bootstrap) seed packages (one or more of pip, setuptools, wheel) in the created virtual environment,\n• None install activation scripts into the binary directory of the virtual environment (these will allow end users to activate the virtual environment from various shells).\n• None create files that mark the virtual environment as to be ignored by version control systems (currently we support Git only, as Mercurial, Bazaar or SVN do not support ignore files in subdirectories). This step can be skipped with the option. The python in your new virtualenv is effectively isolated from the python that was used to create it.\n\nThe first thing we need to be able to create a virtual environment is a python interpreter. This will describe to the tool what type of virtual environment you would like to create, think of it as: version, architecture, implementation. being a python application has always at least one such available, the one itself is using, and as such this is the default discovered element. This means that if you install under python , virtualenv will by default create virtual environments that are also of version . Created python virtual environments are usually not self-contained. A complete python packaging is usually made up of thousands of files, so it’s not efficient to install the entire python again into a new folder. Instead virtual environments are mere shells, that contain little within themselves, and borrow most from the system python (this is what you installed, when you installed python itself). This does mean that if you upgrade your system python your virtual environments might break, so watch out. The upside of this, referring to the system python, is that creating virtual environments can be fast. Here we’ll describe the built-in mechanism (note this can be extended though by plugins). The CLI flag or allows you to specify a python specifier for what type of virtual environment you would like, the format is either:\n• None a specifier identifying the Python implementation, version, architecture in the following format: We have the following restrictions:\n• None the python implementation is all alphabetic characters ( means any implementation, and if is missing it defaults to ),\n• None the version is a dot separated version number optionally followed by for free-threading,\n• None the architecture is either or (missing means ).\n• None means any python implementation having the version ,\n• None means any python implementation having the major version ,\n• None means any python implementation having the version with free threading,\n• None means a python interpreter with the implementation and major version . Given the specifier will apply the following strategy to discover/find the system executable:\n• None If we’re on Windows look into the Windows registry, and check if we see any registered Python implementations that match the specification. This is in line with expectation laid out inside PEP-514\n• None Try to discover a matching python executable within the folders enumerated on the environment variable. In this case we’ll try to find an executable that has a name roughly similar to the specification (for exact logic, please see the implementation code). As detailed above, virtual environments usually just borrow things from the system Python, they don’t actually contain all the data from the system Python. The version of the python executable is hardcoded within the python exe itself. Therefore, if you upgrade your system Python, your virtual environment will still report the version before the upgrade, even though now other than the executable all additional content (standard library, binary libs, etc) are of the new version. Barring any major incompatibilities (rarely the case) the virtual environment will continue working, but other than the content embedded within the python executable it will behave like the upgraded version. If such a virtual environment python is specified as the target python interpreter, we will create virtual environments that match the new system Python version, not the version reported by the virtual environment.\n\nThese are what actually setup the virtual environment, usually as a reference against the system python. virtualenv at the moment has two types of virtual environments:\n• None - this delegates the creation process towards the module, as described in PEP 405. This is only available on Python interpreters having version or later, and also has the downside that virtualenv must create a process to invoke that module (unless virtualenv is installed in the system python), which can be an expensive operation (especially true on Windows).\n• None - this means is able to do the creation operation itself (by knowing exactly what files to create and what system files need to be referenced). The creator with name is an alias on the first creator that’s of this type (we provide creators for various target environments, that all differ in actual create operations, such as CPython 2 on Windows, PyPy2 on Windows, CPython3 on Posix, PyPy3 on Posix, and so on; for a full list see ).\n\nThese will install for you some seed packages (one or more of: pip, setuptools, wheel) that enables you to install additional python packages into the created virtual environment (by invoking pip). Installing setuptools and wheel is disabled by default on Python 3.12+ environments. There are two main seed mechanisms available:\n• None - this method uses the bundled pip with virtualenv to install the seed packages (note, a new child process needs to be created to do this, which can be expensive especially on Windows).\n• None - this method uses the user application data directory to create install images. These images are needed to be created only once, and subsequent virtual environments can just link/copy those images into their pure python library path (the folder). This allows all but the first virtual environment creation to be blazing fast (a mechanism takes usually 98% of the virtualenv creation time, so by creating this install image that we can just link into the virtual environments install directory we can achieve speedups of shaving the initial 1 minute and 10 seconds down to just 8 seconds in case of a copy, or seconds in case symlinks are available - this is on Windows, Linux/macOS with symlinks this can be as low as from 3+ seconds). To override the filesystem location of the seed cache, one can use the environment variable. To install a seed package via either or method virtualenv needs to acquire a wheel of the target package. These wheels may be acquired from multiple locations as follows:\n• None ships out of box with a set of embed for all three seed packages (pip, setuptools, wheel). These are packaged together with the virtualenv source files, and only change upon upgrading virtualenv. Different Python versions require different versions of these, and because virtualenv supports a wide range of Python versions, the number of embedded wheels out of box is greater than 3. Whenever newer versions of these embedded packages are released upstream project upgrades them, and does a new release. Therefore, upgrading virtualenv periodically will also upgrade the version of the seed packages.\n• None However, end users might not be able to upgrade virtualenv at the same speed as we do new releases. Therefore, a user might request to upgrade the list of embedded wheels by invoking virtualenv with the flag. If the operation is triggered in such a manual way subsequent runs of virtualenv will always use the upgraded embed wheels. The operation can trigger automatically too, as a background process upon invocation of virtualenv, if no such upgrade has been performed in the last 14 days. It will only start using automatically upgraded wheel if they have been released for more than 28 days, and the automatic upgrade finished at least an hour ago:\n• None the 28 days period should guarantee end users are not pulling in automatically releases that have known bugs within,\n• None the one hour period after the automatic upgrade finished is implemented so that continuous integration services do not start using a new embedded versions half way through. The automatic behavior might be disabled via the configuration flag/option. To acquire the release date of a package virtualenv will perform the following:\n• None save the date the version was first discovered, and wait until 28 days passed.\n• None Users can specify a set of local paths containing additional wheels by using the command line argument flag. When searching for a wheel to use virtualenv performs lookup in the following order: Bundled wheels are all three above together. If neither of the locations contain the requested wheel version or option is set will use download to load the latest version available from the index server. Custom distributions often want to use their own set of wheel versions to distribute instead of the one virtualenv releases on PyPi. The reason for this is trying to keep the system versions of those packages in sync with what virtualenv uses. In such cases they should patch the module virtualenv.seed.wheels.embed, making sure to provide the function (which returns the wheel to use given a distribution/python version). The , and variables are needed if they want to use virtualenv’s test suite to validate. Furthermore, they might want to disable the periodic update by patching the virtualenv.seed.embed.base_embed.PERIODIC_UPDATE_ON_BY_DEFAULT to , and letting the system update mechanism to handle this. Note in this case the user might still request an upgrade of the embedded wheels by invoking virtualenv via , but no longer happens automatically, and will not alter the OS provided wheels.\n\nThese are activation scripts that will mangle with your shell’s settings to ensure that commands from within the python virtual environment take priority over your system paths. For example, if invoking from your shell returned the system python’s pip before activation, once you do the activation this should refer to the virtual environments . Note, though that all we do is change priority; so, if your virtual environments / folder does not contain some executable, this will still resolve to the same executable it would have resolved before the activation. For a list of shells we provide activators see . The location of these is right alongside the Python executables: usually folder on Windows, on POSIX. They are called , plus an extension that’s specific per activator, with no extension for Bash. You can invoke them, usually by source-ing them. The source command might vary by shell - e.g. on Bash it’s (or ): The activate script prepends the virtual environment’s binary folder onto the environment variable. It’s really just convenience for doing so, since you could do the same yourself. Note that you don’t have to activate a virtual environment to use it. You can instead use the full paths to its executables, rather than relying on your shell to resolve them to your virtual environment. Activator scripts also modify your shell prompt to indicate which environment is currently active, by prepending the environment name (or the name specified by when initially creating the environment) in brackets, like . You can disable this behavior by setting the environment variable to any value. You can also get the environment name via the environment variable if you want to customize your prompt, for example. The scripts also provision a command that will allow you to undo the operation: If using Powershell, the script is subject to the execution policies on the system. By default, Windows 7 and later, the system’s execution policy is set to , meaning no scripts like the script are allowed to be executed. However, that can’t stop us from changing that slightly to allow it to be executed. You may relax the system execution policy to allow running of local scripts without verifying the code signature using the following: Since the script is generated locally for each virtualenv, it is not considered a remote script and can then be executed. A longer explanation of this can be found within Allison Kaptur’s 2013 blog post: There’s no magic: virtualenv edition explains how virtualenv uses bash and Python and and to isolate virtual environments’ paths."
    },
    {
        "link": "https://geeksforgeeks.org/create-virtual-environment-using-venv-python",
        "document": "A virtual environment is a self-contained directory that contains a Python installation for a particular version of Python, plus a number of additional packages. Using virtual environments is a common practice in Python development as it helps to manage dependencies for different projects, avoiding conflicts between them. The venv module provides support for creating lightweight virtual environments.\n\nTo check if venv is installed enter the following command:\n\nIf venv is not available, we might need to install it. On Debian-based systems (like Ubuntu), we can install it using:\n\nIf venv is not available on your Windows system, it’s likely because the required components were not included during the Python installation.\n\nTo create a virtual environment, you can use the venv module, which is included in the Python standard library.\n\nDepending on your operating system, you can use the terminal (macOS/Linux) or Command Prompt (Windows).\n\nUse the cd command to change the directory to your project’s folder. For example:\n\nUse the python -m venv command followed by the name you want to give to your virtual environment. It’s common to name the environment venv or env.\n\nTo create a virtualenv use the following command:\n\nAfter running this command, a directory named venv will be created. This is where Python packages will be installed. To list the files in the folder type below command in the terminal:\n\nActivating a virtual environment sets up your terminal to use the specific Python and package settings for that environment, ensuring isolation from other projects. This prevents dependency conflicts and ensures consistency in package versions. Different operating systems and shells require different activation commands.\n\nTo ensure the pip command uses the virtual environment, you need to activate it. Follow these steps:\n\nAfter activation, the virtual environment name appears on the left side of the terminal, indicating it’s active. For example, if your virtual environment is named venv, you’ll see (venv) in your terminal prompt.\n\nNow that the virtual environment is activated, you can install packages using pip and they will be installed only in this environment:\n\nWhen you are done working, you can deactivate the environment by simply typing:\n\nHow to create a virtual environment using venv in Python?\n\nDo we need to install venv separately?\n\nCan we create a virtual environment for a specific Python version?\n\nIs it possible to create a virtual environment in a specific directory?"
    },
    {
        "link": "https://packaging.python.org/tutorials/installing-packages",
        "document": "This section covers the basics of how to install Python packages.\n\nIt’s important to note that the term “package” in this context is being used to describe a bundle of software to be installed (i.e. as a synonym for a distribution). It does not refer to the kind of package that you import in your Python source code (i.e. a container of modules). It is common in the Python community to refer to a distribution using the term “package”. Using the term “distribution” is often not preferred, because it can easily be confused with a Linux distribution, or another larger software distribution like Python itself.\n\nThis section describes the steps to follow before installing other Python packages. Ensure you can run Python from the command line¶ Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running: You should get some output like . If you do not have Python, please install the latest 3.x version from python.org or refer to the Installing Python section of the Hitchhiker’s Guide to Python. If you’re a newcomer and you get an error like this: File , line , in : name 'python3' is not defined It’s because this command and other suggested commands in this tutorial are intended to be run in a shell (also called a terminal or console). See the Python for Beginners getting started tutorial for an introduction to using your operating system’s shell and interacting with Python. If you’re using an enhanced shell like IPython or the Jupyter notebook, you can run system commands like those in this tutorial by prefacing them with a character: It’s recommended to write rather than plain in order to ensure that commands are run in the Python installation matching the currently running notebook (which may not be the same Python installation that the command refers to). Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the command in this tutorial with and the command with . Do not run any of the commands in this tutorial with : if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written. Ensure you can run pip from the command line¶ Additionally, you’ll need to make sure you have pip available. You can check this by running: If you installed Python from source, with an installer from python.org, or via Homebrew you should already have pip. If you’re on Linux and installed using your OS package manager, you may have to install pip separately, see Installing pip/setuptools/wheel with Linux Package Managers. If isn’t already installed, then first try to bootstrap it from the standard library: If that still doesn’t allow you to run :\n• None Run . This will install or upgrade pip. Additionally, it will install Setuptools and wheel if they’re not installed already. Be cautious if you’re using a Python install that’s managed by your operating system or another package manager. get-pip.py does not coordinate with those tools, and may leave your system in an inconsistent state. You can use to install in which is designed for locally-installed software. See section below for details, but here’s the basic venv command to use on a typical Linux system: This will create a new virtual environment in the subdirectory, and configure the current shell to use it as the default environment.\n\nPython “Virtual Environments” allow Python packages to be installed in an isolated location for a particular application, rather than being installed globally. If you are looking to safely install global command line tools, see Installing stand alone command line tools. Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded. Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application. Also, what if you can’t install packages into the global site-packages directory? For instance, on a shared host. In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments. Currently, there are two common tools for creating Python virtual environments:\n• None venv is available by default in Python 3.3 and later, and installs pip into created virtual environments in Python 3.4 and later (Python versions prior to 3.12 also installed Setuptools).\n• None virtualenv needs to be installed separately, but supports Python 2.7+ and Python 3.3+, and pip, Setuptools and wheel are always installed into created virtual environments by default (regardless of Python version). The basic usage is like so: For more information, see the venv docs or the virtualenv docs. The use of source under Unix shells ensures that the virtual environment’s variables are set within the current shell, and not in a subprocess (which then disappears, having no useful effect). In both of the above cases, Windows users should not use the source command, but should rather run the activate script directly from the command shell like so: Managing multiple virtual environments directly can become tedious, so the dependency management tutorial introduces a higher level tool, Pipenv, that automatically manages a separate virtual environment for each project and application that you work on.\n\nThe most common usage of pip is to install from the Python Package Index using a requirement specifier. Generally speaking, a requirement specifier is composed of a project name followed by an optional version specifier. A full description of the supported specifiers can be found in the Version specifier specification. Below are some examples. To install the latest version of “SomeProject”: To install greater than or equal to one version and less than another: To install a version that’s compatible with a certain version: In this case, this means to install any version “==1.4.*” version that’s also “>=1.4.2”.\n\npip can install from either Source Distributions (sdist) or Wheels, but if both are present on PyPI, pip will prefer a compatible wheel. You can override pip`s default behavior by e.g. using its –no-binary option. Wheels are a pre-built distribution format that provides faster installation compared to Source Distributions (sdist), especially when a project contains compiled extensions. If pip does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future.\n\nTo install packages that are isolated to the current user, use the flag: For more information see the User Installs section from the pip docs. Note that the flag has no effect when inside a virtual environment - all installation commands will affect the virtual environment. If defines any command-line scripts or console entry points, will cause them to be installed inside the user base’s binary directory, which may or may not already be present in your shell’s . (Starting in version 10, pip displays a warning when installing any scripts to a directory outside .) If the scripts are not available in your shell after installation, you’ll need to add the directory to your :\n• None On Linux and macOS you can find the user base binary directory by running and adding to the end. For example, this will typically print (with expanded to the absolute path to your home directory) so you’ll need to add to your . You can set your permanently by modifying ~/.profile.\n• None On Windows you can find the user base binary directory by running and replacing with . For example, this could return so you would need to set your to include . You can set your user permanently in the Control Panel. You may need to log out for the changes to take effect."
    },
    {
        "link": "https://pip.pypa.io/en/stable/cli/pip_install",
        "document": "\n• None PyPI (and other indexes) using requirement specifiers. pip also supports installing from “requirements files”, which provide an easy way to specify a whole environment to be installed.\n• None Identify the base requirements. The user supplied arguments are processed here.\n• None Resolve dependencies. What will be installed is determined here.\n• None Build wheels. All the dependencies that can be are built into wheels.\n• None Install the packages (and uninstall anything being upgraded/replaced). Note that prefers to leave the installed version as-is unless is specified. When looking at the items to be installed, pip checks what type of item each is, in the following order:\n• None Local directory (which must contain a or , otherwise pip will report an error).\n• None Local file (a sdist or wheel format archive, following the naming conventions for those formats). Each item identified is added to the set of requirements to be satisfied by the install. Working Out the Name and Version¶ For each candidate item, pip needs to know the project name and version. For wheels (identified by the file extension) this can be obtained from the filename, as per the Wheel spec. For local directories, or explicitly specified sdist files, the command is used to determine the project metadata. For sdists located via an index, the filename is parsed for the name and project version (this is in theory slightly less reliable than using the command, but avoids downloading and processing unnecessary numbers of files). Any URL may use the syntax (see VCS Support) to explicitly state the project name. Once pip has the set of requirements to satisfy, it chooses which version of each requirement to install using the simple rule that the latest version that satisfies the given constraints will be installed (but see here for an exception regarding pre-release versions). Where more than one source of the chosen version is available, it is assumed that any source is acceptable (as otherwise the versions would differ). Obtaining information about what was installed¶ The install command has a option that will generate a JSON report of what pip has installed. In combination with the and it can be used to resolve a set of requirements without actually installing them. The report can be written to a file, or to standard output (using in combination with ). The format of the JSON report is described in Installation Report. This section is only about installation order of runtime dependencies, and does not apply to build dependencies (those are specified using the [build-system] table). As of v6.1.0, pip installs dependencies before their dependents, i.e. in “topological order.” This is the only commitment pip currently makes related to order. While it may be coincidentally true that pip will install things in the order of the install arguments or in the order of the items in a requirements file, this is not a promise. In the event of a dependency cycle (aka “circular dependency”), the current implementation (which might possibly change later) has it such that the first encountered member of the cycle is installed last. For instance, if quux depends on foo which depends on bar which depends on baz, which depends on foo: Prior to v6.1.0, pip made no commitments about install order. The decision to install topologically is based on the principle that installations should proceed in a way that leaves the environment usable at each step. This has two main practical benefits:\n• None Concurrent use of the environment during the install is more likely to work.\n• None A failed install is less likely to leave a broken environment. Although pip would like to support failure rollbacks eventually, in the mean time, this is an improvement. Although the new install order is not intended to replace (and does not replace) the use of to declare build dependencies, it may help certain projects install from sdist (that might previously fail) that fit the following profile:\n• None They have build dependencies that are also declared as install dependencies using .\n• None works without their build dependencies being installed.\n• None For whatever reason, they don’t or won’t declare their build dependencies using . This section has been moved to Requirements File Format. This section has been moved to Requirement Specifiers. This is now covered in Requirements File Format. Starting with v1.4, pip will only install stable versions as specified by pre-releases by default. If a version cannot be parsed as a compliant version then it is assumed to be a pre-release. If a Requirement specifier includes a pre-release or development version (e.g. ) then pip will allow pre-release and development versions for that requirement. This does not include the != flag. The command also supports a --pre flag that enables installation of pre-releases and development releases. This is now covered in VCS Support. pip searches for packages on PyPI using the HTTP simple interface, which is documented here and there. pip offers a number of package index options for modifying how packages are found. pip looks for packages in a number of places: on PyPI (or the index given as , if not disabled via ), in the local filesystem, and in any additional repositories specified via or . There is no priority in the locations that are searched. Rather they are all checked, and the “best” match for the requirements (in terms of version number - see the specification for details) is selected. This is now covered in HTTPS Certificates. This is now covered in Caching. This is now covered in Caching. This is now covered in Secure installs. This is now covered in Local project installs. This is now covered in Local project installs. This is now covered in Build System Interface.\n\nInstall from the given requirements file. This option can be used multiple times. Constrain versions using the given constraints file. This option can be used multiple times. Include pre-release and development versions. By default, pip only finds stable versions. Install a project in editable mode (i.e. setuptools “develop mode”) from a local project path or a VCS url. Don’t actually install anything, just print what would be. Can be used in combination with --ignore-installed to ‘resolve’ the requirements. Install packages into <dir>. By default this will not replace existing files/folders in <dir>. Use --upgrade to replace existing packages in <dir> with new versions. Only use wheels compatible with <platform>. Defaults to the platform of the running system. Use this option multiple times to specify multiple platforms supported by the target interpreter. The Python interpreter version to use for wheel and “Requires-Python” compatibility checks. Defaults to a version derived from the running interpreter. The version can be specified using up to three dot-separated integers (e.g. “3” for 3.0.0, “3.7” for 3.7.0, or “3.7.3”). A major-minor version can also be given as a string without dots (e.g. “37” for 3.7.0). Only use wheels compatible with Python implementation <implementation>, e.g. ‘pp’, ‘jy’, ‘cp’, or ‘ip’. If not specified, then the current interpreter implementation is used. Use ‘py’ to force implementation-agnostic wheels. Only use wheels compatible with Python abi <abi>, e.g. ‘pypy_41’. If not specified, then the current interpreter abi tag is used. Use this option multiple times to specify multiple abis supported by the target interpreter. Generally you will need to specify --implementation, --platform, and --python-version when using this option. Install to the Python user install directory for your platform. Typically ~/.local/, or %APPDATA%Python on Windows. (See the Python documentation for site.USER_BASE for full details.) Install everything relative to this alternate root directory. Installation prefix where lib, bin and other top-level folders are placed. Note that the resulting installation may contain scripts and other resources which reference the Python interpreter of pip, and not that of . See also the option if the intention is to install packages into another (possibly pip-free) environment. Directory to check out editable projects into. The default in a virtualenv is “<venv path>/src”. The default for global installs is “<current dir>/src”. Upgrade all specified packages to the newest available version. The handling of dependencies depends on the upgrade-strategy used. Determines how dependency upgrading should be handled [default: only-if-needed]. “eager” - dependencies are upgraded regardless of whether the currently installed version satisfies the requirements of the upgraded package(s). “only-if-needed” - are upgraded only when they do not satisfy the requirements of the upgraded package(s). Reinstall all packages even if they are already up-to-date. Ignore the installed packages, overwriting them. This can break your system if the existing package is of a different version or was installed with a different package manager! Disable isolation when building a modern source distribution. Build dependencies specified by PEP 518 must be already installed if this option is used. Use PEP 517 for building source distributions (use --no-use-pep517 to force legacy behaviour). Check the build dependencies when PEP517 is used. Allow pip to modify an EXTERNALLY-MANAGED Python installation Configuration settings to be passed to the PEP 517 build backend. Settings take the form KEY=VALUE. Use multiple --config-settings options to pass multiple keys to the backend. Extra global options to be supplied to the setup.py call before the install or bdist_wheel command. Do not compile Python source files to bytecode Do not warn when installing scripts outside PATH Do not warn about broken dependencies Do not use binary packages. Can be supplied multiple times, and each time adds to the existing value. Accepts either “:all:” to disable all binary packages, “:none:” to empty the set (notice the colons), or one or more package names with commas between them (no colons). Note that some packages are tricky to compile and may fail to install when this option is used on them. Do not use source packages. Can be supplied multiple times, and each time adds to the existing value. Accepts either “:all:” to disable all source packages, “:none:” to empty the set, or one or more package names with commas between them. Packages without binary distributions will fail to install when this option is used on them. Prefer binary packages over source packages, even if the source packages are newer. Require a hash to check each requirement against, for repeatable installs. This option is implied when any package in a requirements file has a --hash option. Specify whether the progress bar should be used [on, off, raw] (default: on) Action if pip is run as a root user [warn, ignore] (default: warn) Generate a JSON file describing what pip did to install the provided requirements. Can be used in combination with --dry-run and --ignore-installed to ‘resolve’ the requirements. When - is used as file name it writes to stdout. When writing to stdout, please combine with the --quiet option to avoid mixing pip logging output with JSON output. Base URL of the Python Package Index (default https://pypi.org/simple). This should point to a repository compliant with PEP 503 (the simple repository API) or a local directory laid out in the same format. Extra URLs of package indexes to use in addition to --index-url. Should follow the same rules as --index-url. Ignore package index (only looking at --find-links URLs instead). If a URL or path to an html file, then parse for links to archives such as sdist (.tar.gz) or wheel (.whl) files. If a local path or file:// URL that’s a directory, then look for archives in the directory listing. Links to VCS project URLs are not supported.\n• None Install and its dependencies from PyPI using Requirement Specifiers\n• None Install a list of requirements specified in a file. See the Requirements files.\n• None Upgrade an already installed to the latest from PyPI. This will guarantee an update to as it is a direct requirement, and possibly upgrade dependencies if their installed versions do not meet the minimum requirements of . Any non-requisite updates of its dependencies (indirect requirements) will be affected by the command.\n• None Install a local project in “editable” mode. See the section on Editable Installs.\n• None Install a project from VCS in “editable” mode. See the sections on VCS Support and Editable Installs.\n• Install from a different index, and not PyPI Install from a local flat directory containing archives (and don’t scan indexes): Search an additional index during install, in addition to PyPI Using this option to search for packages which are not in the main repository (such as private packages) is unsafe, per a security vulnerability called dependency confusion: an attacker can claim the package on the public repository in a way that will ensure it gets chosen over the private package.\n• None Find pre-release and development versions, in addition to stable versions. By default, pip only finds stable versions.\n• Do not use any binary packages Specify to be installed from source:"
    },
    {
        "link": "https://stackoverflow.com/questions/20101834/pip-install-from-git-repo-branch",
        "document": "Using pip with git+ to clone a repository can be extremely slow (test with https://github.com/django/django@stable/1.6.x for example, it will take a few minutes). The fastest thing I've found, which works with GitHub and BitBucket, is:\n\nwhich becomes for Django master:\n\nWith BitBucket it's about the same predictable pattern:\n\nHere, the master branch is generally named default. This will make your installing much faster.\n\nSome other answers mention variations required when placing the package to be installed into your . Note that with this archive syntax, the leading and trailing are not required, and you can just simply paste the URL, so your requirements.txt looks like:"
    },
    {
        "link": "https://stackoverflow.com/questions/14159482/pip-install-a-local-git-repository",
        "document": "I can't find the correct way to install a local directory as a python package using pip.\n\nAs you can see pip just copied over the package to site-packages. How can I avoid this, and use the package directly from its source folder?\n\nI'm trying to integrate django-pipeline into my Django project, but I want to add support for Django 1.4 first, so I forked and cloned my fork."
    },
    {
        "link": "https://pip.pypa.io/en/stable/installation",
        "document": "Usually, pip is automatically installed if you are:\n• None using Python that has not been modified by a redistributor to remove\n\nIf your Python environment does not have pip installed, there are 2 mechanisms to install pip supported directly by pip’s maintainers: Python comes with an module , which can install pip in a Python environment. More details about how works and how it can be used, is available in the standard library documentation. This is a Python script that uses some bootstrapping logic to install pip.\n• None Open a terminal/command prompt, to the folder containing the file and run: More details about this script can be found in pypa/get-pip’s README. The zip application is currently experimental. We test that pip runs correctly in this form, but it is possible that there could be issues in some situations. We will accept bug reports in such cases, but for now the zip application should not be used in production environments. In addition to installing pip in your environment, pip is available as a standalone zip application. This can be downloaded from https://bootstrap.pypa.io/pip/pip.pyz. There are also zip applications for specific pip versions, named . The zip application can be run using any supported version of Python: then the currently active Python interpreter will be used. then the currently active Python interpreter will be used. then the currently active Python interpreter will be used. You may need to configure your system to recognise the extension before this will work.\n\nDepending on how you installed Python, there might be other mechanisms available to you for installing pip such as using Linux package managers. These mechanisms are provided by redistributors of pip, who may have modified pip to change its behaviour. This has been a frequent source of user confusion, since it causes a mismatch between documented behaviour in this documentation and how pip works after those modifications. If you face issues when using Python and pip installed using these mechanisms, it is recommended to request for support from the relevant provider (eg: Linux distro community, cloud provider support channels, etc)."
    }
]