[
    {
        "link": "https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nContent scripts are files that run in the context of web pages. Using the standard Document Object Model (DOM), they are able to read details of the web pages the browser visits, make changes to them, and pass information to their parent extension.\n\nContent scripts can access the following extension APIs directly:\n\nContent scripts are unable to access other APIs directly. But they can access them indirectly by exchanging messages with other parts of your extension.\n\nYou can also access other files in your extension from a content script, using APIs like . To do this, you need to declare them as web-accessible resources. Note that this also exposes the resources to any first-party or third-party scripts running on the same site.\n\nContent scripts live in an isolated world, allowing a content script to make changes to its JavaScript environment without conflicting with the page or other extensions' content scripts.\n\nAn extension may run in a web page with code similar to the following example.\n\nThat extension could inject the following content script using one of the techniques outlined in the Inject scripts section.\n\nWith this change, both alerts appear in sequence when the button is clicked.\n\nContent scripts can be declared statically, declared dynamically, or programmatically injected.\n\nUse static content script declarations in manifest.json for scripts that should be automatically run on a well known set of pages.\n\nStatically declared scripts are registered in the manifest under the key. They can include JavaScript files, CSS files, or both. All auto-run content scripts must specify match patterns.\n\nDynamic content scripts are useful when the match patterns for content scripts are not well known or when content scripts shouldn't always be injected on known hosts.\n\nIntroduced in Chrome 96, dynamic declarations are similar to static declarations, but the content script object is registered with Chrome using methods in the namespace rather than in manifest.json. The Scripting API also allows extension developers to:\n\nLike static declarations, dynamic declarations can include JavaScript files, CSS files, or both.\n\nUse programmatic injection for content scripts that need to run in response to events or on specific occasions.\n\nTo inject a content script programmatically, your extension needs host permissions for the page it's trying to inject scripts into. Host permissions can either be granted by requesting them as part of your extension's manifest or temporarily using .\n\nThe following is a different versions of an activeTab-based extension.\n\nContent scripts can be injected as files.\n\nOr, a function body can be injected and executed as a content script.\n\nBe aware that the injected function is a copy of the function referenced in the call, not the original function itself. As a result, the function's body must be self contained; references to variables outside of the function will cause the content script to throw a .\n\nWhen injecting as a function, you can also pass arguments to the function.\n\nTo customize specified page matching, include the following fields in a declarative registration.\n\nThe content script will be injected into a page if both of the following are true:\n• Its URL matches any pattern and any pattern.\n• The URL doesn't also match an or pattern. Because the property is required, , , and can only be used to limit which pages will be affected.\n\nThe following extension injects the content script into but not into .\n\nGlob properties follow a different, more flexible syntax than match patterns. Acceptable glob strings are URLs that may contain \"wildcard\" asterisks and question marks. The asterisk ( ) matches any string of any length, including the empty string, while the question mark ( ) matches any single character.\n\nFor example, the glob matches any of the following:\n\nHowever, it does not match the following:\n\nThis extension injects the content script into and , but not into :\n\nThis extension injects the content script into and , but not into or :\n\nOne, all, or some of these can be included to achieve the correct scope.\n\nThe field controls when JavaScript files are injected into the web page. The preferred and default value is . See the RunAt type for other possible values.\n\nFor declarative content scripts specified in the manifest, the field allows the extension to specify if JavaScript and CSS files should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab:\n\nWhen programmatically registering content scripts using , the parameter can be used to specify if the content script should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab. This can only be used with tabId, and cannot be used if frameIds or documentIds are specified:\n\nExtensions may want to run scripts in frames that are related to a matching frame, but don't themselves match. A common scenario when this is the case is for frames with URLs that were created by a matching frame, but whose URLs don't themselves match the script's specified patterns.\n\nThis is the case when an extension wants to inject in frames with URLs that have , , , and schemes. In these cases, the URL won't match the content script's pattern (and, in the case of and , don't even include the parent URL or origin in the URL at all, as in or ). However, these frames can still be associated with the creating frame.\n\nTo inject into these frames, extensions can specify the property on a content script specification in the manifest.\n\nWhen specified and set to , Chrome will look at the origin of the initiator of the frame to determine whether the frame matches, rather than at the URL of the frame itself. Note that this might also be different than the target frame's origin (e.g., URLs have a null origin).\n\nThe initiator of the frame is the frame that created or navigated the target frame. While this is commonly the direct parent or opener, it may not be (as in the case of a frame navigating an iframe within an iframe).\n\nBecause this compares the origin of the initiator frame, the initiator frame could be on at any path from that origin. To make this implication clear, Chrome requires any content scripts specified with set to to also specify a path of .\n\nWhen both and are specified, takes priority.\n\nAlthough the execution environments of content scripts and the pages that host them are isolated from each other, they share access to the page's DOM. If the page wishes to communicate with the content script, or with the extension through the content script, it must do so through the shared DOM.\n\nAn example can be accomplished using :\n\nThe non-extension page, example.html, posts messages to itself. This message is intercepted and inspected by the content script and then posted to the extension process. In this way, the page establishes a line of communication to the extension process. The reverse is possible through similar means.\n\nTo access an extension file from a content script, you can call to get the absolute URL of your extension asset as shown in the following example ( ):\n\nTo use fonts or images in a CSS file, you can use to construct a URL as shown in the following example ( ):\n\nAll assets must be declared as web accessible resources in the file:\n\nWhile isolated worlds provide a layer of protection, using content scripts can create vulnerabilities in an extension and the web page. If the content script receives content from a separate website, such as by calling , be careful to filter content against cross-site scripting attacks before injecting it. Only communicate over HTTPS in order to avoid \"man-in-the-middle\" attacks.\n\nBe sure to filter for malicious web pages. For example, the following patterns are dangerous, and disallowed in Manifest V3:"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/manifest/content-scripts",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThe key specifies a statically loaded JavaScript or CSS file to be used every time a page is opened that matches a certain URL pattern. Extensions can also inject content scripts programmatically, see Injecting Scripts for details.\n\nThese are the supported keys for . Only the key and either or are required.\n\nEach file must contain a relative path to a resource in the extension's root directory. Leading slashes ( ) are automatically trimmed. The key specifies when each file will be injected.\n\nOnly the property is required. Then you can use , , and to customize which URLs to inject code into. The key will trigger a warning.\n\nGlob URLs are those that contain \"wildcards\" * and question marks. The wildcard * matches any string of any length, including an empty string, while the question mark ? matches any single character.\n\nThe content script is injected into a page if:\n• Its URL matches any and patterns.\n• And the URL doesn't match or patterns.\n\nThe key specifies if the content script should be injected into all frames matching the specified URL requirements. If set to it will only inject into the topmost frame. It can be used along with to inject into an frame.\n\nTo inject into other frames like , , and , set the to . For details, see Inject in related frames\n\nBy default, content scripts are injected when the document and all resources are finished loading, and live in a private isolated execution environment that isn't accessible to the page or other extensions. You can change these defaults in the following keys:\n\nSee the Run on every page tutorial to build an extension that injects a content script in the manifest."
    },
    {
        "link": "https://stackoverflow.com/questions/28186349/chrome-extension-set-to-run-at-document-start-is-running-too-fast",
        "document": "EDIT: Something was wrong with my Chrome browser and creating a conflict with my script, a full reinstall eliminated whatever the problem source was. If I happen to find out what was causing it I will include it in here.\n\nEDIT2: Just to let anyone reading this in 2017 know that I haven't forgotten this and I have never had this problem since my previous edit.\n\nEDIT3: It is 2019 and so far I've never had this problem again.\n\nI have been learning how to create a simple Chrome extension which is a userscript port. The script works perfectly with Tampermonkey with the setting to , all the necessary events that need to be caught from the beginning are all captured.\n\nHowever, when I set the same settings in the Chrome extension I discovered that the same running setting is faster than Tampermonkey's which causes the first function to fail: ( ) since it tries to append a script element to the section, which doesn't exist until 0.010s later.\n\nMy dirty solution so far has been to make use of a function with the timer set to 10 to check if exists and then proceed with the code if the condition is true.\n\nIs there any way that I can make this work correctly without having to resort to or maybe replicate Tampermonkey's option which appears to run the userscript on the webpage context?\n\nThe following is my manifest.json file:\n\nAll of this could be avoided if Chrome would adopt the event, but until that happens I am stuck with the event. I thank in advance any help provided.\n\nEDIT: I have already tried the suggestions in the replies: using a different point, using and append to . All were unsuccessful because: 1 and 2 makes the script miss early events, and 3 returns the same TypeError as when trying to append to .\n\nThe script has to be inserted/running when or else it will miss early necessary events, but not so early to the point of being unable to append childs to either or\n\nAn example of the code inside :"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_scripts",
        "document": "Inject the scripts specified in and into all frames matching the specified URL requirements, even if the frame is not the topmost frame in a tab. This does not inject into child frames where only their parent matches the URL requirements and the child frame does not match the URL requirements. The URL requirements are checked for each frame independently. Note: This also applies to any tracker or ad that uses iframes, which means that enabling this could make your content script get called dozens of times on some pages. Inject only into frames matching the URL requirements which are the topmost frame in a tab.\n\nAn array of paths, relative to , referencing CSS files that will be injected into matching pages. Files are injected in the order given, and at the time specified by . Note: Firefox resolves URLs in injected CSS files relative to the CSS file itself, rather than to the page it's injected into.\n\nAn array of paths, relative to , referencing JavaScript files that will be injected into matching pages. Files are injected in the order given. This means that, for example, if you include jQuery here followed by another content script, like this: Then, can use jQuery. The files are injected after any files in , and at the time specified by .\n\nInsert the content scripts into pages whose URL is or , if the URL of the page that opened or created this page matches the patterns specified in the rest of the key. This is especially useful to run scripts in empty iframes, whose URL is . To do this you should also set the key. For example, suppose you have a key like this: If the user loads , and this page embeds an empty iframe, then will be loaded into the iframe. Note: is supported in Firefox from version 52. Note that in Firefox, content scripts won't be injected into empty iframes at , even if you specify that value in .\n\nThis option determines when the files specified in and are injected. You can supply one of three strings here, each of which identifies a state in the process of loading a document. The states directly correspond to : Corresponds to . The DOM is still loading. Corresponds to . The DOM has finished loading, but resources such as scripts and images may still be loading. Corresponds to . The document and all its resources have finished loading. The default value is . In all cases, files in are injected after files in .\n\nThe JavaScript world the script executes in. The default content scripts execution environment. This environment is isolated from the page's context: while they share the same document, the global scopes and available APIs differ. The web page's execution environment. This environment is shared with the web page without isolation. Scripts in this environment don't have any access to the APIs that are only available to content scripts. Warning: Due to the lack of isolation, the web page can detect and interfere with the executed code. Do not use the world unless it is acceptable for web pages to read, access, or modify the logic or data that flows through the executed code. The default value is ."
    },
    {
        "link": "https://stackoverflow.com/questions/55255619/chrome-extension-content-script-at-both-document-start-and-document-end",
        "document": "Good day to everyone, as you can see I'm pretty new at Chrome extensions.\n\nCan you run a script from before and after the the DOM or page fully loads?\n\nOr something like:"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nContent scripts are files that run in the context of web pages. Using the standard Document Object Model (DOM), they are able to read details of the web pages the browser visits, make changes to them, and pass information to their parent extension.\n\nContent scripts can access the following extension APIs directly:\n\nContent scripts are unable to access other APIs directly. But they can access them indirectly by exchanging messages with other parts of your extension.\n\nYou can also access other files in your extension from a content script, using APIs like . To do this, you need to declare them as web-accessible resources. Note that this also exposes the resources to any first-party or third-party scripts running on the same site.\n\nContent scripts live in an isolated world, allowing a content script to make changes to its JavaScript environment without conflicting with the page or other extensions' content scripts.\n\nAn extension may run in a web page with code similar to the following example.\n\nThat extension could inject the following content script using one of the techniques outlined in the Inject scripts section.\n\nWith this change, both alerts appear in sequence when the button is clicked.\n\nContent scripts can be declared statically, declared dynamically, or programmatically injected.\n\nUse static content script declarations in manifest.json for scripts that should be automatically run on a well known set of pages.\n\nStatically declared scripts are registered in the manifest under the key. They can include JavaScript files, CSS files, or both. All auto-run content scripts must specify match patterns.\n\nDynamic content scripts are useful when the match patterns for content scripts are not well known or when content scripts shouldn't always be injected on known hosts.\n\nIntroduced in Chrome 96, dynamic declarations are similar to static declarations, but the content script object is registered with Chrome using methods in the namespace rather than in manifest.json. The Scripting API also allows extension developers to:\n\nLike static declarations, dynamic declarations can include JavaScript files, CSS files, or both.\n\nUse programmatic injection for content scripts that need to run in response to events or on specific occasions.\n\nTo inject a content script programmatically, your extension needs host permissions for the page it's trying to inject scripts into. Host permissions can either be granted by requesting them as part of your extension's manifest or temporarily using .\n\nThe following is a different versions of an activeTab-based extension.\n\nContent scripts can be injected as files.\n\nOr, a function body can be injected and executed as a content script.\n\nBe aware that the injected function is a copy of the function referenced in the call, not the original function itself. As a result, the function's body must be self contained; references to variables outside of the function will cause the content script to throw a .\n\nWhen injecting as a function, you can also pass arguments to the function.\n\nTo customize specified page matching, include the following fields in a declarative registration.\n\nThe content script will be injected into a page if both of the following are true:\n• Its URL matches any pattern and any pattern.\n• The URL doesn't also match an or pattern. Because the property is required, , , and can only be used to limit which pages will be affected.\n\nThe following extension injects the content script into but not into .\n\nGlob properties follow a different, more flexible syntax than match patterns. Acceptable glob strings are URLs that may contain \"wildcard\" asterisks and question marks. The asterisk ( ) matches any string of any length, including the empty string, while the question mark ( ) matches any single character.\n\nFor example, the glob matches any of the following:\n\nHowever, it does not match the following:\n\nThis extension injects the content script into and , but not into :\n\nThis extension injects the content script into and , but not into or :\n\nOne, all, or some of these can be included to achieve the correct scope.\n\nThe field controls when JavaScript files are injected into the web page. The preferred and default value is . See the RunAt type for other possible values.\n\nFor declarative content scripts specified in the manifest, the field allows the extension to specify if JavaScript and CSS files should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab:\n\nWhen programmatically registering content scripts using , the parameter can be used to specify if the content script should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab. This can only be used with tabId, and cannot be used if frameIds or documentIds are specified:\n\nExtensions may want to run scripts in frames that are related to a matching frame, but don't themselves match. A common scenario when this is the case is for frames with URLs that were created by a matching frame, but whose URLs don't themselves match the script's specified patterns.\n\nThis is the case when an extension wants to inject in frames with URLs that have , , , and schemes. In these cases, the URL won't match the content script's pattern (and, in the case of and , don't even include the parent URL or origin in the URL at all, as in or ). However, these frames can still be associated with the creating frame.\n\nTo inject into these frames, extensions can specify the property on a content script specification in the manifest.\n\nWhen specified and set to , Chrome will look at the origin of the initiator of the frame to determine whether the frame matches, rather than at the URL of the frame itself. Note that this might also be different than the target frame's origin (e.g., URLs have a null origin).\n\nThe initiator of the frame is the frame that created or navigated the target frame. While this is commonly the direct parent or opener, it may not be (as in the case of a frame navigating an iframe within an iframe).\n\nBecause this compares the origin of the initiator frame, the initiator frame could be on at any path from that origin. To make this implication clear, Chrome requires any content scripts specified with set to to also specify a path of .\n\nWhen both and are specified, takes priority.\n\nAlthough the execution environments of content scripts and the pages that host them are isolated from each other, they share access to the page's DOM. If the page wishes to communicate with the content script, or with the extension through the content script, it must do so through the shared DOM.\n\nAn example can be accomplished using :\n\nThe non-extension page, example.html, posts messages to itself. This message is intercepted and inspected by the content script and then posted to the extension process. In this way, the page establishes a line of communication to the extension process. The reverse is possible through similar means.\n\nTo access an extension file from a content script, you can call to get the absolute URL of your extension asset as shown in the following example ( ):\n\nTo use fonts or images in a CSS file, you can use to construct a URL as shown in the following example ( ):\n\nAll assets must be declared as web accessible resources in the file:\n\nWhile isolated worlds provide a layer of protection, using content scripts can create vulnerabilities in an extension and the web page. If the content script receives content from a separate website, such as by calling , be careful to filter content against cross-site scripting attacks before injecting it. Only communicate over HTTPS in order to avoid \"man-in-the-middle\" attacks.\n\nBe sure to filter for malicious web pages. For example, the following patterns are dangerous, and disallowed in Manifest V3:"
    },
    {
        "link": "https://stackoverflow.com/questions/28186349/chrome-extension-set-to-run-at-document-start-is-running-too-fast",
        "document": "EDIT: Something was wrong with my Chrome browser and creating a conflict with my script, a full reinstall eliminated whatever the problem source was. If I happen to find out what was causing it I will include it in here.\n\nEDIT2: Just to let anyone reading this in 2017 know that I haven't forgotten this and I have never had this problem since my previous edit.\n\nEDIT3: It is 2019 and so far I've never had this problem again.\n\nI have been learning how to create a simple Chrome extension which is a userscript port. The script works perfectly with Tampermonkey with the setting to , all the necessary events that need to be caught from the beginning are all captured.\n\nHowever, when I set the same settings in the Chrome extension I discovered that the same running setting is faster than Tampermonkey's which causes the first function to fail: ( ) since it tries to append a script element to the section, which doesn't exist until 0.010s later.\n\nMy dirty solution so far has been to make use of a function with the timer set to 10 to check if exists and then proceed with the code if the condition is true.\n\nIs there any way that I can make this work correctly without having to resort to or maybe replicate Tampermonkey's option which appears to run the userscript on the webpage context?\n\nThe following is my manifest.json file:\n\nAll of this could be avoided if Chrome would adopt the event, but until that happens I am stuck with the event. I thank in advance any help provided.\n\nEDIT: I have already tried the suggestions in the replies: using a different point, using and append to . All were unsuccessful because: 1 and 2 makes the script miss early events, and 3 returns the same TypeError as when trying to append to .\n\nThe script has to be inserted/running when or else it will miss early necessary events, but not so early to the point of being unable to append childs to either or\n\nAn example of the code inside :"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_scripts",
        "document": "Inject the scripts specified in and into all frames matching the specified URL requirements, even if the frame is not the topmost frame in a tab. This does not inject into child frames where only their parent matches the URL requirements and the child frame does not match the URL requirements. The URL requirements are checked for each frame independently. Note: This also applies to any tracker or ad that uses iframes, which means that enabling this could make your content script get called dozens of times on some pages. Inject only into frames matching the URL requirements which are the topmost frame in a tab.\n\nAn array of paths, relative to , referencing CSS files that will be injected into matching pages. Files are injected in the order given, and at the time specified by . Note: Firefox resolves URLs in injected CSS files relative to the CSS file itself, rather than to the page it's injected into.\n\nAn array of paths, relative to , referencing JavaScript files that will be injected into matching pages. Files are injected in the order given. This means that, for example, if you include jQuery here followed by another content script, like this: Then, can use jQuery. The files are injected after any files in , and at the time specified by .\n\nInsert the content scripts into pages whose URL is or , if the URL of the page that opened or created this page matches the patterns specified in the rest of the key. This is especially useful to run scripts in empty iframes, whose URL is . To do this you should also set the key. For example, suppose you have a key like this: If the user loads , and this page embeds an empty iframe, then will be loaded into the iframe. Note: is supported in Firefox from version 52. Note that in Firefox, content scripts won't be injected into empty iframes at , even if you specify that value in .\n\nThis option determines when the files specified in and are injected. You can supply one of three strings here, each of which identifies a state in the process of loading a document. The states directly correspond to : Corresponds to . The DOM is still loading. Corresponds to . The DOM has finished loading, but resources such as scripts and images may still be loading. Corresponds to . The document and all its resources have finished loading. The default value is . In all cases, files in are injected after files in .\n\nThe JavaScript world the script executes in. The default content scripts execution environment. This environment is isolated from the page's context: while they share the same document, the global scopes and available APIs differ. The web page's execution environment. This environment is shared with the web page without isolation. Scripts in this environment don't have any access to the APIs that are only available to content scripts. Warning: Due to the lack of isolation, the web page can detect and interfere with the executed code. Do not use the world unless it is acceptable for web pages to read, access, or modify the logic or data that flows through the executed code. The default value is ."
    },
    {
        "link": "https://learn.microsoft.com/en-us/microsoft-edge/extensions-chromium/developer-guide/minimize-page-load-time-impact",
        "document": "Content scripts are JavaScript files that your extension injects into webpages, and that run in the context of these webpages. Using content scripts, your extension can access and modify a rendered webpage by reading from or changing the DOM.\n\nContent scripts can, however, have a noticeable impact on the performance of a webpage, for example by slowing down the page load time. This can happen if the content script runs a lot of code while the page is loading.\n\nThis article provides best practices that can help you minimize the performance impact of your extension on the webpages that your users visit.\n\nTo profile the performance of your extension's content script, use Microsoft Edge DevTools or the Edge tracing tool, as described in the following sections.\n\nDevTools provides a set of features for inspecting, debugging, and profiling the code that a webpage uses. DevTools can also be used to profile your extension's code.\n\nIn this section, you'll learn how to use the Performance tool in DevTools to profile your extension's content script. To learn more about the Performance tool, see Introduction to the Performance tool.\n• None To open DevTools, right-click the webpage, and then select Inspect. Or, press Ctrl+Shift+I (Windows, Linux) or Command+Option+I (macOS). DevTools opens.\n• None In DevTools, on the Activity Bar, select the Performance ( ) tab. If that tab isn't visible, select More tools ( ) > Performance.\n• None Reload the page to capture the profiling data that corresponds to the page load time and then, once the page has finished loading, click the Stop ( ) button to end the recording. DevTools displays the recorded performance profile:\n• None To search for the performance events that are caused by your content script, press Ctrl+F on Windows/Linux or Command+F on macOS. The Find text box appears at the bottom of the Performance tool.\n• None Type Evaluate script and then press Enter until the Performance tool highlights the performance events that are caused by your content script. You will know that you have found the right performance event when the Script label in the Summary panel shows the name of your content script:\n\nProfile your content script using the Edge tracing tool\n\nThe Edge tracing tool, available at the URL, is a powerful tool that can provide detailed analysis of your extension's performance. In this section, you'll learn how to use the Edge tracing tool to understand the impact of your extension on the page load time. To learn more about this tracing tool, which is based on the Perfetto tool, see Perfetto UI in the Perfetto Tracing Docs.\n• None To open the Edge tracing tool, open a new tab or window, and go to . The tracing UI opens.\n• None To start a new trace, in the top left corner of the tool, click the Record button. The Record a new trace dialog opens.\n• None Select the Manually select settings option button. The list of categories appears.\n• None To capture detailed information about your extension's content script compilation and execution, select all of the following categories:\n• None Click the Record button. The dialog closes, and the Edge tracing tool starts recording the trace.\n• None Open a new tab and load a webpage that your extension affects. The tracing tool collects data about the performance impact of your extension on the webpage.\n• None Open the tab where the Edge tracing tool is running, and then click the Stop button. The new trace information appears in the tool.\n\nTraces that are recorded by the Edge tracing tool provide a lot of information about the browser, as well as your extension.\n\nTo filter the information to show only what's relevant to the webpage that your extension impacted:\n• None In the page, press Shift+Esc to open the Browser Task Manager dialog.\n• None In the Browser Task Manager dialog, search for the tab that corresponds to the webpage that your extension affected, and note the number in the Process ID column. Close the dialog.\n• None In the toolbar of the Edge tracing tool, click Processes, and then select the checkbox that corresponds to the process ID you noted. Clear all other checkboxes.\n• None In the upper right corner of the Edge tracing tool, click the search field, type ScriptInjection::InjectJS, and then press Enter repeatedly until an event that corresponds to your extension is highlighted in the bottom panel. The bottom panel displays the start time and total duration of the event:\n\nTo continue analyzing the performance impact of your extension's content script on the webpage, look for the following key events inside the ScriptInjection::InjectJS event:\n• v8.compile - shows the compilation time of your content script.\n• v8.run - indicates the running time of the compiled script.\n\nOnly add content script code that's needed for the functionality of your extension\n\nYour extension's content script runs in the context of the webpage. To minimize the impact of your content script on that webpage, make sure to only add, in your content script, the minimum amount of code that your extension needs to run in the context of the webpage. Audit the code in your content script and remove legacy frameworks, tools, libraries, or other code that aren't needed by your content script to run in Microsoft Edge.\n\nYou can make use of lazy loading and code splitting techniques to minimize the amount of code that runs in your content script:\n• None Lazy loading is the process of loading your code only when it's needed, based on the user actions, the page content, or the extension logic.\n• None Code splitting is the process of dividing your code into smaller chunks, or modules, which can be loaded separately or on demand.\n\nIf your extension is small enough, you won't need a build tool to split your code. If your extension is larger, and if your code is more complex to manage, use a build tool to split your code into smaller chunks. Build tools can help you organize your code into logical units, which can be loaded on demand. For example, you can use webpack to split your code into entry points and dynamic imports:\n• None Entry points are loaded on every page load.\n• None Dynamic imports are only loaded on demand, such as when the user interacts with the webpage or with the extension's UI: // When the user clicks on the page. document.addEventListener(\"click\", async () => { // Dynamically load the code that's needed to handle the click event. const module = await import(\"chunk.js\"); // Do something with the newly loaded module code. });\n\nOnly load your content script in required pages and frames\n\nYour extension might not need to run on every webpage that the user visits. To reduce the amount of code that runs when webpages load, configure your extension to load content scripts only on the pages and frames where they are needed.\n\nTo configure the pages and frames where your content scripts are loaded, define URL patterns in your extension manifest file by using the property in the section. To learn more, see Inject scripts in Content scripts in the Chrome Extensions documentation.\n\nYou can also use the extensions API to programmatically inject your content script into the webpage. This API allows you to inject your content script based on the user's actions, the webpage content, or the extension logic. To learn more, see chrome.scripting in the Chrome Extensions documentation.\n\nUse the following best practices when configuring where your content scripts are loaded:\n• None Use the most specific URL patterns possible for the and properties in your extension manifest file. For example, if your content script only needs to run on webpages of the example.com domain, use instead of \" .\n• None To control whether your content script only runs in the top-level frame, or also in nested frames of the webpage that matches a URL pattern, use the property in your extension manifest file. By default, this property is set to , which means that your content script will only run in the top-level frame. If your content script needs to access or modify the DOM in nested frames, set this property to . Note that setting to increases the amount of code that runs on a webpage.\n\nTo reduce the amount of code that is loaded and that runs on each webpage, and to save memory and CPU resources, only load your content scripts when needed, instead of on every page load.\n\nConfigure when to load content scripts in your extension manifest file\n\nTo control when your extension's content script should be loaded, use the property in your extension's manifest file.\n\nBy default, this property is set to the value, which means that the content script will be loaded, and run, after the page has finished loading and the DOM is ready. This is the recommended value for most content scripts. The value ensures that the content script will not interfere with the page loading process.\n\nTo load and run your content script before the page is fully loaded, use the or values. These values are useful in cases such as modifying the webpage layout or styling, but they can also cause performance issues or compatibility problems with other scripts on the page.\n\nTo programmatically load your content scripts at runtime, only when needed, use the API . The API provides more control over when and where your content script is loaded.\n\nFor example, you can use the API to load your content script only after the user has interacted with the webpage or extension UI, such as when clicking an extension's button, or clicking a part of the webpage.\n\nIf you use the API when the user interacts with the webpage, make sure to carefully consider whether you need to repeatedly load your content script every time the interaction happens. Loading content scripts too frequently can cause user experience issues or errors.\n\nBlocking calls and long-running synchronous tasks can delay the webpage load or make other aspects of a webpage slower, as well as negatively impact the UI responsiveness.\n\nBlocking calls are JavaScript operations that prevent running other code until they complete. For example, using the , , or APIs (which are synchronous) prevents the webpage from running other code.\n\nLong-running synchronous tasks are synchronous tasks that take a long time to complete, preventing the browser from running other webpage code while they are running. This can include complex calculations, loops, or string manipulations.\n\nUse asynchronous or non-blocking code, such as the Fetch API, JavaScript Promises, or Web Workers where possible. Asynchronous or non-blocking code allows the execution of other code while waiting for the completion of a task, without blocking the browser process that runs the webpage.\n\nNote that, although using Web Workers to move your complex code logic to another thread is a good practice, it might still slow down devices that have a low CPU core count or that are already busy.\n\nBelow is an example using the Fetch API. While the data is being fetched, the browser is not blocked and can run other code:\n\nTo store data in your extension, use the API instead of the API, which is a synchronous API. The API is asynchronous and can store and retrieve data more efficiently, without affecting the performance of the webpage where your extension is running. For example, you can use the method to retrieve a previously stored value, and then use the result in a callback function:\n\nTo communicate between your content script and your extension's background page, or an other content script, use the or methods. These methods are asynchronous and non-blocking, and allow you to send and receive messages between the different parts of your extension. You can use promises or callbacks to handle the response of the messages. For example, you can use the method to send a message to the background page, and then use the returned object to process the response:\n\nUse Web Workers to run intensive tasks in your content script without blocking the thread that the browser uses to render the webpage. By using Web Workers, the code that runs the intensive tasks runs in a separate thread. Web Workers can improve the performance and responsiveness of your content script and of the webpages it runs on.\n\nNote that creating a Web Worker creates a new thread, which uses new resources on the devices. Using too many resources on low-end devices might lead to performance issues.\n\nTo communicate between your content script and Web Worker, use the and APIs. For example, to create a new Web Worker and send a message to it, use the following code:\n\nTo receive messages in your Web Worker, and to send messages back:"
    },
    {
        "link": "https://dev.to/oluwatobi2001/a-beginners-guide-to-building-content-scripts-df",
        "document": "Browser extensions are add-ons to the browsers which are used to add aesthetics to the site and also provide optimal user experience.\n\n The concept of content script in extension development is a quite useful knowledge to be acquired by developers alike as its significantly expanded the use cases of browser extensions.\n\nThis article aims to introduce what content scripts are and how they work. There would also be a demo project in which the basic of chrome extensions will be discussed and a simple content script will be used in our extension. With that, let's get started.\n\nFirst of all, what is a content script? Content scripts are JavaScript codes which on interaction with web pages via a browser extension, are executed to modify the webpage.\n\nIt easily achieves this by interacting with the webpage document object model. The web page document object model is the raw structure of the given web page. The manner by which the Chrome content scripts act to modify the web page in question is usually termed injection.\n\nHaving had a brief intro to content scripts, we would then go on to implement it on our web pages. But before then, we need to set up our browser extension which will power the script.\n\nSetting up a Chrome extension file is pretty straightforward. For further reference building extensions, attached below is the link to the Chrome extension documentation page. \n\n An ideal Chrome extension must include a well-detailed file which provides the default background information about the Chrome extension.\n\n Also, the appropriate file to be executed is also included. Other additional files help provide aesthetics to the extension.\n\n With that, let's go on to build our extension, incorporating our content script injection. We will illustrate the power of content scripts by creating a Chrome extension which displays a button overlaying on any active web page we navigate to.\n\nIn this section, the parts of the manifest file will be highlighted and discussed. Here is the code to the manifest file for the project.\n\nManifest version: The manifest version is usually requested. By default, it's set to 3. as it is a significant better upgrade than the version 2.\n\n Name: The name of the extension is also typed in the manifest file. In my case, the project is named . That can be tweaked to suit the user's preference. \n\n The Version of the Chrome extension is also inputted. In our case, this is the first version of the extension hence it's named , subsequent improvements on this extension can prompt modifying the file to increase the versions respectively.\n\n A description of what the extension does also gives credence to the Chrome extension to the non-technical users of the extension.\n\nSubsequent points raised are quite cogent in building the content scripts.\n\nThe permissions object highlights the route for the execution of the content scripts. This also prevents the content scripts from running in unexpected tabs and web pages. It allows us to list all the permissions our Chrome extension might require. Some Chrome extensions may need access to the browser storage, other Chrome APIs and some sites in question. In our case for this project, we are limiting our Chrome extension to just the being used. It's important to have this in place to reduce the risk of Chrome extension compromising other non-used parts of our Chrome browser.\n\nWe will then configure the content scripts field in our manifest file. \n\n The content scripts field specifies the various code files we intend to inject into our web page. \n\n It contains the sub field which specifies the webpage URL we want it to act upon. For ease of use, we just included all URLs allowing this to act on all web pages we access. You can however specify the URL you intend to inject in the subfield value. Eg www.google.com,\n\nThe files which contain the injection code are also specified. In our case, \n\n Our JS file is named . We also specified the file used in styling this project.\n\nWith this, we have had a miniature implementation of the manifest file for our project. We will then go on to write our injection code in the subsequent section\n\nIn the spirit of keeping things simple, we would be creating a simple button that when clicked upon, shows an alert message. This button is expected to overlay the existing webpage. \n\n Here is the code below\n\nThe styling can be changed to suit your preference however a styling template has been included in the code repository.\n\nhere is a picture of its implementation.\n\n\n\n Here is the link to the source code containing the code styling.\n\nSo far we have completed the project. However to advance one's knowledge, here are some of the advanced techniques and best practices you can also implement while building content scripts.\n• Implementation of data state managers to allow for dynamic scripting\n• Integrating other external APIs allows for data manipulation and analysis\n\nYou can also interact with me on my blog and check out my other articles here. Till next time, keep on coding!"
    }
]