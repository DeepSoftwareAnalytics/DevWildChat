[
    {
        "link": "https://stackoverflow.com/questions/46719183/c-using-ifstream-to-read-file",
        "document": "I have some questions regarding using in C++.\n\nMost are general questions I couldn't find answers to, so might be useful for others, too.\n\nAnyways, I use and made a variable .\n\nThere is a text file that has several lines of the pattern (where the s are numbers), like this:\n\nSo, I do this:\n\nSo the concerns are:\n• None why is the number needed in the method?\n• None does have at the end automatically? because when we create vars like , it is actually saved as and what happens to the endlines in the file ( ) after each of the lines? (I would like to use the lines in more complex code than this, so want to know)\n• None Will the program move to the next line automatically? If not, how do I tell it to go to the next line?"
    },
    {
        "link": "https://geeksforgeeks.org/read-file-using-ifstream-in-cpp",
        "document": "How to Read a File Using ifstream in C++?\n\nIn C++, we can read the contents of the file by using the ifstream object to that file. ifstream stands for input file stream which is a class that provides the facility to create an input from to some particular file. In this article, we will learn how to read a file line by line through the ifstream class in C++.\n\nRead File Using ifstream in C++\n\nTo read a file line by line using the ifstream class, we can use the std::getline() function. The getline() function can take input from any available stream so we can use the ifstream to the file with the getline() function.\n• None We will first create an ifstream object associated with the given file.\n• None We then use the getline() function and pass the previously created ifstream object to it along with the buffer.\n\nIn the following example, we will read a text file abc.txt line by line using the getline function of the input stream.\n\nC++ Program to Read File using ifstream in C++"
    },
    {
        "link": "https://stackoverflow.com/questions/7868936/read-file-line-by-line-using-ifstream-in-c",
        "document": "Reading a file line by line in C++ can be done in some different ways.\n\nThe simplest approach is to open an std::ifstream and loop using std::getline() calls. The code is clean and easy to understand.\n\nAnother possibility is to use the Boost library, but the code gets a bit more verbose. The performance is quite similar to the code above (Loop with std::getline()).\n\nIf performance is critical for your software, you may consider using the C language. This code can be 4-5 times faster than the C++ versions above, see benchmark below\n\nBenchmark -- Which one is faster?\n\nI have done some performance benchmarks with the code above and the results are interesting. I have tested the code with ASCII files that contain 100,000 lines, 1,000,000 lines and 10,000,000 lines of text. Each line of text contains 10 words in average. The program is compiled with optimization and its output is forwarded to in order to remove the logging time variable from the measurement. Last, but not least, each piece of code logs each line with the function for consistency.\n\nThe results show the time (in ms) that each piece of code took to read the files.\n\nThe performance difference between the two C++ approaches is minimal and shouldn't make any difference in practice. The performance of the C code is what makes the benchmark impressive and can be a game changer in terms of speed."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://cplusplus.com/reference/fstream/ifstream/ifstream",
        "document": "If the mode has set, the opening operation fails. It also fails if is set but is not.\n\n\n\nIf the mode has both and set, the opening operation fails. It also fails if is set but is not."
    },
    {
        "link": "https://stackoverflow.com/questions/1071674/dynamically-allocated-arrays-or-stdvector",
        "document": "I'm trying to optimize my C++ code. I've searched the internet on using dynamically allocated C++ arrays vs using std::vector and have generally seen a recommendation in favor of std::vector and that the difference in performance between the two is negligible. For instance here - Using arrays or std::vectors in C++, what's the performance gap?.\n\nHowever, I wrote some code to test the performance of iterating through an array/vector and assigning values to the elements and I generally found that using dynamically allocated arrays was nearly 3 times faster than using vectors (I did specify a size for the vectors beforehand). I used g++-4.3.2.\n\nHowever I feel that my test may have ignored issues I don't know about so I would appreciate any advice on this issue."
    },
    {
        "link": "https://stackoverflow.com/questions/54966568/storing-dynamic-array-in-vector",
        "document": "Your basic mistake is that you try to force the vector as if it was a raw array. It does stuff for you, let it. It knows it's size, for instance. You don't need\n\nInstead, you can use :\n\nLikewise, you first set the size of your vector and then increase it, which to me means that you do not trust it:\n\nAt this point, you have a vector with a hundred entries that are all zero. You don't need to resize it later if a hundred entries is all you need. resizes it. But note that setting it to a size of 100 means that [100] is not a valid position, the last one is [99], as we start to count at zero. You'd need to set it to a size of 101 to have both zero and hundred as valid addresses.\n\nI rewrote the structure, using a , I think the way I did it is more intuitive, but there will be people who disagree with that and who would also write things like\n\nand there are some good arguments for that, mostly a good practice routine, always doing the braces to avoid errors. However, I prefer a one liner to reduce verbosity.\n\nOne improvement would also be to tell the user about bad input:\n\nNow, another big thing to do here would be to leave the procedural part, by the way. Go for a which has all those functions as a part of it, being called like\n\nbut that is for when you get your code working."
    },
    {
        "link": "https://studyplan.dev/intro-to-programming/std-vector",
        "document": "Inevitably, we will want to store a group of related objects. That might be a collection of characters in a party, a collection of buttons on a UI, or countless other use cases.\n\nLet's imagine we have these objects, which we want to store and manage as a single collection:\n\nProgrammers have invented a huge range of options for storing collections of objects. These containers are broadly called data structures, and which data structure we should use depends on our specific requirements. We’ll cover a much wider range of data structures in the next course. Here, we’ll introduce the most common choice - the dynamic array.\n\nUnder the hood, arrays are contiguous blocks of memory, big enough to store multiple objects in sequence.\n\nThere are hundreds of implementations of arrays in C++ that we can use, and we can even create our own once we learn more advanced topics. In this lesson, we’re using the standard library’s implementation of dynamic arrays, which is called .\n\nThe C++ standard library using the \"vector\" name for their implementation of dynamic arrays is unfortunate. When we’re working on projects that involve maths and physics, such as a video games, the constructs we use to represent things like positions, movement and forces are also called vectors.\n\nThese vectors are not related to arrays at all - the confusing naming conflict is just something we need to adapt to.\n\nTo use , we need to . We can then declare a by giving it a name, and specifying the type of objects it will contain within angled brackets: and . The following example shows how we can declare a called that stores objects:\n\nWhen we see chevrons - and - in our code, we’re typically using an advanced C++ feature called templates. Templates allow classes and functions to be written without specifying all of the data types that the class or function will be using. In this case, the standard library authors created a container called that can store a collection of any type of object. As developers using , we just need to provide the type we want to store between the chevrons. This type we provide is referred to as a template argument. When we pass as the template argument - that is, - we create an array for storing values. But we can replace with any type: Templates are particularly powerful as they allow classes and functions to be compatible with types that aren’t known or don’t exist at the time the template was written. For example, the authors of couldn’t know we would want to store a collection of objects, but their code supports it anyway: We cover templates in much more detail, including how to create our own, in the advanced course.\n\nWe can provide a with some initial values:\n\nWhen we are initializing the values at the same time we declare the array, we can optionally remove the template argument. The compiler can infer what type the vector will be storing, based on the type of objects we provided for its initial values:\n\nTo do this, the compiler is using Class Template Argument Deduction (CTAD), which we’ll cover more in our advanced course.\n\nWe can access the members of our array with the subscript operator, which uses syntax. For example, to access an object within , we’d use , where is the index of the element we want to access.\n\nThe index of an element within an array is simply its position within the array. However, in most programming contexts, indexing is zero-based, meaning we start counting from . This means the first element of the vector is at index , the second element is at index , and so on.\n\nFor example, to access the elements of our array, we would do this:\n\nAs with all values, the index can be derived from any expression that evaluates to an integer:\n\nThis code logs out elements at indices , , and in order:\n\nThe size of an array refers to the number of elements it currently contains. This is also sometimes called the length of the array.\n\nThe function returns the current size of our :\n\nNote that because indexing is zero-based, the last element of a vector is at an index of one less than its . For an array of size , the last element is at index .\n\nWe can get the last element by applying this arithmetic within the subscript operator, or by using the function:\n\nOnce our array is created, we’ll often want to add more items to it. Typically, we want to add items to the end of arrays, as this has performance benefits over adding them to the start. We’ll cover the performance characteristics of containers in more detail in the next course.\n\nand many other data structures provide two ways of adding objects:\n• Pushing an object involves moving or copying an existing object into the container\n• Emplacing an object involves creating a new object directly within the container\n\nCreating an object in place has performance benefits over creating it elsewhere and then moving it. Therefore, where possible, we should prefer emplacing over pushing.\n\nWith , we’re adding items to the back of the container, so the respective functions are called and\n\nIf an object has already been constructed, and we want to add it to the back of our array, we can use :\n\nIf the object we want to add does not already exist, we can construct it right inside of the array, using .\n\nThe arguments we call with will be passed to the constructor of the object type the vector stores:\n\nThe type also offers an method to remove objects from our array. The erase method requires we provide an iterator, which is slightly more advanced than a simple index.\n\nWe cover iterators in detail in the advanced course, but for now, note that we can get an iterator corresponding to a index using , where is the index we’re interested in.\n\nSo, for example, to erase the second item (the item at index ) from our array we’d use:\n\nThe of our array will be reduced by , and all of the objects that were after the element we erased get moved by one position to the left to fill in the gap:\n\nWe can modify objects in a in the usual ways. We can replace the object at a given index using the assignment operator, :\n\nWe can also call functions (including operators) on our objects as needed:\n\nOur above example uses vectors with values, but we can store pointers and references in arrays too:\n\nArrays can also store other arrays. This creates \"multidimensional arrays\". For example, a 3x3 grid could be represented as an array of 3 rows, each row being an array of 3 items:\n\nWe can treat a collection of objects like any other value. Below, we pass a collection to a function:\n\nAs with any other parameter, arrays are passed by value by default. The performance implications are particularly important here, as copying a collection of objects is inherently more expensive than copying a single object.\n\nWe can pass by reference in the usual way, with or without :\n\nWe can also generate and use pointers in the normal way. The following code replicates the previous example, using pointers instead of references:\n\nA common task we have when working with arrays is to perform some action on every object in the collection. We can do this with a loop:\n\nThere is an issue with using values as the index of vectors: modern computers have enough memory to store a lot of objects in an array. This means that the of the array, or the index used to reference a specific position, can be a larger number than the maximum value storable in an .\n\nTo deal with this problem, we have the data type. is guaranteed to be large enough to match the largest possible size of the array.\n\nBecause of this, it is the recommended way of storing array sizes and indices:\n\nOften, we usually don’t need to work with indices at all - we just want to iterate over everything in the array. For those scenarios, we can use this syntax:\n\nThis is known as a range-based for loop. We cover these in more detail in the next course, including how to make our custom types compatible with this syntax.\n\nSimilar to functions, range-based for loops can receive their parameters by reference or value, with value being the default. This means each item in the collection is copied into the body of the loop. We should consider passing by reference instead, particularly if the type we’re using is expensive to copy:\n\nJust like when we’re passing by reference into a function if the loop body isn’t going to modify that reference, we should consider marking it as :\n\nand other arrays keep our objects in contiguous blocks of memory on our system. As we push or emplace objects into our array, it may run out of space at its current memory location.\n\nWe can see how much of our capacity we’re currently using by comparing what is returned from the and methods:\n• returns the number of elements currently in the array.\n• returns the number of elements the array can hold in its current memory location.\n\nBelow, we see the initially has a capacity of , with all spaces being taken. When we add a 6th item, the increases to , whilst the is now :\n\nWhen we add elements beyond the current capacity, the will do some work behind the scenes to let our array grow. It will:\n• Allocate a new block of memory with a larger capacity.\n• Move all existing elements to the new location.\n\nIn our previous example, this new location has enough space to store objects. We’re currently only storing , so we have room to add one more before everything needs to be moved to a larger memory block again.\n\nMoving an array to a new location has a performance cost, so if we’re able to reduce unnecessary movements, we should consider it.\n\nIf we know approximately how many objects our is likely to need to store, we can directly enough capacity for them. Below, we ask our to move to a location with room for objects:\n\nNow, it has plenty of room to grow before it needs to move again:\n\nNaturally, a with a capacity for objects will consume more system memory than one with a capacity of only .\n\nBut if we think it’s eventually going to grow to objects anyway, we may as well just reserve that space from the start and eliminate all the expensive moving.\n• Reallocation can be expensive, especially for large vectors or complex objects.\n• Using can help avoid unnecessary reallocations.\n• However, over-reserving can waste memory if the extra capacity isn't used.\n\nIn this lesson, we've explored the essentials of dynamic arrays, with a particular focus on . You've learned how to create, access, modify, and efficiently manage collections of objects, laying a strong foundation for more advanced programming concepts.\n• Understanding the difference between static and dynamic arrays, and the flexibility of .\n• Creating, initializing, and accessing elements in a , including using and methods.\n• Techniques for modifying elements within a , and the implications of passing vectors to functions.\n• Effective looping through vectors using both traditional and range-based for loops, and the importance of in managing vector sizes.\n• How manages its capacity, and how we can interact with that mechanism using and .\n\nIn the next lesson, we introduce the main design pattern used to manage memory in complex applications. We also introduce smart pointers, the main mechanism used to implement this pattern. We cover:\n• Memory Management Simplified: We explore how smart pointers automate memory management, thereby reducing the chances of memory-related errors.\n• Understanding Memory Ownership: What smart pointers are and how they implement an ownership model for objects in dynamically allocated memory\n• Creating Unique Pointers using : How to create unique pointers using ,\n• Access and Ownership Transfer: How to give other functions access to our resources, and whether we want to maintain or transfer ownership at the same time."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/x964ak/when_is_an_array_preferable_over_a_vector",
        "document": "I have noticed in Java programs they use arrays for algorithmic programming. Is it faster to use a dynamic array in C++ over a vector?"
    },
    {
        "link": "https://cplusplus.com/forum/beginner/235498",
        "document": "For example-\n\n Txt file would say: \n\n \n\n Iron Man, 487\n\n Captain America, 568\n\n The Hulk, 17\n\n Black Widow, 542\n\n Spider Man, 309\n\n Scarlet Witch, 184\n\n Winter Soldier, 237\n\n Just Thor, 491\n\n The Falcon, 319\n\n \n\n So like this simple dynamic array below, except instead of getting input from the user, it's reading it from this file and then showing it. \n\n \n\n std; main() { cout << ; length; cin >> length; *array = [length]; cout << \"I just allocated an array of integers of length \" << length << ; array[0] = 5; [] array; cin.clear(); cin.ignore(32767, ); cin.get(); 0; } I'm learning about Dynamic Arrays and I'm getting to programs that apply user input with them and have been practicing this; however, I would like to learn how to, instead of using user input, read from a text file into a dynamic array.For example-Txt file would say:Iron Man, 487Captain America, 568The Hulk, 17Black Widow, 542Spider Man, 309Scarlet Witch, 184Winter Soldier, 237Just Thor, 491The Falcon, 319So like this simple dynamic array below, except instead of getting input from the user, it's reading it from this file and then showing it.\n\n@tpb That's what I was thinking, but I have read conflicting information (probably over reading to the point of misunderstanding). But could you tell me what is the difference in vector and dynamic array? This confuses me a bit because I see people \"int *array\" and \"vector\" but it doesn't seem synonymous and the C++ book I have has some explanations but they're so garbled in technicality that it confuses me more tbh. I have found some awesome youtube channels that break things down better, but any information would be greatly appreciated. \n\n \n\n Thanks, girlscout\n\n\n\n \n\n A std::vector is a class provided by the C++ standard library that implements a dynamic array. So the only reason for you to implement a dynamic array is for learning purposes to build your own vector. As an example starting point here's a very simplified Vector I just whipped up. I used \"push\" instead of \"push_back\" and pop returns the object, but the most important difference is that the real std::vector class has around 70 methods counting all of the overloads.\n\nwhat is the difference in vector and dynamic array? \n\n 1. wraps an array in a C++ class template.\n\n \n\n 2. manages its memory automatically, a programmer doesn't have to use or to use a vector. When a vector goes out of scope the used memory is automatically released.\n\n \n\n 3. keeps track of the number of elements, the size of the vector.\n\n \n\n 4. is easily resizable at run-time, increasing or decreasing the number of elements as needed using member functions.\n\n \n\n 5. can be created empty, with a specified number of elements or specified number of elements filled with a specified value.\n\n \n\n 6. provides iterator functions to make sequentially accessing elements less prone to get out of bounds errors.\n\n \n\n 7. works well with loops\n\n \n\n 8. allows elements to be inserted and erased at any position in the vector.\n\n \n\n 9. Since keeps track of its size, having a vector as a function parameter doesn't require an additional parameter of the vector's size.\n\n 1.wraps an array in a C++ class template.2.manages its memory automatically, a programmer doesn't have to useorto use a vector. When a vector goes out of scope the used memory is automatically released.3.keeps track of the number of elements, the size of the vector.4.is easily resizable at run-time, increasing or decreasing the number of elements as needed using member functions.5.can be created empty, with a specified number of elements or specified number of elements filled with a specified value.6.provides iterator functions to make sequentially accessing elements less prone to get out of bounds errors.7.works well withloops8.allows elements to be inserted and erased at any position in the vector.9. Sincekeeps track of its size, having a vector as a function parameter doesn't require an additional parameter of the vector's size.\n\n@tpb Oh! I haven't used \"pop\" yet...currently googling the heck out of it. Super useful. Thank you! So does that mean a Vector...IS a dynamic array or just implements one?\n\n@FurryGuy You just made so much sense out of vectors 0.0 I bet you would make great tutorials! \n\n \n\n Okay so now that this is becoming clear to me, I'm wondering why would anyone implement a dynamic array over a vector when vector seems like a better option.\n\n\n\nwhy would anyone implement a dynamic array over a vector when vector seems like a better option. \n\n Maybe they don't know what vectors offer, are required to use dynamic arrays, or they don't like C++.\n\n \n\n Learning the hard way, using dynamic arrays with or , and the possible problems that can be encountered makes learning and using C++ containers a better overall solution.\n\n \n\n Similar to using C / vs. all of what the C++ header offers for generating random numbers. A bit more setup work, with a change in how random numbers are created, and consistently better random sequences are obtained with .\n\n \n\n / \"random\" rant off ;) Maybe they don't know what vectors offer, are required to use dynamic arrays, or they don't like C++.Learning the hard way, using dynamic arrays withor, and the possible problems that can be encountered makes learning and using C++ containers a better overall solution.Similar to using Cvs. all of what the C++header offers for generating random numbers. A bit more setup work, with a change in how random numbers are created, and consistently better random sequences are obtained with/ \"random\" rant off ;)"
    }
]