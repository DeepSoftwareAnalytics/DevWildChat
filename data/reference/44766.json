[
    {
        "link": "https://reddit.com/r/cpp/comments/1cner9k/best_practice_for_optimum_performance",
        "document": "Hi, I'm a scientific programmer. I primarily use Python and FORTRAN. I have to write a code that involves solving a finite difference equation on multidimensional vector array.\n\n(1) Defining a multidimensional array: The array is electric field with three components (ex, ey, ez) defined at (Nx, Ny, Nz) grid. Where Nx, Ny and Nz are the number of points along X, Y and Z. So if Nx, Ny, and Nz = 10, 9, 8 my array will be [10, 9, 8, 3] shape.\n\nThen I have to define gradient along all the three axes and solve some numerical equations which involves matrix multiplications.\n\nI have done this in Python and it was straight forward using Numpy Ndarrays.\n\nI recently tried porting my code to C++. I realised that defining multidimensional arrays in C++ is not so straightforward.\n\nWhat is the fastest and easiest method to implement such a multidimensional array in c++?"
    },
    {
        "link": "https://stackoverflow.com/questions/53038457/what-is-the-best-modern-c-approach-to-construct-and-manipulate-a-2d-array",
        "document": "Some points to get you started.\n\nFirst, vs . This is easy. If you know at compile time the size of your 2d array then definitely else .\n\nis ok for something that you need to cook up quickly and you use seldom in pieces of code that are not performance critical(1).\n\nThe big downside to is the memory layout. You have double indirection and each line is allocated separately, wreaking havoc on your cache so it's a definitely a no no in performance critical code (1). For performance critical code you need to use a mature math library. Experts can write performance oriented code order of magnitude better than you or me and another important advantage of such library is that it passed the test of time.\n\nIf for whatever reason you want to write this yourself then the solution is to flatten the matrix. I.e. use and then access the elements with the formula: . And wrap that in a nice interface. How complex the interface is and what kind of operations you allow on it it's totally up to you.\n\n(1) I would like to point out that most often especially novice programmers completely misunderstand performance concerns (it's completely understandable due to lack of experience). First there are some few generally acceptable practices that apply to any situation. Then comes the analysis of the algorithm and the data types used. But other than that you first write code for readability and then, if performance is a concern, you profile your code and start optimizing where the profiler tells you."
    },
    {
        "link": "https://stackoverflow.com/questions/9672731/manipulating-multidimensional-arrays-with-functions-in-c",
        "document": "I am trying to modify the contents of a 2D array in C++ using a function. I haven't been able to find information on how to pass a 2D array to a function by reference and then manipulate individual cells.\n\nThe problem I am trying to solve has the following format. I have made a simple program for brevity.\n\nSo the value of A[0][0] should change from 0 to 1. What is the correct way to do this? Many thanks in advance..."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-multidimensional-array",
        "document": "A multidimensional array is an array with more than one dimension. It means that it can grow in different directions i.e. instead of changing the length only, it can also change in width, depth or more. It is the homogeneous collection of items where each element is accessed using multiple indices.\n\nwhere s1, s2,…, sn is the size of each dimension.\n\nFor 1D array, the length of the array is simply its size too. But multidimensional arrays have extra dimensions. So, the size of each dimension is considered separately. The number of elements is the product of all its dimensions’ size. It is similar to calculating area in 2D and volume in 3D.\n\nFor example, consider the below array:\n• None The size in bytes can be calculated by multiplying the number of elements by size of each element or we can just use sizeof operator.\n• None In this case, size in bytes = 4*8 = 32 bytes\n\nTo verify the above calculation, we can use sizeof() method to find the size of an array.\n\nWe can have any number of dimensions in an array as per requirement, but the complexity of handling them also increases exponentially. That is why, the most widely used multidimensional arrays are:\n\nA two-dimensional array in C++ is a collection of elements organized the form of rows and columns. It can be visualized as a table or a grid, where each element is accessed using two indices: one for the row and one for the column. Like a one-dimensional array, two-dimensional array indices also range from 0 to n-1 for both rows and columns.\n\nLike 1D arrays, 2D arrays can also be initialized using a list of values enclosed inside {} curly brackets, but as 2D arrays have two dimensions, the list is nested inside another list to initialize each dimension one by one. It means that each row values are nested inside one big list.\n\nNesting can also be omitted, and values will still be assigned sequentially.\n\nThe above array has 2 rows and 4 columns. The elements are filled in a way that the first 4 elements are filled in the first row and the next 4 elements are filled in the second row. The values will be initialized sequentially.\n\nIt is to be noted that the number of values should not exceed the total number of elements an array can store. It can have less values (partial initialization) but cannot have more values.\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nElements of a 2-dimensional array have to be accessed using row and column indices. It is similar to matrix element position, but the only difference is that here indexing starts from 0.\n\nwhere, i is the index of row and j is the index of the column. The range of indexes should be:\n\nAny values other than that leads to the segmentation fault.\n\nThe value at any index can be updated by using = assignment operator.\n\nThe new_value should be of same data type.\n\nTwo loops nested inside each other are needed to traverse a 2D array, one for moving though each dimension. First loop is used to move though the rows of 2D array, while other is used to move though columns in each row to access all the elements of the row.\n\nA three-dimensional array in C++ is a collection of elements organized in a 3D cuboid-like structure. It can be visualized as a series of two-dimensional arrays stacked on top of each other. Each element is accessed using three indices: one for the depth, one for the row, and one for the column.\n\nTo declare a 3D array in C++, we need to specify its third dimension along with 2D dimensions.\n\nwhere depth is the number of 2D arrays in it.\n\nLike 2D arrays, 3D arrays can also be initialized using a list of values enclosed inside {} curly brackets. However, in a 3D array, the values are grouped into 2D arrays, and each 2D array is nested inside another set of curly brackets.\n\nAlternatively, nesting can be omitted, and the values will still be filled sequentially:\n\nThis array has 2 layers (depth), 2 rows per layer, and 3 columns per row. The values are filled sequentially across the layers.\n\nIt is important to note that the number of values should not exceed the total number of elements the array can store. If fewer values are provided, the rest of the array is initialized to 0 (partial initialization).\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nThe elements of a 3D array are accessed using three indices: depth, row, and column. These indices must be within the following ranges:\n\nTo update a value at any index of a 3D array, use the assignment operator = while accessing the element:\n\nTo traverse a 3D array, you need three nested loops: one for each dimension (depth, row, column).\n\nIn C++, you can pass multidimensional arrays to functions. Since multidimensional arrays have more than one dimension, the function signature needs to account for all dimensions.\n\nTo pass a 2D array to a function, you can specify the number of columns (or other dimensions) in the function signature. The number of rows can be deduced automatically.\n\nTo pass a 3D array to a function, you need to specify the size of the second and third dimensions."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/jw0pd/ask_c_what_is_the_correct_way_to_go_to_implement",
        "document": "I'm a CS student with Java, Python and Scheme experience, and just started to learn C++ in my free time.\n\nSpecifically I need a 2 dimensional array with different sizes that can easily be passed to different functions.\n\nMy first taught was to do declare this as follows, with the a print function I used for testing.\n\nBut this doesn't seem to work. I went to google to search how to implement a multidimensional array and I came upon many different suggentions, like using the vector class.\n\nSo what is the best way to implement an multidimentional grid/matrix/array?\n\nEDIT: Thanks for the quick reply's =) , A vector of a vector it will be."
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/basic_io",
        "document": "std; main () { i; cout << \"Please enter an integer value: \" ; cin >> i; cout << \"The value you entered is \" << i; cout << \" and its double is \" << i*2 << ; 0; }\n\nPlease enter an integer value: 702 The value you entered is 702 and its double is 1404."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_user_input.asp",
        "document": "You have already learned that is used to output (print) values. Now we will use to get user input.\n\nis a predefined variable that reads data from the keyboard with the extraction operator ( ).\n\nIn the following example, the user can input a number, which is stored in the variable . Then we print the value of :\n\nint x; \n\ncout << \"Type a number: \"; // Type a number and press enter\n\ncin >> x; // Get user input from the keyboard\n\ncout << \"Your number is: \" << x; // Display the input value Run example »\n\nIn this example, the user must input two numbers. Then we print the sum by calculating (adding) the two numbers:\n\nThere you go! You just built a basic calculator!\n\nTip: Both and belongs to the library, which is short for standard input / output streams. For a complete reference of <iostream> objects along with detailed information, go to our C++ iostream Reference."
    },
    {
        "link": "https://home.csulb.edu/~pnguyen/cecs282/lecnotes/inputoutput.pdf",
        "document": ""
    },
    {
        "link": "https://programiz.com/cpp-programming/input-output",
        "document": "In C++, cout sends formatted output to standard output devices, such as the screen. We use the object along with the operator for displaying output.\n\nHow does this program work?\n• We first include the iostream header file that allows us to display output.\n• The object is defined inside the namespace. To use the namespace, we used the statement.\n• Every C++ program starts with the function. The code execution begins from the start of the function.\n• is an object that prints the string inside quotation marks . It is followed by the operator.\n• is the \"exit status\" of the function. The program ends with this statement, however, this statement is not mandatory.\n\nNote: If we don't include the statement, we need to use instead of . This is the preferred method as using the namespace can create potential problems. However, we have used the namespace in our tutorials in order to make the codes more readable. #include <iostream> int main() { // prints the string enclosed in double quotes std::cout << \"This is C++ Programming\"; return 0; }\n\nTo print the numbers and character variables, we use the same object but without using quotation marks.\n\nIn C++, takes formatted input from standard input devices such as the keyboard. We use the object along with the operator for taking input.\n\nIn the program, we used\n\nto take input from the user. The input is stored in the variable . We use the operator with to take input.\n\nNote: If we don't include the statement, we need to use instead of ."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/arrays",
        "document": "foo[5]; foo[2] = 75; // access to an element of the array."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/arrays-cpp?view=msvc-170",
        "document": "An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using or instead of C-style arrays described in this section. Both of these standard library types store their elements as a contiguous block of memory. However, they provide greater type safety, and support iterators that are guaranteed to point to a valid location within the sequence. For more information, see Containers.\n\nIn a C++ array declaration, the array size is specified after the variable name, not after the type name as in some other languages. The following example declares an array of 1000 doubles to be allocated on the stack. The number of elements must be supplied as an integer literal or else as a constant expression. That's because the compiler has to know how much stack space to allocate; it can't use a value computed at run-time. Each element in the array is assigned a default value of 0. If you don't assign a default value, each element initially contains whatever random values happen to be at that memory location.\n\nThe first element in the array is the zeroth element. The last element is the (n-1) element, where n is the number of elements the array can contain. The number of elements in the declaration must be of an integral type and must be greater than 0. It is your responsibility to ensure that your program never passes a value to the subscript operator that is greater than .\n\nA zero-sized array is legal only when the array is the last field in a or and when the Microsoft extensions are enabled ( or isn't set).\n\nStack-based arrays are faster to allocate and access than heap-based arrays. However, stack space is limited. The number of array elements can't be so large that it uses up too much stack memory. How much is too much depends on your program. You can use profiling tools to determine whether an array is too large.\n\nYou may require an array that's too large to allocate on the stack, or whose size isn't known at compile time. It's possible to allocate this array on the heap by using a expression. The operator returns a pointer to the first element. The subscript operator works on the pointer variable the same way it does on a stack-based array. You can also use pointer arithmetic to move the pointer to any arbitrary elements in the array. It's your responsibility to ensure that:\n• you always keep a copy of the original pointer address so that you can delete the memory when you no longer need the array.\n• you don't increment or decrement the pointer address past the array bounds.\n\nThe following example shows how to define an array on the heap at run time. It shows how to access the array elements using the subscript operator and by using pointer arithmetic:\n\nYou can initialize an array in a loop, one element at a time, or in a single statement. The contents of the following two arrays are identical:\n\nWhen an array is passed to a function, it's passed as a pointer to the first element, whether it's a stack-based or heap-based array. The pointer contains no other size or type information. This behavior is called pointer decay. When you pass an array to a function, you must always specify the number of elements in a separate parameter. This behavior also implies that the array elements aren't copied when the array gets passed to a function. To prevent the function from modifying the elements, specify the parameter as a pointer to elements.\n\nThe following example shows a function that accepts an array and a length. The pointer points to the original array, not a copy. Because the parameter isn't , the function can modify the array elements.\n\nDeclare and define the array parameter as to make it read-only within the function block:\n\nThe same function can also be declared in these ways, with no change in behavior. The array is still passed as a pointer to the first element:\n\nArrays constructed from other arrays are multidimensional arrays. These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence. For example, consider this declaration:\n\nIt specifies an array of type , conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:\n\nThe image is a grid 7 cells wide and 5 cells high. Each cell contains the index of the cell. The first cell index is labeled 0,0. The next cell in that row is 0,1 and so on to the last cell in that row which is 0,6. The next row starts with the index 1,0. The cell after that has an index of 1,1. The last cell in that row is 1,6. This pattern repeats until the last row, which starts with the index 4,0. The last cell in the last row has an index of 4,6. :::image-end\n\nYou can declare multidimensioned arrays that have an initializer list (as described in Initializers). In these declarations, the constant expression that specifies the bounds for the first dimension can be omitted. For example:\n\nThe preceding declaration defines an array that is three rows by four columns. The rows represent factories and the columns represent markets to which the factories ship. The values are the transportation costs from the factories to the markets. The first dimension of the array is left out, but the compiler fills it in by examining the initializer.\n\nUse of the indirection operator (*) on an n-dimensional array type yields an n-1 dimensional array. If n is 1, a scalar (or array element) is yielded.\n\nC++ arrays are stored in row-major order. Row-major order means the last subscript varies the fastest.\n\nYou can also omit the bounds specification for the first dimension of a multidimensional array in function declarations, as shown here:\n\nThe function is written such that adding new factories doesn't require any code changes, just a recompilation.\n\nArrays of objects that have a class constructor are initialized by the constructor. When there are fewer items in the initializer list than elements in the array, the default constructor is used for the remaining elements. If no default constructor is defined for the class, the initializer list must be complete, that is, there must be one initializer for each element in the array.\n\nConsider the class that defines two constructors:\n\nThe first element of is constructed using the constructor ; the remaining two elements are constructed using the default constructor.\n\nStatic member arrays (whether or not) can be initialized in their definitions (outside the class declaration). For example:\n\nYou can access individual elements of an array by using the array subscript operator ( ). If you use the name of a one-dimensional array without a subscript, it gets evaluated as a pointer to the array's first element.\n\nWhen you use multidimensional arrays, you can use various combinations in expressions.\n\nIn the preceding code, is a three-dimensional array of type . The pointer points to an array of type of size three. In this example, the array is used with one, two, and three subscripts. Although it's more common to specify all subscripts, as in the statement, sometimes it's useful to select a specific subset of array elements, as shown in the statements that follow .\n\nLike other operators, the subscript operator ( ) can be redefined by the user. The default behavior of the subscript operator, if not overloaded, is to combine the array name and the subscript using the following method:\n\nAs in all addition that involves pointer types, scaling is done automatically to adjust for the size of the type. The resultant value isn't n bytes from the origin of ; instead, it's the nth element of the array. For more information about this conversion, see Additive operators.\n\nSimilarly, for multidimensional arrays, the address is derived using the following method:\n\nWhen an identifier of an array type appears in an expression other than , address-of ( ), or initialization of a reference, it's converted to a pointer to the first array element. For example:\n\nThe pointer points to the first element of the array . Arrays, unlike pointers, aren't modifiable l-values. That's why the following assignment is illegal:"
    },
    {
        "link": "https://codecademy.com/learn/c-plus-plus-for-programmers/modules/cpp-built-in-data-structures/cheatsheet",
        "document": "In C++, a vector is a data structure that stores a sequence of elements that can be accessed by index. Unlike arrays, vectors can dynamically shrink and grow in size.\n• : add element to the end of the vector.\n• : remove element from the end of the vector.\n• : return the size of the vector.\n• : return whether the vector is empty.\n\nIn C++, stacks and queues are data structures for storing data in specific orders. Stacks are designed to operate in a Last-In-First-Out context (LIFO), where elements are inserted and extracted only from one end of the container.\n• add an element at the top of the stack.\n• remove the element at the top of the stack. Queues are designed to operate in a First-In-First-Out context (FIFO), where elements are inserted into one end of the container and extracted from the other.\n• add an element at the end of the queue.\n• remove the element at the front of the queue.\n\nIn C++, a set is a data structure that contains a collection of unique elements. Elements of a set are index by their own values, or keys. A set cannot contain duplicate elements. Once an element has been added to a set, that element cannot be modified. The following methods apply to both and :\n• : add an element to the set.\n• : removes an element from the set.\n• : check whether an element exists in the set.\n• : return the size of the set. \"primes does not contain 2.\n\n\"\n\nArrays in C++ are used to store a collection of values of the same type. The size of an array is specified when it is declared and cannot change afterward. Use and an integer index to access an array element. Keep in mind: array indices start with , not !. A multidimensional array is an “array of arrays” and is declared by adding extra sets of indices to the array name.\n\nIn C++, a hash map is a data structure that contains a collection of unique elements in the form of key-value pairs. Elements of a hash map are identified by key values, while the mapped values are the content associated with the keys. Each element of a or is an object of type . A object has two member variables:\n• is the value of the key\n• is the mapped value The following methods apply to both and :\n• : add an element to the map.\n• : removes an element from the map.\n• : check whether an element exists in the map.\n• : return the size of the map.\n• operater:\n• If the specified key matches an element in the map, then access the mapped value associated with that key.\n• If the specified key doesn’t match any element in the map, add a new element to the map with that key. \"There is a code for Belgium\n\n\""
    },
    {
        "link": "https://stackoverflow.com/questions/34967756/where-is-the-official-c-documentation",
        "document": "The official C++ \"documentation\" is the C++ standard, ISO/IEC 14882:2014(E). There is information at ISOCPP how to obtain the document.\n\nI wouldn't necessarily consider the standard good documentation but it does specify the behavior of the standard language and library constructs.\n\nThere isn't any other official document on C++ describing the entire language. There are good derivative works making things more accessible like Bjarne Stroustrup's \"Programming: Principles as Practices Using C++\" and Nicolai Josuttis's \"The C++ Standard Library\"."
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-array",
        "document": ""
    }
]