[
    {
        "link": "https://en.cppreference.com/w/cpp/container/map",
        "document": "is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function . Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as Red–black trees.\n\nIterators of iterate in ascending order of keys, where ascending is defined by the comparison that was used for construction. That is, given\n• and , dereferenceable iterators to , with .\n\nm.value_comp()(*it_l, *it_r) == true (least to greatest if using the default comparison).\n\nEverywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent (not unique) if neither compares less than the other: !comp(a, b) && !comp(b, a).\n\nmeets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, maps are associative containers that store data in the form of key value pairs sorted on the basis of keys. No two mapped values can have the same keys. By default, it stores data in ascending order of the keys, but this can be changes as per requirement.\n\nExplanation: In the above program, we created a map m of integer keys and string values. We inserted three key-value pairs into the map: {1, “Geeks”}, {2, “For”}, and {3, “Geeks”}. The map automatically sorts the keys in ascending order.\n\nThe map container is defined as std::map class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, sorts data in increasing order of the keys.\n\nWe can declare and initialize a map in different ways as shown in the below example:\n\nExample: In the above program,\n• map<int, string> m1 is an empty map with no elements.\n• map<int, string> m2 = {{1, “Geeks”}, {2, “For”}, {3, “Geeks”}} initialized to three key-value pairs using initializer list.\n\nTo see more ways to declare and initialize map, refer to this article – Different Ways to Initialize a Map\n\nBasic operations on map containers are shown below:\n\nElements can be inserted into a map using either [] operator or insert() method. If the element with the given key already exists, the insert() method skips the insertion but [] operator updates the associated value to the new value.\n\nWe cannot specify any particular position to insert element as map automatically sort the data according to the order. To know more ways to insert elements in a map, refer this article – Different Ways to Insert Elements in a Map\n\nMap elements can be accessed by using the corresponding key inside operator []. If the key exists, it will return the associated value but if the key doesn’t exist, it will create a new element with the given key and the default value. To avoid this, we can also use at() method for accessing elements with any modification.\n\nTo know more methods to access values in a map, refer to the article – Different Ways to Access a Value in a Map\n\nThe key of an already present elements cannot be modified in the map. But the associated value can be changed by first accessing the element and then using assignment operator to change the value.\n\nExplanation: In this program, expression m[0] = “Tweaks” updates the value associated with the key 0. Similarly, expression m.at(1) = “By” updates the value of the key 1.\n\nTo see more methods to update values in a map, refer to the article – Different Ways to Update Value of a Pair in Map\n\nMap provides fast element search by key using the find() member function. This function returns iterator the element if found, otherwise returns end() iterator.\n\nTo know more methods to search element in map, refer to this article – Check if Map Contains a Specific Key\n\nMaps can be easily traversed by using either range based for loop or using begin() and end() iterator with traditional loops.\n\nTo see more methods to traverse a map, refer to the article – Different Ways to Traverse a Map\n\nMap elements can be deleted from a map using erase() method by passing the key or an iterator.\n\nTo know more ways to delete elements in a map, refer this article – Different Ways to Delete Elements from Map\n\nThe below table lists the time complexity of the above operations on map:\n\nFollowing are some other commonly used operations on a map in C++:\n\nIn C++, map is an associative container that provides the built-in implementation of Red-Black Tree. It stores the elements in some sorted order on the basis of keys. Due do RB Trees, insertion, deletion, and search operations takes logarithmic O(log n) time.\n\nHere’s the list of all member functions of std::map:\n\nInsert elements with a particular key in the map container. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to erase elements from the map. Returns an iterator pointing to the first element of the map. Returns an iterator pointing to the first element of the map. Returns a reverse iterator pointing to the element preceding the first element of the map Returns a reverse iterator pointing to the last element of the map. Returns an iterator to the element with key-value in the map if found, else returns the iterator to end. crbegin() returns a constant reverse iterator referring to the last element in the map container. crend() returns a constant reverse iterator pointing to the theoretical element before the first element in the map. cbegin() returns a constant iterator referring to the first element in the map container. cend() returns a constant iterator pointing to the element that is beyond the last element. Inserts the key with value in the map container. Returns the maximum number of elements a map can hold. Find the first element in the map that is just greater than the given key. Find the first element in the map that is equal to or greater than the given key. Inserts the key and its element in the map container with a given hint. Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the number of elements in the map. Returns whether the map is empty. Removes all the elements from the map. at() function is used to the element associated with the key k. swap() function is used to exchange the contents of two maps but the maps must be of the same type, although sizes may differ."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/header/map",
        "document": "This header is part of the containers library.\n\nstd Key, T, Compare less Key , Allocator allocator pair Key, T map Key, T, Compare, Allocator operator map Key, T, Compare, Allocator x, map Key, T, Compare, Allocator y Key, T, Compare, Allocator pair Key, T operator map Key, T, Compare, Allocator x, map Key, T, Compare, Allocator y Key, T, Compare, Allocator swap map Key, T, Compare, Allocator x, map Key, T, Compare, Allocator y x. y Key, T, Compare, Allocator, Predicate map Key, T, Compare, Allocator erase_if map Key, T, Compare, Allocator c, Predicate pred Key, T, Compare less Key , Allocator allocator pair Key, T multimap Key, T, Compare, Allocator operator multimap Key, T, Compare, Allocator x, multimap Key, T, Compare, Allocator y Key, T, Compare, Allocator pair Key, T operator multimap Key, T, Compare, Allocator x, multimap Key, T, Compare, Allocator y Key, T, Compare, Allocator swap multimap Key, T, Compare, Allocator x, multimap Key, T, Compare, Allocator y x. y Key, T, Compare, Allocator, Predicate multimap Key, T, Compare, Allocator erase_if multimap Key, T, Compare, Allocator c, Predicate pred pmr Key, T, Compare less Key map Key, T, Compare, polymorphic_allocator pair Key, T Key, T, Compare less Key multimap Key, T, Compare, polymorphic_allocator pair Key, T\n\nstd Key, T, Compare less Key , Allocator allocator pair Key, T map key_type Key mapped_type T value_type pair Key, T key_compare Compare allocator_type Allocator pointer allocator_traits Allocator const_pointer allocator_traits Allocator reference value_type const_reference value_type size_type difference_type iterator const_iterator reverse_iterator iterator const_reverse_iterator const_iterator node_type insert_return_type iterator, node_type value_compare Compare comp value_compare Compare c comp c operator value_type x, value_type y comp x. , y. map map Compare map Compare comp, Allocator Allocator InputIter map InputIter first, InputIter last, Compare comp Compare , Allocator Allocator value_type R map from_range_t, R rg, Compare comp Compare , Allocator Allocator map map x map map x map Allocator map map , type_identity_t Allocator map map , type_identity_t Allocator map initializer_list value_type , Compare Compare , Allocator Allocator InputIter map InputIter first, InputIter last, Allocator a map first, last, Compare , a value_type R map from_range_t, R rg, Allocator a map from_range, R rg , Compare , a map initializer_list value_type il, Allocator a map il, Compare , a ~map map operator map x map operator map x allocator_traits Allocator is_nothrow_move_assignable_v Compare map operator initializer_list value_type allocator_type get_allocator iterator begin const_iterator begin iterator end const_iterator end reverse_iterator rbegin const_reverse_iterator rbegin reverse_iterator rend const_reverse_iterator rend const_iterator cbegin const_iterator cend const_reverse_iterator crbegin const_reverse_iterator crend empty size_type size size_type max_size mapped_type operator key_type x mapped_type operator key_type x K mapped_type operator K x mapped_type at key_type x mapped_type at key_type x K mapped_type at K x K mapped_type at K x ... pair iterator, emplace Args ... ... iterator emplace_hint const_iterator position, Args ... pair iterator, insert value_type x pair iterator, insert value_type x P pair iterator, insert P x iterator insert const_iterator position, value_type x iterator insert const_iterator position, value_type x P iterator insert const_iterator position, P InputIter insert InputIter first, InputIter last value_type R insert_range R rg insert initializer_list value_type node_type extract const_iterator position node_type extract key_type x K node_type extract K x insert_return_type insert node_type nh iterator insert const_iterator hint, node_type nh ... pair iterator, try_emplace key_type k, Args ... ... pair iterator, try_emplace key_type k, Args ... K, ... pair iterator, try_emplace K k, Args ... ... iterator try_emplace const_iterator hint, key_type k, Args ... ... iterator try_emplace const_iterator hint, key_type k, Args ... K, ... iterator try_emplace const_iterator hint, K k, Args ... M pair iterator, insert_or_assign key_type k, M obj M pair iterator, insert_or_assign key_type k, M obj K, M pair iterator, insert_or_assign K k, M obj M iterator insert_or_assign const_iterator hint, key_type k, M obj M iterator insert_or_assign const_iterator hint, key_type k, M obj K, M iterator insert_or_assign const_iterator hint, K k, M obj iterator erase iterator position iterator erase const_iterator position size_type erase key_type x K size_type erase K x iterator erase const_iterator first, const_iterator last swap map allocator_traits Allocator is_nothrow_swappable_v Compare clear C2 merge map Key, T, C2, Allocator source C2 merge map Key, T, C2, Allocator source C2 merge multimap Key, T, C2, Allocator source C2 merge multimap Key, T, C2, Allocator source key_compare key_comp value_compare value_comp iterator find key_type x const_iterator find key_type x K iterator find K x K const_iterator find K x size_type count key_type x K size_type count K x contains key_type x K contains K x iterator lower_bound key_type x const_iterator lower_bound key_type x K iterator lower_bound K x K const_iterator lower_bound K x iterator upper_bound key_type x const_iterator upper_bound key_type x K iterator upper_bound K x K const_iterator upper_bound K x pair iterator, iterator equal_range key_type x pair const_iterator, const_iterator equal_range key_type x K pair iterator, iterator equal_range K x K pair const_iterator, const_iterator equal_range K x InputIter, Compare less InputIter , Allocator allocator InputIter map InputIter, InputIter, Compare Compare , Allocator Allocator map InputIter , InputIter , Compare, Allocator R, Compare less R , Allocator allocator R map from_range_t, R , Compare Compare , Allocator Allocator map R , R , Compare, Allocator Key, T, Compare less Key , Allocator allocator pair Key, T map initializer_list pair Key, T , Compare Compare , Allocator Allocator map Key, T, Compare, Allocator InputIter, Allocator map InputIter, InputIter, Allocator map InputIter , InputIter , less InputIter , Allocator R, Allocator map from_range_t, R , Allocator map R , R , less R , Allocator Key, T, Allocator map initializer_list pair Key, T , Allocator map Key, T, less Key , Allocator\n\nstd Key, T, Compare less Key , Allocator allocator pair Key, T multimap key_type Key mapped_type T value_type pair Key, T key_compare Compare allocator_type Allocator pointer allocator_traits Allocator const_pointer allocator_traits Allocator reference value_type const_reference value_type size_type difference_type iterator const_iterator reverse_iterator iterator const_reverse_iterator const_iterator node_type value_compare Compare comp value_compare Compare c comp c operator value_type x, value_type y comp x. , y. multimap multimap Compare multimap Compare comp, Allocator Allocator InputIter multimap InputIter first, InputIter last, Compare comp Compare , Allocator Allocator value_type R multimap from_range_t, R rg, Compare comp Compare , Allocator Allocator multimap multimap x multimap multimap x multimap Allocator multimap multimap , type_identity_t Allocator multimap multimap , type_identity_t Allocator multimap initializer_list value_type , Compare Compare , Allocator Allocator InputIter multimap InputIter first, InputIter last, Allocator a multimap first, last, Compare , a value_type R multimap from_range_t, R rg, Allocator a multimap from_range, R rg , Compare , a multimap initializer_list value_type il, Allocator a multimap il, Compare , a ~multimap multimap operator multimap x multimap operator multimap x allocator_traits Allocator is_nothrow_move_assignable_v Compare multimap operator initializer_list value_type allocator_type get_allocator iterator begin const_iterator begin iterator end const_iterator end reverse_iterator rbegin const_reverse_iterator rbegin reverse_iterator rend const_reverse_iterator rend const_iterator cbegin const_iterator cend const_reverse_iterator crbegin const_reverse_iterator crend empty size_type size size_type max_size ... iterator emplace Args ... ... iterator emplace_hint const_iterator position, Args ... iterator insert value_type x iterator insert value_type x P iterator insert P x iterator insert const_iterator position, value_type x iterator insert const_iterator position, value_type x P iterator insert const_iterator position, P x InputIter insert InputIter first, InputIter last value_type R insert_range R rg insert initializer_list value_type node_type extract const_iterator position node_type extract key_type x K node_type extract K x iterator insert node_type nh iterator insert const_iterator hint, node_type nh iterator erase iterator position iterator erase const_iterator position size_type erase key_type x K size_type erase K x iterator erase const_iterator first, const_iterator last swap multimap allocator_traits Allocator is_nothrow_swappable_v Compare clear C2 merge multimap Key, T, C2, Allocator source C2 merge multimap Key, T, C2, Allocator source C2 merge map Key, T, C2, Allocator source C2 merge map Key, T, C2, Allocator source key_compare key_comp value_compare value_comp iterator find key_type x const_iterator find key_type x K iterator find K x K const_iterator find K x size_type count key_type x K size_type count K x contains key_type x K contains K x iterator lower_bound key_type x const_iterator lower_bound key_type x K iterator lower_bound K x K const_iterator lower_bound K x iterator upper_bound key_type x const_iterator upper_bound key_type x K iterator upper_bound K x K const_iterator upper_bound K x pair iterator, iterator equal_range key_type x pair const_iterator, const_iterator equal_range key_type x K pair iterator, iterator equal_range K x K pair const_iterator, const_iterator equal_range K x InputIter, Compare less InputIter , Allocator allocator InputIter multimap InputIter, InputIter, Compare Compare , Allocator Allocator multimap InputIter , InputIter , Compare, Allocator R, Compare less R , Allocator allocator R multimap from_range_t, R , Compare Compare , Allocator Allocator multimap R , R , Compare, Allocator Key, T, Compare less Key , Allocator allocator pair Key, T multimap initializer_list pair Key, T , Compare Compare , Allocator Allocator multimap Key, T, Compare, Allocator InputIter, Allocator multimap InputIter, InputIter, Allocator multimap InputIter , InputIter , less InputIter , Allocator R, Allocator multimap from_range_t, R , Allocator multimap R , R , less R , Allocator Key, T, Allocator multimap initializer_list pair Key, T , Allocator multimap Key, T, less Key , Allocator\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://incredibuild.com/blog/c-map-explained-with-examples",
        "document": ""
    },
    {
        "link": "https://cplusplus.com/reference/map/map",
        "document": "an unsigned integral type that can represent any non-negative value of\n\nusually the same as size_t"
    },
    {
        "link": "https://udacity.com/blog/2020/03/c-maps-explained.html",
        "document": "Looking to learn more about maps in C++ and how to use them? Then this article is for you. We cover the details on how exactly to use maps, present some use cases for them and explain when to avoid them entirely. Let’s dive in.\n\nWhat is a map in C++?\n\nA C++ map is a way to store a key-value pair. A map can be declared as follows:\n\nEach map entry consists of a pair: a key and a value. In this case, both the key and the value are defined as integers, but you can use other types as well: strings, vectors, types you define yourself, and more.\n\nThere are two main reasons why the map type can be valuable to C++ developers. First, a map allows fast access to the value using the key. This property is useful when building any kind of index or reference. Second, the map ensures that a key is unique across the entire data structure, which is an excellent technique for avoiding duplication of data.\n\nBy virtue of these two advantages, a map is a common choice if you’re developing, for instance, a trading application in which you need to store stock prices by ticker symbol. If you’re creating a weather application, a map would be an effective way to save and look up the current temperature in a set of cities around the world. In an e-commerce store, you’ll likely need a map to find products by identifiers or categories.\n\nHow do I use a map in C++?\n\nThe primary operations you’ll perform with a map are creating a new map, adding elements to and reading elements from a map, and iterating through every element in a map. Let’s take a look at each of these actions.\n\nThere are five ways to construct a map in C++, but two of them are much more commonly used than the others. The first way is to create an empty map, then add elements to it:\n\nIn this example, we create a map that uses integers as keys and strings as values. We use the pair construct to create a key-value pair on the fly and insert that into our map.\n\nThe second often-used option is to initialize the map to a list of values at declaration. This option has been available since the C++11 standard and therefore isn’t supported by older compilers, but it allows for clearer declaration:\n\nOther ways to create a map include copying an existing map, copying parts of an existing map (by indicating a start position and an end position for the copy) and moving elements from another map without creating an intermediate copy.\n\nIn order to access the elements of the map, you can use array-style square brackets syntax:\n\nAnother option, available as of C++11, is the at method:\n\nWhen inserting elements into a map, it’s common to use either the square brackets syntax or the insert method:\n\nIn some cases, you might need to walk through a map and retrieve all the values in it. You can do this by using an iterator—a pointer that facilitates sequential access to a map’s elements.\n\nAn iterator is bound to the shape of the map, so when creating an iterator you’ll need to specify which kind of map the iterator is for. Once you have an iterator, you can use it to access both keys and values in a map. Here’s what the code would look like:\n\nIn this example, the map contains pairs of <int, string>, so we create an iterator that matches that format. We use the sample_map.begin() method to point the iterator to where it should start, and indicate that the for loop should stop when we reach the sample_map.end() location—the end of the map.\n\nThe iterator provides an it->first function to access the first element in a key-value pair (the key), and then it->second can be used to access the value. So, using the example above, we would print out only the values from our sample map.\n\nWhen not to use a C++ map\n\nThe map in C++ is a great fit for quickly looking up values by key. However, searching the contents of a map by value requires iterating through an entire map. If you want to be able to find values in a map, iterating through it can be slow as a map gets large.\n\nThe Boost library offers a bi-directional map which performs better when searching for values often. This data structure isn’t included in the standard C++ library, so you’ll need to install the Boost library on each machine where you compile or run your program (dynamic linking), or alternatively include the Boost library inside your executable (static linking).\n\nIf you find yourself needing to search a map by value in a relatively simple program, it may be that a map is the wrong object to use. Consider using a C++ vector, queue, stack or other data structure which might end up making the program more straightforward and more efficient.\n\nDoes order matter in C++ maps?\n\nTo demonstrate whether order is important in C++ maps, we’ve slightly modified the above example to insert the element { 4, “four” } before inserting { 3, “three” }:\n\nWhen we run the program, the output is still the same as before, even though the order in which we add elements has changed!\n\nThis is because maps in C++ keep their elements ordered by key. Also, in C++ a map can’t contain duplicate items, so using a map is a way to simultaneously deduplicate and order a set of elements.\n\nIf you don’t care about the order of elements in a map, consider using an unordered_map element, which is faster at adding and accessing elements than a regular map.\n\nYou definitely can! Just make sure that the format of the map reflects your intentions:\n\nIn this example, the inner map object acts as a value in the outer map.\n\nIf you’d like to see the list of all available methods for a map object, check out the map reference. If you’re looking for more examples of map usage, consider reading the C++ map tutorial usage guide.\n\nIn this article, we walked you through what a C++ map is and how to use one. We showed you a few examples of adding elements, reading them and traversing the map.\n\nWould you like to learn more about C++? Sign up for our C++ Nanodegree program."
    },
    {
        "link": "https://geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, maps are associative containers that store data in the form of key value pairs sorted on the basis of keys. No two mapped values can have the same keys. By default, it stores data in ascending order of the keys, but this can be changes as per requirement.\n\nExplanation: In the above program, we created a map m of integer keys and string values. We inserted three key-value pairs into the map: {1, “Geeks”}, {2, “For”}, and {3, “Geeks”}. The map automatically sorts the keys in ascending order.\n\nThe map container is defined as std::map class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, sorts data in increasing order of the keys.\n\nWe can declare and initialize a map in different ways as shown in the below example:\n\nExample: In the above program,\n• map<int, string> m1 is an empty map with no elements.\n• map<int, string> m2 = {{1, “Geeks”}, {2, “For”}, {3, “Geeks”}} initialized to three key-value pairs using initializer list.\n\nTo see more ways to declare and initialize map, refer to this article – Different Ways to Initialize a Map\n\nBasic operations on map containers are shown below:\n\nElements can be inserted into a map using either [] operator or insert() method. If the element with the given key already exists, the insert() method skips the insertion but [] operator updates the associated value to the new value.\n\nWe cannot specify any particular position to insert element as map automatically sort the data according to the order. To know more ways to insert elements in a map, refer this article – Different Ways to Insert Elements in a Map\n\nMap elements can be accessed by using the corresponding key inside operator []. If the key exists, it will return the associated value but if the key doesn’t exist, it will create a new element with the given key and the default value. To avoid this, we can also use at() method for accessing elements with any modification.\n\nTo know more methods to access values in a map, refer to the article – Different Ways to Access a Value in a Map\n\nThe key of an already present elements cannot be modified in the map. But the associated value can be changed by first accessing the element and then using assignment operator to change the value.\n\nExplanation: In this program, expression m[0] = “Tweaks” updates the value associated with the key 0. Similarly, expression m.at(1) = “By” updates the value of the key 1.\n\nTo see more methods to update values in a map, refer to the article – Different Ways to Update Value of a Pair in Map\n\nMap provides fast element search by key using the find() member function. This function returns iterator the element if found, otherwise returns end() iterator.\n\nTo know more methods to search element in map, refer to this article – Check if Map Contains a Specific Key\n\nMaps can be easily traversed by using either range based for loop or using begin() and end() iterator with traditional loops.\n\nTo see more methods to traverse a map, refer to the article – Different Ways to Traverse a Map\n\nMap elements can be deleted from a map using erase() method by passing the key or an iterator.\n\nTo know more ways to delete elements in a map, refer this article – Different Ways to Delete Elements from Map\n\nThe below table lists the time complexity of the above operations on map:\n\nFollowing are some other commonly used operations on a map in C++:\n\nIn C++, map is an associative container that provides the built-in implementation of Red-Black Tree. It stores the elements in some sorted order on the basis of keys. Due do RB Trees, insertion, deletion, and search operations takes logarithmic O(log n) time.\n\nHere’s the list of all member functions of std::map:\n\nInsert elements with a particular key in the map container. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to erase elements from the map. Returns an iterator pointing to the first element of the map. Returns an iterator pointing to the first element of the map. Returns a reverse iterator pointing to the element preceding the first element of the map Returns a reverse iterator pointing to the last element of the map. Returns an iterator to the element with key-value in the map if found, else returns the iterator to end. crbegin() returns a constant reverse iterator referring to the last element in the map container. crend() returns a constant reverse iterator pointing to the theoretical element before the first element in the map. cbegin() returns a constant iterator referring to the first element in the map container. cend() returns a constant iterator pointing to the element that is beyond the last element. Inserts the key with value in the map container. Returns the maximum number of elements a map can hold. Find the first element in the map that is just greater than the given key. Find the first element in the map that is equal to or greater than the given key. Inserts the key and its element in the map container with a given hint. Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the number of elements in the map. Returns whether the map is empty. Removes all the elements from the map. at() function is used to the element associated with the key k. swap() function is used to exchange the contents of two maps but the maps must be of the same type, although sizes may differ."
    },
    {
        "link": "https://stackoverflow.com/questions/68637162/the-best-practice-for-unordered-map-keys-and-values-modification",
        "document": "Since apparently values in map are unique and after applying modulo operation values contains unique items, then you should use different data structure. for example:\n\nwill handle uniqueness and order of items for given key.\n\nNow the whole trick is to inspect API of and and how item can be inserted there. See:\n\nNote return value: which gives you iterator to inserted or exciting item in map/set.\n\nKnowing this thing writing a code which is able to meet your requriements is quite simple:"
    },
    {
        "link": "https://reddit.com/r/roguelikedev/comments/3ry6jl/storing_your_map_data_c_though_should_be",
        "document": "I'm a long time roguelike player, avid fan of roguelike radio, have a degree in Computer Science, and a penchant for PCG.\n\nFirst off -tile maps and graphics are easy for me. Getting my '@' to walk about and use stairs and doors was quite easy for me using C++ and the SFML API. What I am not so familiar with, are some of the core concepts and it was here I was hoping you could help :)\n\nI've been working on some very basic PCG just to get my head around some of the concepts ...drunken walk etc ...baby steps.\n\nMy next foray is perfect maze generation using the recursive backtracker method. Before I begin though, I want to know how you store your map data!\n\nint array MAP[MAX][MAX] while somewhat elegant, seems cumbersome and rather inefficient.\n\nstd::vector<int> MAP(MAX * MAX) seems much nicer, but then I have all that cumbersome fiddling about with (x * MAX + y) to get at my individual tiles.\n\nHow do you do it? I would really like to look at some modern examples ...I find that while the Angband source code is helpful, it's full of dated code and I fear it may lead to teaching me some bad practices if I merely try and emulate it.\n\nYour patience and time is greatly appreciated."
    },
    {
        "link": "https://medium.com/@chittaranjansethi/a-comprehensive-guide-to-std-map-in-c-with-code-examples-f5cd576669f1",
        "document": "In the world of programming, efficient data storage and retrieval are crucial for many applications. One powerful tool in C++ that helps achieve this is the std::map container. std::map is a part of the Standard Template Library (STL) and provides an associative array that stores key-value pairs. In this blog, we will explore the features of std::map and provide a code example to demonstrate its usage.\n\nstd::map is implemented as a binary search tree, which ensures that the elements are always sorted based on their keys. This sorted structure allows for efficient searching, insertion, and deletion of elements, making std::map a popular choice when fast key-based operations are required.\n• Ordered Storage: As mentioned earlier, std::map arranges its elements based on their keys. This ordering enables easy traversal of the elements in either ascending or descending order.\n• Unique Keys: Each key in a std::map is unique. This property ensures that you cannot have multiple elements with the same key. If an attempt is made to insert a duplicate key, the insertion operation will fail.\n• Associative Lookup: std::map allows for efficient associative lookup. Given a key, you can quickly find the corresponding value associated with it. This feature is particularly useful in scenarios where you need to perform frequent searches based on specific keys.\n• Dynamic Size: std::map can dynamically grow and shrink as elements are inserted or removed. It takes care of memory management, making it convenient to work with varying data sizes.\n• Efficient Operations: std::map provides efficient operations like insertion, deletion, and searching, with a time complexity of O (log n).\n\nLet’s dive into a simple code example to demonstrate the usage of std::map:\n\nIn this example, we create a std::map called to store student names with corresponding integer keys. We insert three key-value pairs using the function. We then access and update elements using the keys. The ‌function is used to check if a particular key exists. We iterate over the map using a range-based for loop and print the values. Finally, we remove an element using and check the size of the map using the function.\n\nIn this example, we create a std::map named with the key as a string and the value as an integer. We then insert three key-value pairs into the map using the subscript operator ( ). The keys are the names of the students, and the values represent their marks.\n\nWe access the value associated with the key “Bob” using the subscript operator, and modify the value associated with the key “Charlie” using the same operator. We also demonstrate how to check if a key exists in the map using the function.\n\nFinally, we iterate over the map using a range-based for loop and print all the key-value pairs.\n\nstd::map is a versatile container in C++ that simplifies data storage and retrieval based on keys. Its ordered storage, associative lookup, and dynamic size make it a powerful tool for various applications. With its well-defined functionality and ease of use, std::map is worth considering whenever you need efficient key-based operations in your C++ programs."
    }
]