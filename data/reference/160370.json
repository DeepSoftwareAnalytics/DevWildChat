[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://w3schools.com/python/ref_random_choices.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://geeksforgeeks.org/random-choices-method-in-python",
        "document": "The choices() method returns multiple random elements from the list with replacement. Unlike random.choice(), which selects a single item, random.choices() allows us to select multiple items making it particularly useful for tasks like sampling from a population or generating random data.\n• None The code uses random.choices() to select 5 items from the list a = [“geeks”, “for”, “python”].\n• Weights: The item “geeks” has a weight of 10, making it 10 times more likely to be selected than “for” and “python”, which each have a weight of 1.\n• k = 5: Specifies that 5 items will be selected, with replacement (meaning duplicates are possible).\n\nNote: Every time output will be different as the system returns random elements.\n\nLet’s take a closer look at random.choices() method:\n• Example 2: Selects 3 elements from items with specified weights, making some items more likely to be selected.\n• Example 3: Selects 3 elements with cumulative weights, ensuring that selection probabilities are proportionally distributed.\n• Example 4: Selects 5 random characters from the alphabet string, demonstrating the flexibility of random.choices() with strings.\n\nIt allows for sampling with replacement, meaning the same item can be selected multiple times. Common practical applications include:\n• Lottery or Prize Draws: Randomly selecting winners from a pool of entries, where some participants may have more chances based on certain conditions.\n• Simulating Weighted Outcomes: For example, simulating biased coin flips or biased random events (e.g., selecting between different items in a game where certain items are rarer).\n• Random Sampling: Selecting items from a list for tasks like A/B testing, survey sampling, or testing combinations."
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/generated/numpy.std.html",
        "document": "Compute the standard deviation along the specified axis.\n\nReturns the standard deviation, a measure of the spread of a distribution, of the array elements. The standard deviation is computed for the flattened array by default, otherwise over the specified axis.\n\nCalculate the standard deviation of these values. axis None or int or tuple of ints, optional Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array. If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before. Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type. Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary. See Output type determination for more details. Means Delta Degrees of Freedom. The divisor used in calculations is , where represents the number of elements. By default ddof is zero. See Notes for details about use of ddof. If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the method of sub-classes of , however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised. Elements to include in the standard deviation. See for details. Provide the mean to prevent its recalculation. The mean should have a shape as if it was calculated with . The axis for the calculation of the mean should be the same as used in the call to this std function. Array API compatible name for the parameter. Only one of them can be provided at the same time. If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array.\n\nThere are several common variants of the array standard deviation calculation. Assuming the input a is a one-dimensional NumPy array and is either provided as an argument or computed as , NumPy computes the standard deviation of an array as:\n\nDifferent values of the argument ddof are useful in different contexts. NumPy’s default corresponds with the expression:\n\nwhich is sometimes called the “population standard deviation” in the field of statistics because it applies the definition of standard deviation to a as if a were a complete population of possible observations.\n\nMany other libraries define the standard deviation of an array differently, e.g.:\n\nIn statistics, the resulting quantity is sometimed called the “sample standard deviation” because if a is a random sample from a larger population, this calculation provides the square root of an unbiased estimate of the variance of the population. The use of \\(N-1\\) in the denominator is often called “Bessel’s correction” because it corrects for bias (toward lower values) in the variance estimate introduced when the sample mean of a is used in place of the true mean of the population. The resulting estimate of the standard deviation is still biased, but less than it would have been without the correction. For this quantity, use .\n\nNote that, for complex numbers, takes the absolute value before squaring, so that the result is always real and nonnegative.\n\nFor floating-point input, the standard deviation is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the keyword can alleviate this issue.\n\nIn single precision, std() can be inaccurate:\n\nComputing the standard deviation in float64 is more accurate:\n\nUsing the mean keyword to save computation time:"
    },
    {
        "link": "https://numpy.org/devdocs/user/quickstart.html",
        "document": "You’ll need to know a bit of Python. For a refresher, see the Python tutorial. To work the examples, you’ll need installed in addition to NumPy. This is a quick overview of arrays in NumPy. It demonstrates how n-dimensional (\\(n>=2\\)) arrays are represented and can be manipulated. In particular, if you don’t know how to apply common functions to n-dimensional arrays (without using for-loops), or if you want to understand axis and shape properties for n-dimensional arrays, this article might be of help. After reading, you should be able to:\n• None Understand the difference between one-, two- and n-dimensional arrays in NumPy;\n• None Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;\n\nNumPy’s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called axes. For example, the array for the coordinates of a point in 3D space, , has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3. NumPy’s array class is called . It is also known by the alias . Note that is not the same as the Standard Python Library class , which only handles one-dimensional arrays and offers less functionality. The more important attributes of an object are: the number of axes (dimensions) of the array. the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m columns, will be . The length of the tuple is therefore the number of axes, . the total number of elements of the array. This is equal to the product of the elements of . an object describing the type of the elements in the array. One can create or specify dtype’s using standard Python types. Additionally NumPy provides types of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples. the size in bytes of each element of the array. For example, an array of elements of type has 8 (=64/8), while one of type has 4 (=32/8). It is equivalent to . the buffer containing the actual elements of the array. Normally, we won’t need to use this attribute because we will access the elements in an array using indexing facilities. There are several ways to create arrays. For example, you can create an array from a regular Python list or tuple using the function. The type of the resulting array is deduced from the type of the elements in the sequences. A frequent error consists in calling with multiple arguments, rather than providing a single sequence as an argument. : array() takes from 1 to 2 positional arguments but 4 were given transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on. The type of the array can also be explicitly specified at creation time: Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation. The function creates an array full of zeros, the function creates an array full of ones, and the function creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is , but it can be specified via the key word argument . To create sequences of numbers, NumPy provides the function which is analogous to the Python built-in , but returns an array. When is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function that receives as an argument the number of elements that we want, instead of the step: # useful to evaluate function at lots of points When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:\n• None the last axis is printed from left to right,\n• None the second-to-last is printed from top to bottom,\n• None the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. See below to get more details on . If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: To disable this behaviour and force NumPy to print the entire array, you can change the printing options using . Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. Unlike in many matrix languages, the product operator operates elementwise in NumPy arrays. The matrix product can be performed using the operator (in python >=3.5) or the function or method: Some operations, such as and , act in place to modify an existing array rather than create a new one. # b is not automatically converted to integer type : Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting). Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the class. By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the parameter you can apply an operation along the specified axis of an array: NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called “universal functions” ( ). Within NumPy, these functions operate elementwise on an array, producing an array as output. One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences. # from start to position 6, exclusive, set every 2nd element to 1000 Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas: # each row in the second column of b # equivalent to the previous example # each column in the second and third row of b When fewer indices are provided than the number of axes, the missing indices are considered complete slices # the last row. Equivalent to b[-1, :] The expression within brackets in is treated as an followed by as many instances of as needed to represent the remaining axes. NumPy also allows you to write this using dots as . The dots ( ) represent as many colons as needed to produce a complete indexing tuple. For example, if is an array with 5 axes, then # same as c[1, :, :] or c[1] Iterating over multidimensional arrays is done with respect to the first axis: However, if one wants to perform an operation on each element in the array, one can use the attribute which is an iterator over all the elements of the array:\n\nChanging the shape of an array# An array has a shape given by the number of elements along each axis: The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array: The order of the elements in the array resulting from is normally “C-style”, that is, the rightmost index “changes the fastest”, so the element after is . If the array is reshaped to some other shape, again the array is treated as “C-style”. NumPy normally creates arrays stored in this order, so will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions and can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest. The function returns its argument with a modified shape, whereas the method modifies the array itself: If a dimension is given as in a reshaping operation, the other dimensions are automatically calculated: Several arrays can be stacked together along different axes: The function stacks 1D arrays as columns into a 2D array. It is equivalent to only for 2D arrays: # the result is different In general, for arrays with more than two dimensions, stacks along their second axes, stacks along their first axes, and allows for an optional arguments giving the number of the axis along which the concatenation should happen. In complex cases, and are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals . When used with arrays as arguments, and are similar to and in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate. Splitting one array into several smaller ones# Using , you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur: # Split `a` after the third and the fourth column splits along the vertical axis, and allows one to specify along which axis to split.\n\nWhen operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases: No copy at all# Simple assignments make no copy of objects or their data. # no new object is created # a and b are two names for the same ndarray object Python passes mutable objects as references, so function calls make no copy. # id is a unique identifier of an object Different array objects can share the same data. The method creates a new array object that looks at the same data. # c is a view of the data owned by a # a's shape doesn't change, reassigned c is still a view of a Slicing an array returns a view of it: # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10 The method makes a complete copy of the array and its data. # a new array object with new data is created Sometimes should be called after slicing if the original array is not required anymore. For example, suppose is a huge intermediate result and the final result only contains a small fraction of , a deep copy should be made when constructing with slicing: # the memory of ``a`` can be released. If is used instead, is referenced by and will persist in memory even if is executed. See also Copies and views. Here is a list of some useful NumPy functions and methods names ordered in categories. See Routines and objects by topic for the full list.\n\nNumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans. # the elements of `a` at the positions `i` When the indexed array is multidimensional, a single array of indices refers to the first dimension of . The following example shows this behavior by converting an image of labels into a color image using a palette. # each value corresponds to a color in the palette We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape. # indices for the first dim of `a` # indices for the second dim # i and j must have equal shape In Python, is exactly the same as —so we can put and in a and then do the indexing with that. However, we can not do this by putting and into an array, because this array will be interpreted as indexing the first dimension of . File , line , in : index 3 is out of bounds for axis 0 with size 3 Another common use of indexing with arrays is the search of the maximum value of time-dependent series: # index of the maxima for each series # times corresponding to the maxima You can also use indexing with arrays as a target to assign to: However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value: This is reasonable enough, but watch out if you want to use Python’s construct, as it may not do what you expect: Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires to be equivalent to . When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don’t. The most natural way one can think of for boolean indexing is to use boolean arrays that have the same shape as the original array: # `b` is a boolean with `a`'s shape This property can be very useful in assignments: # All elements of `a` higher than 4 become 0 You can look at the following example to see how to use boolean indexing to generate an image of the Mandelbrot set: \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\" The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want: Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, has length 3 (the number of rows in ), and (of length 4) is suitable to index the 2nd axis (columns) of . The function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c: You could also implement the reduce as follows: The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the broadcasting rules in order to avoid creating an argument array the size of the output times the number of vectors."
    },
    {
        "link": "https://numpy.org/doc/2.1/numpy-user.pdf",
        "document": ""
    },
    {
        "link": "https://programiz.com/python-programming/numpy/statistical-functions",
        "document": "Statistics involves gathering data, analyzing it, and drawing conclusions based on the information collected.\n\nNumPy provides us with various statistical functions that can perform statistical data analysis.\n\nHere are some of the statistical functions provided by NumPy:\n\nNext, we will see examples using these functions.\n\nThe median value of a numpy array is the middle value in a sorted array.\n\nIn other words, it is the value that separates the higher half from the lower half of the data.\n\nSuppose we have the following list of numbers:\n\nThen, median is simply the middle number, which in this case is 8.\n\nIt is important to note that if the number of elements is\n• Odd, the median is the middle element.\n• Even, the median is the average of the two middle elements.\n\nNow, we will learn how to calculate the median using NumPy for arrays with odd and even number of elements.\n\nExample 1: Compute Median for Odd Number of Elements\n\nIn the above example, the array named contains an odd number of elements (5 elements).\n\nSo, returns the median of as 3, which is the middle value of the sorted array.\n\nExample 2: Compute Median for Even Number of Elements\n\nHere, since the array has an even number of elements (6 elements), the median is calculated as the average of the two middle elements (3 and 4) i.e. 3.5.\n\nCalculation of the median is not just limited to 1D array. We can also calculate the median of the 2D array.\n\nIn a 2D array, median can be calculated either along the horizontal or the vertical axis individually, or across the entire array.\n\nWhen computing the median of a 2D array, we use the parameter inside to specify the axis along which to compute the median.\n\nIf we specify,\n\nIf we don't use the parameter, the median is computed over the entire array.\n\nExample: Compute the median of a 2D array\n\nIn this example, we have created a 2D array named .\n\nWe then computed the median along the horizontal and vertical axis individually and then computed the median of the entire array.\n• - median along horizontal axis, which gives\n• - median along vertical axis, which gives\n• - median over the entire array, which gives\n\nTo calculate the median over the entire 2D array, first we flatten the array to and then find the middle value of the flattened array which in our case is 10.\n\nThe mean value of a NumPy array is the average value of all the elements in the array.\n\nIt is calculated by adding all elements in the array and then dividing the result by the total number of elements in the array.\n\nWe use the function to calculate the mean value. For example,\n\nIn this example, the mean value is 77.2, which is calculated by adding the elements (76, 78, 81, 66, 85) and dividing the result by 5 (total number of array elements).\n\nExample 3: Mean of NumPy N-d Array\n\nHere, first we have created the 2D array named . We then calculated the mean using .\n• - calculates the mean over the entire array\n• - calculates the mean along vertical axis\n• calculates the mean along horizontal axis\n\nThe standard deviation is a measure of the spread of the data in the array. It gives us the degree to which the data points in an array deviate from the mean.\n• Smaller standard deviation indicates that the data points are closer to the mean\n• Larger standard deviation indicates that the data points are more spread out.\n\nIn NumPy, we use the function to calculate the standard deviation of an array.\n\nExample: Compute the Standard Deviation in NumPy\n\nIn the above example, we have used the function to calculate the standard deviation of the array.\n\nHere, is the standard deviation of . It tells us how much the values in the array deviate from the mean value of the array.\n\nIn a 2D array, standard deviation can be calculated either along the horizontal or the vertical axis individually, or across the entire array.\n\nSimilar to mean and median, when computing the standard deviation of a 2D array, we use the parameter inside to specify the axis along which to compute the standard deviation.\n\nExample: Compute the Standard Deviation of a 2D array.\n\nHere, we have created a 2D array named .\n\nWe then computed the standard deviation along horizontal and vertical axis individually and then computed the standard deviation of the entire array.\n\nIn NumPy, we use the function to compute the nth percentile of a given array.\n\nLet's see an example.\n• 25% of the values in are less than or equal to 5.5.\n• 75% of the values in are less than or equal to 14.5.\n\nNote: To learn more about percentile, visit NumPy Percentile.\n\nFind Minimum and Maximum Value of NumPy Array\n\nWe use the and function in NumPy to find the minimum and maximum values in a given array.\n\nLet's see an example.\n\nAs we can see and returns the minimum and maximum value of which is 1 and 65 respectively."
    },
    {
        "link": "https://numpy.org/doc/stable/reference/generated/numpy.unique.html",
        "document": "Find the unique elements of an array.\n\nReturns the sorted unique elements of an array. There are three optional outputs in addition to the unique elements:\n• None the indices of the input array that give the unique values\n• None the indices of the unique array that reconstruct the input array\n• None the number of times each unique value comes up in the input array\n\nInput array. Unless axis is specified, this will be flattened if it is not already 1-D. If True, also return the indices of ar (along the specified axis, if provided, or in the flattened array) that result in the unique array. If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct ar. If True, also return the number of times each unique item appears in ar. The axis to operate on. If None, ar will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the axis kwarg is used. The default is None. If True, collapses multiple NaN values in the return array into one. The indices of the first occurrences of the unique values in the original array. Only provided if return_index is True. The indices to reconstruct the original array from the unique array. Only provided if return_inverse is True. The number of times each of the unique values comes up in the original array. Only provided if return_counts is True.\n\nWhen an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.\n\nChanged in version 1.21: Like np.sort, NaN will sort to the end of the values. For complex arrays all NaN values are considered equivalent (no matter whether the NaN is in the real or imaginary part). As the representant for the returned array the smallest one in the lexicographical order is chosen - see np.sort for how the lexicographical order is defined for complex arrays.\n\nChanged in version 2.0: For multi-dimensional inputs, is reshaped such that the input can be reconstructed using . The result is now not 1-dimensional when . Note that in NumPy 2.0.0 a higher dimensional array was returned also when was not . This was reverted, but can be used to ensure compatibility with both versions.\n\nReturn the indices of the original array that give the unique values:\n\nReconstruct the input array from the unique values and inverse:\n\nReconstruct the input values from the unique values and counts:"
    },
    {
        "link": "https://matplotlib.org/3.4.3/gallery/statistics/hist.html",
        "document": "Click here to download the full example code\n\nDemonstrates how to plot histograms with matplotlib.\n\nTo plot a 2D histogram, one only needs two vectors of the same length, corresponding to each axis of the histogram."
    },
    {
        "link": "https://matplotlib.org/stable/gallery/statistics/hist.html",
        "document": "Go to the end to download the full example code.\n\nHow to plot histograms with Matplotlib.\n\nTo plot a 2D histogram, one only needs two vectors of the same length, corresponding to each axis of the histogram."
    },
    {
        "link": "https://stackoverflow.com/questions/5328556/histogram-matplotlib",
        "document": "I know this does not answer your question, but I always end up on this page, when I search for the matplotlib solution to histograms, because the simple was removed from the matplotlib example gallery page.\n\nHere is a solution, which doesn't require to be imported. I only import numpy to generate the data to be plotted. It relies on the function instead of the function as in the answer by @unutbu.\n\nAlso check out the matplotlib gallery and the matplotlib examples."
    },
    {
        "link": "https://geeksforgeeks.org/plotting-histogram-in-python-using-matplotlib",
        "document": "Histograms are a fundamental tool in data visualization, providing a graphical representation of the distribution of data. They are particularly useful for exploring continuous data, such as numerical measurements or sensor readings. This article will guide you through the process of Plot Histogram in Python using Matplotlib, covering the essential steps from data preparation to generating the histogram plot.\n\nA Histogram represents data provided in the form of some groups. It is an accurate method for the graphical representation of numerical data distribution. It is a type of bar plot where the X-axis represents the bin ranges while the Y-axis gives information about frequency.\n\nTo create a Matplotlib histogram the first step is to create a bin of the ranges, then distribute the whole range of the values into a series of intervals, and count the values that fall into each of the intervals. Bins are identified as consecutive, non-overlapping intervals of variables.The matplotlib.pyplot.hist() function is used to compute and create a histogram of x.\n\nThe following table shows the parameters accepted by matplotlib.pyplot.hist() function :\n\nHere we will see different methods of Plotting Histogram in Matplotlib in Python:\n\nLet’s create a basic histogram in Matplotlib using Python of some random values.\n\nLet’s create a customized histogram with a density plot using Matplotlib and Seaborn in Python. The resulting plot visualizes the distribution of random data with a smooth density estimate.\n\nCreate a customized histogram using Matplotlib in Python with specific features. It includes additional styling elements, such as removing axis ticks, adding padding, and setting a color gradient for better visualization.\n\nLet’s generates two histograms side by side using Matplotlib in Python, each with its own set of random data and provides a visual comparison of the distributions of and using histograms.\n\nLet’s generates a stacked histogram using Matplotlib in Python, representing two datasets with different random data distributions. The stacked histogram provides insights into the combined frequency distribution of the two datasets.\n\nLet’s generates a 2D hexbin plot using Matplotlib in Python, provides a visual representation of the 2D data distribution, where hexagons convey the density of data points. The colorbar helps interpret the density of points in different regions of the plot.\n\nPlotting Matplotlib histograms is a simple and straightforward process. By using the function, we can easily create histograms with different bin widths and bin edges. We can also customize the appearance of histograms to meet our needs"
    },
    {
        "link": "https://stackoverflow.com/questions/70416097/adding-data-labels-ontop-of-my-histogram-python-matplotlib",
        "document": "i am trying to add data labels values on top of my histogram to try to show the frequency visibly.\n\nThis is my code now but unsure how to code up to put the value ontop:\n\nI was wondering if anyone knows the code to do this:"
    }
]