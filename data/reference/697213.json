[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Component.GetComponentsInChildren.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nGets references to all components of type on the same GameObject as the component specified, and any child of the GameObject.\n\nThe typical usage for this method is to call it from a MonoBehaviour script (which itself is a type of component), to find references to other Components or MonoBehaviours attached to the same GameObject as that script, or its child GameObjects. In this case you can call the method with no preceding object specified. For example:\n\n\n\n \n\n\n\nYou can also call this method on a reference to different component, which might be attached to a different GameObject. In this case, the GameObject to which that component is attached, and its children, are searched. For example:\n\n\n\n \n\n\n\nThis method checks the GameObject on which it is called first, then recurses downwards through all child GameObjects using a depth-first search, until it finds a matching Component of the type specified.\n\n\n\nOnly active child GameObjects are included in the search, unless you call the method with the parameter set to , in which case inactive child GameObjects are also included. The GameObject on which the method is called is always searched regardless of this parameter.\n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject (or any component attached to that GameObject). You can then call on that reference.\n\n\n\nSee the Component and GameObject class reference pages for the other variations of the family of methods.\n\n\n\nThe following example gets a reference to all hinge joint components on the same GameObject as the script, or any of its children, and if found, sets a property on those components.\n\nNote: If the type you request is a derivative of MonoBehaviour and the associated script can't be loaded then this function will return `null` for that component.\n\nThis allows you to avoid allocating new List objects for each call to the method. The list you supply is resized to match the number of results found, and any existing values in the list are overritten.\n\nThis version of GetComponentsInChildren is not as efficient as the Generic version (above), so you should only use it if necessary."
    },
    {
        "link": "https://discussions.unity.com/t/finding-all-children-of-object/653529",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Component.GetComponentInChildren.html",
        "document": "The typical usage for this method is to call it from a MonoBehaviour script (which itself is a type of component), to find references to other Components or MonoBehaviours attached to the same GameObject as that script, or its child GameObjects. In this case you can call the method with no preceding object specified. For example:\n\n\n\n \n\n\n\nYou can also call this method on a reference to different component, which might be attached to a different GameObject. In this case, the GameObject to which that component is attached, and its children, are searched. For example:\n\n\n\n \n\n\n\nThis method checks the GameObject on which it is called first, then recurses downwards through all child GameObjects using a depth-first search, until it finds a matching Component of the type specified.\n\n\n\nOnly active child GameObjects are included in the search, unless you call the method with the parameter set to , in which case inactive child GameObjects are also included. The GameObject on which the method is called is always searched regardless of this parameter.\n\n\n\nNote: GetComponentInChildren returns only the first matching component found, and the order that the components are checked on any individual GameObject is not defined. Therefore, if there are more than one of the specified type that could match on any individual GameObject, and you need to find a specific one, you should use Component.GetComponentsInChildren and check the list of components returned to identify the one you want.\n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject (or any component attached to that GameObject). You can then call on that reference.\n\n\n\nSee the Component and GameObject class reference pages for the other variations of the family of methods.\n\n\n\nThe following example gets a reference to a hinge joint component on the same GameObject as the script, or any of its children, and if found, sets a property on that hinge joint component."
    },
    {
        "link": "https://discussions.unity.com/t/how-can-i-get-only-the-childrens-of-a-gameonbject-with-getcomponentsinchildren-method/76422",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/42375242/unity-getcomponentsinchildrent-return-order",
        "document": "As of Unity 2023 (later rebranded to Unity 6), the order is now well defined in the documentation for GetComponentsInChildren:\n\nThis method checks the GameObject on which it is called first, then recurses downwards through all child GameObjects using a depth-first search, until it finds a matching Component of the type T specified.\n\nThe is not correct though, as it returns all the components. It was likely copy-pasted from the similar GetComponentInChildren which only returns the first match. Despite this incorrection, it is still safe to say that the order described there still applies.\n\nThat means the result is ordered in the same way as you would see them in the hierarchy view from top to bottom."
    },
    {
        "link": "https://thorprojects.com/2020/08/13/object-hierarchy-and-scripts-in-unity",
        "document": "If you’re a traditional developer, Unity is more than a bit odd. The constructs, for the most part, make sense, but they require that you contort your thinking a bit. In this post, I’m going to walk through object hierarchy, scripting, and reuse.\n\nEverything in Unity is built up from the concept of a game object. A game object is a connection for components. Every game object will have either a Transform or a Rect Transform component associated with it. 3D objects have a Transform – which is a 3D transformation containing the location, rotation, and scale, along X, Y, and Z dimensions. 2D objects have Rect Transform components, which are designed to work with 2D objects even if they exist in a 3D space. Game objects with a Transform don’t fundamentally have a size. Their size is driven by the other components that are attached to the game object.\n\nGame objects can be organized in a hierarchy. This is useful when you want the objects to operate as a unit, as we’ll see as we build out the rotator script and demonstrate its use to create a cluster of directional lights. However, for performance reasons, deep nesting of game objects is discouraged. Largely, this is because some operations are recursive, and a large number of recursive operations can drop the frame rate of the solution unacceptably low. (Below about 60 frames per second.)\n\nIn the post Creating A Spinning Cube with Unity and MRTK, I created a single object – called Nexus – which had child objects of lights. To Nexus, we attached a rotation script and rotated Nexus. This caused all the lights associated with Nexus to rotate and move. We were able to set the context of the lights local to Nexus, and whatever Nexus did, the light objects would do as well.\n\nThis illustrates why we need to be careful with object hierarchy inside of Unity. When we do one operation, we’re impacting seven objects inside the hierarchy. The greater the depth of the hierarchy and the more objects, the more things need to be manipulated – or at least checked – for a single operation.\n\nIn Unity, scripts are C# code that is associated with a game object. Placing a script in the project does nothing until it’s connected to an instance of a game object. Game objects themselves can be almost anything – including nothing but a container with a Transform component, like the Nexus game object. When we added the script as a component of the game object, we connected the script and told Unity to instantiate the class and connect it to the game object that we added it to.\n\nIncluding public properties in the script allowed us to set those properties in the editor and ultimately have one script act on multiple objects in different ways. Unity automatically tooled our Camel case names and added spaces before the capital letters to make it more readable. It also provided an editor for the complex Vector3 object. This makes it easy to create scripts that are reusable across objects and for different purposes."
    },
    {
        "link": "https://medium.com/toca-boca-tech-blog/unitys-transformaccessarray-internals-and-best-practices-2923546e0b41",
        "document": "I recently adopted rendering code that makes heavy use of Unity jobs with from a colleague who’s changing teams. I already knew about and saw it used, but I’d never had the opportunity to fully understand how they work.\n\nIt’s a bit of an uphill battle because there’s not much material published about them and the documentation for the struct is very sparse. The most informative documentation pages I found as of writing are IJobParallelForTransform and the child pages of IJobParallelForTransformExtensions, but even these are somewhat slim.\n\nSo this situation turned into the perfect opportunity to explore some internals of Unity’s job system to better understand how and work, especially in combination with “regular” transform accesses on the main thread (i.e. outside of jobs). I found some very interesting results that I want to share in this post.\n\nWhat follows is an explanation of some of ‘s internals, a job test script, analysis of a few job usage patterns, and best practices derived from these observations. I also included a short Unity improvement wishlist to boost the performance of the job system.\n\nJobs in Unity’s job system can only use blittable data types, which means they don’t have access to managed types such as and . In terms of safety, this restriction allows the Unity engine to protect against data races where a worker would write data in memory while another worker or the main thread accesses the same memory location.\n\ninstances provide a way to get around this limitation to access transforms inside jobs, both for reading and writing. At its core, this functionality relies on Unity’s internal C++ class. At 13:14 of the Unite Berlin 2018 — Unity’s Evolving Best Practices talk, there’s a still very relevant discussion of this class. The following quote is very important to understand how works:\n\nFrom here on I’ll use the terms transform hierarchy and transform root somewhat interchangeably.\n\nIf we combine the above with this snippet from the IJobParallelForTransform.Schedule method documentation, we can already get an intuition that the two aspects are related:\n\nWhen you create a instance with an array of transforms, Unity internally reorders it for efficient access. The transforms are first grouped by their transform root. Then the transforms that share the same root are sorted together to optimize iteration speed based on how their shared transform hierarchy stores them internally.\n\nWhen Unity executes a job, the order in which it calls the Execute method with instances can therefore be very different from the original order in the ‘s transform array. That’s where the index argument comes in handy. It allows you to map a specific call to the Execute method to its corresponding transform element in the original transform array. If you noticed the internal method and wondered what it’s about, this is it.\n\nImportantly, doesn’t copy any transform data for reading or writing in jobs. There is no buffer or temporary storage unless you implement one yourself in some other way. This direct access is the main benefit of using them.\n\nBut it also means that there’s one more bit of theory to examine before we look at how everything comes together concretely.\n\nAs mentioned above, Unity’s job system is quite restrictive about what data you can access in jobs. In terms of a and the instances it implicitly provides access to, it means that Unity has some mechanisms to avoid problems with concurrent modifications to transforms and reading stale values. Its data synchronization method, known as fences internally, avoids potential race conditions from the main and worker threads accessing the same transforms concurrently.\n\nUnity’s granularity to protect access to transforms is the transform hierarchy. In other words, all the transforms that share the same transform root also share the same fence. When a job that uses a is scheduled, Unity delays all other accesses to any transform that shares a transform root with the job until it completes. This means any transform that has the same transform root as any transform in the . Let’s illustrate with an example.\n\nThe image above shows how two jobs that don’t access the same transforms still have a transform hierarchy in common. If Job A is scheduled before Job B, Job B doesn’t start until Job A completes. Job A needs to complete in its entirety, even if its remaining job batches use only different transform hierarchies. This blocking behavior affects the following scenarios:\n• Other jobs, even read-only ones.\n• Read or write access to a transform from the main thread, such as in a C# script.\n• Any other access to transforms, such as in animations and skinned mesh renderers.\n\nWhen jobs are blocked they simply remain in the job execution queue. When the main thread is blocked, such as when it calls the JobHandle.Complete method or attempts to access a transform that an unfinished job uses, it can become idle or resort to work stealing where possible. Work stealing means that the main thread picks up a job ready for execution and executes it. The reasoning behind this is that it’s better for the main thread to do something than stay idle, but it has important consequences discussed later in this article.\n\nI wrote the following test script to derive much of the information I presented above and to validate my understanding of in different synthetic job scenarios. No game would ever do this sequence of operations right after another exactly in this way, but it’s still a great way to simulate a wide range of real-world scenarios.\n\nusing System.Threading;\n\nusing Unity.Jobs;\n\nusing Unity.Profiling;\n\nusing UnityEngine;\n\nusing UnityEngine.Jobs;\n\n\n\npublic class TransformAccessArrayTest : MonoBehaviour\n\n{\n\n [SerializeField] [Range(1, 100)] private uint hierarchyRootsCount = 2;\n\n\n\n [Tooltip(\"Transform count in each transform hierarchy root\")]\n\n [SerializeField] [Range(1, 100)] private uint hierarchyDepth = 4;\n\n\n\n [Tooltip(\"How long to delay the start of the TransformJob\")]\n\n [SerializeField] private int delayJobStartMs;\n\n\n\n [Tooltip(\"Per-Transform job time\")]\n\n [SerializeField] private int jobRuntimeMs = 1;\n\n \n\n [SerializeField] [Range(-1, 100)] private int desiredJobCount = -1;\n\n [SerializeField] private bool scheduleAsReadOnlyJob;\n\n \n\n [Tooltip(\"Schedule a second read-only IJobParallelForTransform job\")]\n\n [SerializeField] private bool addParallelReadOnlyJob;\n\n\n\n [Tooltip(\"Applies to read-only jobs only\")]\n\n [Range(1, 100)] [SerializeField] private int readonlyJobBatchSize = 2;\n\n \n\n [SerializeField] private bool readTransformsAfterJob = true;\n\n [SerializeField] private bool writeTransformsAfterJob;\n\n\n\n GameObject[] generatedGameObjects;\n\n TransformAccessArray accessArray;\n\n\n\n static readonly ProfilerMarker markerBefore = new(\"BeforeJobScheduled\");\n\n static readonly ProfilerMarker markerReadAfter = new(\"ReadAfterJobScheduled\");\n\n static readonly ProfilerMarker markerWriteAfter = new(\"WriteAfterJobScheduled\");\n\n\n\n void OnValidate() => Cleanup();\n\n void OnDestroy() => Cleanup();\n\n\n\n void Cleanup()\n\n {\n\n if (generatedGameObjects != null)\n\n {\n\n for (int i = generatedGameObjects.Length - 1; i >= 0; i--)\n\n Destroy(generatedGameObjects[i]);\n\n\n\n generatedGameObjects = null;\n\n if (accessArray.isCreated)\n\n accessArray.Dispose();\n\n }\n\n }\n\n\n\n void Update()\n\n {\n\n // Support dynamically changing parameters in the Editor\n\n if (!accessArray.isCreated)\n\n CreateTransformArray();\n\n \n\n // Write to the transforms from the main thread\n\n using (markerBefore.Auto())\n\n {\n\n foreach (var go in generatedGameObjects)\n\n go.transform.position += new Vector3(0.000001f,0, 0);\n\n }\n\n\n\n var delayJobHandle = delayJobStartMs <= 0 ? default :\n\n new DelayJob() { DelayMs = delayJobStartMs }.Schedule();\n\n var transformJob = new TransformJob() { JobRuntimeMs = jobRuntimeMs };\n\n\n\n // Set the optional DelayJob as a job dependency of TransformJob\n\n if (scheduleAsReadOnlyJob)\n\n {\n\n transformJob.ScheduleReadOnly(accessArray, readonlyJobBatchSize, delayJobHandle);\n\n }\n\n else\n\n {\n\n transformJob.Schedule(accessArray, delayJobHandle);\n\n }\n\n\n\n // Schedule a second read-only job\n\n if (addParallelReadOnlyJob)\n\n {\n\n new ReadOnlyJob() { JobRuntimeMs = jobRuntimeMs }\n\n .ScheduleReadOnly(accessArray, readonlyJobBatchSize, delayJobHandle);\n\n }\n\n\n\n // Fake some work so the loops below can't be removed as no-ops\n\n var position = Vector3.zero;\n\n if (readTransformsAfterJob)\n\n {\n\n using var _ = markerReadAfter.Auto();\n\n foreach (var go in generatedGameObjects)\n\n position += go.transform.position;\n\n }\n\n \n\n if (writeTransformsAfterJob)\n\n {\n\n using var _ = markerWriteAfter.Auto();\n\n position = Vector3.Min(position * 0.0000001f, Vector3.one * 0.1f);\n\n foreach (var go in generatedGameObjects)\n\n go.transform.position = position;\n\n }\n\n }\n\n\n\n void CreateTransformArray()\n\n {\n\n generatedGameObjects = new GameObject[hierarchyRootsCount * hierarchyDepth];\n\n var transforms = new Transform[hierarchyRootsCount * hierarchyDepth];\n\n var transformsIndex = 0;\n\n for (int i = 0; i < hierarchyRootsCount; i++)\n\n {\n\n var parent = new GameObject($\"generated_{i}\");\n\n generatedGameObjects[transformsIndex] = parent;\n\n transforms[transformsIndex++] = parent.transform;\n\n \n\n // Not technically a depth, but it has the same impact\n\n // for Unity's job scheduling\n\n for (int j = 0; j < hierarchyDepth - 1; j++)\n\n {\n\n var child = new GameObject($\"{parent.name}_{j}\");\n\n child.transform.SetParent(parent.transform);\n\n generatedGameObjects[transformsIndex] = child;\n\n transforms[transformsIndex++] = child.transform;\n\n }\n\n }\n\n\n\n accessArray = new TransformAccessArray(transforms, desiredJobCount);\n\n }\n\n}\n\n\n\nstruct DelayJob : IJob\n\n{\n\n public int DelayMs;\n\n public void Execute() => Thread.Sleep(DelayMs);\n\n}\n\n \n\nstruct TransformJob : IJobParallelForTransform\n\n{\n\n public int JobRuntimeMs;\n\n public void Execute(int i, TransformAccess t) => Thread.Sleep(JobRuntimeMs);\n\n}\n\n \n\n// Use a second type to easily identify it in the profiler\n\nstruct ReadOnlyJob : IJobParallelForTransform\n\n{\n\n public int JobRuntimeMs;\n\n public void Execute(int i, TransformAccess t) => Thread.Sleep(JobRuntimeMs);\n\n}\n\nWhen it starts, the script generates a hierarchy of game objects based on the Hierarchy Roots Count and Hierarchy Depth properties.\n\nThe following sequence diagram shows what the Update method does and the yellow boxes illustrate the effect of some of the script’s properties.\n\nIf you enable the Add Parallel Read Only Job property, the script schedules a second job named ReadOnlyJob directly after step number two in the diagram. To keep the script simple, this job accesses the same as the TransformJob, but the results are the same if they use separate instances, as long as they access the same transform hierarchies.\n\nThe DelayJob job is an optional job dependency from the job(s). This allows us to simulate scenarios where the latter consumes output from another job, even though there isn’t any actual output in this test script.\n\nLet’s analyze a few scenarios with Unity configured to use 4 worker threads with the command line option.\n\nIn this scenario we use 2 transform roots with 4 transforms each. The test script schedules a DelayJob which is a dependency to both the TransformJob and ReadOnlyJob jobs."
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/bger99/unity_tip_28_hierarchy_organization",
        "document": "A subreddit for News, Help, Resources, and Conversation regarding Unity, the game engine. Do NOT use your phone to take screenshots. Video and photos of computer screens taken by phones are NOT allowed. All screenshots must be grabbed from the computer itself."
    },
    {
        "link": "https://discussions.unity.com/t/what-is-the-best-way-to-create-scripts-hierarchy/835043",
        "document": ""
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/34794/is-a-recursive-game-object-update-better-than-a-linear-one",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]