[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization",
        "document": "Serialization is the process of converting an object into a form that can be readily transported. For example, you can serialize an object and transport it over the Internet using HTTP between a client and a server. On the other end, deserialization reconstructs the object from the stream.\n\nXML serialization serializes only the public fields and property values of an object into an XML stream. XML serialization does not include type information. For example, if you have a Book object that exists in the Library namespace, there is no guarantee that it is deserialized into an object of the same type.\n\nThe central class in XML serialization is the XmlSerializer class, and the most important methods in this class are the Serialize and Deserialize methods. The XmlSerializer creates C# files and compiles them into .dll files to perform this serialization. The XML Serializer Generator Tool (Sgen.exe) is designed to generate these serialization assemblies in advance to be deployed with your application and improve startup performance. The XML stream generated by the XmlSerializer is compliant with the World Wide Web Consortium (W3C) XML Schema definition language (XSD) 1.0 recommendation. Furthermore, the data types generated are compliant with the document titled \"XML Schema Part 2: Datatypes.\"\n\nThe data in your objects is described using programming language constructs like classes, fields, properties, primitive types, arrays, and even embedded XML in the form of XmlElement or XmlAttribute objects. You have the option of creating your own classes, annotated with attributes, or using the XML Schema Definition tool to generate the classes based on an existing XML Schema.\n\nIf you have an XML Schema, you can run the XML Schema Definition tool to produce a set of classes that are strongly typed to the schema and annotated with attributes. When an instance of such a class is serialized, the generated XML adheres to the XML Schema. Provided with such a class, you can program against an easily manipulated object model while being assured that the generated XML conforms to the XML schema. This is an alternative to using other classes in .NET, such as the XmlReader and XmlWriter classes, to parse and write an XML stream. For more information, see XML Documents and Data. These classes allow you to parse any XML stream. In contrast, use the XmlSerializer when the XML stream is expected to conform to a known XML Schema.\n\nAttributes control the XML stream generated by the XmlSerializer class, allowing you to set the XML namespace, element name, attribute name, and so on, of the XML stream. For more information about these attributes and how they control XML serialization, see Controlling XML Serialization Using Attributes. For a table of those attributes that are used to control the generated XML, see Attributes That Control XML Serialization.\n\nThe XmlSerializer class can further serialize an object and generate an encoded SOAP XML stream. The generated XML adheres to section 5 of the World Wide Web Consortium document titled \"Simple Object Access Protocol (SOAP) 1.1.\" For more information about this process, see How to: Serialize an Object as a SOAP-Encoded XML Stream. For a table of the attributes that control the generated XML, see Attributes That Control Encoded SOAP Serialization.\n\nThe XmlSerializer class generates the SOAP messages created by, and passed to, XML Web services. To control the SOAP messages, you can apply attributes to the classes, return values, parameters, and fields found in an XML Web service file (.asmx). You can use both the attributes listed in \"Attributes That Control XML Serialization\" and \"Attributes That Control Encoded SOAP Serialization\" because an XML Web service can use either the literal or encoded SOAP style. For more information about using attributes to control the XML generated by an XML Web service, see XML Serialization with XML Web Services. For more information about SOAP and XML Web services, see Customizing SOAP Message Formatting.\n\nWhen creating an application that uses the XmlSerializer, be aware of the following items and their implications:\n• None The XmlSerializer creates C# (.cs) files and compiles them into .dll files in the directory named by the TEMP environment variable; serialization occurs with those DLLs. These serialization assemblies can be generated in advance and signed by using the SGen.exe tool. This does not work on a server of Web services. In other words, it is only for client use and for manual serialization. The code and the DLLs are vulnerable to a malicious process at the time of creation and compilation. It might be possible for two or more users to share the TEMP directory. Sharing a TEMP directory is dangerous if the two accounts have different security privileges and the higher-privilege account runs an application using the XmlSerializer. In this case, one user can breach the computer's security by replacing either the .cs or .dll file that is compiled. To eliminate this concern, always be sure that each account on the computer has its own profile. By default, the TEMP environment variable points to a different directory for each account.\n• None If a malicious user sends a continuous stream of XML data to a Web server (a denial of service attack), then the XmlSerializer continues to process the data until the computer runs low on resources. This kind of attack is eliminated if you are using a computer running Internet Information Services (IIS), and your application is running within IIS. IIS features a gate that does not process streams longer than a set amount (the default is 4 KB). If you create an application that does not use IIS and deserializes with the XmlSerializer, you should implement a similar gate that prevents a denial of service attack.\n• None The XmlSerializer serializes data and runs any code using any type given to it. There are two ways in which a malicious object presents a threat. It could run malicious code or it could inject malicious code into the C# file created by the XmlSerializer. In the second case, there is a theoretical possibility that a malicious object may somehow inject code into the C# file created by the XmlSerializer. Although this issue has been examined thoroughly, and such an attack is considered unlikely, you should take the precaution of never serializing data with an unknown and untrusted type.\n• After the XmlSerializer has serialized data, it can be stored as an XML file or other data store. If your data store is available to other processes, or is visible on an intranet or the Internet, the data can be stolen and used maliciously. For example, if you create an application that serializes orders that include credit card numbers, the data is highly sensitive. To help prevent this, always protect the store for your data and take steps to keep it private.\n\nThe following code example shows a basic class with a public field.\n\nWhen an instance of this class is serialized, it might resemble the following.\n\nFor more examples of serialization, see Examples of XML Serialization.\n\nItems That Can Be Serialized\n\nThe following items can be serialized using the XmlSerializer class:\n• Only collections are serialized, not public properties.\n\nFor more information about serializing or deserializing objects, see How to: Serialize an Object and How to: Deserialize an Object.\n\nThe XmlSerializer class gives you complete and flexible control when you serialize an object as XML. If you are creating an XML Web service, you can apply attributes that control serialization to classes and members to ensure that the XML output conforms to a specific schema.\n\nFor example, XmlSerializer enables you to:\n• None Specify whether a field or property should be encoded as an attribute or an element.\n• None Specify an XML namespace to use.\n• None Specify the name of an element or attribute if a field or property name is inappropriate.\n\nAnother advantage of XML serialization is that you have no constraints on the applications you develop, as long as the XML stream that is generated conforms to a given schema. Imagine a schema that is used to describe books. It features a title, author, publisher, and ISBN number element. You can develop an application that processes the XML data in any way you want, for example, as a book order, or as an inventory of books. In either case, the only requirement is that the XML stream conforms to the specified XML Schema definition language (XSD) schema.\n\nThe following should be considered when using the XmlSerializer class:\n• None The Sgen.exe tool is expressly designed to generate serialization assemblies for optimum performance.\n• None The serialized data contains only the data itself and the structure of your classes. Type identity and assembly information are not included.\n• None Only public properties and fields can be serialized. Properties must have public accessors (get and set methods). If you must serialize non-public data, use the DataContractSerializer class rather than XML serialization.\n• None A class must have a parameterless constructor to be serialized by XmlSerializer.\n• None XmlSerializer can process classes that implement IEnumerable or ICollection differently if they meet certain requirements, as follows. A class that implements IEnumerable must implement a public Add method that takes a single parameter. The Add method's parameter must be consistent (polymorphic) with the type returned from the IEnumerator.Current property returned from the GetEnumerator method. A class that implements ICollection in addition to IEnumerable (such as CollectionBase) must have a public Item indexed property (an indexer in C#) that takes an integer and it must have a public Count property of type integer. The parameter passed to the Add method must be the same type as that returned from the Item property, or one of that type's bases. For classes that implement ICollection, values to be serialized are retrieved from the indexed Item property rather than by calling GetEnumerator. Also, public fields and properties are not serialized, with the exception of public fields that return another collection class (one that implements ICollection). For an example, see Examples of XML Serialization.\n\nThe W3C document titled XML Schema Part 2: Datatypes specifies the simple data types that are allowed in an XML Schema definition language (XSD) schema. For many of these (for example, int and decimal), there is a corresponding data type in .NET. However, some XML data types do not have a corresponding .NET data type, for example, the NMTOKEN data type. In such cases, if you use the XML Schema Definition tool (XML Schema Definition Tool (Xsd.exe)) to generate classes from a schema, an appropriate attribute is applied to a member of type string, and its DataType property is set to the XML data type name. For example, if a schema contains an element named \"MyToken\" with the XML data type NMTOKEN, the generated class might contain a member as shown in the following example.\n\nSimilarly, if you are creating a class that must conform to a specific XML Schema (XSD), you should apply the appropriate attribute and set its DataType property to the desired XML data type name.\n\nFor a complete list of type mappings, see the DataType property for any of the following attribute classes:\n• How to: Serialize an Object\n• How to: Deserialize an Object"
    },
    {
        "link": "https://stackoverflow.com/questions/3356976/how-to-serialize-deserialize-simple-classes-to-xml-and-back",
        "document": "Sometimes I want to emulate stored data of my classes without setting up a round trip to the database. For example, let's say I have the following classes:\n\nLet's say I build a object in memory and want to \"save\" it as an XML document. Is this possible via some kind of method? How about in the other direction: is there a built-in way to create a object from an XML document like ?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer.deserialize?view=net-9.0",
        "document": "Deserializes the XML document contained by the specified Stream. Deserializes the XML document contained by the specified TextReader. Deserializes the XML document contained by the specified XmlSerializationReader. Deserializes the XML document contained by the specified XmlReader. Deserializes the XML document contained by the specified XmlReader and encoding style. Deserializes an XML document contained by the specified XmlReader and allows the overriding of events that occur during deserialization. Deserializes the object using the data contained by the specified XmlReader.\n\nDeserializes the XML document contained by the specified Stream. The Stream that contains the XML document to deserialize. The following example deserializes an object using a Stream object. #using <System.Xml.dll> #using <System.dll> using namespace System; using namespace System::IO; using namespace System::Xml::Serialization; // This is the class that will be deserialized. public ref class OrderedItem { public: [XmlElement(Namespace=\"http://www.cpandl.com\")] String^ ItemName; [XmlElement(Namespace=\"http://www.cpandl.com\")] String^ Description; [XmlElement(Namespace=\"http://www.cohowinery.com\")] Decimal UnitPrice; [XmlElement(Namespace=\"http://www.cpandl.com\")] int Quantity; [XmlElement(Namespace=\"http://www.cohowinery.com\")] Decimal LineTotal; // A custom method used to calculate price per item. void Calculate() { LineTotal = UnitPrice * Quantity; } }; void DeserializeObject(String^ filename) { Console::WriteLine(\"Reading with Stream\"); // Create an instance of the XmlSerializer. XmlSerializer^ serializer = gcnew XmlSerializer(OrderedItem::typeid); // Declare an object variable of the type to be deserialized. OrderedItem^ i; // Reading the XML document requires a FileStream. Stream^ reader = gcnew FileStream(filename, FileMode::Open); try { // Call the Deserialize method to restore the object's state. i = dynamic_cast<OrderedItem^>(serializer->Deserialize(reader)); } finally { delete reader; } // Write out the properties of the object. Console::Write(\"{0}\\t{1}\\t{2}\\t{3}\\t{4}\", i->ItemName, i->Description, i->UnitPrice, i->Quantity, i->LineTotal); } int main() { // Read a purchase order. DeserializeObject( \"simple.xml\" ); } using System; using System.IO; using System.Xml.Serialization; // This is the class that will be deserialized. public class OrderedItem { [XmlElement(Namespace = \"http://www.cpandl.com\")] public string ItemName; [XmlElement(Namespace = \"http://www.cpandl.com\")] public string Description; [XmlElement(Namespace=\"http://www.cohowinery.com\")] public decimal UnitPrice; [XmlElement(Namespace = \"http://www.cpandl.com\")] public int Quantity; [XmlElement(Namespace=\"http://www.cohowinery.com\")] public decimal LineTotal; // A custom method used to calculate price per item. public void Calculate() { LineTotal = UnitPrice * Quantity; } } public class Test { public static void Main() { Test t = new Test(); // Read a purchase order. t.DeserializeObject(\"simple.xml\"); } private void DeserializeObject(string filename) { Console.WriteLine(\"Reading with Stream\"); // Create an instance of the XmlSerializer. XmlSerializer serializer = new XmlSerializer(typeof(OrderedItem)); // Declare an object variable of the type to be deserialized. OrderedItem i; using (Stream reader = new FileStream(filename, FileMode.Open)) { // Call the Deserialize method to restore the object's state. i = (OrderedItem)serializer.Deserialize(reader); } // Write out the properties of the object. Console.Write( i.ItemName + \"\\t\" + i.Description + \"\\t\" + i.UnitPrice + \"\\t\" + i.Quantity + \"\\t\" + i.LineTotal); } } Imports System.IO Imports System.Xml.Serialization ' This is the class that will be deserialized. Public Class OrderedItem <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public ItemName As String <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public Description As String <XmlElement(Namespace := \"http://www.cohowinery.com\")> _ Public UnitPrice As Decimal <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public Quantity As Integer <XmlElement(Namespace := \"http://www.cohowinery.com\")> _ Public LineTotal As Decimal 'A custom method used to calculate price per item. Public Sub Calculate() LineTotal = UnitPrice * Quantity End Sub End Class Public Class Test Public Shared Sub Main() Dim t As New Test() ' Read a purchase order. t.DeserializeObject(\"simple.xml\") End Sub Private Sub DeserializeObject(ByVal filename As String) Console.WriteLine(\"Reading with Stream\") ' Create an instance of the XmlSerializer. Dim serializer As New XmlSerializer(GetType(OrderedItem)) ' Declare an object variable of the type to be deserialized. Dim i As OrderedItem Using reader As New Filestream(filename, FileMode.Open) ' Call the Deserialize method to restore the object's state. i = CType(serializer.Deserialize(reader), OrderedItem) End Using ' Write out the properties of the object. Console.Write(i.ItemName & ControlChars.Tab & _ i.Description & ControlChars.Tab & _ i.UnitPrice & ControlChars.Tab & _ i.Quantity & ControlChars.Tab & _ i.LineTotal) End Sub End Class Deserialization is the process of reading an XML document and constructing an object that is strongly typed to the XML Schema (XSD) of the document. Before deserializing, an XmlSerializer must be constructed using the type of the object that is being deserialized. Use the parameter to specify an object that derives from the Stream class, which is designed to write to streams. Classes that derive from the Stream class include: The XmlSerializer cannot deserialize the following: arrays of ArrayList and arrays of List<T>.\n• How to: Specify an Alternate Element Name for an XML Stream\n\nDeserializes the XML document contained by the specified TextReader. The TextReader that contains the XML document to deserialize. An error occurred during deserialization. The original exception is available using the InnerException property. The following example deserializes an object using a TextReader object. #using <System.Xml.dll> #using <System.dll> using namespace System; using namespace System::IO; using namespace System::Text; using namespace System::Xml::Serialization; // This is the class that will be deserialized. public ref class OrderedItem { public: String^ ItemName; String^ Description; Decimal UnitPrice; int Quantity; Decimal LineTotal; // A custom method used to calculate price per item. void Calculate() { LineTotal = UnitPrice * Quantity; } }; void DeserializeObject( String^ filename ) { Console::WriteLine( \"Reading with TextReader\" ); // Create an instance of the XmlSerializer specifying type. XmlSerializer^ serializer = gcnew XmlSerializer( OrderedItem::typeid ); /* Create a TextReader to read the file. Specify an Encoding to use. */ TextReader^ reader = gcnew StreamReader( filename,Encoding::Unicode ); // Declare an object variable of the type to be deserialized. OrderedItem^ i; // Use the Deserialize method to restore the object's state. i = dynamic_cast<OrderedItem^>(serializer->Deserialize( reader )); // Write out the properties of the object. Console::Write( \"{0}\\t{1}\\t{2}\\t{3}\\t{4}\", i->ItemName, i->Description, i->UnitPrice, i->Quantity, i->LineTotal ); } int main() { // Read a purchase order. DeserializeObject( \"simple.xml\" ); } using System; using System.IO; using System.Text; using System.Xml.Serialization; // This is the class that will be deserialized. public class OrderedItem { [XmlElement(Namespace = \"http://www.cpandl.com\")] public string ItemName; [XmlElement(Namespace = \"http://www.cpandl.com\")] public string Description; [XmlElement(Namespace = \"http://www.cohowinery.com\")] public decimal UnitPrice; [XmlElement(Namespace = \"http://www.cpandl.com\")] public int Quantity; [XmlElement(Namespace = \"http://www.cohowinery.com\")] public decimal LineTotal; // A custom method used to calculate price per item. public void Calculate() { LineTotal = UnitPrice * Quantity; } } public class Test { public static void Main() { Test t = new Test(); // Read a purchase order. t.DeserializeObject(\"simple.xml\"); } private void DeserializeObject(string filename) { Console.WriteLine(\"Reading with TextReader\"); // Create an instance of the XmlSerializer specifying type. XmlSerializer serializer = new XmlSerializer(typeof(OrderedItem)); // Create a TextReader to read the file. FileStream fs = new FileStream(filename, FileMode.OpenOrCreate); TextReader reader = new StreamReader(fs); // Declare an object variable of the type to be deserialized. OrderedItem i; // Use the Deserialize method to restore the object's state. i = (OrderedItem) serializer.Deserialize(reader); // Write out the properties of the object. Console.Write( i.ItemName + \"\\t\" + i.Description + \"\\t\" + i.UnitPrice + \"\\t\" + i.Quantity + \"\\t\" + i.LineTotal); } } Imports System.IO Imports System.Text Imports System.Xml.Serialization ' This is the class that will be deserialized. Public Class OrderedItem <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public ItemName As String <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public Description As String <XmlElement(Namespace := \"http://www.cohowinery.com\")> _ Public UnitPrice As Decimal <XmlElement(Namespace := \"http://www.cpandl.com\")> _ Public Quantity As Integer <XmlElement(Namespace := \"http://www.cohowinery.com\")> _ Public LineTotal As Decimal ' A custom method used to calculate price per item. Public Sub Calculate() LineTotal = UnitPrice * Quantity End Sub End Class Public Class Test Public Shared Sub Main() Dim t As New Test() ' Read a purchase order. t.DeserializeObject(\"simple.xml\") End Sub Private Sub DeserializeObject(filename As String) Console.WriteLine(\"Reading with TextReader\") ' Create an instance of the XmlSerializer specifying type. Dim serializer As New XmlSerializer(GetType(OrderedItem)) ' Create a TextReader to read the file. Dim fs as New FileStream(filename, FileMode.OpenOrCreate) Dim reader As New StreamReader(fs) ' Declare an object variable of the type to be deserialized. Dim i As OrderedItem ' Use the Deserialize method to restore the object's state. i = CType(serializer.Deserialize(reader), OrderedItem) ' Write out the properties of the object. Console.Write(i.ItemName & ControlChars.Tab & _ i.Description & ControlChars.Tab & _ i.UnitPrice & ControlChars.Tab & _ i.Quantity & ControlChars.Tab & _ i.LineTotal) End Sub End Class Deserialization is the process of reading an instance of an XML document and constructing an object that is strongly typed to the XML Schema (XSD) of the document. Before deserializing, an XmlSerializer must be constructed using the type of the object that is being deserialized. Classes that inherit from TextReader include StringReader and StreamReader. If you are using a StreamReader to deserialize an object, you must construct the StreamReader with an appropriate Encoding. The encoding specified by the XML document is ignored. To use the encoding specified by the XML document, use the Deserialize overload that takes an XmlReader instead. The XmlReader automatically detects and uses the encoding specified by the XML document. The XmlSerializer cannot deserialize the following: arrays of ArrayList and arrays of List<T>.\n• How to: Specify an Alternate Element Name for an XML Stream\n\nDeserializes the XML document contained by the specified XmlReader. The XmlReader that contains the XML document to deserialize. An error occurred during deserialization. The original exception is available using the InnerException property. The following example deserializes an object using an XmlReader. #using <System.Xml.dll> #using <System.dll> using namespace System; using namespace System::IO; using namespace System::Text; using namespace System::Xml; using namespace System::Xml::Serialization; // This is the class that will be deserialized. public ref class OrderedItem { public: String^ ItemName; String^ Description; Decimal UnitPrice; int Quantity; Decimal LineTotal; // A custom method used to calculate price per item. void Calculate() { LineTotal = UnitPrice * Quantity; } }; void DeserializeObject( String^ filename ) { Console::WriteLine( \"Reading with XmlReader\" ); // Create an instance of the XmlSerializer specifying type and namespace. XmlSerializer^ serializer = gcnew XmlSerializer( OrderedItem::typeid ); // A FileStream is needed to read the XML document. FileStream^ fs = gcnew FileStream( filename,FileMode::Open ); XmlReader^ reader = gcnew XmlTextReader( fs ); // Declare an object variable of the type to be deserialized. OrderedItem^ i; // Use the Deserialize method to restore the object's state. i = dynamic_cast<OrderedItem^>(serializer->Deserialize( reader )); // Write out the properties of the object. Console::Write( \"{0}\\t{1}\\t{2}\\t{3}\\t{4}\", i->ItemName, i->Description, i->UnitPrice, i->Quantity, i->LineTotal ); } int main() { // Read a purchase order. DeserializeObject( \"simple.xml\" ); } using System; using System.IO; using System.Text; using System.Xml; using System.Xml.Serialization; // This is the class that will be deserialized. public class OrderedItem { public string ItemName; public string Description; public decimal UnitPrice; public int Quantity; public decimal LineTotal; // A custom method used to calculate price per item. public void Calculate() { LineTotal = UnitPrice * Quantity; } } public class Test { public static void Main(string[] args) { Test t = new Test(); // Read a purchase order. t.DeserializeObject(\"simple.xml\"); } private void DeserializeObject(string filename) { Console.WriteLine(\"Reading with XmlReader\"); // Create an instance of the XmlSerializer specifying type and namespace. XmlSerializer serializer = new XmlSerializer(typeof(OrderedItem)); // A FileStream is needed to read the XML document. FileStream fs = new FileStream(filename, FileMode.Open); XmlReader reader = XmlReader.Create(fs); // Declare an object variable of the type to be deserialized. OrderedItem i; // Use the Deserialize method to restore the object's state. i = (OrderedItem)serializer.Deserialize(reader); fs.Close(); // Write out the properties of the object. Console.Write( i.ItemName + \"\\t\" + i.Description + \"\\t\" + i.UnitPrice + \"\\t\" + i.Quantity + \"\\t\" + i.LineTotal); } } Imports System.IO Imports System.Text Imports System.Xml Imports System.Xml.Serialization ' This is the class that will be deserialized. Public Class OrderedItem Public ItemName As String Public Description As String Public UnitPrice As Decimal Public Quantity As Integer Public LineTotal As Decimal ' A custom method used to calculate price per item. Public Sub Calculate() LineTotal = UnitPrice * Quantity End Sub End Class Public Class Test Public Shared Sub Main() Dim t As New Test() ' Read a purchase order. t.DeserializeObject(\"simple.xml\") End Sub Private Sub DeserializeObject(ByVal filename As String) Console.WriteLine(\"Reading with XmlReader\") ' Create an instance of the XmlSerializer specifying type and namespace. Dim serializer As New XmlSerializer(GetType(OrderedItem)) ' A FileStream is needed to read the XML document. Dim fs As New FileStream(filename, FileMode.Open) Dim reader As XmlReader = XmlReader.Create(fs) ' Declare an object variable of the type to be deserialized. Dim i As OrderedItem ' Use the Deserialize method to restore the object's state. i = CType(serializer.Deserialize(reader), OrderedItem) fs.Close() ' Write out the properties of the object. Console.Write(i.ItemName & ControlChars.Tab & _ i.Description & ControlChars.Tab & _ i.UnitPrice & ControlChars.Tab & _ i.Quantity & ControlChars.Tab & _ i.LineTotal) End Sub End Class Deserialization is the process of reading an instance of an XML document and constructing an object that is strongly typed to the XML Schema (XSD) of the document. Before deserializing, an XmlSerializer must be constructed using the type of the object that is being deserialized. The XmlReader automatically detects and uses the encoding specified by the XML document. The XmlSerializer cannot deserialize the following: arrays of ArrayList and arrays of List<T>.\n• How to: Specify an Alternate Element Name for an XML Stream"
    },
    {
        "link": "https://stackoverflow.com/questions/364253/how-to-deserialize-xml-document",
        "document": "that don't seem to work :-(\n\nHow do I Deserialize this XML document:\n\nHow about you just save the xml to a file, and use xsd to generate C# classes?\n• Write the file to disk (I named it foo.xml) Et voila - and C# code file that should be able to read the data via :\n\nHere's a working version. I changed the labels to because in the xml the StockNumber, Make and Model values are elements, not attributes. Also I removed the (that function reads the whole stream and returns a string, so the function couldn't use the reader anymore...the position was at the end of the stream). I also took a few liberties with the naming :). [Serializable()] public class Car { [System.Xml.Serialization.XmlElement(\"StockNumber\")] public string StockNumber { get; set; } [System.Xml.Serialization.XmlElement(\"Make\")] public string Make { get; set; } [System.Xml.Serialization.XmlElement(\"Model\")] public string Model { get; set; } } [Serializable()] [System.Xml.Serialization.XmlRoot(\"CarCollection\")] public class CarCollection { [XmlArray(\"Cars\")] [XmlArrayItem(\"Car\", typeof(Car))] public Car[] Car { get; set; } } And the slightly tweaked xml (I needed to add a new element to wrap <Cars>...Net is picky about deserializing arrays):\n\nYou have two possibilities. Suppose that you have your XML file in this location\n• Open Developer Command Prompt\n\n You can find it in Or if you have Windows 8 can just start typing Developer Command Prompt in Start screen\n• Change location to your XML file directory by typing\n• Create XSD file from your xml file by typing Suppose that you have your XML file in this location And that's it! You have generated C# classes from xml file in Required Visual Studio 2012+\n• Copy content of your XML file to clipboard\n• Add to your solution new, empty class file ( + + )\n• Open that file and in menu click \n\n Usage is very simple with this helper class: using System; using System.IO; using System.Web.Script.Serialization; // Add reference: System.Web.Extensions using System.Xml; using System.Xml.Serialization; namespace Helpers { internal static class ParseHelpers { private static JavaScriptSerializer json; private static JavaScriptSerializer JSON { get { return json ?? (json = new JavaScriptSerializer()); } } public static Stream ToStream(this string @this) { var stream = new MemoryStream(); var writer = new StreamWriter(stream); writer.Write(@this); writer.Flush(); stream.Position = 0; return stream; } public static T ParseXML<T>(this string @this) where T : class { var reader = XmlReader.Create(@this.Trim().ToStream(), new XmlReaderSettings() { ConformanceLevel = ConformanceLevel.Document }); return new XmlSerializer(typeof(T)).Deserialize(reader) as T; } public static T ParseJSON<T>(this string @this) where T : class { return JSON.Deserialize<T>(@this.Trim()); } } } All you have to do now, is:\n\nI don't think .net is 'picky about deserializing arrays'. The first xml document is not well formed. There is no root element, although it looks like there is. The canonical xml document has a root and at least 1 element (if at all). In your example: <Root> <-- well, the root <Cars> <-- an element (not a root), it being an array <Car> <-- an element, it being an array item ... </Car> </Cars> </Root>\n\nI found the answers here to be very helpful, that said I still struggled (just a bit) to get this working. So, in case it helps someone I'll spell out the working solution: XML from Original Question. The xml is in a file Class1.xml, a to this file is used in the code to locate this xml file. I used the answer by @erymski to get this working, so created a file called Car.cs and added the following: using System.Xml.Serialization; // Added public class Car { public string StockNumber { get; set; } public string Make { get; set; } public string Model { get; set; } } [XmlRootAttribute(\"Cars\")] public class CarCollection { [XmlElement(\"Car\")] public Car[] Cars { get; set; } } The other bit of code provided by @erymski ... using (TextReader reader = new StreamReader(path)) { XmlSerializer serializer = new XmlSerializer(typeof(CarCollection)); return (CarCollection) serializer.Deserialize(reader); } ... goes into your main program (Program.cs), in like this: using System; using System.IO; using System.Xml.Serialization; namespace ConsoleApp2 { class Program { public static void Main() { var c = new CarCollection(); c = XCar(); foreach (var k in c.Cars) { Console.WriteLine(k.Make + \" \" + k.Model + \" \" + k.StockNumber); } c = null; Console.ReadLine(); } static CarCollection XCar() { using (TextReader reader = new StreamReader(@\"C:\\Users\\SlowLearner\\source\\repos\\ConsoleApp2\\ConsoleApp2\\Class1.xml\")) { XmlSerializer serializer = new XmlSerializer(typeof(CarCollection)); return (CarCollection)serializer.Deserialize(reader); } } } }\n\nKevin's anser is good, aside from the fact, that in the real world, you are often not able to alter the original XML to suit your needs. There's a simple solution for the original XML, too: [XmlRoot(\"Cars\")] public class XmlData { [XmlElement(\"Car\")] public List<Car> Cars{ get; set; } } public class Car { public string StockNumber { get; set; } public string Make { get; set; } public string Model { get; set; } } And then you can simply call:\n\nThe idea is to have all level being handled for deserialization Please see a sample solution that solved my similar issue The above XML is handled in two level public class BankQueryResponse { [XmlElement(\"TRANSACTION_ID\")] public string TransactionId { get; set; } [XmlElement(\"MERCHANT_ACC_NO\")] public string MerchantAccNo { get; set; } [XmlElement(\"TXN_SIGNATURE\")] public string TxnSignature { get; set; } [XmlElement(\"TRAN_DATE\")] public DateTime TranDate { get; set; } [XmlElement(\"TXN_STATUS\")] public string TxnStatus { get; set; } [XmlElement(\"REFUND_DATE\")] public DateTime RefundDate { get; set; } [XmlElement(\"RESPONSE_CODE\")] public string ResponseCode { get; set; } [XmlElement(\"RESPONSE_DESC\")] public string ResponseDesc { get; set; } [XmlAttribute(\"MERCHANT_TRANID\")] public string MerchantTranId { get; set; } } Same Way you need multiple level with Check this example for multilevel deserialization"
    },
    {
        "link": "https://code-maze.com/csharp-xml-deserialization",
        "document": "In the world of C#, XML deserialization is a powerful technique that allows developers to convert XML data into strongly typed objects seamlessly. That said, in this article, we will learn more about XML deserialization in C#. We will cover essential concepts, hence, we are going to highlight the associated benefits and best practices.\n\nAt its core, XML deserialization involves converting XML data into a representation that an application can easily consume. In C#, the .NET Framework provides powerful tools and libraries to facilitate XML deserialization.\n\nBy mapping the XML structure to the properties of a class/record, developers can effortlessly transform XML data into manipulable and programmatically processable objects.\n\nKey Concepts of XML Deserialization in C#\n\nXML deserialization in C# involves converting XML data into strongly typed objects, allowing developers to work with the data more effectively.\n\nC# provides a set of attributes that allow developers to control the serialization and deserialization process. These attributes include , , , and , among others.\n\nBy using these attributes to decorate classes and properties, we can influence the conversion of XML data into objects.\n\nSo, let’s start our example by creating an XML file, person.xml, that requires deserialization:\n\nTo deserialize this XML file, we need to create a new class:\n\nWe define a class with two properties: and . We also use the attribute to specify that the XML element representing an instance of the type is named “Person”.\n\nThe attribute map the and properties to the corresponding XML elements within the “Person” element.\n\nNow, let’s convert this XML to the class object:\n\nHere, we create an instance of the class, specifying the type of the object we want to deserialize – . We then use a to read the XML data from a file.\n\nThe method converts the XML data into an object, and then we cast it to a object, which we can use to access the deserialized values.\n\nNow, let’s delve into more complex situations where XML elements can have nested sub-tags. Let’s create a library.xml file:\n\nThis XML contains multiple elements, each with multiple sub-elements. Therefore, to handle these several elements and their corresponding sub-elements, creating a class capable of accommodating them is crucial:\n\nWe have a class as a collection of books. The attribute specifies the name of the XML element containing the list of books. The attribute specifies that each item within the “Books” element should have a representation as an XML element named “Book”.\n\nThe class defines properties for each book, such as and , and establishes the mapping to the corresponding XML elements.\n\nLet’s check how we can deserialize a complex XML structure:\n\nIn the method, we instantiate with the argument to specify the target type for deserialization. We then deserialize the XML data using the method, which takes a to read the XML string.\n\nThen, we assign the deserialized object to the variable. After that, we use a loop to iterate through each object in the Books list of the object. The and of each book are displayed using .\n\nXML deserialization in C# can encounter errors and exceptions during the process. Handling these errors gracefully and implementing robust exception management is crucial for maintaining the stability and reliability of the application.\n\nHere are some essential considerations for error handling and exception management in XML deserialization.\n\nThe is a common exception that may occur during XML deserialization. It typically indicates that the XML data does not conform to the expected format or structure defined by the target object or its attributes.\n\nThe is another frequently encountered exception in XML deserialization. It occurs when the XML data is invalid, contains syntax errors, or the system fails to parse it correctly.\n\nThe may occur during XML deserialization if the serializer encounters an unsupported XML construct or attribute. This exception occurs when the deserialization process or the chosen XML serializer does not support a specific XML feature or construct.\n\nTo illustrate this point, consider how we can handle these exceptions using a block:\n\nWe offer different ways to handle various types of exceptions, including , , and .\n\nIn C#, records provide a concise way to define immutable data structures. XML deserialization combined with C# records simplifies the process of deserializing XML data into records, providing benefits such as immutability, built-in equality comparison, and improved code readability.\n\nLet’s have a look at the example.\n\nHere, we define a record with properties for the person’s and . The record provides an immutable representation of a person. We should pay attention that this record has a constructor, which is a pretty important part because, without it, the deserialization process will result in an exception.\n\nThen, we can modify the class to deserialize some XML data into our record:\n\nIn the method, we pass the XML data representing a person to the method, which returns a record. The person’s and are then displayed using .\n\nNow let’s check how can we work with complex XML Deserialization with records:\n\nLet’s create a new record for and :\n\nWithout a constructor, we might end up with instances of the record that are in an invalid state, causing unexpected errors or exceptions when accessing or using the object. Therefore, defining a constructor is crucial for maintaining the integrity and consistency of the object’s data and behavior.\n\nLet’s check, how we can deserialize XML with these records in our class:\n\nWe use the method, which takes an XML string and utilizes the class to deserialize it into the specified record type.\n\nIn our method, we pass the XML data representing a library with books to the method, which returns a record. Then, we iterate over the property of the record and display the book and using .\n\nBest Practices For XML Deserialization in C#\n\nLet’s look at a few best practices we should use while working with XML deserialization.\n\nTo accurately represent the XML structure, we should create classes that utilize properties for mapping XML elements or attributes. It helps us to establish a simple mapping between the XML data and the corresponding class properties.\n\nAlso, we should choose appropriate data types for the properties based on the corresponding XML data. It is essential to match the data types to ensure accurate and reliable deserialization.\n\nAdditionally, we have to apply XML serialization attributes, such as , , , , and , to customize the deserialization process, as we did in our previous examples. These attributes enable the definition of specific behaviors and mappings for the deserialization process, granting greater control and flexibility.\n\nBefore performing deserialization, it is essential to validate the XML data to ensure that it conforms to the expected format and constraints. We can achieve this by utilizing XML schema validation or implementing custom validation logic. XML schema validation checks the integrity and validity of the XML data against a predefined XML schema.\n\nCustom validation logic enables the application of specific and customized validation rules. Validating the XML data before deserialization helps us to detect and handle potential issues or inconsistencies, ensuring a smooth and reliable deserialization process:\n\nIn this snippet, we provide XML data validation using an XML schema (XSD) file. We configure the to enable schema validation by associating it with the XML reader and providing the necessary schema file.\n\nBy validating the XML data before deserialization, we can identify and address any inconsistencies or violations in the XML data.\n\nTo optimize XML deserialization performance, especially for large XML documents, there are specific techniques that we can employ. One such technique is buffering, which involves reading and processing XML data in chunks, reducing the memory footprint and improving efficiency. Additionally, asynchronous processing allows for parallel execution of deserialization tasks, leveraging the capabilities of multi-threading or asynchronous programming models.\n\nAnother technique is stream-based deserialization, where XML data is read and processed incrementally from a stream, neglecting the need to load the entire XML document into memory at once:\n\nIn this snippet, we utilize a to read the XML data as part of the deserialization process. This approach allows us to improve performance for large XML documents by leveraging stream-based deserialization, which avoids loading the entire XML into memory at a time.\n\nWhen working with XML deserialization, it is essential to address potential security risks that may arise, such as XML External Entity (XXE) attacks. These can include techniques such as disabling external entity resolution, implementing input validation and sanitization routines, and adopting strong coding practices.\n\nBy incorporating these security measures into our XML deserialization process, we can help safeguard our application against potential security threats and ensure the integrity and safety of our data:\n\nHere, we configure the to prohibit the processing of Document Type Definitions (DTD) and nullify the . By doing so, the application mitigates the risk of XML External Entity (XXE) attacks, where malicious entities attempt to exploit vulnerabilities in XML parsing.\n\nXML Deserialization provides many benefits like Simplified Data Integration, strongly typed Objects, and Increased Productivity.\n\nXML deserialization simplifies the integration of XML data into C# applications. Instead of manually parsing XML and extracting values, developers can utilize deserialization to obtain a structured data representation, saving time and effort.\n\nThe process of XML deserialization in C# enables the creation of strongly typed objects, ensuring type safety and reducing the likelihood of runtime errors. This capability empowers developers to fully utilize the features of the C# language, including IntelliSense and compile-time error checking.\n\nXML deserialization boosts productivity by automating the conversion of XML data into objects. Developers can then focus on implementing business logic and handling data instead of dealing with low-level XML parsing and traversal.\n\nXML deserialization empowers developers to convert XML data into strongly typed objects in C#. By leveraging the tools and libraries provided by the .NET Framework, developers can harness the benefits of XML deserialization, including simplified data integration, type safety, and increased productivity."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/examples-of-xml-serialization",
        "document": "XML serialization can take more than one form, from simple to complex. For example, you can serialize a class that simply consists of public fields and properties, as shown in Introducing XML Serialization. The following code examples address various advanced scenarios, including how to use XML serialization to generate an XML stream that conforms to a specific XML Schema (XSD) document.\n\nBesides serializing an instance of a public class, you can also serialize an instance of a DataSet, as shown in the following code example:\n\nYou can also serialize instances of an XmlElement or XmlNode class, as shown in the following code example:\n\nIf a property or field returns a complex object (such as an array or a class instance), the XmlSerializer converts it to an element nested within the main XML document. For example, the first class in the following code example returns an instance of the second class:\n\nThe serialized XML output might look like this:\n\nYou can also serialize a field that returns an array of objects, as shown in the following code example:\n\nIf two items are ordered, the serialized class instance might look like the following code:\n\nYou can create your own collection classes by implementing the ICollection interface and using the XmlSerializer to serialize instances of these classes.\n\nYou can cut and paste the following example code into a text file and rename it with a .cs or .vb file name extension. Use the C# or Visual Basic compiler to compile the file. Then run it using the name of the executable.\n\nThis example uses a simple scenario to demonstrate how an instance of an object is created and serialized into a file stream using the Serialize method. The XML stream is saved to a file. The same file is then read and reconstructed into a copy of the original object using the Deserialize method.\n\nIn this example, a class named is serialized and then deserialized. A second class named is also included because the public field named must be set to an . Similarly, an class is included because an array of objects must be set to the field. Finally, a class named contains the code that serializes and deserializes the classes.\n\nThe method creates the , , and class objects and sets the public field values. The method also constructs an instance of the XmlSerializer class that's used to serialize and deserialize the .\n\nThe method is a little simpler. It just creates objects to deserialize and reads out their values. As with the method, you must first construct an XmlSerializer, passing the type of class to be deserialized to the constructor. Also, a FileStream is required to read the XML document. To deserialize the objects, call the Deserialize method with the FileStream as an argument. The deserialized object must be cast to an object variable of type . The code then reads the values of the deserialized .\n\nThe XML output might look like this:\n• How to: Serialize an object\n• How to: Deserialize an object"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/controlling-xml-serialization-using-attributes",
        "document": "Attributes can be used to control the XML serialization of an object or to create an alternate XML stream from the same set of classes. For more information about creating an alternate XML stream, see How to: Specify an Alternate Element Name for an XML Stream.\n\nBy default, an XML element name is determined by the class or member name. In a class named , a field named ISBN will produce an XML element tag , as shown in the following example:\n\nThe default behavior can be changed if you want to give the element a new name. The following code shows how an attribute enables this functionality by setting the ElementName property of an XmlElementAttribute:\n\nFor more information about attributes, see Attributes. For a list of attributes that control XML serialization, see Attributes That Control XML Serialization.\n\nThe XmlArrayAttribute and the XmlArrayItemAttribute attributes control the serialization of arrays. Using these attributes, you can control the element name, namespace, and XML Schema (XSD) data type as defined in the W3C document titled XML Schema Part 2: Datatypes. You can also specify the types that can be included in an array.\n\nThe XmlArrayAttribute will determine the properties of the enclosing XML element that results when an array is serialized. For example, by default, serializing the array below will result in an XML element named . The element will contain a series of elements named after the array type .\n\nA serialized instance might resemble the following code:\n\nBy applying a XmlArrayAttribute, you can change the name of the XML element, as follows:\n\nThe resulting XML might resemble the following code:\n\nThe XmlArrayItemAttribute, on the other hand, controls how the items contained in the array are serialized.\n\nThe resulting XML might resemble the following code:\n\nAnother use of the XmlArrayItemAttribute is to allow the serialization of derived classes. For example, another class named that derives from can be added to the previous example. If you don't apply the XmlArrayItemAttribute, the code will fail at run time because the derived class type won't be recognized. To remedy this outcome, apply the attribute twice, each time setting the Type property for each acceptable type (base and derived).\n\nA serialized instance might resemble the following code:\n\nSerializing an Array as a Sequence of Elements\n\nYou can also serialize an array as a flat sequence of XML elements by applying a XmlElementAttribute to the field returning the array as follows:\n\nA serialized instance might resemble the following code:\n\nAnother way to differentiate the two XML streams is to use the XML Schema Definition tool to generate the XML Schema (XSD) document files from the compiled code. For more information on using the tool, see The XML Schema Definition Tool and XML Serialization. When no attribute is applied to the field, the schema describes the element in the following manner:\n\nWhen the XmlElementAttribute is applied to the field, the resulting schema describes the element as follows:\n\nThe ArrayList class can contain a collection of diverse objects. You can therefore use an ArrayList much as you use an array. Instead of creating a field that returns an array of typed objects, however, you can create a field that returns a single ArrayList. However, as with arrays, you must inform the XmlSerializer of the types of objects the ArrayList contains. To accomplish this, assign multiple instances of the XmlElementAttribute to the field, as shown in the following example.\n\nControlling Serialization of Classes Using XmlRootAttribute and XmlTypeAttribute\n\nYou can apply two attributes to a class only: XmlRootAttribute and XmlTypeAttribute. These attributes are similar. The XmlRootAttribute can be applied to only one class: the class that, when serialized, represents the XML document's opening and closing element—in other words, the root element. The XmlTypeAttribute, on the other hand, can be applied to any class, including the root class.\n\nFor example, in the previous examples, the class is the root class, and all its public fields and properties become the XML elements found in the XML document. Therefore, you can have only one root class. By applying the XmlRootAttribute, you can control the XML stream generated by the XmlSerializer. For example, you can change the element name and namespace.\n\nThe XmlTypeAttribute allows you to control the schema of the generated XML. This capability is useful when you need to publish the schema through an XML Web service. The following example applies both the XmlTypeAttribute and the XmlRootAttribute to the same class:\n\nIf this class is compiled, and the XML Schema Definition tool is used to generate its schema, you would find the following XML describing :\n\nIn contrast, if you were to serialize an instance of the class, only would be found in the XML document:\n\nYou might come across a situation where a public property or field doesn't need to be serialized. For example, a field or property could be used to contain metadata. In such cases, apply the XmlIgnoreAttribute to the field or property and the XmlSerializer will skip over it.\n• How to: Specify an Alternate Element Name for an XML Stream\n• How to: Serialize an Object\n• How to: Deserialize an Object"
    },
    {
        "link": "https://stackoverflow.com/questions/22098564/implementing-custom-xml-serialization-deserialization-of-compound-data-type",
        "document": "In our application, we have a Money type, which contains an amount (decimal) and a currency code (string). In simple form, it looks like this:\n\nAs you might imagine, this gets used in many places in the application, and is frequently serialized/deserialized as it is sent to/from the client. The Money amount is typically serialized as a compound value, e.g. \"1.23USD\" to represent $1.23. The old client (HTML/JS) would parse that value into its component parts back into the Money type. Money values are sent as element values, and as attribute values, depending on where they are in the app, e.g:\n\nI am trying to figure out a way that I can use the built-in C#/.NET Xml Serialization tools to have this same sort of behavior. I looked at implementing ISerializable, but haven't been able to figure out quite the correct way to do so.\n\nEssentially, I want to be able to have the Money amount deserialized by custom logic of my own (that knows how to parse \"1.23USD\" into a Money amount), and serialize it to the simple string, e.g. \"1.23USD\"\n\nThe end goal would be to able to have the Money amount in a class as either:\n\njust the same way you can do that with simple types like int, string, double, etc.\n\nIs this possible?"
    },
    {
        "link": "https://stackoverflow.com/questions/11330643/serialize-property-as-xml-attribute-in-element",
        "document": "I have the following class:\n\nWhich (when populated with some test data) and Serialized using XmlSerializer.Serialize() results in the following XML:\n\nWhat I need to have is:\n\nIs there a way to specify this as attributes without writing my own custom serialization code?"
    },
    {
        "link": "https://github.com/dotnet/docs/blob/main/docs/standard/serialization/examples-of-xml-serialization.md",
        "document": "XML serialization can take more than one form, from simple to complex. For example, you can serialize a class that simply consists of public fields and properties, as shown in Introducing XML Serialization. The following code examples address various advanced scenarios, including how to use XML serialization to generate an XML stream that conforms to a specific XML Schema (XSD) document.\n\nBesides serializing an instance of a public class, you can also serialize an instance of a xref:System.Data.DataSet, as shown in the following code example:\n\nYou can also serialize instances of an xref:System.Xml.XmlElement or xref:System.Xml.XmlNode class, as shown in the following code example:\n\nIf a property or field returns a complex object (such as an array or a class instance), the xref:System.Xml.Serialization.XmlSerializer converts it to an element nested within the main XML document. For example, the first class in the following code example returns an instance of the second class:\n\nThe serialized XML output might look like this:\n\nYou can also serialize a field that returns an array of objects, as shown in the following code example:\n\nIf two items are ordered, the serialized class instance might look like the following code:\n\nYou can create your own collection classes by implementing the xref:System.Collections.ICollection interface and using the xref:System.Xml.Serialization.XmlSerializer to serialize instances of these classes.\n\n' Note that only the collection is serialized -- not the ' CollectionName or any other public property of the class.\n\nYou can cut and paste the following example code into a text file and rename it with a .cs or .vb file name extension. Use the C# or Visual Basic compiler to compile the file. Then run it using the name of the executable.\n\nThis example uses a simple scenario to demonstrate how an instance of an object is created and serialized into a file stream using the xref:System.Xml.Serialization.XmlSerializer.Serialize%2A method. The XML stream is saved to a file. The same file is then read and reconstructed into a copy of the original object using the xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A method.\n\nIn this example, a class named is serialized and then deserialized. A second class named is also included because the public field named must be set to an . Similarly, an class is included because an array of objects must be set to the field. Finally, a class named contains the code that serializes and deserializes the classes.\n\nThe method creates the , , and class objects and sets the public field values. The method also constructs an instance of the xref:System.Xml.Serialization.XmlSerializer class that's used to serialize and deserialize the .\n\nThe method is a little simpler. It just creates objects to deserialize and reads out their values. As with the method, you must first construct an xref:System.Xml.Serialization.XmlSerializer, passing the type of class to be deserialized to the constructor. Also, a xref:System.IO.FileStream is required to read the XML document. To deserialize the objects, call the xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A method with the xref:System.IO.FileStream as an argument. The deserialized object must be cast to an object variable of type . The code then reads the values of the deserialized .\n\n' The XmlRoot attribute allows you to set an alternate name ' (PurchaseOrder) for the XML element and its namespace. By ' default, the XmlSerializer uses the class name. The attribute ' also allows you to set the XML namespace for the element. Lastly, ' the attribute sets the IsNullable property, which specifies whether ' the xsi:null attribute appears if the class instance is set to ' The XmlArrayAttribute changes the XML element name ' from the default of \"OrderedItems\" to \"Items\". ' The XmlAttribute attribute instructs the XmlSerializer to serialize the ' Name field as an XML attribute instead of an XML element (XML element is ' Setting the IsNullable property to false instructs the ' XmlSerializer that the XML attribute will not appear if ' the City field is set to a null reference. ' Calculate is a custom method that calculates the price per item ' and stores the value in a field. ' Creates an instance of the XmlSerializer class; ' specifies the type of object to serialize. ' Creates an address to ship and bill to. ' Set ShipTo and BillTo to the same addressee. ' Inserts the item into the array. ' Serializes the purchase order, and close the TextWriter. ' Creates an instance of the XmlSerializer class; ' specifies the type of object to be deserialized. ' If the XML document has been altered with unknown ' nodes or attributes, handles them with the ' A FileStream is needed to read the XML document. ' Declare an object variable of the type to be deserialized. ' Uses the Deserialize method to restore the object's state ' with data from the XML document. ' Reads the fields of the Address.\n\n// The XmlRoot attribute allows you to set an alternate name // (PurchaseOrder) for the XML element and its namespace. By // default, the XmlSerializer uses the class name. The attribute // also allows you to set the XML namespace for the element. Lastly, // the attribute sets the IsNullable property, which specifies whether // the xsi:null attribute appears if the class instance is set to // The XmlArray attribute changes the XML element name // from the default of \"OrderedItems\" to \"Items\". // The XmlAttribute attribute instructs the XmlSerializer to serialize the // Name field as an XML attribute instead of an XML element (XML element is // Setting the IsNullable property to false instructs the // XmlSerializer that the XML attribute will not appear if // the City field is set to a null reference. // Calculate is a custom method that calculates the price per item // and stores the value in a field. // Creates an instance of the XmlSerializer class; // specifies the type of object to serialize. // Creates an address to ship and bill to. // Sets ShipTo and BillTo to the same addressee. // Inserts the item into the array. // Serializes the purchase order, and closes the TextWriter. // Creates an instance of the XmlSerializer class; // specifies the type of object to be deserialized. // If the XML document has been altered with unknown // nodes or attributes, handles them with the // A FileStream is needed to read the XML document. // Declares an object variable of the type to be deserialized. // Uses the Deserialize method to restore the object's state // with data from the XML document. */ // Reads the fields of the Address.\n\nThe XML output might look like this:\n• How to: Serialize an object\n• How to: Deserialize an object"
    }
]