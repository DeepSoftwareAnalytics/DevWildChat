[
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://geeksforgeeks.org/constructors-in-python",
        "document": "In Python, a constructor is a special method that is called automatically when an object is created from a class. Its main role is to initialize the object by setting up its attributes or state.\n\nThe method __new__ is the constructor that creates a new instance of the class while __init__ is the initializer that sets up the instance’s attributes after creation. These methods work together to manage object creation and initialization.\n\nThis method is responsible for creating a new instance of a class. It allocates memory and returns the new object. It is called before __init__.\n\nTo learn more, please refer to “__new__ ” method\n\nThis method initializes the newly created instance and is commonly used as a constructor in Python. It is called immediately after the object is created by __new__ method and is responsible for initializing attributes of the instance.\n\nNote: It is called after __new__ and does not return anything (it returns None by default).\n\nTo learn more, please refer to “__init__” method\n\nDifferences Between __init__ and __new__\n• None Responsible for creating a new instance of the class.\n• None Rarely overridden but useful for customizing object creation and especially in singleton or immutable objects.\n• None Used to initialize the created object.\n\nConstructors can be of two types.\n\nA default constructor does not take any parameters other than self. It initializes the object with default attribute values.\n\nA parameterized constructor accepts arguments to initialize the object’s attributes with specific values.\n\n1. What is the purpose of a constructor in Python?\n\n2. How is __init__ different from __new__?\n\n3. Can a class have both __new__ and __init__?\n\n4. Is it mandatory to define a constructor in every class?"
    },
    {
        "link": "https://realpython.com/python-class-constructor",
        "document": "Creating a class constructor in Python involves understanding the instantiation process, which consists of two steps: instance creation and instance initialization. You start this process by calling the class like a function, which triggers the method to create an instance and the method to initialize it. Mastering these methods allows you to customize how Python constructs and initializes objects of your classes.\n\nBy the end of this tutorial, you’ll understand that:\n• A class constructor in Python triggers the instantiation process, creating and initializing objects.\n• Python handles instantiation internally with for creation and for initialization.\n• You can customize object initialization by overriding the method in your class.\n• The difference between and is that creates the instance, while initializes it.\n• Common use cases for overriding include subclassing immutable types or implementing singletons.\n\nTo better understand the examples and concepts in this tutorial, you should be familiar with object-oriented programming and special methods in Python.\n\nLike many other programming languages, Python supports object-oriented programming. At the heart of Python’s object-oriented capabilities, you’ll find the keyword, which allows you to define custom classes that can have attributes for storing data and methods for providing behaviors. Once you have a class to work with, then you can start creating new instances or objects of that class, which is an efficient way to reuse functionality in your code. Creating and initializing objects of a given class is a fundamental step in object-oriented programming. This step is often referred to as object construction or instantiation. The tool responsible for running this instantiation process is commonly known as a class constructor. Getting to Know Python’s Class Constructors In Python, to construct an object of a given class, you just need to call the class with appropriate arguments, as you would call any function: # Call the class to construct an object In this example, you define using the keyword. This class is currently empty because it doesn’t have attributes or methods. Instead, the class’s body only contains a statement as a placeholder statement that does nothing. Then you create a new instance of by calling the class with a pair of parentheses. In this example, you don’t need to pass any argument in the call because your class doesn’t take arguments yet. In Python, when you call a class as you did in the above example, you’re calling the class constructor, which creates, initializes, and returns a new object by triggering Python’s internal instantiation process. A final point to note is that calling a class isn’t the same as calling an instance of a class. These are two different and unrelated topics. To make a class’s instance callable, you need to implement a special method, which has nothing to do with Python’s instantiation process. You trigger Python’s instantiation process whenever you call a Python class to create a new instance. This process runs through two separate steps, which you can describe as follows:\n• Create a new instance of the target class\n• Initialize the new instance with an appropriate initial state To run the first step, Python classes have a special method called , which is responsible for creating and returning a new empty object. Then another special method, , takes the resulting object, along with the class constructor’s arguments. The method takes the new object as its first argument, . Then it sets any required instance attribute to a valid state using the arguments that the class constructor passed to it. In short, Python’s instantiation process starts with a call to the class constructor, which triggers the instance creator, , to create a new empty object. The process continues with the instance initializer, , which takes the constructor’s arguments to initialize the newly created object. To explore how Python’s instantiation process works internally, consider the following example of a class that implements a custom version of both methods, and , for demonstration purposes: \"2. Initialize the new instance of Point.\" Here’s a breakdown of what this code does:\n• Line 1 defines the class using the keyword followed by the class name.\n• Line 2 defines the method, which takes the class as its first argument. Note that using as the name of this argument is a strong convention in Python, just like using to name the current instance is. The method also takes and , which allow for passing an undefined number of initialization arguments to the underlying instance.\n• Line 4 creates a new instance by calling the parent class’s method with as an argument. In this example, is the parent class, and the call to gives you access to it. Then the instance is returned. This instance will be the first argument to .\n• Line 6 defines , which is responsible for the initialization step. This method takes a first argument called , which holds a reference to the current instance. The method also takes two additional arguments, and . These arguments hold initial values for the instance attributes and . You need to pass suitable values for these arguments in the call to , as you’ll learn in a moment.\n• Lines 8 and 9 initialize and , respectively. To do this, they use the provided input arguments and .\n• Lines 11 and 12 implement the special method, which provides a proper string representation for your class. With in place, you can uncover how the instantiation process works in practice. Save your code to a file called and start your Python interpreter in a command-line window. Then run the following code: 2. Initialize the new instance of Point. Calling the class constructor creates, initializes, and returns a new instance of the class. This instance is then assigned to the variable. In this example, the call to the constructor also lets you know the steps that Python internally runs to construct the instance. First, Python calls and then , resulting in a new and fully initialized instance of , as you confirmed at the end of the example. To continue learning about class instantiation in Python, you can try running both steps manually: # The point object is not initialized : : 2. Initialize the new instance of Point. In this example, you first call on your class, passing the class itself as the first argument to the method. This call only runs the first step of the instantiation process, creating a new and empty object. Note that creating an instance this way bypasses the call to . Note: The code snippet above is intended to be a demonstrative example of how the instantiation process works internally. It’s not something that you would typically do in real code. Once you have the new object, then you can initialize it by calling with an appropriate set of arguments. After this call, your object is properly initialized, with all its attributes set up. A subtle and important detail to note about is that it can also return an instance of a class different from the class that implements the method itself. When that happens, Python doesn’t call in the current class, because there’s no way to unambiguously know how to initialize an object of a different class. Consider the following example, in which the method of the class returns an instance of the class: \"Initialize the new instance of A.\" \"Initialize the new instance of B.\" Because returns an instance of a different class, Python doesn’t run . To confirm this behavior, save the code into a file called and then run the following code in an interactive Python session: Initialize the new instance of A. : The call to the class constructor runs , which returns an instance of instead of . That’s why never runs. Note that doesn’t have a attribute. In contrast, does have an attribute with a value of . Now that you know the steps that Python internally takes to create instances of a given class, you’re ready to dig a little deeper into other characteristics of , , and the steps that they run.\n\nIn Python, the method is probably the most common special method that you’ll ever override in your custom classes. Almost all your classes will need a custom implementation of . Overriding this method will allow you to initialize your objects properly. The purpose of this initialization step is to leave your new objects in a valid state so that you can start using them right away in your code. In this section, you’ll learn the basics of writing your own methods and how they can help you customize your classes. The most bare-bones implementation of that you can write will just take care of assigning input arguments to matching instance attributes. For example, say you’re writing a class that requires and attributes. In that case, you can do something like this: As you learned before, runs the second step of the object instantiation process in Python. Its first argument, , holds the new instance that results from calling . The rest of the arguments to are normally used to initialize instance attributes. In the above example, you initialized the rectangle’s and using the and arguments to . It’s important to note that, without counting , the arguments to are the same ones that you passed in the call to the class constructor. So, in a way, the signature defines the signature of the class constructor. Additionally, keep in mind that must not explicitly return anything different from , or you’ll get a exception: : __init__() should return None, not 'int' In this example, the method attempts to return an integer number, which ends up raising a exception at run time. The error message in the above example says that should return . However, you don’t need to return explicitly, because methods and functions without an explicit statement just return implicitly in Python. With the above implementation of , you ensure that and get initialized to a valid state when you call the class constructor with appropriate arguments. That way, your rectangles will be ready for use right after the construction process finishes. In , you can also run any transformation over the input arguments to properly initialize the instance attributes. For example, if your users will use directly, then you might want to validate the supplied and and make sure that they’re correct before initializing the corresponding attributes: In this updated implementation of , you make sure that the input and arguments are positive numbers before initializing the corresponding and attributes. If either validation fails, then you get a . Note: A more Pythonic technique to tackle attribute validation is to turn attributes into properties. To learn more about properties, check out Python’s property(): Add Managed Attributes to Your Classes. Now say that you’re using inheritance to create a custom class hierarchy and reuse some functionality in your code. If your subclasses provide a method, then this method must explicitly call the base class’s method with appropriate arguments to ensure the correct initialization of instances. To do this, you should use the built-in function like in the following example: The first line in the method of calls with and as arguments. This call ensures the initialization of and in the parent class, . This technique allows you to extend the base class with new attributes and functionality. To wrap up this section, you should know that the base implementation of comes from the built-in class. This implementation is automatically called when you don’t provide an explicit method in your classes. You can make your objects’ initialization step flexible and versatile by tweaking the method. To this end, one of the most popular techniques is to use optional arguments. This technique allows you to write classes in which the constructor accepts different sets of input arguments at instantiation time. Which arguments to use at a given time will depend on your specific needs and context. As a quick example, check out the following class: In this example, takes a regular argument called . It also takes an optional argument called , which defaults to . Because has a default value, you can construct objects by relying on this value or by providing your own. The class’s final behavior will depend on the value of . If this argument is , then you’ll get an informal greeting when you call . Otherwise, you’ll get a more formal greeting. To try out, go ahead and save the code into a file. Then open an interactive session in your working directory and run the following code: In the first example, you create an object by passing a value to the argument and relying on the default value of . You get an informal greeting on your screen when you call on the object. In the second example, you use a and a argument to instantiate . Because is , the result of calling is a formal greeting. Even though this is a toy example, it showcases how default argument values are a powerful Python feature that you can use to write flexible initializers for your classes. These initializers will allow you to instantiate your classes using different sets of arguments depending on your needs. Okay! Now that you know the basics of and the object initialization step, it’s time to change gears and start diving deeper into and the object creation step.\n\nWhen writing Python classes, you typically don’t need to provide your own implementation of the special method. Most of the time, the base implementation from the built-in class is sufficient to build an empty object of your current class. However, there are a few interesting use cases for this method. For example, you can use to create subclasses of immutable types, such as , , , and . In the following sections, you’ll learn how to write custom implementations of in your classes. To do this, you’ll code a few examples that’ll give you an idea of when you might need to override this method. Typically, you’ll write a custom implementation of only when you need to control the creation of a new instance at a low level. Now, if you need a custom implementation of this method, then you should follow a few steps:\n• Create a new instance by calling with appropriate arguments.\n• Customize the new instance according to your specific needs.\n• Return the new instance to continue the instantiation process. With these three succinct steps, you’ll be able to customize the instance creation step in the Python instantiation process. Here’s an example of how you can translate these steps into Python code: This example provides a sort of template implementation of . As usual, takes the current class as an argument that’s typically called . Note that you’re using and to make the method more flexible and maintainable by accepting any number of arguments. You should always define with and , unless you have a good reason to follow a different pattern. In the first line of , you call the parent class’s method to create a new instance and allocate memory for it. To access the parent class’s method, you use the function. This chain of calls takes you up to , which is the base implementation of for all Python classes. Note: The built-in class is the default base class of all Python classes. The next step is to customize your newly created instance. You can do whatever you need to do to customize the instance at hand. Finally, in the third step, you need to return the new instance to continue the instantiation process with the initialization step. It’s important to note that itself only accepts a single argument, the class to instantiate. If you call with more arguments, then you get a : : object.__new__() takes exactly one argument (the type to instantiate) In this example, you hand over and as additional arguments in the call to . The underlying accepts only the class as an argument, so you get a when you instantiate the class. However, still accepts and passes over extra arguments to if your class doesn’t override , as in the following variation of : In this implementation of , you don’t override . The object creation is then delegated to , which now accepts and passes it over to to finalize the instantiation. Now you can create new and fully initialized instances of , just like in the example. Cool! Now that you know the basics of writing your own implementations of , you’re ready to dive into a few practical examples that feature some of the most common use cases of this method in Python programming. To kick things off, you’ll start with a use case of that consists of subclassing an immutable built-in type. As an example, say you need to write a class as a subclass of Python’s type. Your class will have an additional attribute to store the unit that’s used to measure the distance. Here’s a first approach to this problem, using the method: : float expected at most 1 argument, got 2 When you subclass an immutable built-in data type, you get an error. Part of the problem is that the value is set during creation, and it’s too late to change it during initialization. Additionally, is called under the hood, and it doesn’t deal with extra arguments in the same way as . This is what raises the error in your example. To work around this issue, you can initialize the object at creation time with instead of overriding . Here’s how you can do this in practice: In this example, runs the three steps that you learned in the previous section. First, the method creates a new instance of the current class, , by calling . This time, the call rolls back to , which creates a new instance and initializes it using as an argument. Then the method customizes the new instance by adding a attribute to it. Finally, the new instance gets returned. Note: The class in the example above doesn’t provide a proper unit conversion mechanism. This means that something like won’t attempt at converting units before adding the values. If you’re interested in converting units, then check out the Pint project on PyPI. That’s it! Now your class works as expected, allowing you to use an instance attribute for storing the unit in which you’re measuring the distance. Unlike the floating-point value stored in a given instance of , the attribute is mutable, so you can change its value any time you like. Finally, note how a call to the function reveals that your class inherits features and methods from . Returning an object of a different class is a requirement that can raise the need for a custom implementation of . However, you should be careful because in this case, Python skips the initialization step entirely. So, you’ll have the responsibility of taking the newly created object into a valid state before using it in your code. Check out the following example, in which the class uses to return instances of randomly selected classes: In this example, provides a method that creates a new instance by randomly selecting a class from a list of existing classes. Here’s how you can use this class as a factory of pet objects: Every time you instantiate , you get a random object from a different class. This result is possible because there’s no restriction on the object that can return. Using in such a way transforms a class into a flexible and powerful factory of objects, not limited to instances of itself. Finally, note how the method of never runs. That’s because always returns objects of a different class rather than of itself. Allowing Only a Single Instance in Your Classes Sometimes you need to implement a class that allows the creation of a single instance only. This type of class is commonly known as a singleton class. In this situation, the method comes in handy because it can help you restrict the number of instances that a given class can have. Note: Most experienced Python developers would argue that you don’t need to implement the singleton design pattern in Python unless you already have a working class and need to add the pattern’s functionality on top of it. The rest of the time, you can use a module-level constant to get the same singleton functionality without having to write a relatively complex class. Here’s an example of coding a class with a method that allows the creation of only one instance at a time. To do this, checks the existence of previous instances cached on a class attribute: The class in this example has a class attribute called that defaults to and works as a cache. The method checks if no previous instance exists by testing the condition . Note: In the example above, doesn’t provide an implementation of . If you ever need a class like this with a method, then keep in mind that this method will run every time you call the constructor. This behavior can cause weird initialization effects and bugs. If this condition is true, then the code block creates a new instance of and stores it to . Finally, the method returns the new or the existing instance to the caller. Then you instantiate twice to try to construct two different objects, and . If you compare the identity of these objects with the operator, then you’ll note that both objects are the same object. The names and just hold references to the same object. As a final example of how to take advantage of in your code, you can push your Python skills and write a factory function that partially emulates . The function allows you to create subclasses of with the additional feature of having named fields for accessing the items in the tuple. The code below implements a function that partially emulates this functionality by overriding the method of a nested class called : Here’s how this factory function works line by line:\n• Line 1 imports from the module. This function allows you to retrieve items using their index in the containing sequence.\n• Line 3 defines . This function takes a first argument called , which will hold the name of the tuple subclass that you want to create. The argument allows you to pass an undefined number of field names as strings.\n• Line 4 defines a local variable to hold the number of named fields provided by the user.\n• Line 6 defines a nested class called , which inherits from the built-in class.\n• Line 7 provides a class attribute. This attribute defines a tuple for holding instance attributes. This tuple saves memory by acting as a substitute for the instance’s dictionary, , which would otherwise play a similar role.\n• Line 9 implements with as its first argument. This implementation also takes the argument to accept an undefined number of field values.\n• Lines 10 to 14 define a conditional statement that checks if the number of items to store in the final tuple differs from the number of named fields. If that’s the case, then the conditional raises a with an error message.\n• Line 15 sets the attribute of the current class to the value provided by .\n• Lines 16 and 17 define a loop that turns every named field into a property that uses to return the item at the target . The loop uses the built-in function to perform this action. Note that the built-in function provides the appropriate value.\n• Line 18 returns a new instance of the current class by calling as usual.\n• Lines 20 and 21 define a method for your tuple subclass. To try your out, fire up an interactive session in the directory containing the file and run the following code: In this code snippet, you create a new class by calling . The first argument in this call represents the name that the resulting class object will use. The second and third arguments are the named fields available in the resulting class. Then you create a object by calling the class constructor with appropriate values for the and fields. To access the value of each named field, you can use the dot notation. You can also use indices to retrieve the values because your class is a tuple subclass. Because tuples are immutable data types in Python, you can’t assign new values to the point’s coordinates in place. If you try to do that, then you get an . Finally, calling with your instance as an argument reveals that your object inherits all the attributes and methods that regular tuples have in Python."
    },
    {
        "link": "https://w3schools.com/python/python_classes.asp",
        "document": "Almost everything in Python is an object, with its properties and methods.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nTo create a class, use the keyword :\n\nNow we can use the class named MyClass to create objects:\n\nThe examples above are classes and objects in their simplest form, and are not really useful in real life applications.\n\nTo understand the meaning of classes we have to understand the built-in function.\n\nAll classes have a function called , which is always executed when the class is being initiated.\n\nUse the function to assign values to object properties, or other operations that are necessary to do when the object is being created:\n\nThe function controls what should be returned when the class object is represented as a string.\n\nIf the function is not set, the string representation of the object is returned:\n\nObjects can also contain methods. Methods in objects are functions that belong to the object.\n\nLet us create a method in the Person class:\n\nThe parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\nIt does not have to be named , you can call it whatever you like, but it has to be the first parameter of any function in the class:\n\nYou can modify properties on objects like this:\n\nYou can delete properties on objects by using the keyword:\n\nYou can delete objects by using the keyword:\n\ndefinitions cannot be empty, but if you for some reason have a definition with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://geeksforgeeks.org/python-classes-and-objects",
        "document": "A class in Python is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. When we create a new class, we define a new type of object. We can then create multiple instances of this object type.\n\nClasses are created using class keyword. Attributes are variables defined inside the class and represent the properties of the class. Attributes can be accessed using the dot . operator (e.g., MyClass.my_attribute).\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n\nNow, let’s create an object from Dog class.\n\nsound attribute is a class attribute. It is shared across all instances of Dog class, so can be directly accessed through instance dog1.\n\nIn Python, class has __init__() function. It automatically initializes object attributes when an object is created.\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• None Inside bark(), self.name accesses the specific dog’s name and prints it.\n• None When we call dog1.bark(), Python automatically passes dog1 as self, allowing access to its attributes.\n\n__str__ method in Python allows us to define a custom string representation of an object. By default, when we print an object or convert it to a string using str(), Python uses the default implementation, which returns a string like <__main__.ClassName object at 0x00000123>.\n• __str__ Implementation: Defined as a method in the Dog class. Uses the self parameter to access the instance’s attributes (name and age).\n• Readable Output: When print(dog1) is called, Python automatically uses the __str__ method to get a string representation of the object. Without __str__, calling print(dog1) would produce something like <__main__.Dog object at 0x00000123>.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nWhat are classes and objects in Python?\n\nWhy use classes in Python?\n\nHow to define a class in Python?\n\nWhat is an object in OOP?\n\nWhy do we need classes and objects?"
    },
    {
        "link": "https://realpython.com/factory-method-python",
        "document": "This article explores the Factory Method design pattern and its implementation in Python. Design patterns became a popular topic in late 90s after the so-called Gang of Four (GoF: Gamma, Helm, Johson, and Vlissides) published their book Design Patterns: Elements of Reusable Object-Oriented Software.\n\nThe book describes design patterns as a core design solution to reoccurring problems in software and classifies each design pattern into categories according to the nature of the problem. Each pattern is given a name, a problem description, a design solution, and an explanation of the consequences of using it.\n\nThe GoF book describes Factory Method as a creational design pattern. Creational design patterns are related to the creation of objects, and Factory Method is a design pattern that creates objects with a common interface.\n\nThis is a recurrent problem that makes Factory Method one of the most widely used design patterns, and it’s very important to understand it and know how apply it.\n\nBy the end of this article, you will:\n• Recognize opportunities to use Factory Method in your applications\n• Learn to modify existing code and improve its design by using the pattern\n• Learn to identify opportunities where Factory Method is the appropriate design pattern\n• Choose an appropriate implementation of Factory Method\n• Know how to implement a reusable, general purpose solution of Factory Method\n\nFactory Method is a creational design pattern used to create concrete implementations of a common interface. It separates the process of creating an object from the code that depends on the interface of the object. For example, an application requires an object with a specific interface to perform its tasks. The concrete implementation of the interface is identified by some parameter. Instead of using a complex conditional structure to determine the concrete implementation, the application delegates that decision to a separate component that creates the concrete object. With this approach, the application code is simplified, making it more reusable and easier to maintain. Imagine an application that needs to convert a object into its representation using a specified format. Converting an object to a different representation is often called serializing. You’ll often see these requirements implemented in a single function or method that contains all the logic and implementation, like in the following code: In the example above, you have a basic class to represent a song and a class that can convert a object into its representation according to the value of the parameter. The method supports two different formats: JSON and XML. Any other specified is not supported, so a exception is raised. Let’s use the Python interactive shell to see how the code works: You create a object and a , and you convert the song to its string representation by using the method. The method takes the object as a parameter, as well as a string value representing the format you want. The last call uses as the format, which is not supported by the , so a exception is raised. This example is short and simplified, but it still has a lot of complexity. There are three logical or execution paths depending on the value of the parameter. This may not seem like a big deal, and you’ve probably seen code with more complexity than this, but the above example is still pretty hard to maintain. The example above exhibits all the problems you’ll find in complex logical code. Complex logical code uses structures to change the behavior of an application. Using conditional structures makes the code harder to read, harder to understand, and harder to maintain. The code above might not seem hard to read or understand, but wait till you see the final code in this section! Nevertheless, the code above is hard to maintain because it is doing too much. The single responsibility principle states that a module, a class, or even a method should have a single, well-defined responsibility. It should do just one thing and have only one reason to change. The method in will require changes for many different reasons. This increases the risk of introducing new defects or breaking existing functionality when changes are made. Let’s take a look at all the situations that will require modifications to the implementation:\n• When a new format is introduced: The method will have to change to implement the serialization to that format.\n• When the object changes: Adding or removing properties to the class will require the implementation to change in order to accommodate the new structure.\n• When the string representation for a format changes (plain JSON vs JSON API): The method will have to change if the desired string representation for a format changes because the representation is hard-coded in the method implementation. The ideal situation would be if any of those changes in requirements could be implemented without changing the method. Let’s see how you can do that in the following sections. The first step when you see complex conditional code in an application is to identify the common goal of each of the execution paths (or logical paths). Code that uses usually has a common goal that is implemented in different ways in each logical path. The code above converts a object to its representation using a different format in each logical path. Based on the goal, you look for a common interface that can be used to replace each of the paths. The example above requires an interface that takes a object and returns a . Once you have a common interface, you provide separate implementations for each logical path. In the example above, you will provide an implementation to serialize to JSON and another for XML. Then, you provide a separate component that decides the concrete implementation to use based on the specified . This component evaluates the value of and returns the concrete implementation identified by its value. In the following sections, you will learn how to make changes to existing code without changing the behavior. This is referred to as refactoring the code. Martin Fowler in his book Refactoring: Improving the Design of Existing Code defines refactoring as “the process of changing a software system in such a way that does not alter the external behavior of the code yet improves its internal structure.” If you’d like to see refactoring in action, check out the Real Python Code Conversation Refactoring: Prepare Your Code to Get Help. Let’s begin refactoring the code to achieve the desired structure that uses the Factory Method design pattern. The desired interface is an object or a function that takes a object and returns a representation. The first step is to refactor one of the logical paths into this interface. You do this by adding a new method and moving the JSON serialization code to it. Then, you change the client to call it instead of having the implementation in the body of the statement: # The rest of the code remains the same Once you make this change, you can verify that the behavior has not changed. Then, you do the same for the XML option by introducing a new method , moving the implementation to it, and modifying the path to call it. The following example shows the refactored code: The new version of the code is easier to read and understand, but it can still be improved with a basic implementation of Factory Method. The central idea in Factory Method is to provide a separate component with the responsibility to decide which concrete implementation should be used based on some specified parameter. That parameter in our example is the . To complete the implementation of Factory Method, you add a new method that takes the desired . This method evaluates the value of and returns the matching serialization function: Note: The method does not call the concrete implementation, and it just returns the function object itself. Now, you can change the method of to use to complete the Factory Method implementation. The next example shows the complete code: The final implementation shows the different components of Factory Method. The method is the application code that depends on an interface to complete its task. This is referred to as the client component of the pattern. The interface defined is referred to as the product component. In our case, the product is a function that takes a and returns a string representation. The and methods are concrete implementations of the product. Finally, the method is the creator component. The creator decides which concrete implementation to use. Because you started with some existing code, all the components of Factory Method are members of the same class . Usually, this is not the case and, as you can see, none of the added methods use the parameter. This is a good indication that they should not be methods of the class, and they can become external functions: Note: The method in does not use the parameter. The rule above tells us it should not be part of the class. This is correct, but you are dealing with existing code. If you remove and change the method to a function, then you’ll have to change all the locations in the application that use and replace the calls to the new function. Unless you have a very high percentage of code coverage with your unit tests, this is not a change that you should be doing. The mechanics of Factory Method are always the same. A client ( ) depends on a concrete implementation of an interface. It requests the implementation from a creator component ( ) using some sort of identifier ( ). The creator returns the concrete implementation according to the value of the parameter to the client, and the client uses the provided object to complete its task. You can execute the same set of instructions in the Python interactive interpreter to verify that the application behavior has not changed: File , line , in File , line , in File , line , in : You create a and a , and use the to convert the song to its representation specifying a . Since is not a supported format, is raised.\n\nFactory Method should be used in every situation where an application (client) depends on an interface (product) to perform a task and there are multiple concrete implementations of that interface. You need to provide a parameter that can identify the concrete implementation and use it in the creator to decide the concrete implementation. There is a wide range of problems that fit this description, so let’s take a look at some concrete examples. Replacing complex logical code: Complex logical structures in the format are hard to maintain because new logical paths are needed as requirements change. Factory Method is a good replacement because you can put the body of each logical path into separate functions or classes with a common interface, and the creator can provide the concrete implementation. The parameter evaluated in the conditions becomes the parameter to identify the concrete implementation. The example above represents this situation. Constructing related objects from external data: Imagine an application that needs to retrieve employee information from a database or other external source. The records represent employees with different roles or types: managers, office clerks, sales associates, and so on. The application may store an identifier representing the type of employee in the record and then use Factory Method to create each concrete object from the rest of the information on the record. Supporting multiple implementations of the same feature: An image processing application needs to transform a satellite image from one coordinate system to another, but there are multiple algorithms with different levels of accuracy to perform the transformation. The application can allow the user to select an option that identifies the concrete algorithm. Factory Method can provide the concrete implementation of the algorithm based on this option. Combining similar features under a common interface: Following the image processing example, an application needs to apply a filter to an image. The specific filter to use can be identified by some user input, and Factory Method can provide the concrete filter implementation. Integrating related external services: A music player application wants to integrate with multiple external services and allow users to select where their music comes from. The application can define a common interface for a music service and use Factory Method to create the correct integration based on a user preference. All these situations are similar. They all define a client that depends on a common interface known as the product. They all provide a means to identify the concrete implementation of the product, so they all can use Factory Method in their design. You can now look at the serialization problem from previous examples and provide a better design by taking into consideration the Factory Method design pattern. The basic requirements for the example above are that you want to serialize objects into their representation. It seems the application provides features related to music, so it is plausible that the application will need to serialize other type of objects like or . Ideally, the design should support adding serialization for new objects by implementing new classes without requiring changes to the existing implementation. The application requires objects to be serialized to multiple formats like JSON and XML, so it seems natural to define an interface that can have multiple implementations, one per format. The interface implementation might look something like this: Note: The example above doesn’t implement a full interface, but it should be good enough for our purposes and to demonstrate Factory Method. The interface is an abstract concept due to the dynamic nature of the Python language. Static languages like Java or C# require that interfaces be explicitly defined. In Python, any object that provides the desired methods or functions is said to implement the interface. The example defines the interface to be an object that implements the following methods or functions: This interface is implemented by the concrete classes and . The original example used a class. For the new application, you will implement something more generic, like : The implementation of is completely generic, and it only mentions a and a as parameters. The is used to identify the concrete implementation of the and is resolved by the object. The parameter refers to another abstract interface that should be implemented on any object type you want to serialize. Let’s take a look at a concrete implementation of the interface in the class: The class implements the interface by providing a method. In the method, the class uses the object to write its own information without any knowledge of the format. As a matter of fact, the class doesn’t even know the goal is to convert the data to a string. This is important because you could use this interface to provide a different kind of that converts the information to a completely different representation if needed. For example, your application might require in the future to convert the object to a binary format. So far, we’ve seen the implementation of the client ( ) and the product ( ). It is time to complete the implementation of Factory Method and provide the creator. The creator in the example is the variable in . In the original example, you implemented the creator as a function. Functions are fine for very simple examples, but they don’t provide too much flexibility when requirements change. Classes can provide additional interfaces to add functionality, and they can be derived to customize behavior. Unless you have a very basic creator that will never change in the future, you want to implement it as a class and not a function. These type of classes are called object factories. You can see the basic interface of in the implementation of . The method uses to retrieve the from the object factory. You will now implement to meet this interface: The current implementation of is the same you used in the original example. The method evaluates the value of and decides the concrete implementation to create and return. It is a relatively simple solution that allows us to verify the functionality of all the Factory Method components. Let’s go to the Python interactive interpreter and see how it works: File , line , in File , line , in File , line , in : The new design of Factory Method allows the application to introduce new features by adding new classes, as opposed to changing existing ones. You can serialize other objects by implementing the interface on them. You can support new formats by implementing the interface in another class. The missing piece is that has to change to include the support for new formats. This problem is easily solved with the new design because is a class. The current implementation of needs to be changed when a new format is introduced. Your application might never need to support any additional formats, but you never know. You want your designs to be flexible, and as you will see, supporting additional formats without changing is relatively easy. The idea is to provide a method in that registers a new implementation for the format we want to support: The method allows registering new formats by specifying a value used to identify the format and a object. The creator object happens to be the class name of the concrete . This is possible because all the classes provide a default to initialize the instances. The registration information is stored in the dictionary. The method retrieves the registered creator and creates the desired object. If the requested has not been registered, then is raised. You can now verify the flexibility of the design by implementing a and get rid of the annoying you saw earlier: Note: To implement the example, you need to install in your environment using . JSON and YAML are very similar formats, so you can reuse most of the implementation of and overwrite to complete the implementation. The format is then registered with the object to make it available. Let’s use the Python interactive interpreter to see the results: By implementing Factory Method using an Object Factory and providing a registration interface, you are able to support new formats without changing any of the existing application code. This minimizes the risk of breaking existing features or introducing subtle bugs.\n\nThe implementation of is a huge improvement from the original example. It provides great flexibility to support new formats and avoids modifying existing code. Still, the current implementation is specifically targeted to the serialization problem above, and it is not reusable in other contexts. Factory Method can be used to solve a wide range of problems. An Object Factory gives additional flexibility to the design when requirements change. Ideally, you’ll want an implementation of Object Factory that can be reused in any situation without replicating the implementation. There are some challenges to providing a general purpose implementation of Object Factory, and in the following sections you will look at those challenges and implement a solution that can be reused in any situation. Not All Objects Can Be Created Equal The biggest challenge to implement a general purpose Object Factory is that not all objects are created in the same way. Not all situations allow us to use a default to create and initialize the objects. It is important that the creator, in this case the Object Factory, returns fully initialized objects. This is important because if it doesn’t, then the client will have to complete the initialization and use complex conditional code to fully initialize the provided objects. This defeats the purpose of the Factory Method design pattern. To understand the complexities of a general purpose solution, let’s take a look at a different problem. Let’s say an application wants to integrate with different music services. These services can be external to the application or internal in order to support a local music collection. Each of the services has a different set of requirements. Note: The requirements I define for the example are for illustration purposes and do not reflect the real requirements you will have to implement to integrate with services like Pandora or Spotify. The intent is to provide a different set of requirements that shows the challenges of implementing a general purpose Object Factory. Imagine that the application wants to integrate with a service provided by Spotify. This service requires an authorization process where a client key and secret are provided for authorization. The service returns an access code that should be used on any further communication. This authorization process is very slow, and it should only be performed once, so the application wants to keep the initialized service object around and use it every time it needs to communicate with Spotify. At the same time, other users want to integrate with Pandora. Pandora might use a completely different authorization process. It also requires a client key and secret, but it returns a consumer key and secret that should be used for other communications. As with Spotify, the authorization process is slow, and it should only be performed once. Finally, the application implements the concept of a local music service where the music collection is stored locally. The service requires that the the location of the music collection in the local system be specified. Creating a new service instance is done very quickly, so a new instance can be created every time the user wants to access the music collection. This example presents several challenges. Each service is initialized with a different set of parameters. Also, Spotify and Pandora require an authorization process before the service instance can be created. They also want to reuse that instance to avoid authorizing the application multiple times. The local service is simpler, but it doesn’t match the initialization interface of the others. In the following sections, you will solve this problems by generalizing the creation interface and implementing a general purpose Object Factory. The creation of each concrete music service has its own set of requirements. This means a common initialization interface for each service implementation is not possible or recommended. The best approach is to define a new type of object that provides a general interface and is responsible for the creation of a concrete service. This new type of object will be called a . The object has all the logic to create and initialize a service instance. You will implement a object for each of the supported services. Let’s start by looking at the application configuration: The dictionary contains all the values required to initialize each of the services. The next step is to define an interface that will use those values to create a concrete implementation of a music service. That interface will be implemented in a . Let’s look at the implementation of the and : Note: The music service interface defines a method, which should be enough for demonstration purposes. The example shows a that implements . This method is used to create and initialize the concrete . It specifies the required parameters and ignores any additional parameters provided through . Once the is retrieved, it creates and returns the instance. Notice that keeps the service instance around and only creates a new one the first time the service is requested. This avoids going through the authorization process multiple times as specified in the requirements. Let’s do the same for Pandora: The implements the same interface, but it uses different parameters and processes to create and initialize the . It also keeps the service instance around, so the authorization only happens once. Finally, let’s take a look at the local service implementation: The just requires a location where the collection is stored to initialize the . A new instance is created every time the service is requested because there is no slow authorization process. The requirements are simpler, so you don’t need a class. Instead, a function returning an initialized is used. This function matches the interface of the methods implemented in the builder classes. A general purpose Object Factory ( ) can leverage the generic interface to create all kinds of objects. It provides a method to register a based on a value and a method to create the concrete object instances based on the . Let’s look at the implementation of our generic : The implementation structure of is the same you saw in . The difference is in the interface that exposes to support creating any type of object. The builder parameter can be any object that implements the callable interface. This means a can be a function, a class, or an object that implements . The method requires that additional arguments are specified as keyword arguments. This allows the objects to specify the parameters they need and ignore the rest in no particular order. For example, you can see that specifies a parameter and ignores the rest. Let’s create the factory instance and register the builders for the services you want to support: The module exposes the instance through the attribute. Then, the builders are registered with the instance. For Spotify and Pandora, you register an instance of their corresponding builder, but for the local service, you just pass the function. The application defines a dictionary representing the application configuration. The configuration is used as the keyword arguments to the factory regardless of the service you want to access. The factory creates the concrete implementation of the music service based on the specified parameter. You can now run our program to see how it works: You can see that the correct instance is created depending on the specified service type. You can also see that requesting the Pandora or Spotify service always returns the same instance."
    },
    {
        "link": "https://geeksforgeeks.org/factory-method-python-design-patterns",
        "document": "Factory Method is a Creational Design Pattern that allows an interface or a class to create an object, but lets subclasses decide which class or object to instantiate. Using the Factory method, we have the best ways to create an object. Here, objects are created without exposing the logic to the client, and for creating the new type of object, the client uses the same common interface.\n\n\n\nImagine you are having your own startup which provides ridesharing in different parts of the country. The initial version of the app only provides Two-Wheeler ridesharing but as time passes, your app becomes popular and now you want to add Three and Four-Wheeler ridesharing also. \n\nIt’s a piece of great news! but what about the software developers of your startup. They have to change the whole code because now most part of the code is coupled with the Two-Wheeler class and developers have to make changes to the entire codebase. \n\nAfter being done with all these changes, either the developers end with the messy code or with the resignation letter. \n\n\n\nDiagrammatic representation of Problems without using Factory Method\n\n\n\nLet’s understand the concept with one more example which is related to the translations and localization of the different languages. \n\nSuppose we have created an app whose main purpose is to translate one language into another and currently our app works with 10 languages only. Now our app has become widely popular among people but the demand has grown suddenly to include 5 more languages. \n\nIt’s a piece of great news! only for the owner not for the developers. They have to change the whole code because now most part of the code is coupled with the existing languages only and that’s why developers have to make changes to the entire codebase which is really a difficult task to do.\n\nLet’s look at the code for the problem which we may face without using the factory method.\n\n\n\nNote: Following code is written without using the Factory method.\n\nIts solution is to replace the straightforward object construction calls with calls to the special factory method. Actually, there will be no difference in the object creation but they are being called within the factory method.\n\nFor example Our Two_Wheeler, Three_Wheeler, and Four_wheeler classes should implement the ridesharing interface which will declare a method called a ride. Each class will implement this method uniquely.\n\n\n\n\n\nNow let us understand the factory method with the help of an example:\n\nLet’s look at the class diagram considering the example of ride-sharing.\n• None We can easily add new types of products without disturbing the existing client code.\n• None Generally, tight coupling is being avoided between the products and the creator classes and objects.\n• None To create a particular concrete product object, the client might have to sub-class the creator class.\n• None You end up with a huge number of small files i.e, cluttering the files.\n• None In a Graphics system, depending upon the user’s input it can draw different shapes like rectangles, Square, Circle, etc. But for the ease of both developers as well as the client, we can use the factory method to create the instance depending upon the user’s input. Then we don’t have to change the client code for adding a new shape.\n• None On a Hotel booking site, we can book a slot for 1 room, 2 rooms, 3 rooms, etc. Here user can input the number of rooms he wants to book. Using the factory method, we can create a factory class Any Rooms which will help us to create the instance depending upon the user’s input. Again we don’t have to change the client’s code for adding the new facility."
    },
    {
        "link": "https://stackoverflow.com/questions/14992474/factory-method-for-objects-best-practice",
        "document": "First, most of the time you think you need something like this, you don't; it's a sign that you're trying to treat Python like Java, and the solution is to step back and ask why you need a factory.\n\nOften, the simplest thing to do is to just have a constructor with defaulted/optional/keyword arguments. Even cases that you'd never write that way in Java—even cases where overloaded constructors would feel wrong in C++ or ObjC—may look perfectly natural in Python. For example, , or look reasonable. For that matter, a class that inherits from and adds absolutely nothing but an overload looks reasonable. And these are trivial to define:\n\nBut, sometimes you do need factory functions. So, what do you do then? Well, there are two kinds of things that are often lumped together into \"factories\".\n\nA is the idiomatic way to do an \"alternate constructor\"—there are examples all over the stdlib— , , etc.\n\nA function is the idiomatic way to do an \"I don't care what the actual class is\" factory. Look at, e.g., the built-in function. Do you know what it returns in 3.3? Do you care? Nope. That's why it's a function, not or whatever.\n\nYour given example seems like a perfectly legitimate use case, and fits pretty clearly into the \"alternate constructor\" bin (if it doesn't fit into the \"constructor with extra arguments\" bin)."
    },
    {
        "link": "https://medium.com/@amirm.lavasani/design-patterns-in-python-factory-method-1882d9a06cb4",
        "document": "What is the Factory Method Pattern?\n\nAt the core of the Factory Method pattern is the concept of delegation. Instead of the client code directly creating objects, it delegates the responsibility to a Factory Method.\n\nThis method resides in an abstract Creator class or interface, defining an interface for creating objects. Concrete subclasses of the Creator implement this Factory Method, allowing them to create specific instances of objects. This delegation promotes loose coupling between the client code and the objects it uses, enhancing flexibility and maintainability.\n\nLet’s break down the Factory Method pattern into its essential components.\n• Creator: The Creator is an abstract class or interface. It declares the Factory Method, which is essentially a method for creating objects. The Creator provides an interface for creating products but doesn’t specify their concrete classes.\n• Concrete Creator: Concrete Creators are the subclasses of the Creator. They implement the Factory Method, deciding which concrete Product class to instantiate. In other words, each Concrete Creator specializes in creating a particular type of product.\n• Product: The Product is another abstract class or interface. It defines the type of objects the Factory Method creates. These products share a common interface, but their concrete implementations can vary.\n• Concrete Product: Concrete Products are the subclasses of the Product. They provide the specific implementations of the products. Each Concrete Product corresponds to one type of object created by the Factory Method.\n\nLet’s implement the Factory Method pattern in Python for a case involving translations and localization of different languages step by step.\n\nWe start by defining the Product, which is the abstract class representing translations. Each translation will have a common interface with a method called .\n\nNext, we create Concrete Products, which are the translations for specific languages. We’ll create three concrete translation classes, one for each language: French, English, and Spanish.\n\nNow, we define the Creator, an abstract class that declares the Factory Method. The Factory Method in this case is . This method will be implemented by concrete creators to create localizers for specific languages.\n\nWe implement Concrete Creators for specific languages. Each Concrete Creator will implement the Factory Method to create localizers for a particular language.\n\nFinally, we utilize the Factory Method pattern in our client code to create localizers without knowing the concrete classes.\n\nExplore all code examples and design pattern implementations on GitHub!\n\nThe “Factory Method” pattern, as originally conceived, may not align perfectly with Python’s capabilities. It was initially devised for less capable programming languages that couldn’t handle passing classes and functions as parameters or storing them as attributes. However, Python’s flexibility allows for a cleaner and more concise implementation of steps 3 and 4 as follows:\n\nThe Factory Method pattern is particularly useful in various scenarios:\n• Library Frameworks: It’s commonly used in library frameworks, allowing developers to extend and customize the behavior of a library.\n• Plug-in Architectures: When building applications with extensible plug-in architectures, the Factory Method pattern simplifies the addition of new plug-ins without modifying existing code.\n• Testing: Factories can be used to create mock objects for unit testing.\n• Decoupling: It decouples client code from the concrete classes, reducing dependencies and enhancing code stability.\n• Flexibility: It allows for the creation of objects without specifying their exact class, making the code more flexible and maintainable.\n• Extensibility: New product classes can be added without modifying existing code, promoting an open-closed principle.\n\nHowever, like any design pattern, the Factory Method has its drawbacks:\n• Complexity: Introducing multiple Factory Methods and associated classes can lead to increased complexity.\n• Abstraction Overhead: Creating numerous abstract classes and interfaces may add overhead to the codebase.\n• Overkill: In simple scenarios, using the Factory Method pattern might be overkill and add unnecessary complexity.\n\nThe Factory Method design pattern offers a systematic way to create objects while keeping code maintainable and adaptable. It excels in scenarios where object types vary or evolve.\n\nLibrary frameworks, plug-in systems, and software ecosystems benefit from its power. It fosters innovation and allows systems to adapt to evolving demands.\n\nHowever, it should be used judiciously, considering the specific needs of the application and the principle of simplicity. When applied appropriately, the Factory Method pattern can contribute significantly to the overall design and architecture of a software system.\n\nCheck out all code examples and design pattern implementations in the following GitHub repository.\n• The Factory Method Pattern and Its Implementation in Python"
    },
    {
        "link": "https://medium.com/@balakrishnamaduru/implementing-the-factory-method-design-pattern-in-python-a-step-by-step-guide-with-examples-d0c1a465283b",
        "document": "The Factory Method design pattern is a creational pattern used to create objects without specifying the exact class of the object that will be created. This pattern is particularly useful when the type of object to be created can vary and the exact type may not be known until runtime.\n\nHere’s an example of implementing the Factory Method pattern in Python:\n\nLet’s consider a scenario where we want to create different types of shapes such as circles, squares, and rectangles. Each shape will have methods to calculate its area and perimeter.\n• Define an Abstract Base Class: We start by creating an abstract base class for shapes, which enforces that all concrete shapes must implement methods to calculate the area and perimeter.\n\n2. Create Concrete Shape Classes: Next, we implement concrete classes for different shapes.\n\n3. Implement the Factory Class: The factory class is responsible for creating instances of the different shapes based on the provided input.\n\n4. Client Code: The client code uses the factory to create shape objects without knowing the specifics of the shape classes.\n• Encapsulation: The pattern encapsulates the creation logic of objects, making the client code cleaner and easier to manage.\n• Flexibility: Adding new types of shapes becomes easier without modifying existing client code.\n• Adherence to SOLID Principles: This pattern adheres to the Single Responsibility and Open/Closed principles, promoting better software design."
    }
]