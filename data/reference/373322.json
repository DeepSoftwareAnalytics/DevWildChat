[
    {
        "link": "https://create.roblox.com/docs/reference/engine/datatypes/Vector3",
        "document": "The Vector3 data type represents a vector in 3D space, typically used as a point in 3D space or the dimensions of a rectangular prism. Vector3 supports basic component-based arithmetic operations (sum, difference, product, and quotient) and these operations can be applied on the left or right hand side to either another Vector3 or a number. It also features methods for common vector operations, such as Cross() and Dot().\n\nAlternatively to Vector3, consider using the methods and properties of the vector library.\n\nSome example usages of Vector3 are the Position, Rotation, and Size of parts, for example:\n\nVector3 is also commonly used when constructing more complex 3D data types such as CFrame. Many of these data types' methods will use a Vector3 within their parameters, such as CFrame:PointToObjectSpace()."
    },
    {
        "link": "https://devforum.roblox.com/t/lua-scripting-starter-guide/394618",
        "document": "Picking up programming and learning it for the first time works just like any other hobby–art, music, sports, photography, etc.–although, it may be difficult to know where to start as a beginner, especially if you’ve never had experience with it up until now. When I was younger, it was very difficult for me to get into programming as tutorials for a younger, completely unexperienced audience was rare. Although there was plenty of content available, I still had a hard time understanding the material or just got lost in the sea of information that was given to me. There are still plenty of places on either Youtube or other parts of the internet where beginners can learn, but I’ve specifically compiled this list so that you have a neat, simple page you can refer to if you feel lost, or don’t know where to go after searching for tutorials. Becoming an experienced programmer from scratch will not be easy, it will take a lot of effort and more importantly time to become an expert. I say this because many developers I’ve personally known, whether rookies or professionals, tend to bail halfway through their project or goal. Do not lose hope when things don’t come as quickly as you expected, patience is crucial. What sets poor and excellent students isn’t necessarily intelligence, but their willingness to put in work and always seeking new ways to become better at what they do. Think of this article as a legend for Lua, similar to the page in a large book that highlight specific terms or character in the book that the reader might not recognize. When you finish this guide, your ability to code things will be limited, but you should have a much easier time understanding tutorials on more advanced topics. Ultimately, I hope this article can help you get started, or at least guide you through your journey through programming.\n\nP.S. I’ve tried to make this tutorial as kid-friendly as possible, if it is still difficult to read or understand, please DM me on any platform and I’ll try my best fix it. Specific examples are appreciated.\n\nChances are, if you’ve ever played a game, you’ve wondered how it was made. How does a sword go from unequipped to swinging in just a matter of seconds? Why? How is this app able to stream the movies I select? How is the website we’re currently on even able to operate?\n\nComputer programming is an essential part of modern life, as it determines and allows for many technologies we use on a daily basis to operate. However, all code is not written in the same way, rather, there are distinct languages, or ways of writing code. In fact, you might already be familiar with the names of various programming languages, including but not limited to JavaScript or Python.\n\nIn this tutorial, we’ll be covering Lua, the official language of Roblox which can be used to create a variety of different games for users to play.\n\nIn this tutorial, we’ll be using a specific format to write, input, and receive the result of our script. To use a format identical to mine, click on View in the upper left side of your screen, then make sure you have selected and have the following settings:\n\nYour screen should look something similar to this\n\nScripts can be inserted almost everywhere, for the sake of keeping this tutorial short, head over to Model on the top panel and browse to the far left and click on Script, which will generate a script that we can use for our tutorial.\n\nPrint is a built-in function which prints out whatever statement you decide to give it. This can be either number or strings, which we’ll cover in this section. You’ll notice that once you launch a script, there is already a print function automatically typed out for you. This code always comes with your scripts, so we’ll erase it to continue with the next step.\n\nType out print in all lowercase letters. If print is typed incorrectly or typed with any capitals, the program will not recognize the command and will not run it. Add a pair of parenthesis after, studio should automatically add the second one. Make sure there is no space in between print and the parenthesis otherwise Lua will not be able to read it.\n\nNext, we need to add a string in-between the parenthesis so that we don’t just print empty space. A string is any character or words inside of a pair of quotes, such as “Hello World!” For our tutorial, we’ll be adding the string “YellowNoobs!” for the program to print.\n\nYou may replace \"YellowNoobs\" with any other text you wish as long as it is in-between the parenthesis (\"\"), the end result should look something like this,\n\nIf you want to include quotation marks in your quote, you can also use a pair of single quotes (’’) and put the double parenthesis, or vice-versa for single quotes to be printed.\n\nPrint also works for numbers and equations, which it’ll automatically simplify in the output. But before we write out our problem, we need to find the symbols needed to get the right answer.\n\nArithmetic operators are basically all the tools we use in programming to indicate a relationship between numbers. This sounds complicated, but it’s just what we call the symbols we use to add, subtract, multiply, and divide numbers.\n\nHere are the Arithmetic Operators used in Lua:\n\nNow, we’ll write our equation in-between the parenthesis, and paste it into the command bar once we’re ready to get the output. Feel free to mess around with the operators to get the hang of it.\n\nIf we put our code into the command bar we’ll get 81 instead. This is the answer to the equation, and Lua does this because it’s a simplified version, or answer to the problem we originally printed. An important thing to keep in mind is that Lua completes the math using the Order of Operations, meaning it starts with exponents, then division and multiplication, and finally addition and subtraction.\n\nTake this piece of code for example,\n\nWhile you may be tempted to say the answer is 12, since you add 1 + 5, getting 6 and multiplying it by 2, this is wrong. Instead, you multiply 5 and 2 first, then add 1, getting 11. This is a rule of both math and programming, so practice the concept until you can avoid printing the wrong number.\n\nIn order to combine two or more separate values together, you can use concatenation in the print function. We’ll still use the same format, but will add two periods or dots after each string. Do not place this inside of the string, otherwise Lua will interpret it as part of the string and produce an error.\n\nIf we paste this into the command bar, the output will show us a full statement as if it was a single string, meaning the concatenation was successful.\n\nNow that you’ve learned how to make a script, you’ll learn what variables are and how to make your own. Variables are considered vital because they save a lot of time and save you time and make your scripts simpler to review. They can be booleans, numbers, strings, or practically anything you want to assign a name to.\n\nIf you’re struggling to understand the concept of a variable, you can compare it to a nickname you might give someone who’s name may be too tedious to pronounce. Although it is not their birthname, calling them by their nickname will still get their attention as they’ve been given and called by it before.\n\nBelow, I’ve given an example of a variable. The term “variable” will be used interchangeably with the string “YellowNoobs!” whenever we use it in the script. If we put the variable inside of the print command, it will print the text assigned to it. Since the variable is identical to the string we assigned it, we do not need any quotes around the variable name. If you put quotes around a variable name, Lua will interpret it as a string, and print the actual name rather than the value.\n\nIf we copy and paste the code into the input, the output will print our statement.\n\nIt is necessary that you define your variables before using them in your code. Since Lua reads code from top to bottom, it will not know what the variable stands for when it executes the print function. If we paste the code into our command bar, we’ll get the output nil, which means nothing or no data.\n\nWhenever we define the variable, its scope covers all of the code below in the script. Variable scope is just another word for when the variable can be accessed in your script.\n\nThere are two types of variables which you’ll hear about, local and global. The variables we’ve made in this tutorial so far have been global variables, which means they can be accessed in all code below inside the script. Local variables will be covered later in this tutorial, but in simplest terms, they have a much more limited scope.\n\nVariables do not only have to be named “variable” when assigned to a given piece of code. In fact, your variables have to be different names in order for the program to recognize which variable you want it to use in the script.\n\nWhile you can almost freely name your variables, there are a few restrictions that exist inside Lua.\n\nYou can use:\n\nYou can not use:\n• Capital letters as the first letter of the variable (Not required, but common practice)\n• Numbers as the first letter of the variable\n\nComments are a simple green text that organize and give context to your lines of code, which can be a useful tool for yourself or others if you plan on sharing it.\n\nCreating comments is extremely easy, add - - and then your text after you are finished. It should appear something like this.\n\nIf you want your comment to cover more than one line, insert brackets, with your text inside.\n\nAny text attached to the comment will not be executed by the program, and will only be seen by the reader. This green text is helpful in case you want to find a specific piece of code in your script. Comments are also crucial if you plan on sharing your scripts and want the reader to understand what certain commands do. Besides context, you can use comments to credit yourself for your script, or write out directions that the user who uses your script might want to see.\n\nIf you want to change the settings (such as the transparency, or invisibility) of an object in the workspace, you have to write down the specifics before Lua knows what you want it to do.\n\nSo, if we want to change the transparency of the baseplate, we first need to define that the baseplate is inside game.Workspace, with game being the game we’re working on and workspace being the place where baseplate and the rest of our parts are stored. Then, we write the object we’ll be changing (baseplate) and the setting that we want to change (its transparency), and then assign a value to it. If we want it to be fully invisible, we’ll set the value to one, lowering this amount will make it so that it’s semi-transparent.\n\nIn the end, this should make the baseplate completely invisible if we run the code or play the game. Keep in mind that we can change the properties of object in Studio as long as you define it correctly in the code.\n\nWhen you’re writing a sequence of code that needs to be repeated, it may be a little tedious and also messy to write it out several times. Functions are a tool in Lua that we can use to put lines of different code in, which can be repeated and manipulated a lot easier by us. The functions in this segment are not to be confused with the built-in functions of Lua, such as print.\n\nTo define a function, we need to write function and then assign it a name. Then, add a pair of parenthesis after your function name without any spacing in-between, and press enter. I’ll be naming my function printStuff, but you can name yours differently.\n\nNow, we need to write our code for our function to actually execute it. You’ll notice that when you press enter after writing your function, you’ll automatically get end. This statement is here so that you can end, or close off your function, otherwise Lua would get an error.\n\nI want to print several strings, so I’ll insert the several sequences of code inside my function.\n\nWe now have our function, however, nothing will be happen since we haven’t written the command to execute it. We need to type the function name on the next line, and Lua will print our strings.\n\nNow, Lua will execute our code. If we paste all of the content into the command bar, we’ll see that our function is successful. It’s important to note that just like variables, functions need to defined before we actually execute them in our code, otherwise we’ll just get nil.\n\nWhen we covered local variables previously in our tutorial, I mentioned that the scope of it was much more limited. Whereas global variables can be accessed anywhere in our script after being defined, local variables are limited to a block.\n\nSo what is a code block? An example is basically the indented sequence of code that we see in our function. I’ll attach comments to the parts that are a part of the block of code for a visual demonstration.\n\nYou can also tell if something is a block by the small arrow that appears to the left. If you look closely, the arrow facing down next to function is indicating that the block is being shown, and when it is facing up, it means it is closed.\n\nIf we try to print the local variable outside the block, we’ll get nil since the variable can’t be accessed.\n\nA handy feature of functions is the ability to manipulate the variables with ease. You might’ve already noticed the pair of parenthesis when we define the function, and the two other parenthesis when we execute it. These are the spaces where we put our arguments and parameters.\n\nEvery time we execute a function, we might want to change certain parts of the code each time. Parameters are used to tell Lua which variables (and thus any information) inside the function you want to change. They are established when we first define our function, and are placed in-between the first pair of parenthesis on the same line. Make sure to not define the variable you’ll be changing inside of your function, otherwise the parameter will not work.\n\nNow that we’ve defined the parameter, we need to write an argument for the function to be properly executed. An argument is the value we assign the code when executing it. It comes inside our next pair of parenthesis, and can be changed every time we execute the function separately. We’ll print a string and a number, and the program should treat the argument as the variable in the function.\n\nNow if we put it in the output, the two values should be successfully printed.\n\nArguments and parameters aren’t just limited to a single pair, in fact there can be as many as you want. In order to add another pair, separate each parameter and argument by a comma with the next one you want in your function.\n\nNow if we paste it into our command bar, the output should print both statements in the order we gave them. It is important that you put the arguments and parameters in the same order or you will assign the wrong value to the variable. Also, you always have to define your parameters when you execute your function, otherwise Lua will not know what to assign to the variables.\n\nYou might’ve already noticed that below the option to create a script, there is something called a local script. This tutorial won’t go too in-depth about them, but offer a broad summary about its purpose.\n\nLocal scripts are scripts that only affect the user’s client rather than the server. A user’s client is basically what they see, rather than the whole server. So whereas you might be seeing something, your friend playing the same game as you might see something completely different. In comparison, scripts that affect the server are seen by everyone, and not just the individual’s client.\n\nThe concept is a bit difficult to describe by text, and I still can’t do it justice by talking about it in depth, so I urge you to look at this video by TheDevKing to get a better idea of what local scripts are capable of.\n\nYou might’ve heard this word in math class and it is related. Booleans in scripting are the conditions true or false.\n\nWhen comparing values you’ll get a Boolean as well, although you can simply write true or false too.\n\nRelational operators are the operators used to compare values with one another.\n• Equal to, not to be confused with equal which simply assigns something rather than comparing two values: ==\n• Not equal to, which is true if the values are not equal: ~=\n• Greater than or equal to: >=\n• Less than or equal to: <=\n\nNow, let’s take a look at some numbers and see if they represent a true or false boolean\n\nThe first one is false, since the value can only be greater than, and not equal to the other. The next one is true as the values are equal to one another. The last is clearly false, since 8 is not less than the number 2.\n\nIf statements make it so that specific commands only happen if the condition is met, it will execute the code.\n\nFor example, if 5 > 1 the Output will print “Congratulations” since 5 > 1 is true. If the script said 5 < 1 then the script will not print “Congratulations” in Output.\n\nThis is equivalent to saying true instead and will still print our string.\n\nSometimes, our code needs to be repeated in order to produce an outcome we’re looking for. Loops are statements that allow us to repeat code multiple times. They come in several different forms, which we’ll cover in this section of the tutorial.\n\nWhile loops repeat sequences of code while the statement is true. However, when the condition is false, it will not execute the code block. For example, while a variable is less than a certain value, it will continue to print out a string we decide to give it. This is just one of countless things you can do with a while loop, so feel free to get creative if you’re feeling ambitious.\n\nFor our while loop, we’ll assign a number to our variable, x. Afterwards, we go on the next line and write while. This helps Lua understand that it is a while loop, so that when the condition is true, it’ll execute the code block. The do you see after our boolean is simply telling Lua to execute the block of code that is part of the loop when the condition is true.\n\nIn this code, I defined my variable as 10 and made it so that the while loop would continue to run until it was no longer less than a 100. Each time it runs the code, I made it so that it would add 10 to the variable, meaning that once it ran several times, it would no longer execute the code since the condition is false.\n\nNotice the string being printed after the loop. This is not executed until the loop is finished, so not attaching it to the loop can be used to tell us when the loop is finished.\n\nFor loops are able to loop as many times as the user wants. First, we define a variable for the loop, and assign it to a starting and ending value. The loop will continue to repeat until the starting value reaches the end value. While the amount the starting value increases is by 1, you can change it by adding a comma after the end value. Below, is an example of a for loop.\n\nOur loop will now print 1, 6, 11, 16 all the way until 21 where it will stop since it can not go past 25.\n\nHere is the format for the for loop.\n\nA repeat loop repeats the statements assigned to it until a following condition is true.\n\nUnlike a while loop, it runs the statements first before checking if the condition is true.\n\nWriting break at the end of a loop will end the loop if a condition is true. In the example below, break is used to break out of an infinite loop that otherwise keeps running because it is always true.\n\nThis could also work if instead of true we wrote while x < 200 do. The result would be that the loop would end early, ending when x reaches 100 rather than 200.\n\nYou may also hear the term nested loop, which is used to describe a loop with another loop inside of it.\n\nTables are used for storing large sets of data that you might use while creating your script. With tables, you can access and manipulate the data easy, which can come in handy later on. In this section, you’ll be learning about just a single type of tables, arrays.\n\nArrays are simply a list of values compiled in a table. This can include strings, numbers, booleans, functions–pretty much anything that can be used outside the script. To make an array, start by assigning a name of your own to the table.\n\nAfter this first step, you need to assign the data to the table. Assign the table to the data by adding an “=” in between, and write a pair of curly brackets (the second bracket will be automatically typed for you).\n\nNext, you can place all of your values inside of the array. For this tutorial, we’ll place a few strings and numbers together, but you can add more variety to your table if you’re following along. Make sure to separate each value by adding commas in-between them.\n\nIf we want to print specific parts of our array, we can use the index to get what we want. Each value in our array has an index, or number assigned to it. The first value is 1, second value is 2, third value is 3, etc. To print a specific part of our array, we put our table name in the print function, then follow it up with the index of the value, in-between brackets ([]).\n\nIn the end, this should print out our first string, “Hello World” in the output.\n\nWhere Else Can I Learn About Scripting?\n\nThere are many other places to learn, but the sources listed above have helped me with learning or adapting to Lua.\n\nWhat is the Difference Between Input and Output?\n\nInput is the code given to the engine, while output is the received/finished command. For example, print(“YellowNoobs!”) is a input while YellowNoobs is the output.\n\nStopping exploiters isn’t a beginner issue, it is a little more advanced than what we’ve discussed so far. Throughout your scripting career, you’ll realize that the main reason for exploits is due to poor and weak scripts that hackers are able to bypass.\n\nOne feature that Roblox automatically now applies to all games is FilteringEnabled, which prevents hackers from messing with the server itself. To learn more about how it works, you can watch the following video by AlvinBlox,\n\nWhy does Studio Automatically Indent for me?\n\nTechnically, indenting is not necessary, but it is extremely helpful and keeps your code organized. For example, through indents, you can see where your code blocks are. Not only that, but it looks much cleaner. Writing without proper indentation would give both you and the programmers reviewing your code a headache to read.\n\nHow do I become better?\n\nPractice, practice makes perfect, no exceptions. Learning to program unique things by yourself is always something you should strive to achieve as a developer.\n\nThat’s it, the basic tutorial is now finally finished! Hopefully, now you’ll have a far easier time being able to understand new concepts and can use this as a reference whenever you feel stuck.\n\nIf you have any other questions or feedback, please reply in the comments below, good luck!"
    },
    {
        "link": "https://github.com/Roblox/Core-Scripts/blob/master/PlayerScripts/StarterPlayerScripts/ControlScript/MasterControl/Gamepad.lua",
        "document": "raised from 14% on 3/1/16 to accommodate looser XB360 controllers\n\nnothing is connected, at least set up for gamepad1\n\nif the gamepad supports thumbsticks, theres no point in having the dpad buttons getting eaten up by these actions"
    },
    {
        "link": "https://devforum.roblox.com/t/use-of-getservice/204362",
        "document": "This is a pretty simple question not too much detail.\n\nWhats the advantages and disadvangrages of using:\n\n game:GetService(“”)\n\n vs\n\n just game._________\n\nWhat does it do differently and should I use :GetService() when ever I’m getting the core game pieces?"
    },
    {
        "link": "https://github.com/Roblox/Core-Scripts/blob/master/PlayerScripts/StarterPlayerScripts/CameraScript/ClickToMove.lua",
        "document": "Minus and plus 2 is so we can get it into the cell-corner space and then translate it back into cell-center space\n\nLets try again with a slightly set back start point; it is ok to do this again so the FailFinishNotEmpty uses little computation\n\nHeuristic should be something along the lines of distance and closeness to the traveling direction"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService/CreatePath",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628",
        "document": "DISCLAIMER: THIS THREAD IS OLD AND OUTDATED, REFER TO THE NEWEST VERSION OF THIS THREAD: How To Use Roblox Pathfinding Service 2.0\n\nHello everyone! This is my first tutorial. Please correct me anything if I taught something wrong.\n\nIn this post, I will be teaching you guys on how to use the Pathfinding service in Roblox! This tutorial is specially for people who are decent at scripting and new to this service. Anyway without ay further ado...\n\nWhat the heck is Pathfinding service? In Roblox, PathfindingService is a service used to find a clear path between 2 points/destination. Imagine an NPC that can walk with this service. Pretty uninteresting right? Well, with PathfindingService, the NPC will find a clear path to walk to it’s destination without getting stuck at blocking obstacles. This will make the NPC smart enough to get to a specific position.\n\nThis is because, as I’ve stated earlier, PathfindingService allows an NPC to find a clear path between 2 destination points. If you get the idea, a clear path means a path with nothing to block the path. You might be asking, why can’t we just use the MoveTo() function from the humanoid instead? This is because MoveTo() function will ONLY find the fastest path, which is a straight line, from one point to an end point. This makes it hard for the NPC to reach because imagine there’s gaps between the path, blocking obstacles, jumping platforms and even more! With PathfindingService, this issue will be resolved.\n\nHow can we use it? Glad you asked! Follow the steps below.\n• Make sure you use a server script for this, and maybe try to parent it in a NPC model so we can script more easily.\n• Remove the code inside it and get the service of it.\n• Now, let’s create some variables for the NPC’s root part, humanoid and the destination/position we want it to walk to. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead.\n• Cool! Now we can start the real stuffs here. We need to create a path so we can tell the NPC to walk to that destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath()\n• Alright, now we need to give the two points to the path variable so that we will successfully create a path between the starting point and the ending point. Okay, you might be a bit confused. But let me explain. We re calling our path variable and then we use a function called ComputeAsync() which will create a clear path between 2 points. The first parameter of the function is the starting point of our path, in this case we use rootPart.Position as the starting point, then we use destination as our ending point of the path, which is the second argument we need to pass in this function. NOTE: IF YOU'RE NOT USING VECTOR3 AS THE DESTINATION, YOU CAN USE A PART'S POSITION AS THE ENDING POINT. MAKE SURE TO ADD .Position !!! WHICH WILL BE LIKE ComputeAsync(rootPart.Position,part.Position).\n• Now that we have computed the path, it will provide a series of waypoints, which we will tell the NPC to move to each waypoint until it reached it’s destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints()\n• Now, we will use a for loop so that we can tell the NPC to move to each waypoint after they’ve reached the previous ones. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints() for i,v in pairs(waypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end Okay, so what we did is, for every waypoint that’s being iterated in the table of waypoints, we tell the NPC to move to that waypoint using MoveTo(). The gaps between each waypoint is small enough for the NPC to walk to the next waypoint in a straight line. Then, you’ll notice there’s an if statement to it. This checks if whether the NPC reaches a waypoint that needs the humanoid to jump or not. Waypoints have a property called Action and this have 2 values, Jump and Walk. The waypoint will determine whether it’s action is either Jump or Walk. So, we use an if statement to check if the action is jump using an enumeration of PathWaypointAction. If it’s true, we will set the humanoid’s jump to true. And this should work now! Play the game and see the magic happens. Due to my trashy laptop, I’m unable to record it working in Roblox Studio. And there you go! You successfully make a smart NPC!\n\nWait! How can we make it so that when it handles blocked paths? This got me hard when I was trying to find a solution of it. While you can actually use path.Blocked event, I can’t manage to find how to use this event to handle this issue. But, the best thing we can solve this issue is to create a new path and compute it constantly. So for this, we will use RunService.Heartbeat as an alternative way for while true do loop. Then, instead of making a script that’s not good-looking, we will create functions which will do a separate job. So we will create a function that creates a path and returns it, then another function which will tell the NPC to move to each waypoints. The key is to tell the script to constantly create a new path, and compute it, as creating a path and compute it only once only keeps that path forever, so if we do this method, it will create a new clear path constantly. So if you want the full code instead of just trying to create the functions by yourself, here it is. NOTE: I wouldn’t recommend you guys to copy this code. Try to be creative and use your brain instead! local pathfinding = game:GetService(\"PathfindingService\") local run = game:GetService(\"RunService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local hum = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local function GetPath(destination) local path = pathfinding:CreatePath() if typeof(destination) == \"Vector3\" then -- This line is untested yet. Please tell me if it works. path:ComputeAsync(rootPart.Position,destination) else path:ComputeAsync(rootPart.Position,destination.Position) end return path end local function WalkToWaypoints(tableWaypoints) for i,v in pairs(tableWaypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end end local function WalkTo(destination) local path = GetPath(destination) if path.Status == Enum.PathStatus.Success then -- the path will return either success as true value or nopath as false value if it's computed. WalkToWaypoints(path:GetWaypoints()) end end run.Heartbeat:Connect(function() WalkTo(destination) end)\n\nThank you for reading my post! Again, please leave feedbacks and any mistakes and corrections under this post. I will update the post if I did anything wrong.\n\nEDIT 1: I made a spelling mistake while spelling humanoid in the scripts. I accidentally spell it hum as humanoid. If you wanna change it, you can use Ctrl + H or Cmd + H while typing in the script to change these spellings immediately. Sorry for the mistake!"
    }
]