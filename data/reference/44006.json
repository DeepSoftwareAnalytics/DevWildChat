[
    {
        "link": "https://docs.mql4.com",
        "document": "MetaQuotes Language 4 (MQL4) is a built-in language for programming trading strategies. This language is developed by MetaQuotes Ltd. based on their long experience in the creation of online trading platforms. Using this language, you can create your own Expert Advisors that make trading management automated and are perfectly suitable for implementing your own trading strategies. Besides, using MQL4 you can create your own technical indicators (custom indicators), scripts and libraries. MQL4 contains a large number of functions necessary for analyzing current and previously received quotes, and has built-in basic indicators and functions for managing trade orders and controlling them. The MetaEditor (text editor) that highlights different constructions of MQL4 language is used for writing the program code. It helps users to orientate themselves in the expert system text quite easily. The brief guide contains functions, operations, reserved words, and other language constructions divided into categories, and allows finding the description of every used element of the language. Programs written in MetaQuotes Language 4 have different features and purposes:\n• None is a mechanical trading system linked up to a certain chart. An Expert Advisor starts to run when an event happens that can be handled by it: events of initialization and deinitialization, event of a new tick receipt, a timer event, depth of market changing event, chart event and custom events. \n\n An Expert Advisor can both inform you about a possibility to trade and automatically trade on an account sending orders directly to a trade server. Expert Advisors are stored in\n• None is a technical indicator written independently in addition to those already integrated into the client terminal. Like built-in indicators, they cannot trade automatically and are intended for implementing of analytical functions only.\n• None is a program intended for a single execution of some actions. Unlike Expert Advisors, scripts do not process any actions, except for the start event (this requires the OnStart handler function in a script). Scripts are stored in\n• None is a set of custom functions intended for storing and distributing frequently used blocks of custom programs. Libraries cannot start executing by themselves.\n• None is a source text of the most frequently used blocks of custom programs. Such files can be included into the source texts of Expert Advisors, scripts, custom indicators, and libraries at the compiling stage. The use of included files is more preferable than the use of libraries because of additional burden occurring at calling library functions. \n\n Include files can be stored in the same directory as a source file - in this case the #include directive with double quotes is used. Another place to store include files is terminal_directory\\MQL4\\Include, in this case the #include directive is used with angle brackets."
    },
    {
        "link": "https://docs.mql4.com/customind",
        "document": "This is the group functions used in the creation of custom indicators. These functions can't be used when writing Expert Advisors and Scripts. The function sets a flag hiding indicators called by the Expert Advisor Sets the value of an indicator property of the double type Sets the value of an indicator property of the int type Sets the value of an indicator property of the string type Binds the specified indicator buffer with one-dimensional dynamic array of the double type Allocates memory for buffers used for custom indicator calculations Returns the amount of bars not changed after the indicator had been launched last Sets the \"short\" name of a custom indicator to be shown in the DataWindow and in the chart subwindow Sets an arrow symbol for indicators line of the DRAW_ARROW type Sets the bar number from which the drawing of the given indicator line must start Sets drawing line description for showing in the DataWindow and in the tooltip Sets the new type, style, width and color for a given indicator line Sets a new style, width and color of horizontal levels of indicator to be output in a separate window Sets a value for a given horizontal level of the indicator to be output in a separate window Indicator properties can be set using the compiler directives or using functions. To better understand this, it is recommended that you study indicator styles in examples. All the necessary calculations of a custom indicator must be placed in the predetermined function OnCalculate(). MQL4 programmers have 8 buffers and 6 drawing styles to develop custom indicators. In MQL5, this set has been significantly increased up to 512 indicator buffers and 18 drawing styles. In addition, timeseries indexing (calculation from present to past) is not necessary to calculate indicator values. Such an approach is very convenient for developing EAs, but it causes difficulties when working with indicator buffers in loops. Now you are able to set the indexing direction in the arrays on your own, which greatly simplifies the development of indicators. Another notable feature of MQL5 is the dynamic change of the drawing style using the PlotIndexSetXXX functions. For example, an indicator's color, style, line width, as well as an arrow's color and code can be changed on the fly if a certain condition occurs. Also, added the OnCalculate() handler allowing to calculate indicator values based on another indicator. Thus, in MQL5, custom indicators can be superimposed on other indicators (for example, TEMA from MACD) allowing users to receive new combinations of indicators to quickly test ideas without programming."
    },
    {
        "link": "https://book.mql4.com/samples/icustom",
        "document": "When creating a trading strategy a developer often faces the necessity to draw graphically in a security window a certain dependence calculated by a user (programmer). For this purpose MQL4 offers the possibility of creating custom indicators. Custom Indicator is an application program coded in MQL4; it is basically intended for graphical displaying of preliminarily calculated dependences. \n\n \n\n \n\n The main principle underlying custom indicators is passing values of indicator arrays to a client terminal (for drawing indicator lines) via exchange buffers. Buffer is a memory area containing numeric values of an indicator array. MQL4 standard implies the possibility of drawing up to eight indicator lines using one custom indicator. One indicator array and one buffer are brought into correspondence with each indicator line. Each buffer has its own index. The index of the first buffer is 0, of the second one - 1, and so on, the last one has the index 7. Fig. 115 shows how the information from a custom indicator is passed via buffers to a client terminal for drawing indicator lines. \n\n Fig. 115. Passing values of indicator arrays via a buffer to a client terminal. \n\n The general order of building indicator lines is the following: 1. Calculations are conducted in a custom indicator; as a result numeric values are assigned to indicator array elements. 2. Values of indicator array elements are sent to a client terminal via buffers. 3. On the bases of value arrays received from buffers a client terminal displays indicator lines. \n\n \n\n Let's analyze a simple custom indicator that shows two lines - one line is build based on maximal bar prices, the second one uses minimal prices. \n\n Let's analyze in details the indicator parts. In any application program written in MQL4 you can indicate setup parameters that provide the correct program servicing by a client terminal. In this example the head program part (see Program Structure) contains several lines with directives #property . The first directive indicates in what window the client terminal should draw the indicator lines: In MQL4 there are two variants of drawing indicator lines: in the main security window and in a separate window. Main window is the window containing a security chart. In this example parameter indicator_chart_window in #property directory indicates that a client terminal should draw indicator lines in the main window. The next line shows the number of buffers used in the indicator: In the analyzed example two indicator lines are drawn. One buffer is assigned to each buffer, so the total number of buffers is two. The next lines describe colors of the indicator lines. Parameters indicator_color1 and indicator_color2 define color setting for corresponding buffers - in this case for buffers with indexes 0 (Blue) and 1 (Red). Note that figures in parameter names indicator_color1 and indicator_color2 are not buffer indexes. These figures are parts of constant names that are set in accordance with buffers. For each constant color can be set at the discretion of a user. In the next line indicator arrays are declared: The indicator is intended for drawing two indicator lines, so we need to declare two global one-dimension arrays, one for each line. Names of indicator arrays are up to user. In this case array names Buf_0[] and Buf_1[] are used, in other cases other names can be used, for example, Line_1[],Alfa[], Integral[] etc. It is necessary to declare arrays on a global level, because array elements values must be preserved between calls of the special function start(). The described custom indicator is built on the basis of two special functions -init() and start(). The function init() contains the part of code used on the program only once (see Special functions). A very important action is performed in the line: Using the function SetIndexBuffer() a necessary buffer (in this case with the index 0) is put into correspondence with an array (in this case Buf_0). It means for constructing the first indicator line a client terminal will accept data contained in the array Buf_0 using the zero buffer for it. Further the line style is defined: For the zero buffer (0) a client terminal should use the following drawing styles: simple line (DRAW_LINE), solid line (STYLE_SOLID), line width 2. The next two lines contain settings for the second line: Thus, according to the code of the special function init() both indicator lines will be drawn in the main security window. The first one will be a solid blue line with the width 2, the second one is a red dotted line ( STYLE_DOT) of a usual width. Indicator lines can be drawn by other styles as well (see Styles of Indicator Lines). \n\n Values of indicator arrays elements are calculated in the special function start(). To understand correctly the contents of start() code pay attention to the order of indexing bars. The section Arrays describes in details the method of indexing arrays-timeseries. According to this method bar indexing starts from zero. The zero bar is a current yet unformed bar. The nearest bar's index is 1. The next one's is 2 and so on. As new bars appear in a security window, indexes of already formed (history) bars are changed. The new (current, just formed, rightmost) bar gets the zero index, the one to the left of him (that has just fully formed) gets the index 1 and values of indexes of all history bars are also increased by one. The described method of indexing bars is the only one possible for the whole on-line trading system MetaTrader, and it is taken into account when drawing lines using both technical and custom indicators. It was said earlier that indicator lines are constructed on the basis of numeric information contained in indicator arrays. An indicator array contains information about dots coordinates upon which an indicator line is drawn. And the Y coordinate of each dot is the value of an indicator array element, and X coordinate is the value of an indicator array element index. In the analyzed example the first indicator line is drawn using maximal values of bars. Fig, 116 shows this indicator line (of blue color) in a security window, it is built on the basis of the indicator array Buf_0. Fig. 116. Correspondence of coordinates of an indicator line to values of an indicator array. Index value of an indicator array is out by a client terminal into correspondence with a bar index - these index values are equal. It must be also taken into account that the process of constructing indicator lines goes on in real time mode under conditions when in a security window new bars appear from time to time. And all history bars are shifted to the left. To have the indicator line drawn correctly (each line dot above its bar) it must also be shifted together with bars. So there is need (technical need) to re-index an indicator array. The fundamental difference of an indicator array from a usual array is the following: At the moment when a new bar is created, index values of indicator array elements are automatically changed by the client terminal, namely - value of each indicator array index is increased by one and the indicator array size is increased by one element (with a zero index). For example, the zero bar in Fig. 116 (timeframe H1) has the opening time 6:00. At 7:00 a new bar will appear in the security window. The bar opened at 6:00 will automatically get the index 1. To have the indicator line drawn correctly on this bar, the client terminal will change the index of the indicator array element corresponding to the bar opened at 6:00. In the table in Fig. 116 this element is written in the first line. Together with that indexes of all array elements will be increased by the client terminal by one. An the index of the array element corresponding to the bar opened at 6:00 will get the value 1 (before that it was equal to 0). The indicator array will become larger by one element. The index of a new added element will be equal to 0, the value of this element will be a new value reflecting coordinate of the indicator line on a zero bar. This value is calculated in the special function start() on each tick. Calculations in the special function start() should be conducted so that no extra actions were performed. Before the indicator is attached to a chart, it does not reflect any indicator lines (because values of indicator arrays are not defined yet). That's why at the first start of the special function start() indicator array values must be calculated for all bars, on which the indicator line should be drawn. In the analyzed example these are all bars present on a chart (the initial calculations can be conducted not for all available bars, but for some last part of history; it is described in further examples). Ar all further starts of the special function start() there is no need to calculate values of indicator array for all bars again. These values are already calculated and are contained in the indicator array. It is necessary to calculate the current value of the indicator line only on each new tick of the zero bar. For the implementation of the described technology there is a very useful standard function in MQL4 - IndicatorCounted() . This function returns the number of bars that have not changed since the last indicator call. If the indicator has never been attached to a chart, at the first start() execution the value of Counted_bars will be equal to zero: It means the indicator array does not contain any element with earlier predefined value, that is why the whole indicator array must be calculated from beginning to end. The indicator array is calculated from the oldest bar to the zero one. Index of the oldest bar, starting from which calculations must be started, is calculated the following way: Suppose at the moment of attaching the indicator there are 300 bars in a chart window. This is the value of the predefined variable Bars. As defined earlier, Counted_bars is equal to 0. So, as a result we obtain that i index of the first uncounted bar (the latest one, starting from which calculations should be conducted) is equal to 299. All values of indicator array elements are calculated in the loop while(): While i is within the range from the first uncounted bar (299) to the current one (0) inclusively, values of indicator array elements are calculated for both indicator lines. Note, missing values of indicator array elements are calculated during one (the first) start of the special function start(). During calculations the client terminal remembers elements, for which values were calculated. The last iteration in while() is performed when i is equal to 0, i.e. values of indicator arrays are calculated for the zero bar. When the loop is over, the special function start() finishes its execution and control is passed to the client terminal. The client terminal in its turn will draw all (in this case two) indicator lines in accordance with the calculated values of array elements. On the next tick start() will be started by the client terminal again. Further actions will depend on the situation (we will continue analyzing the example for 300 bars). Variant 1. A new tick comes during the formation of the current zero bar (the most common situation). \n\n Fig. 117. The processed tick belongs to the current bar. \n\n Fig. 117 shows two ticks received by the terminal at moments of time t 1 and t 2. The analyzed situation will be the same for both ticks. Let's trace the execution of start() that was launched at the moment t 2. During the execution of the function start() the following line will be executed: IndicatorCounted() will return the value 299, i.e. since the last start() call 299 previous bars were not changed. As a result i index value will be equal to 0 (300-299-1): It means in the next while() loop the values of array elements with the zero index will be calculated. In other words, the new position of an indicator line on the zero bar will be calculated. When the cycle is finished, start() will stop executing and will pass control to the client terminal. Variant 2. A new tick is the first tick of a zero bar (happens from time to time). \n\n Fig. 118. The processed tick is the first tick of a new zero bar. \n\n In this case the fact of appearance of a new bar is important. Before control is passed to the special function start(), client terminal will draw again all bars present in the security window and re-index all declared indicator arrays (set in correspondence with buffers). Besides, client terminal will remember that there are already 301 bars, not 300 in a chart window. Fig. 118 contains situation when on the last tick of the previous bar (at the moment t 2) the function start() was successfully started and executed. That's why, though now the first bar (with index 1) finished at the moment t 2 was calculated by the indicator, function IndicatorCounted() will return value that was on the previous bar, i.e. 299: In the next line index i will be calculated, in this case for the first tick of a new bar it will be equal to 1 (301-299-1): It means calculation of indicator array values in while() loop at the appearance of a new bar will be performed both for the last bar and for the new zero bar. A little earlier during re-indexation of indicator arrays the client terminal increased sizes of these arrays. Values of array elements with zero indexes were not defined before the calculations in the loop. During calculations in the loop these elements get some values. When calculations in start() are over, control is returned to the client terminal. After that the client terminal will draw indicator lines on the zero bar based on just calculated values of array elements with zero indexes. Variant 3. A new tick is the first tick of a new zero bar, but the last but one tick is not processed (rare case). \n\n Fig. 119. Not all ticks of the previous bar were processed. \n\n Fig. 119 shows the situation when start() was launched on the first tick of a new bar at the moment t 5. Previous time this function was started at the moment t 2. Tick that came to the terminal at the moment t 3 (red arrow) was not processed by the indicator. This happened because start() execution time t 2 - t 4 is larger than the interval between ticks t 2 - t 3. This fact will be detected by the client terminal during the execution of start() launched at the moment t 5. During calculations in the line: IndicatorCounted() will return the value 299 (!). This value is true - from the moment of the last indicator call 299 bars were not changed after (now already) 301. That is why the calculated index of the first (leftmost) bar, from which calculations of array element values must be started, will be equal to 1 (301-299-1): it means during while() execution two iterations will be performed. During the first one values of array elements with the index i = 1 will be calculated, i.e. Buf_0[1] and Buf_1[1]. Not, by the moment calculations start, bars and indicator arrays are already re-indexed by the client terminal (because a new bar started, between starts of the special function start()). That is why calculations for elements of arrays with index 1 will be calculated on the basis of array-timeseries (maximal and minimal values of a bar price) also with the index 1: During the second iteration of while() values for elements with zero indexes, i.e. for the zero bar, is calculated on the basis of last known values of arrays-timeseries. Using of the described technology for the calculation of custom indicators allows, first, to guarantee calculation of values of all indicator array elements irrespective of the specific nature of tick history, and second, to conduct calculations only for uncounted bars, i.e. use economically calculating resources. Not, a bar is considered uncounted if calculation of element values of an indicator arrays at least for one last tick of the bar is not performed. Starting the custom indicator userindicator.mq4 in a chart window you will see two lines - a thick blue line built upon bar maximums and a dotted red line built upon its minimums (Fig. 120). \n\n Fig. 120. Two indicator lines in a security window, built by the indicator userindicator.mq4. It should be noted, that one can built a custom indicator, indicator lines of which would coincide with the lines of an analogous technical indicator. It can be easily done if as calculation formulas in the custom indicator, the same formulas as in the technical indicator are used. To illustrate this let's improve the program code analyzed in the previous example. Let the indicator draw lines upon average values of maximums and minimums of several last bars. It is easy to conduct necessary calculations: we simply need to find average values of arrays-timeseries elements. For example, value of an indicator array with the index 3 (i.e. indicator line coordinate for the third bar) on the basis of the last five maximums is calculated the following way: Analogous calculations can be performed for an indicator lines built upon minimums. Example of a simple custom indicator averagevalue.mq4. Indicator lines are built upon average minimal and maximal values of N bars. In this example there is an external variable Aver_Bars. Using this variable a user can indicate the number of bars, for which an average value is calculated. In start()this value is used for the calculation of an average value. In the loop 'for' the sum of maximal and minimal values is calculated for the number of bars corresponding to the value of the variable Aver_Bars. In the next two program lines values of indicator array elements are calculated for indicator lines corresponding to minimal and maximal values. The averaging method used here is also applied for calculations in the technical indicator Moving Average. If we attach the analyzed custom indicator averagevalue.mq4 and the technical indicator Moving Average, we will see three indicator lines. If the same period of averaging is set up for both indicators, Moving Average line will coincide with one of the custom indicator lines (for this purpose parameters described in Fig. 121 must be specified in the technical indicator settings). Thus, using technical indicator a user can construct the reflection of any regularities necessary in practical work. \n\n \n\n MQL4 offers a large service for constructing custom indicators which makes using them very convenient. In particular, indicator lines can be drawn in a separate window. This is convenient when absolute values of the indicator line amplitude is substantially smaller (or larger) than security prices. For example, if we are interested in the difference between average values of bar maximums and minimums in a certain historic interval, depending on timeframe this value will be equal to approximately from 0 to 50 points (for example, for M15). It is not difficult to build an indicator line, but in a security window this line will be drawn in the range 0 - 50 points of a security price, i.e. substantially lower than the chart area reflected on the screen. It is very inconvenient. To draw indicator lines in a separate window (which is in the lower part of a security window), in the directive #property (at the program beginning) parameter indicator_separate_window must be specified: At the moment when such an indicator is attached to a security window, client terminal creates a separate window below a chart, in which indicator lines calculated in the indicator will be drawn. Depending on color settings and types of indicator lines they will be drawn in this or that style. \n\n In most cases indicator lines contain useful information only in the most recent history. The part of indicator lines built upon old bars (for example, 1 month old minute timeframe) can hardly be considered useful for making trade decisions. Besides, if there are a lot of bars in a chart window, time invested into the calculation and drawing of indicator lines is unreasonably large. This may be critical in program debugging, when a program is often compiled and then started. That is why it is necessary to conduct calculations not for the whole history, but for the limited part of the most recent bar history. For this purpose an external variable history is used in the following program. Value of this variable is taken into account when calculating index of the first (leftmost) bar, starting from which elements of indicator arrays must be calculated. Further calculations in while() loop will be conducted for the number of recent history bars not larger than History value. Note, the analyzed method of limiting a calculation history concerns only the part of calculations that are conducted in the first start of the special function start(). Further, when new bars appear, new parts of indicator lines will be added in the right part, while the image in the left part will be preserved. Thus the indicator line length will be increased during the whole indicator operation time. Common value of History parameter is considered approximately 5000 bars. \n\n Example of a simple custom indicator separatewindow.mq4. Indicator lines are drawn in a separate window. Similar calculation of an indicator line is performed in the technical indicator AverageTrue Range. Fig. 122 shows an indicator line constructed by the custom indicator separatewindow.mq4 in a separate window and an indicator line constructed by ATR in another window. In this case lines are fully identical because period of averaging is the same for both indicators - 5. If this parameter is changed in any of the indicators, the corresponding indicator line will also change. \n\n Fig. 122. drawing a custom indicator line in a separate window.\n\n Identical lines of a technical indicator (ATR) and a custom indicator (separatewindow.mq4). \n\n It is also evident that custom indicator line is constructed not for the whole screen width, but for 50 latest bars as specified in the external variable History. If a trader needs to use larger history interval, value of the external variable can be easily changed via the custom indicator settings window. Fig. 123 shows a security window, in which the indicator line us drawn in another style - as a histogram. For getting such a result one line was changed in the program code separatewindow.mq4 - other line styles are indicated: All other code parts are unchanged. \n\n Fig. 123. Drawing custom indicator line in a separate window (histogram).\n\n Similarity of drawings of a technical indicator (ATR) and a custom indicator (separatewindow.mq4). \n\n \n\n In some cases it is necessary to shift an indicator line. It can be easily done by MQL4 means. Let's analyze an example, in which position of indicator lines in a security window are calculated in accordance with values specified by a user. Example of a custom indicator displacement.mq4. Shifting indicator lines horizontally and vertically. For adjusting lines shift in a chart, there are two external variables - Left_Right for horizontal shift of all lines and Up_Down for shifting two dotted lines vertically. The algorithm used for calculating values of corresponding array elements is based on very simple rules:\n• for shifting a line horizontally, assign the calculated value to an array element, the index of which is larger by Left_Right (for shifting to the right and less for shifting to the right) than the index of a bar, for which calculations are conducted;\n• for shifting a line vertically, Up_Down*Point must be added (for shifting upwards or detracted for shifting downwards) to each value of an indicator array characterizing initial line position; In the analyzed example indexes are calculated in the line: Here i is the index of a bar, for which calculations are performed, k is an index of an indicator array element. Red indicator line displayed by the client terminal based on the indicator array Line_0[] is shifted to the left by 5 bars (according to custom settings, see Fig. 124) from the initial line. In this case the initial line is a Moving Average with the period of averaging equal to 5; the formula of MA calculation is (High[i]+Low[i])/2 . In this example the position of the red line is the basis for the calculation of indicator array values for two other lines, i.e. their position on the chart. Dotted lines are calculated this way: Use of index k for elements of all indicator arrays allows to perform calculations for elements of arrays Line_1[], Line_2[] on the same bar as used for calculating values of the corresponding basic array Line_0[]. As a result dotted lines are shifted relative to the red line by the value specified in the indicator settings window, in this case by 30 points (Fig. 124). \n\n Fig. 124. Red indicator line is shifted to the left by 5 bars.\n\n Dotted indicator lines are shifted relative to the red line by 30 points. \n\n There are some limitations in MQL4 that should be taken into account in the programming of custom indicators. There is a group of functions that can be used only in custom indicators and cannot be used in Expert Advisors and scripts: IndicatorBuffers(), IndicatorCounted (), IndicatorDigits(), IndicatorShortName(), SetIndexArrow(), SetIndexBuffer(), SetIndexDrawBegin(), SetIndexEmptyValue(), SetIndexLabel(), SetIndexShift(), SetIndexStyle(), SetLevelStyle(), SetLevelValue(). On the other hand, trade functions cannot be used in indicators: OrderSend(), OrderClose(), OrderCloseBy(), OrderDelete() and OrderModify(). This is because indicators operate in the interface flow (as distinct from Expert Advisors and scripts that operate in their own flow). This is also why algorithms based on looping cannot be used in custom indicators. Start of a custom indicator containing an endless loop (in terms of actual execution time) can result in client terminal hanging up with further necessity to restart a computer. The general comparative characteristics of Expert Advisors, scripts and indicators is contained in Table 2."
    },
    {
        "link": "https://metatrader4.com/en/trading-platform/help/autotrading/custom_indicators",
        "document": "Custom indicator is a program independently developed in MetaQuotes Language 4 by the user and functioning as a technical indicator. Technical indicator is a mathematical transformation of security price and/or volume in order to forecast future price changes. The use of indicators allows to answer the question about whether the current trend will remain the same and where it will turn. Indicators are intended for relative simplifying of the complicated process of trading decision making. Algorithms of indicators are also used for development of trading tactics and expert advisors.\n• To create and compile custom indicators, one has to use the built-in \"MetaEditor\" . It is a constituent of the client terminal and represents a convenient development environment of MQL4 programs.\n• Before using of custom indicators, one has to set them up first. Working parameters common for all indicators are defined in the window of client terminal settings . Besides, every indicator can have its own settings.\n• Parameters of the indicator are calculated and the indicator itself is drawn when imposed into the chart.\n• If there is no need of an indicator anymore, the indicator can be deleted from the chart.\n\nIn the new terminal, the number of built-in technical indicators has been increased from 30 to 38, while the number of drawing styles of custom indicators has been increased 3 times  from 6 to 18. The number of indicator buffers has been expanded from 8 to 512. The indicators themselves can be multi-colored.\n\nFor programmers, the new platform offers ample opportunities and unmatched convenience when developing indicators. MQL5 programs allow performing the efficient calculation of indicator buffers, set colors and display of individual chart elements, add the Chart object (OBJ_CHART) to a symbol chart, draw on the canvas, manage an indicator using the keyboard and mouse, and much more.\n\nWith the indicators, the fifth generation platform's technical analysis features are endless."
    },
    {
        "link": "https://forexrobotfordummies.com/comprehensive-documentation-for-mql4",
        "document": ""
    },
    {
        "link": "https://mql5.com/en/docs/event_handlers/oncalculate",
        "document": "The function is called in the indicators when the Calculate event occurs for processing price data changes. There are two function types. Only one of them can be used within a single indicator.\n\n[in] Size of the price[] array or input series available to the indicator for calculation. In the second function type, the parameter value corresponds to the number of bars on the chart it is launched at.\n\n[in] Contains the value returned by the OnCalculate() function during the previous call. It is designed to skip the bars that have not changed since the previous launch of this function.\n\n[in] Index value in the price[] array meaningful data starts from. It allows you to skip missing or initial data, for which there are no correct values.\n\n[in] Array of values for calculations. One of the price timeseries or a calculated indicator buffer can be passed as the price[] array. Type of data passed for calculation can be defined using the _AppliedTo predefined variable.\n\n[in] Array with spread values for bars.\n\nint type value to be passed as the prev_calculated parameter during the next function call.\n\nIf the OnCalculate() function is equal to zero, no indicator values are shown in the DataWindow of the client terminal.\n\nIf the price data have been changed since the last call of the OnCalculate() function (a deeper history has been loaded or gaps in the history have been filled), the value of the prev_calculated input parameter is set to zero by the terminal itself.\n\nTo define the indexing direction in the time[], open[], high[], low[], close[], tick_volume[], volume[] and spread[] arrays, call the ArrayGetAsSeries() function. In order not to depend on defaults, call the ArraySetAsSeries() function for the arrays to work with.\n\nWhen using the first function type, a necessary timeseries or indicator is selected by a user as the price[] array in the Parameters tab when launching the indicator. To do this, specify the necessary element in the drop-down list of the \"Apply to\" field.\n\nTo get custom indicator values from other mql5 programs, the iCustom() function is used. It returns the indicator handle for subsequent operations. It is also possible to specify the required price [] array or the handle of another indicator. This parameter should be passed the last in the list of input variables of a custom indicator.\n\nIt is necessary to use the connection between the value returned by the OnCalculate() function and the prev_calculated second input parameter. When calling the function, the prev_calculated parameter contains the value returned by the OnCalculate() function during the previous call. This makes it possible to implement resource-saving algorithms for calculating a custom indicator in order to avoid repetitive calculations for the bars that have not changed since the previous launch of this function.\n\n//+------------------------------------------------------------------+ \n\n//| OnCalculate_Sample.mq5 | \n\n//| Copyright 2018, MetaQuotes Software Corp. | \n\n//| https://www.mql5.com | \n\n//+------------------------------------------------------------------+ \n\n#property copyright \"Copyright 2000-2024, MetaQuotes Ltd.\" \n\n#property link \"https://www.mql5.com\" \n\n#property version \"1.00\" \n\n#property description \"Sample Momentum indicator calculation\" \n\n \n\n//---- indicator settings \n\n#property indicator_separate_window \n\n#property indicator_buffers 1 \n\n#property indicator_plots 1 \n\n#property indicator_type1 DRAW_LINE \n\n#property indicator_color1 Blue \n\n//---- inputs \n\ninput int MomentumPeriod=14; // Calculation period \n\n//---- indicator buffer \n\ndouble MomentumBuffer[]; \n\n//--- global variable for storing calculation period \n\nint IntPeriod; \n\n//+------------------------------------------------------------------+ \n\n//| Custom indicator initialization function | \n\n//+------------------------------------------------------------------+ \n\nvoid OnInit() \n\n { \n\n//--- check the input parameter \n\n if(MomentumPeriod<0) \n\n { \n\n IntPeriod=14; \n\n Print(\"Period parameter has an incorrect value. The following value is to be used for calculations \",IntPeriod); \n\n } \n\n else \n\n IntPeriod=MomentumPeriod; \n\n//---- buffers \n\n SetIndexBuffer(0,MomentumBuffer,INDICATOR_DATA); \n\n//---- indicator name to be displayed in DataWindow and subwindow \n\n IndicatorSetString(INDICATOR_SHORTNAME,\"Momentum\"+\"(\"+string(IntPeriod)+\")\"); \n\n//--- set index of the bar the drawing starts from \n\n PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,IntPeriod-1); \n\n//--- set 0.0 as an empty value that is not drawn \n\n PlotIndexSetDouble(0,PLOT_EMPTY_VALUE,0.0); \n\n//--- indicator accuracy to be displayed \n\n IndicatorSetInteger(INDICATOR_DIGITS,2); \n\n } \n\n//+------------------------------------------------------------------+ \n\n//| Momentum indicator calculation | \n\n//+------------------------------------------------------------------+ \n\nint OnCalculate(const int rates_total, // price[] array size \n\n const int prev_calculated, // number of previously handled bars \n\n const int begin, // where significant data start from \n\n const double &price[]) // value array for handling \n\n { \n\n//--- initial position for calculations \n\n int StartCalcPosition=(IntPeriod-1)+begin; \n\n//---- if calculation data is insufficient \n\n if(rates_total<StartCalcPosition) \n\n return(0); // exit with a zero value - the indicator is not calculated \n\n//--- correct draw begin \n\n if(begin>0) \n\n PlotIndexSetInteger(0,PLOT_DRAW_BEGIN,StartCalcPosition+(IntPeriod-1)); \n\n//--- start calculations, define the starting position \n\n int pos=prev_calculated-1; \n\n if(pos<StartCalcPosition) \n\n pos=begin+IntPeriod; \n\n//--- main calculation loop \n\n for(int i=pos;i<rates_total && !IsStopped();i++) \n\n MomentumBuffer[i]=price[i]*100/price[i-IntPeriod]; \n\n//--- OnCalculate execution is complete. Return the new prev_calculated value for the subsequent call \n\n return(rates_total); \n\n }"
    },
    {
        "link": "https://docs.mql4.com/basis/function/events",
        "document": "The MQL4 language provides processing of some predefined events. Functions for handling these events must be defined in a MQL4 program; function name, return type, composition of parameters (if there are any) and their types must strictly conform to the description of the event handler function. The event handler of the client terminal identifies functions, handling this or that event, by the type of return value and type of parameters. If other parameters, not corresponding to below descriptions, are specified for a corresponding function, or another return type is indicated for it, such a function will not be used as an event handler. The OnStart() function is the Start event handler, which is automatically generated only for running scripts. It must be of void type, with no parameters: For the OnStart() function, the int return type can be specified. The OnInit() function is the Init event handler. It must be of void or int type, with no parameters: The Init event is generated immediately after an Expert Advisor or an indicator is downloaded; The OnInit() function is used for initialization. If OnInit() has the int type of the return value, the non-zero return code means unsuccessful initialization, and it generates the Deinit event with the code of deinitialization reason REASON_INITFAILED. OnInit() function execution result is analyzed by the terminal's runtime subsystem only if the program has been compiled using #property strict. To optimize input parameters of an Expert Advisor, it is recommended to use values of the ENUM_INIT_RETCODE enumeration as the return code.. During initialization of an Expert Advisor before the start of testing you can request information about the configuration and resources using the TerminalInfoInteger() function. Successful initialization, testing of the Expert Advisor can be continued. This code means the same as a null value  the Expert Advisor has been successfully initialized in the tester. Initialization failed; there is no point in continuing testing because of fatal errors. For example, failed to create an indicator that is required for the work of the Expert Advisor. This return value means the same as a value other than zero - initialization of the Expert Advisor in the tester failed. This value means the incorrect set of input parameters. The result string containing this return code is highlighted in red in the general optimization table. Testing for the given set of parameters of the Expert Advisor will not be executed The OnInit() function of the void type always denotes successful initialization. The OnDeinit() function is called during deinitialization and is the Deinit event handler. It must be declared as the void type and should have one parameter of the const int type, which contains the code of deinitialization reason. If a different type is declared, the compiler will generate a warning, but the function will not be called. The Deinit event is generated for Expert Advisors and indicators in the following cases:\n• None before reinitialization due to the change of a symbol or chart period, to which the mql4 program is attached;\n• None before reinitialization due to the change of input parameters The NewTick event is generated for Expert Advisors only when a new tick for a symbol is received, to the chart of which the Expert Advisor is attached. It's useless to define the OnTick() function in a custom indicator or script, because the NewTick event is not generated for them. The Tick event is generated only for Expert Advisors, but this does not mean that Expert Advisors required the OnTick() function, since not only NewTick events are generated for Expert Advisors, but also events of Timer, BookEvent and ChartEvent are generated. It must be declared as the void type, with no parameters: The OnTimer() function is called when the Timer event occurs, which is generated by the system timer only for Expert Advisors and indicators - it can't be used in scripts. The frequency of the event occurrence is set when subscribing to notifications about this event to be received by the EventSetTimer() function. You can unsubscribe from receiving timer events for a particular Expert Advisor using the EventKillTimer() function. The function must be defined with the void type, with no parameters: It is recommended to call the EventSetTimer() function once in the OnInit() function, and the EventKillTimer() function should be called once in OnDeinit(). Every Expert Advisor, as well as every indicator works with its own timer and receives events only from it. As soon as the mql4 program stops operating, the timer is destroyed forcibly, if it was created but hasn't been disabled by the EventKillTimer() function. The OnTester() function is the handler of the Tester event that is automatically generated after a history testing of an Expert Advisor on the chosen interval is over. The function must be defined with the double type, with no parameters: The function is called right before the call of OnDeinit() and has the same type of the return value - double. OnTester() can be used only in the testing of Expert Advisors. Its main purpose is to calculate a certain value that is used as the Custom max criterion in the genetic optimization of input parameters. In the genetic optimization descending sorting is applied to results within one generation. I.e. from the point of view of the optimization criterion, the best results are those with largest values (for the Custom max optimization criterion values returned by the OnTester function are taken into account). In such a sorting, the worst values are positioned at the end and further thrown off and do not participate in the forming of the next generation. OnChartEvent() is the handler of a group of ChartEvent events:\n• None CHARTEVENT_KEYDOWN  event of a keystroke, when the chart window is focused;\n• None CHARTEVENT_MOUSE_MOVE  mouse move events and mouse click events (if CHART_EVENT_MOUSE_MOVE =true is set for the chart);\n• None CHARTEVENT_OBJECT_CREATE  event of graphical object creation (if CHART_EVENT_OBJECT_CREATE =true is set for the chart);\n• None CHARTEVENT_OBJECT_CHANGE  event of change of an object property via the properties dialog;\n• None CHARTEVENT_OBJECT_DELETE  event of graphical object deletion (if CHART_EVENT_OBJECT_DELETE =true is set for the chart);\n• None CHARTEVENT_CLICK  event of a mouse click on the chart;\n• None CHARTEVENT_OBJECT_CLICK  event of a mouse click in a graphical object belonging to the chart;\n• None CHARTEVENT_OBJECT_DRAG  event of a graphical object move using the mouse;\n• None CHARTEVENT_OBJECT_ENDEDIT  event of the finished text editing in the entry box of the LabelEdit graphical object;\n• None CHARTEVENT_CUSTOM+n  ID of the user event, where n is in the range from 0 to 65535.\n• None CHARTEVENT_CUSTOM_LAST  the last acceptable ID of a custom event (CHARTEVENT_CUSTOM +65535). The function can be called only in Expert Advisors and indicators. The function should be of void type with 4 parameters: void OnChartEvent(const int id, // Event ID\n\n const long& lparam, // Parameter of type long event\n\n const double& dparam, // Parameter of type double event\n\n const string& sparam // Parameter of type string events\n\n ); For each type of event, the input parameters of the OnChartEvent() function have definite values that are required for the processing of this event. The events and values passed through these parameters are listed in the table below. Value of the id parameter Value of the lparam parameter Value of the dparam parameter Value of the sparam parameter Repeat count (the number of times the keystroke is repeated as a result of the user holding down the key) The string value of a bit mask describing the status of keyboard buttons Mouse events (if property CHART_EVENT_MOUSE_MOVE=true is set for the chart) The string value of a bit mask describing the status of mouse buttons Event of graphical object creation (if CHART_EVENT_OBJECT_CREATE=true is set for the chart) Name of the created graphical object Event of change of an object property via the properties dialog Name of the modified graphical object Event of graphical object deletion (if CHART_EVENT_OBJECT_DELETE=true is set for the chart) Name of the deleted graphical object Event of a mouse click on the chart Event of a mouse click in a graphical object belonging to the chart Name of the graphical object, on which the event occurred Event of a graphical object dragging using the mouse Name of the moved graphical object Event of the finished text editing in the entry box of the LabelEdit graphical object Name of the LabelEdit graphical object, in which text editing has completed ID of the user event under the N number Value set by the EventChartCustom() function Value set by the EventChartCustom() function Value set by the EventChartCustom() function The OnCalculate() function is called only in custom indicators when it's necessary to calculate the indicator values by the Calculate event. This usually happens when a new tick is received for the symbol, for which the indicator is calculated. This indicator is not required to be attached to any price chart of this symbol. The OnCalculate() function must have a return type int. Parameters of open[], high[], low[] and close[] contain arrays with open prices, high and low prices and close prices of the current time frame. The time[] parameter contains an array with open time values, the spread[] parameter has an array containing the history of spreads (if any spread is provided for the traded security). The parameters of volume[] and tick_volume[] contain the history of trade and tick volume, respectively. To determine the indexing direction of time[], open[], high[], low[], close[], tick_volume[], volume[] and spread[], call ArrayGetAsSeries(). In order not to depend on default values, you should unconditionally call the ArraySetAsSeries() function for those arrays, which are expected to work with. The first rates_total parameter contains the number of bars, available to the indicator for calculation, and corresponds to the number of bars available in the chart. We should note the connection between the return value of OnCalculate() and the second input parameter prev_calculated. During the function call, the prev_calculated parameter contains a value returned by OnCalculate() during previous call. This allows for economical algorithms for calculating the custom indicator in order to avoid repeated calculations for those bars that haven't changed since the previous run of this function. For this, it is usually enough to return the value of the rates_total parameter, which contains the number of bars in the current function call. If since the last call of OnCalculate() price data has changed (a deeper history downloaded or history blanks filled), the value of the input parameter prev_calculated will be set to zero by the terminal. To understand it better, it would be useful to start the indicator, which code is attached below. #property indicator_chart_window\n\n #property indicator_buffers 1\n\n //---- plot Line\n\n #property indicator_label1 \"Line\"\n\n #property indicator_type1 DRAW_LINE\n\n #property indicator_color1 clrDarkBlue\n\n #property indicator_style1 STYLE_SOLID\n\n #property indicator_width1 1\n\n //--- indicator buffers\n\n double LineBuffer[];\n\n //+------------------------------------------------------------------+\n\n //| Custom indicator initialization function |\n\n //+------------------------------------------------------------------+\n\n int OnInit()\n\n {\n\n //--- indicator buffers mapping\n\n SetIndexBuffer(0,LineBuffer,INDICATOR_DATA);\n\n //---\n\n return(INIT_SUCCEEDED);\n\n }\n\n //+------------------------------------------------------------------+\n\n //| Custom indicator iteration function |\n\n //+------------------------------------------------------------------+\n\n int OnCalculate(const int rates_total,\n\n const int prev_calculated,\n\n const datetime& time[],\n\n const double& open[],\n\n const double& high[],\n\n const double& low[],\n\n const double& close[],\n\n const long& tick_volume[],\n\n const long& volume[],\n\n const int& spread[])\n\n {\n\n //--- Get the number of bars available for the current symbol and chart period\n\n int bars=Bars(Symbol(),0);\n\n Print(\"Bars = \",bars,\", rates_total = \",rates_total,\", prev_calculated = \",prev_calculated);\n\n Print(\"time[0] = \",time[0],\" time[rates_total-1] = \",time[rates_total-1]);\n\n //--- return value of prev_calculated for next call\n\n return(rates_total);\n\n }"
    },
    {
        "link": "https://docs.mql4.com/basis/variables/inputvariables",
        "document": "The input storage class defines the external variable. The input modifier is indicated before the data type. A variable with the input modifier can't be changed inside mql4-programs, such variables can be accessed for reading only. Values of input variables can be changed only by a user from the program properties window. External variables are always reinitialized immediately before the OnInit() is called. Input variables determine the input parameters of a program. They are available from the Properties window of a program. There is another way to set how your input parameter will look like in the Inputs tab. For this, place a string comment after the description of an input parameter in the same line. In this way you can make names of input parameters more understandable for users. Note: Arrays and variables of complex types can't act as input variables. Note: The length of a string comment for Input variables cannot exceed 63 characters. Custom Indicators are called using the iCustom() function. After the name of the custom indicator, parameters should go in a strict accordance with the declaration of input variables of this custom indicator. If indicated parameters are less than input variables declared in the called custom indicator, the missing parameters are filled with values specified during the declaration of variables. If the custom indicator uses the OnCalculate function of the first type (i.e., the indicator is calculated using the same array of data), then one of ENUM_APPLIED_PRICE values or handle of another indicator should be used as the last parameter when calling such a custom indicator. All parameters corresponding to input variables must be clearly indicated. Not only built-in enumerations provided in MQL4, but also user defined variables can be used as input variables (input parameters for mql4 programs). For example, we can create the dayOfWeek enumeration, describing days of the week, and use the input variable to specify a particular day of the week, not as a number, but in a more common way. In order to enable a user to select a necessary value from the properties window during the script startup, we use the preprocessor command #property script_show_inputs. We start the script and can choose one of values of the dayOfWeek enumeration from the list. We start the EnumInInput script and go to the Inputs tab. By default, the value of swapday (day of triple swap charge) is Wednesday (W = 3), but we can specify any other value, and use this value to change the program operation. Number of possible values of an enumeration is limited. In order to select an input value the drop-down list is used. Mnemonic names of enumeration members are used for values displayed in the list. If a comment is associated with a mnemonic name, as shown in this example, the comment content is used instead of the mnemonic name. Each value of the dayOfWeek enumeration has its value from 0 to 6, but in the list of parameters, comments specified for each value will be shown. This provides additional flexibility for writing programs with clear descriptions of input parameters. Variables with input modifier allow not only setting external parameters values when launching programs but are also necessary when optimizing trading strategies in the Strategy Tester. Each input variable excluding the one of a string type can be used in optimization. Sometimes, it is necessary to exclude some external program parameters from the area of all passes in the tester. sinput memory modifier has been introduced for such cases. sinput stands for static external variable declaration (sinput = static input). It means that the following declaration in an Expert Advisor code will be equivalent to the full declaration The variable declared with sinput modifier is an input parameter of MQL4 program. The value of this parameter can be changed when launching the program. However, this variable is not used in the optimization of input parameters. In other words, its values are not enumerated when searching for the best set of parameters fitting a specified condition. The Expert Advisor shown above has 5 external parameters. \"Number of layers\" is declared to be sinput and equal to 6. This parameter cannot be changed during a trading strategy optimization. We can specify the necessary value for it to be used further on. Start, Step and Stop fields are not available for such a variable. Therefore, users will not be able to optimize this parameter after we specify sinput modifier for the variable. In other words, the terminal users will not be able to set initial and final values for it in the Strategy Tester for automatic enumeration in the specified range during optimization. However, there is one exception to this rule: sinput variables can be varied in optimization tasks using ParameterSetRange() function. This function has been introduced specifically for the program control of available values sets for any input variable including the ones declared as static input (sinput). The ParameterGetInput() function allows to receive input variables values when optimization is launched (in OnTesterInit() handler) and to reset a change step value and a range, within which an optimized parameter values will be enumerated. In this way, combining the sinput modifier and two functions that work with input parameters, allows to create a flexible rules for setting optimization intervals of input parameters that depend on values of another input parameters."
    },
    {
        "link": "https://ebenezerdiagi.medium.com/writing-a-custom-indicator-in-mql4-to-normalise-market-prices-into-a-simple-line-graph-8b59204b0515",
        "document": "Data normalisation means transforming a set of variables to have values within a specified range such as between 0 and 1.\n\nSwetha Lakshmanan in her article explains when and why people would want to normalise data.\n\nThe goal of normalisation for me today, is to change the values of market prices to a common scale, without distorting differences in the ranges of market prices.\n\nI am essentially creating a line graph of market price in order to view the real movement of price without the micro distortions caused by volatility.\n\nEvery market has a unique price range; EurUsd has been ranging between 0.8200 and 1.6000, NzdJpy has been ranging between 41.5 and 97.5. This massive discrepancy in the range of these two pairs would make it practically impossible to compare them algorithmically. Hence the need to normalise the prices.\n\nSpecifically, I have built an indicator for this so that I can further use the normalised data in an expert advisor to trade multiple instruments.\n\nFirstly, you should create an indicator using metaeditor:\n\nx is the most recent (close/open)price. min(x) is the minimum price value for a period and max(x) is the maximum price value for the same period, p.\n\nIn order to achieve this, we would need to calculate the minimum and maximum values on a rolling basis considering that we would be working with a constant feed of market prices.\n\nAssuming a period of 120 (t) where the timeframe, t could be 1hour, 4hours, 1day, our min(x), would be the low of the lowest candle in that 120(t) period, and our max(x), would be the high of the highest candle in the period.\n\nHowever, I will use the open and close prices rather than the low and highs. This is personal preference, as I would like to consider the read bodies of the candles.\n\nTo determine the open/close price of the lowest/highest candle in a period, we use the iLowest and iHighest functions. Note that iLowest and iHighest do not return a price, they return the index of the lowest or highest candle, and as such, we use iLow or iHigh to determine the low or high price for that particular candle.\n\nThis is the function that calculates the normalised value and you would want to place it in the global scope.\n\nNext, we need to write the OnCalculate function that constantly runs the normalise function for every new candle on the timeframe. We would write a for loop that runs through all the bars on the selected chart calculates the i value for every candle. Assuming the pair is EurUsd.\n\nYou should then place this loop into the OnCalculate function, after which your indicator code should look like this:\n\nI hope you found this article useful. Happy trading!"
    },
    {
        "link": "https://docs.mql4.com/customind",
        "document": "This is the group functions used in the creation of custom indicators. These functions can't be used when writing Expert Advisors and Scripts. The function sets a flag hiding indicators called by the Expert Advisor Sets the value of an indicator property of the double type Sets the value of an indicator property of the int type Sets the value of an indicator property of the string type Binds the specified indicator buffer with one-dimensional dynamic array of the double type Allocates memory for buffers used for custom indicator calculations Returns the amount of bars not changed after the indicator had been launched last Sets the \"short\" name of a custom indicator to be shown in the DataWindow and in the chart subwindow Sets an arrow symbol for indicators line of the DRAW_ARROW type Sets the bar number from which the drawing of the given indicator line must start Sets drawing line description for showing in the DataWindow and in the tooltip Sets the new type, style, width and color for a given indicator line Sets a new style, width and color of horizontal levels of indicator to be output in a separate window Sets a value for a given horizontal level of the indicator to be output in a separate window Indicator properties can be set using the compiler directives or using functions. To better understand this, it is recommended that you study indicator styles in examples. All the necessary calculations of a custom indicator must be placed in the predetermined function OnCalculate(). MQL4 programmers have 8 buffers and 6 drawing styles to develop custom indicators. In MQL5, this set has been significantly increased up to 512 indicator buffers and 18 drawing styles. In addition, timeseries indexing (calculation from present to past) is not necessary to calculate indicator values. Such an approach is very convenient for developing EAs, but it causes difficulties when working with indicator buffers in loops. Now you are able to set the indexing direction in the arrays on your own, which greatly simplifies the development of indicators. Another notable feature of MQL5 is the dynamic change of the drawing style using the PlotIndexSetXXX functions. For example, an indicator's color, style, line width, as well as an arrow's color and code can be changed on the fly if a certain condition occurs. Also, added the OnCalculate() handler allowing to calculate indicator values based on another indicator. Thus, in MQL5, custom indicators can be superimposed on other indicators (for example, TEMA from MACD) allowing users to receive new combinations of indicators to quickly test ideas without programming."
    }
]