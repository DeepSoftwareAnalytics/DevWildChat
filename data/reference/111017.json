[
    {
        "link": "https://stackoverflow.com/questions/57168620/linearlayout-vs-constraintlayout-with-recyclerview-items",
        "document": "I have a problem whereby the layout for an item in a recyclerview displays properly when using , but displays nothing when converted to a .\n\nThe context is a project which has not gone far beyond the \"Master Detail\" template, this view replaces the slightly simpler (single TextView) layout from that. The above works as expected. There are about 20 items initially and they all appear.\n\nWithout any other changes, swapping that layout for this one:\n\nNone of the items added to the RecyclerView appear in the emulator, although a shimmed into the Activity shows they are being added. Changing the width to doesn't make any difference.\n\nBoth layouts pass without error and appear as expected in the design view.\n\nHow can I figure out what's gone wrong here? Again, there are no other changes made. I am literally swapping one file for the other and rebuilding (and tried kicking it with \"Invalidate caches...\").\n\nThis is using ."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/constraint-layout",
        "document": "Save and categorize content based on your preferences.\n\nlets you create large, complex layouts with a flat view hierarchy—no nested view groups. It's similar to in that all views are laid out according to relationships between sibling views and the parent layout, but it's more flexible than and easier to use with Android Studio's Layout Editor.\n\nAll the power of is available directly from the Layout Editor's visual tools, because the layout API and the Layout Editor are specially built for each other. You can build your layout with entirely by dragging instead of editing the XML.\n\nThis page shows how to build a layout with in Android Studio 3.0 or higher. For more information about the Layout Editor, see Build a UI with Layout Editor.\n\nTo see a variety of layouts you can create with , see the Constraint Layout Examples project on GitHub.\n\nTo define a view's position in , you add at least one horizontal and one vertical constraint for the view. Each constraint represents a connection or alignment to another view, the parent layout, or an invisible guideline. Each constraint defines the view's position along the vertical or horizontal axis. Each view must have a minimum of one constraint for each axis, but often more are necessary.\n\nWhen you drop a view into the Layout Editor, it stays where you leave it even if it has no constraints. This is only to make editing easier. If a view has no constraints when you run your layout on a device, it is drawn at position [0,0] (the top-left corner).\n\nIn figure 1, the layout looks good in the editor, but there's no vertical constraint on view C. When this layout draws on a device, view C horizontally aligns with the left and right edges of view A, but it appears at the top of the screen because it has no vertical constraint.\n\nFigure 1. The editor shows view C below A, but it has no vertical constraint. Figure 2. View C is now vertically constrained below view A. Although a missing constraint doesn't cause a compilation error, the Layout Editor indicates missing constraints as an error in the toolbar. To view the errors and other warnings, click Show Warnings and Errors . To help you avoid missing constraints, the Layout Editor automatically adds constraints for you with the Autoconnect and infer constraints features. To use in your project, proceed as follows:\n• Ensure you have the repository declared in your file:\n• Add the library as a dependency in the module-level file, as shown in the following example. The latest version might be different than what is shown in the example. // To use constraintlayout in compose // To use constraintlayout in compose\n• In the toolbar or sync notification, click Sync Project with Gradle Files. Now you're ready to build your layout with . Figure 3. The menu to convert a layout to . To convert an existing layout to a constraint layout, follow these steps:\n• Open your layout in Android Studio and click the Design tab at the bottom of the editor window.\n• In the Component Tree window, right-click the layout and click Convert LinearLayout to ConstraintLayout. To start a new constraint layout file, follow these steps:\n• In the Project window, click the module folder and select File > New > XML > Layout XML.\n• Enter a name for the layout file and enter \"androidx.constraintlayout.widget.ConstraintLayout\" for the Root Tag. To add a constraint, do the following: Video 1. The left side of a view is constrained to the left side of the parent.\n• None Drag a view from the Palette window into the editor. When you add a view in a , it displays in a bounding box with square resizing handles on each corner and circular constraint handles on each side.\n• Click the view to select it.\n• Do one of the following:\n• Click a constraint handle and drag it to an available anchor point. This point can be the edge of another view, the edge of the layout, or a guideline. Notice that as you drag the constraint handle, the Layout Editor shows potential connection anchors and blue overlays.\n• None Click one of the Create a connection buttons in the Layout section of the Attributes window, as shown in figure 4. Figure 4. The Layout section of the Attributes window lets you create connections. When the constraint is created, the editor gives it a default margin to separate the two views. When creating constraints, remember the following rules:\n• Every view must have at least two constraints: one horizontal and one vertical.\n• You can create constraints only between a constraint handle and an anchor point that share the same plane. A vertical plane—the left and right sides—of a view can be constrained only to another vertical plane, and baselines can constrain only to other baselines.\n• Each constraint handle can be used for just one constraint, but you can create multiple constraints from different views to the same anchor point. You can delete a constraint by doing any of the following:\n• Click a constraint to select it, and then click .\n• None -click ( -click on macOS) a constraint anchor. The constraint turns red to indicate that you can click to delete it, as shown in figure 5. Figure 5. A red constraint indicates that you can click to delete it.\n• None In the Layout section of the Attributes window, click a constraint anchor, as shown in figure 6. Video 2. Adding a constraint that opposes an existing one. If you add opposing constraints on a view, the constraint lines become coiled like a spring to indicate the opposing forces, as shown in video 2. The effect is most visible when the view size is set to \"fixed\" or \"wrap content,\" in which case the view is centered between the constraints. If you instead want the view to stretch its size to meet the constraints, switch the size to \"match constraints.\" If you want to keep the current size but move the view so that it's not centered, adjust the constraint bias. You can use constraints to achieve different types of layout behavior, as described in the following sections. Constrain the side of a view to the corresponding edge of the layout. In figure 7, the left side of the view is connected to the left edge of the parent layout. You can define the distance from the edge with margin. Define the order of appearance for two views, either vertically or horizontally. In figure 8, B is constrained to always be to the right of A, and C is constrained below A. However, these constraints don't imply alignment, so B can still move up and down. Align the edge of a view to the same edge of another view. In figure 9, the left side of B is aligned to the left side of A. If you want to align the view centers, create a constraint on both sides. You can offset the alignment by dragging the view inward from the constraint. For example, figure 10 shows B with a 24dp offset alignment. The offset is defined by the constrained view's margin. You can also select all the views you want to align, and then click Align in the toolbar to select the alignment type. Align the text baseline of a view to the text baseline of another view. In figure 11, the first line of B is aligned with the text in A. To create a baseline constraint, right-click the text view you want to constrain and then click Show Baseline. Then click on the text baseline and drag the line to another baseline. You can add a vertical or horizontal guideline that lets you constrain your views and is invisible to your app's users. You can position the guideline within the layout based on either dp units or a percentage relative to the layout's edge. To create a guideline, click Guidelines in the toolbar, and then click either Add Vertical Guideline or Add Horizontal Guideline. Drag the dotted line to reposition it, and click the circle at the edge of the guideline to toggle the measurement mode. Similar to a guideline, a barrier is an invisible line that you can constrain views to, except a barrier doesn't define its own position. Instead, the barrier position moves based on the position of views contained within it. This is useful when you want to constrain a view to a set of views rather than to one specific view. For example, in figure 13 view C is constrained to the right side of a barrier. The barrier is set to the \"end\" (or the right side, in a left-to-right layout) of both view A and view B. The barrier moves depending on whether the right side of view A or of view B is is farthest right.\n• Click Guidelines in the toolbar, and then click Add Vertical Barrier or Add Horizontal Barrier.\n• In the Component Tree window, select the views you want inside the barrier and drag them into the barrier component.\n• Select the barrier from the Component Tree, open the Attributes window, and then set barrierDirection. Now you can create a constraint from another view to the barrier. You can also constrain views that are inside the barrier to the barrier. This way, you can align all the views in the barrier to each other, even if you don't know which view is the longest or tallest. You can also include a guideline inside a barrier to ensure a \"minimum\" position for the barrier. Figure 13. View C is constrained to a barrier, which moves based on the position and size of both view A and view B. When you add a constraint to both sides of a view, and the view size for the same dimension is either \"fixed\" or \"wrap content\", the view becomes centered between the two constraints with a bias of 50% by default. You can adjust the bias by dragging the bias slider in the Attributes window or by dragging the view, as shown in video 3. If you instead want the view to stretch its size to meet the constraints, switch the size to \"match constraints.\" Figure 14. When selecting a view, the Attributes window includes controls for 1 size ratio, 2 deleting constraints, 3 height or width mode, 4 margins, and 5 constraint bias. You can also highlight individual constraints in the Layout Editor by clicking them in the 6 constraint list. You can use the corner handles to resize a view, but this hardcodes the size—the view doesn't resize for different content or screen sizes. To select a different sizing mode, click a view and open the Attributes window on the right side of the editor. Near the top of the Attributes window is the view inspector, which includes controls for several layout attributes, as shown in figure 14. This is available only for views in a constraint layout. You can change the way the height and width are calculated by clicking the symbols indicated with callout 3 in figure 14. These symbols represent the size mode as follows. Click the symbol to toggle between these settings:\n• Fixed: specify a specific dimension in the following text box or by resizing the view in the editor.\n• Wrap Content: the view expands only as much as needed to fit its contents. Set this to to let the horizontal dimension change to respect constraints. By default, a widget set to isn't limited by constraints.\n• Match Constraints: the view expands as much as possible to meet the constraints on each side, after accounting for the view's margins. However, you can modify that behavior with the following attributes and values. These attributes take effect only when you set the view width to \"match constraints\":\n• layout_constraintWidth_min This takes a dimension for the view's minimum width.\n• layout_constraintWidth_max This takes a dimension for the view's maximum width. However, if the given dimension has only one constraint, then the view expands to fit its contents. Using this mode on either the height or width also lets you set a size ratio. Note: You can't use for any view in a . Instead, use \"match constraints\" ( ). Figure 15. The view is set to a 16:9 aspect with the width based on a ratio of the height. You can set the view size to a ratio, such as 16:9, if at least one of the view dimensions is set to \"match constraints\" ( ). To enable the ratio, click Toggle Aspect Ratio Constraint (callout 1 in figure 14) and enter the : ratio in the input that appears. If both the width and height are set to \"match constraints,\" you can click Toggle Aspect Ratio Constraint to select which dimension is based on a ratio of the other. The view inspector indicates which dimension is set as a ratio by connecting the corresponding edges with a solid line. For example, if you set both sides to \"match constraints,\" click Toggle Aspect Ratio Constraint twice to set the width to be a ratio of the height. The entire size is dictated by the height of the view, which can be defined in any way, as shown in figure 15. To make your views evenly spaced, click Margin in the toolbar to select the default margin for each view that you add to the layout. Any change you make to the default margin applies only to the views you add from then on. You can control the margin for each view in the Attributes window by clicking the number on the line that represents each constraint. In figure 14, callout 4 shows the bottom margin is set to 16dp. All margins offered by the tool are factors of 8dp to help your views align to Material Design's 8dp square grid recommendations. A chain is a group of views that are linked to each other with bi-directional position constraints. The views within a chain can be distributed either vertically or horizontally. Chains can be styled in one of the following ways:\n• Spread: the views are evenly distributed after margins are accounted for. This is the default.\n• Spread inside: the first and last views are affixed to the constraints on each end of the chain, and the rest are evenly distributed.\n• Weighted: when the chain is set to spread or spread inside, you can fill the remaining space by setting one or more views to \"match constraints\" ( ). By default, the space is evenly distributed between each view that's set to \"match constraints,\" but you can assign a weight of importance to each view using the and attributes. This works the same way as in a linear layout: the view with the highest weight value gets the most space, and views that have the same weight get the same amount of space.\n• Packed: the views are packed together after margins are accounted for. You can adjust the whole chain's bias—left or right, or up or down—by changing the chain's \"head\" view bias. The chain's \"head\" view—the leftmost view in a horizontal chain (in a left-to-right layout) and the top-most view in a vertical chain—defines the chain's style in XML. However, you can toggle between spread, spread inside, and packed by selecting any view in the chain and clicking the chain button that appears below the view. To create a chain, do the following, as shown in video 4:\n• Select all the views to be included in the chain.\n• Right-click one of the views. Here are a few things to consider when using chains:\n• A view can be a part of both a horizontal and a vertical chain, so you can build flexible grid layouts.\n• A chain works properly only if each end of the chain is constrained to another object on the same axis, as shown in figure 14.\n• Although the orientation of a chain is vertical or horizontal, using one doesn't align the views in that direction. To achieve the proper position for each view in the chain, include other constraints, such as alignment constraints. Instead of adding constraints to every view as you place them in the layout, you can move each view into the positions you want in the Layout Editor and then click Infer Constraints to automatically create constraints. Infer Constraints scans the layout to determine the most effective set of constraints for all views. It constrains the views to their current positions while providing flexibility. You might need to make adjustments to make the layout respond as you intend for different screen sizes and orientations. Autoconnect to Parent is a separate feature that you can enable. When it's enabled and you add child views to a parent, this feature automatically creates two or more constraints for each view as you add them to the layout—but only when it's appropriate to constrain the view to the parent layout. Autoconnect doesn't create constraints to other views in the layout. Autoconnect is disabled by default. Enable it by clicking Enable Autoconnection to Parent in the Layout Editor toolbar. Within a , you can animate changes to the size and position of elements by using and . A is a lightweight object that represents the constraints, margins, and padding of all child elements within a . When you apply a to a displayed , the layout updates the constraints of all its children. To build an animation using , specify two layout files that act as start and end keyframes for the animation. You can then load a from the second keyframe file and apply it to the displayed . Note: animations animate only the size and position of child elements. They don't animate other attributes, such as color. The following code example shows how to animate moving a single button to the bottom of the screen. // layout/keyframe1.xml // Keyframe 1 contains the starting position for all elements in the animation // as well as final colors and text sizes. <?xml version=\"1.0\" encoding=\"utf-8\"?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> <Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /> </androidx.constraintlayout.widget.ConstraintLayout> // layout/keyframe2.xml // Keyframe 2 contains another ConstraintLayout with the final positions. <?xml version=\"1.0\" encoding=\"utf-8\"?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> <Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" /> </androidx.constraintlayout.widget.ConstraintLayout> Note: With Android Studio 3.6 and higher, the view binding feature can replace calls. It also provides compile-time type safety for code that interacts with views. Consider using view binding instead of . is used in the Sunflower demo app.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-26 UTC.\"],[],[]]"
    },
    {
        "link": "https://reddit.com/r/androiddev/comments/n62bi9/should_i_use_constriantlayout_as_layout_root_in_a",
        "document": "As I've understood it ConstraintLayout is most efficient when there's one and only one root ConstraintLayout view in the hierarchy. When you have a RecyclerView with a bunch of elements that doesn't have a relationship with the container of the RecyclerView one have to resort to either nested views or a new ConstraintLayout root for each element.\n\nMy feeling from what I've read about performance for ConstraintLayouts (1) tells me nested views are just as efficient or even more effecient than new ConstraintLayouts in this case. Am I right?\n\n(1) I don't have other sources than my head but I believe I've read that ConstraintLayout starts out slow (larger overhead) but wins over nested layouts as the complexity grows"
    },
    {
        "link": "https://medium.com/@fitareq/best-practices-for-efficient-recyclerview-performance-in-android-b405eedc6d34",
        "document": "RecyclerView is one of the most commonly used views in Android development, especially for displaying large lists or grids of data. However, with great power comes great responsibility! RecyclerView can become a bottleneck in your app’s performance if not optimized properly.\n\nThis post will review some best practices to ensure your RecyclerView runs efficiently.\n\nThe pattern is at the heart of RecyclerView. It allows the RecyclerView to efficiently reuse views, which prevents unnecessary view inflation.\n\nEnsure you’re leveraging the to avoid calling repeatedly in .\n\nUsing deeply nested layouts (e.g., multiple layers of or ) will slow down the rendering process. Consider using a or to reduce view hierarchy.\n\n3. Use DiffUtil for Item Changes\n\nUpdating an entire dataset by calling is expensive. Instead, use to calculate the difference between old and new data and update only the necessary views.\n\nThis helps avoid unnecessary UI updates and keeps your RecyclerView snappy.\n\nLoading a large dataset all at once can slow down the UI. Use Android’s library to load data in chunks as the user scrolls.\n\nThis ensures that only a limited number of items are loaded and displayed at once.\n\nWhile RecyclerView automatically recycles views, it’s important to avoid heavy operations in . Make sure all expensive calculations are done outside the method.\n\nUse to prefetch data for upcoming items, reducing lag when scrolling quickly.\n\nThis will cache the next 10 items, making the scrolling experience smoother.\n\nIf your dataset contains unique IDs, enable stable IDs for RecyclerView. This allows it to better optimize view recycling.\n\nIf your RecyclerView displays images (e.g., from a server), use an efficient image-loading library like Picasso or Glide.\n\nThese libraries handle caching, resizing, and loading images efficiently, reducing memory usage and improving performance.\n\nIf you’re using listeners or callbacks in your adapter, make sure you’re not holding references to activity or fragment contexts, which can cause memory leaks. Use or avoid keeping the context altogether.\n\nInstead of manually writing in your , use or to bind views more efficiently.\n\nThis reduces boilerplate code and ensures better performance by directly binding views."
    },
    {
        "link": "https://stackoverflow.com/questions/52700009/why-constraintlayout-slower-than-linearlayout-in-recyclerview-item",
        "document": "is an approach to actualize complex formats with level (one level of settling) outline. By its outline, it's overlaying things, not at all like that never does that Its name says independent from anyone else, is awesome at situating things in respect to other. Suppose you have undetermined view width and you need to put a thing to one side of it and to the base of it in the meantime. You can do that with , however, it would take two settled, with it got way cleaner.\n\nThe center is where things can overlay. Be that as it may, what makes awesome is it can supplant the various designs: Frame, Relative, Linear. Truly, there are numerous different formats, yet those are wrappers What I like about is that it's extremely awesome at utilizing as a part of Design mode before I didn't care for it by any means. For the most part in view of the poor execution of my fair equipment (for Android Studio) and regular rendering bugs properties really are so long and appalling that it's better utilizing it Design mode. It can control position and measurements (not at all like ) of perspectives. Keep in mind, that parameters beginning with layout_ are implied for wrapping format. The view itself doesn't deal with those\n\nSo you can utilize your most loved weight from in by imperative chains, land left/right/top/base of from , overlay things like in straightforward I think no one uses , it's far excessively disappointing, constantly favored settled , with you can do that effortlessly\n\nDespite the fact that it's awesome, outline mode still isn't as immaculate as XML. It gets jumbled simple, you have to zoom in on perspectives and it drives you to have simply , in the event that you endeavor to include some settled design – you'd think twice about it.\n\nHope this will help you."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    },
    {
        "link": "https://geeksforgeeks.org/android-recyclerview",
        "document": "RecyclerView is a ViewGroup added to the android studio as a successor of the GridView and ListView. It is an improvement on both of them and can be found in the latest v-7 support packages. It has been created to make possible construction of any lists with XML layouts as an item which can be customized vastly while improving on the efficiency of ListViews and GridViews. This improvement is achieved by recycling the views which are out of the visibility of the user.\n\nLet us check, Android RecyclerView with a simple example.\n\nExample: An Android Application showing the Exam Schedule\n\nTo implement a basic RecyclerView three sub-parts are needed to be constructed which offer the users the degree of control they require in making varying designs of their choice.\n• The Card Layout: The card layout is an XML layout which will be treated as an item for the list created by the RecyclerView.\n• The ViewHolder: The ViewHolder is a java class that stores the reference to the card layout views that have to be dynamically modified during the execution of the program by a list of data obtained either by online databases or added in some other way.\n• The Data Class: The Data class is a custom java class that acts as a structure for holding the information for every item of the RecyclerView.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK(According to the application needs).\n\nLayouts are important part of the Android Applications. This Application will need two main layouts as mentioned below:\n\nexam_card.xml: (This is the Layout of the element to be inserted in RecyclerView)\n\nStep 2: Defining the Elements to be Inserted in Card\n\nWe have two layouts now, but the elements to be placed in the exam_card.xml needs to be defined. So, create a new file named ExamItem file. Properties like name, date, message, image1 and image2.\n\nThe Adapter: The adapter is the main code responsible for RecyclerView. It holds all the important methods dealing with the implementation of RecylcerView. The basic methods for a successful implementation are:\n• onCreateViewHolder: which deals with the inflation of the card layout as an item for the RecyclerView.\n• onBindViewHolder: which deals with the setting of different data and methods related to clicks on particular items of the RecyclerView.\n• getItemCount: which Returns the length of the RecyclerView.\n• onAttachedToRecyclerView: which attaches the adapter to the RecyclerView.\n\nAfter, defining the whole application properties and providing the functionality to the layouts, we will wrap all of them into MainActivity file. OnCreate Method is defined in this file.\n\nKeep in mind, that the drawable mentioned in the XML layouts have to be added to the drawable folder under res of the Android Studio Project and support package v7 should be added as an implementation in the Gradle file of the project for the code to run. The above code uses ScrollView as a parent to RecyclerView and disables the scrolling of the RecyclerView hence making the whole page scroll instead of just the RecyclerView contents."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://willowtreeapps.com/craft/android-fundamentals-working-with-the-recyclerview-adapter-and-viewholder-pattern",
        "document": "In the mobile development world, regardless of the platform, lists that display data to the user are commonly used in many projects. The Android platform gives us two different types of views that can be leveraged to display lists of data—the ListView and the RecyclerView.\n\nMy friend and team member, Brandon Carter, wrote a post about creating performant ListViews , which I highly recommend reading if you need to use a ListView in your project. Today, however, we are going to focus on the more advanced Android view-type to present lists—the RecyclerView.\n\nRecyclerView is a very powerful and flexible tool available to Android developers. Because of this, it’s crucial that we implement it properly so our code strikes a good balance between being as optimized and concise as possible. The following is a tutorial on how I like to implement the RecyclerView, Adapter, and ViewHolder pattern. Ultimately, my plan is to make this a multipart series of tutorials which will begin by using the simple pattern shown below and then move on to using a more advanced and complex usage of this pattern in future installments.\n\nI have created a companion demo project (open source of course!) that you can reference as you read through this post. The demo project can be found on GitHub at https://github.com/willowtreeapps/SimpleRecyclerViewDemo\n\nGet your mind and fingers ready because these posts will be code heavy. That said, let’s jump in and begin creating awesome RecyclerView stuff. And, if you haven’t already, go ahead and create a basic Android project with an empty Activity.\n\nFirst, we will need a goal for our end product.\n• Create a list containing some number of simple text items.\n• These text items will display the following text: “This is item {itemIndex}” where itemIndex is the index of the ViewModel contained in our list.\n\nWe need to begin setting up our project by making sure that the RecyclerView dependency is included in our project libraries. In your app-level build.gradle file add the following dependency: com.android.support:recyclerview-v7:24.2.1.\n\nHint: You can find the most recent up-to-date version at the official Android Support Library Features page.\n\nThe basic dependencies should now look something like the following:\n\n*Note: Personally, I like to define a variable if there will be multiple dependencies that will need it.\n\nAdding the RecyclerView Widget to the Activity\n\nNow that we have the RecyclerView dependency added to our project, let’s add the view widget to our Activity. In your activity layout file located in the layout resource folder, add the following code:\n\n*Note: The view id is important as we will need to reference it later when instantiating our RecyclerView.‍\n\nIn the layout resource folder create a layout file named “item_simple_itemview.xml” and then add a TextView with the id @+id/simple\\_text.‍\n\n*Note: The view id is extremely important as we will need to reference it later when setting the text to be displayed.\n\nThat’s all we need as far as XML files are concerned, now on to the fun stuff!\n\nFirst, we need to create a common object that will hold our data. Let’s call it SimpleViewModel.‍\n\n*Note: I have purposefully created this data object using a getter and setter so that its contents, the String, cannot be directly modified. It also sets us up for the future as the next installment of this series will utilize this class.\n\nNext, we will need an adapter. The adapter is the piece that will connect our data to our RecyclerView and determine the ViewHolder(s) which will need to be used to display that data. At WillowTree, we advocate the separation of concerns principle and consider it best practice to make the adapter as “dumb” as possible. No work performed on the data should live in the adapter. Instead, as will be demonstrated in our project here, we will handle all data manipulation outside of our adapter in our SimpleViewModel class.\n\nIf using an IDE such as Android Studio, you will immediately notice a red squiggly line which lets us know that there are a basic set of method overrides that will need to be added to your adapter for it to work. These required methods are as follows:\n\nWe will need to add one more method override in our project, getItemViewType(int).\n\n*Hint: In Android Studio you can use the keyboard shortcut CTRL + RETURN to open a context menu which will allow you to find and insert an overridden method.\n\nThis method is called right when the adapter is created and is used to initialize your ViewHolder(s).\n\nOne of the interesting things and, in my opinion, one of the more powerful features that come baked into the RecyclerView, is that the getItemViewType(int position) method allows us to return the actual layout id that the Android framework saves for us as a layout resource. The javadoc for this method reads:\n\n“… Unlike ListView adapters, types need not be contiguous. Consider using id resources to uniquely identify item view types.”\n\nReturning the layout id resource in this method is very powerful because it allows us to use the resource id with the LayoutInflater in the onCreateViewHolder() method and then return the ViewHolder.\n\nThis method is called for each ViewHolder to bind it to the adapter. This is where we will pass our data to our ViewHolder.\n\nThis method returns the size of the collection that contains the items we want to display.\n\nThis method returns an Integer which represents the view type. Since the Android system stores a static reference to each layout as an Integer in the “R” (resources) class, we can simply return the layout resource id to be used in the onCreateViewHolder() method.\n\nWell there it is! We now have a fully functioning RecyclerView Adapter ready to do its thing. Next up, the SimpleViewHolder .\n\nNow that we have the SimpleAdapter and SimpleViewModel set up, let’s go ahead and create our SimpleViewHolder.\n\nA ViewHolder is more than just a dumb object that only holds the item’s views. It is the very object that represents each item in our collection and will be used to display it. This powerful object is the reason I was driven to write this tutorial! Often, I see many examples which use the adapter’s onBindViewHolder() method to do the work on the view holder. As I mentioned earlier, we like to separate our concerns and thus, the adapter should actually be the “dumb” object, only connecting the RecyclerView and its data via the view holder.\n\nSo, with that said, let us create our SimpleViewHolder and add a method called bindData(SimpleViewModel viewModel). As with the SimpleAdapter, you will notice that upon first creating the SimpleViewHolder there will again be a red squiggly line informing you that you will need to add a constructor to your class. This constructor will take the parent View of the item layout allowing you to setup any views you will need to use when displaying your data. For our project, we only have a TextView so let’s go ahead and set that up:\n\nNow that we have the basics implemented we will need to add an additional method that we can use to bind our data to that TextView. Go ahead and name that method “bindData” and have it accept our SimpleViewModel as its parameter. Finally, in our bindData(SimpleViewModel) method, let’s set the TextView’s text by retrieving the data from our SimpleViewModel via the getSimpleText() method. Our bindView method should now look something like this:\n\nThat’s it for our SimpleViewModel! Now, on to hooking everything up in the Activity.\n\nWe almost have a complete project that implements the RecyclerView, Adapter, and ViewHolder pattern, which separates each concern into its own object. All we have left to do is to wire everything up in the main Activity. So, onward!\n\nHooking Everything Up in the Activity\n\nThis Activity will be the screen that will display our RecyclerView and all of its containing data to our users. It is important to note here that unlike our SimpleAdapter and SimpleViewHolder, the Activity does not require any overridden methods. However, we do need to add one method override for all of this to work—the override onCreate(Bundle savedInstanceState). In the onCreate method, we need to add a call to the super method and also add the setContentView(int layoutResID) method passing in our Activity’s layout resource id.\n\nFor this tutorial, we will initialize the SimpleAdapter and RecyclerView in our onCreate() method. Earlier, when we created our SimpleAdapter, we set it up so that we would need to pass in a list of SimpleViewModel objects, so let’s go ahead and create a private helper method to do that now.\n\nAll we are doing here is generating 100 SimpleViewModel objects, that pass in a String of “This is item %d” and adding each of those to List<SimpleViewModel> which will then be returned to the caller.\n\nNow that we have our helper method, move to the onCreate() method and instantiate a new SimpleAdapter that passes in our List<SimpleViewModel> generated from the generateSimpleList() helper method.\n\nAfter that, we will need to instantiate our RecyclerView using the id resource that we created in our Activity’s XML layout file:\n\nNow that we have a RecyclerView, there are a few more things we will need to do to make it work. One of the most important being the LayoutManager. The Android framework provides a few predefined layout managers that we can use to determine how our data will be displayed— LinearLayoutManager, GridLayoutManager, and StaggeredGridLayoutManager. Since we want to display our data as a linear vertical list, we will use LinearLayoutManager. There are multiple ways that you can set the LayoutManager on your RecyclerView —in the XML or programmatically in the Java code. We will go ahead and set our LinearLayoutManager in our Java code:\n\n*Note: To learn more about RecyclerView.LayoutManager you can visit the official documentation here.\n\nThis next step, setting whether or not the RecyclerView has a fixed size, isn’t required but I like to do it because it helps the Android framework optimize the RecyclerView by letting it know in advance the the RecyclerView size will not be affected by the Adapter contents. You can read more about this very useful method in the official Android documentation. With that said, let’s go ahead and implement setHasFixedSize(boolean)like so:\n\nFinally, we will need to attach our SimpleAdapter to the RecyclerView. We do this by using the setAdapter(Adapter) method:\n\nThat’s it! Now our complete Activity class should look something like this:\n\nGo ahead and run your project in the emulator or on your physical device and you will see a list of items, each displaying the text “This is item {index}” where {index} will be the index number of the item in our list. You should see something similar to the video below.\n\nA video of what our completed project should look like.\n\nI look forward to seeing you for the next installment of the RecyclerView tutorial where we kick it up a notch and create a slightly more complex project that expands on what we’ve learned here. We will be implementing multiple ViewHolders, the onClickListener interface, and modifying the item data when tapping an item, exciting stuff to be sure!\n\nIf you have any questions or suggestions, leave a comment below or reach out to us directly and we will be happy to help in any way that we can."
    },
    {
        "link": "https://guides.codepath.com/android/using-the-recyclerview",
        "document": "The is a that renders any adapter-based view in a similar way. It is supposed to be the successor of ListView and GridView. One of the reasons is that has a more extensible framework, especially since it provides the ability to implement both horizontal and vertical layouts. Use the widget when you have data collections whose elements change at runtime based on user action or network events.\n\nIf you want to use a , you will need to work with the following:\n• - To handle the data collection and bind it to the view\n• - Helps with animating the items for common operations such as Addition or Removal of item\n\nFurthermore, it provides animation support for items whenever they are added or removed, which had been extremely difficult to do with . also begins to enforce the ViewHolder pattern too, which was already a recommended practice but now deeply integrated with this new framework.\n\nFor more details, see this detailed overview.\n\ndiffers from its predecessor primarily because of the following features:\n• Required ViewHolder in Adapters - adapters do not require the use of the ViewHolder pattern to improve performance. In contrast, implementing an adapter for requires the use of the ViewHolder pattern for which it uses .\n• Customizable Item Layouts - can only layout items in a vertical linear arrangement and this cannot be customized. In contrast, the has a that allows any item layouts including horizontal lists or staggered grids.\n• Easy Item Animations - contains no special provisions through which one can animate the addition or deletion of items. In contrast, the has the class for handling item animations.\n• Manual Data Source - had adapters for different sources such as and for arrays and database results respectively. In contrast, the requires a custom implementation to supply the data to the adapter.\n• Manual Item Decoration - has the property for easy dividers between items in the list. In contrast, requires the use of a object to setup much more manual divider decorations.\n• Manual Click Detection - has a interface for binding to the click events for individual items in the list. In contrast, only has support for which manages individual touch events but has no built-in click handling.\n\nA needs to have a layout manager and an adapter to be instantiated. A layout manager positions item views inside a and determines when to reuse item views that are no longer visible to the user.\n\nHere is Dave Smith's talk on the custom layout manager\n\nincludes a new kind of adapter. It’s a similar approach to the ones you already used, but with some peculiarities, such as a required . You will have to override two main methods: one to inflate the view and its view holder, and another one to bind data to the view. The good thing about this is that the first method is called only when we really need to create a new view. No need to check if it’s being recycled.\n\nwill animate modifications such as add/delete/select that are notified to the adapter. can be used for basic default animations and works quite well. See the section of this guide for more information.\n\nUsing a has the following key steps:\n• Define a model class to use as the data source\n• Add a to your activity to display the items\n• Create a and to render the item\n• Bind the adapter to the data source to populate the\n\nThe steps are explained in more detail below.\n\nEvery RecyclerView is backed by a source for data. In this case, we will define a class which represents the data model being displayed by the RecyclerView:\n\nInside the desired activity layout XML file in , let's add the from the support library:\n\nIn the layout, preview we can see the within the activity:\n\nNow the is embedded within our activity layout file. Next, we can define the layout for each item within our list.\n\nBefore we create the adapter, let's define the XML layout file that will be used for each row within the list. This item layout for now should contain a horizontal linear layout with a textview for the name and a button to message the person:\n\nThis layout file can be created in and will be rendered for each item row. Note that you should be using for the . See this link for more context.\n\nWith the custom item layout complete, let's create the adapter to populate the data into the recycler view.\n\nHere we need to create the adapter which will actually populate the data into the RecyclerView. The adapter's role is to convert an object at a position into a list row item to be inserted.\n\nHowever, with a the adapter requires the existence of a \"ViewHolder\" object which describes and provides access to all the views within each item row. We can create the basic empty adapter and holder together in as follows:\n\nNow that we've defined the basic adapter and , we need to begin filling in our adapter. First, let's store a member variable for the list of contacts and pass the list in through our constructor:\n\nEvery adapter has three primary methods: to inflate the item layout and create the holder, to set the view attributes based on the data and to determine the number of items. We need to implement all three to finish the adapter:\n\nWith the adapter completed, all that is remaining is to bind the data from the adapter into the RecyclerView.\n\nBinding the Adapter to the RecyclerView\n\nIn our activity, we will populate a set of sample users which should be displayed in the .\n\nFinally, compile and run the app and you should see something like the screenshot below. If you create enough items and scroll through the list, the views will be recycled and far smoother by default than the widget:\n\nUnlike ListView, there is no way to add or remove items directly through the adapter. You need to make changes to the data source directly and notify the adapter of any changes. Also, whenever adding or removing elements, always make changes to the existing list. For instance, reinitializing the list of Contacts such as the following will not affect the adapter, since it has a memory reference to the old list:\n\nInstead, you need to act directly on the existing reference:\n\nThere are many methods available to use when notifying the adapter of different changes:\n\nWe can use these from the activity or fragment:\n\nEvery time we want to add or remove items from the RecyclerView, we will need to explicitly inform the adapter of the event. Unlike the ListView adapter, a RecyclerView adapter should not rely on since the more granular actions should be used. See the API documentation for more details.\n\nAlso, if you are intending to update an existing list, make sure to get the current count of items before making any changes. For instance, a on the adapter should be called to record the first index that will be changed.\n\nOften times there are cases when changes to your list are more complex (i.e. sorting an existing list) and it cannot be easily determined whether each row changed. In this cases, you would normally have to call on the entire adapter to update the entire screen, which eliminates the ability to perform animation sequences to showcase what changed.\n\nThe ListAdapter class simplifies detecting whether an item was inserted, updated, or deleted. You can find more details in this blog post. Note the blog post refers to Support Library v23 that was replaced with AndroidX library. Use this Migration guide to ensure compatibility with the rest of the examples.\n\nFirst, change your adapter to inherit from a to a .\n\nNote that a requires an extra generic parameter, which is the type of data managed by this adapter. We also need to declare an item callback:\n\nYou may notice an error that says \"There is no default constructor available in \". The reason is that you will declare an empty constructor and your adapter will also need to invoke this callback method:\n\nInstead of overriding , remove it since the size of the list will be managed by the class:\n\nWe will also add a helper function to add more contacts. Anytime we wish to add more contacts, will use this method instead. A function provided by the ListAdapter will trigger the comparison.\n\nFinally, we need to modify the to use the method instead.\n\nThe is built on top of the class but requires less boilerplate code. You can see below what the steps are needed to in order to accomplish the same goal. You do not need to follow the steps below if you already using .\n\nThe class, which was added in the v24.2.0 of the support library, helps compute the difference between the old and new list. This class uses the same algorithm used for computing line changes in source code (the diff utility program), so it usually fairly fast. It is recommended however for larger lists that you execute this computation in a background thread.\n\nTo use the class, you need to first implement a class that implements the that accepts the old and new list:\n\nNext, you would implement a method on your adapter to perform the diff and then invoke to notify the adapter whether the element was inserted, removed, moved, or changed:\n\nFor a working example, see this sample code.\n\nIf we are inserting elements to the front of the list and wish to maintain the position at the top, we can set the scroll position to the 1st element:\n\nIf we are adding items to the end and wish to scroll to the bottom as items are added, we can notify the adapter that an additional element has been added and can call on the RecyclerView:\n\nTo implement fetching more data and appending to the end of the list as the user scrolls towards the bottom, use the from the and add an method leveraging the EndlessScrollViewScrollListener document in the guide.\n\nThe is quite flexible and customizable. Several of the options available are shown below.\n\nWe can also enable optimizations if the items are static and will not change for significantly smoother scrolling:\n\nThe positioning of the items is configured using the layout manager. By default, we can choose between , , and . Linear displays items either vertically or horizontally:\n\nFor example, a staggered grid might look like:\n\nWe can build our own custom layout managers as outlined there.\n\nWe can decorate the items using various decorators attached to the recyclerview such as the DividerItemDecoration:\n\nThis decorator displays dividers between each item within the list as illustrated below:\n\nDecorators can also be used for adding consistent spacing around items displayed in a grid layout or staggered grid. Copy over this SpacesItemDecoration.java decorator into your project and apply to a using the method. Refer to this staggered grid tutorial for a more detailed outline.\n\nRecyclerView supports custom animations for items as they enter, move, or get deleted using ItemAnimator. The default animation effects is defined by DefaultItemAnimator, and the complex implementation (see source code) shows that the logic necessary to ensure that animation effects are performed in a specific sequence (remove, move, and add).\n\nCurrently, the fastest way to implement animations with RecyclerView is to use third-party libraries. The third-party recyclerview-animators library contains a lot of animations that you can use without needing to build your own. Simply edit your :\n\nNext, we can use any of the defined animators to change the behavior of our RecyclerView:\n\nFor example, here's scrolling through a list after customizing the animation:\n\nFor a further look into defining custom item animators, check out this custom RecyclerView item animation post.\n\nThere is also a new interface for the ItemAnimator interface. The old interface has now been deprecated to . This library adds a ItemHolderInfo class, which appears to be similar to the MoveInfo class defined by but used more generically to pass state information between animation transition states. It is likely that the next version of will be simplified to use this new class and revised interface.\n\nSee this guide if you want to inflate multiple types of rows inside a single :\n\nThis is useful for feeds which contain various different types of items within a single list.\n\nRecyclerView allows us to handle touch events with:\n\nIn certain cases, we might want a horizontal that allows the user to scroll through a list of items. As the user scrolls, we might want items to \"snap to center\" as they are revealed. Such as in this example:\n\nTo achieve this snapping to center effect as the user scrolls we can use the built-in LinearSnapHelper as follows:\n\nFor more sophisticated snapping behavior, read more about customizing these helpers and review related sample code here.\n\nFor a more manual approach, we can create a custom extension to called which will snap items to center as the user scrolls:\n• Copy over the code from SnappyRecyclerView.java to your project.\n• Configure your new with a horizontal :\n• Attach your adapter to the to populate the data into the horizontal list as normal.\n• You can access the currently \"snapped\" item position with .\n\nThat's all, you should be set for a snap-to-center horizontal scrolling list!\n\nIf you'd like to perform an action whenever a user clicks on any item in your RecyclerView, you'll need to perform that action within a handler.\n\nBelow are three ways you can attach a handler to listen to clicks on a RecyclerView. Note that this can be used to recognize clicks on items, but not for recognizing clicks on individual buttons or other elements within your items...\n\nThe easiest solution for handling a click on an item in a RecyclerView is to add a decorator class such as this clever decorator and then implement the following code in your Activity or Fragment code:\n\nThis technique was originally outlined in this article. Under the covers, this is wrapping the interface pattern described in detail below.\n\nSo, if you apply this code above, you do not need the Simple Click Handler within ViewHolder described below.\n\nAnother solution for setting up item click handlers within a is to add code to your Adapter instead...\n\nUnlike which has the method, does not have special provisions for attaching click handlers to items. So, to achieve a similar effect manually (instead of using the decorator utility above), we can attach click events within the inside our adapter:\n\nIf we want the item to show a \"selected\" effect when pressed, we can set the of the root layout for the row to :\n\nThis creates the following effect:\n\nIn certain cases, you'd want to setup click handlers for views within the but define the click logic within the containing or (i.e bubble up events from the adapter). To achieve this, create a custom listener within the adapter and then fire the events upwards to an interface implementation defined within the parent:\n\nThen we can attach a click handler to the adapter with:\n\nSee this detailed stackoverflow post which describes how to setup item-level click handlers when using .\n\nThe should be used to refresh the contents of a via a vertical swipe gesture. See our detailed RecyclerView with SwipeRefreshLayout guide for a step-by-step tutorial on implementing pull to refresh.\n\nRecyclerView has an method that can be used to implement custom fling behavior. Download this RecyclerViewSwipeListener and you can handle custom swipe detection by adding this class to your RecyclerView:"
    }
]