[
    {
        "link": "https://reddit.com/r/C_Programming/comments/ucfu0d/naming_convention_for_structs_and_typedef_structs",
        "document": "It was my understanding that it was customary to name structs and typedef structs with the first capital letter. Like Book. This obviously helps with distinguishing normal variables and structs.\n\nPrimarily, I am interested in the struct version because I grew out of typedefs. Better to literally write something is a struct so everyone knows. But still what if you name the struct something someone else might use as a variable name? There obviously is some need for differentiation.\n\nI already started using the prefix g_ for global vars (even though I never had a problem with them because I comment a lot and mention stuff like that.)\n\nSome people suggested a bunch of other prefixes. Setting s_ for struct might work pretty well but I don't know if I like it aestthetically. Depending on your answers, I might use it if it is a very popular solutions.\n\nWhat do you do? What should I do?\n\nSeems that most people agree that structs should start with a big letter and PascalCase"
    },
    {
        "link": "https://stackoverflow.com/questions/5558994/naming-convention-when-using-struct-in-c",
        "document": "I think this is done mostly because of the very mistaken idea that a struct and a type cannot have the same name. In other words, that somehow\n\nwill collide in strange ways because the and the have the same name. This is wrong in C. The name of a struct is considered a tag, whereas a typedef creates a type name. These live in two different namespaces and will not collide. In my opinion, it makes a lot more sense for the tag of the struct to be the same as the typedef, assuming you use a typedef at all. In C, you must always reference a struct with the struct keyword. For example, if you define\n\nbut do not make a typedef, then the following is invalid:\n\nIf you want to define variables (or arguments) of type in C, you must provide a typedef:\n\nIn this second example, , and have the same type, although this isn't obvious. Indeed, if the typedef were changed, they would no longer have the same type. Beware of this! It can cause some interesting bugs if type definitions change.\n\nIn C++, a struct definition essentially creates an implicit so that both of the above code snippets compile. There is, in C++, essentially no difference between a struct name (or tag) and a type name. Which is, in my opinion, another great reason to name the two the same way, especially if you anticipate that your C module might be used by some C++ code at some point."
    },
    {
        "link": "https://stackoverflow.com/questions/74570701/how-to-name-structs-and-types-correctly-in-c",
        "document": "When using , you don't even need to state a struct tag. This is only required if you are doing something special like a self-referencing struct or an implementation of \"opaque types\". So the most common solution would simply be to omit the struct tag.\n\nstruct tags and names exist in different name spaces, so you can name them the same if you fancy, as far as the C language is concerned.\n\nThere is as far as I know no convention for naming struct tags. However, some coding standards like the Linux kernel encourages over typedef, for completely subjective reasons.\n\nat the end of a type is a common naming convention for types however. It is fine to use, although prohibited by the POSIX standard.\n\nDepending on what kind of application you are writing, you could either follow things like the Linux kernel coding style or POSIX, or you can completely ignore them."
    },
    {
        "link": "https://users.ece.cmu.edu/~eno/coding/CCodingStandard.html",
        "document": "For the C++ coding standards click here\n• Formatting\n• If Then Else Formatting\n• Use of goto,continue,break and ?:\n• Miscellaneous\n• Mixing C and C++\n• No Magic Numbers\n• Error Return Check Policy\n• To Use Enums or Not to Use Enums\n• Do Not Default If Test to Non-Zero\n• Commenting Out Large Code Blocks\n• Use #if Not #ifdef\n\nA name is the result of a long deep thought process about the ecology it lives in. Only a programmer who understands the system as a whole can create a name that \"fits\" with the system. If the name is appropriate everything fits together naturally, relationships are clear, meaning is derivable, and reasoning from common human expectations works as expected.\n\nIf you find all your names could be Thing and DoIt then you should probably revisit your design.\n• Usually every function performs an action, so the name should make clear what it does: check_for_errors() instead of error_check(), dump_data_to_file() instead of data_file(). This will also make functions and data objects more distinguishable. Structs are often nouns. By making function names verbs and following other naming conventions programs can be read more naturally.\n• Suffixes are sometimes useful:\n• max - to mean the maximum value something can have. For example: retry_max to mean the maximum number of retries, retry_cnt to mean the current retry count.\n• Prefixes are sometimes useful:\n• is - to ask a question about something. Whenever someone sees Is they will know it's a question.\n• get - get a value.\n• Use underbars ('_') to separate name components\n• When declaring variables in structures, declare them organized by use in a manner to attempt to minimize memory wastage because of compiler alignment issues, then by size, and then by alphabetical order. E.g, don't use ``int a; char *b; int c; char *d''; use ``int a; int b; char *c; char *d''. Each variable gets its own type and line, although an exception can be made when declaring bitfields (to clarify that it's part of the one bitfield). Note that the use of bitfields in general is discouraged. Major structures should be declared at the top of the file in which they are used, or in separate header files, if they are used in multiple source files. Use of the structures should be by separate declarations and should be \"extern\" if they are declared in a header file. It may be useful to use a meaningful prefix for each member name. E.g, for ``struct softc'' the prefix could be ``sc_''.\n• use '_' as the word separator.\n• With this approach the scope of the variable is clear in the code.\n• Now all variables look different and are identifiable in the code.\n• place the * close to the variable name not pointer type\n• Global variables should be prepended with a 'g_'.\n• Global variables should be avoided whenever possible.\n• It's important to know the scope of a variable.\n• Global constants should be all caps with '_' separators.\n• Put #defines and macros in all upper using '_' separators. Macros are capitalized, parenthesized, and should avoid side-effects. Spacing before and after the macro name may be any whitespace, though use of TABs should be consistent through a file. If they are an inline expansion of a function, the function is defined all in lowercase, the macro has the same name all in uppercase. If the macro is an expression, wrap the expression in parenthesis. If the macro is more than a single statement, use ``do { ... } while (0)'', so that a trailing semicolon works. Right-justify the backslashes; it makes it easier to read.\n\nSome subtle errors can occur when macro names and enum labels use the same name.\n• Do not put parens next to keywords. Put a space between.\n• Do put parens next to function names.\n• Do not use parens in return statements when it's not necessary.\n• Keywords are not functions. By putting parens next to keywords keywords and function names are made to look alike.\n• Even though with big monitors we stretch windows wide our printers can only print so wide. And we still need to print code.\n• The wider the window the fewer windows we can have on a screen. More windows is better than wider windows.\n• We even view and print diff output correctly on all terminals and printers.\n\nIf Then Else Formatting\n\nOne reason is that if you leave out one of the = signs, the compiler will find the error for you. A second reason is that it puts the value you are looking for right up front where you can find it instead of buried at the end of your expression. It takes a little time to get used to this format, but then it really gets useful.\n• Falling through a case statement into the next case statement shall be permitted as long as a comment is included.\n• The default case should always be present and trigger an error if it should not be reached, yet is reached.\n• If you need to create variables put all the code in a block.\n\nUse of goto,continue,break and ?:\n\nWhen a goto is necessary the accompanying label should be alone on a line and to the left of the code that follows. The goto should be commented (possibly in the block header) as to its utility and purpose.\n\nContinue and break like goto should be used sparingly as they are magic in code. With a simple spell the reader is beamed to god knows where for some usually undocumented reason.\n\nThe two main problems with continue are:\n• It may bypass the test condition\n• It may bypass the increment/decrement expression\n\nConsider the following example where both problems occur:\n\nFrom the above example, a further rule may be given: Mixing continue with break in the same loop is a sure way to disaster.\n• Put the condition in parens so as to set it off from other code\n• If possible, the actions for the test should be simple functions.\n• Put the action for the then and else statement on a separate line unless it can be clearly put on one line.\n• The code is easier to read. Use some white space too. Nothing better than to read code that is one line after another with no white space or comments.\n• Documentation can be added for the variable on the line.\n• It's clear that the variables are initialized.\n• Declarations are clear which reduces the probablity of declaring a pointer when you meant to declare just a char.\n\nTo Use Enums or Not to Use Enums\n\nIn general enums are preferred to #define as enums are understood by the debugger.\n\nBe aware enums are not of a guaranteed size. So if you have a type that can take a known range of values and it is transported in a message you can't use an enum as the type. Use the correct integer size and use constants or #define. Casting between integers and enums is very error prone as you could cast a value not in the enum.\n\nThe macro above can be replaced for integers with the following inline function with no loss of efficiency:\n\nAlways Wrap the Expression in Parenthesis\n• Avoid simple and common names like MAX and MIN.\n• You shall always initialize variables. Always. Every time. gcc with the flag -W may catch operations on uninitialized variables, but it may also not.\n• More problems than you can believe are eventually traced back to a pointer or variable left uninitialized.\n• Functions should limit themselves to a single page of code.\n• The idea is that the each method represents a technique for achieving a single objective.\n• Most arguments of inefficiency turn out to be false in the long run.\n• True function calls are slower than not, but there needs to a thought out decision (see premature optimization).\n\nDo Not Default If Test to Non-Zero\n\nOr better yet use an inline method:\n\nNote, this is just an example, you should really use the standard library string type for doing the comparison.\n\nThe non-zero test is often defaulted for predicates and other functions or expressions which meet the following restrictions:\n• Returns 0 for false, nothing else.\n• Is named so that the meaning of (say) a true return is absolutely obvious. Call a predicate is_valid(), not check_valid().\n\nThe ++ and -- operators count as assignment statements. So, for many purposes, do functions with side effects. Using embedded assignment statements to improve run-time performance is also possible. However, one should consider the tradeoff between increased speed and decreased maintainability that results when embedded assignments are used in artificial places. For example,\n\nThese headers are structured in such a way as they can be parsed and extracted. They are not useless like normal headers. So take time to fill them out. If you do it right once no more documentation may be necessary.\n• @author:\n\n specifies the author of the module\n• @version:\n\n specifies the version of the module\n• @deprecated:\n\n says that a function is not to be used anymore\n• @see:\n\n creates a link in the documentation to the file/function/variable to consult to get a better understanding on what the current block of code does.\n• @todo:\n\n what remains to be done\n• @bug:\n\n report a bug found in the piece of code\n• Make the gotcha keyword the first symbol in the comment.\n• Comments may consist of multiple lines, but the first line should be a self-containing, meaningful summary.\n• The writer's name and the date of the remark should be part of the comment. This information is in the source repository, but it can take a quite a while to find out when and by whom it was added. Often gotchas stick around longer than they should. Embedding date information allows other programmer to make this decision. Embedding who information lets us know who to ask.\n\nA layering violation simply means we have dependency between layers that is not controlled by a well defined interface. When one of the layers changes code could break. We don't want code to break so we want layers to work only with other adjacent layers.\n\nSometimes we need to jump layers for performance reasons. This is fine, but we should know we are doing it and document appropriately.\n• Don't use floating-point variables where discrete values are needed. Using a float for a loop counter is a great way to shoot yourself in the foot. Always test floating-point numbers as <= or >=, never use an exact comparison (== or !=).\n• Compilers have bugs. Common trouble spots include structure assignment and bit fields. You cannot generally predict which bugs a compiler has. You could write a program that avoids all constructs that are known broken on all compilers. You won't be able to write anything useful, you might still encounter bugs, and the compiler might get fixed in the meanwhile. Thus, you should write ``around'' compiler bugs only when you are forced to use a particular buggy compiler.\n• Do not rely on automatic beautifiers. The main person who benefits from good program style is the programmer him/herself, and especially in the early design of handwritten algorithms or pseudo-code. Automatic beautifiers can only be applied to complete, syntactically correct programs and hence are not available when the need for attention to white space and indentation is greatest. Programmers can do a better job of making clear the complete visual layout of a function or file, with the normal attention to detail of a careful programmer (in other words, some of the visual layout is dictated by intent rather than syntax and beautifiers cannot read minds). Sloppy programmers should learn to be careful programmers instead of relying on a beautifier to make their code readable. Finally, since beautifiers are non-trivial programs that must parse the source, a sophisticated beautifier is not worth the benefits gained by such a program. Beautifiers are best for gross formatting of machine-generated code.\n• Accidental omission of the second ``='' of the logical compare is a problem. The following is confusing and prone to error. Does the programmer really mean assignment here? Often yes, but usually no. The solution is to just not do it, an inverse Nike philosophy. Instead use explicit tests and avoid assignment with an implicit test. The recommended form is to do the assignment before doing the test:\n• Modern compilers will put variables in registers automatically. Use the register sparingly to indicate the variables that you think are most critical. In extreme cases, mark the 2-4 most critical values as register and mark the rest as REGISTER. The latter can be #defined to register on those machines with many registers.\n\nUse #if Not #ifdef\n\nYou can't use /**/ style comments because comments can't contain comments and surely a large block of your code will contain a comment, won't it?\n\nDon't use #ifdef as someone can unknowingly trigger ifdefs from the compiler command line. #if 0is that even day later you or anyone else has know idea why this code is commented out. Is it because a feature has been dropped? Is it because it was buggy? It didn't compile? Can it be added back? It's a mystery. Use Descriptive Macro Names Instead of #if 0 #if NOT_YET_IMPLEMENTED #if OBSOLETE #if TEMP_DISABLED Add a short comment explaining why it is not implemented, obsolete or temporarily disabled. In short: Use the .h extension for header files and .c for source files. Do not put data definitions in header files. for example:\n• It's bad magic to have space consuming code silently inserted through the innocent use of header files.\n• It's not common practice to define variables in the header file so it will not occur to developers to look for this when there are problems.\n• Consider defining the variable once in a .c file and use an extern statement to reference it. Mixing C and C++ In order to be backward compatible with dumb linkers C++'s link time type safety is implemented by encoding type information in link symbols, a process called name mangling. This creates a problem when linking to C code as C function names are not mangled. When calling a C function from C++ the function name will be mangled unless you turn it off. Name mangling is turned off with the extern \"C\" syntax. If you want to create a C function in C++ you must wrap it with the above syntax. If you want to call a C function in a C library from C++ you must wrap in the above syntax. Here are some examples: Calling C Functions from C++ extern \"C\" int strncpy(...); extern \"C\" int my_great_function(); extern \"C\" { int strncpy(...); int my_great_function(); }; Creating a C Function in C++ If you have code that must compile in a C and C++ environment then you must use the __cplusplus preprocessor directive. For example: A magic number is a bare naked number used in source code. It's magic because no-one has a clue what it means including the author inside 3 months. For example: if (22 == foo) { start_thermo_nuclear_war(); } else if (19 == foo) { refund_lotso_money(); } else if (16 == foo) { infinite_loop(); } else { cry_cause_im_lost(); } In the above example what do 22 and 19 mean? If there was a number change or the numbers were just plain wrong how would you know? Instead of magic numbers use a real name that means something. You can use #define or constants or enums as names. Which one is a design choice. For example: #define PRESIDENT_WENT_CRAZY (22) const int WE_GOOFED= 19; enum { THEY_DIDNT_PAY= 16 }; if (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); } else if (WE_GOOFED == foo) { refund_lotso_money(); } else if (THEY_DIDNT_PAY == foo) { infinite_loop(); } else { happy_days_i_know_why_im_here(); } Now isn't that better? The const and enum options are preferable because when debugging the debugger has enough information to display both the value and the label. The #define option just shows up as a number in the debugger which is very inconvenient. The const option has the downside of allocating memory. Only you know if this matters for your application.\n• Check every system call for an error return, unless you know you wish to ignore errors. For example, printf returns an error code but rarely would you check for its return code. In which case you can cast the return to (void) if you really care.\n• Include the system error text for every system error message.\n• Check every call to malloc or realloc unless you know your versions of these calls do the right thing. You might want to have your own wrapper for these calls, including new, so you can do the right thing always and developers don't have to make memory checks everywhere."
    },
    {
        "link": "https://doc.ic.ac.uk/lab/cplus/cstyle.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/231760/what-does-a-type-followed-by-t-underscore-t-represent",
        "document": "As Douglas Mayle noted, it basically denotes a type name. Consequently, you would be ill-advised to end variable or function names with ' ' since it could cause some confusion. As well as , the C89 standard defines , , , and probably some others I've forgotten. The C99 standard defines a lot of extra types, such as , , , , , and so on. These new types are formally defined in but most often you will use which (unusually for standard C headers) includes . It ( ) also defines macros for use with the and .\n\nAs Matt Curtis noted, there is no significance to the compiler in the suffix; it is a human-oriented convention.\n\nHowever, you should also note that POSIX defines a lot of extra type names ending in ' ', and reserves the suffix for the implementation. That means that if you are working on POSIX-related systems, defining your own type names with the suffix convention is ill-advised. The system I work on has done it (for more than 20 years); we regularly get tripped up by systems defining types with the same name as we define.\n\nIf you have a convenient abbreviation to use as a prefix, then you may be safe to use type names (though POSIX could decide to use your prefix). Without such a prefix, you may get caught at any time. Generally, the standardized types use all lower-case ( and are two exceptions, twice - all caps, and no ), so you could use with moderate safety, with or without the leading caps. I tend to use (or is that with not having the leading capital letter?) without a suffix for my own work; my functions are usually all lower-case."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/vkawbo/suffix_t_for_custom_types",
        "document": "I often see the suffix in C code on github, like .\n\nSo I dont use it for my code and use instead.\n\nWhat are your opinions on that?"
    },
    {
        "link": "https://reddit.com/r/cprogramming/comments/z954m3/why_do_typedef_name_end_with_t_so_often",
        "document": "I am currently in university and have a C course. I was seeing a lot of examples with typedef, that end with an underscore and t in at the end of the name.\n\nIs there a specific reason for that convention? Also what does the 't' stand for?"
    },
    {
        "link": "https://news.ycombinator.com/item?id=37083329",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/3225386/if-i-do-a-typedef-in-c-or-c-when-should-i-add-t-at-the-end-of-typedefed",
        "document": "When should use use ? Never? It's reserved by a major standard (POSIX) and even if it's not now, your code might someday be used in a POSIX environment, so using is a bad idea.\n\nI would go further to say that over-use of is bad in general. If your type is a , , or , use these keywords when you declare variables and it makes your code more clear. Use of is best reserved for when you want to make the underlying type invisible for abstraction/encapsulation purposes. A few great examples from standard C are , , , and the stdio .\n\nSome of the worst abuses of are by the Windows API ( , , , etc.) and glib ( , , etc.). Making duplicates of the standard C types with the same intended usage is only confusing and serves to lock developers into your library/platform by polluting all the code with these nonstandard type names."
    }
]