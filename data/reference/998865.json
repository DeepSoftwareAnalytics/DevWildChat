[
    {
        "link": "https://discussions.unity.com/t/multithreading-or-similar-in-unity/833577",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/73982271/how-to-find-a-qr-code-position-using-unity-and-hololens",
        "document": "I was running into a similar issue. I am using Unity 2021.3.\n\nI was following the documentation here (https://learn.microsoft.com/en-us/windows/mixed-reality/develop/advanced-concepts/qr-code-tracking-overview) along with the github repo with the sample project.\n\nWhat I needed to do was change the branch to the Open XR branch (https://github.com/microsoft/MixedReality-QRCode-Sample/tree/OpenXR#openxr-sample)\n\nAnd when I copied the scripts and prefabs folder from the Open XR branch into my project and tested, it worked. The QR Code Prefab was following my irl QR code, when I scanned it with the HoloLens 2."
    },
    {
        "link": "https://docs.unity3d.com/2020.1/Documentation/Manual/JobSystemMultithreading.html",
        "document": "In a single-threaded computing system, one instruction goes in at a time, and one result comes out at a time. The time to load and complete programs depends on the amount of work you need the CPU to do.\n\nMultithreading is a type of programming that takes advantage of a CPU’s capability to process many threads at the same time across multiple cores. Instead of tasks or instructions executing one after another, they run simultaneously.\n\nOne thread runs at the start of a program by default. This is the “main thread”. The main thread creates new threads to handle tasks. These new threads run in parallel to one another, and usually synchronize their results with the main thread once completed.\n\nThis approach to multithreading works well if you have a few tasks that run for a long time. However, game development code usually contains many small instructions to execute at once. If you create a thread for each one, you can end up with many threads, each with a short lifetime. That can push the limits of the processing capacity of your CPU and operating system.\n\nIt is possible to mitigate the issue of thread lifetime by having a pool of threads. However, even if you use a thread pool, you are likely to have a large number of threads active at the same time. Having more threads than CPU cores leads to the threads contending with each other for CPU resources, which causes frequent context switching as a result. Context switching is the process of saving the state of a thread part way through execution, then working on another thread, and then reconstructing the first thread, later on, to continue processing it. Context switching is resource-intensive, so you should avoid the need for it wherever possible."
    },
    {
        "link": "https://unity.com/how-to",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/2020.1/Documentation/Manual/CreatingAndUsingScripts.html",
        "document": "The behavior of GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary is controlled by the ComponentsA functional part of a GameObject. A GameObject can contain any number of components. Unity has many built-in components, and you can create your own by writing scripts that inherit from MonoBehaviour. More info\n\nSee in Glossary that are attached to them. Although Unity’s built-in Components can be very versatile, you will soon find you need to go beyond what they can provide to implement your own gameplay features. Unity allows you to create your own Components using scripts. These allow you to trigger game events, modify Component properties over time and respond to user input in any way you like.\n\nUnity supports the C# programming language natively. C# (pronounced C-sharp) is an industry-standard language similar to Java or C++.\n\nIn addition to this, many other .NET languages can be used with Unity if they can compile a compatible DLL - see here for further details.\n\nLearning the art of programming and the use of these particular languages is beyond the scope of this introduction. However, there are many books, tutorials and other resources for learning how to program with Unity. See the Learning section of our website for further details.\n\nUnlike most other assets, scripts are usually created within Unity directly. You can create a new script from the Create menu at the top left of the Project panel or by selecting Assets > Create > C# Script from the main menu.\n\nThe new script will be created in whichever folder you have selected in the Project panel. The new script file’s name will be selected, prompting you to enter a new name.\n\nIt is a good idea to enter the name of the new script at this point rather than editing it later. The name that you enter will be used to create the initial text inside the file, as described below.\n\nWhen you double-click a script Asset in Unity, it will be opened in a text editor. By default, Unity will use Visual Studio, but you can select any editor you like from the External Tools panel in Unity’s preferences (go to Unity > Preferences).\n\nThe initial contents of the file will look something like this:\n\nA script makes its connection with the internal workings of Unity by implementing a class which derives from the built-in class called MonoBehaviour. You can think of a class as a kind of blueprint for creating a new Component type that can be attached to GameObjects. Each time you attach a script component to a GameObject, it creates a new instance of the object defined by the blueprint. The name of the class is taken from the name you supplied when the file was created. The class name and file name must be the same to enable the script component to be attached to a GameObject.\n\nThe main things to note, however, are the two functions defined inside the class. The Update function is the place to put code that will handle the frame update for the GameObject. This might include movement, triggering actions and responding to user input, basically anything that needs to be handled over time during gameplay. To enable the Update function to do its work, it is often useful to be able to set up variables, read preferences and make connections with other GameObjects before any game action takes place. The Start function will be called by Unity before gameplay begins (ie, before the Update function is called for the first time) and is an ideal place to do any initialization.\n\nNote to experienced programmers: you may be surprised that initialization of an object is not done using a constructor function. This is because the construction of objects is handled by the editor and does not take place at the start of gameplay as you might expect. If you attempt to define a constructor for a script component, it will interfere with the normal operation of Unity and can cause major problems with the project.\n\nAs noted above, a script only defines a blueprint for a Component and so none of its code will be activated until an instance of the script is attached to a GameObject. You can attach a script by dragging the script asset to a GameObject in the hierarchy panel or to the inspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary of the GameObject that is currently selected. There is also a Scripts submenu on the Component menu which will contain all the scripts available in the project, including those you have created yourself. The script instance looks much like any other Component in the Inspector:\n\nOnce attached, the script will start working when you press Play and run the game. You can check this by adding the following code in the Start function:-\n\nDebug.Log is a simple command that just prints a message to Unity’s console output. If you press Play now, you should see the message at the bottom of the main Unity editor window and in the Console window (menu: Window > General > ConsoleAbbreviation of game console\n\nSee in Glossary)."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/UIE-best-practices-for-managing-elements.html",
        "document": "This page describes the best practices for managing elements in the visual treeAn object graph, made of lightweight nodes, that holds all the elements in a window or panel. It defines every UI you build with the UI Toolkit.\n\nSee in Glossary.\n\nElements pooling is to keep hold of elements that you might recreate later on, rather than creating elements with every time and letting go of them.\n\nIt’s important to be fully in control of all elements that you pool and make sure you reset them properly before you return them to the pool. Otherwise, the pooling system can become unstable and troublesome. For example, it’s impossible to clean up an element if you pool elements while registering event callbacks or setting an internal non-serialized state at the same time.\n\nKeep the number of visible elements low\n\nTo keep the number of visual elementsA node of a visual tree that instantiates or derives from the C# class. You can style the look, define the behaviour, and display it on screen as part of the UI. More info\n\nSee in Glossary low, use ListView when possible. ListView pools elements and recycles elements as the user scrolls.\n\nAlternatively, you can implement your own pool and recycle mechanism similar to the ListView, and use the following to manage the visible area:\n• To observe the size of a container, use\n• To compute the size of children, use the property\n\nDifferent approaches to hiding an element\n\nWhen you use to remove an element from the hierarchy and eliminate references to it, the element is garbage collected. This reduces the CPU and GPU cost to zero and frees a significant amount of memory. However, it’s a slow and costly operation to recreate elements and reload them in a hierarchy. To avoid this, you can pre-create the elements in a hierarchy, use USS style properties to hide them, and only display them when necessary. While applying styles is generally faster, it can lead to increased memory usage if you create a large number of elements simultaneously.\n\nThe following describes the different approaches to hiding elements and the consequences on processors and memory usage.\n\nWith this approach, the descendants can override the style.\n\nThe following table describes the different aspects of single-frame cost when you hide or display a visual element with the style:\n\nThe following table describes the per-frame behavior for CPU and GPU when you hide a visual element with the style:\n\nWith this approach, the GPU usage can be high if the content is in the ViewportThe user’s visible area of an app on their screen.\n\nSee in Glossary, as the fragment shaderA program that runs on the GPU. More info\n\nSee in Glossary processes all elements, potentially leading to significant overdraw.\n\nThe following table describes the single-frame cost when you hide or display a visual element with the style:\n\nThe following table describes the per-frame behavior for CPU and GPU when you hide a visual element with the style:\n\nWith this approach, the element behaves like it is removed from the layout tree, which might potentially affect the layout of other elements.\n\nThe following table describes the different aspects of single-frame cost when you hide or display a visual element with the style:\n\nThe following table describes the per-frame behavior of the CPU when you hide a visual element with the style. Note that there’s no GPU cost.\n\nTranslate outside of the Viewport\n\nYou can use combined with usage hints to move the elements out of the Viewport. The geometry remains fully active, resulting in minimal CPU usage when you bring back the element on the screen. However, the GPU continues to process the vertices, which might be acceptable depending on the scenario.\n\nThe transform is computed and uploaded into GPU memory, which is generally fast.\n\nThe following table describes the per-frame behavior for CPU and GPU when you hide a visual element by translating it outside of the Viewport:\n\nWhen you use the method to remove the element from the hierarchy, you free up CPU and GPU memories, thereby eliminating any computing costs.\n\nThe following table describes the single-frame cost when you hide or display a visual element by removing it from the hierarchy:\n\nThe following table summarizes the memory usage after the element is hidden with different approaches:"
    },
    {
        "link": "https://docs.unity3d.com/Manual/UIToolkits.html",
        "document": "Unity provides three UI(User Interface) Allows a user to interact with your application. Unity currently supports three UI systems. More info\n\nSee in Glossary systems that you can use to create user interfaces (UI) for the Unity Editor and applications made in the Unity Editor:\n\nThis page provides an overview of each.\n\nUI Toolkit is the newest UI system in Unity. It’s designed to optimize performance across platforms, and is based on standard web technologies. You can use UI Toolkit to create extensions for the Unity Editor, and to create runtime UI for games and applications.\n• A retained-mode UI system that contains the core features and functionality required to create user interfaces.\n• UI Asset types inspired by standard web formats such as HTML, XML, and CSS. Use them to structure and style UI.\n• Tools and resources for learning to use UI Toolkit, and for creating and debugging your interfaces.\n\nUnity intends for UI Toolkit to become the recommended UI system for new UI development projects, but it is still missing some features found in Unity UI (uGUI) and IMGUI.\n\nThe Unity User Interface (Unity UI) package (also called uGUI) is an older, GameObject-based UI system that you can use to develop runtime UI for games and applications. In Unity UI, you use components and the Game view to arrange, position, and style the user interface. It supports advanced rendering and text features.\n\nSee the Unity UI package documentation for the manual and API reference.\n\nImmediate Mode Graphical User Interface (IMGUI) is a code-driven UI Toolkit that uses the function, and scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary that implement it, to draw and manage user interfaces. You can use IMGUI to create custom InspectorsA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary for script components, extensions for the Unity Editor, and in-game debugging displays. It is not recommended for building runtime UI.\n\nUnity intends for UI Toolkit to become the recommended UI system for new UI development projects, but it is still missing some features found in Unity UI (uGUI) and IMGUI. These older systems are better in certain use cases, and are required to support legacy projects.\n\nYour choice of UI system for a given project depends on the kind of UI you plan to develop, and the features you need support for.\n\nFor a comparison of the available UI systems, see the Comparison of UI systems in Unity."
    },
    {
        "link": "https://discussions.unity.com/t/threading-in-unity/30663",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/multithreading-and-messaging/33849",
        "document": ""
    },
    {
        "link": "https://medium.com/@marbleit/unity-ui-system-best-practices-3ced691d3e41",
        "document": "During my development days, I’ve seen many Unity projects. Sometimes I’ve made them from scratch, other times I’ve continued someone else’s project.\n\nIn either case, when I had other developers in the team, I noticed that a lot of them had trouble with Unity’s UI system, whether it’s scaling of components, optimizing rendering calls or just plain structuring of game objects.\n\nI noticed that most of them didn’t follow any guidelines and just worked based on their feeling of the best practice, which often turned out to be wrong. But that was also true for myself, until the experience taught me better.\n\nWhat I also found to be the problem is lack of summarized material for my cases, when I didn’t want to waste time going through whole documentation. So this is my attempt to summarize key points and solutions that I’ve acquired over the years.\n\nDisclaimer: note that these are not the official guidelines, and they might not be convenient for every type of project (VR for example) — but these are the ones I’ve found to be most effective for most projects that will run on screens (mobile, PC, PlayStation, Xbox).\n\nThe only way to start this discussing is to talk about the main UI Component — Canvas. Canvas is the main parent object, that contains all the UI components as children. I will not go into detail about how it works, but instead talk about two key properties when setting it up:\n\nYou can choose among 3 options: Screen Space — Overlay, Screen Space — Camera, World Space.\n\nThe main difference between Screen Space and World Space is that Screen Space will render Canvas in front of the whole game world, basically it will be fixed on the user’s screen in front of everything else, while the World Space will be render among other objects in the game world, and it can be anywhere, like a regular object that is not a part of UI.\n\nIn most cases, your choice will be Screen Space, as the UI components are mostly used for UI indicators inside game that are always in front of the game world (such as health, inventory, number of lives, timers etc.).\n\nThis is probably more important part of the Canvas setup — specifically UI Scale Mode property. By default it’s set to Constant Pixel Size, which can cause scaling issues upon changing of resolutions if left like that. In most cases, UI Scale Mode should be set to Scale With Screen Size, which will give you an option to set default resolution, and make objects in UI scale either with width or height, upon changing the resolution.\n\nExample of Canvas settings for Mobile UI:\n\nThis depends on the use case. Before answering the question, let’s talk about draw calls in Unity, specifically re-draws on Canvas. Let’s say that you have one Text component inside canvas which shows the seconds passed since the start of the game. That means that each second, your Text component is going to change. Every time component changes, Canvas that contains that Text is completely re-drawn. Now let’s say, that you have a few static Image components inside that same Canvas with Text timer. Now each time second passes, Canvas is completely redrawn, meaning that not only Text will be redrawn, but all the static Images (which technically don’t need that redraw since they didn’t change). You can image how that issue can scale up, when you have multiple components that change inside one canvas — and that’s where the second Canvas comes to save the day.\n\nIf you have Canvas nested inside a Canvas, when child Canvas is redrawn, the parent Canvas will not be influenced. So the smartest structuring of the game objects would look like this:\n\nThis knowledge of Canvas redraw behavior can greatly help when optimizing the game for lower-end devices. Think about it all the time, and it will most certainly improve your game’s FPS.\n\nImage component is pretty simple by itself. The main challenge is making sure that the image will appear the same on different screens (resolutions). To ensure that behavior will happen, just make sure that Preserve Aspect is ticked. This is how the Image component should look:\n\nSecond part of making sure it looks the same on every screen will be explained in the Anchoring section.\n\nLike Image, Text component is also pretty simple and presents same challenge — making sure that it looks the same on all screens. This can be ensured by setting custom Font Size, and make sure that Best Fit is unticked! If Best Fit is ticked, size of the font (text) will vary from screen to screen, as Unity (and Canvas) will automatically change it to what they think is best fit, and you will get inconsistent UI as a result.\n\nHere is an example of how Text component should look like:\n\nSecond part of making sure it looks the same on every screen will be explained in the Anchoring section.\n\nAnchors are defining how your UI component will be behaving in relation to it’s parent, and it can be set on each object that has Rect Transform, or in other words, is a part of UI. They look like this by default:\n\nYou should never leave them on their default position. By clicking on the Anchor Rectangle in the Rect Transform, you can select predefined anchor positions (top, bottom, left, right, middle, each of the corners etc.). That menu looks like this:\n\nHowever, what I suggest to ensure that every object will be placed exactly as you’ve set it up, regardless of screen resolution is to drag by hand each anchor to the corner of your UI Component. In the practice, that would look like this:\n\nThis way, however you change the resolution, the object will stay on the same position in the relation to their parent.\n\nI hope this basics of UI have covered some of the troubles you are facing, and managed to put you on the right way of building best UI. Happy game creating!"
    }
]