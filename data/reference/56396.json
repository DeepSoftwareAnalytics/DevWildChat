[
    {
        "link": "https://pyimagesearch.com/2021/01/20/opencv-load-image-cv2-imread",
        "document": "\n• Determine the image’s width, height, and number of channels\n• Display the loaded image to our screen\n• Write the image back out to disk as a different image filetype\n\nBy the end of this guide, you will have a good understanding of how to load images from disk with OpenCV.\n\nA dataset of images is essential to practice and understand the operation of the OpenCV library. It allows us to deal with images of different formats and sizes, thus broadening our understanding of how to manipulate images using OpenCV.\n\nRoboflow has free tools for each stage of the computer vision pipeline that will streamline your workflows and supercharge your productivity.\n\nSign up or Log in to your Roboflow account to access state of the art dataset libaries and revolutionize your computer vision pipeline.\n\nYou can start by choosing your own datasets or using our PyimageSearch’s assorted library of useful datasets.\n\nBring data in any of 40+ formats to Roboflow, train using any state-of-the-art model architectures, deploy across multiple platforms (API, NVIDIA, browser, iOS, etc), and connect to applications or 3rd party tools.\n\nTo learn how to load an image from disk using OpenCV and , just keep reading.\n\nIn the first part of this tutorial, we’ll discuss how to load an image from disk using OpenCV and the function.\n\nFrom there, you’ll learn how to configure your development environment to install OpenCV.\n\nWe will then review our project directory structure, followed by implementing , a Python script that will load input images from disk using OpenCV and the function.\n\nWe’ll wrap up this tutorial with a discussion of our results.\n\nHow do we load images from disk with OpenCV?\n\nThe function accepts a single parameter, the path to where your image lives on your disk:\n\nBefore digging into image loading with OpenCV, you’ll need to have the library installed on your system.\n\nIf you need help configuring your development environment for OpenCV 4.3+, I highly recommend that you read my pip install OpenCV guide — it will have you up and running in a matter of minutes.\n\nAll that said, are you:\n• Wanting to skip the hassle of fighting with the command line, package managers, and virtual environments?\n• Ready to run the code right now on your Windows, macOS, or Linux systems?\n\nGain access to Jupyter Notebooks for this tutorial and other PyImageSearch guides that are pre-configured to run on Google Colab’s ecosystem right in your web browser! No installation required.\n\nAnd best of all, these Jupyter Notebooks will run on Windows, macOS, and Linux!\n\nLet’s review our project structure. Grab the source code from the “Downloads” section, unzip the content, and navigate to where you saved it:\n\nLet’s now implement our image-loading Python script using OpenCV!\n\nLet’s get started learning how to load an input image from disk using OpenCV.\n\nCreate a Python script named , and insert the following code:\n\nWe can now print the image dimensions (width, height, and number of channels) to the terminal for review (Lines 18-20).\n\nIn a future blog post, we’ll talk about what image channels are, but for now keep in mind that the number of channels will be three for color images, representing the Red, Green, and Blue (RGB) components of pixel colors.\n\nBut hey, what good is it having an image in memory if we do not know whether it was read correctly by OpenCV? Let’s display the image on screen for verification:\n\nYou should now be able to apply OpenCV to:\n\nWe’ll review some of the results of those operations in the next section.\n\nNow it’s time to load images from the disk using OpenCV!\n\nStart by accessing the “Downloads” section of this tutorial to retrieve the source code and example images.\n\nFrom there, open a terminal, and execute the following command:\n\nFor my 30th birthday a couple of years ago, my wife rented a near-replica jeep from Jurassic Park (my favorite movie) for us to drive around for the day.\n\nContinuing on with the Jurassic Park theme in this tutorial, here we have a photo of Ray Arnold (played by Samuel L. Jackson).\n\nThis image has a width of 577 pixels, a height of 433 pixels, and three channels.\n\nSpeaking of that final bullet item, let’s give that a try now …\n\nWhat happens if we pass an invalid image path to “cv2.imread”?\n\nHere I am purposely providing an image path that does not exist on my disk.\n\nOpenCV conveniently handles reading and writing a wide variety of image file formats (e.g., JPG, PNG, TIFF). The library also simplifies displaying an image on screen and allowing user interaction with the opened window.\n\nIf an image cannot be read by OpenCV, you should carefully check if the input filename was given correctly, as the function returns a Python object upon failure. The function will fail if the file does not exist or if the image format is unsupported by OpenCV.\n\nWe have also printed the image dimensions to the terminal (width, height, and number of channels), based on the values of the underlying NumPy array shape. Our script then saved the image to disk using the JPG format, taking advantage of OpenCV’s ability to automatically convert the image to the desired file type.\n\nIn the next tutorial in this series, you will learn about OpenCV image basics, including what a pixel is, an overview of the image coordinate system, and how to access individual pixel values.\n\nTo download the source code to this post (and be notified when future tutorials are published here on PyImageSearch), simply enter your email address in the form below!"
    },
    {
        "link": "https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html",
        "document": "Prev Tutorial: Building OpenCV for Tegra with CUDA \n\n Next Tutorial: Writing documentation for OpenCV \n\n\n\nIn this tutorial you will learn how to:\n• Read an image from file (using cv::imread)\n• Display an image in an OpenCV window (using cv::imshow)\n• Write an image to a file (using cv::imwrite)\n\nIn OpenCV 3 we have multiple modules. Each one takes care of a different area or approach towards image processing. You could already observe this in the structure of the user guide of these tutorials itself. Before you use any of them you first need to include the header files where the content of each individual module is declared. You'll almost always end up using the:\n• core section, as here are defined the basic building blocks of the library\n• imgcodecs module, which provides functions for reading and writing\n• highgui module, as this contains the functions to show an image in a window We also include the iostream to facilitate console line output and input. By declaring , in the following, the library functions can be accessed without explicitly stating the namespace.\n\nAs a first step, the OpenCV python library is imported. The proper way to do this is to additionally assign it the name cv, which is used in the following to reference the library.\n\nNow, let's analyze the main code. As a first step, we read the image \"starry_night.jpg\" from the OpenCV samples. In order to do so, a call to the cv::imread function loads the image using the file path specified by the first argument. The second argument is optional and specifies the format in which we want the image. This may be:\n• IMREAD_COLOR loads the image in the BGR 8-bit format. This is the default that is used here.\n• IMREAD_UNCHANGED loads the image as is (including the alpha channel if present)\n• IMREAD_GRAYSCALE loads the image as an intensity one\n\nAfter reading in the image data will be stored in a cv::Mat object.\n\nAfterwards, a check is executed, if the image was loaded correctly.\n\nThen, the image is shown using a call to the cv::imshow function. The first argument is the title of the window and the second argument is the cv::Mat object that will be shown.\n\nBecause we want our window to be displayed until the user presses a key (otherwise the program would end far too quickly), we use the cv::waitKey function whose only parameter is just how long should it wait for a user input (measured in milliseconds). Zero means to wait forever. The return value is the key that was pressed.\n\nIn the end, the image is written to a file if the pressed key was the \"s\"-key. For this the cv::imwrite function is called that has the file path and the cv::Mat object as an argument."
    },
    {
        "link": "https://geeksforgeeks.org/python-opencv-cv2-imread-method",
        "document": "OpenCV-Python is a library of Python bindings designed to solve computer vision problems. cv2.imread() method loads an image from the specified file. If the image cannot be read (because of the missing file, improper permissions, or unsupported or invalid format) then this method returns an empty matrix.\n• None filename: The path to the image file.\n• None flag: The flag specifies the way how the image should be read.\n• cv2.IMREAD_COLOR – It specifies to load a color image. Any transparency of image will be neglected. It is the default flag. Alternatively, we can pass integer value 1\n• cv2.IMREAD_GRAYSCALE – It specifies to load an image in grayscale mode. Alternatively, we can pass integer value 0\n• cv2.IMREAD_UNCHANGED – It specifies to load an image as such including alpha channel. Alternatively, we can pass integer value -1 The cv2.imread() function return a NumPy array if the image is loaded successfully.\n\nIn this example, we are reading the image as a color image.\n\nIn this example, we are reading the image as a greyscale image. Both color and grayscale images are acceptable as input.\n\nIn this example, we are reading the image with the transparency channel.\n\nA NumPy array is produced after reading an image file with the cv2.imread() method. By default, the image is saved in the BGR color space. As a result, the blue, green, and red color channels, respectively, correspond to the first three channels of the NumPy array.\n\nWhat is the use of OpenCV in Python?\n\nWhat is the method used to read an image in OpenCV library?\n\nHow to load an image in Python OpenCV?\n\nTo load an image in Python using OpenCV, use the function and specify the path to the image file. \n\n\n\n\n\n \n\n\n\n \n\n \n\n\n\n # Wait for a key press and close the window \n\n\n\n\n\nWhat are the advantages of OpenCV in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/3803888/how-to-load-png-images-with-4-channels",
        "document": "The right way to read a transparent PNG is to use the 4th channel as alpha channel. Most of the times one wants a white background, if that is the case then below code can be used for alpha compositing.\n\nA detailed blog on this is here here."
    },
    {
        "link": "https://opencv.org/blog/read-display-and-write-an-image-using-opencv",
        "document": "OpenCV is an open-source computer vision library that provides a robust set of tools for handling images and videos. Among its many functionalities, it offers essential methods to read, display, and write images, making it a crucial library for various image-processing applications. With its simple yet efficient functions-imread(), imshow(), and imwrite()-users can seamlessly load images from different file formats, visualize them in a dedicated window, and save them back to the system in their preferred format. These functions serve as the foundation for more advanced computer vision tasks such as object detection, image transformation, and filtering.\n\nIn this article, we will take an in-depth look at each of these fundamental functions, understanding their role and functionality. We will also analyze their syntax in both Python and C++, ensuring that readers can implement them effectively across different programming environments. Whether you are a beginner exploring image processing for the first time or an experienced developer working with OpenCV, mastering these functions is essential for working with images in any computer vision project.\n\nBefore using any OpenCV functions, we must first import the library. This is the essential first step to access all OpenCV functionalities.\n\nWe are assuming that you have already installed OpenCV on your device.\n\nIf not please refer the relevant links below:\n\nTo read an image in OpenCV, we use the imread() function. This function loads an image from the specified file path and returns it as a NumPy array, allowing further processing or analysis.\n• filename (Required) – The name or full path of the image file.\n• If your coding file (script) and image file are in the same directory, you only need to specify the image name along with its extension (e.g., “image.png” or “photo.jpg”).\n• If they are in different folders, you must provide the full path to the image file.\n\nAvoid spaces in filenames, folder names, or image names, as they may cause errors. Use forward slashes (/) instead of backslashes (\\) in file paths to ensure compatibility across different operating systems. We can also use a relative path instead of an absolute path when specifying the image file location.\n• flags (Optional) – This argument determines how the image should be loaded. OpenCV provides several options:\n\nIf no flag is specified, imread() loads the image in BGR format by default, which means it reads the image as a 3-channel color image while ignoring any alpha (transparency) channel. This is equivalent to using IMREAD_COLOR (or 1).\n\nExample Usage in Python for Reading Image in OpenCV\n\nExample usage in C++ for Reading Image in OpenCV\n\nBy using imread(), you can efficiently handle images in OpenCV, setting the foundation for further operations like displaying and modifying the image.\n\nWhen working with images in OpenCV, it’s crucial to understand that OpenCV reads and processes color images in BGR (Blue-Green-Red) format rather than the more commonly used RGB (Red-Green-Blue) format used by most other computer vision libraries, such as Matplotlib, PIL (Pillow), TensorFlow, and PyTorch.\n\nThis difference in color channel order can lead to incorrect color representations when displaying images or working with multiple libraries. If you directly display an OpenCV-loaded image using another library without converting it to RGB, the Red and Blue colors will appear inverted.\n\nNow that we have successfully read the image, we can visually confirm this by displaying the image on the screen. To achieve this, OpenCV provides the imshow() function, which opens a window to display the image.\n• window name (Required) – A string representing the name of the window where the image will be displayed.\n• image (Required) – The image array that was read using cv2.imread().\n\nExample usage in Python for Displaying an Image in OpenCV\n\nExample usage in C++ for Displaying an Image in OpenCV\n\nFollowing are some of the important syntax used in the above code block:\n\nimshow(“Displayed Image”, image) – Opens a new window with the title “Displayed Image” and displays the loaded image.\n\nwaitKey(0) – Pauses the program execution until a key is pressed. Without this, the image window may open and close instantly. You can also specify a time (in milliseconds). For example, waitKey(5000) will keep the window open for 5 seconds before closing it automatically.\n\nSetting waitKey(0) does not mean the window remains open for 0 milliseconds—instead, it tells OpenCV to keep the window open until the user presses a key, making it the preferred option for manual image inspection.\n\ndestroyAllWindows() – is used to close all the windows that have been opened with imshow(). However, if you want to close a specific window instead of all windows, you can use the destroyWindow() function, which requires the exact window name as an argument. It frees up system memory.\n\nIf you are working in Google Colab, you need to upload the image manually using the file upload feature or mount Google Drive. Once uploaded, specify the correct filename or full file path when using cv2.imread().\n\nSince cv2.imshow() does not work in Google Colab, you need to use cv2_imshow() from google.colab.patches to display images.\n\nDisplay image in all formats using Python\n\nDisplay image in all formats using C++\n\nThe code uses imshow() to display each image in a separate window with corresponding titles. The program will wait indefinitely for a key press (via waitKey(0)) before closing all image windows with destroyAllWindows(). This simple example shows how to handle different image formats and modes using OpenCV, providing flexibility for various image processing tasks.\n• The first image is displayed in color\n• The next as grayscale\n• The third is again in color, as this was the original format of the image (which was read using IMREAD_UNCHANGED)\n\nIn OpenCV, you can save or write an image to the disk using the imwrite() function. This function allows you to save an image in various formats like PNG, JPEG, and BMP, among others.\n• filename: The name of the file where the image will be saved, including the file extension (e.g., .jpg, .png, .bmp).\n• image: The image you want to save (the image object returned by imread() or any processed image).\n\nExample usage in Python for Writing an Image in OpenCV\n\nExample usage in C++ for Writing an Image in OpenCV\n\nThe imwrite() function returns a Boolean value (True or False) to indicate whether the image was successfully written to disk.\n• Returns True: If the image is successfully saved at the specified location, imwrite() returns True.\n• Returns False: If the function fails to save the image (due to incorrect path, invalid filename, or permission issues), it returns False.\n\nThe key takeaway is how straightforward and intuitive the process is. All you have to do is specify the filename with its extension (including any path to save the image in a specific folder), and provide the variable that holds the image data, and OpenCV will handle saving the image efficiently. Additionally, if we are saving an image to a specific directory, the directory must exist beforehand; otherwise, the image will not be saved.There’s no need for complex file handling or extra steps—just a quick function call and you’re done!\n\nThis simplicity makes OpenCV an excellent choice for quickly saving processed or altered images during your computer vision or image processing tasks.\n\nWe have learned how to effectively use OpenCV’s basic image handling functions: imread(), imshow(), and imwrite().\n• Reading an Image: We saw how imread() loads images in different formats, with options for color, grayscale, or unchanged (including transparency).\n• Displaying an Image: imshow() allows us to show the image in a window, and waitKey(0) keeps the window open until a key is pressed. Without it, the window would close immediately.\n• Writing an Image: With imwrite(), saving an image to disk is as simple as specifying the filename and providing the image data.\n\nWe also discussed the default BGR format for images in OpenCV and how to manage image windows using destroyWindow() and destroyAllWindows().\n\nIn short, OpenCV simplifies the process of loading, displaying, and saving images, making it a valuable tool for image processing tasks."
    },
    {
        "link": "https://docs.opencv.org/3.4/d1/de5/classcv_1_1CascadeClassifier.html",
        "document": "Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles. Matrix of the type CV_8U containing an image where objects are detected. Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. Parameter specifying how much the image size is reduced at each image scale. Parameter specifying how many neighbors each candidate rectangle should have to retain it. Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. Minimum possible object size. Objects smaller than that are ignored. Maximum possible object size. Objects larger than that are ignored. If model is evaluated on single scale. The function is parallelized with the TBB library.\n• (Python) A face detection example using cascade classifiers can be found at opencv_source_code/samples/python/facedetect.py\n\nThis is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Matrix of the type CV_8U containing an image where objects are detected. Vector of rectangles where each rectangle contains the detected object, the rectangles may be partially outside the original image. Vector of detection numbers for the corresponding objects. An object's number of detections is the number of neighboring positively classified rectangles that were joined together to form the object. Parameter specifying how much the image size is reduced at each image scale. Parameter specifying how many neighbors each candidate rectangle should have to retain it. Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. Minimum possible object size. Objects smaller than that are ignored. Maximum possible object size. Objects larger than that are ignored. If model is evaluated on single scale.\n\nThis is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function allows you to retrieve the final stage decision certainty of classification. For this, one needs to set on true and provide the and parameter. For each resulting detection, will then contain the certainty of classification at the final stage. This value can then be used to separate strong from weaker classifications. A code sample on how to use it efficiently can be found below:\n\nThe documentation for this class was generated from the following file:"
    },
    {
        "link": "https://docs.opencv.org/4.x/d1/de5/classcv_1_1CascadeClassifier.html",
        "document": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function allows you to retrieve the final stage decision certainty of classification. For this, one needs to set on true and provide the and parameter. For each resulting detection, will then contain the certainty of classification at the final stage. This value can then be used to separate strong from weaker classifications.\n\nA code sample on how to use it efficiently can be found below:"
    },
    {
        "link": "https://geeksforgeeks.org/face-detection-using-cascade-classifier-using-opencv-python",
        "document": "In this article, we are going to see how to detect faces using a cascade classifier in OpenCV Python. Face detection has much significance in different fields of today’s world. It is a significant step in several applications, face recognition (also used as biometrics), photography (for auto-focus on the face), face analysis (age, gender, emotion recognition), video surveillance, etc.\n\nOne of the popular algorithms for facial detection is “haarcascade”. It is computationally less expensive, a fast algorithm, and gives high accuracy.\n\nHaarcascade file can be download from here: haarcascade_frontalface_default.xml\n\nIt works in four stages:\n• Haar-feature selection: A Haar-like feature consists of dark regions and light regions. It produces a single value by taking the difference of the sum of the intensities of the dark regions and the sum of the intensities of light regions. It is done to extract useful elements necessary for identifying an object. The features proposed by viola and jones are:\n• Creation of Integral Images: A given pixel in the integral image is the sum of all the pixels on the left and all the pixels above it. Since the process of extracting Haar-like features involves calculating the difference of dark and light rectangular regions, the introduction of Integral Images reduces the time needed to complete this task significantly.\n• AdaBoost Training: This algorithm selects the best features from all features. It combines multiple “weak classifiers” (best features) into one “strong classifier”. The generated “strong classifier” is basically the linear combination of all “weak classifiers”.\n• Cascade Classifier: It is a method for combining increasingly more complex classifiers like AdaBoost in a cascade which allows negative input (non-face) to be quickly discarded while spending more computation on promising or positive face-like regions. It significantly reduces the computation time and makes the process more efficient.\n\nOpenCV comes with lots of pre-trained classifiers. Those XML files can be loaded by cascadeClassifier method of the cv2 module. Here we are going to use haarcascade_frontalface_default.xml for detecting faces.\n\nInitially, the image is a three-layer image (i.e., RGB), So It is converted to a one-layer image (i.e., grayscale).\n\nCascadeClassifier method in cv2 module supports the loading of haar-cascade XML files. Here, we need “haarcascade_frontalface_default.xml” for face detection.\n\nStep 4: Applying the face detection method on the grayscale image\n\nThis is done using the cv2::CascadeClassifier::detectMultiScale method, which returns boundary rectangles for the detected faces (i.e., x, y, w, h). It takes two parameters namely, scaleFactor and minNeighbors. ScaleFactor determines the factor of increase in window size which initially starts at size “minSize”, and after testing all windows of that size, the window is scaled up by the “scaleFactor”, and the window size goes up to “maxSize”. If the “scaleFactor” is large, (e.g., 2.0), there will be fewer steps, so detection will be faster, but we may miss objects whose size is between two tested scales. (default scale factor is 1.3). Higher the values of the “minNeighbors”, less will be the number of false positives, and less error will be in terms of false detection of faces. However, there is a chance of missing some unclear face traces as well.\n\nRectangles are drawn around the detected faces by the rectangle method of the cv2 module by iterating over all detected faces.\n\nBelow is the implementation:"
    },
    {
        "link": "https://stackoverflow.com/questions/45866470/opencv-python-detectmultiscale-api",
        "document": "I was following this particular tutorial on object detection. He uses this version of detectMultiSacle function in his code, which allows him to adjust threshold for detection or something like that with rejectLevels and levelWeights:\n\nThis is my code:\n\nBut it gives the following error, which makes me confused:\n\nI was trying to use originally, but it gives me error that says the fourth argument can't be float, which made suspect I wasn't using the function I thought I was using.\n\nI use to install opencv-python which is version 3.3.0.9. I couldn't find any python documents other than this webpage.\n\nAppreciate some help. Like where can I find documents for latest python api, or some experience with this particular function."
    },
    {
        "link": "https://stackoverflow.com/questions/36218385/parameters-of-detectmultiscale-in-opencv-using-python",
        "document": "Amongst these parameters, you need to pay more attention to four of them:\n• – Parameter specifying how much the image size is reduced at each image scale.\n\nBasically, the scale factor is used to create your scale pyramid. More explanation, your model has a fixed size defined during training, which is visible in the XML. This means that this size of the face is detected in the image if present. However, by rescaling the input image, you can resize a larger face to a smaller one, making it detectable by the algorithm.\n\n1.05 is a good possible value for this, which means you use a small step for resizing, i.e. reduce the size by 5%, you increase the chance of a matching size with the model for detection is found. This also means that the algorithm works slower since it is more thorough. You may increase it to as much as 1.4 for faster detection, with the risk of missing some faces altogether.\n• – Parameter specifying how many neighbors each candidate rectangle should have to retain it.\n\nThis parameter will affect the quality of the detected faces. Higher value results in fewer detections but with higher quality. 3~6 is a good value for it.\n• – Minimum possible object size. Objects smaller than that are ignored.\n\nThis parameter determines how small size you want to detect. You decide it! Usually, [30, 30] is a good start for face detection.\n• – Maximum possible object size. Objects bigger than this are ignored.\n\nThis parameter determines how big size you want to detect. Again, you decide it! Usually, you don't need to set it manually, the default value assumes you want to detect without an upper limit on the size of the face."
    }
]