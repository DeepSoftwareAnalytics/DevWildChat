[
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://pypi.org/project/requests",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://requests.readthedocs.io/en/latest/user/install",
        "document": "This part of the documentation covers the installation of Requests. The first step to using any software package is getting it properly installed.\n\nTo install Requests, simply run this simple command in your terminal of choice:\n\nRequests is actively developed on GitHub, where the code is always available.\n\nYou can either clone the public repository:\n\nOnce you have a copy of the source, you can embed it in your own Python package, or install it into your site-packages easily:"
    },
    {
        "link": "https://docs.python-requests.org/en/v2.0.0",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/72821332/importing-modules-from-a-virtual-environment-in-python",
        "document": "I've recently become interested in virtual environments in Python, in order to keep my code more organized and more portable. For this reason, I did a factory reset on my Raspberry Pi and started from scratch, with only the default Python modules. Beforehand I had made a list of all the dependencies for my project and their versions, and I installed them into a newly made virtual environment. Here's an example of how I did that in terminal, beginning in my project directory. (I'm hoping this is relevant to the question).\n\nMy file and my virtual environment are in the same directory, yet when I try and import one of the modules I installed in my virtual environment, I get an error.\n\nThe same thing happens with all the other libraries I put in the virtual environment, except for and . I believe this to be because different versions of these came preinstalled with Python. As well, I can import , and anything else installed globally in Python.\n\nThis leads me to the question, how do I allow my python program to import modules contained in the virtual environment? I am using Python 3.9 on a Raspberry Pi 4."
    },
    {
        "link": "https://stackoverflow.com/questions/14295680/unable-to-import-a-module-that-is-definitely-installed",
        "document": "The installations I ran previously reported that they had completed successfully, so I expect the import to work. What could be causing this error?\n\nI have tried installing from pip, easy_install, and via python setup.py install from this repo: https://github.com/abielr/mechanize . All of this to no avail, as each time I enter my Python interactive I get:\n\nAfter installing mechanize , I don't seem to be able to import it.\n\nI had the same problem: script with was throwing an , but was telling me \"package already installed\". My fix: run pip without sudo: . Then pip agreed it needed to be installed, installed it, and my script ran. Or even better, use . The benefit of this is, since you are executing the specific version of python that you want the package in, pip will unequivocally install the package into the \"right\" python. Again, don't use in this case... then you get the package in the right place, but possibly with (unwanted) root permissions. My environment is Ubuntu 14.04 32-bit; I think I saw this before and after I activated my virtualenv.\n\nI was able to correct this issue with a combined approach. First, I followed Chris' advice, opened a command line and typed 'pip show packagename' This provided the location of the installed package. Next, I opened python and typed 'import sys', then 'sys.path' to show where my python searches for any packages I import. Alas, the location shown in the first step was NOT in the list. Final step, I typed 'sys.path.append('package_location_seen_in_step_1'). You optionally can repeat step two to see the location is now in the list. Test step, try to import the package again... it works. The downside? It is temporary, and you need to add it to the list each time.\n\nAs a friend did for me today, here is what helped me (I am using Windows): Press 'Setting' -> 'Project' -> 'Project Interpreter'. Here in the window on the right, there is a line with the title 'Project Interpreter' on it's left. Click this line and it will open several additional lines. Now press the 'Show All' line. A window will open. In this window press the small '+' sign in the upper right corner. A new window will open. On the left there are 4 tabs, press the most upper one, which says 'Virtualenv Environment'. Now, in the window on the right, mark the 'Existing Environment' option. The 'Interpreter' line will become well visible. Press the '...' button on the right of the line. Now, a browsing window will open. Browse to the directory that you installed Python itself in. Not the one with PyCharm. When you get there, choose the 'python.exe' file and press OK (the window will disappear). Press OK again (this window will disappear too). Now in this window make sure the new line you created is marked, and press OK again. Now, all the installed packages should be visible in the project interpreter, and are read by your program.\n\nI had this exact problem, but none of the answers above worked. It drove me crazy until I noticed that sys.path was different after I had imported from the parent project. It turned out that I had used importlib to write a little function in order to import a file not in the project hierarchy. Bad idea: I forgot that I had done this. Even worse, the import process mucked with the sys.path--and left it that way. Very bad idea. The solution was to stop that, and simply put the file I needed to import into the project. Another approach would have been to put the file into its own project, as it needs to be rebuilt from time to time, and the rebuild may or may not coincide with the rebuild of the main project.\n\nI had this problem with 2.7 and 3.5 installed on my system trying to test a telegram bot with Python-Telegram-Bot. I couldn't get it to work after installing with pip and pip3, with sudo or without. I always got: Traceback (most recent call last): File \"telegram.py\", line 2, in <module> from telegram.ext import Updater File \"$USER/telegram.py\", line 2, in <module> from telegram.ext import Updater ImportError: No module named 'telegram.ext'; 'telegram' is not a package Reading the error message correctly tells me that python is looking in the current directory for a . And right, I had a script lying there called telegram.py and this was loaded by python when I called . Conclusion, make sure you don't have any in your current working dir when trying to import. (And read error message thoroughly)."
    },
    {
        "link": "https://discuss.python.org/t/trouble-importing-libraries/28218",
        "document": "I am having issues when I try to import and into my script. I have created a virtual environment in this path: C:\\Users\\eldet\\AppData\\Local\\Programs\\Python\\Python311\\venv and have installed the two libraries here: C:\\Users\\eldet\\AppData\\Local\\Programs\\Python\\Python311\\venv\\Lib\\site-packages while my script is here: C:\\Users\\eldet\\AppData\\Local\\Programs\\Python\\Python311\\venv\\Scripts. The IDE I am using is VSCode. As far as I have understood (I’m new to Python), the libraries should import, since they are in the same virtual environment. The Python interpreter is in the sys.path: C:\\Users\\eldet\\AppData\\Local\\Programs\\Python\\Python311, the version is 2.31.0, is 0.0.1 and , 4.12.2. When debugging, I get the error.\n\nLook at the line of code that the traceback points to for the error.\n\n Post the traceback if you are not sure where to look. You should see an import statement at that line and you will need to install\n\n the package that is referred to.\n\n That line of code may not be in the code you have written. You should have all the source code installed so it is usually not\n\n a problem to see where the error is.\n\nMy script is in \\venv\\Scripts It probably should not be. This directory is for scripts that are put there by the installers for the libraries that you are using. Also, you should not try to make the virtual environment inside the Python installation folder itself. Put it somewhere else convenient, such as on the desktop. Most importantly, though: make sure that the virtual environment is activated before giving the command to run the script. Just because your code is inside a sub-folder of some particular Python installation does not mean that that Python installation will be used to run the code. In your case, there are already at least two: the user installation of Python 3.11, and the venv that you created based off of that. If you use the command line to run the code, use the corresponding activation script first. If you run the code from VSCode, you will need to understand how to choose the interpreter - I do not use this IDE (or any other), so I cannot tell you how this works. The Python interpreter is in the sys.path: C:\\Users\\eldet\\AppData\\Local\\Programs\\Python\\Python311 This already confirms the problem. You installed the libraries for the virtual environment’s Python (as you should - this is the reason to use virtual environments!), but the code is running with the original Python.\n\nI obviously, must be doing something wrong. To be able to comment on this,\n• I have created a new virtual environment here: C:\\Users\\eldet\\Documents\\python_virtual_environments and have installed the libraries.\n• I have activated the virtual environment and then I have run the script. … we would need to see exactly how you attempted these parts - step by step, the exact commands used (and/or actions taken in the VSCode GUI). Unless, of course, the instructions from @barry-scott are enough for you to see what you did differently and what’s wrong with it\n\nThank you for your interest. C:\\Users\\eldet\\maps_scraper>pip install requests Requirement already satisfied: requests in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (2.31.0) Requirement already satisfied: charset-normalizer<4,>=2 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from requests) (3.1.0) Requirement already satisfied: idna<4,>=2.5 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from requests) (3.4) Requirement already satisfied: urllib3<3,>=1.21.1 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from requests) (2.0.3) Requirement already satisfied: certifi>=2017.4.17 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from requests) (2023.5.7) C:\\Users\\eldet\\maps_scraper>install bs4 'install' is not recognized as an internal or external command, operable program or batch file. C:\\Users\\eldet\\maps_scraper>pip insatll bs4 ERROR: unknown command \"insatll\" - maybe you meant \"install\" C:\\Users\\eldet\\maps_scraper>pip install bs4 Collecting bs4 Using cached bs4-0.0.1-py3-none-any.whl Requirement already satisfied: beautifulsoup4 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from bs4) (4.12.2) Requirement already satisfied: soupsieve>1.2 in c:\\users\\eldet\\maps_scraper\\lib\\site-packages (from beautifulsoup4->bs4) (2.4.1) Installing collected packages: bs4 Successfully installed bs4-0.0.1 C:\\Users\\eldet\\maps_scraper>python Python 3.11.4 (tags/v3.11.4:d2340ef, Jun 7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import requests Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ModuleNotFoundError: No module named 'requests' >>>\n\nTry adding a print to the file so that you can see that it is doing something. Now you should see that message print out. I suspect that you have not added a main function to your code that is run. For example here an example: import requests def do_something(): print('Doing something') # add your code here # run the code do_something() import sys import requests def do_something(argv): print('Doing something') print('Command line args: %r' % (argv[1:],)) # add your code here # run the code with the command args if __name__ == '__main__': sys.exit(do_something(sys.argv)\n\nOk, so I have added the print and it does print. I have also added a logger but the log file is empty. Here is the script as I have modified it: import logging logging.basicConfig(filename=\"google_maps_scraper.log\", level=logging.INFO) import requests import bs4 import sys def get_restaurants(query): \"\"\"Gets a list of restaurants from Google Maps. Args: query: The query to search for. Returns: A list of restaurant objects. Each restaurant object has the following properties: name: The name of the restaurant. address: The address of the restaurant. phone_number: The phone number of the restaurant. website: The website of the restaurant. rating: The rating of the restaurant. reviews: The number of reviews for the restaurant. \"\"\" url = \"https://www.google.com/maps/search/mexican+restaurants+in+athens,+greece/@37.971871,23.7168781,12z/data=!3m1!4b1?entry=ttu\".format(query) response = requests.get(url) soup = bs4.BeautifulSoup(response.content, \"html.parser\") restaurants = [] for restaurant in soup.find_all(\"div\", class_=\"section-result\"): try: name = restaurant.find(\"div\", class_=\"section-result__title\").text.strip() except AttributeError: name = None try: address = restaurant.find(\"div\", class_=\"section-result__address\").text.strip() except AttributeError: address = None try: phone_number = restaurant.find(\"div\", class_=\"section-result__phone\").text.strip() except AttributeError: phone_number = None try: website = restaurant.find(\"div\", class_=\"section-result__website\").text.strip() except AttributeError: website = None try: rating = restaurant.find(\"div\", class_=\"section-result__rating\").text.strip() except AttributeError: rating = None try: reviews = restaurant.find(\"div\", class_=\"section-result__reviews\").text.strip() except AttributeError: reviews = None restaurant_info = { \"name\": name, \"address\": address, \"phone_number\": phone_number, \"website\": website, \"rating\": rating, \"reviews\": reviews, } logger.info(str(restaurant_info)) restaurants.append(restaurant_info) return restaurants def main(): \"\"\"This is the main action of the script. It calls the `get_restaurants()` function to get a list of restaurants from Google Maps. It then prints the list of restaurants. \"\"\" query = sys.argv[1] restaurants = get_restaurants(query) print(\"The script is running.\") if __name__ == \"__main__\": main()"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-troubleshoot-import-problems-419878",
        "document": "Python import is a mechanism that allows you to include external modules, packages, or specific functions into your current script. It enables code reusability and modular programming by letting you access code from different files and libraries.\n\nPython uses a specific order to search for modules:\n• Be explicit about what you're importing\n• Use virtual environments in LabEx to manage dependencies\n\nBy understanding these fundamentals, you'll be well-equipped to handle Python imports effectively."
    },
    {
        "link": "https://packaging.python.org/guides/installing-using-pip-and-virtual-environments",
        "document": "Install packages in a virtual environment using pip and venv¶\n\nThis guide discusses how to create and activate a virtual environment using the standard library’s virtual environment tool venv and install packages. The guide covers how to:\n• None Install packages into a virtual environment using the command\n\nThis guide has the prerequisite that you are using an official Python version obtained from <https://www.python.org/downloads/>. If you are using your operating system’s package manager to install Python, please ensure that Python is installed before proceeding with these steps.\n\nvenv (for Python 3) allows you to manage separate package installations for different projects. It creates a “virtual” isolated Python installation. When you switch projects, you can create a new virtual environment which is isolated from other virtual environments. You benefit from the virtual environment since packages can be installed confidently and will not interfere with another project’s environment. It is recommended to use a virtual environment when working with third party packages. To create a virtual environment, go to your project’s directory and run the following command. This will create a new virtual environment in a local folder named : The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it . will create a virtual Python installation in the folder. You should exclude your virtual environment directory from your version control system using or similar. Before you can start installing or using packages in your virtual environment you’ll need to it. Activating a virtual environment will put the virtual environment-specific and executables into your shell’s . To confirm the virtual environment is activated, check the location of your Python interpreter: While the virtual environment is active, the above command will output a filepath that includes the directory, by ending with the following: While a virtual environment is activated, pip will install packages into that specific environment. This enables you to import and use packages in your Python application. If you want to switch projects or leave your virtual environment, the environment: Closing your shell will deactivate the virtual environment. If you open a new shell window and want to use the virtual environment, reactivate it. If you want to reactivate an existing virtual environment, follow the same instructions about activating a virtual environment. There’s no need to create a new virtual environment.\n\npip is the reference Python package manager. It’s used to install and update packages into a virtual environment. The Python installers for macOS include pip. On Linux, you may have to install an additional package such as . You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip installed in your user site: The Python installers for Windows include pip. You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip:\n\nWhen your virtual environment is activated, you can install packages. Use the command to install packages. For example,let’s install the Requests library from the Python Package Index (PyPI): pip should download requests and all of its dependencies and install them: Collecting requests Using cached requests-2.18.4-py2.py3-none-any.whl Collecting chardet<3.1.0,>=3.0.2 (from requests) Using cached chardet-3.0.4-py2.py3-none-any.whl Collecting urllib3<1.23,>=1.21.1 (from requests) Using cached urllib3-1.22-py2.py3-none-any.whl Collecting certifi>=2017.4.17 (from requests) Using cached certifi-2017.7.27.1-py2.py3-none-any.whl Collecting idna<2.7,>=2.5 (from requests) Using cached idna-2.6-py2.py3-none-any.whl Installing collected packages: chardet, urllib3, certifi, idna, requests Successfully installed certifi-2017.7.27.1 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22 pip allows you to specify which version of a package to install using version specifiers. For example, to install a specific version of : To install the latest release of requests: To install pre-release versions of packages, use the flag: Some packages have optional extras. You can tell pip to install these by specifying the extra in brackets: pip can install a package directly from its source code. For example, to install the source code in the directory: Additionally, pip can install packages from source in development mode, meaning that changes to the source directory will immediately affect the installed package without needing to re-install: pip can install packages directly from their version control system. For example, you can install directly from a git repository: For more information on supported version control systems and syntax, see pip’s documentation on VCS Support. If you have a local copy of a Distribution Package’s archive (a zip, wheel, or tar file) you can install it directly with pip: If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the Python Package Index (PyPI) at all: This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages. If you want to download packages from a different index than the Python Package Index (PyPI), you can use the flag: If you want to allow packages from both the Python Package Index (PyPI) and a separate index, you can use the flag instead:\n\nPip can export a list of all installed packages and their versions using the command: Which will output a list of package specifiers such as: The command is useful for creating Requirements Files that can re-create the exact versions of all packages installed in an environment."
    }
]