[
    {
        "link": "https://css-tricks.com/snippets/css/a-guide-to-flexbox",
        "document": "The (Flexible Box) module (a W3C Candidate Recommendation as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”). The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space or shrinks them to prevent overflow. Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts.\n\nSince flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”). If “regular” layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout. Items will be laid out following either the (from to ) or the cross axis (from to ).\n• main axis – The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the property (see below).\n• main-start | main-end – The flex items are placed within the container starting from main-start and going to main-end.\n• main size – A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension.\n• cross axis – The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction.\n• cross-start | cross-end – Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.\n• cross size – The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension.\n\nThis defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children. Note that CSS columns have no effect on a flex container. \n\nThis establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.\n• (default): left to right in ; right to left in\n• : right to left in ; left to right in\n• : same as but top to bottom\n• : same as but bottom to top By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property.\n• (default): all flex items will be on one line\n• : flex items will wrap onto multiple lines, from top to bottom.\n• : flex items will wrap onto multiple lines from bottom to top. There are some visual demos of here. This is a shorthand for the and properties, which together define the flex container’s main and cross axes. The default value is . \n\nThis defines the alignment along the main axis. It helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.\n• (default): items are packed toward the start of the flex-direction.\n• : items are packed toward the end of the flex-direction.\n• : items are packed toward the start of the direction.\n• : items are packed toward the end of the direction.\n• : items are packed toward left edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are packed toward right edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are centered along the line\n• : items are evenly distributed in the line; first item is on the start line, last item on the end line\n• : items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.\n• : items are distributed so that the spacing between any two items (and the space to the edges) is equal. Note that that browser support for these values is nuanced. For example, never got support from some versions of Edge, and start/end/left/right aren’t in Chrome yet. MDN has detailed charts. The safest values are , , and . There are also two additional keywords you can pair with these values: and . Using ensures that however you do this type of positioning, you can’t push an element such that it renders off-screen (e.g. off the top) in such a way the content can’t be scrolled too (called “data loss”). \n\nThis defines the default behavior for how flex items are laid out along the cross axis on the current line. Think of it as the version for the cross-axis (perpendicular to the main-axis).\n• / / : items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the rules or the rules.\n• / / : items are placed at the end of the cross axis. The difference again is subtle and is about respecting rules vs. rules.\n• : items are centered in the cross-axis\n• : items are aligned such as their baselines align The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. \n\nThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how aligns individual items within the main-axis. Note: This property only takes effect on multi-line flexible containers, where is set to either or ). A single-line flexible container (i.e. where is set to its default value, ) will not reflect .\n• (default): items are packed in their default position as if no value was set.\n• / : items packed to the start of the container. The (more supported) honors the while honors the direction.\n• / : items packed to the end of the container. The (more support) honors the while end honors the direction.\n• : items evenly distributed; the first line is at the start of the container while the last one is at the end\n• : items evenly distributed with equal space around each line\n• : items are evenly distributed with equal space around them\n• : lines stretch to take up the remaining space The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. The property explicitly controls the space between flex items. It applies that spacing only between items not on the outer edges. The behavior could be thought of as a minimum gutter, as if the gutter is bigger somehow (because of something like ) then the gap will only take effect if that space would end up smaller. It is not exclusively for flexbox, works in grid and multi-column layout as well. \n\nBy default, flex items are laid out in the source order. However, the property controls the order in which they appear in the flex container. Items with the same revert to source order. \n\nThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have set to , the remaining space in the container will be distributed equally to all children. If one of the children has a value of , that child would take up twice as much of the space as either one of the others (or it will try, at least). This defines the ability for a flex item to shrink if necessary. This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The keyword means “look at my width or height property” (which was temporarily done by the keyword until deprecated). The keyword means “size it based on the item’s content” – this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren , , and do. If set to , the extra space around content isn’t factored in. If set to , the extra space is distributed based on its value. See this graphic. This is the shorthand for and combined. The second and third parameters ( and ) are optional. The default is , but if you set it with a single number value, like , that changes the to 0%, so it’s like setting . It is recommended that you use this shorthand property rather than set the individual properties. The shorthand sets the other values intelligently. \n\nThis allows the default alignment (or the one specified by ) to be overridden for individual flex items. Please see the explanation to understand the available values. Note that , and have no effect on a flex item.\n\nFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass to help with some of the prefixing, which also gives you an idea of what kind of things need to be done:\n\nLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. .parent { display: flex; height: 300px; /* Or whatever */ } .child { width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */ } This relies on the fact a margin set to in a flex container absorb extra space. So setting a margin of will make the item perfectly centered in both axes. Now let’s use some more properties. Consider a list of 6 items, all with fixed dimensions, but can be auto-sized. We want them to be evenly distributed on the horizontal axis so that when we resize the browser, everything scales nicely, and without media queries. .flex-container { /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around; } Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. Let’s try something else. Imagine we have a right-aligned navigation element on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. /* Large */ .navigation { display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end; } /* Medium screens */ @media all and (max-width: 800px) { .navigation { /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; } } /* Small screens */ @media all and (max-width: 500px) { .navigation { /* On small screens, we are no longer using row direction but column */ flex-direction: column; } } Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. .wrapper { display: flex; flex-flow: row wrap; } /* We tell all items to be 100% width, via flex-basis */ .wrapper > * { flex: 1 100%; } /* We rely on source order for mobile-first approach * in this case: * 1. header * 2. article * 3. aside 1 * 4. aside 2 * 5. footer */ /* Medium screens */ @media all and (min-width: 600px) { /* We tell both sidebars to share a row */ .aside { flex: 1 auto; } } /* Large screens */ @media all and (min-width: 800px) { /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main { flex: 3 0px; } .aside-1 { order: 1; } .main { order: 2; } .aside-2 { order: 3; } .footer { order: 4; } }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Aligning_items_in_a_flex_container",
        "document": "Flexbox provides several properties to control alignment and spacing, with and being fundamental for centering elements. To center an element, we use the property to align the item on the cross axis, which in this case is the block axis running vertically. We use to align the item on the main axis, which in this case is the inline axis running horizontally. Change the size of the container or nested element in the code example below. The nested element always remains centered.\n\nThe property, set on the flex container, and the property, set on flex items, control the alignment of flex items on the cross axis. The cross axis runs down the columns if is and along the rows if is . In this basic flex example, we're using cross-axis alignment. When we add to a container, the child items become flex items arranged in a row. By default, they will all stretch to match the height of the tallest item, as that item defines the height of the items on the cross axis. If the flex container has a height set, the items will stretch to that height, regardless of how much content is in each item. The reason the items become the same height is that the initial value of , the property that controls alignment on the cross axis, is set to . We can use other values to control how the items align: In the example below, the value of is . Try the other values and see how the items align against each other in the flex container.\n\nThe property sets the property on all of the flex items as a group. This means you can explicitly declare the property to target a single item. The property accepts all of the same values as , plus a value of , which resets the value to that defined on the flex container. In this next live example, the flex container has , which means the items are all aligned to the start of the cross axis. Using the selector, the first item is set to . Another item with the class has set. Change the value of or change the values of on the individual items to see how this works.\n\nThus far, we have looked at alignment behavior when the defaults to while working in a language written top to bottom, with a horizontal main axis and vertical cross axis. Keeping the same writing mode, when the is changed to , the and properties will align the items to the left and right instead of top and bottom; these properties are still aligning items along the cross axis, but the cross axis is now horizontal! You can try this out in the example below, which has a flex container with yet otherwise is exactly the same as the previous example.\n\nAligning content on the cross axis with the property So far, we have focused on aligning items or individual items inside the area defined by a flex container containing a single line of flex items. When flex items are allowed to wrap across multiple lines, the property can be used to control the distribution of space between the lines, also known as packing flex lines. For to have an effect, the cross axis dimension (the height in this case) of the flex container must be greater than needed to display the items. It then works on all the items as a set. The values dictate what happens with the extra available space and the alignment of the entire set of items within it. The property takes the following values: In the live example below, the flex container has a height of , which is more than needed to display our items. The value of is , which means that the available space is shared out between the flex lines, which are placed flush with the start and end of the container on the cross axis. Try out the other values to see how the property works. Once again we can switch our to in order to see how this property behaves when we are working by column. As before, we need enough space in the cross axis to have some free space after displaying all of the items.\n\nNow that we have seen how alignment works on the cross axis, we can take a look at the main axis. Here we only have one property available to us — . This is because we are only dealing with items as a group on the main axis. With we control what happens with available space, should there be more space than is needed to display the items. In our initial example with on the container, the items display as a row and all line up at the start of the container. This is due to the initial value of being , which behaves as . Any available space is placed at the end of the items. The values aren't relevant in this dimension. Otherwise, the property accepts the same values as . In the example below, the value of is . The available space after displaying the items is distributed between the items. The left and right item line up flush with the start and end. If the main axis is in the block direction because is set to , then will distribute space between items in that dimension as long as there is space in the flex container to distribute.\n\nRemember that with all of these alignment methods, the values of and are writing mode-aware. If the value of is and the writing mode is left-to-right, as in English, the items will align starting at the left side of the container. However if the writing mode is right-to-left as in Arabic, the items will line up starting at the right side of the container. The live example below has the property set to to force a right-to-left flow for our items. You can remove this, or change the values of to see how flexbox behaves when the start of the inline direction is on the right.\n\nThe direction of of the line will also change if you change the property — for example, using instead of . In this next example, and define the direction and location of the items within the flex container. In a left to right language, the items line up on the left. Try changing to . You will see that the items now move to the right-hand side, and the visual order of the items is reversed. While this may all seem a little confusing, the rule to remember is that unless you do something to change it, flex items lay themselves out in the direction that words are laid out in the language of your document along the inline, row axis. and will be where the beginning of a sentence of text would start. You can switch them to display in the block direction for the language of your document by selecting . Then, and will be where the top of your first paragraph of text would start. If you change to one of the reverse values, they will lay themselves out from the end axis and in the reverse order to the way words are written in the language of your document. Then, and will change to the end of that axis — so to the location where your lines would wrap if working in rows, or at the end of your last paragraph of text in the block direction.\n\nWe don't have a or property available to us on the main axis as our items are treated as a group on that axis. However it is possible to do some individual alignment in order to separate an item or a group of items from others by using auto margins along with flexbox. A common pattern is a navigation bar where some key items are aligned to the right, with the main group on the left. You might think that this should be a use case for a property. However, consider the image below. As an example, take the following image with three items on one side and two on the other. If were to work on flex items and was set on item d, it would also change the alignment of item e that follows, which may or may not be what is intended. Instead, the d item can be pushed over using CSS margins. In this live example, item 4 is separated from the first three items by setting to , which consumes all the space it can in its axis. This is how centering a block with auto left and right works. Each side tries to take as much space as it can, and so the block is pushed into the middle. In this live example, the flex items are arranged in a row with the basic flex values, and the class , set on the fourth item, applies to that item. Try removing the class on the fourth item or adding the class to a different item to see how it works.\n\nTo create a gap between flex items, use the , , and properties. The property creates gaps between items in a row. The property creates gaps between flex lines when you have set to . The property is a shorthand that sets both and . The gaps between flex items or flex lines depend on the direction. If the property creates rows, the first value defines the gap between flex lines, and the second value defines the gap between items within each line. With columns (when is set to or ), the first value defines the gap between flex items, and the second value defines the gaps between flex lines."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/25098042/fill-remaining-vertical-space-with-css-using-displayflex",
        "document": ""
    },
    {
        "link": "https://joshwcomeau.com/css/interactive-guide-to-flexbox",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/flex",
        "document": ""
    },
    {
        "link": "https://css-tricks.com/snippets/css/a-guide-to-flexbox",
        "document": ""
    },
    {
        "link": "https://w3schools.com/css/css3_flexbox.asp",
        "document": ""
    },
    {
        "link": "https://w3schools.com/cssref/css3_pr_flex-grow.php",
        "document": ""
    }
]