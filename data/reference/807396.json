[
    {
        "link": "https://en.cppreference.com/w/cpp/utility/pair",
        "document": "is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a std::tuple with two elements.\n\nIf neither nor is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of is trivial.\n\nThis specialization of enables efficient implementation of and for printing a object when both and enable it.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/62449141/stdvector-of-key-value-pairs-with-different-types",
        "document": "I am trying to create a small interface function and to send it to a JSON formatter class. The JSON works only with (unlimited) key-value pairs, but the value can be (only):\n\nBut I don't really like it (3 almost similar structures in ), perhaps there is a better C++ way.\n\nIdeally for me is to have something (templated) cleaner and to work like:\n\nLE: I am using C++11, cannot use another standard unfortunately."
    },
    {
        "link": "https://scaler.com/topics/vector-pair-in-cpp",
        "document": "A vector in C++ is a dynamic array that can store a collection of elements of the same data type. It's a versatile data structure, often likened to a list or array in other programming languages. Vectors provide dynamic resizing, meaning they can grow or shrink as needed, making them handy for managing data. They offer efficient random access and insertion/removal at the end. Vectors are part of the C++ Standard Template Library (STL), providing a range of helpful functions and methods to manipulate data.\n\nWhat is Vector Pair in C++? Vector Pair is a powerful feature in C++ that allows programmers to work with pairs of elements stored within a vector container. It is particularly useful when you must group and perform various operations on two related pieces of data, like coordinates, keys, or values. In this article, we will delve into the syntax and usage of Vector Pair in C++, shedding light on its essential attributes. The syntax for declaring and using Vector Pair in C++ is straightforward. You must include the <vector> header to utilize the vector container and <utility> for pairs. Here's a basic outline:\n• We include the necessary headers for vectors and pairs.\n• Declare a vector that will store pairs of an integer and a double.\n• Use push_back to add pairs to the vector. We create pairs using .\n• Access individual elements of the pairs using the and member functions. Vector Pair offers flexibility in choosing the types for the pair elements. You can use custom classes, structures, or standard data types per your requirements. Memory management is crucial when dealing with vector pairs, particularly with large data sets. Vectors dynamically allocate memory, so it's essential to be mindful of memory usage to prevent inefficiencies and potential crashes. When working with large data sets, consider using reserve() to preallocate memory, reducing frequent reallocations and improving performance. Modern C++ features like range-based for loops and lambda expressions enhance code readability. A range-based for loop simplifies iteration through elements, while lambdas facilitate custom operations on vector pairs. Standard library algorithms like std::find, std::sort, and std::for_each provide efficient solutions for common tasks. For instance, std::find quickly locates elements, std::sort sorts pairs based on specified criteria, and std::for_each simplifies element-wise operations. Vector Pair is extensively employed in scenarios where you must maintain associations between two pieces of data. Some common applications include:\n• Implementing algorithms like Dijkstra's shortest path algorithm where nodes and distances are paired.\n• Maintaining data in a sorted order based on one of the pair elements. Understanding the syntax and usage of Vector Pair in C++ is essential for any programmer. This feature simplifies the management of paired data elements and opens up possibilities for various applications. By following the provided syntax and examples, you can harness the power of Vector Pair to enhance your C++ programming skills and efficiently handle related data pairs.\n\nHow to Use a Vector Pair in C++? Vectors are versatile containers in C++ that can hold various data types. While vectors are powerful, combining them with pairs can unlock even greater functionality. In this guide, we will explore how to use vector pairs in C++ for various purposes, including accessing and modifying data, sorting and searching elements, and employing efficient iteration techniques. Accessing and modifying elements within a vector pair is straightforward. First, let's create a vector of pairs: In this example, we create a vector of pairs, allowing us to store both an integer and a string for each student. We then access and modify the second element of the first pair to change Alice's name to Alicia. Sorting and searching within a vector pair can be accomplished using standard C++ functions or custom comparators. Here's how to sort a vector pair based on the first element (integer in our case): Iterating through a vector pair is similar to iterating through a regular vector. You can use range-based for loop or iterator to traverse the elements: In this guide, we've explored how to use vector pairs in C++ for various essential tasks, such as accessing, modifying, sorting, searching, and iterating. By harnessing the power of vector pairs, you can efficiently manage and manipulate paired data in your C++ programs.\n\nLet us now see several examples of vector pairs, explore their applications, and demonstrate how they can be leveraged in real-world scenarios. A vector pair, also known as a std::vector<std::pair<T1, T2>>, is a container that stores pairs of elements. These elements can be of different types (T1 and T2). Let's start with a basic example: In this example, we create a vector pair to store student IDs (int) and their corresponding names (string). We use push_back to add elements and then iterate through the vector to print the pairs. Vector pairs can be sorted based on each pair's first or second element. Here's an example of sorting based on the first element (student ID): This code sorts the vector pair based on student IDs in ascending order. You can perform searches in vector pairs using algorithms like std::find: This code demonstrates searching for a specific student ID in the vector pair. Vector pairs in C++ are incredibly useful for storing and manipulating pairs of related data. They are versatile containers that can be sorted, searched, and customized to suit various applications. Whether you're managing student records, employee details, or any other related data, vector pairs offer a straightforward and efficient solution in C++ programming."
    },
    {
        "link": "https://geeksforgeeks.org/pair-in-cpp-stl",
        "document": "In C++, pair is used to combine together two values that may be of different data types or same data types as a single unit. The first element is stored as a data member with name ‘first’ and the second element as ‘second‘.\n\nExplanation: In this program, we created a pair p1 of type int and string with the values {1, “Geeks”}.\n\nThe pair container is defined in <utility> header file.\n• T1: Data type of the first element.\n• T2: Data type of the second element.\n• p: Name assigned to the pair.\n\nIn C++, pair can be declared and initialized in multiple ways as shown below:\n\nWe can declare an empty pair using the below declaration:\n\nWe can initialize a pair directly by assigning values to first and second.\n\nWe can use make_pair() method to initialize pair.\n\nLet’s take simple example to demonstrate all ways:\n\nExplanation: In the above program, we created three pairs:\n• pair<int, string> p1 creates an empty pair of type int and string.\n• pair<int, string> p2 = {1, “Geeks”} creates a pair and initializes it with the values {1, “Geeks”} using curly braces.\n• pair<int, string> p3 = make_pair(2, “ForGeeks”) creates a pair and initializes it with the values {2, “ForGeeks”} using the make_pair method.\n\nAll the values should match the type of the pair, otherwise, a compiler error will be displayed.\n\nThe basic operations on pairs are show below:\n\nIn pair, first and second values are stored as data members. So, we can access them by using their name with (.) operator.\n\nExplanation: In the above program, p.first accesses the first values of the pair, which is 1. p.second accesses the second element of the pair, which is “Geeks“.\n\nWe update the elements of pair like accessing elements from pair but in place of access, we just assign new value using assignment operator.\n\nExplanation: In the above code, p.first = 2 directly changes the first value of the pair to 2, and p.second = “ForGeeks”; directly changes the second value of the pair to “ForGeeks”.\n\nJust like other data types, we can use relational operators with pairs. They initially compare the first value. If it does not give result, then second value is compared. The following table describes the behaviour of these operators for pairs:\n\nReturns true if both pairs are equal, otherwise false. Returns true if pairs are not equal, otherwise false. Returns true if the LHS pair is greater than the RHS pair, otherwise false. Returns true if the left operand is less than the right operand, otherwise false. Returns true if the left operand is greater than or equal to the right operand, otherwise false. Returns true if the left operand is less than or equal to the right operand, otherwise false.\n\nWe can store extract and store the two values of the pair in two different variables of same type using tie() function.\n\nExplanation: In this program, the first and second value of the pair p is extracted into the variable a and s using the function tie().\n\nA pair is commonly used for the following purposes:\n• None Storing key-value pairs in other containers, especially maps.\n• None Sorting containers on the basis of multiple criteria."
    },
    {
        "link": "https://stackoverflow.com/questions/12702561/iterate-through-a-c-vector-using-a-for-loop",
        "document": "Is there a reason I don't see this in C++? Is it bad practice?\n\nI am new to the C++ language. I have been starting to use vectors, and have noticed that in all of the code I see to iterate though a vector via indices, the first parameter of the for loop is always something based on the vector. In Java I might do something like this with an ArrayList:\n\nThe reason why you don't see such practice is quite subjective and cannot have a definite answer. Because I have seen many of the codes which uses your mentioned way rather than style code! Following can be reasons of some programmers not considering way of looping:\n• Being paranoid about calling every time in the loop condition (i.e. . However either it's a non-issue or can be fixed trivially\n• Preferring over the loop itself\n• Later changing the container from to other one (e.g. , ) will also demand the change of the looping mechanism, because not every container support style of looping (i.e. ) C++11 provides a good facility to iterate through the containers. That is called \"Range based 'for' loop\" (or \"Enhanced 'for' loop\" in Java). With a little code, one can traverse through the full (which is mandatory!) :\n\nThe cleanest way of iterating through a vector is via iterators: for (auto it = begin (vector); it != end (vector); ++it) { it->doSomething (); } or (equivalent to the above) Prior to C++0x, you have to replace auto by the iterator type and use member functions instead of global functions begin and end. This probably is what you have seen. Compared to the approach you mention, the advantage is that you do not heavily depend on the type of . If you change to a different \"collection-type\" class, your code will probably still work. You can, however, do something similar in Java as well. There is not much difference conceptually; C++, however, uses templates to implement this (as compared to generics in Java); hence the approach will work for all types for which and functions are defined, even for non-class types such as static arrays. See here: How does the range-based for work for plain arrays?\n\nIs there any reason I don't see this in C++? Is it bad practice? No. It is not a bad practice, but the following approach renders your code certain flexibility. Usually, pre-C++11 the code for iterating over container elements uses iterators, something like: This is because it makes the code more flexible. All standard library containers support and provide iterators. If at a later point of development you need to switch to another container, then this code does not need to be changed. Note: Writing code which works with every possible standard library container is not as easy as it might seem to be.\n\nThe right way to do that is: for(std::vector<T>::iterator it = v.begin(); it != v.end(); ++it) { it->doSomething(); } Where T is the type of the class inside the vector. For example if the class was CActivity, just write CActivity instead of T. This type of method will work on every STL (Not only vectors, which is a bit better). If you still want to use indexes, the way is:\n\nUsing the auto operator really makes it easy to use as one does not have to worry about the data type and the size of the vector or any other data structure Iterating vector using auto and for loop You can also use this method to iterate sets and list. Using auto automatically detects the data type used in the template and lets you use it. So, even if we had a of or the same syntax will work just fine\n\nA correct way of iterating over the vector and printing its values is as follows: #include<vector> // declare the vector of type int vector<int> v; // insert elements in the vector for (unsigned int i = 0; i < 5; ++i){ v.push_back(i); } // print those elements for (auto it = v.begin(); it != v.end(); ++it){ std::cout << *it << std::endl; } But at least in the present case it is nicer to use a range-based for loop:\n\n \n\n (You may also add after to make a reference to the elements rather than a copy of them. It is then very similar to the above iterator-based approach, but easier to read and write.)\n\nThere's a couple of strong reasons to use iterators, some of which are mentioned here: i.e., if you go from a std::vector to a std::list, or std::set, you can't use numerical indices to get at your contained value. Using an iterator is still valid. If you modify your container in the middle of your loop, the next time you use your iterator it will throw an invalid iterator exception.\n\ndon't forget examples with const correctness - can the loop modify the elements. Many examples here do not, and should use cont iterators. Here we assume Note also, that with the C++11 notation, the default is to copy the element. Use a reference to avoid this, and/or to allow for original elements to be modified: vector<T> v; // ... for (auto t : v) { t.changeSomething(); // changes local t, but not element of v t.doSomething(); } for (auto& t : v) { // reference avoids copying element t.changeSomething(); // changes element of v t.doSomething(); } for (const auto& t : v) { // reference avoids copying element t.doSomething(); // element can not be changed }\n\nI was surprised nobody mentioned that iterating through an array with an integer index makes it easy for you to write faulty code by subscripting an array with the wrong index. For example, if you have nested loops using and as indices, you might incorrectly subscript an array with rather than and thus introduce a fault into the program. In contrast, the other forms listed here, namely the range based loop, and iterators, are a lot less error prone. The language's semantics and the compiler's type checking mechanism will prevent you from accidentally accessing an array using the wrong index."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-iterate-through-a-vector-in-cpp",
        "document": "How to Iterate Through a Vector in C++?\n\nIterating or traversing a vector means accessing each element of the vector sequentially. In this article, we will learn different methods to iterate over a vector in C++.\n\nThe simplest way to iterate a vector is by using a range based for loop. Let's take a look at a simple example that iterate the vector using range based for loop:\n\nThe range-based for loop allows users to iterate through the vector without bothering about size and iterators. However, the i in the above program is a copy of the element. To work with the actual vector elements, i should be defined as a reference.\n\nThe above method is only preferred when you want to iterate the whole vector. So, C++ also provides other different methods to iterate through the vector that may be more relevant in some cases:\n\nThis method is the traditional way to traverse the std::vector in which we access each element using index till the index is less than the size of the vector. The size of the vector can be determined using vector size() method.\n\nThis method provides full control over the range of iteration and allows direct access to elements. It is useful when index values are needed for processing.\n\nVectors can be iterated using the vector begin() and end() iterators. These iterators support the increment operation, so we can dereference and increment the begin iterator till it reaches the end iterator.\n\nThis method is useful while working with STL algorithms that need iterators to work.\n\nTo traverse the iterator in reverse, vector rbegin() and rend() iterators can be used. They are used in the similar way as normal vector iterators.\n\nWe have discussed all the primary methods of iterating over a vector. Other methods are the possible variation of these methods to suit specific needs of the particular case. Each approach has its advantages, so the choice of method depends on the context and the problem at hand."
    },
    {
        "link": "https://stackoverflow.com/questions/60349386/c-how-to-loop-through-integer-elements-in-a-vector",
        "document": "In order to do this properly (and safely), you need to understand how works.\n\nYou may know that a vector works much like an array with \"infinite\" size. Meaning, it can hold as many elements as you want, as long as you have enough memory to hold them. But how does it do that?\n\nA vector has an internal buffer (think of it like an array allocated with ) that may be the same size as the elements you're storing, but generally it's larger. It uses the extra space in the buffer to insert any new elements that you want to insert when you use .\n\nThe amount of elements the vector has is known as its size, and the amount of elements it can hold is known as its capacity. You can query those via the and member functions.\n\nHowever, this extra space must end at some point. That's when the magic happens: When the vector notices it doesn't have enough memory to hold more elements, it allocates a new buffer, larger1 than the previous one, and copies all elements to it. The important thing to notice here is that the new buffer will have a different address. As we continue with this explanation, keep this in mind.\n\nNow, we need to talk about iterators. I don't know how much of C++ you have studied yet, but think of an old plain array:\n\nyou can take the address of the first element by doing:\n\nand you can take the address of the end of the array (more specifically, one past the last element) by doing:\n\nif you have these addresses, one way to iterate the array and print all elements would be:\n\nAn iterator works much like a pointer. If you increment it (like we do with the pointer using above), it will point to the next element. If you dereference it (again, like we do with the pointer using above), it will return the element it is pointing to.\n\nprovides us with two member functions, and , that return iterators analogous to our and pointers above. This is what you need to keep in mind from this section: Internally, these iterators have pointers that point to the elements in the vector's internal buffer.\n\nTheoretically, you can use and to iterate a vector like this:\n\nNote that, apart from the ugly type of , this is exactly the same as our pointer example. C++ introduced the keyword , that lets us get rid of these ugly types, when we don't really need to know them:\n\nThis works exactly the same (in fact, has the exact same type), but now we don't need to type (or read) that uglyness.\n\nBut, there's an even better way. C++ has also introduced range-based :\n\nthe range-based construct does several things for you:\n• It calls and 2 to get the upper and lower bounds of the range we're going to iterate;\n• Keeps an internal iterator (let's call it ), and calls on every step of the loop;\n• Dereferences the iterator (by calling ) and stores it in the variable for us. This means we do not need to dereference it ourselves (note how the line looks different from the other examples)\n\nputting it all together\n\nLet's do a small exercise. We're going to iterate a vector of numbers, and, for each odd number, we are going to insert a new elements equal to .\n\nThis is the naive way that we could probably think at first:\n\nOf course, this is wrong! Vector will start with a capacity of . This means that, when we try using for the first time, it will allocate a new buffer.\n\nIf the buffer was reallocated, its address has changed. Then, what happens to the internal pointer that the range-based for is using to iterate the vector? It no longer points to the buffer!\n\nThis it what we call a reference invalidation. Look at the reference for . At the very beginning, it says:\n\nOnce the range-based tries to increment and dereference the now invalid pointer, bad things will happen.\n\nThere are several ways to avoid this. For instance, in this particular algorithm, I know that we can never insert more than new elements. This means that the size of the vector can never go past after the loop has ended. With this knowledge in hand, I can increase the vector's capacity beforehand:\n\nIf for some reason I don't know this information for a particular algorithm, I can use a separate vector to store the new elements, and then add them to our vector at the end:\n\nFinally, there's the old plain , using an to iterate. The iterator cannot be invalidated because it holds an index, instead of a pointer to the internal buffer:\n\nHopefully by now, you understand the advantages and drawbacks of each method. Happy studies!\n\n1 How much larger depends on the implementation. Generally, implementations choose to allocate a new buffer of twice the size of the current buffer.\n\n2 This is a small lie. The whole story is a bit more complicated: It actually tries to call and . Because is in the namespace, it ends up calling and , which, in turn, call and . All of this machinery is there to ensure that the range-based works not only with standard containers, but also with anything with a proper implementation for and . That includes, for instance, regular plain arrays."
    },
    {
        "link": "https://dev.to/vikramvee/three-different-ways-to-iterate-vectors-in-c-using-for-keyword-3871",
        "document": "Hello friends, Vectors in C++ are equivalent of List in C# and Java. Vectors are basically used to hold the elements of same type. More specifically it is a collection of elements. The elements could be of any primitive type like int, string, float or it could be any user defined type.\n\nPlease note that you should be using C++ 11 or above to use some of the features of the article.\n\nIn this article I will show you a small code snippet for different ways to iterate over the vectors in C++.\n\n\n\nIn the above code I have declared a variable of type vector named vec. And I am inserting 10 elements to the vector.\n\nThe elements will be inserted one after another in the increasing order of the index of the array. But we are not here to see how the elements are inserted, there are couple of more ways to do the same.\n\nSince we have all the elements in the vector defined in the previous code snippet. What if we want to iterate over vector and find out about these items. There are three different ways we can iterate over the elements of vector in C++.\n\nThe first way to iterate over the elements is using the range for. It's new in C++ 11 and made the iteration even more attractive.\n\n\n\nBasically in the above code, I am iterating over the vector using auto keyword. This will auto determine the type of the elements in the vector. It takes each and every element in the vector and proceeds for its task for that element. Here we are simply printing the element.\n\nThe second one is the traditional way we use in programming. By declaring a variable which will take care of the elements and size of the array. The variable will act as index for the vector elements.\n\nIn this approach we have to be bit careful as we should know about our vector. What is the size of the elements, how many iterations we want for the vector, the type of the elements in the vector, getting the elements using the index and so on.\n\nSize returns unsigned integer that is the reason I have used the same for the variable deceleration. You can use integer as well but you will get a warning for the same.\n\n\n\nThe third way as shown in the below code snippet is use to iterators. There are methods provided by the C++ compiler to get the start and end iterator of the vector. The begin method takes the vector as the parameter and returns the beginning of the vector. The end of the vector is provided by end function. And there is a comparison which takes care of the end of the vector.\n\nInstead of using the index notation or square brackets to get the element from the vector we use the reference of the iterator to get the current element.\n\n\n\nIt all depends on the programmer which way he wants to iterate over the vector. But all the three ways mentioned above serve the same purpose. I would personally go for first approach due to ease of syntax and no need of adding an extra parameter.\n\nThis was a short post to quickly review all the ways to iterate over a vector using the for keyword in C++. There are other ways as well to achieve the same using while and do..while."
    },
    {
        "link": "https://asawicki.info/news_1770_3_ways_to_iterate_over_stdvector",
        "document": "This will be a short article about basics of C++. is a container that dynamically allocates a continuous array of elements. There are multiple ways to write a for loop to iterate over its elements. In 2018 I've written an article \"Efficient way of using std::vector\" where I compared their performance. I concluded that using iterators can be orders of magnitude slower than using a raw pointer to its data in Debug configuration. This time, I would like to focus on how using \"modern\" C++ also limits our freedom.\n\nLanguage purists would probably say that the recommended way to traverse a vector is now a range-based for loop, available since C++11. This is indeed the shortest and the most convenient form, but inside the loop it gives access only to the current element, not its index and not any other elements.\n\nImagine that while traversing the vector, for some elements that are not the first and that meet certain criteria, we want to compare them with their previous element. This is not possible in a range-based for loop above, unless we memorize the previous element in a separate variable and update it on every iteration. Using iterators gives us the possibility to move forward or backward and thus to access the previous element when needed.\n\nThis is more flexible, but what if we want to insert some elements to the vector while traversing it? There is a trap awaiting here because method may invalidate all iterators when underlying array gets reallocated. This is why only iterating using an index is safe here:\n\nNote that pretty much any modern programming language allows to insert and remove elements from a dynamic array using an index, e.g.:\n• Even Rust, which also supports iterators, offers methods , that take index as parameter.\n\nOnly C++ requires clumsy syntax with iterators like .\n\nI know that the code fragments shown above can be written in many other ways, e.g. using keyword. If you have an idea for writing any of these loops better way, please leave a comment below and let's discuss."
    }
]