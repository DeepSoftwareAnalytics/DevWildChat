[
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_GPIO",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what GPIO is and how to use it through examples.\n\nGPIO stands for general purpose input/output. It is a type of pin found on an integrated circuit that does not have a specific function. While most pins have a dedicated purpose, such as sending a signal to a certain component, the function of a GPIO pin is customizable and can be controlled by the software.\n• Pin Mode : Each port bit of the general-purpose I/O (GPIO) ports can be individually configured by software in several modes:\n• Pin characteristics :\n• Input : no pull-up and no pull-down or pull-up or pull-down\n• Output : push-pull or open-drain with pull-up or pull-down capability\n• Alternate function : push-pull or open-drain with pull-up or pull-down capability.\n• Change the rising and falling edge when the pin state changes from high to low or low to high.\n• A higher GPIO speed increases the EMI noise from STM32 and increases the STM32 consumption.\n• It is good to adapt the GPIO speed to the peripheral speed. For example, low speed is optimal for toggling GPIO at 1 Hz, while using SPI at 45 MHz requires very high speed setting.\n\nLearn how to Toggle a pin on STM32L476 Nucleo board using Hardware Abstraction Layer (HAL) library and learn how to setup the pin and GPIO port in STM32CubeIDE.\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n• Select NUCLEO-L476RG using the Board Selector as shown in the figure below:\n\n\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n• You will then get a popup asking if you want to initialize peripherals to their default configuration.\n• No need to configure any peripheral as only the core/Flash/SRAMs are used (default peripherals).\n• If you want to start the project with a board, the LED pin is already selected (PA5 on NucleoL476RG. For other boards refer to the user manual).\n• Output speed set to very high is important for faster peripherals such as SPI or USART.\n\nThe easiest way to generate the code is to save your current project : Ctrl + S \n\n The code is generated so you can see it in the left side of the screen in the project explorer \n\n \n\n Now, open the main.c file which is the main source file for this application\n• The LED toggling is done with a HAL function inside main.c\n• Click on Debug button (to run step by step)\n• Or on Run button (to execute) \n\n\n\nEvery 500 ms the green LED state changes."
    },
    {
        "link": "https://controllerstech.com/stm32-gpio-input-configuration",
        "document": "In the previous tutorial, we covered how to use the GPIO pin as output using Registers. This tutorial will cover how to configure the pin as input, and then how to read it’s state.\n\nI will use a button to read the input state of the pin. In order to configure the pin in the input mode, we need to follow the steps mentioned below /************** STEPS TO FOLLOW ***************** 1. Enable GPIOA clock 2. Set the PIN PA5 as input 3. Configure the Pull UP / Pull Down mode ************************************************/ The GPIO clock can be enabled in the RCC_AHB1ENR Register As you can see above, the 0th bit of RCC_AHB1ENR Register enables the clock for the GPIOA. That’s why we need to write a 1 in the 0th position To configure the pin as input, we will modify the GPIOx_MODER Register. This register is responsible for configuring different modes for the GPIO, and in this case we will configure it as the input mode Since I am using pin PA1, I need to modify the pins 2 and 3. This basically works like, if the PIN is ‘y‘, the we need to configure the bits ‘2y’ and ‘2y+1’\n\nAlso, in order to set the pin as input, we need to set the bits (3:2) as 0:0. This means that we need to write a ‘0’ in the 2nd and 3rd positions I am going to configure the pin as the Pull-Up pin. The reason for the same is that the button is connected as shown below When the button will be pressed, the current from the PA1 will sink into the ground, and the PA1 will go LOW To configure the Pull UP / Pull DOWN, we need to modify the GPIOx_PUPDR Register As we need to configure the Pull-UP for the the pin PA1, we need to modify respective bits (3:2). I want to set the Pull-up here, so i need to configure the bits (3:2) as 0:1 That’s all for the configuration of the GPIO as input pin. To configure the Pin as the input in F1 series, the steps are shown below /*************>>>>>>> STEPS FOLLOWED <<<<<<<<************ 1. Enable GPIO Clock 2. Set the required Pin in the INPUT Pull-up/ Pull-down Mode 3. Configure the ODR (1-> Pull UP, 0-> Pull down) ********************************************************/ Let’s cover them all one by one Since we are using the pin PA1 as the input, The GPIOA clock can be enabled in the RCC_APB2ENR Register As you can see the 2nd bit of APB2ENR Register controls the GPIOA Clock. So to enable the clock, we will write a ‘1’ in this position To control the mode of the pin, we need to modify the Control Register GPIOx_CR This Control Register is divided into 2 Registers of 32 bits each i.e CRL(pins 0 to 7) and CRH(pins 8 to 15). Since we are using PA1, we will modify the CRL Register\n• As you can see above, each pin can be controlled using the 4 bits. For PA1, these bits are 7:6:5:4\n• The lower 2 bits can be used to select the mode i.e output or input\n• The Higher bits can be used to configure this mode\n• Also note that the reset state for the CNF bits is 0:1, so we need to clear the bits before setting a new value there Here we have selected the input mode with Pull-up/Pull-down mode, but to select the either mode, there is no special register here. This description is provided in the table 20: Port bit configuration table as per the instructions in the picture above. This table can be seen below To set the Pull-up register, we need to write a ‘1’ in the Output Data Register (GPIOx_ODR) GPIOA->ODR |= (1<<1); // --> PA1 is in Pull UP mode This completes the GPIO Configuration for the F1 Series How to Read the Pin State To read the state of the pin, we will check the Input Data Register (IDR) IDR is a read only register. The respective bit either set or reset depending on the state of the PIN. Now since I am using the Pull-UP for pin PA1 here, the 1st bit of IDR will always be HIGH. When the button is pressed, the current from PA1 will sink into the ground, and the pin will be LOW, and so does the bit 1. So basically we wait for the 1st bit of the IDR to go LOW. And when it is low, indicating the button has been pressed, we can do the processing. int count = 0; int main () { SysClockConfig (); GPIOConfig (); while (1) { if (!(GPIOA->IDR &(1<<1))) { while (!(GPIOA->IDR &(1<<1))); count++; } } } Here we check for the bit 1 of the IDR, if it is low, we increment the count variable.\n\nSo whenever the button is pressed, the count variable will increment As you can see above, the count variable increments to 9, indicating the button has been pressed 9 times You can help with the development by Below.\n\nTo download the project, click the button."
    },
    {
        "link": "https://deepbluembedded.com/stm32-gpio-tutorial",
        "document": "In this STM32 GPIO tutorial, we’ll discuss the STM32 GPIO hardware’s internal functionalities. How it works on low-level, so you can configure it in the best way to meet your applications’ needs. We’ll get into the GPIO speed, alternative functions, locking mechanism, and different possible configurations. So let’s get started!\n\nEach of the general-purpose I/O ports has two 32-bit configuration registers, two 32-bit data registers, a 32-bit set/reset register, a 16-bit reset register, and a 32-bit locking register. Each I/O port bit is freely programmable, however, the I/O port registers must be accessed as 32-bit words (half-word or byte accesses are not allowed). The purpose of the set/reset registers is to allow atomic read/modify accesses to any of the GPIO registers. This way, there is no risk that an IRQ occurs between the read and modify access.\n\nHere is a digital diagram for the internal structure of a typical GPIO pin. It shows the diode protection, internal pull-up or down enable/disable, and also the push-pull output driver, output enable/disable for switching between input/output pin modes, Schmitt-triggered digital input, and analog input.\n\nThe STM32 GPIO output voltage level is 3.3v and the GPIO input voltage is also 3.3v while some of these input pins are 5v tolerant. But you have to refer to the datasheet to make sure which input pins are 5v tolerant.\n\nYou have to assume that all GPIO pins are not 5v tolerant by default until you find in the datasheet that a specific pin is 5v tolerant, only then you can use it as a 5v pin. The pins are mostly 3.3V and can be damaged when hooked up to 5V digital input lines. Level shifting may be mandatory in many cases.\n\nSTM32 GPIO pins have a maximum current limit of 25mA per IO pin. This is the maximum current that can be sourced or sunk by any IO pin.\n\nSo you have to be careful with the voltage level for input pins. And also you’ve to pay attention to the output current when you set GPIO output pins. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as per the datasheet. And you’ve to check it for the specific target STM32 microcontroller you’re dealing with.\n\nThe STM32 GPIO lines have a programmable speed control that can be used to set the “slew rate” of the IO lines which dictates the maximum allowable speed that the IO line can be driven at. In this section, we’ll summarize this GPIO speed control feature with all of its possible configurations (options).\n\nWhen a GPIO pin is set to input mode, the data present on the I/O pin is sampled into the Input Data Register every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins.\n\nWhen a GPIO pin is set to output mode, you’ll have the option to configure the pin speed mode by programming the respective bits in the configuration registers. Down below is a table for the different modes available in the datasheet for the STM32F103C8 microcontroller.\n\nHowever, other microcontrollers will have different options for the pin output speed. For example, the other microcontroller we’ll be using in this course STM32L432KC. It has a dedicated speed control register for GPIO pins, which have 4 different speed options: Low-speed, Medium-speed, High-speed, and Very High-speed.\n\nYou’ll find what do these speed grades translate to in the device datasheet IO pin characteristics. Here is the table for this parameter from the STM32L432KC datasheet table.\n• None Very High Speed -> Up to\n\nThere is no need for the software to disable interrupts when programming the GPIOx_ODR at the bit level: it is possible to modify only one or several bits in a single atomic APB2 write access. This is achieved by programming to ‘1’ the Bit Set/Reset Register (GPIOx_BSRR, or for reset only GPIOx_BRR) to select the bits to modify. The unselected bits will not be modified.\n\nAll ports have external interrupt capability. To use external interrupt lines, the port must be configured in input mode. We’ll discuss this in a more detailed manner when we get into the EXTI (external interrupt/event controller) topic.\n\nTo optimize the number of peripheral I/O functions for different device packages, it is possible to remap some alternate functions to some other pins. This is achieved by software, by programming the corresponding registers.\n\nThis option can help you remap the peripherals io pins, so you don’t have to change so much in the PCB layout when you change the target microcontroller on the board. This can be extremely advantageous and ease the routing process. And helps you move the high-speed signals away so as to reduce the noise level at certain parts.\n\nThe locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied to a port bit, it is no longer possible to modify the value of the port bit until the next reset.\n\nSubject to the specific hardware characteristics of each I/O port listed in the datasheet, each port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software in several modes:\n\nNot all STM32 GPIO Pin are 5v tolerant. Mostly they are 3.3v. You have to enable the clock for the GPIO you want to use regardless of the mode of operation. When configuring a GPIO output pin, you can select the speed suitable for your application whether you need high-frequency switching on the IO line or not.\n\nThe APB2 bus speed determines the sampling rate for all GPIO input configured pins. You can disconnect any GPIO pin (make it high impedance) by setting it into input mode with Hi-Z. You can freeze or lock the GPIO pins configuration after the system initialization if no change is intended using the locking mechanism.\n\nAlternative function pins can be interchanged (remapped) internally so you can enjoy more freedom in routing these signals. All STM32 GPIO pins are interrupt-capable pins but have to be configured within the EXTI as we’ll see later on in this STM32 tutorials series.\n\nYou can check the STM32 GPIO tutorials below to learn more about STM32 GPIO and do some example projects to practice what you’ll learn."
    },
    {
        "link": "https://st.com/resource/en/application_note/an4899-stm32-microcontroller-gpio-hardware-settings-and-lowpower-consumption-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://medium.com/vicara-hardware-university/stm32-guide-gpio-and-buttons-8303e6c8cb44",
        "document": "STM32 is a diverse family of 32-bit microcontroller used in a wide variety of applications today, ranging from simple toys to even complex control systems like home appliances. As a result, being able to develop applications on this platform is an essential skill. With that in mind, let us start with learning how to develop apps using simple GPIO and Buttons.\n• This is not a tutorial for C programming, therefore going forward I shall assume a good understanding of C and it basics.\n• If you are a beginner to STM32 CubeIDE, I suggest you to refer to another blog I have written on getting started with CubeIDE.\n• It suggested but not necessary to have access to a STM32 discovery kit, preferably the STM32F407-Discovery Board. If you have another board, you can still follow along as the core concepts and code syntax will remain the same across target devices.\n\nHardware Abstraction Library(HAL) is a part of developer libraries provided by STMicroelectronics for ease of development. The abstraction library is a set of functions and definitions which make it possible for developers to focus on getting their codes running instead of being bogged down with setting all the plethora of registers and bits to get a simple I/O operation possible. Using the functions in the HAL library, developers can simply call a single function to perform operations like read I/O data, or even perform complex processes like SPI or I2C.\n\nGPIO stands for General Purpose Input-Output. All pins on a STM32 microcontroller operate as a GPIO. These pins however can perform only a pre-defined set of operations depending on how the microcontroller registers for the GPIO is initialized. These modes of operations are:\n\nThe STM32F4 — Discovery Kit has 4 user accessible LED and a single Push-Button. In the image, it is the blue button.\n\nThe LED’s are connected to pins 12,13,14 and 15 on Port D of the GPIO.\n\nThe push-button is on Pin 0 of Port A. Since, these values are fixed, in this tutorial, we will follow the same convention.\n\nThere obviously are other functions for GPIO like locking and interrupts, but in this tutorial we will be focusing on only these and in most cases, you will be using only these as well.\n\nThe red LED on the board is at pin GPIOD.12. This information is available on the datasheet for the discovery board. I will provide a link in the Sources section of the article.\n\nHere, the things to note are that our port is GPIOD and pin is GPIO_Pin_12. This is as per the HAL conventions. gpios’ are referred as GPIOx and pins as GPIO_PIN_x. If you peek into their definitions, you will find that GPIOD is actually a 32-bit memory location as is GPIO_Pin_12.\n\nAlso, we need to add a delay after each toggle. If we don’t do this, the LED will toggle so fast that our eyes will not be able to perceive it. For that, we use HAL_Delay(x) function. x here stands for the number of milliseconds of delay.\n\nThus, in the while loop of the main function, we add the following code.\n\nHit Fn-11 key to start building and debugging. The LED should toggle with half second interval.\n\nA more practical approach is turning an LED on when a button is pressed. This an example of real-time application of microcontroller and this same design can be upgraded to more complex solutions with relative ease.\n\nThe process flow involves turning the LED off before loop execution, then wait for button input. If the button GPIO is 1(logical HIGH), then the LED turns on, else LED remain off.\n\nThe following code snippet is a demo:\n\nHit Fn-11 key to start building and debugging. The LED should turn on each time the button is pressed and turns off when the button is released.\n\nThe above code snippet reads the button pin each execution cycle and writes the corresponding output to the LED. This however, consumes a lot of power as there is unnecessary code execution if no button is pressed or released. The better way to do this is by checking and writing LED state when the button is pressed, ie when there is an interrupt from the button. A blog about using interrupts will be out soon, going into the details of this process.\n\nIn this tutorial, we discussed the methods for using Buttons and LED’s in our hardware setup. The same code will work of any GPIO pin connected to the LED or the button.\n\nAdditionally, this was the first introduction to the HAL library."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-embedded-software/uart-hal-api-s/td-p/410407",
        "document": "I have no experience of using Keil but in general......\n\nin this what is __IO\n\nIf I remember correctly it is just the equivalent of volatile. So you variable is treated as volatile.\n\nand what is ITStatus in which header file can i find about it\n\nIt is in stm32f4xx.h (or the equivalent for your processor) and is just an enum defining SET and RESET.\n\nhow to know the different types present in it ?\n\nThis is not as easy as it could be! I have found the HAL libraries slow to learn (so don't worry that you are struggling to start with). The easiest way to to to use example projects so can see how they are structured and just search for stuff like this. You will eventually get the idea where to find stuff.\n\n2. what is the difference between HAL_UART_Receive_IT and HAL_UART_Receive (other than blocking and unblocking )\n\nThe first uses interrupts and, as you say, is not blocking. The 2nd just uses polling and is blocking. I find the best way to understand functions like this is to just look at the implementation of the functions. If you are lucky then they have sensible comments to help you (the uart stuff is reasonably well documented, to a point)\n\nand in that program they are sending data and receiving it using UART interrupts but i dont find any IRQHandler in it .\n\nbut in the other c file which is linked to it called stm32xx_it.c\n\nIt is fairly standard to include things like stm32xx_it.c in the project. That is the user implementation of the interrupt handlers so can override anything in the libraries.\n\nthe function is given as like this\n\nwhat does HAL_UART_IRQHandler() do ? where is it defined ?\n\nIt does what the name implies, ie. handles the UART interrupts for the HAL libraries. Hence it being called from the USARTx_IRQHandler(). It is in the stm32fxx_hal_uart.c module.\n\nAnd if they are sending and receiving data using interrupts whyarent\n\nThe receive_it() etc are the user functions to receive or transmit data under interrupts. So to transmit some data you call the transmit_IT() function with the data in a buffer. The HAL libraries do the rest. These functions should not be confused with the IRQ functions which actually handle the interrupts.\n\nI would really love to have the entire code explanation if possible (if anyone with some time to spend and more patience) and I really thank for such kind action ......\n\nI don't have time to explain in more depth I am afraid so I would suggest going through the example project in detail. Any function you don't understand then just search for it and read the code to understand it. Eventually all will be clearer!\n\nUnfortunately the HAL libraries are sometimes difficult to understand without experience. They are designed to be flexible and give an standard interface across many devices but in doing so they become complex and difficult to follow.\n\nHowever, as a general pointer it is worth knowing that t\n\nhe hal libraries make a lot of use of weak functions and call backs. So, for example, the\n\nUSARTx_IRQHandler() is declared as a weak function that (I think) just does nothing. It is then up to the user to code (and hence over-ride) this function. This is done in your example code in the stm32f4xx_it.c module. In your examples case the programmer knew he wanted to use the standard HAL library to handle the uart interrupts so he just called the\n\nHAL_UART_IRQHandler(& UartHandle);. You could write your own interrupt handler here if you want to do it your own way (which I generally do for uart stuff as I don't like the hal way of doing things).\n\nYou will also probably find a stim32f4xx_hal_msp.c module in your example project. This is where you will find the user code for call backs for things like initialisation. So, for example, if your main() calls HAL_Init() this will do the basic stuff but then calls HAL_MspInit(). HAL_MspInit() is likely in your _hal_msp.c and will contain your specific initialisation code. This way the user can add to the basic HAL stuff without having to rewrite all the HAL functions just because they don't do quite what is wanted.\n\nSorry I cannot go into more detail but hopefully this helps a bit. (and I am not an expert, I just learnt all this myself over the last few months)"
    },
    {
        "link": "https://stackoverflow.com/questions/71626597/what-are-the-various-ways-to-disable-and-re-enable-interrupts-in-stm32-microcont",
        "document": "Update 10 May 2023: one of my primary motivating factors in learning this stuff was related to my first ever ring buffer implementation I wrote 7 years ago in 2016, leading to this debugging problem where I lost 25 hours of debugging work in 2 days. I finally wrote a really good ring buffer implementation that is lock-free when used on any system which supports C11 or C++11 atomic types. It is the best implementation I've ever written, and also the best I've ever seen. It solves a lot of the problems of other implementations. Full details are in the top of the file. It runs in both C and C++. You can see the full implementation here: containers_ring_buffer_FIFO_GREAT.c in my eRCaGuy_hello_world repo.\n\nFor the definition of these functions, see:\n• https://github.com/ARM-software/CMSIS/blob/master/CMSIS/Include/cmsis_gcc.h\n• Contains at least:\n\nTo save and restore the interrupt state, use , like this:\n\nWhen dealing with global interrupts, this is the best way for bare-metal, non-FreeRTOS code!\n\nI think this technique is also cross-compatible with ALL ARM-core mcus, not just STM32.\n\nI first learned this technique from Tilen Majerle, here: https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/. His work and contributions to clear up this super-obfuscated stuff are infinitely valuable and appreciated!\n\nIt is best to avoid disabling global interrupts, if possible, and disable only the fewest number of specific interrupts possible to achieve atomicity for your specific code. So, using these functions allows you to enable or disable only the specific interrupts you need to!\n\nNVIC stands for \"Nested Vector Interrupt Controller\". Nested interrupts (meaning: a higher-priority interrupt can still fire within an ISR) are enabled by default on STM32 microcontrollers. Each interrupt type has a priority assigned to it, with lower numbers being higher priority, and higher-priority interrupts are able to fire while an ISR is being processed for a lower-priority interrupt. See here for a little more information on the STM32 NVIC: https://stm32f4-discovery.net/2014/05/stm32f4-stm32f429-nvic-or-nested-vector-interrupt-controller/.\n\nContrast this to AVR microcontrollers (ex: ATMega328 / Arduino Uno), which do not have priority-based interrupts, so by default, when any ISR is being processed, all interrupts (ie: global interrupts) are automatically disabled as the program enters the ISR. Note that even on AVR mcus, however, you can still manually enable nested interrupts / ISRs if you like by manually re-enabling global interrupts inside your ISR, via a call to on Arduino or (set interrupts) on raw AVR.\n\nEach ARM-core microcontroller manufacturer, I believe, including STM32 types, must define and create its own list of interrupt request types, so see below for the STM32 details on their specific interrupt types defined for each mcu.\n\nSee, for example: \"stm/stm32f2xx/st_hal_v1.1.3/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cortex.c/.h\" - definitions for those functions above are in those files. See them online:\n\nHere are the definitions of and . Notice that they just check to ensure your is valid, then they pass the input argument on to the ARM-core CMSIS and functions above!:\n\nFor s: see the appropriate definition file for your specific board! These are board-specific definitions, for your board from your manufacturer. Here are all of the boards in the STM32 F2xx line, for instance: https://github.com/STMicroelectronics/STM32CubeF2/tree/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include. Let's look at the file specifically:\n• Raw view (since file is too big to view on GitHub otherwise): https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF2/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include/stm32f217xx.h\n\nFrom this file, we can see the definition for the , which is the \"STM32F2XX Interrupt Number Definition\". Here is what it looks like:\n\nTo get exclusive access (to ensure strings are atomically printed, for instance) to the for printing debug chars via a HAL-based blocking (polled) mode (ie: via ), you need to disable all interrupts for by doing the following. (This guarantees you get atomic access to this device):\n\nThe FreeRTOS atomic-access-guard / interrupt-related functions are listed under the \"Modules\" section of the Kernel Control API here: Kernel Control:\n\nSee also my README here, with a potential list of which calls are and are not allowed within FreeRTOS critical sections: https://github.com/ElectricRCAircraftGuy/eRCaGuy_Engineering/tree/main/FreeRTOS#freertos-critical-section-calls\n• None These are the preferred macros to use, and are the freertos-recommended ones!\n• None These all support nested calls, and end up calling anyway, which is the port implementation of the lower-level , shown below. Calls to and are designed to nest. Therefore, a critical section will only be exited when one call to has been executed for every preceding call to . Critical sections must be kept very short, otherwise they will adversely affect interrupt response times. Every call to must be closely paired with a call to . FreeRTOS API functions must not be called from within a critical section.\n• None These do NOT support nested calls!\n• None Official documentation on them is on the main \"Kernel Control\" page:\n• \n• at the link above states: Normally this macro would not be called directly and and should be used in its place.\n• at the link above states: Normally this macro would not be called directly and and should be used in its place.\n• Note also that the use of is demonstrated as the technique used to panic inside an example macro definition for .\n• From here: https://www.freertos.org/a00110.html#configASSERT, when used with a debugger, it is defined as: /* Define configASSERT() to disable interrupts and sit in a loop. */ #define configASSERT( ( x ) ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }\n• My thoughts: perhaps in this one case (ie: hard asserting, or panicking), might be preferred over because no amount of calling from another thread will re-enable interrupts once has been called [I think!?]--rather, one would have to explicitly (and accidentally) call (ex: from another thread) to re-enable interrupts once has been called. In other words, using the low-level call is appropriate here because it will truly cause the system to sit in a loop, as desired, whereas would not.\n\nBeyond the examples above, you can also use FreeRTOS queues (which are thread-safe, unlike all containers in the C++ std library), mutexes, semaphores, task notifications, and other synchronization primitives, where able and where appropriate, to protect certain data which is shared between FreeRTOS tasks (threads), assuming you are running FreeRTOS.\n\nSee the list of these tools here: https://www.freertos.org/a00106.html, and in the left-hand navigation menus once you click on that link.\n• None Add an atomic ( or really makes more sense as a function name for this, I think) demo using ARM-core CMSIS functions, or assembly, or whatever means necessary, to demonstrate writing a spin lock in STM32. I don't know how to do this yet so it will require finding the right function or operation to use. See here: https://en.wikipedia.org/wiki/Test-and-set#Pseudo-C_implementation_of_a_spin_lock: volatile int lock = 0; void critical() { // Spin lock: loop forever until we get the lock; we know the lock was // successfully obtained after exiting this while loop because the // test_and_set() function locks the lock and returns the previous lock // value. If the previous lock value was 1 then the lock was **already** // locked by another thread or process. Once the previous lock value // was 0, however, then it indicates the lock was **not** locked before we // locked it, but now it **is** locked because we locked it, indicating // we own the lock. while (test_and_set(&lock) == 1); critical section // only one process can be in this section at a time lock = 0; // release lock when finished with the critical section } Here is a spin lock implementation I did in C11 using types. It should work just fine for STM32 as well, and probably compiles to use the underlying exclusive / operations to store (write) and read (load), but I'd have to check that by looking at the assembly. Additionally, this implementation would need to be modified to add safety anti-deadlock mechanisms such as automatic deferral, timeout, and retry, to prevent deadlock. See my notes here: Add basic mutex (lock) and spin lock implementations in C11, C++11, AVR, and STM32\n• My answer on this for AVR mcus/Arduino\n• My answer on the general practice and demo of using atomic access guards, and my func which ensures atomic access withOUT turning interrupts off\n• [my Q&A] Which variable types/sizes are atomic on STM32 microcontrollers?\n\nSee the References section of my question here: How to properly count timer overflows to convert a 32-bit high-resolution timer into a 64-bit high-resolution timer:"
    },
    {
        "link": "https://wiki.st.com/stm32mpu/wiki/Interrupt_overview",
        "document": "This article explains STM32 MPU interrupt topology and its management on Linux® environment.\n\nThe Linux® kernel software layer that handles the interrupts is splitted into two parts:\"\n• A generic part:\n• providing a common API to request and configure an interrupt line.\n• creating a virtual mapping for all interrupts in order to have only one ID per interrupt.\n\nFor more information refer to Linux® kernel documentation in core-api/genericirq.html[1].\n\nAs explain in Framework purpose, the irqchip driver makes the interface with the hardware to configure and manage an interrupt. On STM32 Arm® Cortex® MPUs devices, a hardware interrupt can be generated by GIC, EXTI, PWR or GPIO. Several irqchip drivers are consequently required, one per hardware block.\n\nThe next section provides topology information for each kind of interrupt source.\n• procfs: provides interrupt information to the user space.\n• interrupt framework: generic part described in the Framework purpose section.\n• Irqchips:\n• GIC irqchip: GIC irqchip driver part. This irqchip driver is used when a GIC interrupt is directly requested by a device. This is the case for all the peripheral interrupts that are not wakeup sources. This irqchip is in charge of controlling the GIC internal peripheral (hardware). An example of GIG irqchip usage is available here.\n• EXTI irqchip: EXTI irqchip driver part. This irqchip driver is used when an EXTI interrupt (EXTernal Interrupt) is requested by a device. This kind of interrupts is used to wake up the system from low-power mode. This irqchip directly controls the EXTI internal peripheral but it is also linked to the gic irqchip through the hierarchical irq domain mechanism[2]. This link is transparent for the requester.\n• pwr_irq irqchip: pwr_irq irqchip driver part. This irqchip driver is used when an EXTI interrupt mapped to a wakeup pin is requested by a device. This kind of interrupts is used to wake up the system from the deepest low-power mode (more details about low-power modes are available here). This irqchip is part of the hierarchical irq domain mechanism[2]. The pwr_irq irqchip in turn controls the PWR internal peripheral and it is also linked to the gic irqchip through the same hierarchical irq domain mechanism[2]. These hierarchical links are transparent for the requester.\n• Note:\n• pwr_irq irqchip is only used for STM32MP15x lines .\n• optee irqchip: This irqchip driver is used when a 'wakeup' pins handled by OPTEE is requested by a device. This \"optee\" irqchip is created in Linux to expose those wakeup pins. In those cases, a Linux kernel device can get an interrupt mapped on a wakeup pin using an optee phandle in devicetree.\n• Note:\n• Relevant for STM32MP13x lines and STM32MP2 series, as in those cases, the wakeup pins are handled by OPTEE.\n• See How_to_configure_PWR_Wake-up_pins for more details.\n• Pinctrl irqchip: Pinctrl irqchip driver part. This irqchip driver is used when a device wants to configure/request a GPIO as an interrupt. It directly controls the GPIO internal peripheral but it is also linked to the EXTI irqchip through the hierarchical irq domain mechanism[2]. This link is transparent for the requester.\n\nThe kernel space API is the interface for declaring and managing interrupts. The user space interface is used to monitor interrupt information or set interrupt affinity.\n• It provides information about interrupts such as the virtual number, the hardware ID and the irqchip used (see chapter 1.2 Kernel data of /proc kernel documentation[3]).\n• It configures interrupt affinity[4], that is assigns an interrupt to a dedicated CPU.\n\nThe main kernel API drivers for users are the following:\n• enable_irq_wake: enables a requested interrupt that could wake up the system.\n• disable_irq_wake: disables a requested interrupt that could wake up the system.\n\n... The available routines can be found in Linux® kernel header file: include/linux/interrupt.h[5].\n\nThe interrupt framework and irqchip drivers are enabled by default.\n\n\n\nThe generic way to declare an interrupt in the device tree is declared in Linux® kernel documentation in: Documentation/devicetree/bindings/interrupt-controller/interrupts.txt [6].\n\nHowever each irqchip driver has his own bindings description. The below chapters provide the link to the bindings documentation for each interrupt controller as well as a simple example of interrupt declaration.\n\nPwr_irq irqchip has not to be used directly. User has to use exti to invoke pwr_irq irqchip thanks to the hierarchical implementation.\n\nOP-TEE OS interrupt services are based on the Arm GIC driver. TF-A and U-Boot do not handle interrupts. STM32MPU uses GICv2 model. \n\n OP-TEE OS handling of interrupt may imply CPU execution context switches between secure and non-secure worlds.\n\nTwo types of interrupts are defined from OP-TEE OS point of view:\n• Native interrupt - The interrupts handled by OP-TEE OS in its secure privileged mode.\n• Foreign interrupt - The interrupt to be handled by the non-secure world, that is the Linux kernel.\n• a native interrupt is signalled with a FIQ, assigned to the secure world\n• a foreign interrupt is signalled with an IRQ, assigned to the non-secure world\n\nNOTE: This description is in alignment with OP-TEE version: v3.19.0\n\nOP-TEE OS has the following files that implement the interrupt framework:\n\nAdditionally, the files implement the interrupts for PMIC:\n\nNOTE: pwr_irq is an extra interrupt controller used for EXTI 55 to 60. It's mapped on pwr interrupt controller.\n\nOP-TEE OS executes in the secure world. World switch is done by the core’s secure monitor level/mode.\n\nWhen the normal world invokes the secure world, the normal world executes a SMC instruction. The SMC exception is always trapped by the Monitor. If the related service targets the trusted OS, the Monitor will switch to OP-TEE OS world execution. When the secure world returns to the normal world, OP-TEE OS executes an SMC that is caught by the Monitor which switches back to the normal world.\n\nWhen a secure interrupt is signaled by the Arm GIC, it shall reach the OP-TEE OS interrupt exception vector. If the secure world is executing, OP-TEE OS will handle interrupt straight from its exception vector. If the normal world is executing when the secure interrupt raises, the Monitor vector must handle the exception and invoke OP-TEE OS to serve the interrupt.\n\nWhen a non-secure interrupt is signaled by the Arm GIC, it shall reach the normal world interrupt exception vector. If the normal world is executing, it will handle straight the exception from its exception vector. If the secure world is executed when the non-secure interrupt raises, OP-TEE OS will temporarily return back to normal world via the Monitor to let normal world serve the interrupt.\n\nInterrupt management resources are declared in header file interrupt.h A single linked list is created where the interrupt handlers are stored.\n• itr_enable() and itr_disable() : enable or disable an interrupt respectively.\n• itr_set_ipriority(): Set the priority of an interrupt.\n• itr_handle(): Handler to the interrupt, invoked by - gic_it_handle()\n• itr_core_handler(): Interrupt root handler. plat-stm32mp1/main.c routes the interrupts to the interrupt handler of the GIC driver.\n• itr_raise_pi(): raise the Peripheral Interrupt corresponding to the interrupt ID\n• itr_raise_sgi() : raise the Software Generated Interrupt corresponding to the interrupt ID, the input argument cpu_mask represents which CPU shall receive the interrupt.\n• itr_set_affinity(): let corresponding interrupt forward to the CPU interface according to the cpu_mask specified in the input argument.\n• itr_add(): Register an interrupt handler function for a given interrupt ID.\n• itr_free(): Unregister an interrupt handler function from a given interrupt ID.\n• itr_set_pmr(): Set the GIC device Priority Mask and return its previous value.\n\nstruct itr_chip: An interrupt controller instance, named chip, defines operation function handlers for management of the interrupt(s) it controls. An interrupt chip driver must provide operation handler functions: .add, .enable and .disable. There are other operation handler functions that are optional, as for example: .rasie_pi, .raise_sgi and .set_priority.\n\nAn interrupt chip driver registers the controller instance with API function itr_init(). It is called by the main_init_gic() API defined in the main.c present in the platform folder."
    },
    {
        "link": "https://stackoverflow.com/questions/69980145/how-to-set-up-interrupt-registers-on-the-stm32-microcontrollers",
        "document": "I wanted to toggle a led status by reading a push button status's using interrupt instead of polling. I'm using a Nucleo board F411 and a register based programming instead of that no sense HAL libraries(lol I'm just joking)\n\nAfter reading the reference manual and the programming manual for the corresponding micro controller I thought that this code would work fine for the purpose of implementing interrupts...turns out it was not the case. I took at look at the debugging session to see how the corresponding registers changes and it does exactly as I need (the NVIC->ISERx, the priority bits, the unmasking bits, the rising or falling edge trigger, etc) so I actually have no idea what is wrong with my way of thinking about this problem.\n\nBy the way, I'm using a custom made (for me) class in order to easily set up any GPIO, I've tried this separately and I can say that the problem is not related to my library. You may think of this as just a configuration function for the GPIO as system_clock_config might be.\n\nThe thing is, whenever I push the button, nothing happens.\n\nI get no compilation errors nor warnings.\n\nHere is the code:"
    },
    {
        "link": "https://digikey.com/en/maker/projects/getting-started-with-stm32-timers-and-timer-interrupts/d08e6493cefa486fb1e79c43c0b08cc6",
        "document": "Timers are one of the most important features in modern microcontrollers. They allow us to measure how long something takes to execute, create non-blocking code, precisely control pin timing, and even run operating systems.\n\nThe STM32 line of microcontrollers from STMicroelectronics are no exception: each controller offers a full suite of timers for us to use. In this guide, I’ll show you how to configure a timer using STM32CubeIDE, use it to measure execution time, and set up non-blocking code. Additionally, we’ll cover the basics of interrupts and how to use them to flash an LED.\n\nIf you are not familiar with STM32CubeIDE, please see here to get familiar with it.\n\nPlease see here if you would like to see this information presented in video format:\n\nA timer (sometimes referred to as a counter) is a special piece of hardware inside many microcontrollers. Their function is simple: they count (up or down, depending on the configuration--we'll assume up for now). For example, an 8-bit timer will count from 0 to 255. Most timers will “roll over” once they reach their max value. So, our 8-bit timer would start over again from 0 once it reaches 255.\n\nYou can apply a variety of settings to most timers to change the way they function. These settings are usually applied via other special function registers inside the microcontroller. For example, instead of counting to a maximum of 255, you might tell the timer that you want it to roll over at 100 instead. Additionally, you can often connect other hardware or peripherals inside the microcontroller to the timer, like toggling a specific pin automatically when the timer rolls over.\n\nHere are some of the common hardware functions you’ll see with timers:\n• Output compare (OC): toggle a pin when a timer reaches a certain value\n• Input capture (IC): measure the number of counts of a timer between events on a pin\n• Pulse width modulation (PWM): toggle a pin when a timer reaches a certain value and on rollover. By adjusting the on versus off time (duty cycle), you can effectively control the amount of electrical power going to another device.\n\nThese hardware-connected timer functions will be a topic for another time. For now, I’d like to focus on using a timer to measure time between events (i.e. measure execution time) as well as triggering basic interrupts.\n\nHow fast do timers run? Well, that depends on how fast you tell them to run. All timers require a clock of some sort. Most will be connected to the microcontroller’s main CPU clock (others, like real time clocks, have their own clock sources). A timer will tick (increment by one) each time it receives a clock pulse.\n\nIn this demo, we will be using an STM32 Nucleo-L476RG, which has a default main clock (HCLK) of 80 MHz. We could have a timer tick at 80 MHz, but that might be too fast for many of our applications. A 16-bit timer can count to 65,535 before rolling over, which means we can measure events no longer than about 819 microseconds!\n\nIf we wish to measure longer events, we need to use a prescaler, which is a piece of hardware that divides the clock source. For example, a prescaler of 80 would turn an 80 MHz clock into a 1 MHz clock.\n\nNow, our timer would tick once every 1 microsecond and, assuming a 16-bit timer, be able to time events up to a maximum of about 65.5 milliseconds.\n\nIf you look at the datasheet for your microcontroller, you will often find a section talking about the various timers available. For example, here is a table from section 3.24 of our STM32L476 datasheet giving us information about the different general purpose timers at our disposal.\n\nTimer 16 offers some basic functionality, so we’ll use that. Note that it is a 16-bit timer and can only count up.\n\nIf you look in section 3.11 of that same datasheet, you will find a “clock tree,” which is a diagram showing you how the clocks are connected to various prescalers and peripherals inside the STM32 chip. I’ve highlighted in yellow the clock path that we would need to be concerned with to configure the speed of Timer 16.\n\nAs you can see, there is more than one prescaler that we need to worry about in STM32. Our 80 MHz HCLK signal is first divided by the APB2 prescaler and then multiplied by either 1x or 2x (this is automatically set in hardware depending on what you choose for the APB2 prescaler). This signal is used to clock timers 1, 8, 15, 16, and 17. Each timer also has its own separate prescaler that we can set.\n\nSo, if we choose an APB2 prescaler of 8, which sets the multiplier to 2x, and a timer prescaler of 4, our timer would tick at a rate of 5 MHz (80 MHz / 8 * 2 / 4 = 5 MHz).\n\nNote that you can get the value of a timer at any given moment by reading its CNT register. You can read more about the registers needed to control the timers for the STM32476RG in this reference manual. For example, section 28.6.20 talks about Timer 16.\n\nFor the following examples, you only need a Nucleo-L476RG and a USB mini cable. We will just be timing events and toggling the onboard LED.\n\nOpen STM32CubeIDE, start a new project, select your board (Nucleo-L476RG), and give your project a good name.\n\nIn the CubeMX perspective, open Timers and select TIM16. Set the Prescaler (PSC) to 79. I’ll write “80 - 1” to show that a prescaler value of 79 actually means use a clock divider or 80. The prescaler is off by 1 because it’s 0-based: a PSC value of “0” means to use a prescaler (clock divider) of 1.\n\nSet the Counter Period to 65535. Once again, I’ll write “65536 - 1” to show that this counter will actually tick 65536 times in total (the rollover from 65535 to 0 counts as a tick).\n\nSave to generate code and open main.c. There, include <stdio.h> so we can use sprintf and change main() so that we measure the time it takes to execute the HAL_Delay(50) function. Here is what the code should look like (note that I left out everything after main(), as that should have been generated by CubeMX).\n\nIn our code, note that we start the timer with HAL_TIM_Base_Start(&htim16). From there, we can use __HAL_TIM_GET_COUNTER(&htim16) to get the value of the counter (from the CNT register) at that moment. We simply subtract timestamps to get the amount of time elapsed. Note that the method presented allows us to measure time between events even if the timer rolls over. However, it will not work if the difference between the timestamps is longer than 65,536 microseconds (the maximum value our timer can count to).\n\nBuild the project and start debugging. Press the play button and connect to your Nucleo board with a serial terminal program, such as PuTTY. You should see that it takes about 51000 microseconds to execute HAL_Delay(50) (interestingly, it seems that HAL_Delay() adds a millisecond).\n\nIn addition to measuring execution time, we can recreate the blinky example using timers. By doing so, we can create non-blocking code to toggle the LED. This allows you to run other code while waiting for the LED to toggle.\n\nBack in the CubeMX perspective, change the Timer 16 prescaler to 7999 (“8000 - 1”). With a main CPU clock of 80 MHz, our timer will now tick at a rate of 10 kHz (80 MHz / 8000 = 10 kHz).\n\nChange main.c to the following:\n\nNote that you can get rid of the #include <stdio.h>, as we are not printing to the serial terminal anymore.\n\nAfter starting the timer, we get a timestamp with __HAL_TIM_GET_COUNTER(&htim16). We subtract subsequent timestamps and compare them to a value. In this case, our value is 10,000. With a timer running at 10 kHz, it will take 1 second for the timer to count from one timestamp to 10,000 + that timestamp.\n\nOnce again, this method is capable of handling timer rollovers, but it cannot handle timing events longer than about 6.55 seconds (65,536 ticks / 10,000 kHz = 6.5536 sec).\n\nRun the code, and you should see the LED start to toggle once per second.\n\nTimers can be used to trigger a variety of interrupts (see section 72.2.9 of the HAL/LL API reference document for a list of possible HAL-supported interrupt callbacks). We will use a very basic interrupt: when the timer reaches its maximum value, it will rollover back to 0 and trigger an interrupt.\n\nTo accomplish that, we will set the Timer 16 prescaler to be 8000 so that it ticks at a rate of 10 kHz. We will then set its maximum value to 10,000 (actually, we’ll set it to 9,999 as we want the interrupt to trigger on the rollover) so that it takes 1 second to reach the maximum value.\n\nEach time the interrupt occurs, we’ll toggle the LED. This accomplishes the same effect as before (blinky), but using interrupts instead. It makes our code even more non-blocking!\n\nIn CubeMX, change the counter period to 9,999 (“10000 - 1”).\n\nClick on the NVIC Settings tab and enable the TIM1 update interrupt and TIM16 global interrupt setting. Note that this is required to get interrupts to fire!\n\nIn main.c change the main() function to the following (the includes and variable declarations above it should be the same as the previous example):\n\nNote that the only thing we have in there now is HAL_TIM_Base_Start_IT(&htim16), which starts the timer in interrupt mode. The while superloop is blank! Our blinky code will be entirely handled by interrupts.\n\nScroll down to find the /* USER CODE BEGIN 4 */ guards. In there, add the following:\n\nThis is an interrupt handler. The HAL libraries will manage the main interrupt service routine (ISR) when the timer interrupt occurs (feel free to examine it in stm32l4xx_it.c). At some point in that ISR, the code will call HAL_TIM_PeriodElapsedCallback(), which we need to provide a definition for. In that definition, we check to make sure that the timer handle (htim) is indeed our Timer 16 and then toggle the LED pin. Note that this is a generic timer interrupt callback. If you set up multiple timer interrupts, this one callback will be called for any of them, which is why we check the timer instance handle (htim) to differentiate among the possible timers.\n\nRun this code in debug mode, and you should see the LED flash again, just like before!\n\nI hope this has helped you get started using timers and timer interrupts. Timers are very powerful features in microcontrollers, as they allow you to perform a variety of tasks, including running non-blocking code. Interrupts can be used in conjunction with timers to perform functions outside of your main code.\n\nSee the following documents if you would like to dig into STM32 timers and interrupts.\n• Getting Started with STM32 and Nucleo Part 1: Introduction to STM32CubeIDE and Blinky\n• Getting Started with STM32 and Nucleo Part 2: How to Use I2C to Read Temperature Sensor TMP102\n• Getting Started with STM32 and Nucleo Part 3: How to Run Multiple Threads with CMSIS-RTOS Interface\n• Getting Started With STM32 & Nucleo Part 4: Working with ADC and DMA\n• Getting Started with STM32 - How to Use SPI"
    }
]