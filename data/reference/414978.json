[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html",
        "document": "\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. - The IP address and port number to bind to. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - The IP address and port number to bind to. - requested maximum length of the queue of incoming connections. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• Returns the local address of this server socket. If the socket was bound prior to being , then this method will continue to return the local address after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, the address is returned. the address to which this socket is bound, or the loopback address if denied by the security manager, or if the socket is unbound.\n• Returns the port number on which this socket is listening. If the socket was bound prior to being , then this method will continue to return the port number after the socket is closed. the port number to which this socket is listening or -1 if the socket is not bound yet.\n• Returns the address of the endpoint this socket is bound to. If the socket was bound prior to being , then this method will continue to return the address of the endpoint after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, a representing the address and the local port to which the socket is bound is returned. a representing the local endpoint of this socket, or a representing the loopback address if denied by the security manager, or if the socket is not bound yet.\n• Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. A new Socket is created and, if there is a security manager, the security manager's method is called with and as its arguments to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when waiting for a connection. - if a security manager exists and its method doesn't allow the operation. - if a timeout was previously set with setSoTimeout and the timeout has been reached. - if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted\n• Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client. - if this socket has an associated channel, and the channel is in non-blocking mode - if an I/O error occurs when waiting for a connection.\n• Closes this socket. Any thread currently blocked in will throw a If this socket has an associated channel then the channel is closed as well. - if an I/O error occurs when closing the socket.\n• Returns the unique object associated with this socket, if any. A server socket will have a channel if, and only if, the channel itself was created via the method. the server-socket channel associated with this socket, or if this socket was not created for a channel\n• Returns the binding state of the ServerSocket. true if the ServerSocket successfully bound to an address\n• Returns the closed state of the ServerSocket. true if the socket has been closed\n• java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be . A timeout of zero is interpreted as an infinite timeout. Enable/disable with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, ais raised, though the ServerSocket is still valid. The optionbe enabled prior to entering the blocking operation to have effect. The timeout must be. A timeout of zero is interpreted as an infinite timeout. - the specified timeout, in milliseconds - if there is an error in the underlying protocol, such as a TCP error.\n• Retrieve setting for . 0 returns implies that the option is disabled (i.e., timeout of infinity).\n• When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the state or wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required if there is a connection in the timeout state involving the socket address or port. Enabling prior to binding the socket using allows the socket to be bound even though a previous connection is in a timeout state. When a is created the initial setting of is not defined. Applications can use to determine the initial setting of . The behaviour when is enabled or disabled after a socket is bound (See ) is not defined. - whether to enable or disable the socket option - if an error occurs enabling or disabling the socket option, or the socket is closed.\n• a indicating whether or not is enabled. - if there is an error in the underlying protocol, such as a TCP error.\n• . Returns the implementation address and implementation port of this socket as a If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, an representing the address is returned as the implementation address.\n• Sets the server socket implementation factory for the application. The factory can be specified only once. When an application creates a new server socket, the socket implementation factory's method is called to create the actual socket implementation. Passing to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's method to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when setting the socket factory. - if the factory has already been defined. - if a security manager exists and its method doesn't allow the operation.\n• . The value actually set in the accepted socket must be determined by calling Sets a default proposed value for the option for sockets accepted from this. The value actually set in the accepted socket must be determined by calling after the socket is returned by The value of is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer. It is possible to change the value subsequently, by calling . However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes. - the size to which to set the receive buffer size. This value must be greater than 0. - if there is an error in the underlying protocol, such as a TCP error. - if the value is 0 or is negative.\n• , that is the proposed buffer size that will be used for Sockets accepted from this . Gets the value of the option for this, that is the proposed buffer size that will be used for Sockets accepted from this Note, the value actually set in the accepted socket is determined by calling . the value of the option for this . - if there is an error in the underlying protocol, such as a TCP error.\n• Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values . If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values . Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor. - An expressing the relative importance of a short connection time - An expressing the relative importance of low latency - An expressing the relative importance of high bandwidth"
    },
    {
        "link": "https://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html",
        "document": "\n• \n• means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Creates a server socket, bound to the specified port. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling The maximum queue length for incoming connection indications (a request to connect) is set to . If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket factory, that factory's method is called to create the actual socket implementation. Otherwise a \"plain\" socket is created. If there is a security manager, its method is called with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. - the port number, or to use a port number that is automatically allocated. - if an I/O error occurs when opening the socket. - if a security manager exists and its method doesn't allow the operation. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Creates a server socket and binds it to the specified local port number, with the specified backlog. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling The maximum queue length for incoming connection indications (a request to connect) is set to the parameter. If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket factory, that factory's method is called to create the actual socket implementation. Otherwise a \"plain\" socket is created. If there is a security manager, its method is called with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - the port number, or to use a port number that is automatically allocated. - requested maximum length of the queue of incoming connections. - if an I/O error occurs when opening the socket. - if a security manager exists and its method doesn't allow the operation. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• bindAddr argument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. If bindAddr is null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number of means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Create a server with the specified port, listen backlog, and local IP address to bind to. Theargument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. Ifis null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling If there is a security manager, this method calls its method with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - the port number, or to use a port number that is automatically allocated. - requested maximum length of the queue of incoming connections. - the local InetAddress the server will bind to - if a security manager exists and its method doesn't allow the operation. - if an I/O error occurs when opening the socket. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• \n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. - The IP address & port number to bind to. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - The IP address & port number to bind to. - requested maximum length of the queue of incoming connections. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• Returns the local address of this server socket. If the socket was bound prior to being , then this method will continue to return the local address after the socket is closed. the address to which this socket is bound, or if the socket is unbound.\n• Returns the port number on which this socket is listening. If the socket was bound prior to being , then this method will continue to return the port number after the socket is closed. the port number to which this socket is listening or -1 if the socket is not bound yet.\n• if it is not bound yet. Returns the address of the endpoint this socket is bound to, orif it is not bound yet. If the socket was bound prior to being , then this method will continue to return the address of the endpoint after the socket is closed. a representing the local endpoint of this socket, or if it is not bound yet.\n• Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. A new Socket is created and, if there is a security manager, the security manager's method is called with and as its arguments to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when waiting for a connection. - if a security manager exists and its method doesn't allow the operation. - if a timeout was previously set with setSoTimeout and the timeout has been reached. - if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted\n• Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client. - if this socket has an associated channel, and the channel is in non-blocking mode - if an I/O error occurs when waiting for a connection.\n• Closes this socket. Any thread currently blocked in will throw a If this socket has an associated channel then the channel is closed as well. - if an I/O error occurs when closing the socket.\n• Returns the unique object associated with this socket, if any. A server socket will have a channel if, and only if, the channel itself was created via the method. the server-socket channel associated with this socket, or if this socket was not created for a channel\n• Returns the binding state of the ServerSocket. true if the ServerSocket succesfuly bound to an address\n• Returns the closed state of the ServerSocket. true if the socket has been closed\n• Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, a java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be > 0. A timeout of zero is interpreted as an infinite timeout. - the specified timeout, in milliseconds - if there is an error in the underlying protocol, such as a TCP error.\n• Retrieve setting for SO_TIMEOUT. 0 returns implies that the option is disabled (i.e., timeout of infinity).\n• When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the state or wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required if there is a connection in the timeout state involving the socket address or port. Enabling prior to binding the socket using allows the socket to be bound even though a previous connection is in a timeout state. When a is created the initial setting of is not defined. Applications can use to determine the initial setting of . The behaviour when is enabled or disabled after a socket is bound (See ) is not defined. - whether to enable or disable the socket option - if an error occurs enabling or disabling the socket option, or the socket is closed.\n• a indicating whether or not SO_REUSEADDR is enabled. - if there is an error in the underlying protocol, such as a TCP error.\n• Returns the implementation address and implementation port of this socket as a .\n• Sets the server socket implementation factory for the application. The factory can be specified only once. When an application creates a new server socket, the socket implementation factory's method is called to create the actual socket implementation. Passing to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's method to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when setting the socket factory. - if the factory has already been defined. - if a security manager exists and its method doesn't allow the operation.\n• . The value actually set in the accepted socket must be determined by calling Sets a default proposed value for the SO_RCVBUF option for sockets accepted from this. The value actually set in the accepted socket must be determined by calling after the socket is returned by The value of SO_RCVBUF is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer. It is possible to change the value subsequently, by calling . However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes. - the size to which to set the receive buffer size. This value must be greater than 0. - if there is an error in the underlying protocol, such as a TCP error. - if the value is 0 or is negative.\n• , that is the proposed buffer size that will be used for Sockets accepted from this . Gets the value of the SO_RCVBUF option for this, that is the proposed buffer size that will be used for Sockets accepted from this Note, the value actually set in the accepted socket is determined by calling . the value of the SO_RCVBUF option for this . - if there is an error in the underlying protocol, such as a TCP error.\n• Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values . If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values . Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor. - An expressing the relative importance of a short connection time - An expressing the relative importance of low latency - An expressing the relative importance of high bandwidth"
    },
    {
        "link": "https://geeksforgeeks.org/java-net-serversocket-class-in-java",
        "document": "ServerSocket Class in Java provides a system-independent way to implement the server side of a client/server socket connection. The constructor for ServerSocket throws an exception if it can’t listen on the specified port (for example, the port is already being used).\n• java.nio channel , ServerSocket class is used for retrieving a ServerSocket associated with this channel.\n• java.rmi.Server , ServerSocket class is used to create a server socket on the specified port (port 0 indicates an anonymous port).\n• javax.net , the ServerSocket is used widely to:\n• None return a server socket bound to the specified port.\n• None return a server socket bound to the specified port, and uses the specified connection backlog.\n• None return a server socket bound to the specified port, with a specified listen backlog and local IP.\n\nThe below Java program demonstrates the working of server-side programming using ServerSocket class.\n\nExplanation: In the above example, it demonstrates a basic server-side implementation using the ServerSocket class. It listens on port 6666, accepts a client connection, reads a message sent by the client, and then closes the connection.\n\nThe below Java program demonstrate the working of client-side programming using ServerSocket class.\n\nExplanation: In the above example, it demonstrates a basic client-side implementation using the Socket class. It connects to a server at localhost on port 6666, sends a message “Hello GFG Readers!”, and then closes the connection.\n\nListens for a connection to be made to this socket and accepts it. Binds the ServerSocket to a specific address (IP address and port number). Binds the ServerSocket to a specific address (IP address and port number) and requests queqe length. If a request arrives when the queue is full then the request will be rejected by the server. Returns the unique ServerSocketChannel object associated with this socket, if any. Returns the local address of this server socket. Returns the port number on which this socket is listening. Returns the address of the endpoint this socket is bound to, or null if it is not bound yet. Gets the value of the SO_RCVBUF option for this ServerSocket, that is the proposed buffer size that will be used for Sockets accepted from this ServerSocket. Subclasses of ServerSocket use this method to override accept() to return their own subclass of the Returns the binding state of the ServerSocket. Returns the closed state of the ServerSocket. Sets a default proposed value for the SO_RCVBUF option for sockets accepted from this ServerSocket. Sets the server socket implementation factory for the application. Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. Returns the implementation address and implementation port of this socket as a String."
    },
    {
        "link": "http://edelstein.pebbles.cs.cmu.edu/jadeite/main.php?api=java6&state=class&package=java.net&class=ServerSocket",
        "document": "It is possible to change the value subsequently, by calling {@link Socket#setReceiveBufferSize(int)}. However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind().\n\nFailure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes."
    },
    {
        "link": "https://download.java.net/java/early_access/valhalla/docs/api/java.base/java/net/ServerSocket.html",
        "document": "This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester. The actual work of the server socket is performed by an instance of the class. The class defines convenience methods to set and get several socket options. This class also defines the and methods to set and query socket options. A supports the following options: The size of the socket receive buffer Additional (implementation specific) options may also be supported. Additional (implementation specific) options may also be supported.\n• \n• - an instance of a SocketImpl to use on the ServerSocket. - if a security manager is set and its method doesn't allow .\n• means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Creates a server socket, bound to the specified port. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling The maximum queue length for incoming connection indications (a request to connect) is set to . If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket implementation factory, that factory's method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created. If there is a security manager, its method is called with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. - the port number, or to use a port number that is automatically allocated. - if an I/O error occurs when opening the socket. - if a security manager exists and its method doesn't allow the operation. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Creates a server socket and binds it to the specified local port number, with the specified backlog. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling The maximum queue length for incoming connection indications (a request to connect) is set to the parameter. If a connection indication arrives when the queue is full, the connection is refused. If the application has specified a server socket implementation factory, that factory's method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created. If there is a security manager, its method is called with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - the port number, or to use a port number that is automatically allocated. - requested maximum length of the queue of incoming connections. - if an I/O error occurs when opening the socket. - if a security manager exists and its method doesn't allow the operation. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• bindAddr argument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. If bindAddr is null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number of means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling Create a server with the specified port, listen backlog, and local IP address to bind to. Theargument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. Ifis null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number ofmeans that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling If there is a security manager, this method calls its method with the argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - the port number, or to use a port number that is automatically allocated. - requested maximum length of the queue of incoming connections. - the local InetAddress the server will bind to - if a security manager exists and its method doesn't allow the operation. - if an I/O error occurs when opening the socket. - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.\n• \n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. - The IP address and port number to bind to. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - The IP address and port number to bind to. - requested maximum length of the queue of incoming connections. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• Returns the local address of this server socket. If the socket was bound prior to being , then this method will continue to return the local address after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, the address is returned. the address to which this socket is bound, or the loopback address if denied by the security manager, or if the socket is unbound.\n• Returns the port number on which this socket is listening. If the socket was bound prior to being , then this method will continue to return the port number after the socket is closed. the port number to which this socket is listening or -1 if the socket is not bound yet.\n• Returns the address of the endpoint this socket is bound to. If the socket was bound prior to being , then this method will continue to return the address of the endpoint after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, a representing the address and the local port to which the socket is bound is returned. a representing the local endpoint of this socket, or a representing the loopback address if denied by the security manager, or if the socket is not bound yet.\n• Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. This method is interruptible in the following circumstances:\n• The socket is associated with a . In that case, interrupting a thread accepting a connection will close the underlying channel and cause this method to throw with the interrupt status set.\n• The socket uses the system-default socket implementation and a virtual thread is accepting a connection. In that case, interrupting the virtual thread will cause it to wakeup and close the socket. This method will then throw with the interrupt status set. A new Socket is created and, if there is a security manager, the security manager's method is called with and as its arguments to ensure the operation is allowed. This could result in a SecurityException. An instance of this class using a system-default accepts sockets with a of the same type, regardless of the client socket implementation factory, if one has been set. - if an I/O error occurs when waiting for a connection. - if a security manager exists and its method doesn't allow the operation. - if a timeout was previously set with setSoTimeout and the timeout has been reached. - if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted\n• Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method a newly created, unbound, FooSocket. On return from implAccept the FooSocket will be connected to a client. The behavior of this method is unspecified when invoked with a socket that is not newly created and unbound. Any socket options set on the given socket prior to invoking this method may or may not be preserved when the connection is accepted. It may not be possible to accept a connection when this socket has a of one type and the given socket has a of a completely different type. An instance of this class using a system-default can accept a connection with a Socket using a of the same type: is thrown if the Socket is using a custom . An instance of this class using a custom cannot accept a connection with a Socket using a system-default . - if this socket has an associated channel, and the channel is in non-blocking mode - if an I/O error occurs when waiting for a connection, or if it is not possible for this socket to accept a connection with the given socket\n• Closes this socket. Any thread currently blocked in will throw a If this socket has an associated channel then the channel is closed as well. - if an I/O error occurs when closing the socket.\n• Returns the unique object associated with this socket, if any. A server socket will have a channel if, and only if, the channel itself was created via the method. the server-socket channel associated with this socket, or if this socket was not created for a channel\n• Returns the binding state of the ServerSocket. If the socket was bound prior to being closed, then this method will continue to return after the socket is closed. true if the ServerSocket successfully bound to an address\n• Returns the closed state of the ServerSocket. true if the socket has been closed\n• java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. A timeout of zero is interpreted as an infinite timeout. The option must be enabled prior to entering the blocking operation to have effect. Enable/disable with the specified timeout, in milliseconds. With this option set to a positive timeout value, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, ais raised, though the ServerSocket is still valid. A timeout of zero is interpreted as an infinite timeout. The optionbe enabled prior to entering the blocking operation to have effect. - the specified timeout, in milliseconds - if there is an error in the underlying protocol, such as a TCP error\n• Retrieve setting for . 0 returns implies that the option is disabled (i.e., timeout of infinity).\n• When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the state or wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required if there is a connection in the timeout state involving the socket address or port. Enabling prior to binding the socket using allows the socket to be bound even though a previous connection is in a timeout state. When a is created the initial setting of is not defined. Applications can use to determine the initial setting of . The behaviour when is enabled or disabled after a socket is bound (See ) is not defined. - whether to enable or disable the socket option - if an error occurs enabling or disabling the socket option, or the socket is closed.\n• a indicating whether or not is enabled. - if there is an error in the underlying protocol, such as a TCP error.\n• . Returns the implementation address and implementation port of this socket as a If there is a security manager set, and this socket is bound, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, an representing the address is returned as the implementation address.\n• Sets the server socket implementation factory for the application. The factory can be specified only once. When an application creates a new server socket, the socket implementation factory's method is called to create the actual socket implementation. Passing to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's method to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when setting the socket factory. - if the factory has already been defined. - if a security manager exists and its method doesn't allow the operation.\n• . The value actually set in the accepted socket must be determined by calling Sets a default proposed value for the option for sockets accepted from this. The value actually set in the accepted socket must be determined by calling after the socket is returned by The value of is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertised to the remote peer. It is possible to change the value subsequently, by calling . However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes. - the size to which to set the receive buffer size. This value must be greater than 0. - if there is an error in the underlying protocol, such as a TCP error. - if the value is 0 or is negative.\n• , that is the proposed buffer size that will be used for Sockets accepted from this . Gets the value of the option for this, that is the proposed buffer size that will be used for Sockets accepted from this Note, the value actually set in the accepted socket is determined by calling . the value of the option for this . - if there is an error in the underlying protocol, such as a TCP error.\n• Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values . If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values . Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor. - An expressing the relative importance of a short connection time - An expressing the relative importance of low latency - An expressing the relative importance of high bandwidth\n• Sets the value of a socket option. - The type of the socket option value - The value of the socket option. A value of may be valid for some options. - if the server socket does not support the option. - if the value is not valid for the option. - if an I/O error occurs, or if the socket is closed. - if name is - if a security manager is set and if the socket option requires a security permission and if the caller does not have the required permission. do not require any security permission.\n• Returns the value of a socket option. - The type of the socket option value The value of the socket option. - if the server socket does not support the option. - if an I/O error occurs, or if the socket is closed. - if name is - if a security manager is set and if the socket option requires a security permission and if the caller does not have the required permission. do not require any security permission.\n• Returns a set of the socket options supported by this server socket. This method will continue to return the set of options even after the socket has been closed. A set of the socket options supported by this socket. This set may be empty if the socket's SocketImpl cannot be created.\n\nReport a bug or suggest an enhancement\n\n For further API reference and developer documentation see the Java SE Documentation, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. Other versions.\n\n Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.\n\n Copyright © 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.\n\nAll rights reserved. Use is subject to license terms and the documentation redistribution policy. \n\nDRAFT 23-valhalla+1-90"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nReading from and Writing to a Socket\n\nLet's look at a simple example that illustrates how a program can establish a connection to a server program using the class and then, how the client can send data to and receive data from the server through the socket.\n\nThe example program implements a client, , that connects to an echo server. The echo server receives data from its client and echoes it back. The example implements an echo server. (Alternatively, the client can connect to any host that supports the Echo Protocol.)\n\nThe example creates a socket, thereby getting a connection to the echo server. It reads input from the user on the standard input stream, and then forwards that text to the echo server by writing the text to the socket. The server echoes the input back through the socket to the client. The client program reads and displays the data passed back to it from the server.\n\nNote that the example both writes to and reads from its socket, thereby sending data to and receiving data from the echo server.\n\nLet's walk through the program and investigate the interesting parts. The following statements in the -with-resources statement in the example are critical. These lines establish the socket connection between the client and the server and open a and a on the socket:\n\nThe first statement in the -with resources statement creates a new object and names it . The constructor used here requires the name of the computer and the port number to which you want to connect. The example program uses the first command-line argument as the name of the computer (the host name) and the second command line argument as the port number. When you run this program on your computer, make sure that the host name you use is the fully qualified IP name of the computer to which you want to connect. For example, if your echo server is running on the computer and it is listening on port number 7, first run the following command from the computer if you want to use the example as your echo server:\n\nAfterward, run the example with the following command:\n\nThe second statement in the -with resources statement gets the socket's output stream and opens a on it named . Similarly, the third statement gets the socket's input stream and opens a on it named . The example uses readers and writers so that it can write Unicode characters over the socket. If you are not yet familiar with the Java platform's I/O classes, you may wish to read Basic I/O.\n\nThe next interesting part of the program is the loop. The loop reads a line at a time from the standard input stream with the object , which is created in the fourth statement in the -with resources statement. The loop then immediately sends the line to the server by writing it to the connected to the socket:\n\nThe last statement in the loop reads a line of information from the connected to the socket. The method waits until the server echoes the information back to . When returns, prints the information to the standard output.\n\nThe loop continues until the user types an end-of-input character. That is, the example reads input from the user, sends it to the Echo server, gets a response from the server, and displays it, until it reaches the end-of-input. (You can type an end-of-input character by pressing Ctrl-C.) The loop then terminates, and the Java runtime automatically closes the readers and writers connected to the socket and to the standard input stream, and it closes the socket connection to the server. The Java runtime closes these resources automatically because they were created in the -with-resources statement. The Java runtime closes these resources in reverse order that they were created. (This is good because streams connected to a socket should be closed before the socket itself is closed.)\n\nThis client program is straightforward and simple because the echo server implements a simple protocol. The client sends text to the server, and the server echoes it back. When your client programs are talking to a more complicated server such as an HTTP server, your client program will also be more complicated. However, the basics are much the same as they are in this program:\n• Open an input stream and output stream to the socket.\n• Read from and write to the stream according to the server's protocol.\n\nOnly step 3 differs from client to client, depending on the server. The other steps remain largely the same."
    },
    {
        "link": "https://stackoverflow.com/questions/28945707/bufferedreader-and-sockets-in-java",
        "document": "Suppose I'm using a Socket InputStream like this,in order to read the following data:\n\n (first part encoded in ASCII)\n\nwhat I expect at this point,is that contains the text:\n\nThen I would like to use the original socket InputStream:\n\nto read the binary part of the message.\n\nNow, what if the BufferedReader has buffered some of the binary data,\n\n this would be a problem because I would miss part of the data.\n\n Am I misssing something ?"
    },
    {
        "link": "https://baeldung.com/java-buffered-reader",
        "document": "BufferedReader is a class which simplifies reading text from a character input stream. It buffers the characters in order to enable efficient reading of text data.\n\nIn this tutorial, we’re going to look at how to use the BufferedReader class.\n\n2. When to Use BufferedReader\n\nIn general, BufferedReader comes in handy if we want to read text from any kind of input source whether that be files, sockets, or something else.\n\nSimply put, it enables us to minimize the number of I/O operations by reading chunks of characters and storing them in an internal buffer. While the buffer has data, the reader will read from it instead of directly from the underlying stream.\n\nLike most of the Java I/O classes, BufferedReader implements Decorator pattern, meaning it expects a Reader in its constructor. In this way, it enables us to flexibly extend an instance of a Reader implementation with buffering functionality:\n\nBut, if buffering doesn’t matter to us we could just use a FileReader directly:\n\nIn addition to buffering, BufferedReader also provides some nice helper functions for reading files line-by-line. So, even though it may appear simpler to use FileReader directly, BufferedReader can be a big help.\n\nIn general, we can configure BufferedReader to take any kind of input stream as an underlying source. We can do it using InputStreamReader and wrapping it in the constructor:\n\nIn the above example, we are reading from System.in which typically corresponds to the input from the keyboard. Similarly, we could pass an input stream for reading from a socket, file or any imaginable type of textual input. The only prerequisite is that there is a suitable InputStream implementation for it.\n\nAs an alternative, we could use the Scanner class to achieve the same functionality as with BufferedReader.\n\nHowever, there are significant differences between these two classes which can make them either more or less convenient for us, depending on our use case:\n• BufferedReader is synchronized (thread-safe) while Scanner is not\n• Scanner can parse primitive types and strings using regular expressions\n• BufferedReader allows for changing the size of the buffer while Scanner has a fixed buffer size\n• Scanner hides IOException, while BufferedReader forces us to handle it\n• BufferedReader is usually faster than Scanner because it only reads the data without parsing it\n\nWith these in mind, if we are parsing individual tokens in a file, then Scanner will feel a bit more natural than BufferedReader. But, just reading a line at a time is where BufferedReader shines.\n\nIf needed, we also have a guide on Scanner as well.\n\nLet’s go through the entire process of building, using and destroying a BufferReader properly to read from a text file.\n\nWrapping the FileReader like this is a nice way to add buffering as an aspect to other readers.\n\nBy default, this will use a buffer of 8 KB. However, if we want to buffer smaller or larger blocks, we can use the BufferedReader(Reader, int) constructor:\n\nThis will set the buffer size to 16384 bytes (16 KB).\n\nThe optimal buffer size depends on factors like the type of the input stream and the hardware on which the code is running. For this reason, to achieve the ideal buffer size, we have to find it ourselves by experimenting.\n\nIt’s best to use powers of 2 as buffer size since most hardware devices have a power of 2 as the block size.\n\nFinally, there is one more handy way to create a BufferedReader using the Files helper class from the java.nio API:\n\nCreating it like this is a nice way to buffer if we want to read a file because we don’t have to manually create a FileReader first and then wrap it.\n\nNext, let’s read the content of the file using the readLine method:\n\nWe can do the same thing as above using the lines method introduced in Java 8 a bit more simply:\n\nAfter using the BufferedReader, we have to call its close() method to release any system resources associated with it. This is done automatically if we use a try-with-resources block:\n\nNow let’s focus on various useful methods available in BufferedReader.\n\nWe can use the read() method to read a single character. Let’s read the whole content character-by-character until the end of the stream:\n\nThis will read the characters (returned as ASCII values), cast them to char and append them to the result. We repeat this until the end of the stream, which is indicated by the response value -1 from the read() method.\n\nIf we want to read multiple characters at once, we can use the method read(char[] cbuf, int off, int len):\n\nIn the above code example, we’ll read up to 5 characters into a char array and construct a string from it. In the case that no characters were read in our read attempt (i.e. we’ve reached the end of the stream), we’ll simply return an empty string.\n\nWe can also skip a given number of characters by calling the skip(long n) method:\n\nIn the above example, we read from an input string which contains numbers separated by two underscores. In order to construct a string containing only the numbers, we are skipping the underscores by calling the skip method.\n\nWe can use the mark(int readAheadLimit) and reset() methods to mark some position in the stream and return to it later. As a somewhat contrived example, let’s use mark() and reset() to ignore all whitespaces at the beginning of a stream:\n\nIn the above example, we use the mark() method to mark the position we just read. Giving it a value of 1 means only the code will remember the mark for one character forward. It’s handy here because, once we see our first non-whitespace character, we can go back and re-read that character without needing to reprocess the whole stream. Without having a mark, we’d lose the L in our final string.\n\nNote that because mark() can throw an UnsupportedOperationException, it’s pretty common to associate markSupported() with code that invokes mark(). Though, we don’t actually need it here. That’s because markSupported() always returns true for BufferedReader.\n\nOf course, we might be able to do the above a bit more elegantly in other ways, and indeed mark and reset aren’t very typical methods. They certainly come in handy, though, when there is a need to look ahead.\n\nIn this quick tutorial, we’ve learned how to read character input streams on a practical example using BufferedReader."
    },
    {
        "link": "https://studytonight.com/java-examples/java-bufferedreader",
        "document": "The class is part of the package and extends the class. BufferedReader is used to read text from a character input stream and buffers the characters for better performance.\n\nIn this tutorial, we will learn more about this class.\n• As discussed above, is a class used to read text from some source(like files or sockets).\n• BufferedReader wraps another reader or input stream to increase the overall efficiency and performance of our program.\n• A BufferedReader uses a buffer to store the data read from the source. It decreases the number of I/O operations required.\n• Several readers like FileReader and InputStreamReader have costly read operations, and it is better to wrap them using BufferedReader.\n\nThe BufferedReader class provides two constructors. Each of them takes a Reader as a parameter. We can also specify the size of the underlying buffer in the constructor. The default buffer size is 8KB.\n\nLet's wrap a FileReader with the BufferedReader. We can use it to read data from a file.\n\nIn the later sections, we will use it to read data from the files in different ways.\n\nWe can create a BufferedReader using an input stream as a source.\n\nLet's wrap the InputStreamReader and read data from System.in. It will read data that we enter using the keyboard. The code below demonstrates this.\n\nThe image below shows the output.\n\nWe should always use the close() method of the BufferedReader to release all the system resources associated with the reader. We don't need to explicitly call this method if we are using a try-with-resources block.\n\nBoth Scanner and BufferedReader can read data from an external source. However, there are some differences between the two.\n• BufferedReader class is synchronized and thread-safe, whereas the Scanner class is not synchronized.\n• The Scanner class has a smaller buffer of fixed size(1KB). BufferedReader can change the size of the buffer. Also, the default size of the buffer used by BufferedReader is much more than the Scanner class.\n• BufferedReader is faster than Scanner as it reads data without parsing it.\n• A Scanner will hide the IOException. With a BufferedReader, we need to handle this exception.\n\nThe class provides several methods to read data. The readLine() method reads one line at a time. This method returns null if we reach the end of the stream. Let's read a file using this method. The demo.txt file contains the following lines.\n\nThe code to read the file is shown below.\n\n\n\n Line: 1\n\n This is a Demo File.\n\n \n\n Line: 2\n\n We will read this file using BufferedReader.\n\n \n\n Line: 3\n\n This is the end of file.\n\nWe can also read a single character at a time by using the read() method of the BufferedReader class. This method returns the char read as an integer. If we reach the end of the stream, then it returns -1. The code below demonstrates this method's working. Our file contains the text \"Hello World!\".\n\nThe read() method can also read multiple characters at once. We need to pass a char array in which it will store the data. We also need to use an offset that indicates the starting index of the char array. The stored data starts from this index. We also need to mention the maximum length of characters to read.\n\nOur file contains the text \"HelloWorld\". We want to read \"Hello\" from the file. The code below demonstrates how to do this.\n\nThe BufferedReader class provides a skip() method, which we can use to skip characters. It takes a long type parameter. Suppose our file contains the text \"H*e*l*l*o\". After reading each character, we need to skip one character as we don't want to read the asterisks.\n\nThe BufferedReader class provides us the mark() method to mark a specific character. We can come back to this marked character anytime in the future by using the reset() method. The mak() method takes an integer as input that denotes the maximum bytes that can be read before the mark becomes invalid.\n\nSuppose our file contains the text \"He*llo\". We will read all the characters but mark the asterisk. Then we will come back to this mark using reset().\n\nThe BufferedReader class reads data from a source like a file or a stream. It improves the performance of other readers by using a buffer that reduces the number of I/O operations. The BufferedReader class provides several convenient methods to read data. We can use the readLine() method to read individual lines. The read() method can read single or multiple characters."
    }
]