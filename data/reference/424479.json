[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient",
        "document": "In this article, you learn how to make HTTP requests and handle responses with the class.\n\nHTTP endpoints commonly return JavaScript Object Notation (JSON) data, but not always. For convenience, the optional System.Net.Http.Json NuGet package provides several extension methods for and objects that perform automatic serialization and deserialization by using the ðŸ“¦ System.Text.Json NuGet package. The examples in this article call attention to places where these extensions are available.\n\nMost of the examples in this article reuse the same instance, so you can configure the instance once and use it for the remaining examples. To create an object, use the class constructor. For more information, see Guidelines for using HttpClient.\n\nThe code completes the following tasks:\nâ€¢ Instantiate a new instance as a variable. According to the guidelines, the recommended approach is to reuse instances during the application lifecycle.\n\nThis instance uses the base address to make subsequent requests. To apply other configurations, consider the following APIs:\n\nTo make an HTTP request, you call any of the following API methods:\n\nThe HttpContent type is used to represent an HTTP entity body and corresponding content headers. For HTTP methods (or request methods) that require a body ( , , ), you use the HttpContent class to specify the body of the request. Most examples show how to prepare the StringContent subclass with a JSON payload, but other subclasses exist for different content (MIME) types.\nâ€¢ FormUrlEncodedContent: Provides HTTP content for name/value tuples encoded by using the MIME type.\nâ€¢ MultipartContent: Provides a collection of HttpContent objects that get serialized by using the MIME type specification.\nâ€¢ MultipartFormDataContent: Provides a container for content encoded by using the MIME type.\nâ€¢ ReadOnlyMemoryContent: Provides HTTP content based on an ReadOnlyMemory<T> value.\n\nThe class is also used to represent the response body of the HttpResponseMessage class, which is accessible on the HttpResponseMessage.Content property.\n\nUse an HTTP GET request\n\nA request shouldn't send a body. This request is used (as the method name indicates) to retrieve (or get) data from a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.GetAsync method:\n\nThe code completes the following tasks:\nâ€¢ Write the request details to the console.\nâ€¢ Write the JSON response body to the console.\n\nThe method is a custom extension that isn't part of the framework. If you're curious about the implementation, consider the following C# code:\n\nThis functionality is used to write the request details to the console in the following form:\n\nAs an example, the request to the endpoint outputs the following message:\n\nCreate the HTTP GET request from JSON\n\nThe https://jsonplaceholder.typicode.com/todos endpoint returns a JSON array of objects. Their JSON structure resembles the following form:\n\nThe C# object is defined as follows:\n\nIt's a type, with optional , , , and properties. For more information on the type, see Introduction to record types in C#. To automatically deserialize requests into a strongly typed C# object, use the GetFromJsonAsync extension method that's part of the ðŸ“¦ System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ The query string represents the filtering criteria for the request. When the command succeeds, the response is automatically deserialized into a object.\nâ€¢ None Write the request details to the console, along with each object.\n\nA request sends data to the server for processing. The header of the request signifies what MIME type the body is sending. To make an HTTP request given an instance and a Uri object, use the HttpClient.PostAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Write the response body as a string to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PostAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the object to the console.\n\nThe request method either replaces an existing resource or creates a new one by using the request body payload. To make an HTTP request given an instance and a Uri object, use the HttpClient.PutAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PutAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\nâ€¢ Serialize the instance as JSON and make a request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Deserialize the response body into a instance and write the objects to the console.\n\nThe request is a partial update to an existing resource. This request doesn't create a new resource and it isn't intended to replace an existing resource. Instead, this method only partially updates a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.PatchAsync method:\n\nThe code completes the following tasks:\nâ€¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\nâ€¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nNo extension methods exist for requests in the NuGet package.\n\nA request removes an existing resource and the request is idempotent, but not safe. Multiple requests to the same resources yield the same result, but the request affects the state of the resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.DeleteAsync method:\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\n\nThe request is similar to a request. Instead of returning the resource, this request returns only the headers associated with the resource. A response to the request doesn't return a body. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response headers and write each header to the console.\n\nThe request is used to identify which HTTP methods a server or endpoint supports. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\nâ€¢ Send an HTTP request to the endpoint.\nâ€¢ Ensure the response is successful and write the request details to the console.\nâ€¢ Iterate over all of the response content headers and write each header to the console.\n\nThe request can be useful for debugging as it provides application-level loop-back of the request message. To make an HTTP request, create an HttpRequestMessage by using the type:\n\nWhen you handle an HTTP response, you interact with the HttpResponseMessage type. Several members are used to evaluate the validity of a response. The HTTP status code is available in the HttpResponseMessage.StatusCode property.\n\nTo ensure the is (HTTP status code 200), you can evaluate the value as shown in the following example:\n\nThere are other HTTP status codes that represent a successful response, such as (HTTP status code 201), (HTTP status code 202), (HTTP status code 204), and (HTTP status code 205). You can use the HttpResponseMessage.IsSuccessStatusCode property to evaluate these codes as well, which ensures that the response status code is within the range 200-299:\n\nIf you need to have the framework throw the HttpRequestException error, you can call the HttpResponseMessage.EnsureSuccessStatusCode() method:\n\nThis code throws an error if the response status code isn't within the 200-299 range.\n\nWith a valid response, you can access the response body by using the Content property. The body is available as an HttpContent instance, which you can use to access the body as a stream, byte array, or string.\n\nThe following code uses the object to read the response body:\n\nYou can use different objects to read the response body. Use the object to read the response body:\n\nUse the object to read the response body:\n\nWhen you know an HTTP endpoint returns JSON, you can deserialize the response body into any valid C# object by using the System.Net.Http.Json NuGet package:\n\nIn this code, the value is the response body deserialized as the type .\n\nWhen an HTTP request fails, the system throws the HttpRequestException object. Catching the exception alone might not be sufficient. There are other potential exceptions thrown that you might want to consider handling. For example, the calling code might use a cancellation token that was canceled before the request completed. In this scenario, you can catch the TaskCanceledException error:\n\nLikewise, when you make an HTTP request, if the server doesn't respond before the HttpClient.Timeout value is exceeded, the same exception is thrown. In this scenario, you can distinguish that the time-out occurred by evaluating the Exception.InnerException property when catching the TaskCanceledException error:\n\nIn the code, when the inner exception is an TimeoutException type, then the time-out occurred and the cancellation token doesn't cancel the request.\n\nTo evaluate the HTTP status code when you catch the HttpRequestException object, you can evaluate the HttpRequestException.StatusCode property:\n\nIn the code, the EnsureSuccessStatusCode() method is called to throw an exception if the response isn't successful. The HttpRequestException.StatusCode property is then evaluated to determine if the response was a (HTTP status code 404). There are several helper methods on the object that implicitly call the method on your behalf.\n\nFor HTTP error handing, consider the following APIs:\n\nWhen you call these methods, you can handle the object and evaluate the HttpRequestException.StatusCode property to determine the HTTP status code of the response:\n\nThere might be scenarios where you need to throw the HttpRequestException object in your code. The HttpRequestException() constructor is public and you can use it to throw an exception with a custom message:\n\nAn HTTP proxy can be configured in one of two ways. A default is specified on the HttpClient.DefaultProxy property. Alternatively, you can specify a proxy on the HttpClientHandler.Proxy property.\n\nThe property is a static property that determines the default proxy that all instances use, if no proxy is set explicitly in the HttpClientHandler object passed through its constructor.\n\nThe default instance returned by this property initializes according to a different set of rules depending on your platform:\nâ€¢ Windows: Read proxy configuration from environment variables, or if variables aren't defined, read from user proxy settings.\nâ€¢ macOS: Read proxy configuration from environment variables, or if variables aren't defined, read from system proxy settings.\nâ€¢ Linux: Read proxy configuration from environment variables, or if variables aren't defined, initialize a nonconfigured instance to bypass all addresses.\n\nThe property initialization on Windows and Unix-based platforms uses the following environment variables:\nâ€¢ : The proxy server used on HTTP requests.\nâ€¢ : The proxy server used on HTTPS requests.\nâ€¢ : The proxy server used on HTTP and/or HTTPS requests when the and/or variables aren't defined.\nâ€¢ : A comma-separated list of hostnames to exclude from proxying. Asterisks aren't supported for wildcards. Use a leading period (.) when you want to match a subdomain. Examples: (with leading period) matches , but doesn't match . (without leading period) doesn't match . This behavior might be revisited in the future to match other ecosystems better.\n\nOn systems where environment variables are case-sensitive, the variable names can be all lowercase or all uppercase. The lowercase names are checked first.\n\nThe proxy server can be a hostname or IP address, optionally followed by a colon and port number, or it can be an URL, optionally including a username and password for proxy authentication. The URL must start with , not , and can't include any text after the hostname, IP, or port.\n\nThe HttpClientHandler.Proxy property identifies the WebProxy object to use to process requests to internet resources. To specify that no proxy should be used, set the property to the proxy instance returned by the GlobalProxySelection.GetEmptyWebProxy() method.\n\nThe local computer or application configuration file might specify that a default proxy is used. If the property is specified, then the proxy settings from the property override the local computer or application config file and the handler uses the proxy settings specified. If no proxy is specified in a config file and the property is unspecified, the handler uses the proxy settings inherited from the local computer. If there are no proxy settings, the request is sent directly to the server.\n\nThe HttpClientHandler class parses a proxy bypass list with wildcard characters inherited from local computer settings. For example, the class parses a bypass list of from browsers as a regular expression of . Therefore, a URL of bypasses the proxy by using the class.\n\nThe class supports local proxy bypass. The class considers a destination to be local if any of the following conditions are met:\nâ€¢ The destination contains a flat name (no periods (.) in the URL).\nâ€¢ The destination contains a loopback address (Loopback or IPv6Loopback) or the destination contains an IPAddress property assigned to the local computer.\nâ€¢ The domain suffix of the destination matches the local computer's domain suffix, as defined in the DomainName property.\n\nFor more information about configuring a proxy, see the following APIs:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://kenslearningcurve.com/tutorials/getting-started-with-httpclient-in-c",
        "document": "When you have multiple applications and they need to communicate with each other to exchange data you might want to use a protocol that makes something like that happen. In C#, the HTTPClient class provides a powerful and flexible way to make HTTP requests and handle responses. Whether youâ€™re building a web application that needs to interact with APIs or simply need to retrieve data from a server, HTTPClient in C# can help.\n\nIn this tutorial, weâ€™ll explore how to use the HTTPClient class in C# to make GET and POST requests, handle errors, and more. Weâ€™ll cover the basics of setting up and configuring the HTTPClient and advanced usage scenarios such as working with different content types and handling authentication. By the end of this tutorial, youâ€™ll have a solid understanding of how to use the HTTPClient in your own C# projects.\n\nIn this tutorial, I will use a few free APIs that you can find online. You donâ€™t need to register or generate a key. If they do change in the future, please let me know.\n\nWhat is the HTTPClient?\n\nMicrosoft has a good and short description of the HTTPClient in C#:\n\nAnd that is exactly what this class does.\n\nHTTP is the very foundation of data communication on the Internet. Every time you visit a page, upload a photo of a cute dog to social media, check your e-mail, and much more, it requires data to be sent and received through the World Wide Web.\n\nIf you work with C# and need to receive information or data from an external, online data source, you need to send out an HTTP request and need to be able to receive the response. Before the .NET Framework 4.5, we used the HttpWebRequest and HttpWebResponse to handle these requests. Since version 4.5 we have the HTTPClient class.\n\nSo, why not use the HttpWebResponse and HttpWebRequest? There are some differences between those and the HTTPClient. Here are a few:\nâ€¢ The HTTPClient is easier to use and read\nâ€¢ HTTPClient automatically reuses the connection for multiple requests for better performance. HttpWebRequest has the KeepAlive property, but itâ€™s disabled by default.\nâ€¢ HTTPClient automatically includes a set of default headers in every request, such as User-Agent, Accept, and Connection headers. HttpWebRequest does not provide default headers.\n\nThe HTTPWebRequest is still usable in the newest version of .NET and could be a good option in several cases. Newer classes and functions donâ€™t always mean the older ones are bad.\n\nIt really depends on the situation when you need to perform HTTP requests. Here are some basic guidelines:\nâ€¢ You need a simpler and more modern API for sending HTTP requests and receiving HTTP responses.\nâ€¢ You want to perform asynchronous operations using the async/await pattern.\nâ€¢ You need automatic handling of decompression, connection reuse, and default headers.\nâ€¢ You want to take advantage of HTTP/2 support.\nâ€¢ You need more control over the HTTP request and response and are willing to work with a lower-level API.\nâ€¢ You need to support older .NET Framework versions (before 4.5), as HttpWebRequest has been around since .NET Framework 1.1.\nâ€¢ You need to perform more advanced HTTP operations, such as sending chunked requests or using custom HTTP methods.\nâ€¢ You are working with a legacy system that requires the use of HttpWebRequest.\n\nSetting up the HTTPClient in C#\n\nThere are a few types of HTTP requests that describe what you might want to do. In this tutorial, I will explain how you can perform a GET, POST, and DELETE request. Letâ€™s start with the simplest of all: GET.\n\nBefore we can make an HTTP request we need to set up the HTTPClient. I create a Console App to write and test the code. I also install the NuGet package Newtonsoft.Json and will use this in the next code.\n\nUsing and setting up the HTTPClient comes in different layers. We need to initialize the HTTPClient class, then send out the request, and check if that request was successful. If we expect data to be sent back we need to grab that data and transform it into our code.\n\nIf we create code to implement it, it would look like this:\n\nOn line 1 the HTTPClient is initialized. I am using the using so the HTTPClient initialization will dispose of when I donâ€™t need it anymore, also closing the connections. Then on line 3, I send the GET request to the URL. This is an asynchronous method, so I use the await.\n\nOn line 5 I check if the response was successful. Meaning that I get a positive HTTP status code. If it is not successful I could throw an exception or something.\n\nBut it is successful so I can retrieve the content from the response on line 7. The response.Content.ReadAsStringAsync() retrieves the response as a string, making it perfect to convert it to a JSON on line 9.\n\nAnd then we are done with the HTTPClient in C#. I look through the list of jokes and print them on my screen.\n\nPretty simple, right? All you need to do is have an URL, initialization of the HTTPClient class, and off you go.\n\nWhile a GET request is pretty simple, a POST needs a little bit extra. A POST request lets you send data from a client to the source, like an API. Therefore, the POST request needs a body with data.\n\nThis body is usually a key-value situation. The key is a property name and the value is â€¦. Well, the value of that property. Apart from the body, there isnâ€™t anything special about it. It even starts the same, but we donâ€™t expect any data to be returned, so we donâ€™t have to grab and deserialize data.\n\nAgain, I initialize the HTTPClient. On lines 3 to 7 I create a new joke, nothing special here. But on line 9 I create a new variable of the type StringContent and initialize it with the newJoke that is being converted to a JSON string. Because I am using JSON as the body of the request, I need to set the ContentType of the body to application/json. I do this on line 10.\n\nThe reason I need to set the ContentType is to let the target know what kind of data Iâ€™ll be sending to it. It also could be XML and the target canâ€™t receive XML if I send JSON.\n\nThe PUT request works exactly the same but instead of using client.PostAsync you use the client.PutAsync.\n\nThere are a lot of other headers you can set, but I will tell you more about that later.\n\nAlright! On line 12 I do the actual POST to the URL. This time I use the client.PostAsync. The first parameter is the URL, we already did that with the GET, and the second one is the body, which we created on line 9.\n\nWith a POST request, or PUT and DELETE, there is no need to check if the response is successful or not. More the opposite; we want to know when it went wrong. Therefore, I check if the response is not successful on line 13. If this is true, I get the content of the request. This is most of the time the error from the target telling me what I did wrong.\n\nI put this information in an exception so I will be alerted when something goes wrong while posting information to the target. This information could be that a required property is empty, the endpoint is incorrect, and so on.\n\nThe DELETE request looks a lot like the POST request, but with a slight difference: We donâ€™t expect to receive data from the target. If you already created the code for the POST, you can simply copy-paste that and change it a bit to this:\n\nOkay, when I look at it, it doesnâ€™t look the same at all. Anywayâ€¦\n\nAgain, I initialize the HTTPClient on line 1. On line 3 I send the DELETE request to a target. DELETE requests usually need an identifier in the URL, hence the â€™12â€™ in this example URL.\n\nWe only want to know when the request has failed and sends a response with a back status code, so we just want to check if the response is unsuccessful on line 5.\n\nTo figure out what went wrong we can extract the error by reading the content from the response and put it in an exception.\n\nI think you get the idea of how to use the HTTPClient in C#. But there is much more to it than just sending simple requests to a target and reading its response. Here are a few advanced settings you might need while expanding your HTTPClient class.\n\nSome APIs need you to authorize by adding a token to your request to the API. This is usually a JWT from the API. You need to add this token to the Authorization header of the request.\n\nThis is one of the default request headers of the client. Setting this is pretty easy if you know where to add it:\n\nAlthough it looks pretty simple, please keep in mind you need to set the DefaultRequestHeaders before you send the request, which is done on line 5. There is no point in setting the default request headers after you send everything to the target.\n\nBy default, the HTTPClient waits 100000 ms (100 seconds) for a request to finish. If it doesnâ€™t complete before that, an exception is thrown. This is what we call a timeout.\n\nYou can change that to whatever you want if you feel the need to do that. There is a setting of the HTTPClient class which is called Timeout and set with a TimeSpan.\n\nIn the example above, the timeout of the HTTPClient is set to 30 seconds. This means that if the request of that initialized client takes more than 30 seconds, an exception is thrown.\n\nIf you need to send different requests within the same method or at the same time, you donâ€™t have to close and open the HTTPClient. Reuse it. Below is an example. The client will only be closed on line 32.\n\nIf you want to reach a target using a proxy, the HTTPClient in C# will help you. It has a special handler that you can configure to use the proxy.\n\nThe following example has a proxy, which is fictional.\n\nYou can use the HTTPClient to download an image from the web and store it in an array of bytes and then save it as a file. For this, we use the GetByteArrayAsync(uri) method.\n\nThe HTTPClient in C# is used mostly when requesting or sending data from and to an external target, which is usually an API. It has different options and settings you can use to make your requests.\n\nIt has great advantages over HttpWebRequest, but the HttpWebRequest is still being used in older and new projects. Itâ€™s a good idea to get some idea of how the HttpWebRequest works, although it feels a lot to the HTTPClient."
    },
    {
        "link": "https://stackoverflow.com/questions/71368397/how-to-send-a-post-request-in-dotnet-with-a-list-of-request-headers",
        "document": "Your code isn't far off, here's an example that I had in one of my projects ...\n\n... obviously, it has varying degrees of thought for the scenario at hand but just adapt it as need be."
    },
    {
        "link": "https://sentry.io/answers/how-to-send-a-post-request-in-net-using-c-sharp",
        "document": "How to send a POST request in .NET using C#\n\nIn C#, how do you send an HTTP POST request to a URL?\n\nLetâ€™s take a simple example you can run in a terminal with to a test site, and see if we can recreate it in .NET:\n\nMicrosoft recommends using the for web requests.\n\nHereâ€™s a C# example that has the same result as the command above:\n\nWe use an asynchronous method, instead of the traditional . This allows us to use so our app can do other work while waiting for a response from the website.\n\nYour app should only have one instance of , to use as few network resources as possible. Every class in your app can share a single HttpClient. Here we are also instantiating with a statement so that .NET immediately frees its network resources when it is no longer in use.\n\nTo make the request, we create a dictionary with whatever POST key-value pairs we want to send and use the â€™s method to send the encoded data. The response is returned as a string, which we print.\n\nHow to Write Less Code\n\nIf you prefer a more fluent or functional style of coding with fewer temporary variables, you can refactor this function as:\n\nHow to Make a GET Request\n\nHereâ€™s how to make a GET request instead of a POST:\n\nWe have only removed code from the POST request example, and changed to .\n\nHow to Convert Objects To and From JSON to Send Requests\n\nIf you want to serialize and deserialize .NET objects to JSON strings to transfer them in HTTP requests, you can use Microsoftâ€™s class. We have a simple example of this in this article.\n\nYou can also use the shortcut package . It provides two methods to read and write JSON:\n\nRead Microsoftâ€™s detailed documentation on the class here. It explains how to catch timeout exceptions and check status codes."
    },
    {
        "link": "https://newtonsoft.com/json/help/html/serializingjson.htm",
        "document": "The quickest method of converting between JSON text and a .NET object is using the JsonSerializer. The JsonSerializer converts .NET objects into their JSON equivalent and back again by mapping the .NET object property names to the JSON property names and copies the values for you.\n\nFor simple scenarios where you want to convert to and from a JSON string, the SerializeObject and DeserializeObject methods on JsonConvert provide an easy-to-use wrapper over JsonSerializer. SerializeObject and DeserializeObject both have overloads that take a JsonSerializerSettings object. JsonSerializerSettings lets you use many of the JsonSerializer settings listed below while still using the simple serialization methods.\n\nFor more control over how an object is serialized, the JsonSerializer can be used directly. The JsonSerializer is able to read and write JSON text directly to a stream via JsonTextReader and JsonTextWriter. Other kinds of JsonWriters can also be used, such as JTokenReader/JTokenWriter, to convert your object to and from LINQ to JSON objects, or BsonReader/BsonWriter, to convert to and from BSON. JsonSerializer has a number of properties on it to customize how it serializes JSON. These can also be used with the methods on JsonConvert via the JsonSerializerSettings overloads. You can read more about the available JsonSerializer settings here: Serialization Settings"
    },
    {
        "link": "https://stackoverflow.com/questions/11754633/newtonsoft-json-serialize-and-deserialize-class-with-property-of-type-ienumerabl",
        "document": "I am trying to move some code to consume ASP.NET MVC Web API generated Json data instead of SOAP Xml.\n\nI have run into a problem with serializing and deserializing properties of type:\n\nHere is a simple example:\n\nI can serialize instances of SampleGroup easily with:\n\nHowever the corresponding deserialize fails:\n\n\"Could not create an instance of type JsonSerializationExample.ISample. Type is an interface or abstract class and cannot be instantated.\"\n\nIf I derive a JsonConverter I can decorate my property as follows:\n\nHere is the JsonConverter:\n\nThis converter solves the deserialization problem but I cannot figure how to code the WriteJson method to get serialization working again.\n\nIs this a \"correct\" way to solve the problem in the first place?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to",
        "document": "How to write .NET objects as JSON (serialize)\n\nThis article shows how to use the System.Text.Json namespace to serialize to JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nTo write JSON to a string or to a file, call the JsonSerializer.Serialize method.\n\nThe following example creates JSON as a string:\n\nThe JSON output is minified (whitespace, indentation, and new-line characters are removed) by default.\n\nThe following example uses synchronous code to create a JSON file:\n\nThe following example uses asynchronous code to create a JSON file:\n\nThe preceding examples use type inference for the type being serialized. An overload of takes a generic type parameter:\n\nYou can also use GitHub Copilot to generate serialization code for you. For instructions, see the Use GitHub Copilot section in this article.\nâ€¢ By default, all public properties are serialized. You can specify properties to ignore. You can also include private members.\nâ€¢ The default encoder escapes non-ASCII characters, HTML-sensitive characters within the ASCII-range, and characters that must be escaped according to the RFC 8259 JSON spec.\nâ€¢ By default, JSON is minified. You can pretty-print the JSON.\nâ€¢ By default, casing of JSON names matches the .NET names. You can customize JSON name casing.\nâ€¢ By default, circular references are detected and exceptions thrown. You can preserve references and handle circular references.\nâ€¢ By default, fields are ignored. You can include fields.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\nâ€¢ None .NET primitives that map to JavaScript primitives, such as numeric types, strings, and Boolean.\nâ€¢ None Collections and dictionaries from the following namespaces: For more information, see Supported types in System.Text.Json.\n\nYou can implement custom converters to handle additional types or to provide functionality that isn't supported by the built-in converters.\n\nHere's an example showing how a class that contains collection properties and a user-defined type is serialized:\n\nIt's 5-10% faster to serialize to a UTF-8 byte array than to use the string-based methods. That's because the bytes (as UTF-8) don't need to be converted to strings (UTF-16).\n\nTo serialize to a UTF-8 byte array, call the JsonSerializer.SerializeToUtf8Bytes method:\n\nA Serialize overload that takes a Utf8JsonWriter is also available.\n\nTo pretty-print the JSON output, set JsonSerializerOptions.WriteIndented to :\n\nStarting in .NET 9, you can also customize the indent character and size using IndentCharacter and IndentSize.\n\nUse GitHub Copilot to serialize to JSON\n\nYou can use GitHub Copilot in your IDE to generate code that uses to serialize to JSON. You can customize the prompt to use object fields that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://medium.com/@ieplt/comprehensive-guide-to-using-json-and-newtonsoft-json-in-net-ac67b7963e35",
        "document": "JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. JSON is widely used for data exchange between a server and a web application, as well as in many other scenarios where structured data needs to be transmitted or stored.\n\nWhy We Use JSON\nâ€¢ Human-Readable: JSON is written in a text format that is readable and easy to understand, which makes debugging and development straightforward.\nâ€¢ Language Independent: JSON is language-agnostic, meaning it can be used across different programming languages, making it ideal for cross-platform data interchange.\nâ€¢ Lightweight: JSON is compact and lightweight, which is efficient for data transmission over networks.\nâ€¢ Interoperability: JSONâ€™s format is based on key-value pairs, making it compatible with many modern programming languages and libraries.\n\nJSON is used in various domains, each benefiting from its simplicity and versatility. Below are some common use cases with examples.\n\nIn a microservices architecture, services often communicate with each other using message brokers like Kafka, RabbitMQ, and Azure Service Bus. These services need a standardized format to serialize and deserialize data, and JSON is commonly chosen for this purpose due to its aforementioned benefits.\n\nFor instance, when a microservice sends a message containing user information to another service, it often uses JSON to format this data. Here is an example of a JSON message:\n\nThis JSON message can be published to a message queue or topic and consumed by another service, which will then deserialize it into a corresponding object.\n\nRESTful APIs commonly use JSON to format data sent to and received from clients. For example, a weather API might return weather data in JSON format:\n\nA client application can then parse this JSON to display the weather information to users.\n\nMany applications use JSON to store configuration settings. For instance, a web application might have a configuration file named that stores settings for connecting to a database:\n\nThis JSON file can be read by the application during startup to configure the database connection and logging levels.\n\nNoSQL databases like MongoDB use JSON-like documents to store data. For example, a user document in a MongoDB collection might look like this:\n\nThis document format allows for flexible and dynamic schemas, which is a key advantage of NoSQL databases.\n\nMany third-party services and APIs provide data in JSON format, allowing easy integration and data manipulation. For example, a stock market API might return the latest stock prices in JSON:\n\nApplications can consume this JSON data to display stock prices or perform further analysis.\n\nJSON is widely used in mobile applications to transmit data between the server and the client. For example, a mobile app might send a request to a server to get a list of products, and the server responds with a JSON array of products:\n\nThe mobile app can then parse this JSON array to display the products in a list view.\n\nSerialization is the process of converting an object into a format that can be easily stored or transmitted. Newtonsoft.Json makes it simple to serialize .NET objects into JSON strings. Letâ€™s explore how to serialize objects using Newtonsoft.Json.\n\nTo serialize an object into a JSON string, you can use the method. Here's a basic example:\n\nIn this example, the object is serialized into a JSON string. The method automatically converts the object's properties into JSON format.\n\nYou can format the JSON output to make it more readable by using the enum:\n\nJust as with deserialization, you can use the attribute to control how properties are serialized:\n\nYou can control how null values are handled during serialization using the setting:\n\nIf was , it would be omitted from the JSON output.\n\nFor more complex scenarios, you can create custom converters by inheriting from . This allows you to define custom serialization logic:\n\nYou can then use this custom converter in your class:\n\nDeserialization is the process of converting a JSON string back into an object. Newtonsoft.Json makes it simple to deserialize JSON strings into .NET objects. Letâ€™s explore how to deserialize JSON into objects using Newtonsoft.Json.\n\nTo deserialize JSON into a C# object, you can use the method. Here's a basic example:\n\nIn this example, the JSON string is deserialized into an instance of the class. The method automatically maps the JSON properties to the corresponding properties of the object.\n\nIn some cases, JSON property names may not match the property names in your C# class. You can use the attribute to map JSON properties to class properties:\n\nThis ensures that the JSON properties are correctly mapped even if their names differ from the class properties.\n\nBy default, Newtonsoft.Json will ignore extra properties in the JSON that are not present in the target class. However, you can handle these scenarios explicitly using settings like and :\n\nYou can control how null values are handled during deserialization using the setting:\n\nFor more complex scenarios, you can create custom converters by inheriting from . This allows you to define custom serialization and deserialization logic:\n\nYou can then use this custom converter in your class:\n\nNewtonsoft.Json is a powerful and flexible library for handling JSON in .NET applications. Its wide array of features and settings allows for precise control over the serialization and deserialization process, making it suitable for a variety of use cases, from simple data mapping to complex custom conversions.\n\nUnderstanding how to effectively use Newtonsoft.Json can greatly enhance your ability to work with JSON data in .NET, ensuring robust and maintainable code."
    },
    {
        "link": "https://stackoverflow.com/questions/6201529/how-do-i-turn-a-c-sharp-object-into-a-json-string-in-net",
        "document": "I have classes like these:\n\nAnd I would like to turn a object into a JSON string like this:\n\n(Without the formatting). I found this link, but it uses a namespace that's not in .NET 4. I also heard about JSON.NET, but their site seems to be down at the moment, and I'm not keen on using external DLL files.\n\nAre there other options besides manually creating a JSON string writer?"
    }
]