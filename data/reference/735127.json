[
    {
        "link": "https://geeksforgeeks.org/basics-file-handling-c",
        "document": "File handling in C is the process in which we create, open, read, write, and close operations on a file. C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc. to perform input, output, and many different C file operations in our program.\n\nWhy do we need File Handling in C?\n\nSo far the operations using the C program are done on a prompt/terminal which is not stored anywhere. The output is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program. The use of file handling is exactly what the situation calls for.\n\nIn order to understand why file handling is important, let us look at a few features of using files:\n• Reusability: The data stored in the file can be accessed, updated, and deleted anywhere and anytime providing high reusability.\n• Portability: Without losing any data, files can be transferred to another in the computer system. The risk of flawed coding is minimized with this feature.\n• Efficient: A large amount of input may be required for some programs. File handling allows you to easily access a part of a file using few instructions which saves a lot of time and reduces the chance of errors.\n• Storage Capacity: Files allow you to store a large amount of data without having to worry about storing everything simultaneously in a program.\n\nTypes of Files in C\n\nA file can be classified into two types based on the way the file stores the data. They are as follows:\n\nA text file contains data in the form of ASCII characters and is generally used to store a stream of characters.\n• None Each line in a text file ends with a new line character (‘\n\n’).\n• None It can be read or written by any text editor.\n• None They are generally stored with .txt\n• None Text files can also be used to store the source code.\n\nA binary file contains data in binary form (i.e. 0’s and 1’s) instead of ASCII characters. They contain data that is stored in a similar manner to how it is stored in the main memory.\n• None The binary files can be created only from within a program and their contents can only be read by a program.\n• None More secure as they are not easily readable.\n• None They are generally stored with .bin\n\nC file operations refer to the different possible operations that we can perform on a file in C such as:\n• fopen() with attributes as “a” or “a+” or “w” or “w+”\n\nThe highlighted text mentions the C function used to perform the file operations.\n\nA file pointer is a reference to a particular position in the opened file. It is used in file handling to perform all file operations such as read, write, close, etc. We use the FILE macro to declare the file pointer variable. The FILE macro is defined inside <stdio.h> header file.\n\nFile Pointer is used in almost all the file operations in C.\n\nFor opening a file in C, the fopen() function is used with the filename or file path along with the required access modes.\n• file_name: name of the file when present in the same directory as the source file. Otherwise, full path.\n• access_mode: Specifies for what operation the file is being opened.\n• None If the file is opened successfully, returns a file pointer to it.\n• None If the file is not opened, then returns NULL.\n\nFile opening modes or access modes specify the allowed operations on the file to be opened. They are passed as an argument to the fopen() function. Some of the commonly used file access modes are listed below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) returns NULL. Open for reading in binary mode. If the file does not exist, fopen( ) returns NULL. Open for writing in text mode. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens only in the append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. If the file does not exist, it will be created. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file does not exist, fopen( ) returns NULL. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist a new file is created. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens the file in both reading and append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. If the file does not exist, it will be created.\n\nAs given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”.\n\nThe file is not opened because it does not exist in the source directory. But the fopen() function is also capable of creating a file if it does not exist. It is shown below\n\nThe fopen() function can not only open a file but also can create a file if it does not exist already. For that, we have to use the modes that allow the creation of a file if not found such as w, w+, wb, wb+, a, a+, ab, and ab+.\n\nThe file read operation in C can be performed using functions fscanf() or fgets(). Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. There are also other functions we can use to read from a file. Such functions are listed below:\n\nSo, it depends on you if you want to read the file line by line or character by character.\n\nThe getc() and some other file reading functions return EOF (End Of File) when they reach the end of the file while reading. EOF indicates the end of the file and its value is implementation-defined.\n\nThe file write operations can be performed by the functions fprintf() and fputs() with similarities to read operations. C programming also provides some other functions that can be used to write data to a file such as:\n\nThe fclose() function is used to close the file. After successful file operations, you must always close a file to remove it from the memory.\n\nwhere the file_pointer is the pointer to the opened file.\n\nExamples of File Handing in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nThis program will create a file named GfgTest.c in the same directory as the source file which will contain the following text: “GeeksforGeeks-A Computer Science Portal for Geeks”.\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nThis program reads the text from the file named GfgTest.c which we created in the previous example and prints it in the console.\n\nTill now, we have only discussed text file operations. The operations on a binary file are similar to text file operations with little difference.\n\nTo open a file in binary mode, we use the rb, rb+, ab, ab+, wb, and wb+ access mode in the fopen() function. We also use the .bin file extension in the binary filename.\n\nWe use fwrite() function to write data to a binary file. The data is written to the binary file in the from of bits (0’s and 1’s).\n• ptr: pointer to the block of memory to be written.\n• size: size of each element to be written (in bytes).\n\nExample: Program to write to a Binary file using fwrite()\n\nThe fread() function can be used to read data from a binary file in C. The data is read from the file in the same form as it is stored i.e. binary form.\n• ptr: pointer to the block of memory to read.\n• size: the size of each element to read(in bytes).\n\nExample: Program to Read from a binary file using fread()\n\nIf we have multiple records inside a file and need to access a particular record that is at a specific position, so we need to loop through all the records before it to get the record. Doing this will waste a lot of memory and operational time. To reduce memory consumption and operational time we can use fseek() which provides an easier way to get to the required data. fseek() function in C seeks the cursor to the given record in the file.\n\nThe rewind() function is used to bring the file pointer to the beginning of the file. It can be used in place of fseek() when you want the file pointer at the start.\n\nMore Functions for C File Operations\n\nThe following table lists some more functions that can be used to perform file operations or assist in performing them."
    },
    {
        "link": "https://fresh2refresh.com/c-programming/c-file-handling/fopen-fclose-gets-fputs-functions-c",
        "document": "fopen(), fclose(), gets(), fputs() functions in C:\n\nfopen(), fclose(), gets() and fputs() functions are file handling functions in C programming language. Please find below the description and syntax for each above file handling functions.\n\nDeclaration: FILE *fopen (const char *filename, const char *mode) fopen() function is used to open a file to perform operations such as reading, writing etc. In a C program, we declare a file pointer and use fopen() as below. fopen() function creates a new file if the mentioned file name does not exist. Where,\n\n fp – file pointer to the data type “FILE”.\n\n filename – the actual file name with full path of the file.\n\n mode – refers to the operation that will be performed on the file. Example: r, w, a, r+, w+ and a+. Please refer below the description for these mode of operations. Declaration: int fclose(FILE *fp); fclose() function closes the file that is being pointed by file pointer fp. In a C program, we close a file as below.\n\n fclose (fp); Declaration: char *gets (char *string) gets functions is used to read the string (sequence of characters) from keyboard input. In a C program, we can read the string from standard input/keyboard as below.\n\n gets (string); Declaration: int fputs (const char *string, FILE *fp) fputs function writes string into a file pointed by fp. In a C program, we write string into a file as below.\n\n fputs (fp, “some data”);\n\nMode of operations performed on a file in C language:\n\nThere are many modes in opening a file. Based on the mode of file, it can be opened for reading or writing or appending the texts. They are listed below.\n• r – Opens a file in read mode and sets pointer to the first character in the file. It returns null if file does not exist.\n• w – Opens a file in write mode. It returns null if file could not be opened. If file exists, data are overwritten.\n• a – Opens a file in append mode. It returns null if file couldn’t be opened.\n• r+ – Opens a file for read and write mode and sets pointer to the first character in the file.\n• w+ – opens a file for read and write mode and sets pointer to the first character in the file.\n• a+ – Opens a file for read and write mode and sets pointer to the first character in the file. But, it can’t modify existing contents.\n\nExample program for fopen(), fclose(), gets() and fputs() functions in C programming language:\n\n/ * Open, write and close a file : */ # include <stdio.h> # include <string.h> int main( ) { FILE *fp ; char data[50]; // opening an existing file printf( \"Opening the file test.c in write mode\" ) ; fp = fopen(\"test.c\", \"w\") ; if ( fp == NULL ) { printf( \"Could not open file test.c\" ) ; return 1; } printf( \"\n\n Enter some text from keyboard” \\ “ to write in the file test.c\" ) ; // getting input from user while ( strlen ( gets( data ) ) > 0 ) { // writing in the file fputs(data, fp) ; fputs(\"\n\n\", fp) ; } // closing the file printf(\"Closing the file test.c\") ; fclose(fp) ; return 0; } “ to write in the file test.c\"\n\nOther Inbuilt file handling functions in C programming language:\n\nC programming language offers many other inbuilt functions for handling files. They are given below. Please click on each function name below to know more details, example programs, output for the respective file handling function."
    },
    {
        "link": "https://tutorialspoint.com/cprogramming/c_file_io.htm",
        "document": "File handling in C is the process of handling file operations such as creating, opening, writing data, reading data, renaming, and deleting using the C language functions. With the help of these functions, we can perform file operations to store and retrieve the data in/from the file in our program.\n\nNeed of File Handling in C\n\nIf we perform input and output operations using the C program, the data exists as long as the program is running, when the program is terminated, we cannot use that data again. File handling is required to work with files stored in the external memory i.e., to store and access the information to/from the computer's external memory. You can keep the data permanently using file handling.\n\nA file represents a sequence of bytes. There are two types of files: text files and binary files −\n• Text file − A text file contains data in the form of ASCII characters and is generally used to store a stream of characters. Each line in a text file ends with a new line character (\"\n\n\"), and generally has a \".txt\" extension.\n• Binary file − A binary file contains data in raw bits (0 and 1). Different application programs have different ways to represent bits and bytes and use different file formats. The image files (.png, .jpg), the executable files (.exe, .com), etc. are the examples of binary files.\n\nWhile working with file handling, you need a file pointer to store the reference of the FILE structure returned by the fopen() function. The file pointer is required for all file-handling operations.\n\nThe fopen() function returns a pointer of the FILE type. FILE is a predefined struct type in stdio.h and contains attributes such as the file descriptor, size, and position, etc.\n\nBelow is the syntax to declare a file pointer −\n\nA file must be opened to perform any operation. The fopen() function is used to create a new file or open an existing file. You need to specify the mode in which you want to open. There are various file opening modes explained below, any one of them can be used during creating/opening a file.\n\nThe fopen() function returns a FILE pointer which will be used for other operations such as reading, writing, and closing the files.\n\nBelow is the syntax to open a file −\n\nHere, filename is the name of the file to be opened, and mode defines the file's opening mode.\n\nThe file access modes by default open the file in the text or ASCII mode. If you are going to handle binary files, then you will use the following access modes instead of the above-mentioned ones:\n\nThere are various modes in which a file can be opened. The following are the different file opening modes −\n\nIn the following example, we are creating a new file. The file mode to create a new file will be \"w\" (write-mode).\n\nIn the following example, we are opening an existing file. The file mode to open an existing file will be \"r\" (read-only). You may also use other file opening mode options explained above.\n\nNote: There must be a file to be opened.\n\nEach file must be closed after performing operations on it. The fclose() function closes an opened file.\n\nBelow is the syntax of fclose() function −\n\nThe fclose() function returns zero on success, or EOF if there is an error in closing the file.\n\nThe fclose() function actually flushes any data still pending in the buffer to the file, closes the file, and releases any memory used for the file. The EOF is a constant defined in the header file stdio.h.\n\nIn the following example, we are closing an opened file −\n\nThe following library functions are provided to write data in a file opened in writeable mode −\n\nThe fputc() function is an unformatted function that writes a single character value of the argument \"c\" to the output stream referenced by \"fp\".\n\nIn the following code, one character from a given char array is written into a file opened in the \"w\" mode:\n\nThe fputs() function writes the string \"s\" to the output stream referenced by \"fp\". It returns a non-negative value on success, else EOF is returned in case of any error.\n\nThe following program writes strings from the given two-dimensional char array to a file −\n\nWhen the program is run, a file named \"file2.txt\" is created in the current folder and save the following lines −\n\nThe fprintf() function sends a formatted stream of data to the disk file represented by the FILE pointer.\n\nIn the following program, we have an array of struct type called \"employee\". The structure has a string, an integer, and a float element. Using the fprintf() function, the data is written to a file.\n\nThe following library functions are provided to read data from a file that is opened in read mode −\n\nThe fgetc() function reads a character from the input file referenced by \"fp\". The return value is the character read, or in case of any error, it returns EOF.\n\nThe following example reads the given file in a character by character manner till it reaches the end of file.\n\nRun the code and check its output −\n\nThe fgets() function reads up to \"n 1\" characters from the input stream referenced by \"fp\". It copies the read string into the buffer \"buf\", appending a null character to terminate the string.\n\nThis following program reads each line in the given file till the end of the file is detected −\n\nRun the code and check its output −\n\nThe fscanf() function in C programming language is used to read formatted input from a file.\n\nIn the following program, we use the fscanf() function to read the formatted data in different types of variables. Usual format specifiers are used to indicate the field types (%d, %f, %s, etc.)\n\nWhen the above program is executed, it opens the text file \"file3.txt\" and prints its contents on the screen. After running the code, you will get an output like this −\n\nThe read/write operations are done in a binary form in the case of a binary file. You need to include the character \"b\" in the access mode (\"wb\" for writing a binary file, \"rb\" for reading a binary file).\n\nThere are two functions that can be used for binary input and output: the fread() function and the fwrite() function. Both of these functions should be used to read or write blocks of memories, usually arrays or structures.\n\nThe fwrite() function writes a specified chunk of bytes from a buffer to a file opened in binary write mode. Here is the prototype to use this function:\n\nIn the following program, an array of a struct type called \"employee\" has been declared. We use the fwrite() function to write one block of byte, equivalent to the size of one employee data, in a file that is opened in \"wb\" mode.\n\nThe fread() function reads a specified chunk of bytes from a file opened in binary read mode to a buffer of the specified size. Here is the prototype to use this function:\n\nIn the following program, an array of a struct type called \"employee\" has been declared. We use the fread() function to read one block of byte, equivalent to the size of one employee data, in a file that is opened in \"rb\" mode.\n\nWhen the above program is executed, it opens the file \"file4.dat\" and prints its contents on the screen. After running the code, you will get an output like this −\n\nThe rename() function is used to rename an existing file from an old file name to a new file name.\n\nBelow is the syntax to rename a file −\n\nIf there is a file (file1.txt) available, the following will be the output −"
    },
    {
        "link": "https://quora.com/What-is-the-use-of-a-fopen-and-fclose-in-file-handling",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://w3resource.com/c-programming/c-file-handling.php",
        "document": "File handling in C is essential for reading from and writing to files, allowing programs to manage data efficiently. This tutorial covers the core functions used for file operations: fopen(), fclose(), fread(), and fwrite(). We will demonstrate their usage with practical examples and detailed explanations.\n• Example - Reading from Files with fread()\n• Example - Writing to Files with fwrite()\n\nThe fopen() function is used to open a file in C. It creates a new file if it doesn't exist (depending on the mode) or opens an existing file for reading, writing, or both. It returns a pointer to the file (of type FILE *). If the file cannot be opened, it returns NULL.\n\nSyntax of fopen() Function in C\n• Description: A string representing the name (or path) of the file to be opened.\n• Description: A string representing the mode in which the file should be opened. Common modes include reading, writing, appending, etc.\n• Example: \"r\" for reading, \"w\" for writing.\n• \"r\": Opens the file for reading. The file must exist.\n• \"w\": Opens the file for writing. If the file exists, its contents are erased. If the file does not exist, it is created.\n• \"a\": Opens the file for appending. Data is written at the end of the file. If the file does not exist, it is created.\n• \"r+\": Opens the file for both reading and writing. The file must exist.\n• \"w+\": Opens the file for both reading and writing. If the file exists, its contents are erased. If it doesn’t exist, a new file is created.\n• \"a+\": Opens the file for both reading and appending. If the file does not exist, it is created.\n• Returns a pointer of type FILE* that represents the opened file.\n• If the file cannot be opened, fopen() returns NULL.\n• Always check the return value to ensure the file was opened successfully.\n• After finishing file operations, use fclose() to close the file and free resources.\n\nThe fclose() function is used to close a file that was previously opened using fopen(), freopen(), or other file-opening functions. It ensures that any data still in the buffer is flushed to the file and that system resources (such as file pointers) are properly released.\n\nSyntax of fclose() Function in C\n• Description: A pointer to the file object that was opened by fopen(). This is the file that you want to close.\n• Example: If you opened a file like FILE *file = fopen(\"example.txt\", \"r\");, then you would pass file to fclose().\n• Returns 0 if the file is closed successfully.\n• Returns EOF (End of File) if an error occurs during closing.\n• Always close files after you're done working with them to free resources.\n• Closing a file ensures that any buffered data is written to disk (especially important when writing to a file).\n• Failing to close a file can lead to memory leaks or corruption of the file.\n\nfread() Function - Reading from a File in C\n\nThe fread() function is used to read a block of data from a file into memory. It reads binary data from a file stream, which makes it suitable for working with both text and binary files.\n\nSyntax of fread() Function in C\n• Description: A pointer to the memory where the data read from the file will be stored.\n• Description: The size of each element to be read, in bytes. Typically, this is the sizeof() the data type being read (e.g., sizeof(int) or sizeof(char)).\n• Example: sizeof(int) when reading integers or sizeof(char) when reading characters.\n• Description: The number of elements to read. This specifies how many items of the given size should be read from the file.\n• Example: To read 100 integers from a file, use fread(array, sizeof(int), 100, file);.\n• Description: A pointer to the FILE object from which to read the data. This is the file that was opened using fopen().\n• Example: If you opened a file with FILE *file = fopen(\"data.bin\", \"rb\");, pass file as the stream.\n• Description: The total number of elements successfully read. If this value is less than nmemb, either the end of the file has been reached, or an error occurred.\n• fread() reads data in binary form, making it suitable for any type of file.\n• The function reads data into memory pointed to by ptr.\n• Always check the return value to ensure the desired amount of data was read.\n• EOF (End of File) can cause fread() to return fewer elements than requested without an error occurring.\n\nfwrite() Function - Writing to a File in C\n\nThe fwrite() function is used to write data from memory to a file. It is commonly used for writing binary data to files but can also write text data. The function writes a specified number of elements of a given size from a buffer to a file stream.\n\nSyntax of fwrite() Function in C\n• Description: A pointer to the array or memory block where the data to be written is stored.\n• Description: The size of each element to write, in bytes. Usually, this is the sizeof() the data type being written (e.g., sizeof(int) or sizeof(char)).\n• Example: sizeof(int) when writing integers or sizeof(char) when writing characters.\n• Description: The number of elements to write. This parameter specifies how many items of the given size should be written from memory to the file.\n• Example: To write 100 integers to a file, use fwrite(array, sizeof(int), 100, file);.\n• Description: A pointer to the FILE object representing the open file where data is written. This file is typically opened using fopen().\n• Example: If you opened a file with FILE *file = fopen(\"data.bin\", \"wb\");, pass file as the stream.\n• Description: The total number of elements successfully written. If this value is less than nmemb, it indicates an error occurred or that the disk is full.\n• fwrite() writes data in binary form, which makes it suitable for writing any type of data (text or binary).\n• The function writes data from memory pointed to by ptr to the file specified by stream.\n• Always check the return value to ensure that the correct number of elements was written.\n• If fwrite() writes fewer elements than expected, it usually indicates a problem with the file system, such as insufficient disk space.\n\nExample - Opening and Closing Files with fopen() and fclose()\n\nFollowing example demonstrates how to open and close a file using the fopen() and fclose() function.\n• fopen(\"example.txt\", \"w\") opens the file example.txt for writing. If the file does not exist, it is created. If it exists, its contents are truncated.\n• fclose(file) closes the file, ensuring that all data is flushed and resources are freed.\n• Always check if fopen() returns NULL, indicating an error.\n• Always close files with fclose() to avoid memory leaks and ensure data integrity.\n\nExample - Reading from Files with fread()\n\nFollowing example demonstrates how to read text data from a file using the fread() function.\n• fread(buffer, sizeof(char), sizeof(buffer) - 1, file) reads up to 19 characters from the file into the buffer.\n• A null terminator is added to the buffer to create a valid string.\n• The program checks if data was read successfully and prints the result.\n\nExample - Writing to Files with fwrite()\n\nFollowing example focuses on writing text data to a file using fwrite() in a text file format.\n• fwrite(text, sizeof(char), 13, file) writes 13 characters (including space and punctuation) from the text string into the file.\n• After the writing operation, the program checks whether the correct number of elements was written.\n• The file is then closed using fclose().\n• fopen(): Opens a file. Returns NULL if the file cannot be opened.\n• fread(): Reads data from a file. Returns the number of items read.\n• fwrite(): Writes data to a file. Returns the number of items written."
    },
    {
        "link": "https://geeksforgeeks.org/error-handling-during-file-operations-in-c-c",
        "document": "File operations are a common task in C programming, but they can encounter various errors that need to be handled gracefully. Proper error handling ensures that your program can handle unexpected situations, such as missing files or insufficient permissions, without crashing. In this article, we will learn how to handle some common errors during file operations in C.\n\nHere are some common errors that can occur during file operations:\n\nFailure to check for errors then the program may behave abnormally therefore an unchecked error may result in premature termination for the program or incorrect output.\n\nBelow are some standard error handling techniques:\n\nA missing file can occur when opening a file in read mode (r) or append mode (a). Use fopen() and check for NULL. If it is, the error message can be printed using perror() function.\n\nExplanation: After attempting to read from the file, ferror() checks if there was a read error. If ferror() returns a non-zero value, it indicates that there was an error during the read operation.\n\nIf the file exists but the program lacks the required permissions, fopen() will fail. We can change the perror() output to “permission deined” as shown in the below snippet.\n\nWhen writing to a file, ensure the disk has enough space. Errors during writing can be detected using ferror().\n\nWhen creating a new file with fopen() in w mode, the existing file will be overwritten. To avoid this, check if the file exists first.\n\nAlways verify that the file pointer is not NULL before performing operations like reading or writing.\n\nWhen reading a file, reaching the end is not an error but requires proper handling to avoid unexpected results.\n\nAlways check if the file pointer is valid before performing any operations."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/1i25zdi/best_practices_for_error_management_in_c",
        "document": "First of all, I want to thank all active commenters, I am learning a lot by reading this subreddit.\n\nI am studying Hanson's \"C interfaces and implementations\". He proposes creating a rather complex interface to manage exceptions, but reading the subreddit here I have seen that his approach, based on / , is considered outdated. I found this comment by u/pgetreuer to be particularly interesting.\n\nMy question is this: where can I study modern error management in C? Is it possible to create some error interface that gives me a trace not only of the function where the error happened but also of its caller, as happens e.g. in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/9325962/how-to-catch-error-in-file-io-using-c",
        "document": "I am using following code snippet in C to copy a file:\n\nMy file is very large (200 MB), I have to handle errors if file is moved or removed while reading, writing is in progress. How can I do that?\n\nLet me clear it tad more, Any how I will get access to path by some wifi means. So if wifi will be disconnected then how I'll get the error.."
    },
    {
        "link": "https://stackoverflow.com/questions/19758483/failure-remediation-strategy-for-file-i-o",
        "document": "I'm doing buffered IO into a file, both read and write. I'm using , standard ANSI C file I/O functions. In all cases, I'm writing to a standard local file on a disk. How often do these file I/O operations fail, and what should the strategy be for failures? I'm not exactly looking for stats, but I'm looking for a general purpose statement on how far I should go to handle error conditions.\n\nFor instance, I think everyone recognizes that could and probably will fail someday on some user's machine and the developer should check for a NULL being returned, but there is no great remediation strategy since it probably means the system is out of memory. At least, this seems to be the approach taken with on desktop systems, embedded systems are different.\n\nLikewise, is it worth reattempting a file I/O operation, or should I just consider a failure to be basically unrecoverable, etc.\n\nI would appreciate some code samples demonstrating proper usage, or a library guide reference that indicates how this is to be handled. Any other data is, of course, welcome."
    },
    {
        "link": "https://geeksforgeeks.org/error-handling-in-c",
        "document": "In C programming, error handling is typically done using functions that handle runtime errors, returning error codes or messages to notify the programmer about the failure or incorrect operation. Since C does not provide built-in exception handling like other high-level languages (e.g., try-catch in Java or Python), error handling relies heavily on function return values, global variables, and system calls.\n\nA lot of C function calls return -1 or NULL or set an in case of an error code as the global variable errno, so quick tests on these values are easily done with an instance of ‘if statement’.\n\nerrno is a global variable defined in the <errno.h> header file that indicates the error that occurred during a function call in C. When a function fails, the errno variable is automatically set to a specific error code, which helps identify the type of error encountered. Different values of errno correspond to different types of errors, providing useful information for error handling in C programs.\n\nBelow is a list of a few different errno values and their corresponding meaning:\n\nDifferent methods are used to handle different kinds of errors in C. Some of the commonly used methods are:\n\nThe perror() function is used to print an error message to the standard error stream (stderr). It helps to display the error string based on the global errno variable, which stores the error code set by system calls and library functions.\n\nExplanation: This code attempts to open a non-existent file using fopen(), which sets the errno variable with an error code. It then prints the value of errno and uses perror() to display a descriptive error message related to the failure, helping the user understand the cause of the error, such as “No such file or directory.”\n\nThe strerror() function is also used to show the error description. This function returns a pointer to the textual representation of the current errno value.\n\nExplanation: The code attempts to open a non-existent file, sets errno on failure, and then prints both the error code and the corresponding error message using strerror().\n\nThe ferror() function is used to check if an error occurred during a file operation. It returns a non-zero value if there was an error during the file operation.\n\nExplanation: This code attempts to open a file and handles potential errors using perror() if the file can’t be opened. It reads the file character by character, checks for errors during reading using ferror(), and prints an appropriate message. The file is closed at the end, and the program exits with a status indicating success or failure.\n\nThe feof() function checks whether the end of a file has been reached during reading operations. It helps to identify when there is no more data to read from the file.\n\nExplanation: In this code, feof() is used to check if the end of the file (EOF) has been reached while reading the file character by character using fgetc(). If feof(fp) returns true, the while loop breaks, stopping further reading of the file.\n\nThe clearerr() function is used to clear the error and EOF flags for a stream. It allows recovery from errors and allows the stream to be reused for further operations.\n\nExplanation: The code opens a file in read mode, handles potential errors during the file opening and operations, clears any error indicators with clearerr(), and finally closes the file.\n\nC programs use the exit() function to terminate the program and return a status code to the operating system. The C standard specifies two constants: EXIT_SUCCESS and EXIT_FAILURE, that may be passed to exit() to indicate successful or unsuccessful termination, respectively. These are macros defined in <stdlib.h> header file.\n\nExplanation: The code attempts to open a file using fopen(). If the file doesn’t exist, fopen() returns NULL, and the program prints the error using errno, strerror(), and perror() to provide detailed information about the failure. The program then exits with a failure status using exit(EXIT_FAILURE). If the file is successfully opened, it is closed and the program exits with a success status (exit(EXIT_SUCCESS)), but no further code is executed after the exit() calls.\n\nHandling divide by zero errors is essential to avoid program crashes or undefined behavior. You can check for a zero divisor before performing division to prevent this error.\n\nExplanation: The program checks if the divisor num2 is zero before performing the division. If it is, it prints an error message instead of performing the division.\n\nWhat is the difference between perror() and strerror()?\n\nWhat does clearerr() do in file handling?\n\nWhat is the purpose of exit() in error handling?"
    },
    {
        "link": "https://stackoverflow.com/questions/15708793/c-convert-an-uppercase-letter-to-lowercase",
        "document": "You messed up the second part of your condition. That should be .\n\nAlso, FYI, there is a C library function that does this already:"
    },
    {
        "link": "https://geeksforgeeks.org/tolower-function-in-c",
        "document": "tolower() function in C is used to convert the uppercase alphabet to the lowercase alphabet. It does not affect characters other than uppercase characters. It is defined in the <ctype.h> header file in C.\n\nThe syntax of tolower() function is:\n• It returns the ASCII value corresponding to the lowercase of the character passed as the argument.\n\nThe below C program demonstrates the tolower() function.\n\nThe below code converts all uppercase letters in the string to their lowercase equivalents, while leaving other characters unchanged."
    },
    {
        "link": "https://shiksha.com/online-courses/articles/tolower-c",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/60057330/how-to-turn-all-uppercase-letters-to-lowercase-in-a-string-and-vice-versa-in-c",
        "document": "There are a number of ways you can handle both the data and the conversions. One of the easiest ways to store your collection of strings that lends itself to easy manipulation is std::vector which then allows you to create a (a vector of strings). A simple range-based loop provides all you need to iterate over each string.\n\nTo convert the characters in each string to upper/lower case std::transform provides an easy way to convert all or some of the characters in each string (or apply any other operation to each element in the container) Your conversions to lowercase and to uppercase, then reduce to:\n\nIn each case above the transformation is applied to the range of characters from , outputting the transformation beginning at , where the transformation itself is provided by the lambda function or the counterpart.\n\nTo implement your vector of strings and then perform the conversion to lower and then to upper, you could do:\n\nPutting it altogether and adding the needed headers, you could do:\n\nWhere each string in your vector is first converted to lowercase, and then to uppercase and output as shown above. There are many, many ways you can put the pieces together. Getting familiar with the different tools available to apply changes to each member (element) in a container using the niceties provided by the Standard Template Library, can make your work shorter and generally more robust. Let me know if you have further questions."
    },
    {
        "link": "https://geeksforgeeks.org/convert-alternate-characters-string-upper-case",
        "document": "Given a string, convert the characters of the string into the opposite case,i.e. if a character is the lower case then convert it into upper case and vice-versa.\n\nASCII values of alphabets: A – Z = 65 to 90, a – z = 97 to 122\n• None Take one string of any length and calculate its length.\n• None Scan string character by character and keep checking the index.\n• None If a character in an index is in lower case, then subtract 32 to convert it into upper case, else add 32 to convert it in lowercase\n\nApproach 2: The problem can be solved using letter case toggling. Follow the below steps to solve the problem:\n• None Print the string after all operations\n\nBelow is the implementation of the above approach:\n\nApproach : Using isupper() and islower(),upper() and lower().\n\nInitialize an empty string.Iterate a for loop over the given string and check each character whether is lowercase or uppercase using isupper() and islower().If lowercase converts the character to uppercase using upper() and append to empty string, similarly with uppercase.\n\nTime Complexity:- O(N) Where N is length of String\n\nIn this implementation, we initialize a pointer p to the start of the string str. We then use a while loop to iterate through the string by checking if the character p points to is the null character (‘\\0’). Inside the loop, we use the same logic as the previous implementation, but instead of accessing the array element at index i, we use the dereference operator * to access the value that p points to. After updating the character at the current position, we increment the pointer p to point to the next character in the string.\n\nTime Complexity:- O(n) Where N is length of input String"
    }
]