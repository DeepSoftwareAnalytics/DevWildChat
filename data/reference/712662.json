[
    {
        "link": "https://developer.android.com/reference/android/os/BatteryManager",
        "document": "The BatteryManager class contains strings and constants used for values in the Intent, and provides a method for querying battery and charging properties.\n\nSent when the device's battery has started charging (or has reached full charge and the device is on power). Sent when the device's battery may be discharging, so apps should avoid doing extraneous work that would cause it to discharge faster. Remaining battery capacity as an integer percentage of total capacity (with no fractional part). Battery capacity in microampere-hours, as an integer. Average battery current in microamperes, as an integer. Instantaneous battery current in microamperes, as an integer. Extra for : Boolean field indicating whether the battery is currently considered to be low, that is whether a broadcast has been sent. Extra for : Int value representing the battery's capacity level. Extra for : Int value representing the battery charging status. Extra for : Int value representing the battery charging cycle count. Extra for : integer containing the current health constant. Extra for : integer containing the resource ID of a small status bar icon indicating the current battery state. Extra for : integer field containing the current battery level, from 0 to . Extra for : integer indicating whether the device is plugged in to a power source; 0 means it is on battery, other constants are different types of power sources. Extra for : boolean indicating whether a battery is present. Extra for : integer containing the maximum battery level. Extra for : integer containing the current status constant. Extra for : String describing the technology of the current battery. Extra for : integer containing the current battery temperature. Extra for : integer containing the current battery voltage level.\n\nCompute an approximation for how much time (in milliseconds) remains until the battery is fully charged. Return the value of a battery property of integer type. Return the value of a battery property of long type If the platform does not provide the property queried, this value will be Long.MIN_VALUE. Return the value of a battery property of String type. Return true if the battery is currently considered to be charging.\n\nCreates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted.\n\nSent when the device's battery has started charging (or has reached full charge and the device is on power). This is a good time to do work that you would like to avoid doing while on battery (that is to avoid draining the user's battery due to things they don't care enough about). This is paired with . The current state can always be retrieved with .\n\nCompute an approximation for how much time (in milliseconds) remains until the battery is fully charged. Returns -1 if no time can be computed: either there is not enough current data to make a decision or the battery is currently discharging. how much time is left, in milliseconds, until the battery is fully charged or -1 if the computation fails\n\nReturn true if the battery is currently considered to be charging. This means that the device is plugged in and is supplying sufficient power that the battery level is going up (or the battery is fully charged). Changes in this state are matched by broadcasts of and ."
    },
    {
        "link": "https://developer.android.com/training/monitoring-device-state/battery-monitoring",
        "document": "When you're altering the frequency of your background updates to reduce the effect of those updates on battery life, checking the current battery level and charging state is a good place to start.\n\nThe battery-life impact of performing application updates depends on the battery level and charging state of the device. The impact of performing updates while the device is charging over AC is negligible, so in most cases you can maximize your refresh rate whenever the device is connected to a wall charger. Conversely, if the device is discharging, reducing your update rate helps prolong the battery life.\n\nSimilarly, you can check the battery charge level, potentially reducing the frequency of—or even stopping—your updates when the battery charge is nearly exhausted.\n\nStart by determining the current charge status. The broadcasts all battery and charging details in a sticky that includes the charging status.\n\nBecause it's a sticky intent, you don't need to register a —by simply calling passing in as the receiver as shown in the next snippet, the current battery status intent is returned. You could pass in an actual object here, but we'll be handling updates in a later section so it's not necessary.\n\nYou can extract both the current charging status and, if the device is being charged, whether it's charging via USB or AC charger:\n\nTypically you should maximize the rate of your background updates in the case where the device is connected to an AC charger, reduce the rate if the charge is over USB, and lower it further if the battery is discharging.\n\nThe charging status can change as easily as a device can be plugged in, so it's important to monitor the charging state for changes and alter your refresh rate accordingly.\n\nThe broadcasts an action whenever the device is connected or disconnected from power. It's important to receive these events even while your app isn't running—particularly as these events should impact how often you start your app in order to initiate a background update—so you should register a in your manifest to listen for both events by defining the and within an intent filter.\n\nIn some cases it's also useful to determine the current battery level. You may choose to reduce the rate of your background updates if the battery charge is below a certain level.\n\nYou can find the current battery charge by extracting the current battery level and scale from the battery status intent as shown here:\n\nReact to significant changes in battery level\n\nYou can't easily continually monitor the battery state, but you don't need to.\n\nGenerally speaking, the impact of monitoring the battery level has a greater impact on the battery than your app's normal behavior. For example, registering a in the manifest to cancel pending work when the battery is low will mainly serve to drain the battery further (and is therefore impossible since Android 8.0). Instead, you can provide constraints on work that describe when it should be run, allowing the system to make the decision without spending power starting your app.\n\nIt is generally good practice to not run your background updates when the battery is critically low. It doesn't matter how fresh your data is if the phone turns itself off before you can make use of it. To do this, use the WorkManager library with a constraint to specify that the work should not be run if the battery is low (in addition to any relevant constraints).\n\nIn many cases, the act of charging a device is coincident with putting it into a dock. To learn more, see Determine and monitor the docking state and type."
    },
    {
        "link": "https://stackoverflow.com/questions/54038290/getting-the-battery-level",
        "document": "I know there are many questions like this, but I need a concrete answer whether it is possible or not.\n\nI want to get the current available battery power in mAh for any android phone. It is crucial for my project. I tried BatteryManager.\n\nIt exactly provides the information I need, but only for some devices.\n\nI also tried using PowerProfile via Java Reflection.\n\nBut it provides the total battery capacity. What I need is the current remaining battery power. Is there any universal way to get that for every device? Any library would also do."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/android.os.batterymanager?view=net-android-35.0",
        "document": "The BatteryManager class contains strings and constants used for values in the Intent, and provides a method for querying battery and charging properties.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License.\n\nSent when the device's battery has started charging (or has reached full charge and the device is on power). Sent when the device's battery may be discharging, so apps should avoid doing extraneous work that would cause it to discharge faster. Remaining battery capacity as an integer percentage of total capacity (with no fractional part). Battery capacity in microampere-hours, as an integer. Average battery current in microamperes, as an integer. Instantaneous battery current in microamperes, as an integer. Extra for : Boolean field indicating whether the battery is currently considered to be low, that is whether a broadcast has been sent. Extra for : Int value representing the battery charging status. Extra for : Int value representing the battery charging cycle count. Extra for : integer containing the current health constant. Extra for : integer containing the resource ID of a small status bar icon indicating the current battery state. Extra for : integer field containing the current battery level, from 0 to . Extra for : integer indicating whether the device is plugged in to a power source; 0 means it is on battery, other constants are different types of power sources. Extra for : boolean indicating whether a battery is present. Extra for : integer containing the maximum battery level. Extra for : integer containing the current status constant. Extra for : String describing the technology of the current battery. Extra for : integer containing the current battery temperature. Extra for : integer containing the current battery voltage level.\n\nCreates and returns a copy of this object. (Inherited from Object) Compute an approximation for how much time (in milliseconds) remains until the battery is fully charged. Indicates whether some other object is \"equal to\" this one. (Inherited from Object) Returns a hash code value for the object. (Inherited from Object) Return the value of a battery property of integer type. Return the value of a battery property of long type If the platform does not provide the property queried, this value will be Long. Return the value of a battery property of String type. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. (Inherited from Object) Wakes up a single thread that is waiting on this object's monitor. (Inherited from Object) Wakes up all threads that are waiting on this object's monitor. (Inherited from Object) Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>. (Inherited from Object) Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed. (Inherited from Object) Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed. (Inherited from Object)\n\nGets the JNI name of the type of the instance . Try to coerce to type , checking that the coercion is valid on the Java side. Try to coerce to type , checking that the coercion is valid on the Java side."
    },
    {
        "link": "https://stackoverflow.com/questions/3291655/get-battery-level-and-state-in-android",
        "document": "Tutorial For Android has a code sample that explains how to get battery information.\n\nTo sum it up, a broadcast receiver for the intent is set up dynamically, because it can not be received through components declared in manifests, only by explicitly registering for it with ."
    },
    {
        "link": "https://dnshariprasad.medium.com/android-service-8e1d45002b79",
        "document": "\n• Used for performing tasks that need to run in the background even if the app is not in the foreground.\n• These services are often used for operations that may take some time to complete, such as downloading files, processing data, or sending notifications.\n\nEx: Downloading a large file\n• They provide a client-server interaction model, allowing components to communicate with the service and access its methods.\n• Bound services are often used when multiple components need to interact with a single instance of a service to share data or perform specific operations.\n• When all clients unbind from a bound service, the service is destroyed.\n\n— Manual Thread Management\n\n — destroyed automatically when there are no more clients bound to them*\n• IntentService handles the creation and management of worker threads, making it easier to perform background tasks without manually managing threads.\n• IntentService stops itself automatically, you don’t need to explicitly call or .\n• They provide an ongoing notification to inform the user that the service is running in the background.\n• Foreground services are less likely to be killed by the system when resources are needed, making them suitable for tasks that require continuous operation, such as playing music or monitoring location.\n\n— Manual Thread Management\n\n — Requires manual stopping\n\nThey should not be automatically stopped by the system while the notification is active. \n\n— ongoing notification to inform the user*\n\n — Client-server interaction*\n\npublic class MyForegroundService extends Service {\n\n\n\n private static final int NOTIFICATION_ID = 123;\n\n\n\n @Override\n\n public void onCreate() {\n\n super.onCreate();\n\n\n\n // Create and display the foreground notification\n\n Notification notification = createNotification();\n\n startForeground(NOTIFICATION_ID, notification);\n\n }\n\n\n\n @Override\n\n public int onStartCommand(Intent intent, int flags, int startId) {\n\n // Handle the background tasks based on the incoming intent\n\n if (intent != null) {\n\n // Process the intent's data\n\n // Perform background tasks\n\n }\n\n \n\n // Return a value that indicates how the system should handle the service after it's finished executing\n\n return START_STICKY;\n\n }\n\n\n\n @Nullable\n\n @Override\n\n public IBinder onBind(Intent intent) {\n\n return null;\n\n }\n\n\n\n private Notification createNotification() {\n\n // Create a notification using NotificationCompat.Builder\n\n NotificationCompat.Builder builder = new NotificationCompat.Builder(this, \"channelId\")\n\n .setContentTitle(\"Foreground Service\")\n\n .setContentText(\"Service is running in the foreground\")\n\n .setSmallIcon(R.drawable.ic_notification);\n\n\n\n return builder.build();\n\n }\n\n}"
    },
    {
        "link": "https://stackoverflow.com/questions/19572337/which-strategy-to-choose-when-doing-long-running-tasks-on-android",
        "document": "I am creating an application that will download around 30 images. Let's say it takes more than 10 seconds. I have been reading about and I guess that it shouldn't be used since the task will take more than a couple of seconds.\n\nAsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent pacakge such as Executor, ThreadPoolExecutor and FutureTask.\n\nWhen looking at the API for I see there are methods that can publish to the UI thread. If I have understood it right a more proper way to do long running task is to use a ? That means that I have to post updates to the UI thread myself. Is it correct that you use the method of View?\n\nI could need some guidance whether or not I am on the right track."
    },
    {
        "link": "https://developer.android.com/develop/background-work/services",
        "document": "A is an application component that can perform long-running operations in the background. It does not provide a user interface. Once started, a service might continue running for some time, even after the user switches to another application. Additionally, a component can bind to a service to interact with it and even perform interprocess communication (IPC). For example, a service can handle network transactions, play music, perform file I/O, or interact with a content provider, all from the background.\n\nCaution: A service runs in the main thread of its hosting process; the service does not create its own thread and does not run in a separate process unless you specify otherwise. You should run any blocking operations on a separate thread within the service to avoid Application Not Responding (ANR) errors.\n\nThese are the three different types of services:\n\nAlthough this documentation generally discusses started and bound services separately, your service can work both ways—it can be started (to run indefinitely) and also allow binding. It's simply a matter of whether you implement a couple of callback methods: to allow components to start it and to allow binding.\n\nRegardless of whether your service is started, bound, or both, any application component can use the service (even from a separate application) in the same way that any component can use an activity—by starting it with an . However, you can declare the service as private in the manifest file and block access from other applications. This is discussed more in the section about Declaring the service in the manifest.\n\nA service is simply a component that can run in the background, even when the user is not interacting with your application, so you should create a service only if that is what you need.\n\nIf you must perform work outside of your main thread, but only while the user is interacting with your application, you should instead create a new thread in the context of another application component. For example, if you want to play some music, but only while your activity is running, you might create a thread in , start running it in , and stop it in . Also consider using thread pools and executors from the package or Kotlin coroutines instead of the traditional class. See the Threading on Android document for more information about moving execution to background threads.\n\nRemember that if you do use a service, it still runs in your application's main thread by default, so you should still create a new thread within the service if it performs intensive or blocking operations.\n\nTo create a service, you must create a subclass of or use one of its existing subclasses. In your implementation, you must override some callback methods that handle key aspects of the service lifecycle and provide a mechanism that allows the components to bind to the service, if appropriate. These are the most important callback methods that you should override:\n\nIf a component starts the service by calling (which results in a call to ), the service continues to run until it stops itself with or another component stops it by calling .\n\nIf a component calls to create the service and is not called, the service runs only as long as the component is bound to it. After the service is unbound from all of its clients, the system destroys it.\n\nThe Android system stops a service only when memory is low and it must recover system resources for the activity that has user focus. If the service is bound to an activity that has user focus, it's less likely to be killed; if the service is declared to run in the foreground, it's rarely killed. If the service is started and is long-running, the system lowers its position in the list of background tasks over time, and the service becomes highly susceptible to killing—if your service is started, you must design it to gracefully handle restarts by the system. If the system kills your service, it restarts it as soon as resources become available, but this also depends on the value that you return from . For more information about when the system might destroy a service, see the Processes and Threading document.\n\nIn the following sections, you'll see how you can create the and service methods, as well as how to use them from other application components.\n\nYou must declare all services in your application's manifest file, just as you do for activities and other components.\n\nTo declare your service, add a element as a child of the element. Here is an example:\n\nSee the element reference for more information about declaring your service in the manifest.\n\nThere are other attributes that you can include in the element to define properties such as the permissions that are required to start the service and the process in which the service should run. The attribute is the only required attribute—it specifies the class name of the service. After you publish your application, leave this name unchanged to avoid the risk of breaking code due to dependence on explicit intents to start or bind the service (read the blog post, Things That Cannot Change).\n\nCaution: To ensure that your app is secure, always use an explicit intent when starting a and don't declare intent filters for your services. Using an implicit intent to start a service is a security hazard because you cannot be certain of the service that responds to the intent, and the user cannot see which service starts. Beginning with Android 5.0 (API level 21), the system throws an exception if you call with an implicit intent.\n\nYou can ensure that your service is available to only your app by including the attribute and setting it to . This effectively stops other apps from starting your service, even when using an explicit intent.\n\nNote: Users can see what services are running on their device. If they see a service that they don't recognize or trust, they can stop the service. In order to avoid having your service stopped accidentally by users, you need to add the attribute to the element in your app manifest. In the description, provide a short sentence explaining what the service does and what benefits it provides.\n\nA started service is one that another component starts by calling , which results in a call to the service's method.\n\nWhen a service is started, it has a lifecycle that's independent of the component that started it. The service can run in the background indefinitely, even if the component that started it is destroyed. As such, the service should stop itself when its job is complete by calling , or another component can stop it by calling .\n\nAn application component such as an activity can start the service by calling and passing an that specifies the service and includes any data for the service to use. The service receives this in the method.\n\nFor instance, suppose an activity needs to save some data to an online database. The activity can start a companion service and deliver it the data to save by passing an intent to . The service receives the intent in , connects to the Internet, and performs the database transaction. When the transaction is complete, the service stops itself and is destroyed.\n\nCaution: A service runs in the same process as the application in which it is declared and in the main thread of that application by default. If your service performs intensive or blocking operations while the user interacts with an activity from the same application, the service slows down activity performance. To avoid impacting application performance, start a new thread inside the service.\n\nThe class is the base class for all services. When you extend this class, it's important to create a new thread in which the service can complete all of its work; the service uses your application's main thread by default, which can slow the performance of any activity that your application is running.\n\nThe Android framework also provides the subclass of that uses a worker thread to handle all of the start requests, one at a time. Using this class is not recommended for new apps as it will not work well starting with Android 8 Oreo, due to the introduction of Background execution limits. Moreover, it's deprecated starting with Android 11. You can use JobIntentService as a replacement for that is compatible with newer versions of Android.\n\nThe following sections describe how you can implement your own custom service, however you should strongly consider using WorkManager instead for most use cases. Consult the guide to background processing on Android to see if there is a solution that fits your needs.\n\nYou can extend the class to handle each incoming intent. Here's how a basic implementation might look:\n\nThe example code handles all incoming calls in and posts the work to a running on a background thread. It works just like an and processes all requests serially, one after another. You could change the code to run the work on a thread pool, for example, if you'd like to run multiple requests simultaneously.\n\nNotice that the method must return an integer. The integer is a value that describes how the system should continue the service in the event that the system kills it. The return value from must be one of the following constants:\n\nFor more details about these return values, see the linked reference documentation for each constant.\n\nYou can start a service from an activity or other application component by passing an to or . The Android system calls the service's method and passes it the , which specifies which service to start.\n\nNote: If your app targets API level 26 or higher, the system imposes restrictions on using or creating background services unless the app itself is in the foreground. If an app needs to create a foreground service, the app should call . That method creates a background service, but the method signals to the system that the service will promote itself to the foreground. Once the service has been created, the service must call its method within five seconds.\n\nFor example, an activity can start the example service in the previous section ( ) using an explicit intent with , as shown here:\n\nThe method returns immediately, and the Android system calls the service's method. If the service isn't already running, the system first calls , and then it calls .\n\nIf the service doesn't also provide binding, the intent that is delivered with is the only mode of communication between the application component and the service. However, if you want the service to send a result back, the client that starts the service can create a for a broadcast (with ) and deliver it to the service in the that starts the service. The service can then use the broadcast to deliver a result.\n\nMultiple requests to start the service result in multiple corresponding calls to the service's . However, only one request to stop the service (with or ) is required to stop it.\n\nA started service must manage its own lifecycle. That is, the system doesn't stop or destroy the service unless it must recover system memory and the service continues to run after returns. The service must stop itself by calling , or another component can stop it by calling .\n\nOnce requested to stop with or , the system destroys the service as soon as possible.\n\nIf your service handles multiple requests to concurrently, you shouldn't stop the service when you're done processing a start request, as you might have received a new start request (stopping at the end of the first request would terminate the second one). To avoid this problem, you can use to ensure that your request to stop the service is always based on the most recent start request. That is, when you call , you pass the ID of the start request (the delivered to ) to which your stop request corresponds. Then, if the service receives a new start request before you are able to call , the ID doesn't match and the service doesn't stop.\n\nCaution: To avoid wasting system resources and consuming battery power, ensure that your application stops its services when it's done working. If necessary, other components can stop the service by calling . Even if you enable binding for the service, you must always stop the service yourself if it ever receives a call to .\n\nFor more information about the lifecycle of a service, see the section below about Managing the Lifecycle of a Service.\n\nA bound service is one that allows application components to bind to it by calling to create a long-standing connection. It generally doesn't allow components to start it by calling .\n\nCreate a bound service when you want to interact with the service from activities and other components in your application or to expose some of your application's functionality to other applications through interprocess communication (IPC).\n\nTo create a bound service, implement the callback method to return an that defines the interface for communication with the service. Other application components can then call to retrieve the interface and begin calling methods on the service. The service lives only to serve the application component that is bound to it, so when there are no components bound to the service, the system destroys it. You do not need to stop a bound service in the same way that you must when the service is started through .\n\nTo create a bound service, you must define the interface that specifies how a client can communicate with the service. This interface between the service and a client must be an implementation of and is what your service must return from the callback method. After the client receives the , it can begin interacting with the service through that interface.\n\nMultiple clients can bind to the service simultaneously. When a client is done interacting with the service, it calls to unbind. When there are no clients bound to the service, the system destroys the service.\n\nThere are multiple ways to implement a bound service, and the implementation is more complicated than a started service. For these reasons, the bound service discussion appears in a separate document about Bound Services.\n\nWhen a service is running, it can notify the user of events using snackbar notifications or status bar notifications.\n\nA snackbar notification is a message that appears on the surface of the current window for only a moment before disappearing. A status bar notification provides an icon in the status bar with a message, which the user can select in order to take an action (such as start an activity).\n\nUsually, a status bar notification is the best technique to use when background work such as a file download has completed, and the user can now act on it. When the user selects the notification from the expanded view, the notification can start an activity (such as to display the downloaded file).\n\nThe lifecycle of a service is much simpler than that of an activity. However, it's even more important that you pay close attention to how your service is created and destroyed because a service can run in the background without the user being aware.\n\nThe service lifecycle—from when it's created to when it's destroyed—can follow either of these two paths:\n• A started service The service is created when another component calls . The service then runs indefinitely and must stop itself by calling . Another component can also stop the service by calling . When the service is stopped, the system destroys it.\n• A bound service The service is created when another component (a client) calls . The client then communicates with the service through an interface. The client can close the connection by calling . Multiple clients can bind to the same service and when all of them unbind, the system destroys the service. The service does not need to stop itself.\n\nThese two paths aren't entirely separate. You can bind to a service that is already started with . For example, you can start a background music service by calling with an that identifies the music to play. Later, possibly when the user wants to exercise some control over the player or get information about the current song, an activity can bind to the service by calling . In cases such as this, or doesn't actually stop the service until all of the clients unbind.\n\nLike an activity, a service has lifecycle callback methods that you can implement to monitor changes in the service's state and perform work at the appropriate times. The following skeleton service demonstrates each of the lifecycle methods:\n\nNote: Unlike the activity lifecycle callback methods, you are not required to call the superclass implementation of these callback methods.\n\nFigure 2. The service lifecycle. The diagram on the left shows the lifecycle when the service is created with and the diagram on the right shows the lifecycle when the service is created with .\n\nFigure 2 illustrates the typical callback methods for a service. Although the figure separates services that are created by from those created by , keep in mind that any service, no matter how it's started, can potentially allow clients to bind to it. A service that was initially started with (by a client calling ) can still receive a call to (when a client calls ).\n\nBy implementing these methods, you can monitor these two nested loops of the service's lifecycle:\n• The entire lifetime of a service occurs between the time that is called and the time that returns. Like an activity, a service does its initial setup in and releases all remaining resources in . For example, a music playback service can create the thread where the music is played in , and then it can stop the thread in . Note: The and methods are called for all services, whether they're created by or .\n• The active lifetime of a service begins with a call to either or . Each method is handed the that was passed to either or . If the service is started, the active lifetime ends at the same time that the entire lifetime ends (the service is still active even after returns). If the service is bound, the active lifetime ends when returns.\n\nNote: Although a started service is stopped by a call to either or , there isn't a respective callback for the service (there's no callback). Unless the service is bound to a client, the system destroys it when the service is stopped— is the only callback received.\n\nFor more information about creating a service that provides binding, see the Bound Services document, which includes more information about the callback method in the section about Managing the lifecycle of a bound service."
    },
    {
        "link": "https://medium.com/@fierydinesh/understanding-service-and-intentservice-in-android-with-kotlin-cea76512ec16",
        "document": "A Service is an Android component that runs in the background without a user interface. It allows you to perform long-running tasks, such as network operations, database operations, and audio playback, even when the user switches to another app. Services are primarily used to handle tasks that do not require a user interface but should continue to run beyond the lifecycle of the hosting activity.\n\nA Service can be started and stopped using the and methods, respectively. Once started, a Service continues to run until explicitly stopped or until it completes its task.\n\nWhen to use a Service:\n• Downloading or uploading data from the internet.\n\nCreating a Service in Kotlin:\n\nTo create a Service in Android using Kotlin, follow these steps:\n\nStep 1: Create a new Kotlin class that extends the `Service` class.\n\nStep 2: Override the `onCreate()` method to initialize the service.\n\nStep 3: Implement the `onStartCommand()` method, where you define the background task that the service should perform.\n\nHere’s a brief explanation of the different return values from :\n• : The system will try to recreate the Service and call with a null intent if the Service was killed due to resource constraints.\n• : The system will not try to recreate the Service, and the Service will remain stopped until an explicit start command is sent.\n• : The system will try to recreate the Service and redeliver the last intent that was passed to the Service through if the Service was killed before it finished processing the intent.\n\nAn IntentService is a subclass of Service that provides a simplified way to handle asynchronous operations in the background. It handles each intent on a worker thread and stops itself automatically when the work is done.\n• Sequential processing of Intents: Intents are queued and processed one by one, avoiding concurrent execution of tasks.\n• Automatic termination: IntentService stops itself automatically when all the Intents are processed, which makes it convenient for one-off tasks.\n• Simplicity: IntentService handles thread management and execution flow, allowing developers to focus on the task implementation.\n\nWhen to use an IntentService:\n\nCreating an IntentService in Kotlin:\n\nTo create an IntentService in Android using Kotlin, follow these steps:\n\nStep 1: Create a new Kotlin class that extends the `IntentService` class.\n\nStep 2: Override the `onHandleIntent()` method, where you define the background task that the service should perform for each incoming intent.\n\nUsing the Service and IntentService: Once you’ve created your Service and IntentService classes, you need to register them in the AndroidManifest.xml file:\n\nTo start the Service or IntentService from an activity or any other component:\n\nConclusion:\n\nIn this blog, we explored two types of services in Android: Service and IntentService. While Service is suitable for long-running tasks that need to be explicitly stopped, IntentService is useful for executing short-lived background operations that automatically stop once their work is done. Understanding when to use each type of service is essential for building efficient and responsive Android applications."
    },
    {
        "link": "https://developer.android.com/develop/background-work/background-tasks/persistent/how-to/long-running",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nWorkManager has built-in support for long running workers. In such cases, WorkManager can provide a signal to the OS that the process should be kept alive if possible while this work is executing. These Workers can run longer than 10 minutes. Example use-cases for this new feature include bulk uploads or downloads (that cannot be chunked), crunching on an ML model locally, or a task that's important to the user of the app.\n\nUnder the hood, WorkManager manages and runs a foreground service on your behalf to execute the , while also showing a configurable notification.\n\nnow supports the API, and supports a suspending API. These APIs allow developers to specify that this is important (from a user perspective) or long-running.\n\nStarting with , WorkManager also allows you to create a , which can be used to cancel workers without having to register a new Android component using the API. This approach is especially useful when used with the or APIs, which can be used to add a notification action to cancel the .\n\nYou'll use a slightly different approach depending on whether you are coding in Kotlin or Java.\n\nKotlin developers should use . Instead of using , you can use the suspending version of that method, .\n\nDevelopers using a or a can call the API, which returns a . You can also call to update an ongoing .\n\nHere is a simple example of a long running worker that downloads a file. This Worker keeps track of progress to update an ongoing which shows the download progress.\n\nIf your app targets Android 14 (API level 34) or higher you must specify a foreground service type for all long-running workers. If your app targets Android 10 (API level 29) or higher and contains a long-running worker that requires access to location, indicate that the worker uses a foreground service type of .\n\nIf your app targets Android 11 (API level 30) or higher and contains a long-running worker that requires access to camera or microphone, declare the or foreground service types, respectively.\n\nTo add these foreground service types, complete the steps described in the following sections.\n\nDeclare the worker's foreground service type in your app's manifest. In the following example, the worker requires access to location and microphone:\n\nWhen you call or , ensure you specify a foreground service type."
    }
]