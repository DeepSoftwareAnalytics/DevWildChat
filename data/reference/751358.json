[
    {
        "link": "https://poi.apache.org",
        "document": "The Apache POI team is pleased to announce the release of 5.4.0. Several dependencies were updated to their latest versions to pick up security fixes and other improvements.\n\nA summary of changes is available in the Release Notes. A full list of changes is available in the change log. People interested should also follow the dev list to track progress.\n\nSee the downloads page for more details.\n\nWhile testing a potential Apache POI 5.4.0 release, we discovered a serious bug in log4j-api 2.24.1. This leads to NullPointerExceptions when you use a version of log4j-core that is not of the exact same version (2.24.1). We recommend that users avoid log4j 2.24.1 and use the latest 2.24.x version where this issue is fixed again.\n\nXMLBeans release 5.2.2 had the problematic log4j-api 2.24.1 dependency and thus can lead to such issues if used in some other context. In the meantime a version 5.3.0 of XmlBeans was released which avoids this issue.\n\nPlease direct any queries to the Log4j Team. The main issue is Issue 3143.\n\n4 March 2022 - CVE-2022-26336 - A carefully crafted TNEF file can cause an out of memory exception in Apache POI poi-scratchpad versions prior to 5.2.0\n\nDescription:\n\n A shortcoming in the HMEF package of poi-scratchpad (Apache POI) allows an attacker to cause an Out of Memory exception. This package is used to read TNEF files (Microsoft Outlook and Microsoft Exchange Server). If an application uses poi-scratchpad to parse TNEF files and the application allows untrusted users to supply them, then a carefully crafted file can cause an Out of Memory exception.\n\nMitigation:\n\n Affected users are advised to update to poi-scratchpad 5.2.1 or above which fixes this vulnerability. It is recommended that you use the same versions of all POI jars.\n\nThe Apache POI PMC has evaluated the security vulnerabilities reported for Apache Log4j.\n\nPOI 5.1.0 and XMLBeans 5.0.2 only have dependencies on log4j-api 2.14.1. The security vulnerabilities are not in log4j-api - they are in log4j-core.\n\nIf any POI or XMLBeans user uses log4j-core to control their logging of their application, we strongly recommend that they upgrade all their log4j dependencies to the latest version (currently v2.20.0) - including log4j-api.\n\nDescription:\n\n When parsing XML files using XMLBeans 2.6.0 or below, the underlying parser created by XMLBeans could be susceptible to XML External Entity (XXE) attacks.\n\nThis issue was fixed a few years ago but on review, we decided we should have a CVE to raise awareness of the issue.\n\nMitigation:\n\n Affected users are advised to update to Apache XMLBeans 3.0.0 or above which fixes this vulnerability. XMLBeans 4.0.0 or above is preferable.\n\nDescription:\n\n When using the tool XSSFExportToXml to convert user-provided Microsoft Excel documents, a specially crafted document can allow an attacker to read files from the local filesystem or from internal network resources via XML External Entity (XXE) Processing.\n\nMitigation:\n\n Apache POI 4.1.0 and before: users who do not use the tool XSSFExportToXml are not affected. Affected users are advised to update to Apache POI 4.1.1 which fixes this vulnerability.\n\nCredit: This issue was discovered by Artem Smotrakov from SAP\n\nThe Apache POI team is pleased to announce the release of XMLBeans 3.1.0. Featured are a handful of bug fixes.\n\nThe Apache POI project has unretired the XMLBeans codebase and is maintaining it as a sub-project, due to its importance in the poi-ooxml codebase.\n\nA summary of changes is available in the Release Notes. People interested should also follow the POI dev list to track progress.\n\nThe XMLBeans JIRA project has been reopened and feel free to open issues.\n\nWe did some work to verify that compilation with Java 11 is working and that all unit-tests pass.\n\nSee the details in the FAQ entry."
    },
    {
        "link": "https://poi.apache.org/components/spreadsheet/quick-guide.html",
        "document": "As of version 3.8, POI has slightly different syntax to work with data validations with .xls and .xlsx formats. Check the value a user enters into a cell against one or more predefined value(s). The following code will limit the value the user can enter into cell A1 to one of three integer values, 10, 20 or 30. This code will do the same but offer the user a drop down list to select a value from. To create a message box that will be shown to the user if the value they enter is invalid. Replace 'Box Title' with the text you wish to display in the message box's title bar and 'Message Text' with the text of your error message. To create a prompt that the user will see when the cell containing the data validation receives focus The text encapsulated in the first parameter passed to the createPromptBox() method will appear emboldened and as a title to the prompt whilst the second will be displayed as the text of the message. The createExplicitListConstraint() method can be passed and array of String(s) containing interger, floating point, dates or text values. To obtain a validation that would check the value entered was, for example, an integer between 10 and 100, use the DVConstraint.createNumericConstraint(int, int, String, String) factory method. Look at the javadoc for the other validation and operator types; also note that not all validation types are supported for this method. The values passed to the two String parameters can be formulas; the '=' symbol is used to denote a formula It is not possible to create a drop down list if the createNumericConstraint() method is called, the setSuppressDropDownArrow(false) method call will simply be ignored. Date and time constraints can be created by calling the createDateConstraint(int, String, String, String) or the createTimeConstraint(int, String, String). Both are very similar to the above and are explained in the javadoc. The contents of specific cells can be used to provide the values for the data validation and the DVConstraint.createFormulaListConstraint(String) method supports this. To specify that the values come from a contiguous range of cells do either of the following: and in both cases the user will be able to select from a drop down list containing the values from cells A1, A2 and A3. The data does not have to be as the data validation. To select the data from a different sheet however, the sheet must be given a name when created and that name should be used in the formula. So assuming the existence of a sheet named 'Data Sheet' this will work: Data validations work similarly when you are creating an xml based, SpreadsheetML, workbook file; but there are differences. Explicit casts are required, for example, in a few places as much of the support for data validations in the xssf stream was built into the unifying ss stream, of which more later. Other differences are noted with comments in the code. Check the value the user enters into a cell against one or more predefined value(s). // Here the boolean value false is passed to the setSuppressDropDownArrow() // method. In the hssf.usermodel examples above, the value passed to this // Note this extra method call. If this method call is omitted, or if the // boolean value false is passed, then Excel will not validate the value the This code will do the same but offer the user a drop down list to select a value from. Note that the call to the setSuppressDropDowmArrow() method can either be simply excluded or replaced with: These both exactly mirror the hssf.usermodel so please refer to the 'Messages On Error:' and 'Prompts:' sections above. To obtain a validation that would check the value entered was, for example, an integer between 10 and 100, use the XSSFDataValidationHelper(s) createNumericConstraint(int, int, String, String) factory method. The values passed to the final two String parameters can be formulas; the '=' symbol is used to denote a formula. Thus, the following would create a validation the allows values only if they fall between the results of summing two cell ranges It is not possible to create a drop down list if the createNumericConstraint() method is called, the setSuppressDropDownArrow(true) method call will simply be ignored. Please check the javadoc for other constraint types as examples for those will not be included here. There are, for example, methods defined on the XSSFDataValidationHelper class allowing you to create the following types of constraint; date, time, decimal, integer, numeric, formula, text length and custom constraints. One other type of constraint not mentioned above is the formula list constraint. It allows you to create a validation that takes it value(s) from a range of cells. This code would create a validation that took it's values from cells in the range A1 to F1. The usefulness of this technique can be extended if you use named ranges like this; OpenOffice Calc has slightly different rules with regard to the scope of names. Excel supports both Workbook and Sheet scope for a name but Calc does not, it seems only to support Sheet scope for a name. Thus it is often best to fully qualify the name for the region or area something like this; This does open a further, interesting opportunity however and that is to place all of the data for the validation(s) into named ranges of cells on a hidden sheet within the workbook. These ranges can then be explicitly identified in the setRefersToFormula() method argument. The classes within the ss.usermodel package allow developers to create code that can be used to generate both binary (.xls) and SpreadsheetML (.xlsx) workbooks. The techniques used to create data validations share much in common with the xssf.usermodel examples above. As a result just one or two examples will be presented here. Check the value the user enters into a cell against one or more predefined value(s). Workbook workbook = new XSSFWorkbook(); // or new HSSFWorkbook // Note the check on the actual type of the DataValidation object. // If it is an instance of the XSSFDataValidation class then the // boolean value 'false' must be passed to the setSuppressDropDownArrow() // method and an explicit call made to the setShowErrorBox() method. // If the Datavalidation contains an instance of the HSSFDataValidation // class then 'true' should be passed to the setSuppressDropDownArrow() // method and the call to setShowErrorBox() is not necessary. This code will do the same but offer the user a drop down list to select a value from. Workbook workbook = new XSSFWorkbook(); // or new HSSFWorkbook // Note the check on the actual type of the DataValidation object. // If it is an instance of the XSSFDataValidation class then the // boolean value 'false' must be passed to the setSuppressDropDownArrow() // method and an explicit call made to the setShowErrorBox() method. // If the Datavalidation contains an instance of the HSSFDataValidation // class then 'true' should be passed to the setSuppressDropDownArrow() // method and the call to setShowErrorBox() is not necessary. These both exactly mirror the hssf.usermodel so please refer to the 'Messages On Error:' and 'Prompts:' sections above. As the differences between the ss.usermodel and xssf.usermodel examples are small - restricted largely to the way the DataValidationHelper is obtained, the lack of any need to explicitly cast data types and the small difference in behaviour between the hssf and xssf interpretation of the setSuppressDropDowmArrow() method, no further examples will be included in this section. In some cases, it may be necessary to present to the user a sheet which contains more than one drop down list. Further, the choice the user makes in one drop down list may affect the options that are presented to them in the second or subsequent drop down lists. One technique that may be used to implement this behaviour will now be explained. There are two keys to the technique; one is to use named areas or regions of cells to hold the data for the drop down lists, the second is to use the INDIRECT() function to convert between the name and the actual addresses of the cells. In the example section there is a complete working example- called LinkedDropDownLists.java - that demonstrates how to create linked or dependent drop down lists. Only the more relevant points are explained here. To create two drop down lists where the options shown in the second depend upon the selection made in the first, begin by creating a named region of cells to hold all of the data for populating the first drop down list. Next, create a data validation that will look to this named area for its data, something like this; Note that the name of the area - in the example above it is 'CHOICES' - is simply passed to the createFormulaListConstraint() method. This is sufficient to cause Excel to populate the drop down list with data from that named region. Next, for each of the options the user could select in the first drop down list, create a matching named region of cells. The name of that region should match the text the user could select in the first drop down list. Note, in the example, all upper case letters are used in the names of the regions of cells. Now, very similar code can be used to create a second, linked, drop down list; The key here is in the following Excel function - INDIRECT(UPPER($A$1)) - which is used to populate the second, linked, drop down list. Working from the inner-most pair of brackets, it instructs Excel to look at the contents of cell A1, to convert what it reads there into upper case – as upper case letters are used in the names of each region - and then convert this name into the addresses of those cells that contain the data to populate another drop down list.\n\nUsing Excel, it is possible to hide a row on a worksheet by selecting that row (or rows), right clicking once on the right hand mouse button and selecting 'Hide' from the pop-up menu that appears. To emulate this using POI, simply call the setZeroHeight() method on an instance of either XSSFRow or HSSFRow (the method is defined on the ss.usermodel.Row interface that both classes implement), like this: Workbook workbook = new XSSFWorkbook(); // OR new HSSFWorkbook() If the file were saved away to disc now, then the first row on the first sheet would not be visible. Using Excel, it is possible to unhide previously hidden rows by selecting the row above and the row below the one that is hidden and then pressing and holding down the Ctrl key, the Shift and the pressing the number 9 before releasing them all. To emulate this behaviour using POI do something like this: If the file were saved away to disc now, any previously hidden rows on the first sheet of the workbook would now be visible. The example illustrates two features. Firstly, that it is possible to unhide a row simply by calling the setZeroHeight() method and passing the boolean value 'false'. Secondly, it illustrates how to test whether a row is hidden or not. Simply call the getZeroHeight() method and it will return 'true' if the row is hidden, 'false' otherwise.\n\nIn Excel, you can apply a set of borders on an entire workbook region at the press of a button. The PropertyTemplate object simulates this with methods and constants defined to allow drawing top, bottom, left, right, horizontal, vertical, inside, outside, or all borders around a range of cells. Additional methods allow for applying colors to the borders. It works like this: you create a PropertyTemplate object which is a container for the borders you wish to apply to a sheet. Then you add borders and colors to the PropertyTemplate, and finally apply it to whichever sheets you need that set of borders on. You can create multiple PropertyTemplate objects and apply them to a single sheet, or you can apply the same PropertyTemplate object to multiple sheets. It is just like a preprinted form. Defines the look of the border, is it thick or thin, solid or dashed, single or double. This enum replaces the CellStyle.BORDER_XXXXX constants which have been deprecated. The PropertyTemplate will not support the older style BORDER_XXXXX constants. A special value of BorderStyle.NONE will remove the border from a Cell once it is applied. Describes the portion of the region that the BorderStyle will apply to. For example, TOP, BOTTOM, INSIDE, or OUTSIDE. A special value of BorderExtent.NONE will remove the border from the PropertyTemplate. When the template is applied, no change will be made to a cell border where no border properties exist in the PropertyTemplate. // #1) these borders will all be medium in default color // #2) these cells will have medium outside borders and thin inside borders // #3) these cells will all be medium weight with different colors for the // outside, inside horizontal, and inside vertical borders. The center // cell will have no borders. NOTE: The last pt.drawBorders() call removes the borders from the range by using BorderStyle.NONE. Like setCellStyleProperties, the applyBorders method merges the properties of a cell style, so existing borders are changed only if they are replaced by something else, or removed only if they are replaced by BorderStyle.NONE. To remove a color from a border, use IndexedColor.AUTOMATIC.getIndex(). Additionally, to remove a border or color from the PropertyTemplate object, use BorderExtent.NONE. This does not work with diagonal borders yet."
    },
    {
        "link": "https://baeldung.com/java-microsoft-excel",
        "document": "In this tutorial, we’ll demonstrate the use of the Apache POI, JExcel, and Fastexcel APIs for working with Excel spreadsheets.\n\nThese libraries can be used to dynamically read, write and modify the content of an Excel spreadsheet and provide an effective way of integrating Microsoft Excel into a Java Application.\n\nTo begin, we will need to add the following dependencies to our pom.xml file:\n\nThe latest versions of poi, poi-ooxml, jxls-jexcel, fastexcel-reader, and fastexcel can be downloaded from Maven Central.\n\nThe Apache POI library supports both .xls and .xlsx files and is a more complex library than other Java libraries for working with Excel files.\n\nIt provides the Workbook interface for modeling an Excel file, and the Sheet, Row, and Cell interfaces that model the elements of an Excel file, as well as implementations of each interface for both file formats.\n\nWhen working with the newer .xlsx file format, we’d use the XSSFWorkbook, XSSFSheet, XSSFRow, and XSSFCell classes.\n\nTo work with the older .xls format, we use the HSSFWorkbook, HSSFSheet, HSSFRow, and HSSFCell classes.\n\nLet’s create a method that opens a .xlsx file and then reads content from the first sheet of the file.\n\nThe method for reading cell content varies depending on the type of data in the cell. The type of cell content can be determined using the getCellType() method of the Cell interface.\n\nFirst, let’s open the file from a given location:\n\nNext, let’s retrieve the first sheet of the file and iterate through each row:\n\nApache POI has different methods for reading each type of data. Let’s expand on the content of each switch case above.\n\nWhen the cell type enum value is STRING, the content will be read using the getRichStringCellValue() method of the Cell interface:\n\nCells having the NUMERIC content type can contain either a date or a number and are read in the following manner:\n\nFor BOOLEAN values, we have the getBooleanCellValue() method:\n\nAnd when the cell type is FORMULA, we can use the getCellFormula() method:\n\nApache POI uses the same interfaces presented in the previous section for writing to an Excel file and has better support for styling than JExcel.\n\nLet’s create a method that writes a list of persons to a sheet titled “Persons”.\n\nFirst, we will create and style a header row that contains “Name” and “Age” cells:\n\nNext, let’s write the content of the table in a different style:\n\nFinally, let’s write the content to a “temp.xlsx” file in the current directory and close the workbook:\n\nLet’s test the above methods in a JUnit test that writes content to the temp.xlsx file and then reads the same file to verify it contains the text we have written:\n\nThe JExcel library is a lightweight library with the advantage that it’s easier to use than Apache POI, but with the disadvantage that it only provides support for processing Excel files in the .xls (1997-2003) format.\n\nAt the moment, .xlsx files are not supported.\n\nIn order to work with Excel files, this library provides a series of classes that represent the different parts of an Excel file. The Workbook class represents the entire collection of sheets. The Sheet class represents a single sheet, and the Cell class represents a single cell of a spreadsheet.\n\nLet’s write a method that creates a workbook from a specified Excel file, gets the first sheet of the file, and then traverses its content and adds each row in a HashMap:\n\nFor writing to an Excel file, the JExcel library offers classes similar to the ones used above, which model a spreadsheet file: WritableWorkbook, WritableSheet, and WritableCell.\n\nThe WritableCell class has subclasses corresponding to the different types of content that can be written: Label, DateTime, Number, Boolean, Blank, and Formula.\n\nThis library also supports basic formatting, such as controlling font, color, and cell width.\n\nLet’s write a method that creates a workbook called “temp.xls” in the current directory and then writes the same content we wrote in the Apache POI section.\n\nNext, let’s create the first sheet and write the header of the Excel file, containing the “Name” and “Age” cells:\n\nWith a new style, let’s write the content of the table we’ve created:\n\nIt’s very important to remember to write to the file and close it at the end so it can be used by other processes, using the write() and close() methods of the Workbook class:\n\nFastexcel is an easy-to-use library with limited features and a lower memory footprint compared to Apache POI.\n\nIts multi-threaded support using CompletableFuture makes it a great alternative when working with large files that aren’t feature-extensive. At the moment, the library has only basic style support and doesn’t support graphs.\n\nLet’s write a method to access the Excel file and read the data from its first sheet. Let’s add the data to a Map of row indices as keys and a list of the content from that row as value:\n\nHere, we’re using cell.getRawValue() which returns the value of that cell as a String. Alternatively, based on CellType we can use the getCellAsBoolean(int cellIndex), getCellAsDate(int cellIndex), getCellAsString(int cellIndex) or getCellAsNumber(int cellIndex) methods from the Row class to read a cell’s content.\n\nUnlike the libraries mentioned above, Fastexcel uses different interfaces to write to an Excel file than the ones used to read Excel.\n\nWe’ll begin by creating a Workbook from an OutputStream. We’ll then write the “Name” and “Age” headers in the default first sheet and add style details to the cells. Next, let’s add another row with a person’s name and age:\n\nHere, we also see that the Row class in the fastexcel-reader library uses the variable rowNum with an offset of 1. Whereas, the value(int r, int c, Object value) method from the Worksheet class from the fastexcel library expects the row’s index with an offset of 0.\n\nIn this article, we saw how to use the Apache POI API, JExcel API, and Fastexcel API to read and write an Excel file from a Java program.\n\nWhen deciding on which library to use, we should consider the benefits and drawbacks of each library. For example, Apache POI is feature-rich and has support for graphs but has a high memory footprint. In contrast, Fastexcel has limited features but consumes less memory than Apache POI."
    },
    {
        "link": "https://javadoc.io/doc/org.apache.poi/poi/5.2.2/index.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/8202008/required-maven-dependencies-for-apache-poi-to-work",
        "document": "I want to use Apache POI library to parse excel files (old versions and newer versions of excel). So I was wondering what jars do i need to include from the Apache POI because in following link:\n\nI found lots of jars to be included, do I need to include them all?\n\nIf so, what is the latest stable version to be included, and does it work with Microsoft's Office 2010?"
    },
    {
        "link": "https://geeksforgeeks.org/reading-writing-data-excel-file-using-apache-poi",
        "document": "In Java, reading an Excel file is not similar to reading a Word file because of cells in an Excel file. JDK does not provide a direct API to read data from Excel files for which we have to toggle to a third-party library that is Apache POI. Apache POI is an open-source java library designed for reading and writing Microsoft documents in order to create and manipulate various file formats based on Microsoft Office. Using POI, one should be able to perform create, modify and display/read operations on the following file formats. \n\nFor Example, Java doesn’t provide built-in support for working with excel files, so we need to look for open-source APIs for the job. Apache POI provides Java API for manipulating various file formats based on the Office Open XML (OOXML) standard and OLE2 standard from Microsoft. Apache POI releases are available under the Apache License (V2.0).\n\nEarlier we introduced Apache POI- a Java API useful for interacting with Microsoft Office documents. Now we’ll see how can we read and write to an excel file using the API.\n\nProcedure: Writing a file using POI is very simple and involve the following steps:\n• Repeat steps 3 and 4 to write more data.\n\nProcedure: Reading an excel file is also very simple if we divide this into steps.\n• Get to the desired sheet\n• iterate over all cells in a row\n• repeat steps 3 and 4 until all data is read."
    },
    {
        "link": "https://stackoverflow.com/questions/26336274/exporting-to-excel-in-java-using-apache-poi",
        "document": "Your problem is the mis-match of these two lines\n\nIf you really want to generate a older-style Excel workbook, you need to change the first line to be rather than\n\nIf you do mean to generate a Excel workbook, then the content type on the second line needs to be the correct .xlsx one, which would be:"
    },
    {
        "link": "https://medium.com/@kaveeshapiumini1999/very-large-json-data-export-to-excel-with-apache-poi-a23ad2ac923f",
        "document": "Apache POI is a popular open-source Java library developed by the Apache Software Foundation that allows developers to work with Microsoft Office documents, such as Excel spreadsheets, Word documents, and PowerPoint presentations. POI stands for “Poor Obfuscation Implementation,” which humorously reflects its purpose of dealing with the complexities of Microsoft’s proprietary file formats.\n\nWith Apache POI, Java applications can create, read, and modify Office documents, making it a valuable tool for automating tasks involving data manipulation and reporting. It provides APIs for handling various aspects of Office documents, including data formatting, cell styling, data insertion, and extraction of data from spreadsheets.\n\nFor Excel, POI supports both older formats (.xls) and the newer XML-based formats (.xlsx). It allows developers to create new Excel workbooks, read existing ones, and write data to specific cells or ranges. POI also supports formulas, charts, and various Excel features. For Word documents, POI enables the creation of new Word files and the manipulation of existing ones, allowing the insertion of text, paragraphs, tables, and other content. It supports basic text formatting and document properties.\n\nApache POI provides three main workbooks for working with Excel files: HSSFWorkbook (Horrible Spreadsheet), XSSFWorkbook (XML Spreadsheet), and SXSSFWorkbook (Streaming Workbook). Following table compares properties, advantages, and limitations of them.\n\nDealing with very large data in Java\n\nSXSSFWorkbook in Apache POI is essential when dealing with very large Excel datasets in Java applications where memory constraints are a concern.\n\nUnlike XSSFWorkbook, which holds the entire workbook in memory, SXSSFWorkbook employs a streaming mechanism, allowing for the processing of large datasets row by row without loading the entire workbook into memory.\n\nThis feature becomes crucial when handling massive amounts of data, preventing excessive memory consumption and potential out-of-memory errors. Thus, SXSSFWorkbook is a practical choice for scenarios where scalability and efficient memory usage are paramount, making it a valuable tool for handling big data in Excel files.\n\nThis article presents the usage of Apache POI’s SXSSFWorkbook to export very large JSON data from a specified file to an Excel workbook. It dynamically generates a header row based on the JSON keys and efficiently creates data rows, demonstrating the streaming capabilities of SXSSFWorkbook for handling large datasets with limited memory. The resulting Excel workbook is saved as “output.xlsx” in the project directory.\n\nFirstly, you need to have the Apache POI library in your project. You can include it in your project using Maven by adding the following dependency to your pom.xml file.\n\nThe readJsonFile method reads the JSON data from the specified file. You need to specify your absolute file path in jsonFilePath\n\nSXSSFWorkbook is the Streaming Usermodel API for Excel in Apache POI.\n\nSXSSFWorkbook.DEFAULT_WINDOW_SIZE is used to set the window size, which determines how many rows are kept in memory at a time. The default window size is 100. This means that when the number of unflushed records reaches 101, the first row is flushed to disk, and so on. The SXSSFWorkbook instance is created with the specified window size.\n\nworkbook.createSheet() creates a new sheet within the SXSSFWorkbook.\n\nBy default, SXSSFWorkbook is configured for auto-flushing. This means that when the window size is reached, the oldest rows are automatically flushed to disk to free up memory.\n\nIn the above code, auto-flushing is in effect because the SXSSFWorkbook is created without specifying a window size (using SXSSFWorkbook.DEFAULT_WINDOW_SIZE).\n\nIf you want to control when and how data is flushed to disk, you can use manual flushing.\n\nTo manually flush rows, you can use the flushRows(int keepRows) method of SXSSFSheet. The keepRows parameter specifies the number of rows to keep in memory, and all other rows are flushed to disk.\n\nIf you want to manually flush rows, you would typically call flushRows() at specific points in your code based on your requirements.\n\nExample of Manual Flushing is as follows. Here, every 100th row is manually flushed to disk, retaining the last 100 rows in memory. This approach can be useful in scenarios where you want more fine-grained control over memory usage and flushing behavior.\n\nThe method createHeaderRow is to dynamically generate the header row based on the keys of the first JSONObject in the JSON array.\n\nIt creates a new row in the given sheet (starting at row index 0 as the header should be the first row in the sheet) and populates each cell with the keys extracted from the first JSONObject, effectively creating column headers in the Excel sheet. If the JSONArray is empty, implying no data, the method returns early.\n\nThe method addDataRows iterates through the JSON array and creates data rows in the Excel sheet for each JSONObject in the array.\n\nIt dynamically handles different data types, converting strings directly, extracting double values from numbers, and using the toString() method for other types, ensuring versatile data insertion into the Excel sheet.\n\nHere, closing the workbook and the output stream is a best practice and is crucial as it ensures proper resource release and file finalization for robust and reliable file export operations.\n\nThe completed JsonToExcelExporter class is as follows\n\nThis creates an output.xlsx file in the project directly. The final output with a sample json data exported to excel format is as follows.\n\nTo export data to Excel using Apache POI:\n• Create a new workbook object using the Workbook class from the POI library.\n• Create a new sheet within the workbook using the Sheet class.\n• Create rows and cells within the sheet to hold your data.\n• Save the workbook to a file or stream using the appropriate method, such as write or writeTo.\n\nMoreover, Apache POI, give control over various Excel features, such as formatting, formulas, styling, and more."
    },
    {
        "link": "https://stackoverflow.com/questions/24933868/exporting-resultset-from-java-database-to-excel-using-apache-poi",
        "document": "Help am stucked on this project of exporting from result set to excel..previous solutions here haven't answered my questions but they have helped..here is my code so far it only displays a row in the database. My Code"
    },
    {
        "link": "https://medium.com/@metehankozan/creating-excel-files-in-java-with-apache-poi-0378be215b44",
        "document": "Creating Excel files can be summarized into the following steps,\n• Repeat steps 3 and 4 to write more data.\n\nLet’s put these steps in action in the following examples.\n\nFor the first example I will skip over the 5th step and create a workbook with only a single data.\n\nAnd to see what it looks like save the Excel file with the following code snippet.\n\nHopefully without any errors you should now see an Excel file with the name excel.xlsx in your working directory and when opened up it should look something like this:\n\nI hope you got the gist of how to create Excel files in Java. Let’s bring the 5th step back into play and insert multiple data to multiple rows and cells in the Excel file.\n\n//create a workbook\n\nWorkbook workbook = new XSSFWorkbook();\n\n\n\n//create a sheet in the workbook\n\nSheet sheet = workbook.createSheet(\"excel-sheet\");\n\n\n\n//create the 0th row using the createRow() method\n\nRow row0 = sheet.createRow(0);\n\n//create cell by using the createCell() method\n\n//and set the values to the cell by using the setCellValue() method\n\nrow0.createCell(0).setCellValue(\"S.No.\");\n\nrow0.createCell(1).setCellValue(\"Customer Name\");\n\nrow0.createCell(2).setCellValue(\"Account Number\");\n\nrow0.createCell(3).setCellValue(\"e-mail\");\n\nrow0.createCell(4).setCellValue(\"Balance\");\n\n\n\n//create the 1st row\n\nRow row1 = sheet.createRow(1);\n\n//insert data in the first row\n\nrow1.createCell(0).setCellValue(1);\n\nrow1.createCell(1).setCellValue(\"John William\");\n\nrow1.createCell(2).setCellValue(9999999);\n\nrow1.createCell(3).setCellValue(\"william.john@gmail.com\");\n\nrow1.createCell(4).setCellValue(\"700000.00\");\n\n\n\n//create the 2nd row\n\nRow row2 = sheet.createRow(2);\n\n//insert data in the second row\n\nrow2.createCell(0).setCellValue(2);\n\nrow2.createCell(1).setCellValue(\"Mathew Parker\");\n\nrow2.createCell(2).setCellValue(22222222);\n\nrow2.createCell(3).setCellValue(\"parker.mathew@gmail.com\");\n\nrow2.createCell(4).setCellValue(\"200000.00\");\n\n\n\n//save the Excel file\n\ntry {\n\n FileOutputStream out = new FileOutputStream(\n\n new File(\"excel.xlsx\"));\n\n workbook.write(out);\n\n out.close();\n\n} catch (Exception e) {\n\n e.printStackTrace();\n\n}\n\nAnd this time the result should look something like this:\n\nAlthough these examples might have their own use cases, in real life these are not as effective and practical when you are working with LOTS of data. That’s where arrays, lists, and for loops come into play.\n\nLet’s have a list of employees’ data stored in an Object array. Each element in the array corresponds to a different attribute: name, employee ID, hire date, and salary. And then populate the Excel file using these data with a for loop.\n\nWhen populating the Excel cells, we cast the Object data to their respective types (String, int, double) before setting them in the cells.\n\nAnd the resulting Excel file should look like the following.\n\nIn this example we had 3 employees, but it wouldn’t much change even if there where thousands of them (considering you are getting your list of employees from a DB, etc.) thanks to the for loop. Maybe you might have to switch to SXSSF implementation if your Excel file gets too big though."
    }
]