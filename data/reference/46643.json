[
    {
        "link": "https://stackoverflow.com/questions/17779480/python-random-map-generation-with-perlin-noise",
        "document": "Recently, I've been attempting to defeat one of my main weaknesses in programming in general, random generation. I thought it would be an easy thing to do, but the lack of simple information is killing me on it. I don't want to sound dumb, but it feels to me like most of the information from places like this are written for mathematicians who went to college to graduate in theoretical mathematics. I just don't understand what I'm meant to do with that information in order to apply it to programming in a language such as python.\n\nI've been working a few days staring at equations and attempting attempt after attempt, but still after all those days, after ripping my code apart again and again, all that's been working properly this entire time is this noise generator to generate basic noise:\n\nI'm wanting it to eventually produce something like this:\n\nHow can I manage to smooth out the white-noise I generate, and turn it into islands? Can anyone explain it in a very simplistic way for me?\n\nI may be thinking about all of this very wrong."
    },
    {
        "link": "https://stackoverflow.com/questions/48964516/2d-noise-generation-in-python",
        "document": "For me, terrain generation is a multi-step process.\n\n( 1 ) Start out with primitive shapes like domes, which can be generated procedurally. Alternatively, You can also experiment with Voronoi plates and have levels rise where collisions happen. Also look into Perlin Noise.\n\n( 2a ) Simulate erosion using rainfall. Fluvial erosion can be simulated with spheres \"rolling\" down the slopes of your terrain. As a drop flows over a node, it takes a small chunk of land with it, reducing the height of the land.\n\nWhere the droplets go next is determined by the lowest negative change in elevation amongst your neighboring nodes or tiles. After each erosion round, or even drop, you can smooth the terrain so future drops will know where to drop.\n\nAs your drops roll down slopes, they will eventually need to find a stopping point. The most realistic and time-consuming method would be to find water flooding levels to make lakes and oceans. A faster method is to have the drops reduce in size over time and stop when they reach zero.\n\n( 2b ) Generate a water flow map for erosion. This is good for river generation. The basic idea is to find an edge point for flow-off. You can have multiple flow-off points, but you will have to process the river generation algorithm in parallel. The basic idea for the algorithm is\n\nYou can use the water volume map to decide an amount to erode (depth and radius of dirt dig). Alternatively, you could use it to pre-script drop flow 2a's algorithm. You would have to change the direction of the directed graph arcs though.\n\n( 3 ) After Erosion, you can apply light noise to the terrain for rockiness. I find additive blends of random circle radii to be a useful and fast method. You could also use Perlin noise with higher octaves than what you used for your base terrain. Just remember blurs will soften your slopes and noise will make things sharper.\n\nThis will give you a somewhat decent terrain. If you want to go further, you could look into lake generation and cliff generation. You would also have to decide if you want other features like craters, arches, mesas, and towers.\n\nFractal coastlines and rivers are also worth looking into. I would just get all of Mandelbrot's books and papers on the subject. There is a wealth of info on terrain generation from him, even though his work can be applied to a much greater scope of computer science, and mathematics."
    },
    {
        "link": "https://pypi.org/project/perlin-noise",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_noise.html",
        "document": "Inheriting noise classes can optionally override this function to provide a more optimal algorithm.\n\nA default get_seamless_image() implementation is provided for libraries that do not provide seamless noise. This function requests a larger image from the get_image() method, reverses the quadrants of the image, then uses the strips of extra width to blend over the seams.\n\nThis class defines the interface for noise generation libraries to inherit from.\n\nNote: With set to , the default implementation expects the noise generator to return values in the range to .\n\nReturns an Array of Images containing 3D noise values for use with ImageTexture3D.create().\n\nNote: With set to , the default implementation expects the noise generator to return values in the range to .\n\nReturns the 1D noise value at the given (x) coordinate.\n\nReturns the 2D noise value at the given position.\n\nReturns the 2D noise value at the given position.\n\nReturns the 3D noise value at the given position.\n\nReturns the 3D noise value at the given position.\n\nNote: With set to , the default implementation expects the noise generator to return values in the range to .\n\nReturns an Array of Images containing seamless 3D noise values for use with ImageTexture3D.create().\n\nNote: With set to , the default implementation expects the noise generator to return values in the range to ."
    },
    {
        "link": "http://py5coding.org/reference/sketch_noise.html",
        "document": "Generate pseudo-random noise values for specific coodinates using Processing’s noise algorithm. Noise functions are random sequence generators that produce a more natural, harmonic succession of numbers compared to the random() method.\n\nIn contrast to the random() method, noise is defined in an n-dimensional space, in which each coordinate corresponds to a fixed pseudo-random value (fixed only for the lifespan of the program). The noise value can be animated by moving through the noise space, as demonstrated in the examples. Any dimension can also be interpreted as time. An easy way to animate the noise value is to pass the method the frame_count divided by a scaling factor, as is done in a few of the examples.\n\nThe generated noise values for this method will typically be between 0 and 1, and can be generated in 1, 2, or 3 dimensions. Py5 also provides the os_noise() method, which generates noise using the OpenSimplex 2 algorithm (smooth version / SuperSimplex). That algorithm generates noise values between -1 and 1, and can be generated in 2, 3, or 4 dimensions. Be aware of both of these differences when modifying your code to switch from one to the other. There are other differences in the character of the noise values generated by both methods, so you’ll need to do some experimentation to get the results you want.\n\nThe actual noise structure is similar to that of an audio signal, in respect to the method’s use of frequencies. Similar to the concept of harmonics in physics, both noise algorithms are computed over several octaves which are added together for the final result.\n\nThe nature of the noise values returned can be adjusted with noise_seed() and noise_detail().\n\nAnother way to adjust the character of the resulting sequence is the scale of the input coordinates. As the method works within an infinite space, the value of the coordinates doesn’t matter as such; only the distance between successive coordinates is important. As a general rule, the smaller the difference between coordinates, the smoother the resulting noise sequence. Steps of 0.005-0.03 work best for most applications, but this will differ depending on the use case and the noise settings.\n\nPy5’s method can also accept numpy arrays as parameters. It will use broadcasting when needed and calculate the values efficiently. Using numpy array parameters will be much faster and efficient than calling the method repeatedly in a loop. See the examples to see how this can be done.\n\nNoise generation is a rich and complex topic, and there are many noise algorithms and libraries available that are worth learning about. Early versions of py5 used the Python “noise” library, which can generate noise using the “Improved Perlin Noise” algorithm (as described in Ken Perlin’s 2002 SIGGRAPH paper) and the Simplex Noise algorithm (also developed by Ken Perlin). That Python library was removed from py5 because it has some bugs and hasn’t had a release in years. Nevertheless, it might be useful to you, and can be installed separately like any other Python package. You can also try the Python library “vnoise”, which is a pure Python implementation of the Improved Perlin Noise algorithm. Note that py5 can also employ Java libraries, so consider “FastNoise Lite” to experiment with a large selection of noise algorithms with efficient implementations."
    },
    {
        "link": "https://stackoverflow.com/questions/17779480/python-random-map-generation-with-perlin-noise",
        "document": "Recently, I've been attempting to defeat one of my main weaknesses in programming in general, random generation. I thought it would be an easy thing to do, but the lack of simple information is killing me on it. I don't want to sound dumb, but it feels to me like most of the information from places like this are written for mathematicians who went to college to graduate in theoretical mathematics. I just don't understand what I'm meant to do with that information in order to apply it to programming in a language such as python.\n\nI've been working a few days staring at equations and attempting attempt after attempt, but still after all those days, after ripping my code apart again and again, all that's been working properly this entire time is this noise generator to generate basic noise:\n\nI'm wanting it to eventually produce something like this:\n\nHow can I manage to smooth out the white-noise I generate, and turn it into islands? Can anyone explain it in a very simplistic way for me?\n\nI may be thinking about all of this very wrong."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/166148/generating-different-maps-using-perlin-noise-with-a-seed",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/23178631/do-i-need-custom-random-number-generator-for-perlin-noise",
        "document": "The noise function used in Perlin noise is a seeded random number generator. That is, it must return the same value every time it is called with the same value for parameter, X. You can think of X as some position in space in a given dimension between the bounds of the region you're computing Perlin noise over.\n\nYou can use the Python random module if you can reset the state of the RNG based upon your given parameter so it always returns the same value for a given X.\n\nNote that Noise returned the same value when passing 1 in the first time, and the second. It also returned a different value when value other than 1 was input. The parameter to seed can be any hashable type in Python. For your purposes, any numeric type works.\n\nTypically when creating Perlin noise, many calls are made to this Noise function, so you'll want it to be fast. On my machine, it takes about 14 microseconds to execute the function above. That's only ~70000 calls per second. It may be that implementing the pseudocode for IntNoise may result in better performance. Infact, the following method:\n\nSeems to take on average about 1.6 microseconds per invocation, or about 10 times faster than the Noise above. Its range of return values is is (-1, 1), but that can be changed by modifying the last line. I can't speak to the uniformity of its distribution, however, a picture is worth a thousand words. Blue dots below are from IntNoise, and red dots are from the python random.uniform function.\n\nThe Noise function above can be used by the smooth noise algorithm in your question. The URL you linked in the question describes what the smoothing functions are for better than I could. After reading the paragraph, study the pictures of 1D and 2D smoothing next to it to better understand their purpose."
    },
    {
        "link": "https://reddit.com/r/roguelikedev/comments/127v72s/help_needed_with_perlin_noise_implementation_in",
        "document": "I need help with my code in implementing a simple Perlin noise generator in python for my game's terrain. The output map looks like it's biased along the rows. I think it looks quit wrong. Look below:\n\nAnd here's the mathutils helper script that you would need to run the above:\n\nWhere am I going wrong in the Perlin noise script?"
    },
    {
        "link": "https://rtouti.github.io/graphics/perlin-noise-algorithm",
        "document": "This article is my humble attempt to explain how the algorithm works and how to use it.\n\nIt took me quite some time to understand how the algorithm works and a lot of resources helped me along the way. This is my way to return the favor.\n\nPerlin noise is a popular procedural generation algorithm invented by Ken Perlin. It can be used to generate things like textures and terrain procedurally, meaning without them being manually made by an artist or designer. The algorithm can have 1 or more dimensions, which is basically the number of inputs it gets. In this article, I will use 2 dimensions because it’s easier to visualize than 3 dimensions. There is also a lot of confusion about what Perlin noise is and what it is not. It is often confused with value noise and simplex noise. There is basically 4 type of noise that are similar and that are often confused with one another : classic Perlin noise, improved Perlin noise, simplex noise, and value noise. Improved Perlin noise is an improved version of classic Perlin noise. Simplex noise is different but is also made by Ken Perlin. Value noise is also different. A rule of thumb is that if the noise algorithm uses a (pseudo-)random number generator, it’s probably value noise. This article is about improved Perlin noise.\n\nFirst, how to use it. The algorithm takes as input a certain number of floating point parameters (depending on the dimension) and return a value in a certain range (for Perlin noise, that range is generally said to be between -1.0 and +1.0 but it’s actually a bit different). Let’s say it is in 2 dimensions, so it takes 2 parameters: x and y. Now, x and y can be anything but they are generally a position. To generate a texture, x and y would be the coordinates of the pixels in the texture (multiplied by a small number called the frequency but we will see that at the end). So for texture generation, we would loop through every pixel in the texture, calling the Perlin noise function for each one and decide, based on the return value, what color that pixel would be.\n\nAn example implementation would look like this:\n\nThis code would result in an image like this:\n\nThe above code is in a C++-like language, where as all the rest of the code is in ES6 javascript.\n\nAlso, the code has been written for readability, not performance. It creates a lot of unnecessary temporary Vector2 objects. If you want to use Perlin noise for a real-world project, I recommend using a more standard (and faster) implementation, like Ken Perlin’s reference implementation. You could even use some noise functions that are implemented entirely on the GPU, which is generally much faster than a CPU implementation.\n\nAs you can see, each pixel don’t just have a random color, instead they follow a smooth transition from pixel to pixel and the texture don’t look random at the end. That is because Perlin noise (and other kinds of noise) has this property that if 2 inputs are near each other (e.g. (3.1, 2.5) and (3.11, 2.51)), the results of the noise function will be near each other too.\n\nSo, how does it work?\n\nI’ll give a quick explanation first and explain it in details later:\n\nThe inputs are considered to be on an integer grid (see Figure 2). Each floating point input lies within a square of this grid. For each of the 4 corners of that square, we generate a value. Then we interpolate between those 4 values and we have a final result. The difference between Perlin noise and value noise is how those 4 values are obtained. Where value noise uses a pseudo-random number generator, Perlin noise does a dot product between 2 vectors.\n\nThe first vector is the one pointing from the grid point (the corners) to the input point. The other vector is a constant vector assigned to each grid point (see Figure 3). That one must always be the same for the same grid point, but it can change if you change the seed of the algorithm (we’ll see how in a moment).\n\nAn implementation to get the first vector would look like this:\n\nGenerally, in Perlin noise implementations, the noise will “wrap” after every multiple of 256 (let’s call this number w), meaning it will repeat. That’s because, to give every grid point a constant vector, we’ll soon need something called a permutation table. It’s an array of size w containing all the integers between 0 and w-1 but shuffled (i.e. a permutation). The index for this array (the value between the square brackets [ ]) is X or Y (or a value near them) so it need to be less than 256. The noise “wraps” because if, for example, the input x is 256, X will be equal to 0. This 0 will be used to index the permutation table and then to generate a random vector. Since X is 0 at every multiple of 256, the random vector will be the same at all those points, so the noise repeats. You can if you want have a larger permutation table (say, of size 512) and in that case the noise would wrap at every multiple of 512.\n\nThe thing is, that’s just the technique used by Ken Perlin to get those constant vectors for each corner point. You can absolutely use another way, and you would maybe not have the limitation of the wrapping. You could for example use a pseudo random number generator to generate the constant vectors, but in this case you would probably fair better by just using value noise.\n\nWe first create the permutation table and shuffle it. I’ll show you the code and I’ll explain just after:\n\nAn example of a shuffle function is given in the complete code at the end of the article.\n\nNext, we need a value from that table for each of the corners. There is a restriction however: a corner must always get the same value, no matter which of the 4 grid cells that has it as a corner contains the input value. For example, if the top-right corner of the grid cell (0, 0) has a value of 42, then the top-left corner of grid cell (1, 0) must also have the same value of 42. It’s the same grid point, so same value no matter from which grid cell it’s calculated:\n\nThe way we selected the values for the corners in the code above respect this restriction. If we are in grid cell (0, 0), “valueBottomRight” will be equal to P[P[0+1]+0] = P[P[1]+0]. Whereas in the grid cell (1, 0), “valueBottomLeft” will be equal to P[P[1]+0]. “valueBottomRight” and “valueBottomLeft” are the same. The restriction is respected.\n\nWe also want to double the table for the noise to wrap at each multiple of 256. If we are computing P[X+1] and X is 255 (so X+1 is 256), we would get an overflow if we didn’t double the array because the max index of a size 256 array is 255. What is important is that we must not double the array and then shuffle it. Instead, we must shuffle it and then double it. In the example of P[X+1] where X is 255, we want P[X+1] to have the same value as P[0] so the noise can wrap.\n\nNow is the time to get those constant vectors. Ken Perlin’s original implementation used a strange function called “grad” that calculated the dot product for each corner directly. We are gonna make things simpler by creating a function that just returns the constant vector given a certain value from the permutation table and calculate the dot product later.\n\nAlso, since it’s easier to generate them, those constant vectors can be 1 of 4 different vectors: (1.0, 1.0), (1.0, -1.0), (-1.0, -1.0) and (-1.0, 1.0).\n\nTo find the constant vectors given a value from a permutation table, we can do something like that:\n\nSince v is between 0 and 255 and we have 4 possible vectors, we can do a & 3 (equivalent to % 4) to get 4 possible values of h (0, 1, 2 and 3). Depending of that value, we return one of the possible vectors.\n\nWe can now calculate the dot products:\n\nNow that we have to dot product for each corner, we need to somehow mix them to get a single value. For this, we’ll use interpolation. Interpolation is a way to find what value lies between 2 other values (say, a1 and a2), given some other value t between 0.0 and 1.0 (a percentage basically, where 0.0 is 0% and 1.0 is 100%). For example: if a1 is 10, a2 is 20 and t is 0.5 (so 50%), the interpolated value would be 15 because it’s midway between 10 and 20 (50% or 0.5). Another example: a1=50, a2=100 and t=0.4. Then the interpolated value would be at 40% of the way between 50 and 100, that is 70. This is called linear interpolation because the interpolated values are in a linear curve.\n\nNow we have 4 values that we need to interpolate but we can only interpolate 2 values at a time. So to way we use interpolation for Perlin noise is that we interpolate the values of top-left and bottom-left together to get a value we’ll call v1. After that we do the same for top-right and bottom-right to get v2. Then finally we interpolate between v1 and v2 to get a final value. This is the value we want our noise function to return.\n\nNote that if we change the input point just a little bit, the vectors between each corner and the input point will change just a little bit too, whereas the constant vector will not change at all. The dot products will also change just a little bit, and so will the final value return by the noise function. Even if the input changes grid square, like from (3.01, 2.01) to (2.99, 1.99), the final values will still be very close because even if 2 (or 3) of the corners change, the other 2 (or 1) would not and since with both inputs we are close to the corner(s), interpolation will cause the final value to be really close to that of the corner(s). Since with both inputs that corner will have the same value, the final results will be really close.\n\nHere is the code for a function that does linear interpolation (also called lerp):\n\nWe could use linear interpolation but that would not give great results because it would feel unnatural, like in this image that shows 1 dimensional linear interpolation :\n\n[Figure 4] The abrupt transition that results from linear interpolation\n\nAs you can see, the change between what is inferior to 1 and what is superior to 1 is abrupt. What we want is something smoother, like this:\n\n[Figure 5] The smooth transition that results from non-linear interpolation\n\n[Figure 6] The smooth transition between the corners of a grid square\n\nWith linear interpolation, we would use xf as an interpolation value (t). Instead we are going to transform xf and yf into u and v. We will do it in a way that, given a value of t between 0.0 and 0.5 (excluded), the transformed value will be something a little bit smaller (but capped at 0.0). Also, given a value of t between 0.5 (excluded) and 1.0, the transformed value would be a little larger (but capped at 1.0). For 0.5, the transformed value should be 0.5. Doing this will result in a curvy transition, like in figures 5 and 6.\n\nTo do this, we need something called an ease curve: it’s just a mathematical curve that looks like this:\n\nIf you look closely, you can see that for an input (xf or yf, the x axis) between 0.0 and 0.5, the output (u or v, the y axis) is a little bit closer to 0.0. And for a value between 0.5 and 1.0, the output is a little bit closer to 1.0. For x=0.5, y=0.5. That will do the work perfectly.\n\nThe curve above is the ease function used by Ken Perlin in his implementation of Perlin Noise. The equation is 6t5-15t4+10t3. This is also called a fade function. In code, it looks like that:\n\nNow, we just have to do linear interpolation the way we said before, but with u and v as interpolation values (t). Here is the code:\n\nIf you run the code and try to generate something like a texture, giving to the Noise function the coordinates of it’s pixels, you will probably get a completely black texture.\n\nWhen all the input to the algorithm are integers, say (5,3), the vector from the grid point (5,3) to the input will be the vector (0,0), because the input is also (5,3). The dot product for that grid point will be 0, and since the input lies exactly on that grid point, the interpolation will cause the result to be exactly that dot product, that is, 0. To solve this small issue, we generally multiply the inputs by a small value called the frequency.\n\nHere is an example of Perlin noise for generating a heightmap.\n\nFractal brownian motion is not part of the core Perlin noise algorithm, but it is (as far as I know) almost always used with it. It gives MUCH better results:\n\nSo how does it work?\n\nThe second image doesn’t look good because it is way too smooth, which make it unrealistic. Real life terrain is more noisy.\n\nSo to go from the second image to the first, we need to add some noise, and luckily for us, this is basically what FBM does.\n\nHere is what 1 dimensional Perlin noise might look like with the input x being a real number between 0 and 3, and with a frequency of 1 :\n\nIf we take another curve with an input x between 0 and 3 but use a frequency of 2, it will look like this :\n\nEven though the input is still between 0 and 3, the curve look a lot bumpier because multiplying the input by 2 made it effectively go from 0 to 6. What if we multiplied this curve by some value between 0 and 1 (let’s say 0.5) and added it to the first curve?\n\nWe would get this :\n\nIf we add another of these curves, also doubling the frequency and decreasing the multiplier (which is called the amplitude), we would get something like this :\n\nIf we keep doing this a few more times, we would get this :\n\nThis is exactly what we want. A curve with an overall smooth shape, but with a lot of smaller details. This look like a realistic chain of moutains. If you do this in 2d, it’s exactly how you get the heightmap from Figure 8.\n\nWe just added multiple “layers” of noise together, each with a different amplitude and frequency, and when one layer has a frequency that is double the frequency of the previous layer, this layer is called an octave. Though you will probably often see the term “octave” used more loosely for when the frequency is multiplied by a number other than 2.\n\nThe first octave constitute the overall shape of our chain of mountains. It has a small frequency (so there is not a million moutains) and an amplitude of 1. The second octave will add smaller (so we decrease the amplitude) more noisy details to the mountain range (so we increase the frequency). We can keep doing this - adding smaller and smaller details to the moutains - until we have our final (and beautiful) result.\n\nYou don’t have to worry about the final value exceeding the typical range of Perlin noise because even though we keep adding stuff, those stuff are not all positive, they can also be negative, so it balances out. Also, we keep decreasing the amplitude so we are adding smaller and smaller numbers, which diminishes the chances of overflowing the range. But still, it will happen sometimes.\n\nIn code, it would look something like this:\n\nThere you go. This is Perlin noise in a nutshell. You can use it to generate all kinds of things, from moutains ranges to heightmaps.\n\nHope you liked. Thanks for reading :)"
    }
]