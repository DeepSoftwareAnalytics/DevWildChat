[
    {
        "link": "https://geeksforgeeks.org/python-dictionary",
        "document": "A Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can’t be repeated and must be immutable.\n\nExample: Here, The data is stored in key:value pairs in dictionaries, which makes it easier to find values.\n\nIn Python, a dictionary can be created by placing a sequence of elements within curly {} braces, separated by a ‘comma’.\n• Dictionary keys are case sensitive: the same name but different cases of Key will be treated distinctly.\n• Keys must be immutable: This means keys can be strings, numbers, or tuples but not lists.\n• Keys must be unique: Duplicate keys are not allowed and any duplicate key will overwrite the previous value.\n• None . Hence, operations like search, insert, delete can be performed in Constant Time\n\nWe can access a value from a dictionary by using the key within square brackets orget()method.\n\nWe can add new key-value pairs or update existing keys by using assignment.\n\nWe can remove items from dictionary using the following methods:\n• None : Removes an item by key and returns its value.\n• None : Removes and returns the last key-value pair.\n\nWe can iterate over keys [using keys() method] , values [using values() method] or both [using item() method] with a for loop.\n\nRead in detail – Ways to Iterating Over a Dictionary\n• None Check if two arrays are equal or not\n• None Max distance between two occurrences in array\n• None Count all pairs with absolute difference equal to k\n• None Remove minimum elements such that no common elements exist in two arrays\n• None Count distinct elements in every window of size k\n\nHow to use dictionaries in Python?\n\nHow to print dictionaries in Python?\n\nHow to declare a dictionary in Python?\n\nWhat are dictionary keys and values in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/2466191/set-attributes-from-dictionary-in-python",
        "document": "Is it possible to create an object from a dictionary in python in such a way that each key is an attribute of that object?\n\nSomething like this:\n\nI think it would be pretty much the inverse of this question: Python dictionary from an object's fields"
    },
    {
        "link": "https://stackoverflow.com/questions/21619391/python-accessing-object-attributes-from-objects-stored-in-a-dictionary",
        "document": "I have a dictionary with objects being stored as values. How might I access and print the attributes of a particular object? For example,\n\nI want to print obj1.attribute. I have tried:\n\nto no avail. I cannot just access the object directly because I have not assigned it to a variable. This program automatically generates objects and places them in dict with an automatically generated key, which spares me manual assignment of an arbitrary amount of values. If anyone knows a better way to phrase this question, please go ahead. Thank you so much!\n\nEDIT: My dictionary's name is not 'dict', nor is my attribute named 'attribute.' These are used simply for clarity.\n\nEDIT: OK, here's what's going on. I'm using Tkinter to retrieve contact information through entry fields. I'm using that input to create an object with attributes name, address, etc. So,\n\nIs there a reason that \"dic[0].name\" would return an empty string?"
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://w3schools.com/python/python_dictionaries.asp",
        "document": "Dictionaries are used to store data values in key:value pairs.\n\nA dictionary is a collection which is ordered*, changeable and do not allow duplicates.\n\nDictionaries are written with curly brackets, and have keys and values:\n\nDictionary items are ordered, changeable, and do not allow duplicates.\n\nDictionary items are presented in key:value pairs, and can be referred to by using the key name.\n\nWhen we say that dictionaries are ordered, it means that the items have a defined order, and that order will not change.\n\nUnordered means that the items do not have a defined order, you cannot refer to an item by using an index.\n\nDictionaries are changeable, meaning that we can change, add or remove items after the dictionary has been created.\n\nDictionaries cannot have two items with the same key:\n\nTo determine how many items a dictionary has, use the function:\n\nThe values in dictionary items can be of any data type:\n\nFrom Python's perspective, dictionaries are defined as objects with the data type 'dict':\n\nIt is also possible to use the dict() constructor to make a dictionary.\n\nThere are four collection data types in the Python programming language:\n• List is a collection which is ordered and changeable. Allows duplicate members.\n• Tuple is a collection which is ordered and unchangeable. Allows duplicate members.\n• Set is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.\n• Dictionary is a collection which is ordered** and changeable. No duplicate members.\n\n*Set items are unchangeable, but you can remove and/or add items whenever you like. **As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.\n\nWhen choosing a collection type, it is useful to understand the properties of that type. Choosing the right type for a particular data set could mean retention of meaning, and, it could mean an increase in efficiency or security."
    },
    {
        "link": "https://stackoverflow.com/questions/9142050/what-is-the-python-best-practice-concerning-dicts-vs-objects-for-simple-key-valu",
        "document": "Well, the two approaches are closely related! When you do\n\nSimilarly, you can subclass to make return the same as and so will also work for your subclass.\n\nThe object approach is often convenient and useful when you know that the keys in your mapping will all be simple strings that are valid Python identifiers. If you have more complex keys, then you need a \"real\" mapping.\n\nYou should of course also use objects when you need more than a simple mapping. This \"more\" would normally be extra state or extra computations on the returned values.\n\nYou should also consider how others will use your objects. If they know it's a simple , then they also know that they can call etc. That's not so clear if you give them back an object. Basically: if you think they need to manipulate the keys and values of your like a normal , then you should probably make it a .\n\nAs for the most \"pythonic\" way to do this, then I can only say that I've seen libraries use both approaches:\n• None The BeautifulSoup library parses HTML and hands you back some very dynamic objects where both attribute and item access have special meanings. They could have chosen to give back objects instead, but there there is a lot of extra state associated with each object and so it makes perfect sense to use a real class.\n• None There are of course also lots of libraries that simply give back normal objects — they are the bread and butter of many Python programs."
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://stackoverflow.com/questions/2466191/set-attributes-from-dictionary-in-python",
        "document": "Is it possible to create an object from a dictionary in python in such a way that each key is an attribute of that object?\n\nSomething like this:\n\nI think it would be pretty much the inverse of this question: Python dictionary from an object's fields"
    },
    {
        "link": "https://medium.com/@dsjayamal/python-mapping-dictionary-to-class-attributes-1a3786f05fe5",
        "document": "When it comes to mapping dictionaries from external sources like MongoDB query results or API responses to class attributes, we often perform this task manually. However, manual mapping can be time consuming and may lead to runtime errors if the properties do not match correctly. Additionally over time this can make our codebase messy and harder to maintain.\n\nHere are some example codes for mapping dictionaries to classes. lets consider the following Python dictionary that needs to be mapped to a class\n\nUsing the namedtuple approach we can create an object from the dictionary and map the class properties. However the dictionary must contain all the properties defined in the namedtuple. Otherwise the interpreter will throw an error such as\n\nIf the dictionary contains additional values the interpreter will throw an error like\n\nIn this approach, you can access name and other properties as class attributes. However, the problem is that prior to class initialization, there are no attributes like name, and no default values are set for these properties. If the dictionary does not contain these keys, the properties will not be initialized at runtime. If we try to access these properties, the interpreter will throw an AttributeError, such as:\n\nWhile named tuples and the method offer some level of flexibility for handling structured data they come with significant limitations. Such as named tuples are immutable and lack methods, type checking, and default values, make them less suitable for complex data structures.\n\nUsing can lead to complex error handling and lack of type enforcement and reduced readability. To overcome these limitations we can create a custom class mapper.\n\nThe implimentation of custom class mapper have two main class components and .\n\nThe Type class is designed to serve as a metadata holder for class attributes in Python. It helps in defining aliases for dictionary keys and specifying default factory functions that process attribute values. This class is particularly useful when you need to map dictionary data to class attributes with additional processing or different key names.\n\nHere’s the implementation and an explanation of the class\n\nConstructor of the class initiate two attributes and .\n\nA string that specifies an alternative key name to be used when looking up values in the dictionary. If alias is provided, the value from the dictionary corresponding to this key will be assigned to the attribute.\n\nA callable (function) that processes the value before assigning it to the attribute. This is useful for custom transformations or formatting of the attribute value.\n\nThe class is intended to be used with a base class ( ) that handles the mapping of dictionary values to class attributes.\n\nThe ModelBase class is designed to map a dictionary (payload) to the attributes of a class that inherits from . It use the class to handle metadata for class attributes such as alias names and default factory functions.\n\nHere is the complete implementation of the ModelBase class\n\nfrom type import Type\n\n\n\nclass ModelBase:\n\n\n\n def __init__(self, payload):\n\n # Iterate over all annotated class attributes\n\n for key, _class in self.__annotations__.items():\n\n\n\n\n\n \n\n # Initialize default variables\n\n _attr_key_in_payload = key\n\n _attr_mapper = None\n\n\n\n # Check if the current attribute is an instance of Type\n\n if hasattr(self, key) and type(self.__getattribute__(key)) is Type:\n\n attr: Type = self.__getattribute__(key)\n\n\n\n # Use the alias if it is set\n\n if attr.alias:\n\n _attr_key_in_payload = attr.alias\n\n \n\n # Set the default factory if it is callable\n\n if attr.default_factory and callable(attr.default_factory):\n\n _attr_mapper = attr.default_factory\n\n\n\n # Try to set the attribute from the payload\n\n try:\n\n if _attr_key_in_payload in payload:\n\n # Check if the attribute is a List and process accordingly\n\n if vars(_class).get('_name') == 'List' and len(vars(_class).get('__args__')):\n\n # Map each element in the list to the appropriate class\n\n _list = [vars(_class).get('__args__')[0](e) for e in payload[_attr_key_in_payload]]\n\n self.__setattr__(key, _list)\n\n else:\n\n # Directly set the attribute\n\n self.__setattr__(key, _class(payload[_attr_key_in_payload]))\n\n\n\n # Apply the default factory if available\n\n if _attr_mapper:\n\n self.__setattr__(key, _attr_mapper(self.__getattribute__(key)))\n\n else:\n\n # Set attribute to None if not in payload\n\n self.__setattr__(key, None)\n\n except Exception as e:\n\n # Print error message and set attribute to None in case of failure\n\n print(f\"Error setting attribute {key}: {e}\")\n\n self.__setattr__(key, None)\n• This loop iterates over the class annotations (Attributes of the class). is the attribute name and is the type or class of the attribute.\n• is initially set to the attribute name. This variable will eventually hold the key name from the dictionary (payload).\n• is initialised as None. This will hold the default factory function if one is provided.\n\nThis block checks if the attribute has been defined with a Type instance.\n• IF the attribute is of type it retrieves the alias and default factory function.\n• IF an alias is provided is set to the alias.\n• IF a default factory function is provided and is callable is set to this function.\n• The block handles the assignment of dictionary values to class attributes.\n• If (the key in the dictionary) exists in payload, the code proceeds to assign the value to the attribute.\n• If the attribute type is a list the code maps each element in the list to the specified class.\n• For non-list attributes the value from the dictionary is assigned directly to the attribute.\n• If a default factory function ( ) is provided it processes the attribute value.\n• If the key does not exist in the dictionary the attribute is set to .\n• The block catches any exceptions that occur during the assignment and prints an error message, then sets the attribute to None.\n\nLets map our custom class mapping implimentation for our employee dictionary cenerio. first we will create a employee class with properties , , , , and\n• Attribute is given an alias . This means that when the dictionary is processed the value corresponding to the key will be assigned to the attribute.\n• Attribute is given an alias and a default factory function . This function processes the value to construct a full URL.\n\nWhen an instance of is created with , the constructor processes the dictionary. It assigns the values from the dictionary to the respective attributes using the alias and default factory function if provided.\n\nThe class provides a robust and flexible way to map dictionary data to class attributes including handling nested structures and custom value formatting. By using for metadata, you can streamline the process of initializing complex objects from dictionaries, reducing boilerplate code and improving maintainability.\n\npydantic is a Python library that helps with data validation and settings management by leveraging Python type annotations. It provides a robust way to define classes with type-checked fields, making it easier to handle data from external sources like APIs or databases. Using pydantic you can ensure that the data conforms to the expected types reducing runtime errors and improving code readability.\n\nDefine a pydantic model by creating a class that inherits from pydantic.BaseModel. Use type annotations to specify the expected types of the fields.\n\nAfter defining a Pydantic model, dictionary mapping can be done easily as shown below\n\nUsing the Pydantic module offers several benefits such as,\n• Ensures that the data conforms to the expected types catching errors early.\n• Converts input data to the specified types making it easier to work with data from various sources.\n• Validates the data ensuring that your models are always in a consistent state.\n• Reduces boilerplate code for validation and initialization making your codebase cleaner and more maintainable.\n\nFor each of the above-mentioned methods I ran the benchmarking up to 100,000 dictionary objects. The following results were achieved. Here n is the number of objects mapped using each method and the performance time is shown in seconds\n\nThe benchmark results offer a detailed comparison of four approaches Custom Class, Pydantic, Named Tuple, and Setattr. consistently shows superior performance with the fastest initialization times, making it ideal for straightforward and high-performance applications. also performs well, maintaining stable times across different dictionary sizes, but its fixed properties and immutability can restrict its suitability for dynamic data scenarios.\n\nIn contrast Pydantic despite longer initialization times excels in data validation and configuration management making it preferable for applications prioritizing data integrity. The Custom class implimentation while not as speedy as or it strikes a balance between performance and functionality. also the custom class implimentaiton allows for custom mappings, default values, and type enforcement, offering versatility for complex data structures.\n\nWhile Pydantic ensures robust validation, the Custom Class approach provides a more adaptable solution, balancing performance and flexibility. Therefore, the Custom Class method is well-suited for applications needing reliable performance and nuanced data handling capabilities.\n\nThe complete code for this article is available in here."
    },
    {
        "link": "https://toptal.com/python/python-class-attributes-an-overly-thorough-guide",
        "document": "Editor’s note: This article was updated on 11/29/22 by our editorial team. It has been modified to include recent sources and to align with our current editorial standards.\n\nI recently had a programming interview phone screen in which we used a collaborative text editor and it got me thinking about Python class attributes.\n\nI was asked to implement a certain API and chose to do so in Python. Abstracting away the problem statement, let’s say I needed a class whose instances stored some and some .\n\nI took a deep breath and started typing. After a few lines, I had something like this:\n• Me: “I’m pretty sure it is. It’s just setting a default value for the instance attribute.”\n• Interviewer: “When does that code get executed?”\n• Me: “I’m not really sure. I’ll just fix it up to avoid confusion.”\n\nFor reference, and to give you an idea of what I was going for, here’s how I amended the code:\n\nAs it turns out, we were both wrong. The real answer lay in understanding the distinction between Python class attributes and Python instance attributes.\n\nNote: If you have an expert handle on Python class attributes, you can skip ahead to use cases.\n\nMy interviewer was wrong in that the above code is syntactically valid.\n\nI was wrong in that the code isn’t setting a “default value” for the instance attribute. Instead, it’s defining as a class attribute with value .\n\nIn my experience, Python class attributes are a topic that many people know something about, but few understand completely.\n\nA Python class attribute is an attribute of the class (circular, I know), rather than an attribute of an instance of a class.\n\nLet’s use a Python class example to illustrate the difference. Here, is a class attribute, and is an instance attribute:\n\nNote that all instances of the class have access to , and that it can also be accessed as a property of the class itself:\n\nFor Java or C++ programmers, the class attribute is similar—but not identical—to the static member. We’ll see how they differ later.\n\nTo understand what’s happening here, let’s talk briefly about Python namespaces.\n\nA namespace is a mapping from names to objects, with the property that there is zero relation between names in different namespaces. They’re usually implemented as Python dictionaries, although this is abstracted away.\n\nDepending on the context, you may need to access a namespace using dot syntax (e.g., ) or as a local variable (e.g., ). As a concrete example:\n\nPython classes and instances of classes each have their own distinct namespaces represented by the pre-defined attributes and , respectively.\n\nWhen you try to access Python attributes from an instance of a class, it first looks at its instance namespace. If it finds the attribute, it returns the associated value. If not, it then looks in the class namespace and returns the attribute (if it’s present, otherwise throwing an error). For example:\n\nThe instance namespace takes precedence over the class namespace: If there is a Python attribute with the same name in both, the instance namespace will be checked first and its value returned. Here’s a simplified version of the code for attribute lookup:\n\nWith this in mind, we can make sense of how class attributes handle assignment:\n• If a class attribute is set by accessing the class, it will override the value for all instances. For example:\n\nAt the namespace level we’re setting . (Note: This isn’t the exact code which would be as returns a dictproxy, an immutable wrapper that prevents direct assignment, but it helps for demonstration’s sake). Then, when we access , has a new value in the class namespace and thus 2 is returned.\n• If a Python class variable is set by accessing an instance, it will override the value only for that instance. This essentially overrides the class variable and turns it into an instance variable available intuitively only for that instance. For example:\n\nAt the namespace level we’re adding the attribute to , so when we look up , we return 2. Meanwhile, other instances of will not have in their instance namespaces, so they continue to find in and thus return 1.\n\nWhat if your class attribute has a mutable type? You can manipulate the class attribute by accessing it through a particular instance and, in turn, end up manipulating the referenced object that all instances are accessing (as pointed out by Timothy Wiseman).\n\nLet’s go back to the I defined earlier and see how my use of a class variable could have led to problems down the road:\n\nMy goal was to have the empty list ( ) as the default value for , and for each instance of to have its own data that would be altered over time on an instance-by-instance basis. But in this case, we got the following behavior (note that is arbitrary in this example):\n\nThis is no good—altering our Python class variable via one instance alters it for all the others!\n\nAt the namespace level all instances of are accessing and modifying the same list in without making their own attributes in their instance namespaces.\n\nWe could get around this using assignment; that is, instead of exploiting the list’s mutability, we could assign our objects to have their own lists, as follows:\n\nIn this case, we’re adding , so the original remains unchanged.\n\nUnfortunately, this requires that users have intimate knowledge of its variables, and this workaround is certainly prone to mistakes. In a sense, we’d be addressing the symptoms rather than the cause. It’s preferable to have something that is correct by construction.\n\nMy personal solution: If you’re just using a class variable to assign a default value to a would-be Python instance variable, don’t use mutable values. In this case, every instance of was going to override with its own instance attribute eventually, so using an empty list as the default led to a tiny bug that was easily overlooked. Instead of the above, we could have either:\n• Stuck to instance attributes entirely, as demonstrated in the introduction.\n• Avoided using the empty list (a mutable value) as our “default.”\n\nOf course, we’d have to handle the case appropriately, but that’s a small price to pay.\n\nWhen Should You Use Python Class Attributes?\n\nClass attributes are tricky, but let’s look at a few cases where they would come in handy:\n• Storing constants. As class attributes can be accessed as attributes of the class itself, it’s often nice to use them for storing class-wide, class-specific constants. For example:\n• Defining default values. As a small example, we might create a bounded list (i.e., a list that can only hold a certain number of elements or fewer) and choose to have a default cap of 10 items: We could then create instances with their own specific limits too, by assigning them to the instance’s attribute. foo = MyClass() foo.limit = 50 ## foo can now hold 50 elements—other instances can hold 10 This only makes sense if you will want your typical instance of to hold just 10 elements or fewer—if you’re giving all of your instances different limits, then should be an instance variable. (Remember to be careful when using mutable values as your defaults.)\n• Tracking all data across all instances of a given class. This is sort of specific, but I could see a scenario in which you might want to access a piece of data related to every existing instance of a given class. To make the scenario more concrete, let’s say we have a class, and every person has a . We want to keep track of all the names that have been used. One approach might be to iterate over the garbage collector’s list of objects, but it’s simpler to use class variables. Note that, in this case, will only be accessed as a class variable, so the mutable value default is acceptable. We could even use this design pattern to track all existing instances of a given class, rather than just some associated data. class Person(object): all_people = [] def __init__(self, name): self.name = name Person.all_people.append(self) joe = Person('Joe') bob = Person('Bob') print Person.all_people ## [<__main__.Person object at 0x10e428c50>, <__main__.Person object at 0x10e428c90>]\n\nNote: If you’re worrying about performance at this level, you might not want to be use Python in the first place, as the differences will be on the order of tenths of a millisecond—but it’s still fun to poke around a bit and it helps for illustration’s sake.\n\nRecall that a class’s namespace is created and filled in at the time of the class’s definition. That means that we do just one assignment for a given class variable, while instance variables must be assigned every time a new instance is created.\n\nLet’s take an example:\n\nWe assign to just once, but on every call to .\n\nAs further evidence, let’s use the Python disassembler:\n\nWhen we look at the byte code, it’s again obvious that has to do two assignments, while does just one.\n\nIn practice, what does this gain really look like? I’ll be the first to admit that timing tests are highly dependent on often uncontrollable factors and the differences between them are often hard to explain accurately.\n\nHowever, I think these small snippets (run with the Python timeit module) help to illustrate the differences between class and instance variables, so I’ve included them anyway.\n\nNote: I’m on a MacBook Pro with OS X 10.8.5 and Python 2.7.2.\n\nThe initializations of are faster by over a second, so the difference here does appear to be statistically significant.\n\nSo why is this the case? One speculative explanation: We do two assignments in , but just one in .\n\nNote: There’s no way to re-run your setup code on each trial with timeit, so we have to reinitialize our variable on our trial. The second line of times represents the above times with the previously calculated initialization times deducted.\n\nFrom the above, it looks like only takes about 60% as long as to handle assignments.\n\nWhy is this the case? One speculative explanation: When we assign to , we first look in the instance namespace ( ), fail to find , and then look in the class namespace ( ), then make the proper assignment. When we assign to , we do half as many lookups, as we immediately assign to the instance namespace ( ).\n\nIn summary, though these performance gains won’t matter in reality, these tests are interesting at the conceptual level. If anything, I hope these differences help illustrate the mechanical distinctions between class and instance variables.\n\nClass attributes seem to be underused in Python; a lot of programmers have different impressions of how they work and why they might be helpful.\n\nMy take: Python class variables have their place within the school of good code. When used with care, they can simplify things and improve readability. But when carelessly thrown into a given class, they’re sure to trip you up.\n\nPython doesn’t have private variables so to speak, but another interesting relationship between class and instance naming comes with name mangling.\n\nIn the Python style guide, it’s said that pseudo-private variables should be prefixed with a double underscore: ‘__’. This is not only a sign to others that your variable is meant to be treated privately, but also a way to prevent access to it, of sorts. Here’s what I mean:\n\nLook at that: The instance attribute is automatically prefixed with the class name to yield .\n\nWhile still settable and gettable using , this name mangling is a means of creating a “private” variable as it prevents you and others from accessing it by accident or through ignorance.\n\nEdit: As Pedro Werneck kindly pointed out, this behavior is largely intended to help out with subclassing. In the PEP 8 style guide, they see it as serving two purposes: (1) preventing subclasses from accessing certain attributes, and (2) preventing namespace clashes in these subclasses. While useful, variable mangling shouldn’t be seen as an invitation to write code with an assumed public-private distinction, such as is present in Java."
    }
]