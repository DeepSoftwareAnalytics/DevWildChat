[
    {
        "link": "https://stackoverflow.com/questions/32001/resettable-java-timer",
        "document": "I'd like to have a java.utils.Timer with a resettable time in java.I need to set a once off event to occur in X seconds. If nothing happens in between the time the timer was created and X seconds, then the event occurs as normal.\n\nIf, however, before X seconds has elapsed, I decide that the event should occur after Y seconds instead, then I want to be able to tell the timer to reset its time so that the event occurs in Y seconds. E.g. the timer should be able to do something like:\n\nI don't see a way to do this using the utils timer, as if you call cancel() you cannot schedule it again.\n\nThe only way I've come close to replicating this behavior is by using javax.swing.Timer and involves stopping the origional timer, and creating a new one. i.e.:\n\nIs there an easier way??"
    },
    {
        "link": "https://stackoverflow.com/questions/53223320/how-do-i-reset-a-timer-in-java",
        "document": "So I'm trying to program a handheld electronic game, called Lights Out Cube, in Java using Eclipse Oxygen.2, and I decided to include a timer so that the player knows how much time was required by him to finish the game. When the player clicks on a button called \"Start/Reset\"(I change its text to \"Reset\" after clicking it once), which is where I activate the timer, the game starts. After every click I check if player has finished the game, and if he does, I stop the timer. If he wishes to play again, I want the timer to restart. Please help me out here:\n\nIs there anyway this can be done? Or will I have to remove the timer entirely?"
    },
    {
        "link": "https://ftc-docs.firstinspires.org/programming_resources/shared/myblocks/timer_example/timer-example.html",
        "document": "FTC timers offer much more capability than the familiar Block. Java programmers can learn about timers from this Blocks tutorial; you can easily apply its lessons to Java programs.\n\nWhen creating myBlocks, be careful when converting or ‘packaging’ a section of existing Java code into a myBlock method. As a programmer, you must consider where your myBlock might be placed in the OpMode. For example, if the myBlock is placed inside a repeat while loop, the Java method will be called many times – this may or may not be what you intended. Use the annotation comment to tell the Blocks user how your myBlock should be run, including looping (or not).\n\nA particular caution with timers: creating or instantiating a new FTC timer also starts or resets that timer. If a timer is created inside a myBlock that’s used in a Blocks repeat loop, that timer will constantly reset and never advance to the intended time limit.\n\nThe following example separates the create timer task from the reset timer task.\n\nLine 15: this single line of Java does all this: - declare a field called myStopwatch, of type (class) ElapsedTime - the field is private, can be used only in this class SampleMyBlocks - the field is static, can be used in static methods such as myBlocks - call the constructor method ElapsedTime() to instantiate a new ElapsedTime instance - assign that instance to the field myStopwatch\n\nLines 18-19 again show two strings of text (each in quotes), joined with a “+” character to form a single text string. This is an alternate way to meet the requirement that a comment field must be a single line of text, with no ‘line break’.\n\nLine 22: this method has no inputs (empty parentheses) and no outputs (keyword void). This is why the annotation @ExportToBlocks was missing the parameterLabels field.\n\nIn Line 24 the data is displayed using a formatting code, indicated by the percent sign. The .2f will display a numeric value with 2 digits to the right of the decimal point.\n\nAlso on Line 24, the object myStopwatch uses a method to retrieve that timer’s current value in seconds.\n\nLine 28: the double-strokes operator || means “OR”. Other operators include && (“AND”), == (“EQUALS”), and != (“NOT EQUAL TO”).\n\nLine 29: the object myStopwatch uses a method to start the timer again from zero.\n\nSo, what was the danger? A programmer might naturally place Line 15 inside the method, perhaps at Line 23. But that would reset the timer at every cycle of the repeat while loop. The stopwatch would always show zero.\n\nOr, a programmer might use Line 15 to replace Line 29, since they “do the same thing”. But the object myStopwatch is needed at Line 24 also, for telemetry. Moving the telemetry to be after Line 29 does not help. If the operator has not yet pressed gamepad button X, the object does not exist and the program will crash.\n\nWhen you clicked “Build Everything” in OnBot Java, all of the code in your SampleMyBlocks class was processed. That included creating the object myStopwatch, which became available for any method in that class. It was not necessary to declare it inside the myBlock method. In this case, it needed to be outside the method.\n\nHere’s the myBlock in a repeat loop, with its comment and tooltip:\n\nAgain, the comment field is the only way to communicate with future users of your myBlock. They cannot see your Java code or its Java comments. Keep your myBlocks interface simple, and the instructions clear."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-timer-timertask-example",
        "document": "Java java.util.Timer is a utility class that can be used to schedule a thread to be executed at certain time in future. Java Timer class can be used to schedule a task to be run one-time or to be run at regular intervals.\n\njava.util.TimerTask is an abstract class that implements Runnable interface and we need to extend this class to create our own TimerTask that can be scheduled using java Timer class.\n\nJava Timer class is thread safe and multiple threads can share a single Timer object without need for external synchronization. Timer class uses java.util.TaskQueue to add tasks at given regular interval and at any time there can be only one thread running the TimerTask, for example if you are creating a Timer to run every 10 seconds but single thread execution takes 20 seconds, then Timer object will keep adding tasks to the queue and as soon as one thread is finished, it will notify the queue and another thread will start executing. Java Timer class uses Object wait and notify methods to schedule the tasks. Here is a simple program for Java Timer and TimerTask example.\n\nNotice that one thread execution will take 20 seconds but Java Timer object is scheduled to run the task every 10 seconds. Here is the output of the program:\n\nThe output confirms that if a task is already executing, Timer will wait for it to finish and once finished, it will start again the next task from the queue. Java Timer object can be created to run the associated tasks as a daemon thread. Timer cancel() method is used to terminate the timer and discard any scheduled tasks, however it doesn’t interfere with the currently executing task and let it finish. If the timer is run as daemon thread, whether we cancel it or not, it will terminate as soon as all the user threads are finished executing. Timer class contains several schedule() methods to schedule a task to run once at given date or after some delay. There are several scheduleAtFixedRate() methods to run a task periodically with certain interval. While scheduling tasks using Timer, you should make sure that time interval is more than normal thread execution, otherwise tasks queue size will keep growing and eventually task will be executing always. That’s all for a quick roundup on Java Timer and Java TimerTask."
    },
    {
        "link": "https://quora.com/What-is-the-use-of-Timer-Class-in-Java",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://baeldung.com/java-timer-and-timertask",
        "document": "Timer and TimerTask are java util classes that we use to schedule tasks in a background thread. Basically, TimerTask is the task to perform, and Timer is the scheduler.\n\nLet’s start by simply running a single task with the help of a Timer:\n\nThis performs the task after a certain delay, which we gave as the second parameter of the schedule() method. In the next section, we’ll see how to schedule a task at a given date and time.\n\nNote that if we’re running this as a JUnit test, we should add a Thread.sleep(delay * 2) call to allow the Timer’s thread to run the task before the Junit test stops executing.\n\nNow let’s look at the Timer#schedule(TimerTask, Date) method, which takes a Date instead of a long as its second parameter. This allows us to schedule the task at a certain instant rather than after a delay.\n\nThis time, let’s imagine we have an old legacy database and want to migrate its data into a new database with a better schema.\n\nWe can create a DatabaseMigrationTask class that will handle this migration:\n\nFor simplicity, we represent the two databases by a List of Strings. Simply put, our migration consists of putting the data from the first list into the second.\n\nTo perform this migration at the desired instant, we’ll have to use the overloaded version of the schedule() method:\n\nAs we can see, we give the migration task and the date of execution to the schedule() method.\n\nThen the migration is executed at the time indicated by twoSecondsLater:\n\nBefore that moment, the migration doesn’t occur.\n\nNow that we’ve covered how to schedule the single execution of a task let’s see how to deal with repeatable tasks.\n\nOnce again, the Timer class offers multiple possibilities. We can set up the repetition to observe either a fixed delay or a fixed rate.\n\nA fixed delay means that the execution will start after a period of time after the moment the last execution started, even if it was delayed (therefore being itself delayed).\n\nLet’s say we want to schedule a task every two seconds, with the first execution taking one second and the second one taking two but being delayed by one second. Then the third execution starts at the fifth second:\n\nOn the other hand, a fixed rate means that each execution will respect the initial schedule, no matter if a previous execution has been delayed.\n\nLet’s reuse our previous example. With a fixed rate, the second task will start after three seconds (because of the delay), but the third one will start after four seconds (respecting the initial schedule of one execution every two seconds):\n\nNow that we’ve covered these two principles let’s see how we can use them.\n\nTo use fixed-delay scheduling, there are two more overloads of the schedule() method, each taking an extra parameter stating the periodicity in milliseconds.\n\nWhy two overloads? Because there’s still the possibility of starting the task at a certain moment or after a certain delay.\n\nAs for the fixed-rate scheduling, we have the two scheduleAtFixedRate() methods, which also take the periodicity in milliseconds. Again, we have one method to start the task at a given date and time and another to start it after a given delay.\n\nIt’s also worth mentioning that, if a task takes more time than the period to execute, it delays the whole chain of executions, whether we’re using fixed-delay or fixed-rate.\n\nNow let’s imagine we want to implement a newsletter system, sending an email to our followers every week. In this case, a repetitive task seems ideal.\n\nSo let’s schedule the newsletter every second, which is basically spamming, but we’re good to go as the sending is fake.\n\nEach time it executes, the task will print its scheduled time, which we gather using the TimerTask#scheduledExecutionTime() method.\n\nSo what if we want to schedule this task every second in fixed-delay mode? We’ll have to use the overloaded version of the schedule() that we mentioned earlier:\n\nOf course, we only carry the tests for a few occurrences:\n\nAs we can see, there is at least one second between each execution, but they’re sometimes delayed by a millisecond. This phenomenon is due to our decision to use fixed-delay repetition.\n\nNow, what if we were to use a fixed-rate repetition? Then we would have to use the scheduledAtFixedRate() method:\n\nThis time, executions aren’t delayed by the previous ones:\n\nThe execution of a task can be cancelled in a few ways.\n\nThe first option is to call the TimerTask.cancel() method inside the run() method’s implementation of the TimerTask itself:\n\nAnother option is to call the Timer.cancel() method on a Timer object:\n\n4.3. Stop the Thread of the TimerTask Inside Run\n\nWe can also stop the thread inside the run method of the task, thus cancelling the entire task:\n\nNotice the TODO instruction in the run implementation; in order to run this simple example, we’ll need to actually stop the thread.\n\nIn a real-world custom thread implementation, stopping the thread should be supported, but in this case, we can ignore the deprecation and use the simple stop API on the Thread class itself.\n\nWe can also make good use of an ExecutorService to schedule timer tasks, instead of using the timer.\n\nHere’s a quick example of how to run a repeated task at a specified interval:\n\nSo what are the main differences between the Timer and the ExecutorService solution:\n• Timer can be sensitive to changes in the system clock; ScheduledThreadPoolExecutor isn’t.\n• Timer has only one execution thread; ScheduledThreadPoolExecutor can be configured with any number of threads.\n• Runtime Exceptions thrown inside the TimerTask kill the thread, so the following scheduled tasks won’t run further; with ScheduledThreadExecutor, the current task will be cancelled, but the rest will continue to run.\n\nIn this article, we illustrated the many ways we can use the simple, yet flexible Timer and TimerTask infrastructure built into Java for quickly scheduling tasks. There are, of course, much more complex and complete solutions in the Java world if we need them, such as the Quartz library, but this is a very good place to start."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html",
        "document": "Cancels this timer task. If the task has been scheduled for one-time execution and has not yet run, or has not yet been scheduled, it will never run. If the task has been scheduled for repeated execution, it will never run again. (If the task is running when this call occurs, the task will run to completion, but will never run again.)\n\nNote that calling this method from within the method of a repeating timer task absolutely guarantees that the timer task will not run again.\n\nThis method may be called repeatedly; the second and subsequent calls have no effect."
    },
    {
        "link": "https://developer.ibm.com/articles/j-schedule",
        "document": ""
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-timer-timertask-example",
        "document": "Java java.util.Timer is a utility class that can be used to schedule a thread to be executed at certain time in future. Java Timer class can be used to schedule a task to be run one-time or to be run at regular intervals.\n\njava.util.TimerTask is an abstract class that implements Runnable interface and we need to extend this class to create our own TimerTask that can be scheduled using java Timer class.\n\nJava Timer class is thread safe and multiple threads can share a single Timer object without need for external synchronization. Timer class uses java.util.TaskQueue to add tasks at given regular interval and at any time there can be only one thread running the TimerTask, for example if you are creating a Timer to run every 10 seconds but single thread execution takes 20 seconds, then Timer object will keep adding tasks to the queue and as soon as one thread is finished, it will notify the queue and another thread will start executing. Java Timer class uses Object wait and notify methods to schedule the tasks. Here is a simple program for Java Timer and TimerTask example.\n\nNotice that one thread execution will take 20 seconds but Java Timer object is scheduled to run the task every 10 seconds. Here is the output of the program:\n\nThe output confirms that if a task is already executing, Timer will wait for it to finish and once finished, it will start again the next task from the queue. Java Timer object can be created to run the associated tasks as a daemon thread. Timer cancel() method is used to terminate the timer and discard any scheduled tasks, however it doesn’t interfere with the currently executing task and let it finish. If the timer is run as daemon thread, whether we cancel it or not, it will terminate as soon as all the user threads are finished executing. Timer class contains several schedule() methods to schedule a task to run once at given date or after some delay. There are several scheduleAtFixedRate() methods to run a task periodically with certain interval. While scheduling tasks using Timer, you should make sure that time interval is more than normal thread execution, otherwise tasks queue size will keep growing and eventually task will be executing always. That’s all for a quick roundup on Java Timer and Java TimerTask."
    },
    {
        "link": "https://stackoverflow.com/questions/7814089/how-to-schedule-a-periodic-task-in-java",
        "document": "You can also use JobRunr, an easy to use and open-source Java Scheduler.\n\nTo schedule a Job every 8 hours using JobRunr, you would use the following code:\n\nIf you are using Spring Boot, Micronaut or Quarkus, you can also use the annotation:\n\nJobRunr also comes with an embedded dashboard that allows you to follow-up on how your jobs are doing."
    }
]