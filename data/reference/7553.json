[
    {
        "link": "https://stackoverflow.com/questions/5889705/pyqt-how-to-remove-elements-from-a-qvboxlayout",
        "document": "I want a multi-color selection widget. The way I'm doing it is having a \"+\" button, and an initially empty vbox. When + is pressed, it adds a QHBoxLayout to the vbox containing a \"-\" button and 3 spinboxes. When the \"-\" button is pressed I want that row to disappear and everything to go back to looking like it did before that row was added. The code I currently have is:\n\nAdding widgets works fine. However, removing them results in a really messed-up looking thing where the row isn't actually removed, but the spacing is all messed up.\n\nWhat am I doing wrong?\n\nEDIT: The docs say, for :\n\nHow do I do that? (I come from a GTK background...)\n\nEDIT 2: I even kept track of the rows and called the function to remove it, but it still gets messed up. What gives? It looks like the layout is removed but none of the widgets are...\n\nEDIT 3: this also doesn't work, just messes things up in a similar way:"
    },
    {
        "link": "https://stackoverflow.com/questions/5899826/pyqt-how-to-remove-a-widget",
        "document": "If your widget have no child widgets that depend on it I think you can use:\n\naccording to my tests, when the widget has children, you have to:\n\nIf you don't have a variable name for the widget at class or global level you still can remove from layout with and get the widget pointer from the this functions returns with method, in that case you don't need to assign to the variable name because it is not referenced outside your function.\n\nTry both methods and see what works for you (don't leak memory after repeating a good number of times)."
    },
    {
        "link": "https://forum.qt.io/topic/11302/remove-widgets-from-qvboxlayout-solved",
        "document": "I have some (small) issues with the QVBoxLayout.\n\nI have a list of input lines ordered in a QVBoxLayout. I have buttons to add lines (which works perfectly fine), and buttons to remove lines. When there are only 2 or 3 lines, the lines don't disappear in the widget. They are desactivated, but they remain visible, and overlap with the active lines. Maybe a picture will explain better than me, so here is a screenshot. On the left: the window after adding 3 lines, and on the right, the window after removing 2 lines using the takeAt(int) method.\n\nIs there any way to clean the widget ? I have looked, but I didn't find any clearLyout() method or anything similar. update() of the layout or the widget does not work either.\n\nThanks for the advice !"
    },
    {
        "link": "https://doc.qt.io/qt-6/qvboxlayout.html",
        "document": "The QVBoxLayout class lines up widgets vertically. More...\n\nThis class is used to construct vertical box layout objects. See QBoxLayout for details.\n\nThe simplest use of the class is like this:\n\nFirst, we create the widgets we want to add to the layout. Then, we create the QVBoxLayout object, setting as parent by passing it in the constructor; next we add the widgets to the layout. will be the parent of the widgets that are added to the layout.\n\nIf you don't pass a parent to the constructor, you can at a later point use QWidget::setLayout() to install the QVBoxLayout object onto . At that point, the widgets in the layout are reparented to have as their parent."
    },
    {
        "link": "https://riverbankcomputing.com/pipermail/pyqt/2009-November/025214.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/33793315/how-to-use-spacers-in-qt",
        "document": "I have a with assigned to it .\n\nThen there is a single assigned to the layout.\n\nThe problem is that QLabel is positioned at the middle of the GroupBox. While I want it to be aligned with the top edge of the GroupBox. I probably need to add some sort of spacer. So the spacer would dynamically resize itself to fill the GroupBox's empty area pushing QLabel upward.\n\nWhat widget and what size policy should be used as a spacer?"
    },
    {
        "link": "https://stackoverflow.com/questions/13828657/qspaceritem-in-qformlayout-vertical-expand",
        "document": "After lot of time with manual as well as lots of tries i guess it's impossible to do what you want using QFormLayout.\n\nThis layout is desinged for windows with lot of fields to fill, but only for that.\n\nIf you want to add bigger spacing between sections of your form you can use QVBoxLayout with a couple of QFormLayout's inside it separated by spacings. Notice that in this case each section will have own width of first and second column so maybe that is not the best solution.\n\nThe other solution (if we are talking about grouping some options) is to use a couple of QGroupBoxes with QFormLayouts in it. The groups will not be separated by growing spacing, but it will be very readable and you can name your groups. If grouping options is what you want to do - this is probably the most common and user friendly way to do this.\n\nIf you only want visual effect you pointed - columns with same width in every section and growing spacing between sections, you can use QGridLayout with 2 columns and add spacers in rows between sections. In this case you have to create QLabel to put into first column by yourself."
    },
    {
        "link": "https://realpython.com/python-pyqt-layout",
        "document": "PyQt’s layout managers provide a user-friendly and productive way of arranging graphical components, or widgets, on a GUI. Laying out widgets properly will make your GUI applications look polished and professional. Learning to do so efficiently and effectively is a fundamental skill for you to get up and running with GUI application development using Python and PyQt.\n• What the benefits are of using PyQt’s layout managers\n• How to programmatically lay out widgets on a GUI using PyQt’s layout managers\n• How to select the right layout manager for your GUI application\n• How to lay out widgets in main window–based and dialog-based applications\n\nWith this knowledge and skillset, you’ll be able to use Python and PyQt to create professional-looking GUI applications.\n\nFor a better understanding of how to use layout managers, some previous knowledge of how to create PyQt GUI applications and how to work with PyQt widgets would be helpful.\n\nWhen you’re creating graphical user interface (GUI) applications, a common issue is how to get your graphical components—buttons, menus, toolbars, labels, and so on—laid out coherently on your forms and windows. This process is known as GUI layout, and it’s an important step in creating GUI applications. In the past, if you wanted to lay out graphical components, or widgets, on a window, then you would follow one of the following approaches:\n• Decide on and manually set a static size and position for each widget on the window.\n• Calculate and set the size and position of each widget dynamically. The first approach is fairly direct, but it has at least the following drawbacks:\n• Your windows will be non-resizable, which might cause problems when displaying them on different screen resolutions.\n• Your labels might not support localization properly because the length of a given text changes between languages.\n• Your widgets will display differently on different platforms, which makes it difficult to write multiplatform applications that look good. The second approach is more flexible. However, it also has drawbacks:\n• You have to do a lot of manual calculations to determine the right size and position of each widget.\n• You have to do some extra calculations to respond correctly to window resizing.\n• You have to redo all the calculations any time you modify the layout of your window. Even though you can still use either of these two approaches to lay out your GUIs, most of the time you’ll want to use a third and more convenient approach implemented by most modern GUI frameworks or toolkits: layout managers. Note: In some GUI frameworks, such as Tkinter, layout managers are also referred to as geometry managers. Layout managers automatically arrange widgets on a GUI according to your specific needs. They avoid the compatibility drawbacks of the first approach as well as the annoying and complicated calculations of the second approach. In the following sections, you’ll learn about PyQt’s built-in layout managers and how to use them to effectively lay out the graphical components of your GUI applications.\n\nGetting Stocked With a Gallery of PyQt Layouts In PyQt, widgets are graphical components that you use as building blocks for your GUI applications. When you place a bunch of widgets on a window to create a GUI, you need to give them some order. You need to set the widgets’ size and position on the window, and you also need to define their behavior for when the user resizes the underlying window. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out the PyQt4 documentation, the Qt for Python documentation, or the original Qt documentation. In this tutorial, you’ll find that most links will take you to the original Qt documentation, which is a better source of information in most cases. To arrange the widgets on windows or forms in PyQt, you can use the following techniques:\n• Use and on your widgets to provide an absolute size and position.\n• Reimplement and calculate your widgets’ size and position dynamically.\n• Use layout managers and let them do all the calculations and hard work for you. These techniques generally correspond to the three different approaches for laying out a GUI that you saw in the previous section. Again, calculating the size and position dynamically might be a good approach, but most of the time you’ll be better off using layout managers. In PyQt, layout managers are classes that provide the required functionality to automatically manage the size, position, and resizing behavior of the widgets in the layout. With layout managers, you can automatically arrange child widgets within any parent, or container, widget. Using layout managers will ensure that you make good use of the available space on your GUI and also that your application remains usable when the user resizes the window. Layout managers work as containers for both widgets and other layouts. To add widgets to a layout manager, you call on the layout at hand. To add a layout to another layout, you call on the layout at hand. You’ll dive deeper into nesting layouts in the section Nesting Layouts to Build Complex GUIs. Once you’ve added all the required widgets to a layout manager, you set the layout manager on a given widget using . You can set a layout manager on any subclasses of , including windows or forms. Note: is a PyQt class that you can use to create main window–style applications. This class has its own built-in layout manager. So, if you’re using , then you commonly won’t need to set a layout manager on your main window objects. All the widgets in a layout are automatically set as children of the widget on which you install the layout, not of the layout itself. That’s because widgets can have only other widgets, not layouts, as their parent. PyQt’s layout managers provide some cool features that make your life a lot easier when it comes to creating good-looking GUI applications:\n• Handling the size and position of widgets without the need for any calculation\n• Handling the resizing and repositioning of widget when the user resizes the underlying window Using layout managers will also dramatically increase your productivity and improve your code’s maintainability in the long term. In the next few sections, you’ll learn the basics of how to use these general-purpose layout managers.\n\nWhen creating GUI applications with PyQt, you’ll often use one or more of the four general-purpose layouts that you saw at the end of the previous section to get your widget laid out on your windows and forms. In the next few sections, you’ll learn how to create and use the four general-purpose layout managers with the help of some examples. Box layout managers take the space they get from their parent layout or widget, divide it up into a number of boxes, or cells, and make each widget in the layout fill one box. is one of the two available box layouts in PyQt. This layout manager allows you to arrange widgets horizontally, one next to the other. The widgets are added to the layout from left to right. This means that the widget that you add first in your code will be the left-most widget in the layout. To add widgets to a object, you call on the layout object. This method takes one required argument and two optional arguments:\n• is a required argument that holds the specific widget that you want to add to the layout.\n• is an optional argument that holds an integer number representing the stretch factor to apply to . Widgets with higher stretch factors grow more on window resizing. It defaults to , which means that the widget has no stretch factor assigned.\n• is an optional argument that holds horizontal and vertical flags. You can combine these flags to produce the desired alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s a small application that shows how to create a horizontal layout using . In this example, you’ll use objects to better visualize where each widget will be placed in the layout according to the order in which you add the widgets to your code: # Set the layout on the application's window On line 15, you create a object called . On lines 17 to 19, you add three buttons to using . Note that you pass and to the parameter in the Center and Right-Most buttons, respectively. On line 21, you set as your window’s top-level layout using . Note: If you’re new to GUI programming with PyQt, then you can take a look at Python and PyQt: Building a GUI Desktop Calculator to get a better idea of how to create a GUI application with PyQt. If you run this application, then you’ll get the following window on your screen: This window contains three buttons arranged in a horizontal fashion. Note that the Left-Most button corresponds to the first button that you add in your code. So, buttons are shown in the same order (from left to right) that you add them in your code (from top to bottom). The Center and Right-Most buttons have different stretch factors, so they expand in proportion to those factors when you resize the window. Additionally, all the buttons in and the layout itself are set as children of . This is automatically done by the layout object, which internally calls on each widget. The call to on line 22 prints a list of the children of on your terminal as evidence of this behavior. arranges widgets vertically, one below the other. You can use this class to create vertical layouts and arrange your widgets from top to bottom. Since is another box layout, its method works the same as in . Here’s a PyQt application that shows how to create and use a object for creating vertical arrangements of widgets in your GUIs: # Set the layout on the application's window On line 16, you create an instance of . On lines 18 to 20, you add three buttons to . Finally, you set as your window’s top-level layout. If you run this application, then you’ll get the following window: Your window shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order (from top to bottom) as you add them in your code (from top to bottom). You can use to arrange widgets in a grid of rows and columns. Each widget will have a relative position in the grid. To define a widget’s position, or cell in the grid, you use a pair of coordinates of the form . These coordinates should be zero-based integer numbers. takes the available space on its parent, divides it into rows and columns, and places each widget into its own cell or box. automatically figures out how many rows and columns the final layout will have depending on the number of widgets and their coordinates. If you don’t add a widget to a given cell, then will leave that cell empty. To add widgets to a grid layout, you call on the layout. This method has two different overloaded implementations:\n• adds to the cell at ( , ).\n• adds to the cell, spanning multiple rows, columns, or both. The first implementation takes the following arguments:\n• is a required argument that holds the specific widget that you need to add to the layout.\n• is a required argument that holds an integer representing the coordinate of a row in the grid.\n• is a required argument that holds an integer representing the coordinate of a column in the grid.\n• is an optional argument that holds the alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s an example of how to use to create a grid of widgets: # Set the layout on the application's window On line 15, you create the object. Then, on lines 17 to 25, you add widgets to the layout using . To see how grid layouts manage cells without an assigned widget, comment out one or more of these lines and run the application again. If you run this code from your command line, then you’ll get a window like this: Each widget in the object occupies the cell defined by the pair of coordinates that you provide in . The text on each button reflects those coordinates. The coordinates are zero-based, so the first cell is at . In the second implementation of , the arguments and stay the same, and you have four additional arguments that allow you to place the widget across several rows or columns:\n• takes an integer number that represents the row in which the widget will start.\n• takes an integer number that represents the column in which the widget will start.\n• takes an integer number that represents the number of rows that the widget will occupy in the grid.\n• takes an integer number that represents the number of columns that the widget will occupy in the grid. Here’s an application that shows how this variation of works: # Set the layout on the application's window On line 19, you use the second implementation of to add a button that occupies two columns in the grid. The button starts at the second row ( ) and at the first column ( ). Finally, the button occupies one row ( ) and two columns ( ). Note: Since PyQt is a Python binding for Qt, which is a set of C++ libraries, sometimes you can’t use keyword arguments when calling PyQt methods. The keyword arguments used in the above paragraph have the sole purpose of showing what value is assigned to each argument. Here’s the window that you’ll see on your screen if you run this application: In this kind of layout, you can make a widget occupy more than one cell, just as you did with the Button Spans two Cols button. If you’re constantly creating forms to perform actions like inputting data into a database, then is for you. This class arranges widgets in a two-column layout. The first column usually displays a label describing the intended input, and the second column generally contains input widgets such as , , or that allow the user to enter or edit data. To add widgets to a form layout, you use . This method has several variations but, most of the time, you’ll choose from the following two:\n• adds a new row to the bottom of a form layout. The row should contain a object ( ) and an input widget ( ).\n• automatically creates and adds a new object with as its text. holds an input widget. Here’s a sample application that uses a object to arrange widgets: # Set the layout on the application's window On line 17, you create a object. Then, on lines 19 to 22, you add some rows to the layout. Note that on lines 19 and 20, you use the second variation of the method, and on line 22, you use the first variation, passing a object as the first argument to . If you run this code, then you’ll get the following window on your screen: With a , you can organize your widgets in a two-column arrangement. The first column contains labels that ask the user for some information. The second column shows widgets that allow the user to input or edit that information.\n\nYou can use nested layouts to create complex GUIs that would be difficult to create using one of the general-purpose PyQt’s layout managers. To do that, you need to call on an outer layout. This way, the inner layout becomes a child of the outer layout. Suppose you need to create a dialog that shows a label and a line edit in a form layout, and below those widgets you want to place several checkboxes in a vertical layout. Here’s a mock-up of what your dialog should look like: The blue rectangle represents your outer layout. The green rectangle is the form layout that will hold the label and line edit. The red rectangle is the vertical layout to hold the option checkboxes. Both the green layout and the red layout are nested into the blue one, which is a vertical layout. Here’s an example of how to build this layout using PyQt: # Create a form layout for the label and line edit # Add a label and a line edit to the form layout # Add some checkboxes to the layout # Nest the inner layouts into the outer layout Here’s what you’re doing in this code:\n• On line 17, you create the outer, or top-level, layout, which you’ll use as a parent layout and as the main layout of your window. In this case, you use because you want your widgets to be arranged vertically on your form. In your mock-up, this is the blue layout.\n• On line 19, you create a form layout to hold a label and a line edit.\n• On line 21, you add the required widgets to the layout. This is equivalent to your green layout.\n• On line 23, you create a vertical layout to hold the checkboxes.\n• On lines 25 to 27, you add the required checkboxes. This is your red layout.\n• On lines 29 and 30, you nest and under the . That’s it! If you run the application, then you’ll see a window like the following: In this application, you nest two different layouts under an outer layout to create a general layout for your window. At the top of the window, you use a horizontal layout to place a label and a line edit. Then you place some checkboxes below that using a vertical layout.\n\nSo far, you’ve seen how to use traditional or general-purpose layout managers to arrange the widgets in your application’s windows. These layout managers will arrange widgets on a single-page layout. In other words, your GUI will always show the same set of widgets to the user. Sometimes you need to create a layout that shows a different set of widgets in response to certain user actions on the GUI. For example, if you’re creating a preferences dialog for a given application, then you might want to present the user with a tab-based, or multipage, layout in which each tab or page contains a different set of closely related options. Every time the user clicks on a tab or page, the application shows a different set of widgets. PyQt provides a built-in layout called and some convenient widgets like that will allow you to create this kind of multipage layout. The next few sections will walk you through some of these tools. provides a layout manager that will allow you to arrange your widgets on a stack, one on top of the other. In this kind of layout, only one widget is visible at a given time. To populate a stacked layout with widgets, you need to call on the layout object. This will add each widget to the end of the layout’s internal list of widgets. You can also insert or remove a widget at a given position in the list of widgets using or , respectively. Each widget in the list of widgets is displayed as an independent page. If you want to show several widgets on a page, then use a object for each page and set an appropriate layout of widgets to the page widget. If you need to get the total number of widgets (pages) in the layout, then you can call . An important point to keep in mind when working with objects is that you need to explicitly provide a mechanism to switch between pages. Otherwise, your layout will always show the same page to the user. To switch between pages, you need to call on the layout object. Here’s an example that shows how to use a stacked layout with a combo box for switching between pages: # Create and connect the combo box to switch between pages # Add the combo box and the stacked layout to the top-level layout On lines 21 to 23, you create a object that will allow you to switch between the pages in the layout. Then you add two options to the combo box in a list and connect it to , which is intended to handle page switching. Inside , you call on the layout object, passing the current index of the combo box as an argument. This way, when the user changes the option in the combo box, the page on the stacked layout will change accordingly. On line 25, you create the object. On lines 27 to 32, you add the first page to the layout, and on lines 34 to 39, you add the second page. Each page is represented by a object that contains several widgets in a convenient layout. The final step to get everything working is to add the combo box and the layout to the application’s main layout. Here’s how your application behaves now: In this case, you have two pages in your application’s layout. Each page is represented by a object. When you select a new page in the combo box on the top of the window, the layout changes to show the selected page. Note: PyQt provides a convenient class called , which is built on top of . You can also use this class to create multipage layouts. This class provides a stack of widgets in which only one widget is visible at a time. Just like stacked layouts, doesn’t provide an intrinsic mechanism for switching between pages. Besides stacked layout and stacked widget, you can use to create a multipage user interface. You’ll learn how in the next section. Another popular way of creating multipage arrangements in PyQt is by using a class called . This class provides a tab bar and a page area. You use the tab bar to switch between pages and the page area to display the page associated with the selected tab. The tab bar is located at the top of the page area by default. However, you can change this behavior using and one of four possible tab positions: Right of the pages To add tabs to a tab widget, you use . This method has two variations, or overloaded implementations: In both cases, the method adds a new tab, with as the tab’s title. needs to be a widget representing the page associated with the tab at hand. In the second variation of the method, needs to be a object. If you pass an icon to , then that icon will be shown to the left of the tab’s title. A common practice when creating tab widgets is to use a object for each page. This way, you’ll be able to add extra widgets to the page using a layout containing the required widgets. Most of the time, you’ll use tab widgets to create dialogs for your GUI applications. This kind of layout allows you to present the user with several options in a relatively small space. You can also take advantage of the tab system to organize your options according to some classification criteria. Here’s a sample application that shows the basics of how to create and use a object: # Create the tab widget with two tabs In this example, you use a tab widget to present the user with a concise dialog that shows options related to the General and Network sections of a hypothetical preferences menu. On line 20, you create the object. Then you add two tabs to the tab widget using . In and , you create the specific GUI for each tab. To do this, you use a object, a object, and some checkboxes to hold the options. If you run the application now, then you’ll get the following dialog on your screen: That’s it! You have a fully functional tab-based GUI. Note that to switch between pages, you just need to click the corresponding tab.\n\nGUI applications are commonly built using a main window and one or more dialogs. Dialogs are small windows that allow you to communicate with your users. PyQt provides to handle the creation of dialogs. Unlike , doesn’t have a predefined or default top-level layout. That’s because dialogs can be quite varied and include a wide range of widget arrangements and combinations. Once you place all the widgets on a dialog’s GUI, you need to set a top-level layout on that dialog. To do this, you have to call on the dialog object just like you’d do with any other widget. Here’s a dialog-style application that shows how to set a top-level layout to a object: # Set the layout on the dialog In this case, the application’s window inherits from , so you have a dialog-style application. On line 16, you create the layout that you’ll use as the dialog’s top-level layout. On lines 18 to 21, you create a form layout to arrange some widgets in a form. On line 24, you add a object. You’ll often use to handle the buttons on a dialog. In this example, you use two buttons, an Ok button and a Cancel button. These buttons won’t have any functionality—they’re just intended to make the dialog more realistic. Once you have all the widgets and layouts in place, you can add them to the top-level layout. That’s what you do on lines 28 and 29. The final step, on line 30, is to set the top-level layout as your dialog’s layout using . If you run this application, then you’ll see the following window on your screen: It’s a best practice to set a top-level layout for all your dialogs. This ensures that the dialog’s GUI will behave coherently when the user resizes the underlying window. Otherwise, your dialogs could appear disorganized and unpolished in the user’s eyes.\n\nWhen it comes to using PyQt’s layout managers to arrange the widgets on a window or form, managing space—empty space, space between widgets, and so on—is a common issue. Being able to manage this space is an important skill to have. Internally, layouts manage the available space on a window using some of the following widget properties:\n• contains the smallest size the widget can have while remaining usable\n• holds the default behavior of a widget in a layout Layouts use these properties to automatically position and resize widgets, assigning a given amount of space to each widget according to the available space. This ensures that widgets are consistently arranged and remain usable. In the next three sections, you’ll learn how the different types of layouts manage space in PyQt. Box layouts do a great job when it comes to distributing available space between widgets. However, sometime their default behavior isn’t enough, and you need to manually handle the available space. To help you out in this situation, PyQt provides . This class allows you to add blank space (or empty boxes) to a box layout. Normally, you don’t need to use directly. Instead, you call some of the following methods on your box layout objects:\n• adds a non-stretchable space (or empty box) of fixed size to the layout. must be an integer representing the size of the space in pixels.\n• adds a stretchable space with a minimum size of and a stretch factor to a box layout. must be an integer.\n• inserts a non-stretchable space at position , with size . If is negative, then the space is added at the end of the box layout.\n• inserts a stretchable space at position , with a minimum size of and a stretch factor of . If is negative, then the space is added at the end of the box layout. Stretchable spacers will expand or shrink to fill empty space when the user resizes the underlying window. Non-stretchable spacers will remain the same size regardless of the changes in the size of the underlying window. Go back to the example of how to use vertical layouts and run that application again. If you pull down the border of the window, then you’ll notice that more space appears between the buttons the further down you pull: This happens because the layout handles the newly available space by automatically expanding its boxes. You can change this behavior by adding a stretchable object to the end of the layout. In your example’s code, update the initializer of as follows: # Set the layout on the application's window In the highlighted line, you add a stretchable object to the end of the layout by calling on the layout. If you run the application again, then you’ll get the following behavior: Now all the extra space is automatically assigned to the stretchable object at the bottom of the layout without affecting the position or size of the rest of the widgets. You can use this and other space management techniques to make your GUI applications look good and polished. Grid and form layouts handle available space in a different way. In these types of layouts, you can handle only the vertical and horizontal space between widgets. These layouts provide three methods to manage these spaces:\n• sets both the vertical and the horizontal spacing between widgets to .\n• sets only the vertical spacing between widgets in the layout to .\n• sets only the horizontal spacing between widgets in the layout to . In all cases, is an integer representing pixels. Now go back to the example on how to create a form layout and update the initializer of like this: # Set the layout on the application's window In the highlighted line, you set the vertical space between widgets to pixels. If you run the application again, then you’ll see the following window: Now there’s more space between the rows of widgets. You can also try modifying the example of how to use a grid layout by adding some vertical or horizontal space just to see how all these spacing mechanisms work."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QSpacerItem.html",
        "document": "Changes this spacer item to have preferred width , preferred height , horizontal size policy and vertical size policy .\n\nThe default values provide a gap that is able to stretch if nothing else wants the space.\n\nNote that if is called after the spacer item has been added to a layout, it is necessary to invalidate the layout in order for the spacer item’s new size to take effect."
    },
    {
        "link": "https://forum.qt.io/topic/125299/how-to-use-qspaceritem",
        "document": "I have QGridLayout and three QLabels with textes in it.\n\nI would like to use spacer to move labels to down:\n\nNow I have situation on the left and I would like to have situation on the right.\n\nI try something like this:\n\nbut with no effects."
    }
]