[
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/system-information-schema-views/system-information-schema-views-transact-sql?view=sql-server-ver16",
        "document": "An information schema view is one of several methods SQL Server provides for obtaining metadata. Information schema views provide an internal, system table-independent view of the SQL Server metadata. Information schema views enable applications to work correctly although significant changes have been made to the underlying system tables. The information schema views included in SQL Server comply with the ISO standard definition for the INFORMATION_SCHEMA.\n\nSQL Server supports a three-part naming convention when you refer to the current server. The ISO standard also supports a three-part naming convention. However, the names used in both naming conventions are different. The information schema views are defined in a special schema named INFORMATION_SCHEMA. This schema is contained in each database. Each information schema view contains metadata for all data objects stored in that particular database. The following table shows the relationships between the SQL Server names and the SQL standard names.\n\nThis name-mapping convention applies to the following SQL Server ISO-compatible views.\n\nAlso, some views contain references to different classes of data such as character data or binary data.\n\nWhen you reference the information schema views, you must use a qualified name that includes the schema name. For example:\n\nThe visibility of the metadata in information schema views is limited to securables that a user either owns or on which the user has been granted some permission. For more information, see Metadata Visibility Configuration.\n\nInformation schema views are defined server-wide and therefore cannot be denied within the context of a user database. To REVOKE or DENY access (SELECT), the master database must be used. By default the public role has SELECT-permission to all information schema views but the content is limited with metadata visibility rules."
    },
    {
        "link": "https://docs.microsoft.com/en-us/sql/relational-databases/system-information-schema-views/system-information-schema-views-transact-sql?view=sql-server-ver15",
        "document": "An information schema view is one of several methods SQL Server provides for obtaining metadata. Information schema views provide an internal, system table-independent view of the SQL Server metadata. Information schema views enable applications to work correctly although significant changes have been made to the underlying system tables. The information schema views included in SQL Server comply with the ISO standard definition for the INFORMATION_SCHEMA.\n\nSQL Server supports a three-part naming convention when you refer to the current server. The ISO standard also supports a three-part naming convention. However, the names used in both naming conventions are different. The information schema views are defined in a special schema named INFORMATION_SCHEMA. This schema is contained in each database. Each information schema view contains metadata for all data objects stored in that particular database. The following table shows the relationships between the SQL Server names and the SQL standard names.\n\nThis name-mapping convention applies to the following SQL Server ISO-compatible views.\n\nAlso, some views contain references to different classes of data such as character data or binary data.\n\nWhen you reference the information schema views, you must use a qualified name that includes the schema name. For example:\n\nThe visibility of the metadata in information schema views is limited to securables that a user either owns or on which the user has been granted some permission. For more information, see Metadata Visibility Configuration.\n\nInformation schema views are defined server-wide and therefore cannot be denied within the context of a user database. To REVOKE or DENY access (SELECT), the master database must be used. By default the public role has SELECT-permission to all information schema views but the content is limited with metadata visibility rules."
    },
    {
        "link": "https://chartio.com/learn/databases/using-information-schema-views-to-check-to-see-if-table-exists-in-sql-server",
        "document": "What is the Problem?\n\nWhen writing queries for a database you might be new to, or one that changes often, you might want to run a quick check to find all the tables in a specific database, or the columns in the database, or to search if table or column exists.\n\nWhy is This a Problem?\n\nUnderstanding the schema and what tables are in it help to write efficient SQL and helps avoid running queries multiple times just to see if the schema name or column name is correct.\n\nThis tutorial will help solve these problems.\n\nQuerying the metadata on a data source is the easiest way to determine the makeup of a table if you don’t have an understanding of it already. Microsoft SQL Server provides an information schema view as one of several methods for obtaining this metadata. As their support documentation states, “Information schema views provide an internal, system table-independent view of the SQL Server metadata. Information schema views enable applications to work correctly although significant changes have been made to the underlying system tables.”\n\nWe will be using a couple of the views in the information schema in order to run queries that help determine the makeup of tables in the data source.\n\nTo Show the and in the database or find and .\n\nThis first query will return all of the tables in the database you are querying.\n\nThe second query will return a list of all the columns and tables in the database you are querying.\n\nOr, you can also query for just the from a specific table and return the column names from the specific table ‘Album’ in our database.\n\nWith this next query you can find out whether or not there is a in the data source that matches some kind of search parameters.\n\nThe query will return the word ‘found’ if the table ‘Album’ exists in our database.\n\nNow to take it a littler further, you can use this query to find out whether or not there is a in the data source that matches some kind of search parameters.\n\nUtilizing the view in your data source can be a reliable way to determine what is in the data source while you build your queries.\n\nFor more information on the Microsoft SQL Server System Information Schema Views, please read more from their support docs."
    },
    {
        "link": "https://stackoverflow.com/questions/46187767/difference-between-information-schema-vs-sys-tables-in-sql-server",
        "document": "Both and objects are both metadata catalogs that are available in SQL Server.\n\nThe set of views are the ANSI/ISO standard catalogs for metadata. Most RDBMSs support the majority of views, and each view exposes essentially identical information regardless of the vendor. In SQL Server, most, if not all, the views are views that go back to the tables in one way or another. In SQL Server, you can see the underlying VIEW definitions by running queries like:\n\nThe tables and views are the original metadata catalog views and tables that were, AFAIK, created by Sybase (Microsoft purchased SQL Server's original code base from them). Most RDBMSs have an equivalent set of catalog tables, but the specific table names differ between vendors. In SQL Server, these tables and the later addition of the dynamic management views (DMVs) are what Microsoft created to capture a database's metadata for system and user use.\n\nIn SQL Server, since the the views typically point back to the tables and due to the ISO definitions for those views, it is not unheard of that the views do not contain all metadata or all objects that you're looking for. (Personally, I think Aaron's bias in that article is a little overblown, but he's probably been bitten by the issue more than I have, and he also probably works on more complexly configured databases than I do.)\n\nThat said, however:\n\nThis clearly returns much more detailed information, but notice that returns both user tables and views, while only returns user tables.\n\nPersonally, I find the views much better organized and much easier to use for ad hoc queries to find tables by name or columns by name. Still, there are some corner cases where you have to go to the objects tables, and there are some situations where missing objects in the views can bite you. If I'm looking for a reliable and complete set of items, then I use the tables (specifically or ), but those require a lot more work to get readable results. The views have done much of that work for you already."
    },
    {
        "link": "https://stackoverflow.com/questions/15782934/how-to-query-information-schema-views",
        "document": "While working within SQL Server 2000, on one of the legacy systems, I ran the following query\n\nand got a result set with\n\nNow the problem is, there is no view with that name ( ) in the database. The only view with the same TEXT has a different name .\n\nDoes anyone know how this could be possible?"
    },
    {
        "link": "https://sqlshack.com/using-sp_executesql-stored-procedure-for-executing-dynamic-sql-queries",
        "document": "The sp_executesql stored procedure is used to execute dynamic SQL queries in SQL Server. A dynamic SQL query is a query in string format. There are several scenarios where you have an SQL query in the form of a string.\n\nFor example, if a user wants to search for a product by name, he will enter the name of the product in a search box on the website. The product name, which is in the form of a string will be concatenated with a SELECT query to form another string. These types of queries need to be executed dynamically because different users will search for different product names and so a query will need to be generated dynamically depending on the product name.\n\nNow that you understand what dynamic SQL is, let’s see how the sp_executesql stored procedure can be used to execute dynamic SQL queries.\n\nLet’s first create some dummy data that we can use to execute the examples in this article.\n\nThe following script creates a dummy database named BookStore with one table i.e. Books. The Books table has four columns: id, name, category, and price:\n\nLet’s now add some dummy records in the Books table:\n\nThe above script adds 10 dummy records in the Books table.\n\nAs I mentioned earlier, the sp_executesql stored procedure is used to execute dynamic SQL queries that are in the form of a string. Let’s see this in action.\n\nIn the script above, we declare a variable @SQL_QUERY and initialize it with a string query that returns the id, name, and price from the Books table where the price is greater than 4,000.\n\nNext, we execute the sp_executesql stored procedure via the EXECUTE command. To execute a dynamic SQL query that is in the string format, you simply have to pass the string containing the query to the sp_executesql query.\n\nIt is important to mention that the string should be in the Unicode format before the sp_executesql stored procedure executes it. This is the reason we put ‘N’ at the beginning of the string containing the @SQL_QUERY variable. The ‘N’ converts the query string into the Unicode string format. Here is the output of the above script:\n\nIn real life database queries, the filter or condition is passed by the users. For instance, a user may search books within a specific search limit. In that case, the SELECT query remains the same, only the WHERE condition is changed. It is convenient to store the WHERE clause in a separate string variable and then concatenate the SELECT condition with the WHERE clause to create the final query. This is shown in the following example:\n\nHere in the script above, we declare two variables: @CONDITION and @SQL_QUERY. The @CONDITION variable contains the WHERE clause in string format whereas the @SQL_QUERY contains the SELECT query. Next, these two variables are concatenated and passed to the sp_executesql stored procedure. Here is the output:\n\nThe output shows all the books where the price is greater than 5,000.\n\nYou can also pass parameters to the sp_executesql stored procedure. This is particularly handy when you don’t know the values used to filter records before runtime. To execute a sp_executesql stored procedure with parameters, you need to perform the following steps:\n• First, you need to create a variable that is going to store the list of parameters\n• Next, in the query string, you need to pass the names of the parameters\n• Finally, you need to pass the query, the variable that contains a list of parameters and the actual parameters along with their values to the sp_executesql stored procedure\n\nLook at the following example:\n\nIn the script above, we create three variables: @CONDITION, @SQL_QUERY, and @PARAMS. The @PARAMS variable is a variable that stores the list of parameters that we will use in the string query format.\n\nIf you look at the value of the @CONDITION variable, it contains a WHERE clause with two parameters: @LowerPrice and @HigherPrice. To specify a parameter inside a string query, you simply have to prefix with the ‘@’ operator before the name of the parameter. Here the @LowerPrice parameter is used to set the lower bound for the price of books whereas the @HigherPrice sets the higher bound for the value in the price column of the BookStore table.\n\nNext, while executing the sp_executesql stored procedure, the @SQL_QUERY variable which contains the string query is passed along with the @PARAMS variable which contains the parameter list. The parameter names i.e. @LowerPrice and @HigherPrice are also passed to the sp_executesql stored procedure along with the values 3,000 and 6,000 respectively. In the output, you will see the records where the price is between 3,000 and 6,000 as shown below:\n\nThis article explains the functionality of sp_executesql stored procedure which is used to execute dynamic SQL queries. The article shows how to execute the SELECT query in the form of a string via sp_executesql stored procedure. You also saw how to pass parameters to the sp_executesql stored procedure in order to execute queries where values are passed at runtime."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric\n\nExecutes a Transact-SQL statement or batch that can be reused many times, or one that is built dynamically. The Transact-SQL statement or batch can contain embedded parameters.\n\nThe code samples in this article use the or sample database, which you can download from the Microsoft SQL Server Samples and Community Projects home page.\n\nA Unicode string that contains a Transact-SQL statement or batch. @stmt must be either a Unicode constant or a Unicode variable. More complex Unicode expressions, such as concatenating two strings with the operator, aren't allowed. Character constants aren't allowed. Unicode constants must be prefixed with an . For example, the Unicode constant is valid, but the character constant isn't. The size of the string is limited only by available database server memory. On 64-bit servers, the size of the string is limited to 2 GB, the maximum size of nvarchar(max).\n\n@stmt can contain parameters having the same form as a variable name. For example:\n\nEach parameter included in @stmt must have a corresponding entry in both the @params parameter definition list and the parameter values list.\n\nA string that contains the definitions of all parameters that are embedded in @stmt. The string must be either a Unicode constant or a Unicode variable. Each parameter definition consists of a parameter name and a data type. n is a placeholder that indicates more parameter definitions. Every parameter specified in @stmt must be defined in @params. If the Transact-SQL statement or batch in @stmt doesn't contain parameters, @params isn't required. The default value for this parameter is .\n\nA value for the first parameter that is defined in the parameter string. The value can be a Unicode constant or a Unicode variable. There must be a parameter value supplied for every parameter included in @stmt. The values aren't required when the Transact-SQL statement or batch in @stmt has no parameters.\n\nIndicates that the parameter is an output parameter. text, ntext, and image parameters can be used as parameters, unless the procedure is a common language runtime (CLR) procedure. An output parameter that uses the keyword can be a cursor placeholder, unless the procedure is a CLR procedure.\n\nA placeholder for the values of extra parameters. Values can only be constants or variables. Values can't be more complex expressions such as functions, or expressions built by using operators.\n\nReturns the result sets from all the SQL statements built into the SQL string.\n\nparameters must be entered in the specific order as described in the Syntax section earlier in this article. If the parameters are entered out of order, an error message occurs.\n\nhas the same behavior as regarding batches, the scope of names, and database context. The Transact-SQL statement or batch in the @stmt parameter isn't compiled until the statement is executed. The contents of @stmt are then compiled and executed as an execution plan separate from the execution plan of the batch that called . The batch can't reference variables declared in the batch that calls . Local cursors or variables in the batch aren't visible to the batch that calls . Changes in database context last only to the end of the statement.\n\ncan be used instead of stored procedures to execute a Transact-SQL statement many times when the change in parameter values to the statement is the only variation. Because the Transact-SQL statement itself remains constant and only the parameter values change, the SQL Server query optimizer is likely to reuse the execution plan it generates for the first execution. In this scenario, performance is equivalent to that of a stored procedure.\n\nsupports the setting of parameter values separately from the Transact-SQL string, as shown in the following example.\n\nOutput parameters can also be used with . The following example retrieves a job title from the table in the sample database, and returns it in the output parameter .\n\nBeing able to substitute parameters in offers the following advantages over using the statement to execute a string:\n• None Because the actual text of the Transact-SQL statement in the string doesn't change between executions, the query optimizer probably matches the Transact-SQL statement in the second execution with the execution plan generated for the first execution. Therefore, SQL Server doesn't have to compile the second statement.\n• None The Transact-SQL string is built only once.\n• None The integer parameter is specified in its native format. Casting to Unicode isn't required.\n\nWhen the OPTIMIZED_SP_EXECUTESQL database scoped configuration is enabled, the compilation behavior of batches submitted using becomes identical to the serialized compilation behavior that objects such as stored procedures and triggers currently employ.\n\nWhen batches are identical (excluding any parameter differences), the option tries to obtain a compile lock as an enforcement mechanism to guarantee that the compilation process is serialized. This lock ensures that if multiple sessions invoke simultaneously, those sessions will wait while trying to obtain an exclusive compile lock after the first session starts the compilation process. The first execution of compiles and inserts its compiled plan into the plan cache. Other sessions abort waiting on the compile lock and reuse the plan once it becomes available.\n\nWithout the option, multiple invocations of identical batches executed via compile in parallel and place their own copies of a compiled plan into the plan cache, which replace or duplicate plan cache entries in some cases.\n\nis off by default. To enable at the database level, use the following Transact-SQL statement:\n\nThe following example creates and executes a statement that contains an embedded parameter named .\n\nThe following example shows using to execute a dynamically built string. The example stored procedure is used to insert data into a set of tables that are used to partition sales data for a year. There's one table for each month of the year that has the following format:\n\nThis sample stored procedure dynamically builds and executes an statement to insert new orders into the correct table. The example uses the order date to build the name of the table that should contain the data, and then incorporates that name into an statement.\n\nUsing in this procedure is more efficient than using to execute the dynamically built string, because it allows for the use of parameter markers. Parameter markers make it more likely that the Database Engine reuses the generated query plan, which helps to avoid additional query compilations. With , each string is unique because the parameter values are different, and would be appended to the end of the dynamically generated string. When executed, the query wouldn't be parameterized in a way that encourages plan reuse, and would have to be compiled before each statement is executed, which would add a separate cached entry of the query in the plan cache.\n\nC. Use the OUTPUT parameter\n\nThe following example uses an parameter to store the result set generated by the statement in the parameter. Two statements are then executed that use the value of the parameter.\n\nThe following example creates and executes a statement that contains an embedded parameter named ."
    },
    {
        "link": "https://forums.sqlteam.com/t/how-to-use-sp-executesql-for-dynamic-sql-which-is-stored-in-sql-table/15667",
        "document": "Here is an example of how you would do it. That said, don't do it. It is very vulnerable to SQL injection attacks. If you can describe your end goal, people on this forum might be able to suggest safer/better alternatives. CREATE TABLE #tmp (QueryString NVARCHAR(4000)); INSERT INTO #tmp VALUES ('SELECT * FROM sys.tables') DECLARE @x NVARCHAR(4000); SELECT TOP (1) @x = QueryString FROM #tmp; EXEC sys.sp_executesql @x;\n\nThe return code from sp_executesql is zero if the job was successful, and non-zero on failure. So @i being zero simply means the query ran successfully. If you want to get the output from the result of the query, you have to use an OUT parameter. There is a very specific way for doing this. Look at this page, and in particular the example code that I have copied below from that page. Here, @max_titleOUT is the parameter that returns the desired result. Notice how the OUTPUT keyword is specified both in @ParmDefinition and in sp_executesql call for that parameter.\n\n----STEP1 EXECUTE STATAMENT FROM DIRECT QUERY IS UPATING THE SALESDETAIL AMOUNT\n\n DECLARE @SQLCODE NVARCHAR(1000)\n\n DECLARE @statement NVARCHAR(400)\n\n DECLARE @parameterDefinition NVARCHAR(400)\n\n DECLARE @BID INT=1\n\n DECLARE @i int\n\n SET @SQLCODE='UPDATE SALESDETAIL SET AMOUNT=50 WHERE Batchid=@batchid'\n\n SET @statement =@SQLCODE\n\n SET @parameterDefinition = N'@batchid int'\n\n execute @i= sp_executesql @statement, @parameterDefinition, @BatchID=@BID (3 rows affected)\n\n 0\n\n ---ABOVE STEP IS WORKING\n\n ----STEP2 EXECUTE STATAMENT FROM SQL TABLE IS NOT UPATING THE SALESDETAIL AMOUNT --IN THE MESSAGE WINDOW\n\n 0\n\n STEP2 NOT UPDATING THE AMOUNT THIS IS THE PROBLEM\n\nThere is no reason why storing sql code in a table, pulling it out and executing it shouldn't work; whether that is a good idea (as per JamesK & yosiasz) is a different conversation Looking at your \"demo\" code the one thing missing is any actual data in the SQLCODE table to execute use tempdb; DROP TABLE IF EXISTS #wibble DROP TABLE IF EXISTS #code -- table to hold \"code\" create table #code ( code varchar(100) ) -- dummy table with some data CREATE TABLE #wibble ( wobble VARCHAR(10) ) INSERT INTO #wibble SELECT * FROM (VALUES ('some'), ('data')) as v(v) -- set up variables requried DECLARE @SQL NVARCHAR(100) = 'SELECT * FROM #WIBBLE' DECLARE @RC INTEGER -- SQL parameters DECLARE @parameterDefinition NVARCHAR(400) = N'@batchid int' DECLARE @BID INT=1 -- run sp_execute sql with just variables -- OUTPUT, 2 rows EXEC @RC = SP_EXECUTESQL @SQL SELECT @RC -- prove #code is empty -- OUTPUT, 0 rows SELECT * FROM #code -- get NON existent code from #code and execute -- OUTPUT 0 rows SELECT @SQL = (SELECT code from #code) -- prove @sql is blank SELECT @SQL AS '@sql is empty' -- EXECUTE EXEC @RC = SP_EXECUTESQL @SQL SELECT @RC -- same again but with (spurious) parameters attached, same 0 row output EXEC @RC = SP_EXECUTESQL @SQL, @parameterDefinition, @BatchID=@BID SELECT @RC -- actually populate #code INSERT INTO #code SELECT 'SELECT * FROM #WIBBLE' -- PROVE #code has ... er ... code SELECT * FROM #code -- now get code from #code and execute -- OUTPUT, 2 rows SELECT @SQL = (SELECT code from #code) -- prove @SQL has \"code\" SELECT @SQL AS '@sql is not empty' -- execute EXEC @RC = SP_EXECUTESQL @SQL SELECT @RC -- and again, with parameters, 2 rows EXEC @RC = SP_EXECUTESQL @SQL, @parameterDefinition, @BatchID=@BID SELECT @RC"
    },
    {
        "link": "https://stackoverflow.com/questions/68531204/executing-dynamic-sql-code-with-sp-executesql-with-return-value",
        "document": "I'm looking for a way to execute the @batchSQL dynamic SQL through sp_executesql. I'm working on synchronizing tables between two databases and due to poor performance trying to see if synchronizing data in batches could help solve the performance issues.\n\nThe batching part is just an excerpt, but it would execute all stored procedures that synchronize data by starting with the first record in a table and calculating the next batch size based on how many records it can synchronize within one minute.\n\nThere is a default set for the first run: 10 for @batchSize and 0 for @batchRow. The calculations are not really relevant to the issue so I've left that part out and just kept the important bits. In the @batchSQL variable the @batchProcess contains the name of the next stored procedure to run.\n\nIn order to run the second batching process after the first 'default' run, the @cursRows variable gets the number of rows in the cursor with @@CURSOR_ROWS. This way the second batch process will start from the first record not yet synchronized. However after the sp_executesql line runs, the value returned is null in the BatchSize column of the BatchTable table.\n\nWhen I'm not executing it as dynamic sql but hardcoding the @batchSQL line with the same values as used in the default run, it returns the value from @cursRows correctly.\n\nHere is the procedure that I'm testing with called by the previous code snippet.\n\nDoes anyone have an idea how to get @cursRows back from this query?\n\nAll help is greatly appreciated!"
    },
    {
        "link": "https://sqlshack.com/introduction-to-sp_executesql-stored-procedure-with-examples",
        "document": "The sp_executesql is a built-in stored procedure in SQL Server that enables to execute of the dynamically constructed SQL statements or batches. Executing the dynamically constructed SQL batches is a technique used to overcome different issues in SQL programming sometimes. For example, when we want to determine the displayed columns in our reports, this procedure might be a solution option for us. In the simplest sense, this procedure takes a dynamically constructed SQL batch and other parameters, then execute it in the runtime and, finally, it returns the result.\n• Note: In this article’s examples, the sample AdventureWorks database will be used.\n\nThe following code describes the syntax:\n\n@stmt parameter is used to specify dynamically generated SQL statement or batch. The data type of this parameter must be Unicode strings, for this reason, we have to add N prefix for the direct text usage or have to use nvarchar or nchar data typed variables.\n\n@parameternameN_datatype defines the parameter’s name and data type that has been used in the dynamically constructed SQL statements.\n\nWith the help of the @parameternameN=’ValueN’ expression, we can assign a value to the defined parameters which are placed in the SQL statement. In the following sections of the article, we will explore the usage details with examples from easy to difficult.\n\nThe purpose of this example is, retrieving data from the Person table which is taking part under the same schema on the AdventureWorks database:\n\nThe dynamically constructed SQL statement will be assigned to the @SqlStatment variable. The @ColName variable is used to specify the column names, that we want to display in the result set of the query. As a last, we will filter the Person table data with the @PerType parameter. This parameter data type will be nchar(2) and filter the data whose Persontype column expressions equal to “EM”. As the last step, we will execute the query and achieve the result:\n\nThe result set of the query shows only FirstName, MiddleName and LastName columns because of the assigned value of the @ColNames variable. At the same time, we can adjust the displaying column names with this parameter. For example, the following example will be displayed only FirstName column:\n\nsp_executesql provides to return execution result of the dynamically constructed SQL statement or batch. The OUTPUT parameter plays a key role to resolve this case. In this example, we will count the row number of the PersonPhone table and then we will set the return value to a variable with the OUTPUT parameter. The trick of this usage is to indicate the @RowNumber parameter as an OUTPUT parameter and then we assigned this internal parameter value to the @Result parameter:\n\nThe EXEC statement is another option to execute the dynamic SQL statements. For example, we can execute the following dynamically constructed SQL statement through the EXEC statement:\n\nIn the previous example, we executed the dynamically constructed query with the EXEC statement but we need to take account one point about it. We could not parametrize the EXEC statement and this is the main drawback of it.\n\nsp_executesql has some advantages comparing to the EXEC statement. Now, let’s take a glance at these:\n• sp_executesql has the ability to reuse the cached query plans\n\nEach query executed in SQL Server is compiled before it is executed. This query compilation process generates an output that is called the query plan. However, this query compilation process might be very expensive sometimes. For this reason, SQL Server wishes to reuse the cached query plans as possible as for the same queries in order to degrade the query compilation costs. Now, we will prove this idea.\n\nAt first, we will clear all the cached plans with FREEPROCCACHE. However, do not execute this command in the production environment because it could be damage to the performance of the SQL Server:\n\nIn this step, we will execute the following query 3 times with the random parameters.\n\nNow we will check out the generated query plans in the sys.dm_exec_cached_plans:\n\nNow, we will repeat a similar test scenario for the EXEC statement:\n\nIn this step, we will execute the dynamically constructed query 3 times for the random parameters with the EXEC statement:\n\nNow, we will re-check sys.dm_exec_cached_plans view to see how many query plans were created:\n\nAs a result, sp_executesql generated a one query plan in the first execution of the query and then it used the same query plan again and again. In spite of that, the EXEC statement created new query plans for each query execution. This type of usage could consume SQL Server resources and could be caused by performance issues.\n• Note: sp_executesql allows for generating parameterized dynamic queries. So that it is more secure to SQL injection attacks. EXEC statement is more vulnerable in terms of SQL injections.\n\nIn this article, we explored the sp_executesql procedure details and learned the usage methods. This procedure is very useful to resolve the dynamic query issues however, we have to consider the SQL injection issues when we decide to use dynamic queries in SQL Server."
    }
]