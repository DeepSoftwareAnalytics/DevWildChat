[
    {
        "link": "https://projectf.io/posts/riscv-arithmetic",
        "document": "In the last few years, we‚Äôve seen an explosion of RISC-V CPU designs on FPGA and ASIC, including the RP2350 found on the Raspberry Pi Pico 2. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions and programming.\n\nThe first part looks at load immediate, addition, and subtraction. We‚Äôll also cover sign extension and pseudoinstructions.\n\nRISC-V Assembler: Arithmetic | Logical | Shift | Load and Store | Branch and Set | Jump and Function | Multiply and Divide | Compiler Explorer | Assembler Cheat Sheet\n\nRISC-V handles processors of different sizes with separate but consistent instruction sets:\n\nI‚Äôll be focusing on RV32, but the other instruction sets work in a similar way.\n\nThe base integer instruction set for RV32 is RV32I (\"I\" stands for integer). RV32I contains the essential RISC-V instructions, including arithmetic, memory access, and flow control.\n\nRV32I has 32 general-purpose registers: x0 to x31. These registers are 32 bits wide.\n\nx0 is hard-wired to 0 (zero). You can use the other registers as you see fit, but there is an ABI (application binary interface) to make life easier for programmers and allow code from different developers to interoperate. My examples use the ABI temporary registers t0-t6. I cover all the ABI registers in my functions post.\n\nWith that briefest of introductions out of the way, let‚Äôs get started on the instructions.\n\nIt‚Äôs simple to load an immediate (constant) value into a register with load immediate li:\n\nrd is the destination register, and imm is a 32-bit immediate.\n\nRISC-V registers are 32 bits wide. RISC-V instructions are 32 bits wide. An instruction needs room for an opcode and registers, so it can‚Äôt hold a 32-bit immediate. How does li manage it? Load immediate is not a RISC-V instruction but a pseudoinstruction.\n\nPseudoinstructions are translated into one or more real instructions by the assembler. Pseudoinstructions are syntactic sugar that makes code easier to write and understand, and we‚Äôll see examples of them throughout this series.\n\nHowever, before we can properly understand load immediate, we need to cover arithmetic.\n\nRISC-V instructions typically have a destination register and two sources. For addition, the sources can be two registers (add) or a register and an immediate (addi).\n\nrd is the destination register, rs1 and rs2 are source registers, and imm is a 12-bit immediate.\n\nExamples of adding a register to an immediate:\n\nWith a 12-bit immediate, addi can add a value in the range -2048 to 2047. RISC-V has no increment (inc) or decrement (dec) instructions; addi handles them too.\n\nNot content with addition and subtraction, addi is also behind two common pseudoinstructions:\n\nThe mv (move) instruction copies one register to another. mv is addi with an immediate value of 0. The move instruction can only copy between registers, it can‚Äôt access memory.\n\nMove example (note the destination is the first register given):\n\nThe nop instruction advances the program counter but makes no other changes. A standard nop encoding clarifies the programmer‚Äôs intent and prevents the instruction from being optimised away.\n\nRISC-V immediates are sign extended. The most significant bit (MSB) fills the remaining bits to create a 32-bit value. A 12-bit RISC-V immediate can represent -2048 to 2047 inclusive.\n\nUsing a signed immediate, we can add and subtract with addi (see above) or jump forwards and backwards in code (discussed in Jump and Function).\n\nRISC-V‚Äôs designers made several small decisions that have an oversized impact on the simplicity and power of the instruction set: sign extending immediates is one of them.\n\nThe sub instruction subtracts registers. Subtracting an immediate is handled by addi (above).\n\nThe neg pseudoinstruction negates a register value: positive numbers become negative and vice-versa. Negate only takes one source register because it uses sub with the zero register (x0) as the first source.\n\nProTip: the destination register comes first in RISC-V assembler.\n\nLoad upper immediate sets the upper 20 bits of a register with an immediate value and zeros the lower 12 bits. Another way of looking at lui is that it left shifts the immediate by 12 bits. The lui instruction has room for a 20-bit immediate because it needs no source registers.\n\nIf out of range, GNU assembler returns .\n\nNow we‚Äôve met addi and lui, we‚Äôre ready to deconstruct li.\n\nLoad upper immediate (lui) sets the upper 20 bits; add immediate (addi) adds a 12-bit immediate. Together these two instructions can load a 32-bit immediate into a register.\n\nLet‚Äôs see how the assembler handles our li examples:\n\nThe first three examples fit into 12 bits, so they only need addi:\n\nRemember that the x0 register is hard-wired to 0 (zero).\n\nThe t3 (0x100000) example fits in the upper 20 bits, so it only needs lui:\n\nThe t4 (4100) example is a little too large for 12 bits (212 + 4 = 4100), so we need lui then addi:\n\nThe t5 (0xFACE) example is a sneaky one:\n\nThe obvious answer of adding 0xACE to 0xF won‚Äôt work because addi sign extends the 12-bit immediate. Looking at 0xACE in binary, we see the most significant bit is 1:\n\nThe result of the sign extension is negative: -1330 (-0x532).\n\nTo correct for the sign extension, we need to add 1 to the lui immediate: .\n\nAny immediate with 1 as the most significant bit needs this correction. Use li, and the assembler will take care of it. :)\n\nThe next post in the RISC-V assembler series looks at Logical Instructions. You can also check out the RISC-V Assembler Cheat Sheet and my FPGA & RISC-V Tutorials.\n\nGet in touch on Mastodon, Bluesky, or X. Enjoy my work? Please sponsor me. üôè\n\nThanks to jtruk and Daniel Mangum for suggestions and corrections."
    },
    {
        "link": "https://mcyoung.xyz/2021/11/29/assembly-1",
        "document": "A Turing tarpit is a programming language that is Turing-complete but very painful to accomplish anything in. One particularly notable tarpit is Brainfuck, which has a reputation among beginner and intermediate programmers as being unapproachable and only accessible to the most elite programmers hence the name, as Wikipedia puts it:\n\nAssembly language, the ‚Äúlowest-level‚Äù programming language on any computer, has a similar reputation: difficult, mysterious, and beyond understanding. A Turing tarpit that no programmer would want to have anything to do with.\n\nAlthough advanced programmers usually stop seeing assembly as mysterious and inaccessible, I feel like it is a valuable topic even for intermediate programmers, and one that can be made approachable and interesting.\n\nThis series seeks to be that: assuming you have already been using a compiled language like Rust, C++, or Go, how is assembly relevant to you?\n\nWhat Is It, Anyways?\n\nAs every programmer knows, computers are very stupid. They are very good at following instructions and little else. In fact, the computer is so stupid, it can only process basic instructions serially, one by one. The instructions are very simple: ‚Äúadd these two values‚Äù, ‚Äúcopy this value from here to there‚Äù, ‚Äúgo run these instructions over here‚Äù.\n\nA computer processor implements these instructions as electronic circuits. At its most basic level, every computer looks like the following program:\n\nThe array is a your program encoded as a sequence of these ‚Äúmachine instructions‚Äù in some kind of binary format. For example, in RISC-V programs, each instruction is a 32-bit integer. This binary format is called machine code.\n\nFor example, when a RISC-V processor encounters the value decoding circuitry decides that it means that it should take the value in the ‚Äúregister‚Äù , add to it, and place the result in the register .\n\nHowever, if you‚Äôre a human programming a computer, writing all of this by hand is‚Ä¶ very 60s, and you might prefer to have a textual representation, so you can write this more simply as .\n\nis a single line of assembly: it describes a single instruction in text form. Assembly language is ‚Äújust‚Äù a textual representation of the program‚Äôs machine code. Your assembler can convert from text into machine instructions, and a disassembler reverses the process.\n\nThe simple nature of these instructions is what makes assembly a sort of Turing tarpit: you only get the most basic operations possible: you‚Äôre responsible for building everything else.\n\nThere isn‚Äôt ‚Äúan‚Äù assembly language. Every computer has a different instruction set architecture, or ‚ÄúISA‚Äù; I use the terms ‚Äúinstruction set‚Äù, ‚Äúarchitecture‚Äù, and ‚ÄúISA‚Äù interchangeably. Each ISA has a corresponding assembly language that describes that ISA‚Äôs specific instructions, but they all generally have similar overall structure.\n\nI‚Äôm going to focus on three ISAs for ease of exposition, introduced in this order:\n‚Ä¢ x86_64, the instruction set of the device you‚Äôre reading this on (unless it‚Äôs a phone, an Apple M1 laptop, or something like a Nintendo Switch). That‚Äôs Part II.\n‚Ä¢ MOS 6502, a fairly ancient ISA still popular in very small microcontrollers. That‚Äôs Part III.\n\nWe‚Äôre starting with RISC-V because it‚Äôs a particularly elegant ISA (having been developed for academic work originally), while still being representative of the operations most ISAs offer.\n\nIn the future, I may dig into some other, more specialized ISAs.\n\nIt‚Äôs actually very rare to write actual assembly. Thanks to modern (relatively) languages like Rust, C++, and Go, and even things like Haskell and JavaScript, virtually no programmers need to write assembly anymore.\n\nBut that‚Äôs only because it‚Äôs the leading language written by computers themselves. A compiler‚Äôs job is, fundamentally, to write the the assembly you would have had to write for you. To better understand what a compiler is doing for you, you need to be able to read its output.\n\nAt this point, it may be worth looking at my article on linkers as a refresher on the C compilation model.\n\nFor example, let‚Äôs suppose we have the very simple C program below.\n\nClang, my C compiler of choice, can turn it directly into a library via . asks the compiler to stop before the link step, outputting the object file . We can ask the compiler to stop even sooner than that by writing , which will output , the assembly file the compiler produced! For this example, and virtually all others in this post, I‚Äôm using a RISC-V target: .\n\nIf you build with to make the code as small as possible (this makes it easiest to see what‚Äôs going on, too), you get something like this:\n\nThere‚Äôs a lot going on! But pay attention to the two lines with a : the first is , which is the multiplication . The second is , which is our function call to ! I‚Äôll explain what everything else means in short order.\n\nWriting assembly isn‚Äôt a crucial skill, but being able to read it is. It‚Äôs actually so useful, that a website exists for quickly generating the assembly output of a vast library of compilers: the Compiler Explorer, frequently just called ‚Äúgodbolt‚Äù after its creator, Matt Godbolt. Being able to compare the output of different compilers can help understand what they do! Click on the button in the code fences to a godbolt for it.\n\n‚ÄúLow-level‚Äù languages like C aren‚Äôt the only ones where you can inspect assembly output. Godbolt supports Go: for example, click the button below.\n\nHopefully this is motivation enough to jump into the language proper. It is very useful to have a godbolt tab open to play around with examples!\n\nSo, let‚Äôs say you do want to read assembly. How do we do that?\n\nLet‚Äôs revisit our example above. This time, I‚Äôve added comments explaining what all the salient parts of the code do, including the assembler directives, which are all of the form . Note that the actual compiler output includes way more directives that would get in the way of exposition.\n\nThere‚Äôs a lot of terms below that I haven‚Äôt defined yet. I‚Äôll break down what this code does gradually, so feel free to refer back to it as necessary, using this handy-dandy link.\n\nAll assemblers are different, but the core syntax tends to be the same. There are three main kinds of syntax productions:\n‚Ä¢ Instructions, which consist of a mnemonic followed by some number of operands, such as and above. These are the text encoding of machine code.\n‚Ä¢ Labels, which consist of a symbol followed by a colon, like or . These are used to let instruction operands refer to locations in the program.\n‚Ä¢ Directives, which vary wildly by assembler. GCC-style assembly like that above uses a syntax, as seen in , , and . They control the behavior of the assembler in various ways.\n\nAn assembler‚Äôs purpose is to read the file and serialize it as a binary file. It‚Äôs kind of like a compiler, but it does virtually no interesting work at all, beyond knowing how to encode instructions.\n\nDirectives control how this serialization occurs (such as moving around the output cursor); instructions are emitted as-is, and labels refer to locations in the object file. Simple enough, right?\n\nLet‚Äôs look at the very first instruction in :\n\nThe first token is called the mnemonic, which is a painfully terse abbreviation of what the instruction does. In this case, means ‚Äúadd with immediate‚Äù.\n\nis a register. Registers are special variables wired directly into the processor that can be used as operands in instructions. The degree to which only registers are permitted as operands varies by architecture; RISC-V only allows registers, but x86, as we‚Äôll see, does not. Registers come in many flavors, but is a GPR, or ‚Äúgeneral purpose register‚Äù; it holds a machine word-sized integer, which in the case of 32-bit RISC-V is‚Ä¶ 32-bit.\n\nis an immediate, which is a literal value that is encoded directly into the instruction. The encoding of will include the binary representation of (in the case of RISC-V, as a 12-bit integer). [The decoding example above]{#decoding-instructions} shows how immediates are literally encoded immediately in the instruction.\n\nImmediates allow for small but fixed integer arguments to be encoded with high locality to the instruction, which is good for code size and performance.\n\nThe first operand in RISC-V is (almost) always the output. should be read as . Virtually all assembler syntax follows this convention, which is called the three-address code.\n\nOther kinds of operands exist: for example, refers to the symbol . The assembler, which doesn‚Äôt actually know where is, will emit a small note in the object file that tells the linker to find and splat it into the assembly according to some instructions in the note. These notes are called relocations.\n\nThe instructions and use the and operand types, which are specific to RISC-V; they load the low 12 bits and high 20 bits of a symbol‚Äôs address into the immediate operand. This is a RISC-V-specific pattern for loading an address into a register, which most assemblers provide with the pseudoinstruction (where stands for ‚Äúload address‚Äù).\n\nMost architectures have their own funny architecture-specific operand types to deal with the architecture‚Äôs idiosyncrasy.\n\nAvailable instructions tend to be motivated by providing one of three classes of functionality:\n‚Ä¢ A Turing-complete register machine execution environment. This lends to the Turing tarpit nature of assembly: only the absolute minimum in terms of control flow and memory access is provided.\n‚Ä¢ Efficient silicon implementation of common operations on bit strings and integers, ranging from arithmetic to cryptographic algorithms.\n‚Ä¢ Building a secure operating system, hosting virtual machines, and actuating hardware external to the processor, like a monitor, a keyboard, or speakers.\n\nInstructions can be broadly classified into four categories: arithmetic, memory, control flow, and ‚Äúeverything else‚Äù. In the last thirty years, the bar for general-purpose architectures is usually ‚Äúthis is enough to implement a C runtime.‚Äù\n\nArithmetic makes up the bulk of the instruction set. This always includes addition, subtraction, and bitwise and, or, and xor, as well as unary not and negation.\n\nIn RISC-V, these come in two variants: a three-register version and a two-register, one immediate version. For example, is the three-register version of addition, while is the immediate version. There isn‚Äôt a though, since you can just use negative immediates with .\n\nand are not actual instructions in RISC-V, but pseudoinstructions: encodes as , while becomes .\n\nMost instruction sets also have bit shifts, usually in three flavors: left shifts, right shifts, and arithmetic right shifts; arithmetic right shift is defined such that it behaves like division by powers of two on signed integers. RISC-V‚Äôs names for these instructions are , , and .\n\nMultiplication and division are somewhat rarer, because they are expensive to implement in silicon; smaller devices don‚Äôt have them. Division in particular is very complex to implement in silicon. Instruction sets usually have different behavior around division by zero: some architectures will fault, similar to a memory error, while some, like RISC-V, produce a well-defined trap value.\n\nThere is usually also a ‚Äúcopy‚Äù instruction that moves the value of one register to another, which is kind of like a trivial arithmetic instruction. RISC-V calls this , but it‚Äôs just a pseudoinstruction that expands to .\n\nSome architectures also offer more exotic arithmetic. This is just a sampler of what‚Äôs sometimes available:\n‚Ä¢ Bit rotation, which is like a shift but bits that get shifted off end up at the other end of the integer. This is useful for a vast array of numeric algorithms, including ARX ciphers like ChaCha20.\n‚Ä¢ Byte reversal, which can be used for changing the endianness of an integer; bit reversal is analogous.\n‚Ä¢ Bit extraction, which can be used to form new integers out of bitfields of another.\n‚Ä¢ Carry-less multiplication, which is like long multiplication but you don‚Äôt bother to carry anything when you add intermediates. This is used to implement Galois/Counter mode encryption.\n\nThere is also a special kind of arithmetic instruction called a vector instruction, but I‚Äôll leave those for another time.\n\nLoad instructions fetch memory from RAM into registers, while store instructions write it back. These instructions are what we use to implement pointers.\n\nThey come in all sorts of different sizes: RISC-V has , , and for loading 32-, 16-, and 8-bit values from a location; , , and are their store counterparts. 64-bit RISC-V also provides and for 64-bit loads and stores.\n\nLoad/store instructions frequently take an offset for indexing into memory. is effectively , treating like a pointer.\n\nThese instructions frequently have an alignment constraint: the pointer value must (or, at least, should) be divisible by the number of bytes being loaded. RISC-V, for example, mandates that only be used on pointers divisible by 4. This constraint simplifies the microarchitecture; even on architectures that don‚Äôt mandate it, aligned loads and stores are typically far faster.\n\nThis category also includes instructions necessary for implementing atomics, such as on x86 and / on RISC-V. Atomics are fundamentally about changing the semantics of reading and writing from RAM, and thus require special processor support.\n\nSome architectures, like x86, 65816, and very recently, ARM, provide instructions that implement and its ilk in hardware: in x86, for example, this is called .\n\nControl flow is the secret ingredient that turns our glorified calculator into a Turing tarpit: they allow changing the flow of program execution based on its current state.\n\nUnconditional jumps implement : given some , the instruction jumps directly to it. can be thought of as writing to a special register that holds the program counter. RISC-V also provides a dynamic jump, , which will jump to the address in a register. Function calls and returns are a special kind of unconditional jump.\n\nConditional jumps, often called branches, implement . will jump to if and contain the same value. RISC-V provides branch instructions for all kinds of comparisons, like , , and .\n\nConditional and unconditional jumps can be used together to build loops, much like we could in C using and .\n\nFor example, to zero a region of memory:\n\n‚ÄúEverything else‚Äù is, well‚Ä¶ everything else.\n\nNo-op instructions do nothing: ‚Äôs only purpose is to take up space in the instruction stream. No-op instructions can be used to pad space in the instruction stream, provide space for the linker to fix things up later, or implement sleds.\n\nInstructions for poking processor state, like in RISC-V and in also belong in this category, as do ‚Äúhinting‚Äù instructions like memory prefetches.\n\nThere are also instructions for special control flow: is RISC-V‚Äôs ‚Äúsyscall‚Äù instruction, which ‚Äútraps‚Äù to the kernel for it to do something; other architectures have similar instructions.\n\nBreakpoint instructions and ‚Äúfence‚Äù instructions belong here, too.\n\nFunctions are the core abstraction of all of programming. Assembly is no different: we have functions there, too!\n\nLike in any language, functions are passed a list of arguments, perform some work, and return a value. For example, in C:\n\nUnfortunately, there isn‚Äôt anything like function call syntax in assembly. As with everything else, we need do it instruction by instruction. All we do get in most architectures is a instruction, which sets up a return address somewhere, and a instruction, which uses the return address to jump to where the function was called.\n\nWe need some way to pass arguments, return a computed value, and maintain a call stack, so that each function‚Äôs return address is kept intact for its instruction to consume. We also need this to be universal: if I pull in a library, I should be able to call its functions.\n\nThis mechanism is called the calling convention of the platform‚Äôs ABI. It‚Äôs a convention, because all libraries must respect it in their exposed API for code to work correctly at runtime.\n\nAt the instruction level, function calls look something like this:\n‚Ä¢ Pre-call setup. The caller sets up the function call arguments by placing them in the appointed locations for arguments. These are usually either registers or locations on the stack. a. The caller also saves the caller-saved registers to the stack.\n‚Ä¢ Jump to the function. The caller executes a instruction (or whatever the function call instruction might be called ‚Äì virtually all architectures have one). This sets the program counter to the first instruction of the callee.\n‚Ä¢ Function prologue. The callee does some setup before executing its code. a. The callee reserves space on the stack in an architecture-dependent manner. b. The callee saves the callee-saved registers to this stack space.\n‚Ä¢ Function body. The actual code of the function runs now! This part of the function needs to make sure the return value winds up wherever the return slot for the function is.\n‚Ä¢ Function epilogue. The callee undoes whatever work it did in the prologue, such as restoring saved registers, and executes a (or equivalent) instruction to return.\n‚Ä¢ Post-call cleanup. The caller is now executing again; it can unspill any saved state that it needs immediately after the function call, and can retrieve the return value from the return slot. In some ABIs, such as C++‚Äôs on Linux, this is where the destructors of the arguments get run. (Rust, and C++ on Windows, have callee-destroyed arguments instead.)\n\nWhen people say that function calls have overhead, this is what they mean. Not only does the instruction cause the processor to slam the breaks on its pipeline, causing all kinds of work to get thrown away, but state needs to be delicately saved and restored across the function boundary to maintain the illusion of a callstack.\n\nSmall functions which don‚Äôt need to use as many registers can avoid some of the setup and cleanup, and leaf functions which don‚Äôt call any other functions can avoid basically all of it!\n\nAlmost all registers in RISC-V are caller-saved, except for and the ‚Äúsaved‚Äù registers and .\n\nCallee-saved registers are convenient, because they won‚Äôt be wiped out by function calls. We can actually see the call to use this: even though the compiler could have emitted and avoided the , this is actually less optimal. We need to keep the value around to return, and is caller-saved, so we would have had to spill before calling , regardless of whether overwrites or not. We would then have to unspill it into before . This costs us a hit to RAM. However, by emitting , we speculatively avoid the spill: if is compiled such that it never touches , the value never leaves registers at all!\n\nWe can see steps 1 and 2 in the call to :\n\nArguments in the usual RISC-V calling convention, word-sized arguments are passed in the through registers, falling back to passing on the stack if they run out of space. If the argument is too big to fit in a register, it gets passed by reference instead. Arguments that fit into two registers can be split across registers.\n\nWe can see this in action above. The first argument, a string, is passed by pointer in ; and do the work of actually putting that pointer into . The second argument is passed in , copied from where it landed from the earlier instruction.\n\nComplex function signatures require much more work to set up.\n\nOnce we‚Äôre done getting arguments into place, we , which switches execution over to ‚Äôs first instruction. In addition, it stores the return address, specifically, the address of the instruction immediately after the , into an architecture-specific location. On RISC-V, this is the special register .\n\nMeanwhile, steps 3 and 4 occur in ‚Äôs prologue/epilogue itself:\n\n, which we stared at so hard above, grows the stack by 16 bytes. holds the stack pointer, which points to the top of the stack at all times. The stack grows downwards (as in most architectures!) and must be aligned to 16-byte boundaries across function calls: even though only uses eight of those bytes, the full 16 bytes must be allocated.\n\nThe two instructions that follow store (or ‚Äúspill‚Äù) the callee-saved registers and to the stack. Note that through are not spilled, since doesn‚Äôt use them!\n\nTh this point, the function does its thing, whatever that means. This includes putting the return value in the return slot, which, for a function that returns an , is in . In general, the return slot is passed back to the caller much like arguments are: if it fits in registers, and are used; otherwise, the caller allocates space for it and passes a pointer to the return slot as a hidden argument (in e.g. ).\n\nThe epilogue inverts all operations of the prologue in reverse, unspilling registers and shrinking the stack, followed by . On RISC-V, all does is jump to the location referred to by the register.\n\nOf course, all this work is only necessary to maintain the illusion of a callstack; if were a leaf function, it would not need to spill anything at all! This results in an almost trivial function:\n\nBecause leaf functions won‚Äôt call other functions, they won‚Äôt need to save the caller-saved registers, so they can freely use them instead of the registers.\n\nThe End, for Now\n\nPhew! We‚Äôre around six thousand words in, so let‚Äôs checkpoint what we‚Äôve learned:\n‚Ä¢ Computers are stupid, but can at least follow extremely basic instructions, which are encoded as binary.\n‚Ä¢ Assembly language is human-readable version of these basic instructions for a particular computer.\n‚Ä¢ Each instruction is a mnemonic followed by zero or more operands.\n‚Ä¢ Registers hold values the machine is currently operating on.\n‚Ä¢ Instructions can be broadly categorized as arithmetic, memory, control flow, and ‚Äúmiscellaneous‚Äù (plus vector and float instructions, for another time).\n‚Ä¢ The calling convention describes the low-level interface of a general function, consisting of some pre-call setup, and a prologue and epilogue in each function.\n\nThat‚Äôs all for now. RISC-V is a powerful but reasonably simple ISA. Next time, we‚Äôll dive into the much older, much larger, and much more complex Intel x86."
    },
    {
        "link": "https://shakti.org.in/docs/risc-v-asm-manual.pdf",
        "document": ""
    },
    {
        "link": "https://projectf.io/posts/riscv-load-store",
        "document": "This RISC-V assembler post covers load and store instructions, such as lw, sw, and lbu. We also cover memory alignment, addressing modes, and loading symbol addresses. Load and store instructions are included in RV32I, the base integer instruction set.\n\nIn the last few years, we‚Äôve seen an explosion of RISC-V CPU designs on FPGA and ASIC, including the RP2350 found on the Raspberry Pi Pico 2. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions and programming.\n\nRISC-V Assembler: Arithmetic | Logical | Shift | Load and Store | Branch and Set | Jump and Function | Multiply and Divide | Compiler Explorer | Assembler Cheat Sheet\n\nRISC-V is a load-store architecture: load and store instructions access memory, while other instructions work with CPU registers. A load reads a value from memory into a register. A store writes a value from a register into memory.\n\nRV32 is a 32-bit architecture, and all arithmetic is performed on 32-bit words (there‚Äôs no ‚Äúbyte add‚Äù instruction, for example). However, loads and stores support 8 and 16-bit data as programmers commonly work with 8 and 16-bit data, such as text.\n\nRISC-V uses consistent names and one-letter abbreviations for data sizes:\n\nBeing familiar with these one-letter abbreviations is a great help in understanding loads and stores.\n\nProTip: A word is always 32 bits wide, even on 64-bit RISC-V (RV64).\n\nLoad instructions have a consistent format that we‚Äôll illustrate with load word:\n\nWhere rd is the destination register, source register rs1 holds the memory address, and imm is an address offset. The offset is a 12-bit signed immediate, so can reach addresses -2048 to +2047 bytes from the the address in rs1.\n\nFor example, if we want to load the word at address 0x140 into register t0:\n\nt0 is loaded with the word at address 0x140.\n\nTo load the next word, we increase the address by 4 because addresses are in units of bytes:\n\nt1 is loaded with the word at address 0x144.\n\nHalves and bytes work in the same way, but the value is sign-extended:\n\nt2 is loaded with the half word at address 0x146. t3 is loaded with the byte at address 0x147.\n\nThanks to sign extension, a byte in memory with the value -1 retains the correct value when loaded into a register. See arithmetic sign extension for a reminder of how sign extension works.\n\nRISC-V includes unsigned load half and byte to handle unsigned data, such as UTF-8 text:\n\nUnsigned loads zero-fill the upper part of the register.\n\nThe store instructions are straightforward because there‚Äôs no need to worry about sign extension:\n\nStore instructions look like the equivalent load instructions:\n\nWhere rs2 is the source register, rs1 holds the memory address, and imm is an address offset.\n\nNote how the source register is the first operand, which makes stores like loads but is different from other RISC-V instructions. This is best seen with some examples:\n\nMemory location 0x140 now contains a word with the value 42 (0x0000002A).\n\nIf we want to zero a word of memory, we can store the zero (x0) register to it:\n\nHalves and bytes work in the same way, storing the least significant 16 or 8 bits to memory:\n\nWhat state is our memory now in? A good way to think about this is to ask what happens if we load a word from memory address 0x144?\n\nThe answer hinges on RISC-V being little endian. A little-endian CPU stores the least significant byte at the lowest address. x86 and ARM are also little endian.\n\nOur sh instruction puts the least significant byte, 0xCE, at address 0x144 and the most significant byte, 0xFA, at address 0x145.\n\nThe following sb instruction puts 0xCE at address 0x146. 0x147 is still zero from the previous ‚Äúsw zero‚Äù instruction.\n\nAfter this load, t1 contains 0x00CEFACE.\n\nMost of the time, you‚Äôll be accessing data as either words or bytes, in which case you needn‚Äôt worry about RISC-V being little endian.\n\nThis is a cursory look at endianness, but there‚Äôs plenty of material online. Wikipedia‚Äôs Endianness article is a decent place to start.\n\nThe load and store instructions require a memory address, but what if you want to reference a symbol? This sounds too abstract, so let‚Äôs look at a concrete example let‚Äôs say ‚ÄúHello, World!‚Äù.\n\nWe put our greeting string in the data section with the .ascii assembler directive:\n\nImagine a function called that displays a null-terminated string. We need to pass the address of our greeting string from the data section, but we don‚Äôt know the address!\n\nThe la (load address) pseudoinstruction comes to our rescue:\n\nNote how we pass the (first) argument to a function in register a0. See my post covering function calls for an explanation of the RISC-V calling convention.\n\nRISC-V uses byte addressing, the norm for all general-purpose CPUs. With byte addressing, you can access an individual byte in memory even with a 32 or 64-bit CPU.\n\nWe‚Äôre so used to thinking of data sizes in bytes that we rarely stop to think about it, but there‚Äôs no fundamental reason we should divide data into 8-bit chunks. If a CPU is 32-bit, why not address memory in units of 32-bit words? Word addressing would be simpler, and a 32-bit CPU could access 16 GiB or memory vs 4 GiB with byte addressing.\n\nHowever, the dominant UTF-8 text encoding is byte-based and with good reason. CPU performance depends on cache hits, so efficient storage of frequently used data, such as text, is essential.\n\nThe upshot of byte addressing is that if you want to move to the next word, you must add 4 to the address. On 64-bit CPUs, you add 8 to get to the next double word. Accidentally adding 1, rather than 4, to a memory address is a common source of bugs in my personal experience. üòÖ\n\nRemember, the load and store memory offset is a signed 12-bit value, so you can access memory locations between -2048 and +2047 bytes from the base address in the register.\n\nRISC-V doesn‚Äôt require data to be naturally aligned; for example, words don‚Äôt have to be on a 4-byte boundary. However, not all CPUs support misaligned memory access, and it‚Äôs invariably slower on those that do support it. I strongly recommend using natural alignment for your data.\n\nYour code should be correctly aligned by the compiler. You can align your data with the GNU assembler .balign assembler directive.\n\nFor example, to align the word with the label ‚Äúfoo‚Äù to a 4-byte boundary:\n\nNB. The alignment directive applies to the label, so it must appear before the label (not the data)!\n\nAn addressing mode is how the CPU calculates a memory address. With x86 and 68K, the smart use of addressing modes is critical to writing good code. With RISC-V, addressing modes aren‚Äôt really a thing. I will stick my neck out a little and say RISC-V has three addressing modes, but it‚Äôs not something you usually need to consider.\n\nPC is the program counter, which keeps track of where the CPU is within the code. In x86 land, this is known as the instruction pointer (IP), which is frankly a much better name. We‚Äôll learn more about the program counter when we discuss branches.\n\nIncluding variations, the Motorola 68000 has 14 addressing modes! For example address register indirect with post-increment. These help you write compact assembly code but complicate the CPU design. I love 68000 assembler, but I appreciate the simplicity of RISC-V.\n\nThe next post looks at RISC-V Branch and Set Instructions, including the zero register.\n\nCheck out the RISC-V Assembler Cheat Sheet and my FPGA & RISC-V Tutorials.\n\nGet in touch on Mastodon, Bluesky, or X. Enjoy my work? Please sponsor me. üôè"
    },
    {
        "link": "https://cse.iitd.ac.in/~srsarangi/archbook/chapters/riscv.pdf",
        "document": ""
    },
    {
        "link": "https://riscv.org/specifications/ratified",
        "document": ""
    },
    {
        "link": "https://cs.brown.edu/courses/csci1952y/2024/assets/docs/riscv-spec-v2.2.pdf",
        "document": ""
    },
    {
        "link": "https://content.riscv.org/wp-content/uploads/2019/06/riscv-spec.pdf",
        "document": ""
    },
    {
        "link": "https://taintedbits.com/2023/07/09/exploring-the-fundamentals-of-RISC-V-assembly-and-shellcode-series-part1",
        "document": "In the ever-evolving landscape of computer architecture, RISC-V has emerged as a promising and disruptive force. With its open-source nature and elegant design philosophy, RISC-V has garnered significant attention from both academia and industry alike. Unlike proprietary architectures, RISC-V is an open-source instruction set architecture (ISA) that provides unrestricted access to its specifications. This openness has spurred innovation, encouraging a flourishing ecosystem of developers, researchers, and companies to contribute to its development. Recent statistics indicate a surge in the adoption of RISC-V architecture, serving as a testament to its growing popularity. According to industry reports, the shipment of RISC-V-based devices reached an astounding 1 billion units in 2022 alone, marking a significant milestone for this emerging technology.\n\nGiven the growing popularity of RISC-V in the embedded systems market, it becomes crucial to address the potential security risks associated with the increasing number of devices. This blogpost series aims to provide a comprehensive exploration of RISC-V assembly language fundamentals, enabling readers to understand its core concepts and functionalities. We will begin by delving into the basics of RISC-V assembly, laying a solid foundation for subsequent discussions. In future blog posts, we will focus on setting up the development environment and tools required for writing and compiling assembly code. Furthermore, we will explore practical examples such as crafting basic shellcode and testing it on simple buffer overflow vulnerabilities. Additionally, we will dive into the creation of various shellcode variations, including shell spawning and reverse TCP shells, to expand our understanding and practical skills in this domain.\n\nRISC-V is an open-source instruction set architecture (ISA) that is designed to be simple, modular, and extensible. It was developed at the University of California, Berkeley, and has gained significant attention and adoption in both academia and industry.\n‚Ä¢ Instruction Set: RISC-V follows the Reduced Instruction Set Computing (RISC) philosophy, which means it has a minimalistic and streamlined set of instructions. The base RISC-V instruction set is divided into several standard instruction sets, ranging from a small subset suitable for embedded systems to more comprehensive sets for general-purpose computing.\n‚Ä¢ Bit Widths: RISC-V supports both 32-bit and 64-bit instruction set variants. The 32-bit variant is commonly used in resource-constrained embedded systems, while the 64-bit variant provides increased address space and computational capabilities for general-purpose computing.\n‚Ä¢ Register File: RISC-V has a standard set of general-purpose registers, typically 32 in number for 32-bit variants and 64 for 64-bit variants. These registers are used to hold data during program execution and serve as the primary operands for arithmetic and logical operations.\n‚Ä¢ Memory Model: RISC-V employs a simple and flexible memory model. It supports a flat memory space where data and instructions are stored. Memory accesses are performed through load and store instructions, which transfer data between registers and memory.\n‚Ä¢ Exception Handling: RISC-V provides mechanisms for handling exceptions, such as interrupts, system calls, and other events that require special attention. The architecture defines a set of exception codes and specifies how the processor should respond to these events.\n‚Ä¢ Privilege Levels: RISC-V supports multiple privilege levels to enforce different levels of access and protection. These levels include user mode, supervisor mode, and machine mode. Each privilege level has its own set of instructions and privileges.\n\nRISC-V instructions are divided into different formats based on their structure and operand types. The most common formats include:\n‚Ä¢ R-type: Used for arithmetic and logical operations, which involve two source registers and one destination register.\n‚Ä¢ I-type: Used for immediate operations, where one operand is a register and the other is an immediate value.\n‚Ä¢ S-type: Used for store operations, which store data from a register into memory.\n‚Ä¢ B-type: Used for branch operations, which perform conditional jumps based on comparison results.\n‚Ä¢ U-type: Used for unconditional jumps and instruction-level constants.\n‚Ä¢ J-type: Used for jump operations with a signed immediate offset.\n\nBasic RISC-V instructions cover a range of operations such as arithmetic, logical, memory access, and control flow. Here are some examples of common RISC-V instructions along with their syntax:\n‚Ä¢ \n‚Ä¢ ADD: Adds two registers and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ SUB: Subtracts one register from another and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ ADDI: Adds an immediate value to a register and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ \n‚Ä¢ AND: Performs bitwise AND between two registers and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ OR: Performs bitwise OR between two registers and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ XOR: Performs bitwise XOR between two registers and stores the result in a destination register.\n\n Syntax:\n‚Ä¢ \n‚Ä¢ JAL: Jumps to a target address and stores the return address in a register.\n\n Syntax:\n‚Ä¢ JALR: Jumps to a target address with a register offset and stores the return address in a register.\n\n Syntax:\n‚Ä¢ BEQ: Branches to a target address if two registers are equal.\n\n Syntax:\n‚Ä¢ BNE: Branches to a target address if two registers are not equal.\n\n Syntax:\n\nThese examples represent just a subset of the basic instructions available in RISC-V. The syntax follows a common pattern where rd represents the destination register, rs1 and rs2 are the source registers, imm denotes an immediate value, and offset specifies an offset from a base register.\n\nIt‚Äôs important to consult the official RISC-V documentation and specific implementation‚Äôs instruction set reference for a comprehensive list of instructions and their precise syntax, as it may vary based on the specific RISC-V variant or extension being used.\n\nLoad and store instructions in RISC-V are used to transfer data between the processor‚Äôs registers and memory. These instructions play a vital role in reading and writing data, facilitating data manipulation and program execution. Here‚Äôs an explanation of load and store instructions in RISC-V:\n‚Ä¢ Load Instructions: Load instructions fetch data from memory and store it in a register. They allow the processor to access data stored in memory for subsequent processing or use. Common load instructions in RISC-V include:\n‚Ä¢ LW (Load Word): Loads a 32-bit word from memory into a register.\n\n Syntax: LW rd, offset(rs1)\n\n Example:\n‚Ä¢ LH (Load Halfword): Loads a 16-bit halfword from memory into a register.\n\n Syntax: LH rd, offset(rs1)\n\n Example:\n‚Ä¢ LB (Load Byte): Loads an 8-bit byte from memory into a register.\n\n Syntax: LB rd, offset(rs1)\n\n Example: \n\n Load instructions typically require specifying the destination register (rd), the memory address obtained by adding an immediate offset to the base register (offset(rs1)).\n‚Ä¢ Store Instructions: Store instructions transfer data from registers to memory. They allow the processor to write data back to memory for storage or output purposes. Common store instructions in RISC-V include:\n‚Ä¢ SW (Store Word): Stores a 32-bit word from a register into memory.\n\n Syntax: SW rs2, offset(rs1)\n\n Example:\n‚Ä¢ SH (Store Halfword): Stores a 16-bit halfword from a register into memory.\n\n Syntax: SH rs2, offset(rs1)\n\n Example:\n‚Ä¢ SB (Store Byte): Stores an 8-bit byte from a register into memory.\n\n Syntax: SB rs2, offset(rs1)\n\n Example: \n\n Store instructions require specifying the source register (rs2), the memory address obtained by adding an immediate offset to the base register (offset(rs1)).\n\nIn load and store instructions, ‚Äòrd‚Äô represents the destination or source register, ‚Äòrs1‚Äô is the base register that holds the memory address, ‚Äòoffset‚Äô specifies the offset from the base address, and ‚Äòrs2‚Äô is the register containing the data to be stored.\n\nIt‚Äôs important to note that memory access in RISC-V is typically aligned, meaning that data is accessed on word boundaries (32-bit or 4-byte alignment). Unaligned access may lead to performance penalties or even exceptions on certain RISC-V implementations.\n\nLoad and store instructions are fundamental for manipulating data in RISC-V programs and are used extensively in various applications, including data processing, data storage, and communication with external devices.\n\nControl transfer instructions in RISC-V are used to alter the flow of program execution by changing the order of instructions or redirecting the program to a different location. These instructions enable branching, looping, and subroutine calls. Here‚Äôs an explanation of control transfer instructions in RISC-V:\n‚Ä¢ Unconditional Jump Instructions: Unconditional jump instructions transfer control unconditionally to a target address. The most commonly used unconditional jump instruction in RISC-V is:\n‚Ä¢ JAL (Jump and Link): Jumps to a target address and stores the return address (address of the instruction following the JAL) into a register.\n\n Syntax: \n\n Example:\n‚Ä¢ Conditional Branch Instructions: Conditional branch instructions allow branching based on a specific condition. They evaluate the condition and decide whether to perform a jump or continue with the next sequential instruction. Some common conditional branch instructions in RISC-V are:\n‚Ä¢ BEQ (Branch if Equal): Branches to a target address if two registers are equal.\n\n Syntax: \n\n Example:\n‚Ä¢ BNE (Branch if Not Equal): Branches to a target address if two registers are not equal.\n\n Syntax: \n\n Example:\n‚Ä¢ BLT (Branch if Less Than): Branches to a target address if one register is less than another.\n\n Syntax: \n\n Example:\n‚Ä¢ BGE (Branch if Greater Than or Equal): Branches to a target address if one register is greater than or equal to another.\n\n Syntax: \n\n Example:\n‚Ä¢ Jump and Link Register Instructions: Jump and link register instructions perform a jump to a target address and store the return address in a register. Unlike unconditional jumps, these instructions allow for subroutine calls and enable the program to return to the instruction following the jump. One such instruction in RISC-V is:\n‚Ä¢ JALR (Jump and Link Register): Jumps to a target address computed as the sum of a register and an immediate offset and stores the return address in a register.\n\n Syntax: \n\n Example:\n\nControl transfer instructions are essential for implementing conditional statements, loops, and function calls in RISC-V assembly language. They provide the ability to control the flow of execution and create flexible program structures.\n\nIt‚Äôs important to consider the branching offsets in control transfer instructions, as they are relative to the current program counter and may need to be calculated accordingly.\n\nUnderstanding control transfer instructions enables programmers to create complex program structures and implement control flow logic in RISC-V assembly programs.\n\nSystem call instructions in RISC-V allow programs to interact with the operating system and request specific services or functionalities. These instructions provide a mechanism for user-level programs to access privileged operations, such as file I/O, process management, and input/output operations. Here‚Äôs an explanation of system call instructions in RISC-V:\n\nECALL (Environment Call): The ECALL instruction is used to invoke a system call and transfer control to the operating system. It provides a way for user-level programs to request services from the underlying operating system. The specific system call number and arguments are typically passed through predefined registers.\n\nRISC-V follows a convention for passing system call arguments and receiving results. The arguments for a system call are typically passed in specific registers, such as a0, a1, a2, a3, and so on. The return value of a system call is stored in the a0 register.\n\nThe specific mapping of system call numbers to their corresponding services varies depending on the operating system and its RISC-V implementation. Developers should consult the operating system documentation or relevant system call reference for the specific system call numbers and their corresponding functionality.\n\nExamples of System Calls:\n\n The available system calls and their functionality depend on the operating system. Some common system call services include:\n‚Ä¢ File I/O: Opening, reading from, writing to, and closing files.\n‚Ä¢ Input/Output: Reading from and writing to standard input/output.\n‚Ä¢ Networking: Performing network-related operations, such as socket creation and data transfer.\n\nThe exact system call instructions and their arguments can vary depending on the operating system and the specific RISC-V implementation used.\n\nUnderstanding system call instructions allows programmers to leverage the services provided by the operating system and access privileged operations from user-level programs. It enables interaction with the underlying system and facilitates the development of complex and feature-rich applications on the RISC-V platform.\n\nAddressing modes in RISC-V determine how memory addresses are calculated for load and store instructions. These modes define how the base address, offset, and index registers are combined to form the effective memory address. RISC-V supports various addressing modes to provide flexibility and efficient memory access. Here‚Äôs an explanation of addressing modes in RISC-V:\n‚Ä¢ Immediate Addressing: In immediate addressing mode, the memory address is formed by adding an immediate value to a base register. The immediate value is a constant value specified directly in the instruction. Example: \n\n In this mode, the memory address is formed by adding the immediate value ‚Äòimm‚Äô to the base register ‚Äòrs1‚Äô.\n‚Ä¢ Register Addressing: Register addressing mode uses a register to hold the memory address directly. The memory address is obtained from the contents of the register without any additional calculation. Example: LW rd, (rs1)\n\n In this mode, the memory address is directly obtained from the register ‚Äòrs1‚Äô.\n‚Ä¢ Base or Offset Addressing: Base or offset addressing mode combines a base register and an immediate offset value to calculate the memory address. Example: \n\n In this mode, the memory address is obtained by adding the immediate offset ‚Äòoffset‚Äô to the base register ‚Äòrs1‚Äô.\n‚Ä¢ Indexed Addressing: Indexed addressing mode combines a base register, an index register, and an immediate offset to calculate the memory address. The offset is added to the sum of the base register and the index register to form the effective address. Example: \n\n In this mode, the memory address is obtained by adding the immediate offset ‚Äòoffset‚Äô to the sum of the base register ‚Äòrs1‚Äô and the index register ‚Äòrs2‚Äô.\n\nRISC-V addressing modes provide flexibility for accessing memory and enable efficient data retrieval. They allow for direct access, indexing, and offset calculations based on the requirements of the program. The choice of addressing mode depends on the specific memory access pattern, data structure, and optimization considerations.\n\nIt‚Äôs important to consult the official RISC-V documentation and specific implementation‚Äôs instruction set reference for the supported addressing modes and their corresponding syntax, as it may vary based on the specific RISC-V variant or extension being used.\n\n#Working with arrays and data structures in RISC-V assembly\n\nWorking with arrays and data structures in RISC-V assembly involves effectively manipulating and accessing elements stored in memory. Arrays and data structures provide a way to organize and represent collections of related data. Here‚Äôs an elaboration on working with arrays and data structures in RISC-V assembly:\n‚Ä¢ Array Access: Arrays consist of a contiguous block of elements of the same data type. To access individual elements within an array, you need to calculate the memory address of each element. RISC-V assembly provides addressing modes, such as immediate, register, base+offset, or indexed addressing, to facilitate array access. Example: Accessing elements of an array in RISC-V assembly: Assume the array starts at address array_base nd each element occupies 4 bytes (word) \n\n \n\n By incrementing the offset, you can access successive elements in the array.\n‚Ä¢ Data Structures: Data structures, such as structs or records, allow grouping related data of different types into a single unit. In RISC-V assembly, you can access the individual fields of a data structure using byte offsets or structure offsets. Example: Accessing fields of a data structure in RISC-V assembly: By adding the appropriate byte offset to the base address, you can access specific fields within the data structure.\n‚Ä¢ Iterating Over Arrays and Data Structures: Iterating over arrays and data structures typically involves using loops. You can use branch instructions to implement loops and maintain a loop counter to iterate through the elements or fields. Example: Looping over an array in RISC-V assembly: # Assume array_size holds the size of the array \n\n \n\n \n\n \n\n \n\n # ... Do operations with the element ... \n\n \n\n J Loop # Jump back to the beginning of the loop \n\n \n\n By manipulating the loop counter, you can access and perform operations on each element within the array or fields within a data structure.\n\nWorking with arrays and data structures in RISC-V assembly requires careful management of memory addresses, appropriate offsets, and loop control. Understanding addressing modes, memory layout, and control flow enables efficient manipulation and traversal of structured data in RISC-V assembly programs.\n\nHere‚Äôs a simple program in C that calculates the sum of two numbers:\n\nNow, let‚Äôs disassemble this C program into RISC-V assembly code using a disassembler:\n\nThe disassembled RISC-V assembly code represents the C program‚Äôs functionality translated into the corresponding assembly instructions. You can observe the instructions such as , which perform operations like loading and storing values, arithmetic calculations, moving values between registers, and invoking system calls like printf.\n\nNote: The specific assembly instructions and register usage may vary depending on the RISC-V toolchain and options used for compilation and disassembly.\n\nRemember that the disassembled code represents the low-level assembly representation of the C program, allowing you to understand the underlying instructions executed by the processor.\n\nIn conclusion, this blog post has presented an introductory overview of RISC-V assembly language, highlighting its fundamental role in programming for RISC-V processors. We explored essential aspects such as the instruction set architecture, registers, instruction formats, and assembly directives. Acquiring a solid understanding of RISC-V assembly empowers developers and researchers to leverage the full potential of RISC-V architectures, optimize system performance, and build secure and efficient systems. Moreover, by delving into the intricacies of RISC-V assembly, security researchers can deepen their comprehension of the inner workings of these processors, enabling them to effectively address the evolving landscape of RISC-V technology and the associated threats it may face. In the next post will look into how to write and compile the assembly code."
    },
    {
        "link": "https://sifive.com/blog/all-aboard-part-4-risc-v-code-models",
        "document": "The RISC-V ISA was designed to be both simple and modular. In order to achieve these design goals, RISC-V minimizes one of the largest costs in implementing complex ISAs: addressing modes. Addressing modes are expensive both in small designs (due to decode cost) and large designs (due to implicit dependencies). RISC-V only has three addressing modes:\n‚Ä¢ PC-relative, via the , and instructions.\n‚Ä¢ Register-offset, via the , and all memory instructions.\n‚Ä¢ Absolute, via the instruction (though arguably this is just -offset).\n\nThese addressing modes have been carefully selected in order to allow for efficient code generation with a minimum of hardware complexity. We achieve this simplicity by relying on modern toolchains to optimize addressing in software -- this stands in stark contrast to traditional ISAs, which implement a plethora of addressing modes in hardware instead. Studies have shown that the RISC-V approach is sound: we are able to achieve similar code size in benchmarks while having vastly simpler decoding rules and a significant amount of free encoding space.\n\nAll these hardware complexity reductions come at the cost of increased software complexity. This blog post introduces another bit of software complexity in RISC-V: the concept of a code model. Just like relocations and relaxations, code models are not specific to RISC-V -- in fact, the RISC-V toolchain has fewer code models than most popular ISAs, largely because we rely on software optimizations instead of wacky addressing modes, which allows our addressing modes to be significantly more flexible.\n\nMost programs do not fill the entire address space available to them with symbols (most don't fill it at all, but those that do tend to fill their address space with heap). ISAs tend to take advantage of this locality by implementing shorter addressing modes in hardware and relying on software to provide larger address modes. The code model determines which software addressing mode is used, and, therefore, what constraints are enforced on the linked program. Software addressing modes determine how the programmer sees addresses, as opposed to hardware addressing modes which determine how address bits in instructions are handled.\n\nCode models are necessary due to the split between the compiler and the linker: when generating an unlinked object, the compiler doesn't know the absolute address of any symbol but it still must know what addressing mode to use as some addressing modes may require scratch registers to operate. As the compiler cannot generate actual addressing code, it generates addressing templates (known as relocations) that the linker can then fix up once it knows the actual addresses of each symbol. The code model determines what these addressing templates look like, and thus which relocations are emitted.\n\nThis is probably best explained with an example. Imagine the following C code:\n\nEven though a single GCC invocation can produce a binary for this simple case, under the covers the GCC driver script is actually running the preprocessor, then the compiler, then the assembler and finally the linker. The argument to GCC allows users to see all these intermediate files, and is a useful argument for poking around inside the toolchain.\n\nEach step in this run of the GCC wrapper script generates a file:\n‚Ä¢ : The preprocessed source, which expands any preprocessor directives (things like or ).\n‚Ä¢ : The output of the actual compiler, which is an assembly file (a text file in the RISC-V assembly format).\n‚Ä¢ : The output of the assembler, which is an unlinked object file (an ELF file, but not an executable ELF).\n‚Ä¢ : The output of the linker, which is a linked executable (an executable ELF file).\n\nIn order to understand why the code model exists, we must first examine this toolchain flow in a bit more detail. Since this is a simple source file with no preprocessor macros, the preprocessor run is pretty boring: all it does is emit some directives to be used if debugging information is later generated:\n\nThe preprocessed output is then fed through the compiler, which generates an assembly file. This file is plain text that contains RISC-V assembly code and therefore is easy to read:\n\nThe generated assembly contains a pair of instructions to address : and then . This imposes a constraint on the address that can take on: it must be addressable by a 32-bit signed absolute constant (not 32-bit offset from some register or the PC, but actually a 32-bit address). Note that the restriction on symbol addresses is not related to the size of a pointer on this architecture: specifically pointers may still be 64 bits here, but all global symbols must be addressable by a 32-bit absolute address.\n\nAfter the compiler generates assembly, the GCC wrapper script calls the assembler to generate an object file. This file is an ELF binary, which can be read with a variety of tools provided by Binutils. In case we'll use to show the symbol table, disassemble the text section and show the relocations generated by the assembler:\n\nAt this point we have an object file, but we still don't know the actual addresses of any global symbols. This is where there's a bit of overlap in the roles of each component of the toolchain: it's the assembler's job to convert textual instructions into bits, but in the cases where those bits depend on the address of a global symbol (like the in the code above, for example) the assembler can't know what those bits should actually be. In order to allow the linker to fill out these bits in the final executable object file, the assembler generates entries in a relocation table for every bit range the linker is expected to fill out. Relocations define a bit range that the linker is meant to fill out when linking the code together. The specific definition of any relocation type present in the text section is ISA-specific, the RISC-V definitions can be found in our ELF psABI document.\n\nAfter assembling the program, the GCC wrapper script runs the linker to generate an executable. This is another ELF file, but this time it's a full executable. Since this contains lots of C library code, I'm going to show only the relevant fragments of it here:\n\nThere are a few interesting things to note here:\n‚Ä¢ The symbol table contains symbols with actual, absolute values. This is the whole point of the linker.\n‚Ä¢ The text section contains the correct bits to actually reference the global symbols, as opposed to just a bunch of 0s.\n‚Ä¢ The relocations against global symbols have been removed, as they're no longer necessary. Some relocations may still exist in executables to allow for things like dynamic linking, but in this simple case there are none.\n\nUntil now, this example has been using RISC-V's default code model medlow. In order to demonstrate a bit more specifically what a code model is it's probably best to contrast this with our other code model, medany. The difference can be summed up with a single example output:\n\nSpecifically, the medany code model generates / pairs to refer to global symbols, which allows the code to be linked at any address; while medlow generates / pairs to refer to global symbols, which restricts the code to be linked around address zero. They both generate 32-bit signed offsets for referring to symbols, so they both restrict the generated code to being linked within a 2GiB window.\n\nWhat does -mcmodel=medlow mean?\n\nThis selects the medium-low code model, which means program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Addressing for global symbols uses / instruction pairs, which emit the / sequences. Here's an example of some generated code using the medlow code model:\n\nWhat does -mcmodel=medany mean?\n\nThis selects the medium-any code model, which means the program and its statically defined symbols must lie within any single 2 GiB address range. Addressing for global symbols uses / instruction pairs, which emit the / sequences. Here's an example of some generated code using the medany code model (with , in order to make this match the -mcmodel=medlow example a bit more cleanly):\n\nNote that currently defaults to , which can have an appreciable performance effect. There's a bit of nuance in that performance effect, so we'll discuss it in a later blog.\n\nThe Difference Between a Code Model and an ABI\n\nOne commonly misunderstood distinction is the difference between a code model and an ABI. The ABI determines the interface between functions, while the code model determines how code is generated within a function. Specifically: both RISC-V code models limit the code that addresses symbols to 32-bit offsets, but on RV64I-based systems they still encode pointers as 64-bit.\n\nSpecifically this means that functions compiled with can be called by functions compiled with , and vice versa. The restrictions placed on symbol addressing by both of these functions will need to be met in order to allow an executable to be linked, but that constraint is just generally true. As the code model doesn't affect the layout of structures in memory or how arguments are passed between functions it's largely transparent to programs.\n\nContrast this to linking code generated for two different ABIs, which is invalid. Imagine a function that contains a argument. A function compiled for will expect this argument in a register. When called by a function compiled for that places the argument in an X register the program won't work correctly.\n\nUp until this point we haven't discussed how code models interact with linker relaxation, largely because the answer is now fairly simple: it all just works, assuming you use the RISC-V branches of the various toolchain components as there are a handful of patches that haven't found their way upstream yet.\n\nLinker relaxation is actually an important enough optimization that it affected the RISC-V ISA significantly: linker relaxation allows RISC-V to forgo an addressing mode that would otherwise be required to get reasonable performance on many codebases. On RISC-V targets, the following addressing modes are available:\n‚Ä¢ Symbols within a 7-bit offset from 0 (or from ): 2 bytes.\n‚Ä¢ Symbols within a 12-bit offset from 0 (or from ): 4 bytes.\n‚Ä¢ Symbols within a 32-bit offset from 0: 8 bytes. On RV32I this is the entire address space.\n\nThis can all be achieved with a single code model, and while using a single hardware addressing mode (register+offset) via eight instruction formats (U, I, S, CI, CR, CIW, CL, and CS) without any mode bits. You could view this as a sort of variable-length address encoding that's optional to support in hardware -- for more information see the \"Compressed Macro-Op Fusion\" paper. As this compressing is all implemented transparently by the linker, we only need a single code model. Contrast this behavior with the ARMv8 GCC port, which requires selecting a different code model for each of the address generation sequences it can emit.\n\nAchieving variable-length addressing sequences is usually something reserved for CISC processors, which achieve this by implementing a plethora of addressing modes in hardware and opportunistically shrinking addressing sequences at assembly time when possible. The RISC-V method of using fusible multi-instruction addressing sequences and linker relaxation has the advantages of both allowing simple implementations and resulting in similar code size.\n\nRead more of the All Aboard blog series:\n‚Ä¢ All Aboard, Part 1: The -march, -mabi, and -mtune arguments to RISC-V Compilers\n‚Ä¢ All Aboard, Part 3: Linker Relaxation in the RISC-V Toolchain\n‚Ä¢ All Aboard, Part 5: Per-march and per-mabi Library Paths on RISC-V Systems\n‚Ä¢ All Aboard, Part 7: Entering and Exiting the Linux Kernel on RISC-V\n‚Ä¢ All Aboard, Part 8: The RISC-V Linux Port is Upstream!\n‚Ä¢ All Aboard, Part 9: Paging and the MMU in the RISC-V Linux Kernel\n‚Ä¢ All Aboard, Part 10: How to Contribute to the RISC-V Software Ecosystem"
    }
]