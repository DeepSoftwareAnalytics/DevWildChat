[
    {
        "link": "https://docs.drools.org/7.6.0.Final/drools-docs/html_single",
        "document": "So where do we get started? There are so many use cases and so much functionality in a rule engine such as Drools that it becomes beguiling. Have no fear my intrepid adventurer, the complexity is layered and you can ease yourself in with simple use cases. Stateless session, not utilising inference, forms the simplest use case. A stateless session can be called like a function passing it some data and then receiving some results back. Some common use cases for stateless sessions are, but not limited to:\n• \n• Is this person eligible for a mortgage?\n• \n• Filter incoming messages, such as emails, into folders. So let’s start with a very simple example using a driving license application. public class Applicant { private String name; private int age; private boolean valid; // getter and setter methods here } Now that we have our data model we can write our first rule. We assume that the application uses rules to reject invalid applications. As this is a simple validation use case we will add a single rule to disqualify any applicant younger than 18. package com.company.license rule \"Is of valid age\" when $a : Applicant( age < 18 ) then $a.setValid( false ); end To make the engine aware of data, so it can be processed against the rules, we have to insert the data, much like with a database. When the Applicant instance is inserted into the engine it is evaluated against the constraints of the rules, in this case just two constraints for one rule. We say two because the type Applicant is the first object type constraint, and is the second field constraint. An object type constraint plus its zero or more field constraints is referred to as a pattern. When an inserted instance satisfies both the object type constraint and all the field constraints, it is said to be matched. The is a binding variable which permits us to reference the matched object in the consequence. There its properties can be updated. The dollar character ('$') is optional, but it helps to differentiate variable names from field names. The process of matching patterns against the inserted data is, not surprisingly, often referred to as pattern matching. To use this rule it is necessary to put it a Drools file, just a plain text file with .drl extension , short for \"Drools Rule Language\". Let’s call this file licenseApplication.drl, and store it in a Kie Project. A Kie Project has the structure of a normal Maven project with an additional file (kmodule.xml) defining the s and s that can be created. This file has to be placed in the resources/META-INF folder of the Maven project while all the other Drools artifacts, such as the licenseApplication.drl containing the former rule, must be stored in the resources folder or in any other subfolder under it. Since meaningful defaults have been provided for all configuration aspects, the simplest kmodule.xml file can contain just an empty kmodule tag like the following: At this point it is possible to create a that reads the files to be built, from the classpath. The above code snippet compiles all the DRL files found on the classpath and put the result of this compilation, a , in the . If there are no errors, we are now ready to create our session from the and execute against some data: The preceding code executes the data against the rules. Since the applicant is under the age of 18, the application is marked as invalid. So far we’ve only used a single instance, but what if we want to use more than one? We can execute against any object implementing Iterable, such as a collection. Let’s add another class called , which has the date of the application, and we’ll also move the boolean valid field to the class. public class Applicant { private String name; private int age; // getter and setter methods here } public class Application { private Date dateApplied; private boolean valid; // getter and setter methods here } We will also add another rule to validate that the application was made within a period of time. package com.company.license rule \"Is of valid age\" when Applicant( age < 18 ) $a : Application() then $a.setValid( false ); end rule \"Application was made this year\" when $a : Application( dateApplied > \"01-jan-2009\" ) then $a.setValid( false ); end Unfortunately a Java array does not implement the interface, so we have to use the JDK converter method . The code shown below executes against an iterable list, where all collection elements are inserted before any matched rules are fired. StatelessKieSession kSession = kContainer.newStatelessKieSession(); Applicant applicant = new Applicant( \"Mr John Smith\", 16 ); Application application = new Application(); assertTrue( application.isValid() ); ksession.execute( Arrays.asList( new Object[] { application, applicant } ) ); assertFalse( application.isValid() ); The two execute methods and are actually convenience methods for the interface 's method . The commands factory, obtainable from the like all other factories of the KIE API, is used to create commands, so that the following is equivalent to : Batch Executor and Command Factory are particularly useful when working with multiple Commands and with output identifiers for obtaining results. KieCommands kieCommands = kieServices.getCommands(); List<Command> cmds = new ArrayList<Command>(); cmds.add( kieCommands.newInsert( new Person( \"Mr John Smith\" ), \"mrSmith\", true, null ) ); cmds.add( kieCommands.newInsert( new Person( \"Mr John Doe\" ), \"mrDoe\", true, null ) ); BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) ); assertEquals( new Person( \"Mr John Smith\" ), results.getValue( \"mrSmith\" ) ); supports many other Commands that can be used in the like , , and . Stateful Sessions are long lived and allow iterative changes over time. Some common use cases for Stateful Sessions are, but not limited to: In contrast to a Stateless Session, the method must be called afterwards to ensure there are no memory leaks, as the KieBase contains references to Stateful Knowledge Sessions when they are created. Since Stateful Knowledge Session is the most commonly used session type it is just named in the KIE API. also supports the interface, like , the only difference being that the command is not automatically called at the end for a Stateful Session. We illustrate the monitoring use case with an example for raising a fire alarm. Using just four classes, we represent rooms in a house, each of which has one sprinkler. If a fire starts in a room, we represent that with a single instance. public class Room { private String name // getter and setter methods here } public class Sprinkler { private Room room; private boolean on; // getter and setter methods here } public class Fire { private Room room; // getter and setter methods here } public class Alarm { } In the previous section on Stateless Sessions the concepts of inserting and matching against data were introduced. That example assumed that only a single instance of each object type was ever inserted and thus only used literal constraints. However, a house has many rooms, so rules must express relationships between objects, such as a sprinkler being in a certain room. This is best done by using a binding variable as a constraint in a pattern. This \"join\" process results in what is called cross products, which are covered in the next section. When a fire occurs an instance of the class is created, for that room, and inserted into the session. The rule uses a binding on the field of the object to constrain matching to the sprinkler for that room, which is currently off. When this rule fires and the consequence is executed the sprinkler is turned on. rule \"When there is a fire turn on the sprinkler\" when Fire($room : room) $sprinkler : Sprinkler( room == $room, on == false ) then modify( $sprinkler ) { setOn( true ) }; System.out.println( \"Turn on the sprinkler for room \" + $room.getName() ); end Whereas the Stateless Session uses standard Java syntax to modify a field, in the above rule we use the statement, which acts as a sort of \"with\" statement. It may contain a series of comma separated Java expressions, i.e., calls to setters of the object selected by the statement’s control expression. This modifies the data, and makes the engine aware of those changes so it can reason over them once more. This process is called inference, and it’s essential for the working of a Stateful Session. Stateless Sessions typically do not use inference, so the engine does not need to be aware of changes to data. Inference can also be turned off explicitly by using the sequential mode. So far we have rules that tell us when matching data exists, but what about when it does not exist? How do we determine that a fire has been extinguished, i.e., that there isn’t a object any more? Previously the constraints have been sentences according to Propositional Logic, where the engine is constraining against individual instances. Drools also has support for First Order Logic that allows you to look at sets of data. A pattern under the keyword matches when something does not exist. The rule given below turns the sprinkler off as soon as the fire in that room has disappeared. rule \"When the fire is gone turn off the sprinkler\" when $room : Room( ) $sprinkler : Sprinkler( room == $room, on == true ) not Fire( room == $room ) then modify( $sprinkler ) { setOn( false ) }; System.out.println( \"Turn off the sprinkler for room \" + $room.getName() ); end While there is one sprinkler per room, there is just a single alarm for the building. An object is created when a fire occurs, but only one is needed for the entire building, no matter how many fires occur. Previously was introduced to match the absence of a fact; now we use its complement which matches for one or more instances of some category. rule \"Raise the alarm when we have one or more fires\" when exists Fire() then insert( new Alarm() ); System.out.println( \"Raise the alarm\" ); end Likewise, when there are no fires we want to remove the alarm, so the keyword can be used again. rule \"Cancel the alarm when all the fires have gone\" when not Fire() $alarm : Alarm() then delete( $alarm ); System.out.println( \"Cancel the alarm\" ); end Finally there is a general health status message that is printed when the application first starts and after the alarm is removed and all sprinklers have been turned off. rule \"Status output when things are ok\" when not Alarm() not Sprinkler( on == true ) then System.out.println( \"Everything is ok\" ); end As we did in the Stateless Session example, the above rules should be placed in a single DRL file and saved into the resouces folder of your Maven project or any of its subfolder. As before, we can then obtain a from the . The only difference is that this time we create a Stateful Session, whereas before we created a Stateless Session. With the session created it is now possible to iteratively work with it over time. Four objects are created and inserted, as well as one object for each room. At this point the engine has done all of its matching, but no rules have fired yet. Calling allows the matched rules to fire, but without a fire that will just produce the health message. String[] names = new String[]{\"kitchen\", \"bedroom\", \"office\", \"livingroom\"}; Map<String,Room> name2room = new HashMap<String,Room>(); for( String name: names ){ Room room = new Room( name ); name2room.put( name, room ); ksession.insert( room ); Sprinkler sprinkler = new Sprinkler( room ); ksession.insert( sprinkler ); } ksession.fireAllRules(); > Everything is ok We now create two fires and insert them; this time a reference is kept for the returned . A Fact Handle is an internal engine reference to the inserted instance and allows instances to be retracted or modified at a later point in time. With the fires now in the engine, once is called, the alarm is raised and the respective sprinklers are turned on. > Raise the alarm > Turn on the sprinkler for room kitchen > Turn on the sprinkler for room office After a while the fires will be put out and the instances are retracted. This results in the sprinklers being turned off, the alarm being cancelled, and eventually the health message is printed again. > Cancel the alarm > Turn off the sprinkler for room office > Turn off the sprinkler for room kitchen > Everything is ok Everyone still with me? That wasn’t so hard and already I’m hoping you can start to see the value and power of a declarative rule system. People often confuse methods and rules, and new rule users often ask, \"How do I call a rule?\" After the last section, you are now feeling like a rule expert and the answer to that is obvious, but let’s summarize the differences nonetheless. rule \"Hello World\" when Person( name == \"Chuck\" ) then System.out.println( \"Hello Chuck\" ); end\n• Rules execute by matching against any data as long it is inserted into the engine.\n• Rules can never be called directly.\n• Specific instances cannot be passed to a rule.\n• Depending on the matches, a rule may fire once or several times, or not at all. Earlier the term \"cross product\" was mentioned, which is the result of a join. Imagine for a moment that the data from the fire alarm example were used in combination with the following rule where there are no field constraints: In SQL terms this would be like doing and every row in the Room table would be joined with every row in the Sprinkler table resulting in the following output: These cross products can obviously become huge, and they may very well contain spurious data. The size of cross products is often the source of performance problems for new rule authors. From this it can be seen that it’s always desirable to constrain the cross products, which is done with the variable constraint. This results in just four rows of data, with the correct Sprinkler for each Room. In SQL (actually HQL) the corresponding query would be . The Agenda is a Rete feature. It maintains set of rules that are able to execute, its job is to schedule that execution in a deterministic order. During actions on the , rules may become fully matched and eligible for execution; a single Rule Runtime Action can result in multiple eligible rules. When a rule is fully matched a Rule Match is created, referencing the rule and the matched facts, and placed onto the Agenda. The Agenda controls the execution order of these Matches using a Conflict Resolution strategy. The engine cycles repeatedly through two phases:\n• Rule Runtime Actions. This is where most of the work takes place, either in the Consequence (the RHS itself) or the main Java application process. Once the Consequence has finished or the main Java application process calls the engine switches to the Agenda Evaluation phase.\n• Agenda Evaluation. This attempts to select a rule to fire. If no rule is found it exits, otherwise it fires the found rule, switching the phase back to Rule Runtime Actions. The process repeats until the agenda is clear, in which case control returns to the calling application. When Rule Runtime Actions are taking place, no rules are being fired. So far the data and the matching process has been simple and small. To mix things up a bit a new example will be explored that handles cashflow calculations over date periods. The state of the engine will be illustratively shown at key stages to help get a better understanding of what is actually going on under the hood. Three classes will be used, as shown below. This will help us grow our understanding of pattern matching and joins further. We will then use this to illustrate different techniques for execution control. public class CashFlow { private Date date; private double amount; private int type; long accountNo; // getter and setter methods here } public class Account { private long accountNo; private double balance; // getter and setter methods here } public AccountPeriod { private Date start; private Date end; // getter and setter methods here } By now you already know how to create KieBases and how to instantiate facts to populate the , so tables will be used to show the state of the inserted data, as it makes things clearer for illustration purposes. The tables below show that a single fact was inserted for the . Also inserted are a series of debits and credits as objects for that account, extending over two quarters. Two rules can be used to determine the debit and credit for that quarter and update the Account balance. The two rules below constrain the cashflows for an account for a given time period. Notice the \"&&\" which use short cut syntax to avoid repeating the field name twice. rule \"increase balance for credits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"decrease balance for debits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == DEBIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance -= $amount; end Earlier we showed how rules would equate to SQL, which can often help people with an SQL background to understand rules. The two rules above can be represented with two views and a trigger for each view, as below: select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == CREDIT and cf.date >= ap.start and cf.date <= ap.end select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == DEBIT and cf.date >= ap.start and cf.date <= ap.end If the is set to the first quarter we constrain the rule \"increase balance for credits\" to fire on two rows of data and \"decrease balance for debits\" to act on one row of data. The two cashflow tables above represent the matched data for the two rules. The data is matched during the insertion stage and, as you discovered in the previous chapter, does not fire straight away, but only after is called. Meanwhile, the rule plus its matched data is placed on the Agenda and referred to as an RuIe Match or Rule Instance. The Agenda is a table of Rule Matches that are able to fire and have their consequences executed, as soon as fireAllRules() is called. Rule Matches on the Agenda are referred to as a conflict set and their execution is determine by a conflict resolution strategy. Notice that the order of execution so far is considered arbitrary. After all of the above activations are fired, the account has a balance of -25. If the is updated to the second quarter, we have just a single matched row of data, and thus just a single Rule Match on the Agenda. The firing of that Activation results in a balance of 25. What if you don’t want the order of rule execution to be arbitrary? When there is one or more Rule Match on the Agenda they are said to be in conflict, and a conflict resolution strategy is used to determine the order of execution. The Drools strategy is very simple and based around a salience value, which assigns a priority to a rule. Each rule has a default value of 0, the higher the value the higher the priority. As a general rule, it is a good idea not to count on rules firing in any particular order, and to author the rules without worrying about a \"flow\". However when a flow is needed a number of possibilities exist beyond salience: agenda groups, rule flow groups, activation groups and control/semaphore facts. As of Drools 6.0 rule definition order in the source file is used to set priority after salience. To illustrate Salience we add a rule to print the account balance, where we want this rule to be executed after all the debits and credits have been applied for all accounts. We achieve this by assigning a negative salience to this rule so that it fires after all rules with the default salience 0. rule \"Print balance for AccountPeriod\" salience -50 when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end The table below depicts the resulting Agenda. The three debit and credit rules are shown to be in arbitrary order, while the print rule is ranked last, to execute afterwards. Agenda groups allow you to place rules into groups, and to place those groups onto a stack. The stack has push/pop bevaviour. Calling \"setFocus\" places the group onto the stack: The agenda always evaluates the top of the stack. When all the rules have fired for a group, it is popped from the stack and the next group is evaluated. rule \"increase balance for credits\" agenda-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" agenda-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end First set the focus to the \"report\" group and then by placing the focus on \"calculation\" we ensure that group is evaluated first. Drools also features ruleflow-group attributes which allows workflow diagrams to declaratively specify when rules are allowed to fire. The screenshot below is taken from Eclipse using the Drools plugin. It has two ruleflow-group nodes which ensures that the calculation rules are executed before the reporting rules. The use of the ruleflow-group attribute in a rule is shown below. rule \"increase balance for credits\" ruleflow-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" ruleflow-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end Inference has a bad name these days, as something not relevant to business use cases and just too complicated to be useful. It is true that contrived and complicated examples occur with inference, but that should not detract from the fact that simple and useful ones exist too. But more than this, correct use of inference can crate more agile and less error prone business rules, which are easier to maintain. So what is inference? Something is inferred when we gain knowledge of something from using previous knowledge. For example, given a Person fact with an age field and a rule that provides age policy control, we can infer whether a Person is an adult or a child and act on this. rule \"Infer Adult\" when $p : Person( age >= 18 ) then insert( new IsAdult( $p ) ) end Due to the preceding rule, every Person who is 18 or over will have an instance of IsAdult inserted for them. This fact is special in that it is known as a relation. We can use this inferred relation in any rule: So now we know what inference is, and have a basic example, how does this facilitate good rule design and maintenance? Let’s take a government department that are responsible for issuing ID cards when children become adults, henceforth referred to as ID department. They might have a decision table that includes logic like this, which says when an adult living in London is 18 or over, issue the card: However the ID department does not set the policy on who an adult is. That’s done at a central government level. If the central government were to change that age to 21, this would initiate a change management process. Someone would have to liaise with the ID department and make sure their systems are updated, in time for the law going live. This change management process and communication between departments is not ideal for an agile environment, and change becomes costly and error prone. Also the card department is managing more information than it needs to be aware of with its \"monolithic\" approach to rules management which is \"leaking\" information better placed elsewhere. By this I mean that it doesn’t care what explicit age ▸ = 18 information determines whether someone is an adult, only that they are an adult. In contrast to this, let’s pursue an approach where we split (de-couple) the authoring responsibilities, so that both the central government and the ID department maintain their own rules. It’s the central government’s job to determine who is an adult. If they change the law they just update their central repository with the new rules, which others use: The IsAdult fact, as discussed previously, is inferred from the policy rules. It encapsulates the seemingly arbitrary piece of logic age ▸ = 18 and provides semantic abstractions for its meaning. Now if anyone uses the above rules, they no longer need to be aware of explicit information that determines whether someone is an adult or not. They can just use the inferred fact: While the example is very minimal and trivial it illustrates some important points. We started with a monolithic and leaky approach to our knowledge engineering. We created a single decision table that had all possible information in it and that leaks information from central government that the ID department did not care about and did not want to manage. We first de-coupled the knowledge process so each department was responsible for only what it needed to know. We then encapsulated this leaky knowledge using an inferred fact IsAdult. The use of the term IsAdult also gave a semantic abstraction to the previously arbitrary logic age ▸ = 18. So a general rule of thumb when doing your knowledge engineering is: After regular inserts you have to retract facts explicitly. With logical assertions, the fact that was asserted will be automatically retracted when the conditions that asserted it in the first place are no longer true. Actually, it’s even cleverer then that, because it will be retracted only if there isn’t any single condition that supports the logical assertion. Normal insertions are said to be stated, i.e., just like the intuitive meaning of \"stating a fact\" implies. Using a and a counter, we track how many times a particular equality is stated; this means we count how many different instances are equal. When we logically insert an object during a RHS execution we are said to justify it, and it is considered to be justified by the firing rule. For each logical insertion there can only be one equal object, and each subsequent equal logical insertion increases the justification counter for this logical assertion. A justification is removed by the LHS of the creating rule becoming untrue, and the counter is decreased accordingly. As soon as we have no more justifications the logical object is automatically retracted. If we try to logically insert an object when there is an equal stated object, this will fail and return null. If we state an object that has an existing equal object that is justified we override the Fact; how this override works depends on the configuration setting . When the property is set to discard we use the existing handle and replace the existing instance with the new Object, which is the default behavior; otherwise we override it to stated but we create an new . This can be confusing on a first read, so hopefully the flow charts below help. When it says that it returns a new , this also indicates the was propagated through the network. 6.4.1.1. Bus Pass Example With Inference and TMS The previous example was issuing ID cards to over 18s, in this example we now issue bus passes, either a child or adult pass. rule \"Issue Child Bus Pass\" when $p : Person( age < 16 ) then insert(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) then insert(new AdultBusPass( $p ) ); end As before the above example is considered monolithic, leaky and providing poor separation of concerns. As before we can provide a more robust application with a separation of concerns using inference. Notice this time we don’t just insert the inferred object, we use \"insertLogical\": rule \"Infer Child\" when $p : Person( age < 16 ) then insertLogical( new IsChild( $p ) ) end rule \"Infer Adult\" when $p : Person( age >= 16 ) then insertLogical( new IsAdult( $p ) ) end A \"insertLogical\" is part of the Drools Truth Maintenance System (TMS). When a fact is logically inserted, this fact is dependant on the truth of the \"when\" clause. It means that when the rule becomes false the fact is automatically retracted. This works particularly well as the two rules are mutually exclusive. So in the above rules if the person is under 16 it inserts an IsChild fact, once the person is 16 or over the IsChild fact is automatically retracted and the IsAdult fact inserted. Returning to the code to issue bus passes, these two rules can + logically insert the ChildBusPass and AdultBusPass facts, as the TMS + supports chaining of logical insertions for a cascading set of retracts. rule \"Issue Child Bus Pass\" when $p : Person( ) IsChild( person == $p ) then insertLogical(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) IsAdult( person =$p ) then insertLogical(new AdultBusPass( $p ) ); end Now when a person changes from being 15 to 16, not only is the IsChild fact automatically retracted, so is the person’s ChildBusPass fact. For bonus points we can combine this with the 'not' conditional element to handle notifications, in this situation, a request for the returning of the pass. So when the TMS automatically retracts the ChildBusPass object, this rule triggers and sends a request to the person: rule \"Return ChildBusPass Request \"when $p : Person( ) not( ChildBusPass( person == $p ) ) then requestChildBusPass( $p ); end It is important to note that for Truth Maintenance (and logical assertions) to work at all, your Fact objects (which may be JavaBeans) must override equals and hashCode methods (from java.lang.Object) correctly. As the truth maintenance system needs to know when two different physical objects are equal in value, both equals and hashCode must be overridden correctly, as per the Java standard. Two objects are equal if and only if their equals methods return true for each other and if their hashCode methods return the same values. See the Java API for more details (but do keep in mind you MUST override both equals and hashCode). TMS behaviour is not affected by theruntime configuration of Identity vs Equality, TMS is always equality. 6.4.1.3. Deleting stated or logically asserted facts from the working memory By default when a fact is deleted from the working memory Drools attempts to remove it both from the set of stated facts and also from the Truth Maintenance System in case it has been logically asserted. However, using an overload of the delete method, it is also possible to remove it only from one of the 2. For instance invoking: the fact is removed only if it has been logically asserted, but not if it is a stated fact. In this case, if the fact has been stated its deletion fails silently and it is ignored. Decision tables are a \"precise yet compact\" (ref. Wikipedia) way of representing conditional logic, and are well suited to business level rules. Drools supports managing rules in a spreadsheet format. Supported formats are Excel (XLS), and CSV, which means that a variety of spreadsheet programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can be utilized. It is expected that web based decision table editors will be included in a near future release. Decision tables are an old concept (in software terms) but have proven useful over the years. Very briefly speaking, in Drools decision tables are a way to generate rules driven from the data entered into a spreadsheet. All the usual features of a spreadsheet for data capture and manipulation can be taken advantage of. 6.5.1. When to Use Decision Tables Consider decision tables as a course of action if rules exist that can be expressed as rule templates and data: each row of a decision table provides data that is combined with a template to generate a rule. Many businesses already use spreadsheets for managing data, calculations, etc. If you are happy to continue this way, you can also manage your business rules this way. This also assumes you are happy to manage packages of rules in .xls or .csv files. Decision tables are not recommended for rules that do not follow a set of templates, or where there are a small number of rules (or if there is a dislike towards software like Excel or OpenOffice.org). They are ideal in the sense that there can be control over what parameters of rules can be edited, without exposing the rules directly. Decision tables also provide a degree of insulation from the underlying object model. Here are some examples of real world decision tables (slightly edited to protect the innocent). In the above examples, the technical aspects of the decision table have been collapsed away (using a standard spreadsheet feature). The rules start from row 17, with each row resulting in a rule. The conditions are in columns C, D, E, etc., the actions being off-screen. The values in the cells are quite simple, and their meaning is indicated by the headers in Row 16. Column B is just a description. It is customary to use color to make it obvious what the different areas of the table mean. Note that although the decision tables look like they process top down, this is not necessarily the case. Ideally, rules are authored without regard for the order of rows, simply because this makes maintenance easier, as rows will not need to be shifted around all the time. As each row is a rule, the same principles apply. As the rule engine processes the facts, any rules that match may fire. (Some people are confused by this. It is possible to clear the agenda when a rule fires and simulate a very simple decision table where only the first match effects an action.) Also note that you can have multiple tables on one spreadsheet. This way, rules can be grouped where they share common templates, yet at the end of the day they are all combined into one rule package. Decision tables are essentially a tool to generate DRL rules automatically. Figure 150. A real world example using multiple tables for grouping like rules The key point to keep in mind is that in a decision table each row is a rule, and each column in that row is either a condition or action for that rule. The spreadsheet looks for the RuleTable keyword to indicate the start of a rule table (both the starting row and column). Other keywords are also used to define other package level attributes (covered later). It is important to keep the keywords in one column. By convention the second column (\"B\") is used for this, but it can be any column (convention is to leave a margin on the left for notes). In the following diagram, C is actually the column where it starts. Everything to the left of this is ignored. If we expand the hidden sections, it starts to make more sense how it works; note the keywords in column C. Now the hidden magic which makes it work can be seen. The RuleSet keyword indicates the name to be used in the rule package that will encompass all the rules. This name is optional, using a default, but it must have the RuleSet keyword in the cell immediately to the right. The other keywords visible in Column C are Import and Sequential which will be covered later. The RuleTable keyword is important as it indicates that a chunk of rules will follow, based on some rule templates. After the RuleTable keyword there is a name, used to prefix the names of the generated rules. The sheet name and row numbers are appended to guarantee unique rule names. The RuleTable name combined with the sheet name must be unique across all spreadsheet files in the same KieBase. If that’s not the case, some rules might have the same name and only 1 of them will be applied. To show such ignored rules, raise the severity of such rule name conflicts. The column of RuleTable indicates the column in which the rules start; columns to the left are ignored. In general the keywords make up name-value pairs. Referring to row 14 (the row immediately after RuleTable), the keywords CONDITION and ACTION indicate that the data in the columns below are for either the LHS or the RHS parts of a rule. There are other attributes on the rule which can also be optionally set this way. Row 15 contains declarations of ObjectTypes . The content in this row is optional, but if this option is not in use, the row must be left blank; however this option is usually found to be quite useful. When using this row, the values in the cells below (row 16) become constraints on that object type. In the above case, it generates and , where 42 and \"stilton\" come from row 18. In the above example, the \"==\" is implicit; if just a field name is given the translator assumes that it is to generate an exact match. An ObjectType declaration can span columns (via merged cells), meaning that all columns below the merged range are to be combined into one set of constraints within a single pattern matching a single fact at a time, as opposed to non-merged cells containing the same ObjectType, but resulting in different patterns, potentially matching different or identical facts. Row 16 contains the rule templates themselves. They can use the \"$param\" placeholder to indicate where data from the cells below should be interpolated. (For multiple insertions, use \"$1\", \"$2\", etc., indicating parameters from a comma-separated list in a cell below.) Row 17 is ignored; it may contain textual descriptions of the column’s purpose. Rows 18 and 19 show data, which will be combined (interpolated) with the templates in row 15, to generate rules. If a cell contains no data, then its template is ignored. (This would mean that some condition or action does not apply for that rule row.) Rule rows are read until there is a blank row. Multiple RuleTables can exist in a sheet. Row 20 contains another keyword, and a value. The row positions of keywords like this do not matter (most people put them at the top) but their column should be the same one where the RuleTable or RuleSet keywords should appear. In our case column C has been chosen to be significant, but any other column could be used instead. In the above example, rules would be rendered like the following (as it uses the \"ObjectType\" row): The constraints and are interpreted as single constraints, to be added to the respective ObjectType in the cell above. If the cells above were spanned, then there could be multiple constraints on one \"column\". Very large decision tables may have very large memory requirements. There are two types of rectangular areas defining data that is used for generating a DRL file. One, marked by a cell labelled , defines all DRL items except rules. The other one may occur repeatedly and is to the right and below a cell whose contents begin with . These areas represent the actual decision tables, each area resulting in a set of rules of similar structure. A Rule Set area may contain cell pairs, one below the cell and containing a keyword designating the kind of value contained in the other one that follows in the same row. The columns of a Rule Table area define patterns and constraints for the left hand sides of the rules derived from it, actions for the consequences of the rules, and the values of individual rule attributes. Thus, a Rule Table area should contain one or more columns, both for conditions and actions, and an arbitrary selection of columns for rule attributes, at most one column for each of these. The first four rows following the row with the cell marked with are earmarked as header area, mostly used for the definition of code to construct the rules. It is any additional row below these four header rows that spawns another rule, with its data providing for variations in the code defined in the Rule Table header. Only the first worksheet is examined for decision tables. Entries in a Rule Set area may define DRL constructs (except rules), and specify rule attributes. While entries for constructs may be used repeatedly, each rule attribute may be given at most once, and it applies to all rules unless it is overruled by the same attribute being defined within the Rule Table area. Entries must be given in a vertically stacked sequence of cell pairs. The first one contains a keyword and the one to its right the value, as shown in the table below. This sequence of cell pairs may be interrupted by blank rows or even a Rule Table, as long as the column marked by is upheld as the one containing the keyword. The package name for the generated DRL file. Optional, the default is . \"true\" or \"false\". If \"true\", then salience is used to ensure that rules fire from the top down. Optional, at most once. If omitted, no firing order is imposed. Optional, at most once. In sequential mode, this option is used to set the start value of the salience. If omitted, the default value is 65535. Optional, at most once. In sequential mode this option is used to check if this minimum salience value is not violated. If omitted the default value is 0. \"true\" or \"false\". If \"true\", then quotation marks are escaped so that they appear literally in the DRL. Optional, at most once. If omitted, quotation marks are escaped. \"true\" or \"false\". If \"true\", then a String representation is used for DRL instead of a double value from a Numeric cell Optional, at most once. If omitted, a double value is used. Optional, may be used repeatedly. Declarations of DRL globals, i.e., a type followed by a variable name. Multiple global definitions must be separated with a comma. Optional, may be used repeatedly. One or more function definitions, according to DRL syntax. Optional, may be used repeatedly. One or more query definitions, according to DRL syntax. Optional, may be used repeatedly. One or more declarative types, according to DRL syntax. Optional, may be used repeatedly. In some locales, MS Office, LibreOffice and OpenOffice will encode a double quote differently, which will cause a compilation error. The difference is often hard to see. For example: will fail, but will work. For defining rule attributes that apply to all rules in the generated DRL file you can use any of the entries in the following table. Notice, however, that the proper keyword must be used. Also, each of these attributes may be used only once. Rule attributes specified in a Rule Set area will affect all rule assets in the same package (not only in the spreadsheet). Unless you are sure that the spreadsheet is the only one rule asset in the package, the recommendation is to specify rule attributes not in a Rule Set area but in a Rule Table columns for each rule instead. An integer defining the \"salience\" value for the rule. Overridden by the \"Sequential\" flag. A long integer value defining the \"duration\" value for the rule. A Boolean value. \"true\" enables the rule; \"false\" disables the rule. A Boolean value. \"true\" inhibits looping of rules due to changes made by its consequence. A Boolean value. \"true\" inhibits additional activations of all rules with this flag set within the same ruleflow or agenda group. A Boolean value. \"true\" for a rule within an agenda group causes activations of the rule to automatically give the focus to the group. A string identifying an activation (or XOR) group. Only one rule within an activation group will fire, i.e., the first one to fire cancels any existing activations of other rules within the same group. A string identifying an agenda group, which has to be activated by giving it the \"focus\", which is one way of controlling the flow between groups of rules. All Rule Tables begin with a cell containing \"RuleTable\", optionally followed by a string within the same cell. The string is used as the initial part of the name for all rules derived from this Rule Table, with the row number appended for distinction. (This automatic naming can be overridden by using a NAME column.) All other cells defining rules of this Rule Table are below and to the right of this cell. The next row defines the column type, with each column resulting in a part of the condition or the consequence, or providing some rule attribute, the rule name or a comment. The table below shows which column headers are available; additional columns may be used according to the table showing rule attribute entries given in the preceding section. Note that each attribute column may be used at most once. For a column header, either use the keyword or any other word beginning with the letter given in the \"Initial\" column of these tables. Provides the name for the rule generated from that row. The default is constructed from the text following the RuleTable tag and the row number. A text, resulting in a comment within the generated rule. Code snippet and interpolated values for constructing a constraint within a pattern in a condition. At least one per rule table Code snippet and interpolated values for constructing an action for the consequence of the rule. At least one per rule table Code snippet and interpolated values for constructing a metadata entry for the rule. Given a column headed CONDITION, the cells in successive lines result in a conditional element.\n• Text in the first cell below CONDITION develops into a pattern for the rule condition, with the snippet in the next line becoming a constraint. If the cell is merged with one or more neighbours, a single pattern with multiple constraints is formed: all constraints are combined into a parenthesized list and appended to the text in this cell. The cell may be left blank, which means that the code snippet in the next row must result in a valid conditional element on its own. To include a pattern without constraints, you can write the pattern in front of the text for another pattern. The pattern may be written with or without an empty pair of parentheses. A \"from\" clause may be appended to the pattern. If the pattern ends with \"eval\", code snippets are supposed to produce boolean expressions for inclusion into a pair of parentheses after \"eval\".\n• Text in the second cell below CONDITION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using \"==\" with the value from the cells below, the field selector alone is sufficient. Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A text according to the pattern delimiter snippet is expanded by repeating the snippet once for each of the values of the comma-separated list of values in each of the cells below, inserting the value in place of the symbol and by joining these expansions by the given delimiter. Note that the forall construct may be surrounded by other text.\n• If the cell in the preceding row is not empty, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below CONDITION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the conditional element or constraint for this rule. Given a column headed ACTION, the cells in successive lines result in an action statement.\n• Text in the first cell below ACTION is optional. If present, it is interpreted as an object reference.\n• Text in the second cell below ACTION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A method call without interpolation can be achieved by a text without any marker symbols. In this case, use any non-blank entry in a row below to include the statement. The forall construct is available here, too.\n• If the first cell is not empty, its text, followed by a period, the text in the second cell and a terminating semicolon are stringed together, resulting in a method call which is added as an action statement for the consequence. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below ACTION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the action statement for this rule. Using instead of works in most cases, but it will fail if the replacement text contains a comma: then, only the part preceding the first comma is inserted. Use this \"abbreviation\" judiciously. Given a column headed METADATA, the cells in successive lines result in a metadata annotation for the generated rules.\n• Text in the first cell below METADATA is ignored.\n• Text in the second cell below METADATA is subject to interpolation, as described above, using values from the cells in the rule rows. The metadata marker character is prefixed automatically, and thus it should not be included in the text for this cell.\n• Text in the third cell below METADATA is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the metadata annotation for this rule. The various interpolations are illustrated in the following example. If the template is and the cell is , then the result is . If the template is and the cell contains , the result will be . The template with a cell containing results in . The next example demonstrates the joint effect of a cell defining the pattern type and the code snippet below it. This spreadsheet section shows how the type declaration spans 2 columns, and thus both constraints will appear as . Since only the field names are present in the snippet, they imply an equality test. In the following example the marker symbol is used. The result of this column is the pattern . You may have noticed that the marker and the operator \"==\" are redundant. The next example illustrates that a trailing insertion marker can be omitted. Here, appending the value from the cell is implied, resulting in You can provide the definition of a binding variable, as in the example below. Here, the result is Note that the quotes are provided automatically. Actually, anything can be placed in the object type row. Apart from the definition of a binding variable, it could also be an additional pattern that is to be inserted literally. A simple construction of an action statement with the insertion of a single value is shown below. The cell below the ACTION header is left blank. Using this style, anything can be placed in the consequence, not just a single method call. (The same technique is applicable within a CONDITION column as well.) Below is a comprehensive example, showing the use of various column headers. It is not an error to have no value below a column header (as in the NO-LOOP column): here, the attribute will not be applied in any of the rules. Figure 153. Example usage of keywords for imports, headers, etc. And, finally, here is an example of Import, Variables and Functions. Figure 154. Example usage of keywords for functions, etc. Multiple package names within the same cell must be separated by a comma. Also, the pairs of type and variable names must be comma-separated. Functions, however, must be written as they appear in a DRL file. This should appear in the same column as the \"RuleSet\" keyword; it could be above, between or below all the rule rows. It may be more convenient to use Import, Variables, Functions and Queries repeatedly rather than packing several definitions into a single cell. The API to use spreadsheet based decision tables is in the drools-decisiontables module. There is really only one class to look at: . This class will take spreadsheets in various formats, and generate rules in DRL (which you can then use in the normal way). The can just be used to generate partial rule files if it is wished, and assemble it into a complete rule package after the fact (this allows the separation of technical and non-technical aspects of the rules if needed). To get started, a sample spreadsheet can be used as a base. Alternatively, if the plug-in is being used (Rule Workbench IDE), the wizard can generate a spreadsheet from a template (to edit it an xls compatible spreadsheet editor will need to be used). Spreadsheets are well established business tools (in use for over 25 years). Decision tables lend themselves to close collaboration between IT and domain experts, while making the business rules clear to business analysts, it is an ideal separation of concerns. Typically, the whole process of authoring rules (coming up with a new decision table) would be something like:\n• Business analyst takes a template decision table (from a repository, or from IT)\n• Decision table business language descriptions are entered in the table(s)\n• Decision table is handed to a technical resource, who maps the business language (descriptions) to scripts (this may involve software development of course, if it is a new application or data model)\n• Technical person hands back and reviews the modifications with the business analyst.\n• The business analyst can continue editing the rule rows as needed (moving columns around is also fine etc).\n• In parallel, the technical person can develop test cases for the rules (liaising with business analysts) as these test cases can be used to verify rules and rule changes once the system is running. Features of applications like Excel can be used to provide assistance in entering data into spreadsheets, such as validating fields. Lists that are stored in other worksheets can be used to provide valid lists of values for cells, like in the following diagram. Some applications provide a limited ability to keep a history of changes, but it is recommended to use an alternative means of revision control. When changes are being made to rules over time, older versions are archived (many open source solutions exist for this, such as Subversion or Git). Related to decision tables (but not necessarily requiring a spreadsheet) are \"Rule Templates\" (in the drools-templates module). These use any tabular data source as a source of rule data - populating a template to generate many rules. This can allow both for more flexible spreadsheets, but also rules in existing databases for instance (at the cost of developing the template up front to generate the rules). With Rule Templates the data is separated from the rule and there are no restrictions on which part of the rule is data-driven. So whilst you can do everything you could do in decision tables you can also do the following:\n• store your data in a database (or any other format)\n• conditionally generate rules based on the values in the data\n• use data for any part of your rules (e.g. condition operator, class name, property name)\n• run different templates over the same data As an example, a more classic decision table is shown, but without any hidden rows for the rule meta data (so the spreadsheet only contains the raw data to generate the rules). See the ExampleCheese.xls in the examples download for the above spreadsheet. If this was a regular decision table there would be hidden rows before row 1 and between rows 1 and 2 containing rule metadata. With rule templates the data is completely separate from the rules. This has two handy consequences - you can apply multiple rule templates to the same data and your data is not tied to your rules at all. So what does the template look like?\n• Lines 2-4: Following the header is the list of columns in the order they appear in the data. In this case we are calling the first column , the second and the third .\n• Line 5: An empty line signifies the end of the column definitions.\n• Lines 6-9: Standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global and function definitions into this section.\n• Line 10: The keyword signals the start of a rule template. There can be more than one template in a template file, but each template should have a unique name.\n• Lines 11-18: The rule template - see below for details.\n• Line 20: The keywords signify the end of the template. The rule templates rely on MVEL to do substitution using the syntax @{token_name}. There is currently one built-in expression, @{row.rowNumber} which gives a unique number for each row of data and enables you to generate unique rule names. For each row of data a rule will be generated with the values in the data substituted for the tokens in the template. A rule template has to be included in a file with extension .drt and associated to the corresponding decision table when defining the kbase in the kmodule.xml file as in the following example With the example data above the following rule file would be generated: package org.drools.examples.templates; global java.util.List list; rule \"Cheese fans_1\" when Person(age == 42) Cheese(type == \"stilton\") then list.add(\"Old man stilton\"); end rule \"Cheese fans_2\" when Person(age == 21) Cheese(type == \"cheddar\") then list.add(\"Young man cheddar\"); end At this point the named \"TemplatesKS\" and containing the rules generated from the template can be simply created from the and used as any other . KieSession ksession = kc.newKieSession( \"TemplatesKS\" ); // now create some test data ksession.insert( new Cheese( \"stilton\", 42 ) ); ksession.insert( new Person( \"michael\", \"stilton\", 42 ) ); final List<String> list = new ArrayList<String>(); ksession.setGlobal( \"list\", list ); ksession.fireAllRules(); One way to illuminate the black box that is a rule engine, is to play with the logging level. Everything is logged to SLF4J, which is a simple logging facade that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a dependency to the logging adaptor for your logging framework of choice. If you’re not using any logging framework yet, you can use Logback by adding this Maven dependency: If you’re developing for an ultra light environment, use or instead. Configure the logging level on the package . For example: In Logback, configure it in your logback.xml file: In Log4J, configure it in your log4j.xml file:\n\nMake sure the Drools Eclipse plugin is installed, which needs the Graphical Editing Framework (GEF) dependency installed first. Then download and extract the drools-examples zip file, which includes an already created Eclipse project. Import that project into a new Eclipse workspace. The rules all have example classes that execute the rules. If you want to try the examples in another project (or another IDE) then you will need to set up the dependencies by hand, of course. Many, but not all of the examples are documented below, enjoy! Name: Hello World Main class: org.drools.examples.helloworld.HelloWorldExample Module: drools-examples Type: Java application Rules file: HelloWorld.drl Objective: demonstrate basic rules in use The \"Hello World\" example shows a simple application using rules, written both using the MVEL and the Java dialects. This example demonstrates how to create and use a . Also, audit logging and debug outputs are shown, which is omitted from other examples as it’s all very similar. The following code snippet shows how the session is created with only 3 lines of code. Obtains the KieServices factory. This is the main interface applications use to interact with the engine. Creates a KieContainer from the project classpath. This will look for a /META-INF/kmodule.xml file to configure and instantiate the KieModule into the KieContainer. Drools has an event model that exposes much of what’s happening internally. Two default debug listeners are supplied, and which print out debug event information to the stream displayed in the Console window. Adding listeners to a Session is trivial, as shown in the next snippet. The provides execution auditing, the result of which can be viewed in a graphical viewer. The logger is actually a specialised implementation built on the and listeners. When the engine has finished executing, must be called. Most of the examples use the Audit logging features of Drools to record execution flow for later inspection. // The application can also setup listeners ksession.addEventListener( new DebugAgendaEventListener() ); ksession.addEventListener( new DebugRuleRuntimeEventListener() ); // To setup a file based audit logger, uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, \"./helloworld\" ); // To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging, // uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, \"./helloworld\", 1000 ); The single class used in this example is very simple. It has two fields: the message, which is a and the status which can be one of the two integers or . A single object is created with the message text \"Hello World\" and the status and then inserted into the engine, at which point is executed. // The application can insert facts into the session final Message message = new Message(); message.setMessage( \"Hello World\" ); message.setStatus( Message.HELLO ); ksession.insert( message ); // and fire the rules ksession.fireAllRules(); To execute the example as a Java application:\n• Open the class in your Eclipse IDE\n• Right-click the class and select \"Run as…​\" and then \"Java application\" If we put a breakpoint on the method and select the variable, we can see that the \"Hello World\" rule is already activate on the Agenda. The application print outs go to to while the debug listener print outs go to . Example 260. HelloWorld: System.out in the Console window Example 261. HelloWorld: System.err in the Console window The actual rules are inside the file src/main/resources/org/drools/examples/helloworld/HelloWorld.drl : rule \"Hello World\" dialect \"mvel\" when m : Message( status == Message.HELLO, message : message ) then System.out.println( message ); modify ( m ) { message = \"Goodbye cruel world\", status = Message.GOODBYE }; end The LHS (after ) section of the rule states that it will be activated for each object inserted into the Rule Runtime whose status is . Besides that, two variable bindings are created: the variable is bound to the attribute and the variable is bound to the matched object itself. The RHS (after ) or consequence part of the rule is written using the MVEL expression language, as declared by the rule’s attribute . After printing the content of the bound variable to , the rule changes the values of the and attributes of the object bound to . This is done using MVEL’s statement, which allows you to apply a block of assignments in one statement, with the engine being automatically notified of the changes at the end of the block. It is possible to set a breakpoint into the DRL, on the call, and inspect the Agenda view again during the execution of the rule’s consequence. This time we start the execution via \"Debug As\" and \"Drools application\" and not by running a \"Java application\":\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Debug as…​\" and then \"Drools application\". Now we can see that the other rule , which uses the Java dialect, is activated and placed on the Agenda. The \"Good Bye\" rule, which specifies the \"java\" dialect, is similar to the \"Hello World\" rule except that it matches objects whose status is . The Java code that instantiates the creates an audit log file that can be loaded into the Audit view. The Audit view is used in many of the examples to demonstrate the example execution flow. In the view screen shot below we can see that the object is inserted, which creates an activation for the \"Hello World\" rule; the activation is then executed which updates the object causing the \"Good Bye\" rule to activate; finally the \"Good Bye\" rule also executes. Selecting an event in the Audit view highlights the origin event in green; therefore the \"Activation created\" event is highlighted in green as the origin of the \"Activation executed\" event. This example is implemented in two different versions to demonstrate different ways of implementing the same basic behavior: forward chaining, i.e., the ability the engine has to evaluate, activate and fire rules in sequence, based on changes on the facts in the Working Memory. Name: State Example Main class: org.drools.examples.state.StateExampleUsingSalience Module: drools-examples Type: Java application Rules file: StateExampleUsingSalience.drl Objective: Demonstrates basic rule use and Conflict Resolution for rule firing priority. Each class has fields for its name and its current state (see the class ). The two possible states for each objects are: public class State { public static final int NOTRUN = 0; public static final int FINISHED = 1; private final PropertyChangeSupport changes = new PropertyChangeSupport( this ); private String name; private int state; ... setters and getters go here... } Ignoring the , which will be explained later, we see the creation of four objects named A, B, C and D. Initially their states are set to , which is default for the used constructor. Each instance is asserted in turn into the Session and then is called. final State a = new State( \"A\" ); final State b = new State( \"B\" ); final State c = new State( \"C\" ); final State d = new State( \"D\" ); ksession.insert( a ); ksession.insert( b ); ksession.insert( c ); ksession.insert( d ); ksession.fireAllRules(); ksession.dispose(); // Stateful rule session must always be disposed when finished\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" You will see the following output in the Eclipse console window: There are four rules in total. First, the rule fires, setting A to state , which then causes B to change its state to . C and D are both dependent on B, causing a conflict which is resolved by the salience values. Let’s look at the way this was executed. The best way to understand what is happening is to use the Audit Logging feature to graphically see the results of each operation. To view the Audit log generated by a run of this example:\n• If the Audit View is not visible, click on \"Window\" and then select \"Show View\", then \"Other…​\" and \"Drools\" and finally \"Audit View\".\n• In the \"Audit View\" click the \"Open Log\" button and select the file \"<drools-examples-dir>/log/state.log\". After that, the \"Audit view\" will look like the following screenshot: Reading the log in the \"Audit View\", top to bottom, we see every action and the corresponding changes in the Working Memory. This way we observe that the assertion of the State object A in the state activates the rule, while the assertions of the other objects have no immediate effect. The execution of rule Bootstrap changes the state of A to , which, in turn, activates rule \"A to B\". rule \"A to B\" when State(name == \"A\", state == State.FINISHED ) b : State(name == \"B\", state == State.NOTRUN ) then System.out.println(b.getName() + \" finished\" ); b.setState( State.FINISHED ); end The execution of rule \"A to B\" changes the state of B to , which activates both, rules \"B to C\" and \"B to D\", placing their Activations onto the Agenda. From this moment on, both rules may fire and, therefore, they are said to be \"in conflict\". The conflict resolution strategy allows the engine’s Agenda to decide which rule to fire. As rule \"B to C\" has the higher salience value (10 versus the default salience value of 0), it fires first, modifying object C to state . The Audit view shown above reflects the modification of the object in the rule \"A to B\", which results in two activations being in conflict. The Agenda view can also be used to investigate the state of the Agenda, with debug points being placed in the rules themselves and the Agenda view opened. The screen shot below shows the breakpoint in the rule \"A to B\" and the state of the Agenda with the two conflicting rules. Example 269. Salience State: Rule \"B to C\" rule \"B to C\" salience 10 when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); end Rule \"B to D\" fires last, modifying object D to state . rule \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end There are no more rules to execute and so the engine stops. Another notable concept in this example is the use of dynamic facts, based on objects. As described in the documentation, in order for the engine to see and react to changes of fact properties, the application must tell the engine that changes occurred. This can be done explicitly in the rules by using the statement, or implicitly by letting the engine know that the facts implement as defined by the JavaBeans specification. This example demonstrates how to use to avoid the need for explicit statements in the rules. To make use of this feature, ensure that your facts implement , the same way the class does, and use the following code in the rules file to configure the engine to listen for property changes on those facts: When using objects, each setter must implement a little extra code for the notification. Here is the setter for in the class : Example 272. Setter Example with PropertyChangeSupport There are another class in this example: . It executes from A to B to C to D, as just shown, but uses agenda-groups to control the rule conflict and which one fires first. Agenda groups are a way to partition the Agenda into groups and to control which groups can execute. By default, all rules are in the agenda group \"MAIN\". The \"agenda-group\" attribute lets you specify a different agenda group for the rule. Initially, a Working Memory has its focus on the Agenda group \"MAIN\". A group’s rules will only fire when the group receives the focus. This can be achieved either ny using the method by or the rule attribute . \"auto-focus\" means that the rule automatically sets the focus to its agenda group when the rule is matched and activated. It is this \"auto-focus\" that enables rule \"B to C\" to fire before \"B to D\". Example 273. Agenda Group State Example: Rule \"B to C\" rule \"B to C\" agenda-group \"B to C\" auto-focus true when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"B to D\" ).setFocus(); end The rule \"B to C\" calls on the agenda group \"B to D\", allowing its active rules to fire, which allows the rule \"B to D\" to fire. Example 274. Agenda Group State Example: Rule \"B to D\" rule \"B to D\" agenda-group \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end Name: Fibonacci Main class: org.drools.examples.fibonacci.FibonacciExample Module: drools-examples Type: Java application Rules file: Fibonacci.drl Objective: Demonstrates Recursion, the CE not and cross product matching The Fibonacci Numbers (see http://en.wikipedia.org/wiki/Fibonacci_number) discovered by Leonardo of Pisa (see http://en.wikipedia.org/wiki/Fibonacci) is a sequence that starts with 0 and 1. The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers. The Fibonacci sequence begins with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,…​ The Fibonacci Example demonstrates recursion and conflict resolution with salience values. The single fact class is used in this example. It has two fields, sequence and value. The sequence field is used to indicate the position of the object in the Fibonacci number sequence. The value field shows the value of that Fibonacci object for that sequence position, using -1 to indicate a value that still needs to be computed. public static class Fibonacci { private int sequence; private long value; public Fibonacci( final int sequence ) { this.sequence = sequence; this.value = -1; } ... setters and getters go here... }\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" Eclipse shows the following output in its console window (with \"…​snip…​\" indicating lines that were removed to save space): recurse for 50 recurse for 49 recurse for 48 recurse for 47 ...snip... recurse for 5 recurse for 4 recurse for 3 recurse for 2 1 == 1 2 == 1 3 == 2 4 == 3 5 == 5 6 == 8 ...snip... 47 == 2971215073 48 == 4807526976 49 == 7778742049 50 == 12586269025 To kick this off from Java we only insert a single Fibonacci object, with a sequence field of 50. A recursive rule is then used to insert the other 49 objects. This example doesn’t use . It uses the MVEL dialect, which means we can use the keyword, which allows a block setter action which also notifies the engine of changes. The rule Recurse is very simple. It matches each asserted object with a value of -1, creating and asserting a new object with a sequence of one less than the currently matched object. Each time a Fibonacci object is added while the one with a sequence field equal to 1 does not exist, the rule re-matches and fires again. The conditional element is used to stop the rule’s matching once we have all 50 Fibonacci objects in memory. The rule also has a salience value, because we need to have all 50 objects asserted before we execute the Bootstrap rule. rule Recurse salience 10 when f : Fibonacci ( value == -1 ) not ( Fibonacci ( sequence == 1 ) ) then insert( new Fibonacci( f.sequence - 1 ) ); System.out.println( \"recurse for \" + f.sequence ); end The Audit view shows the original assertion of the object with a sequence field of 50, done from Java code. From there on, the Audit view shows the continual recursion of the rule, where each asserted object causes the Recurse rule to become activated and to fire again. When a object with a sequence field of 2 is asserted the \"Bootstrap\" rule is matched and activated along with the \"Recurse\" rule. Note the multi-restriction on field , testing for equality with 1 or 2. rule Bootstrap when f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction then modify ( f ){ value = 1 }; System.out.println( f.sequence + \" == \" + f.value ); end At this point the Agenda looks as shown below. However, the \"Bootstrap\" rule does not fire because the \"Recurse\" rule has a higher salience. When a object with a sequence of 1 is asserted the Bootstrap rule is matched again, causing two activations for this rule. Note that the \"Recurse\" rule does not match and activate because the conditional element stops the rule’s matching as soon as a object with a sequence of 1 exists. Once we have two objects with values not equal to -1 the \"Calculate\" rule is able to match. It was the \"Bootstrap\" rule that set the objects with sequence 1 and 2 to values of 1. At this point we have 50 Fibonacci objects in the Working Memory. Now we need to select a suitable triple to calculate each of their values in turn. Using three Fibonacci patterns in a rule without field constraints to confine the possible cross products would result in 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect. The \"Calculate\" rule uses field constraints to correctly constraint the thee Fibonacci patterns in the correct order; this technique is called cross product matching. The first pattern finds any Fibonacci with a value != -1 and binds both the pattern and the field. The second Fibonacci does this, too, but it adds an additional field constraint to ensure that its sequence is greater by one than the Fibonacci bound to . When this rule fires for the first time, we know that only sequences 1 and 2 have values of 1, and the two constraints ensure that references sequence 1 and references sequence 2. The final pattern finds the Fibonacci with a value equal to -1 and with a sequence one greater than . At this point, we have three objects correctly selected from the available cross products, and we can calculate the value for the third object that’s bound to . rule Calculate when // Bind f1 and s1 f1 : Fibonacci( s1 : sequence, value != -1 ) // Bind f2 and v2; refer to bound variable s1 f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 ) // Bind f3 and s3; alternative reference of f2.sequence f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 ) then // Note the various referencing techniques. modify ( f3 ) { value = f1.value + v2 }; System.out.println( s3 + \" == \" + f3.value ); end The statement updated the value of the object bound to . This means we now have another new Fibonacci object with a value not equal to -1, which allows the \"Calculate\" rule to rematch and calculate the next Fibonacci number. The Audit view below shows how the firing of the last \"Bootstrap\" modifies the object, enabling the \"Calculate\" rule to match, which then modifies another Fibonacci object allowing the \"Calculate\" rule to match again. This continues till the value is set for all objects. This tutorial demonstrates the process of developing a complete personal banking application to handle credits and debits on multiple accounts. It uses a set of design patterns that have been created for the process. The class is a simple harness to execute one or more DRL files against a set of data. It compiles the Packages and creates the Knowledge Base for each execution, allowing us to easily execute each scenario and inspect the outputs. In reality this is not a good solution for a production system, where the Knowledge Base should be built just once and cached, but for the purposes of this tutorial it shall suffice. The first of our sample Java classes loads and executes a single DRL file, Example.drl , but without inserting any data. public class Example1 { public static void main(String[] args) throws Exception { new RuleRunner().runRules( new String[] { \"Example1.drl\" }, new Object[0] ); } } The first simple rule to execute has a single condition that will always be true, so that this rule will match and fire, once, after the start. The output for the rule is below, showing that the rule matches and executes the single print statement. The next step is to assert some simple facts and print them out. public class Example2 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example2.drl\" }, numbers ); } private static Integer wrap( int i ) { return new Integer(i); } } This doesn’t use any specific facts but instead asserts a set of objects. This is not considered \"best practice\" as a number is not a useful fact, but we use it here to demonstrate basic techniques before more complexity is added. Now we will create a simple rule to print out these numbers. rule \"Rule 02\" when Number( $intValue : intValue ) then System.out.println( \"Number found with value: \" + $intValue ); end Once again, this rule does nothing special. It identifies any facts that are objects and prints out the values. Notice the use of the abstract class : we inserted objects but we now look for any kind of number. The pattern matching engine is able to match interfaces and superclasses of asserted objects. The output shows the DRL being loaded, the facts inserted and then the matched and fired rules. We can see that each inserted number is matched and fired and thus printed. Loading file: Example2.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 5 Number found with value: 1 Number found with value: 4 Number found with value: 1 Number found with value: 3 There are certainly many better ways to sort numbers than using rules, but since we will need to apply some cashflows in date order when we start looking at banking rules we’ll develop simple rule based sorting technique. public class Example3 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example3.drl\" }, numbers ); } private static Integer wrap(int i) { return new Integer(i); } } Again we insert our objects, but this time the rule is slightly different: rule \"Rule 03\" when $number : Number( ) not Number( intValue < $number.intValue ) then System.out.println(\"Number found with value: \" + $number.intValue() ); retract( $number ); end The first line of the rule identifies a and extracts the value. The second line ensures that there does not exist a smaller number than the one found by the first pattern. We might expect to match only one number - the smallest in the set. However, the retraction of the number after it has been printed means that the smallest number has been removed, revealing the next smallest number, and so on. The resulting output shows that the numbers are now sorted numerically. Loading file: Example3.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 1 Number found with value: 1 Number found with value: 3 Number found with value: 4 Number found with value: 5 We are ready to start moving towards our personal accounting rules. The first step is to create a object. Class has two simple attributes, a date and an amount. (Note that using the type for monetary units is generally not a good idea because floating point numbers cannot represent most numbers accurately.) There is also an overloaded constructor to set the values, and a method to print a cashflow. The Java code of Example4.java inserts five Cashflow objects, with varying dates and amounts. public class Example4 { public static void main(String[] args) throws Exception { Object[] cashflows = { new Cashflow(new SimpleDate(\"01/01/2007\"), 300.00), new Cashflow(new SimpleDate(\"05/01/2007\"), 100.00), new Cashflow(new SimpleDate(\"11/01/2007\"), 500.00), new Cashflow(new SimpleDate(\"07/01/2007\"), 800.00), new Cashflow(new SimpleDate(\"02/01/2007\"), 400.00), }; new RuleRunner().runRules( new String[] { \"Example4.drl\" }, cashflows ); } } The convenience class extends , providing a constructor taking a String as input and defining a date format. The code is listed below Now, let’s look at Example4.drl to see how we print the sorted objects: rule \"Rule 04\" when $cashflow : Cashflow( $date : date, $amount : amount ) not Cashflow( date < $date) then System.out.println(\"Cashflow: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a and extract the date and the amount. In the second line of the rule we ensure that there is no Cashflow with an earlier date than the one found. In the consequence, we print the that satisfies the rule and then retract it, making way for the next earliest . So, the output we generate is: Next, we extend our , resulting in a which can be a credit or a debit operation. (Normally, we would just add this to the type, but we use extension to keep the previous version of the class intact.) There are lots of ways to improve this code, but for the sake of the example this will do. Now let’s create Example5, a class for running our code. public class Example5 { public static void main(String[] args) throws Exception { Object[] cashflows = { new TypedCashflow(new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new TypedCashflow(new SimpleDate(\"05/01/2007\"), TypedCashflow.CREDIT, 100.00), new TypedCashflow(new SimpleDate(\"11/01/2007\"), TypedCashflow.CREDIT, 500.00), new TypedCashflow(new SimpleDate(\"07/01/2007\"), TypedCashflow.DEBIT, 800.00), new TypedCashflow(new SimpleDate(\"02/01/2007\"), TypedCashflow.DEBIT, 400.00), }; new RuleRunner().runRules( new String[] { \"Example5.drl\" }, cashflows ); } } Here, we simply create a set of objects which are either credit or debit operations. We supply them and Example5.drl to the RuleEngine. Now, let’s look at a rule printing the sorted objects. rule \"Rule 05\" when $cashflow : TypedCashflow( $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not TypedCashflow( date < $date, type == TypedCashflow.CREDIT ) then System.out.println(\"Credit: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a fact with a type of and extract the date and the amount. In the second line of the rule we ensure that there is no of the same type with an earlier date than the one found. In the consequence, we print the cashflow satisfying the patterns and then retract it, making way for the next earliest cashflow of type . So, the output we generate is Continuing our banking exercise, we are now going to process both credits and debits on two bank accounts, calculating the account balance. In order to do this, we create two separate objects and inject them into the objects before passing them to the Rule Engine. The reason for this is to provide easy access to the correct account without having to resort to helper classes. Let’s take a look at the class first. This is a simple Java object with an account number and balance: Now let’s extend our , resulting in , to include an reference. The Java code of Example5.java creates two objects and passes one of them into each cashflow, in the constructor call. public class Example6 { public static void main(String[] args) throws Exception { Account acc1 = new Account(1); Account acc2 = new Account(2); Object[] cashflows = { new AllocatedCashflow(acc1,new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/02/2007\"), TypedCashflow.CREDIT, 100.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/03/2007\"), TypedCashflow.CREDIT, 500.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/02/2007\"), TypedCashflow.DEBIT, 800.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/03/2007\"), TypedCashflow.DEBIT, 400.00), new AllocatedCashflow(acc1,new SimpleDate(\"01/04/2007\"), TypedCashflow.CREDIT, 200.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/04/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/05/2007\"), TypedCashflow.CREDIT, 700.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/05/2007\"), TypedCashflow.DEBIT, 900.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/05/2007\"), TypedCashflow.DEBIT, 100.00) }; new RuleRunner().runRules( new String[] { \"Example6.drl\" }, cashflows ); } } Now, let’s look at the rule in Example6.drl to see how we apply each cashflow in date order and calculate and print the balance. rule \"Rule 06 - Credit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Credit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance()+$amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end rule \"Rule 06 - Debit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.DEBIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Debit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance() - $amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end Although we have separate rules for credits and debits, but we do not specify a type when checking for earlier cashflows. This is so that all cashflows are applied in date order, regardless of the cashflow type. In the conditions we identify the account to work with, and in the consequences we update it with the cashflow amount. Loading file: Example6.drl Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0] Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0 Account: 2 - new balance: -400.0 Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0 Account: 2 - new balance: 100.0 Debit: Wed May 02 00:00:00 BST 2007 :: 100.0 Account: 2 - new balance: 0.0 Credit: Fri May 11 00:00:00 BST 2007 :: 700.0 Account: 2 - new balance: 700.0 Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0 Account: 1 - new balance: 300.0 Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0 Account: 1 - new balance: 400.0 Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0 Account: 1 - new balance: -400.0 Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0 Account: 1 - new balance: -200.0 Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0 Account: 1 - new balance: 100.0 Debit: Mon May 07 00:00:00 BST 2007 :: 900.0 Account: 1 - new balance: -800.0 The Pricing Rule decision table demonstrates the use of a decision table in a spreadsheet, in Excel’s XLS format, in calculating the retail cost of an insurance policy. The purpose of the provide set of rules is to calculate a base price and a discount for a car driver applying for a specific policy. The driver’s age, history and the policy type all contribute to what the basic premium is, and an additional chunk of rules deals with refining this with a discount percentage. Open the file PricingRuleDTExample.java and execute it as a Java application. It should produce the following output in the Console window: Cheapest possible BASE PRICE IS: 120 DISCOUNT IS: 20 The code to execute the example follows the usual pattern. The rules are loaded, the facts inserted and a Stateless Session is created. What is different is how the rules are added. Note the use of the object. Its input type is set to . If you use the BRMS, all this is of course taken care of for you. There are two fact types used in this example, and . Both are used with their default values. The is 30 years old, has had no prior claims and currently has a risk profile of . The being applied for is , and it has not yet been approved. In this decision table, each row is a rule, and each column is a condition or an action. Referring to the spreadsheet show above, we have the declaration, which provides the package name. There are also other optional items you can have here, such as for global variables, and for importing classes. In this case, the namespace of the rules is the same as the fact classes we are using, so we can omit it. Moving further down, we can see the declaration. The name after this (Pricing bracket) is used as the prefix for all the generated rules. Below that, we have \"CONDITION or ACTION\", indicating the purpose of the column, i.e., whether it forms part of the condition or the consequence of the rule that will be generated. You can see that there is a driver, his data spanned across three cells, which means that the template expressions below it apply to that fact. We observe the driver’s age range (which uses and with comma-separated values), , and in the respective columns. In the action columns, we are set the policy base price and log a message. In the preceding spreadsheet section, there are broad category brackets, indicated by the comment in the leftmost column. As we know the details of our drivers and their policies, we can tell (with a bit of thought) that they should match row number 18, as they have no prior accidents, and are 30 years old. This gives us a base price of 120. The above section contains the conditions for the discount we might grant our driver. The discount results from the bracket, the number of prior claims, and the policy type. In our case, the driver is 30, with no prior claims, and is applying for a policy, which means we can give a discount of 20%. Note that this is actually a separate table, but in the same worksheet, so that different templates apply. It is important to note that decision tables generate rules. This means they aren’t simply top-down logic, but more a means to capture data resulting in rules. This is a subtle difference that confuses some people. The evaluation of the rules is not necessarily in the given order, since all the normal mechanics of the rule engine still apply. Name: Pet Store Main class: org.drools.examples.petstore.PetStoreExample Module: drools-examples Type: Java application Rules file: PetStore.drl Objective: Demonstrate use of Agenda Groups, Global Variables and integration with a GUI, including callbacks from within the rules The Pet Store example shows how to integrate Rules with a GUI, in this case a Swing based desktop application. Within the rules file, it demonstrates how to use Agenda groups and auto-focus to control which of a set of rules is allowed to fire at any given time. It also illustrates the mixing of the Java and MVEL dialects within the rules, the use of accumulate functions and the way of calling Java functions from within the ruleset. All of the Java code is contained in one file, PetStore.java , defining the following principal classes (in addition to several classes to handle Swing Events):\n• contains the method that we will look at shortly.\n• is responsible for creating and displaying the Swing based GUI. It contains several smaller classes, mainly for responding to various GUI events such as mouse button clicks.\n• holds the table data. Think of it as a JavaBean that extends the Swing class .\n• allows the GUI to interact with the Rules.\n• keeps the items that we wish to buy.\n• stores details of the order and the products we are buying.\n• is a JavaBean holding details of the product available for purchase, and its price. Much of the Java code is either plain JavaBeans or Swing-based. Only a few Swing-related points will be discussed in this section, but a good tutorial about Swing components can be found at Sun’s Swing website, in http://java.sun.com/docs/books/tutorial/uiswing/. The pieces of Java code in Petstore.java that relate to rules and facts are shown below. Example 305. Creating the PetStore KieContainer in PetStore.main // KieServices is the factory for all KIE services KieServices ks = KieServices.Factory.get(); // From the kie services, a container is created from the classpath KieContainer kc = ks.getKieClasspathContainer(); // Create the stock. Vector<Product> stock = new Vector<Product>(); stock.add( new Product( \"Gold Fish\", 5 ) ); stock.add( new Product( \"Fish Tank\", 25 ) ); stock.add( new Product( \"Fish Food\", 2 ) ); // A callback is responsible for populating the // Working Memory and for firing all rules. PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( kc ) ); ui.createAndShowGUI(); The code shown above create a from the classpath and based on the definitions in the kmodule.xml file. Unlike other examples where the facts are asserted and fired straight away, this example defers this step to later. The way it does this is via the second last line where a object is created using a constructor accepting the object collecting our products, and an instance of the class containing the Rule Base that we have just loaded. The Java code that fires the rules is within the method. This is triggered (eventually) when the Checkout button is pressed by the user. Example 306. Firing the Rules - extract from CheckoutCallBack.checkout() public String checkout(JFrame frame, List<Product> items) { Order order = new Order(); // Iterate through list and add to cart for ( Product p: items ) { order.addItem( new Purchase( order, p ) ); } // Add the JFrame to the ApplicationData to allow for user interaction // From the container, a session is created based on // its definition and configuration in the META-INF/kmodule.xml file KieSession ksession = kcontainer.newKieSession(\"PetStoreKS\"); ksession.setGlobal( \"frame\", frame ); ksession.setGlobal( \"textArea\", this.output ); ksession.insert( new Product( \"Gold Fish\", 5 ) ); ksession.insert( new Product( \"Fish Tank\", 25 ) ); ksession.insert( new Product( \"Fish Food\", 2 ) ); ksession.insert( new Product( \"Fish Food Sample\", 0 ) ); ksession.insert( order ); ksession.fireAllRules(); // Return the state of the cart return order.toString(); } Two items get passed into this method. One is the handle to the Swing component surrounding the output text frame, at the bottom of the GUI. The second is a list of order items; this comes from the storing the information from the \"Table\" area at the top right section of the GUI. The for loop transforms the list of order items coming from the GUI into the JavaBean, also contained in the file PetStore.java . Note that it would be possible to refer to the Swing dataset directly within the rules, but it is better coding practice to do it this way, using simple Java objects. It means that we are not tied to Swing if we wanted to transform the sample into a Web application. It is important to note that all state in this example is stored in the Swing components, and that the rules are effectively stateless. Each time the \"Checkout\" button is pressed, this code copies the contents of the Swing into the Session’s Working Memory. Within this code, there are nine calls to the . The first of these creates a new from the . Remember that we passed in this when we created the class in the method. The next two calls pass in two objects that we will hold as global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the , as well as the order list. The final call is the standard . Next, we look at what this method causes to happen within the rules file. Example 307. Package, Imports, Globals and Dialect: extract from PetStore.drl The first part of file PetStore.drl contains the standard package and import statements to make various Java classes available to the rules. New to us are the two globals and . They hold references to the Swing components and components that were previously passed on by the Java code calling the method. Unlike variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the Session. The next extract from the file PetStore.drl contains two functions that are referenced by the rules that we will look at shortly. Example 308. Java Functions in the Rules: extract from PetStore.drl function void doCheckout(JFrame frame, KieRuntime krt) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to checkout?\", \"\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (n == 0) { krt.getAgenda().getAgendaGroup( \"checkout\" ).setFocus(); } } function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to buy a tank for your \" + total + \" fish?\", \"Purchase Suggestion\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); System.out.print( \"SUGGESTION: Would you like to buy a tank for your \" + total + \" fish? - \" ); if (n == 0) { Purchase purchase = new Purchase( order, fishTank ); krt.insert( purchase ); order.addItem( purchase ); System.out.println( \"Yes\" ); } else { System.out.println( \"No\" ); } return true; } Having these functions in the rules file just makes the Pet Store example more compact. In real life you probably have the functions in a file of their own, within the same rules package, or as a static method on a standard Java class, and import them, using . The purpose of these two functions is:\n• displays a dialog asking users whether they wish to checkout. If they do, focus is set to the agenda-group, allowing rules in that group to (potentially) fire.\n• displays a dialog asking users whether they wish to buy a tank. If so, a new fish tank is added to the order list in Working Memory. We’ll see the rules that call these functions later on. The next set of examples are from the Pet Store rules themselves. The first extract is the one that happens to fire first, partly because it has the attribute set to true. Example 309. Putting items into working memory: extract from PetStore.drl // Insert each item in the shopping cart into the Working Memory // Insert each item in the shopping cart into the Working Memory rule \"Explode Cart\" agenda-group \"init\" auto-focus true salience 10 dialect \"java\" when $order : Order( grossTotal == -1 ) $item : Purchase() from $order.items then insert( $item ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"show items\" ).setFocus(); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"evaluate\" ).setFocus(); end This rule matches against all orders that do not yet have their calculated . It loops for each purchase item in that order. Some parts of the \"Explode Cart\" rule should be familiar: the rule name, the salience (suggesting the order for the rules being fired) and the dialect set to . There are three new features:\n• `agenda-group defines the name of the agenda group. In this case, there is only one rule in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the next attribute for its chance to fire.\n• auto-focus ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when `fireAllRules() is called from the Java code.\n• sets the focus to the and agenda groups in turn, permitting their rules to fire. In practice, we loop through all items on the order, inserting them into memory, then firing the other rules after each insert. The next two listings show the rules within the and agenda groups. We look at them in the order that they are called. Example 310. Show Items in the GUI - extract from PetStore.drl The agenda-group has only one rule, called \"Show Items\" (note the difference in case). For each purchase on the order currently in the Working Memory (or Session), it logs details to the text area at the bottom of the GUI. The variable used to do this is one of the global variables we looked at earlier. The Agenda group also gains focus from the rule listed previously. This Agenda group has two rules, and , shown below. // Free Fish Food sample when we buy a Gold Fish if we haven't already bought // Fish Food and don't already have a Fish Food Sample rule \"Free Fish Food Sample\" agenda-group \"evaluate\" dialect \"mvel\" when $order : Order() not ( $p : Product( name == \"Fish Food\") && Purchase( product == $p ) ) not ( $p : Product( name == \"Fish Food Sample\") && Purchase( product == $p ) ) exists ( $p : Product( name == \"Gold Fish\") && Purchase( product == $p ) ) $fishFoodSample : Product( name == \"Fish Food Sample\" ); then System.out.println( \"Adding free Fish Food Sample to cart\" ); purchase = new Purchase($order, $fishFoodSample); insert( purchase ); $order.addItem( purchase ); end // Suggest a tank if we have bought more than 5 gold fish and don't already have one rule \"Suggest Tank\" agenda-group \"evaluate\" dialect \"java\" when $order : Order() not ( $p : Product( name == \"Fish Tank\") && Purchase( product == $p ) ) ArrayList( $total : size > 5 ) from collect( Purchase( product.name == \"Gold Fish\" ) ) $fishTank : Product( name == \"Fish Tank\" ) then requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); end The rule will only fire if\n• we don’t already have any fish food, and\n• we don’t already have a free fish food sample, and\n• we do have a Gold Fish in our order. If the rule does fire, it creates a new product (Fish Food Sample), and adds it to the order in Working Memory. The rule will only fire if\n• we don’t already have a Fish Tank in our order, and\n• we do have more than 5 Gold Fish Products in our order. If the rule does fire, it calls the function that we looked at earlier (showing a Dialog to the user, and adding a Tank to the order / working memory if confirmed). When calling the requireTank() function the rule passes the global frame variable so that the function has a handle to the Swing GUI. The next rule we look at is . Example 312. Doing the Checkout - extract (6) from PetStore.drl rule \"do checkout\" dialect \"java\" when then doCheckout(frame, kcontext.getKieRuntime()); end The rule has no agenda group set and no auto-focus attribute. As such, is is deemed part of the default (MAIN) agenda group. This group gets focus by default when all the rules in agenda-groups that explicitly had focus set to them have run their course. There is no LHS to the rule, so the RHS will always call the function. When calling the function, the rule passes the global variable to give the function a handle to the Swing GUI. As we saw earlier, the function shows a confirmation dialog to the user. If confirmed, the function sets the focus to the checkout agenda-group, allowing the next lot of rules to fire. rule \"Gross Total\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal == -1) Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ), sum( $price ) ) then modify( $order ) { grossTotal = total }; textArea.append( \"\n\ngross total=\" + total + \"\n\n\" ); end rule \"Apply 5% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 10 && < 20 ) then $order.discountedTotal = $order.grossTotal * 0.95; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end rule \"Apply 10% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 20 ) then $order.discountedTotal = $order.grossTotal * 0.90; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end There are three rules in the checkout agenda-group:\n• If we haven’t already calculated the gross total, accumulates the product prices into a total, puts this total into the session, and displays it via the Swing , using the global variable yet again.\n• If our gross total is between 10 and 20, calculates the discounted total and adds it to the session and displays it in the text area.\n• If our gross total is not less than 20, calculates the discounted total and adds it to the session and displays it in the text area. Now that we’ve run through what happens in the code, let’s have a look at what happens when we actually run the code. The file PetStore.java contains a method, so that it can be run as a standard Java application, either from the command line or via the IDE. This assumes you have your classpath set correctly. (See the start of the examples section for more information.) The first screen that we see is the Pet Store Demo. It has a list of available products (top left), an empty list of selected products (top right), checkout and reset buttons (middle) and an empty system messages area (bottom). To get to this point, the following things have happened:\n• The method has run and loaded the Rule Base but not yet fired the rules. So far, this is the only code in connection with rules that has been run.\n• A new object has been created and given a handle to the Rule Base, for later use.\n• Various Swing components do their stuff, and the above screen is shown and waits for user input. Clicking on various products from the list might give you a screen similar to the one below. Note that no rules code has been fired here. This is only Swing code, listening for mouse click events, and adding some selected product to the object for display in the top right hand section. (As an aside, note that this is a classic use of the Model View Controller design pattern). It is only when we press the \"Checkout\" button that we fire our business rules, in roughly the same order that we walked through the code earlier.\n• Method is called (eventually) by the Swing class waiting for the click on the \"Checkout\" button. This inserts the data from the object (top right hand side of the GUI), and inserts it into the Session’s Working Memory. It then fires the rules.\n• The rule is the first to fire, given that it has set to true. It loops through all the products in the cart, ensures that the products are in the Working Memory, and then gives the and agenda groups a chance to fire. The rules in these groups add the contents of the cart to the text area (at the bottom of the window), decide whether or not to give us free fish food, and to ask us whether we want to buy a fish tank. This is shown in the figure below. Figure 401. Do we want to buy a fish tank?\n• The Do Checkout rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the doCheckout() function which displays a 'Would you like to Checkout?' Dialog Box.\n• The function sets the focus to the agenda-group, giving the rules in that group the option to fire.\n• The rules in the the agenda-group display the contents of the cart and apply the appropriate discount.\n• Swing then waits for user input to either checkout more products (and to cause the rules to fire again), or to close the GUI - see the figure below. Figure 402. Petstore Demo after all rules have fired. We could add more System.out calls to demonstrate this flow of events. The output, as it currently appears in the Console window, is given in the listing below. Example 314. Console (System.out) from running the PetStore GUI Adding free Fish Food Sample to cart SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes Name: Honest Politician Main class: org.drools.examples.honestpolitician.HonestPoliticianExample Module: drools-examples Type: Java application Rules file: HonestPoliticianExample.drl Objective: Illustrate the concept of \"truth maintenance\" based on the logical insertion of facts The Honest Politician example demonstrates truth maintenance with logical assertions. The basic premise is that an object can only exist while a statement is true. A rule’s consequence can logically insert an object with the method. This means the object will only remain in the Working Memory as long as the rule that logically inserted it remains true. When the rule is no longer true the object is automatically retracted. In this example there is the class , with a name and a boolean value for being honest. Four politicians with honest state set to true are inserted. Politician blair = new Politician(\"blair\", true); Politician bush = new Politician(\"bush\", true); Politician chirac = new Politician(\"chirac\", true); Politician schroder = new Politician(\"schroder\", true); ksession.insert( blair ); ksession.insert( bush ); ksession.insert( chirac ); ksession.insert( schroder ); ksession.fireAllRules(); The Console window output shows that, while there is at least one honest politician, democracy lives. However, as each politician is in turn corrupted by an evil corporation, so that all politicians become dishonest, democracy is dead. Hurrah!!! Democracy Lives I'm an evil corporation and I have corrupted schroder I'm an evil corporation and I have corrupted chirac I'm an evil corporation and I have corrupted bush I'm an evil corporation and I have corrupted blair We are all Doomed!!! Democracy is Dead As soon as there is at least one honest politician in the Working Memory a new object is logically asserted. This object will only exist while there is at least one honest politician. As soon as all politicians are dishonest, the object will be automatically retracted. This rule is given a salience of 10 to ensure that it fires before any other rule, as at this stage the \"Hope is Dead\" rule is actually true. Example 318. Honest Politician: Rule \"We have an honest politician\" rule \"We have an honest Politician\" salience 10 when exists( Politician( honest == true ) ) then insertLogical( new Hope() ); end As soon as a object exists the \"Hope Lives\" rule matches and fires. It has a salience of 10 so that it takes priority over \"Corrupt the Honest\". Now that there is hope and we have, at the start, four honest politicians, we have four activations for this rule, all in conflict. They will fire in turn, corrupting each politician so that they are no longer honest. When all four politicians have been corrupted we have no politicians with the property . Thus, the rule \"We have an honest Politician\" is no longer true and the object it logical inserted (due to the last execution of ) is automatically retracted. rule \"Corrupt the Honest\" when politician : Politician( honest == true ) exists( Hope() ) then System.out.println( \"I'm an evil corporation and I have corrupted \" + politician.getName() ); modify ( politician ) { honest = false }; end With the object being automatically retracted, via the truth maintenance system, the conditional element applied to is no longer true so that the following rule will match and fire. rule \"Hope is Dead\" when not( Hope() ) then System.out.println( \"We are all Doomed!!! Democracy is Dead\" ); end Let’s take a look at the Audit trail for this application: The moment we insert the first politician we have two activations. The rule \"We have an honest Politician\" is activated only once for the first inserted politician because it uses an conditional element, which matches once for any number. The rule \"Hope is Dead\" is also activated at this stage, because we have not yet inserted the object. Rule \"We have an honest Politician\" fires first, as it has a higher salience than \"Hope is Dead\", which inserts the object. (That action is highlighted green.) The insertion of the object activates \"Hope Lives\" and de-activates \"Hope is Dead\"; it also activates \"Corrupt the Honest\" for each inserted honest politician. Rule \"Hope Lives\" executes, printing \"Hurrah!!! Democracy Lives\". Then, for each politician, rule \"Corrupt the Honest\" fires, printing \"I’m an evil corporation and I have corrupted X\", where X is the name of the politician, and modifies the politician’s honest value to false. When the last honest politician is corrupted, is automatically retracted, by the truth maintenance system, as shown by the blue highlighted area. The green highlighted area shows the origin of the currently selected blue highlighted area. Once the fact is retracted, \"Hope is dead\" activates and fires printing \"We are all Doomed!!! Democracy is Dead\". Name: Sudoku Main class: org.drools.examples.sudoku.SudokuExample Type: Java application Rules file: sudoku.drl, validate.drl Objective: Demonstrates the solving of logic problems, and complex pattern matching. This example demonstrates how Drools can be used to find a solution in a large potential solution space based on a number of constraints. We use the popular puzzle of Sudoku. This example also shows how Drools can be integrated into a graphical interface and how callbacks can be used to interact with a running Drools rules engine in order to update the graphical interface based on changes in the Working Memory at runtime. Sudoku is a logic-based number placement puzzle. The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9, once, and only once. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints. The general strategy to solve the problem is to ensure that when you insert a new number it should be unique in its particular 3x3 zone, row and column. See Wikipedia for a more detailed description. Download and install drools-examples as described above and then execute java org.drools.examples.DroolsExamplesApp and click on \"SudokuExample\". The window contains an empty grid, but the program comes with a number of grids stored internally which can be loaded and solved. Click on \"File\", then \"Samples\" and select \"Simple\" to load one of the examples. Note that all buttons are disabled until a grid is loaded. Loading the \"Simple\" example fills the grid according to the puzzle’s initial state. Click on the \"Solve\" button and the Drools-based engine will fill out the remaining values, and the buttons are inactive once more. Alternatively, you may click on the \"Step\" button to see the next digit found by the rule set. The Console window will display detailed information about the rules which are executing to solve the step in a human readable form. Some examples of these messages are presented below. single 8 at [0,1] column elimination due to [1,2]: remove 9 from [4,2] hidden single 9 at [1,2] row elimination due to [2,8]: remove 7 from [2,4] remove 6 from [3,8] due to naked pair at [3,2] and [3,7] hidden pair in row at [4,6] and [4,4] Click on the \"Dump\" button to see the state of the grid, with cells showing either the established value or the remaining possibilitiescandidates. Now, let us load a Sudoku grid that is deliberately invalid. Click on \"File\", \"Samples\" and \"!DELIBERATELY BROKEN!\". Note that this grid starts with some issues, for example the value 5 appears twice in the first row. A few simple rules perform a sanity check, right after loading a grid. In this case, the following messages are printed on standard output: cell [0,8]: 5 has a duplicate in row 0 cell [0,0]: 5 has a duplicate in row 0 cell [6,0]: 8 has a duplicate in col 0 cell [4,0]: 8 has a duplicate in col 0 Validation complete. Nevertheless, click on the \"Solve\" button to apply the solving rules to this invalid grid. This will not complete; some cells remain empty. The solving functionality has been achieved by the use of rules that implement standard solving techniques. They are based on the sets of values that are still candidates for a cell. If, for instance, such a set contains a single value, then this is the value for the cell. A little less obvious is the single occurrence of a value in one of the groups of nine cells. The rules detecting these situations insert a fact of type Setting with the solution value for some specific cell. This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to. Finally, it is retracted. Other rules merely reduce the permissible values for some cells. Rules \"naked pair\", \"hidden pair in row\", \"hidden pair in column\" and \"hidden pair in square\" merely eliminate possibilities but do not establish solutions. More sophisticated eliminations are done by \"X-wings in rows\", \"X-wings in columns\", \"intersection removal row\" and \"intersection removal column\". The Java source code can be found in the /src/main/java/org/drools/examples/sudoku directory, with the two DRL files defining the rules located in the /src/main/rules/org/drools/examples/sudoku directory. The package contains a set of classes which implement a framework for Sudoku puzzles. Note that this package does not have any dependencies on the Drools libraries. defines an interface which can be implemented to store a Sudoku puzzle as a 9x9 grid of objects. is a Swing component which can visualize any implementation of . and are used to communicate state changes between the model and the view: events are fired when a cell’s value is resolved or changed. If you are familiar with the model-view-controller patterns in other Swing components such as then this pattern should be familiar. provides a number of partially filled Sudoku puzzles for demonstration purposes. Package contains a utility class with a method for compiling DRL files. The package contains a set of classes implementing the elementary object and its various aggregations: the subtypes and as well as , all of which are subtypes of . It’s interesting to note that and are subclasses of , which provides a property with the type . For a it represents the individual candidate set; for a the set is the union of all candidate sets of its cells, or, simply, the set of digits that still need to be allocated. With 81 and 27 objects and the linkage provided by the properties , and and the property , a list of objects, it is possible to write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set. An object of class is used for triggering the operations that accompany the allocation of a value: its removal from the candidate sets of sibling cells and associated cell groups. Moreover, the presence of a fact is used in all rules that should detect a new situation; this is to avoid reactions to inconsistent intermediary states. An object of class is used in a low priority rule to execute an emergency halt when a \"Step\" does not terminate regularly. This indicates that the puzzle cannot be solved by the program. The class implements a Java application combining the components described. Validation rules detect duplicate numbers in cell groups. They are combined in an agenda group which enables us to activate them, explicitly, after loading a puzzle. The three rules \"duplicate in cell…​\" are very similar. The first pattern locates a cell with an allocated value. The second pattern pulls in any of the three cell groups the cell belongs to. The final pattern would find a cell (other than the first one) with the same value as the first cell and in the same row, column or square, respectively. Rule \"terminate group\" fires last. It prints a message and calls halt. There are three types of rules in this file: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets. Rules \"set a value\", \"eliminate a value from Cell\" and \"retract setting\" depend on the presence of a object. The first rule handles the assignment to the cell and the operations for removing the value from the \"free\" sets of the cell’s three groups. Also, it decrements a counter that, when zero, returns control to the Java application that has called . The purpose of rule \"eliminate a value from Cell\" is to reduce the candidate lists of all cells that are related to the newly assigned cell. Finally, when all eliminations have been made, rule \"retract setting\" retracts the triggering fact. There are just two rules that detect a situation where an allocation of a number to a cell is possible. Rule \"single\" fires for a with a candidate set containing a single number. Rule \"hidden single\" fires when there is no cell with a single candidate but when there is a cell containing a candidate but this candidate is absent from all other cells in one of the three groups the cell belongs to. Both rules create and insert a fact. Rules from the largest group of rules implement, singly or in groups of two or three, various solving techniques, as they are employed when solving Sudoku puzzles manually. Rule \"naked pair\" detects identical candidate sets of size 2 in two cells of a group; these two values may be removed from all other candidate sets of that group. A similar idea motivates the three rules \"hidden pair in…​\"; here, the rules look for a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of this group. This, then, means that all other candidates can be eliminated from the two cells harbouring the hidden pair. A pair of rules deals with \"X-wings\" in rows and columns. When there are only two possible cells for a value in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated. If you follow the pattern sequence in one of these rules, you will see how the conditions that are conveniently expressed by words such as \"same\" or \"only\" result in patterns with suitable constraints or prefixed with \"not\". The rule pair \"intersection removal…​\" is based on the restricted occurrence of some number within one square, either in a single row or in a single column. This means that this number must be in one of those two or three cells of the row or column; hence it can be removed from the candidate sets of all other cells of the group. The pattern establishes the restricted occurrence and then fires for each cell outside the square and within the same cell file. These rules are sufficient for many but certainly not for all Sudoku puzzles. To solve very difficult grids, the rule set would need to be extended with more complex rules. (Ultimately, there are puzzles that cannot be solved except by trial and error.) Name: Number Guess Main class: org.drools.examples.numberguess.NumberGuessExample Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: NumberGuess.drl Objective: Demonstrate use of Rule Flow to organise Rules The \"Number Guess\" example shows the use of Rule Flow, a way of controlling the order in which rules are fired. It uses widely understood workflow diagrams for defining the order in which groups of rules will be executed. The creation of the package and the loading of the rules (using the method) is the same as the previous examples. There is an additional line to add the Rule Flow (NumberGuess.rf ), which provides the option of specifying different rule flows for the same Knowledge Base. Otherwise, the Knowledge Base is created in the same manner as before. final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession(); KnowledgeRuntimeLogger logger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/numberguess\"); ksession.insert( new GameRules( 100, 5 ) ); ksession.insert( new RandomNumber() ); ksession.insert( new Game() ); ksession.startProcess( \"Number Guess\" ); ksession.fireAllRules(); logger.close(); ksession.dispose(); Once we have a Knowledge Base, we can use it to obtain a Stateful Session. Into our session we insert our facts, i.e., standard Java objects. (For simplicity, in this sample, these classes are all contained within our NumberGuessExample.java file. Class provides the maximum range and the number of guesses allowed. Class automatically generates a number between 0 and 100 and makes it available to our rules, by insertion via the method. Class keeps track of the guesses we have made before, and their number. Note that before we call the standard method, we also start the process that we loaded earlier, via the method. We’ll learn where to obtain the parameter we pass (\"Number Guess\", i.e., the identifier of the rule flow) when we talk about the rule flow file and the graphical Rule Flow Editor below. Before we finish the discussion of our Java code, we note that in some real-life application we would examine the final state of the objects. (Here, we could retrieve the number of guesses, to add it to a high score table.) For this example we are content to ensure that the Working Memory session is cleared by calling the method. Figure 409. RuleFlow for the NumberGuess Example If you open the NumberGuess.rf file in the Drools IDE (provided you have the JBoss Rules extensions installed correctly in Eclipse) you should see the above diagram, similar to a standard flowchart. Its icons are similar (but not exactly the same) as in the JBoss jBPM workflow product. Should you wish to edit the diagram, a menu of available components should be available to the left of the diagram in the IDE, which is called the palette. This diagram is saved in XML, an (almost) human readable format, using XStream. If it is not already open, ensure that the Properties View is visible in the IDE. It can be opened by clicking \"Window\", then \"Show View\" and \"Other\", where you can select the \"Properties\" view. If you do this before you select any item on the rule flow (or click on the blank space in the rule flow) you should be presented with the following set of properties. Keep an eye on the Properties View as we progress through the example’s rule flow, as it presents valuable information. In this case, it provides us with the identification of the Rule Flow Process that we used in our earlier code snippet, when we called . In the \"Number Guess\" Rule Flow we encounter several node types, many of them identified by an icon.\n• The Start node (white arrow in a green circle) and the End node (red box) mark beginning and end of the rule flow.\n• A Rule Flow Group box (yellow, without an icon) represents a Rule Flow Groups defined in our rules (DRL) file that we will look at later. For example, when the flow reaches the Rule Flow Group \"Too High\", only those rules marked with an attribute of `ruleflow-group can potentially fire.\n• Action nodes (yellow, cog-shaped icon) perform standard Java method calls. Most action nodes in this example call , indicating the program’s progress to the user.\n• Split and Join Nodes (blue ovals, no icon) such as \"Guess Correct?\" and \"More guesses Join\" mark places where the flow of control can split, according to various conditions, and rejoin, respectively\n• Arrows indicate the flow between the various nodes. The various nodes in combination with the rules make the Number Guess game work. For example, the \"Guess\" Rule Flow Group allows only the rule \"Get user Guess\" to fire, because only that rule has a matching attribute of `ruleflow-group . Example 324. A Rule firing only at a specific point in the Rule Flow: NumberGuess.drl rule \"Get user Guess\" ruleflow-group \"Guess\" no-loop when $r : RandomNumber() rules : GameRules( allowed : allowedGuesses ) game : Game( guessCount < allowed ) not ( Guess() ) then System.out.println( \"You have \" + ( rules.allowedGuesses - game.guessCount ) + \" out of \" + rules.allowedGuesses + \" guesses left.\n\nPlease enter your guess from 0 to \" + rules.maxRange ); br = new BufferedReader( new InputStreamReader( System.in ) ); i = br.readLine(); modify ( game ) { guessCount = game.guessCount + 1 } insert( new Guess( i ) ); end The rest of this rule is fairly standard. The LHS section (after ) of the rule states that it will be activated for each object inserted into the Working Memory where is less than from the object and where the user has not guessed the correct number. The RHS section (or consequence, after ) prints a message to the user and then awaits user input from . After obtaining this input (the method call blocks until the return key is pressed) it modifies the guess count and inserts the new guess, making both available to the Working Memory. The rest of the rules file is fairly standard: the package declares the dialect as MVEL, and various Java classes are imported. In total, there are five rules in this file:\n• Get User Guess, the Rule we examined above.\n• A Rule to inspect the guess and retract it from memory if incorrect.\n• A Rule that notifies the user that all guesses have been used up. One point of integration between the standard Rules and the RuleFlow is via the attribute on the rules, as discussed above. A second point of integration between the rules (.drl) file and the Rules Flow .rf files is that the Split Nodes (the blue ovals) can use values in the Working Memory (as updated by the rules) to decide which flow of action to take. To see how this works, click on the \"Guess Correct Node\"; then within the Properties View, open the Constraints Editor by clicking the button at the right that appears once you click on the \"Constraints\" property line. You should see something similar to the diagram below. Click on the \"Edit\" button beside \"To node Too High\" and you’ll see a dialog like the one below. The values in the \"Textual Editor\" window follow the standard rule format for the LHS and can refer to objects in Working Memory. The consequence (RHS) is that the flow of control follows this node (i.e., \"To node Too High\") if the LHS expression evaluates to true. Figure 412. Constraint Editor for the \"Guess Correct\" Node: value too high Since the file NumberGuess.java contains a method, it can be run as a standard Java application, either from the command line or via the IDE. A typical game might result in the interaction below. The numbers in bold are typed in by the user. Example 325. Example Console output where the Number Guess Example beat the human! You have 5 out of 5 guesses left. Please enter your guess from 0 to 100 50 Your guess was too high You have 4 out of 5 guesses left. Please enter your guess from 0 to 100 25 Your guess was too low You have 3 out of 5 guesses left. Please enter your guess from 0 to 100 37 Your guess was too low You have 2 out of 5 guesses left. Please enter your guess from 0 to 100 44 Your guess was too low You have 1 out of 5 guesses left. Please enter your guess from 0 to 100 47 Your guess was too low You have no more guesses The correct guess was 48 A summary of what is happening in this sample is:\n• The method of NumberGuessExample.java loads a Rule Base, creates a Stateful Session and inserts , and (containing the target number) objects into it. The method also sets the process flow we are going to use, and fires all rules. Control passes to the Rule Flow.\n• File NumberGuess.rf , the Rule Flow, begins at the \"Start\" node.\n• Control passes (via the \"More guesses\" join node) to the Guess node.\n• At the Guess node, the appropriate Rule Flow Group (\"Get user Guess\") is enabled. In this case the Rule \"Guess\" (in the NumberGuess.drl file) is triggered. This rule displays a message to the user, takes the response, and puts it into Working Memory. Flow passes to the next Rule Flow Node.\n• At the next node, \"Guess Correct\", constraints inspect the current session and decide which path to take. If the guess in step 4 was too high or too low, flow proceeds along a path which has an action node with normal Java code printing a suitable message and a Rule Flow Group causing a highest guess or lowest guess rule to be triggered. Flow passes from these nodes to step 6. If the guess in step 4 was right, we proceed along the path towards the end of the Rule Flow. Before we get there, an action node with normal Java code prints a statement \"you guessed correctly\". There is a join node here (just before the Rule Flow end) so that our no-more-guesses path (step 7) can also terminate the Rule Flow.\n• Control passes as per the Rule Flow via a join node, a guess incorrect Rule Flow Group (triggering a rule to retract a guess from Working Memory) onto the \"More guesses\" decision node.\n• The \"More guesses\" decision node (on the right hand side of the rule flow) uses constraints, again looking at values that the rules have put into the working memory, to decide if we have more guesses and if so, goto step 3. If not, we proceed to the end of the rule flow, via a Rule Flow Group that triggers a rule stating \"you have no more guesses\".\n• The loop over steps 3 to 7 continues until the number is guessed correctly, or we run out of guesses. Name: Conway's Game Of Life Main class: org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: conway-ruleflow.drl conway-agendagroup.drl Objective: Demonstrates 'accumulate', 'collect' and 'from' Conway’s Game Of Life, described in http://en.wikipedia.org/wiki/Conway’s_Game_of_Life and in http://www.math.com/students/wonders/life/life.html, is a famous cellular automaton conceived in the early 1970’s by the mathematician John Conway. While the system is well known as \"Conway’s Game Of Life\", it really isn’t a game at all. Conway’s system is more like a simulation of a form of life. Don’t be intimidated. The system is terribly simple and terribly interesting. Math and Computer Science students alike have marvelled over Conway’s system for more than 30 years now. The application presented here is a Swing-based implementation of Conway’s Game of Life. The rules that govern the system are implemented as business rules using Drools. This document will explain the rules that drive the simulation and discuss the Drools parts of the implementation. We’ll first introduce the grid view, shown below, designed for the visualisation of the game, showing the \"arena\" where the life simulation takes place. Initially the grid is empty, meaning that there are no live cells in the system. Each cell is either alive or dead, with live cells showing a green ball. Preselected patterns of live cells can be chosen from the \"Pattern\" drop-down list. Alternatively, individual cells can be doubled-clicked to toggle them between live and dead. It’s important to understand that each cell is related to its neighboring cells, which is fundamental for the game’s rules. Neighbors include not only cells to the left, right, top and bottom but also cells that are connected diagonally, so that each cell has a total of 8 neighbors. Exceptions are the four corner cells which have only three neighbors, and the cells along the four border, with five neighbors each. So what are the basic rules that govern this game? Its goal is to show the development of a population, generation by generation. Each generation results from the preceding one, based on the simultaneous evaluation of all cells. This is the simple set of rules that govern what the next generation will look like:\n• If a live cell has fewer than 2 live neighbors, it dies of loneliness.\n• If a live cell has more than 3 live neighbors, it dies from overcrowding.\n• If a dead cell has exactly 3 live neighbors, it comes to life. That is all there is to it. Any cell that doesn’t meet any of those criteria is left as is for the next generation. With those simple rules in mind, go back and play with the system a little bit more and step through some generations, one at a time, and notice these rules taking their effect. The screenshot below shows an example generation, with a number of live cells. Don’t worry about matching the exact patterns represented in the screen shot. Just get some groups of cells added to the grid. Once you have groups of live cells in the grid, or select a pre-designed pattern, click the \"Next Generation\" button and notice what happens. Some of the live cells are killed (the green ball disappears) and some dead cells come to life (a green ball appears). Step through several generations and see if you notice any patterns. If you click on the \"Start\" button, the system will evolve itself so you don’t need to click the \"Next Generation\" button over and over. Play with the system a little and then come back here for more details of how the application works. Now lets delve into the code. As this is an advanced example we’ll assume that by now you know your way around the Drools framework and are able to connect the presented highlight, so that we’ll just focus at a high level overview. The example has two ways to execute, one way uses Agenda Groups to manage execution flow, and the other one uses Rule Flow Groups to manage execution flow. These two versions are implemented in and , respectively. Here, we’ll discuss the Rule Flow version, as it’s what most people will use. All the objects are inserted into the Session and the rules in the \"register neighbor\" are allowed to execute by the Rule Flow process. This group of four rules creates relations between some cell and its northeastern, northern, northwestern and western neighbors. This relation is bidirectional, which takes care of the other four directions. Border cells don’t need any special treatment - they simply won’t be paired with neighboring cells where there isn’t any. By the time all activations have fired for these rules, all cells are related to all their neighboring cells. rule \"register north east\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northEast : Cell( row == ($row - 1), col == ( $col + 1 ) ) then insert( new Neighbor( $cell, $northEast ) ); insert( new Neighbor( $northEast, $cell ) ); end rule \"register north\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $north : Cell( row == ($row - 1), col == $col ) then insert( new Neighbor( $cell, $north ) ); insert( new Neighbor( $north, $cell ) ); end rule \"register north west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northWest : Cell( row == ($row - 1), col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $northWest ) ); insert( new Neighbor( $northWest, $cell ) ); end rule \"register west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $west : Cell( row == $row, col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $west ) ); insert( new Neighbor( $west, $cell ) ); end Once all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to Live. Then, when the user clicks \"Start\" or \"Next Generation\", it executes the \"Generation\" ruleflow. This ruleflow is responsible for the management of all changes of cells in each generation cycle. The rule flow process first enters the \"evaluate\" group, which means that any active rule in the group can fire. The rules in this group apply the Game-of-Life rules discussed in the beginning of the example, determining the cells to be killed and the ones to be given life. We use the \"phase\" attribute to drive the reasoning of the Cell by specific groups of rules; typically the phase is tied to a Rule Flow Group in the Rule Flow process definition. Notice that it doesn’t actually change the state of any objectss at this point; this is because it’s evaluating the grid in turn and it must complete the full evaluation until those changes can be applied. To achieve this, it sets the cell to a \"phase\" which is either or , used later to control actions applied to the object. Example 327. Conway’s Game of Life: Evaluate Cells with state changes rule \"Kill The Lonely\" ruleflow-group \"evaluate\" no-loop when // A live cell has fewer than 2 live neighbors theCell: Cell( liveNeighbors < 2, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Kill The Overcrowded\" ruleflow-group \"evaluate\" no-loop when // A live cell has more than 3 live neighbors theCell: Cell( liveNeighbors > 3, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Give Birth\" ruleflow-group \"evaluate\" no-loop when // A dead cell has 3 live neighbors theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE ) then modify( theCell ){ theCell.setPhase( Phase.BIRTH ); } end Once all objects in the grid have been evaluated, we first clear any calculation activations that occurred from any previous data changes. This is done via the \"reset calculate\" rule, which clears any activations in the \"calculate\" group. We then enter a split in the rule flow which allows any activations in both the \"kill\" and the \"birth\" group to fire. These rules are responsible for applying the state change. Example 328. Conway’s Game of Life: Apply the state changes rule \"reset calculate\" ruleflow-group \"reset calculate\" when then WorkingMemory wm = drools.getWorkingMemory(); wm.clearRuleFlowGroup( \"calculate\" ); end rule \"kill\" ruleflow-group \"kill\" no-loop when theCell: Cell( phase == Phase.KILL ) then modify( theCell ){ setCellState( CellState.DEAD ), setPhase( Phase.DONE ); } end rule \"birth\" ruleflow-group \"birth\" no-loop when theCell: Cell( phase == Phase.BIRTH ) then modify( theCell ){ setCellState( CellState.LIVE ), setPhase( Phase.DONE ); } end At this stage, a number of objects have been modified with the state changed to either or . Now we get to see the power of the facts defining the cell relations. When a cell becomes live or dead, we use the relation to iterate over all surrounding cells, increasing or decreasing the count. Any cell that has its count changed is also set to to the phase, to make sure it is included in the reasoning during the evaluation stage of the Rule Flow Process. Notice that we don’t have to do any iteration ourselves; simply by applying the relations in the rules we make the rule engine do all the hard work for us, with a minimal amount of code. Once the live count has been determined and set for all cells, the Rule Flow Process comes to and end. If the user has initially clicked the \"Start\" button, the engine will restart the rule flow; otherwise the user may request another generation. Example 329. Conway’s Game of Life: Evaluate cells with state changes rule \"Calculate Live\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.LIVE ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ), setPhase( Phase.EVALUATE ); } end rule \"Calculate Dead\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.DEAD ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ), setPhase( Phase.EVALUATE ); } end A simplifed version of the Space Invaders game. Use the keys Z and K, to move left and right and M to fire a misile. The example is built up over 6 projects, each adding slightly more complexity to the last. Invaders1Main creates the frame and attaches the KeyListener, feeding key events into the engine. It also sets up the main game loop which can be found in \"Main.drl\". The typical convention used through out the example is to have one agenda group per file, and all rules in that file in the same agenda group. The Run fact is used to drive the repeat of the Game loop. Initially there are only one groups that is evaluated, Keys. The \"keys.drl\" file is shared by several examples, and illustrates rule re-use across multipel projects. rule \"init\" when then insert( new Run() ); setFocus( \"Init\" ); end rule GameLoop when r : Run() then setFocus( \"Keys\" ); end rule Draw when r : Run() then ui.show(); modify( r ) {} // force loop end Invaders2Main adds the \"Draw\" stage to the game loop and draws the SpaceShip Invaders3Main adds move controls to the spaceship, notice the ship moves out of the boundaries of the screen. KeyPressed is detected and that sets a delta of dx on the ship direction. That delta is then repeated applied to the x position of the ship rule ShipDeltaMoveLeft agenda-group \"Move\" when s : Ship() KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 - s.speed } end rule ShipDeltaStopLeft agenda-group \"Move\" when s : Ship() not KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 } end rule ShipMove agenda-group \"Move\" when s : Ship( dx != 0 ) Run() then modify( s ) { x = s.x + s.dx } end Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. Invaders6Main adds a lot more meat. Pressing the \"M\" key fires a missile that travels up the screen, while moving collision between the missile and the invader is checked. Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. rule InsertBullet agenda-group \"Bullet\" when KeyPressed( keyText == \"M\" ) s : Ship() not Bullet() then b = new Bullet(); b.x = s.x + (s.width/2) - (b.width/2); b.y = s.y - s.height - b.height; b.width = conf.bulletWidth; b.height = conf.bulletHeight; b.dy = 0 - conf.bulletSpeed; insert( b ); end rule BulletMove agenda-group \"Bullet\" when b : Bullet( y > 0 ) @watch( !y ) Run() then modify( b ) { y = b.y + b.dy } end rule Collision agenda-group \"Bullet\" when b : Bullet( ) @watch( y ) i : Invader( x < b.x, x + width > b.x, y > b.y) Run() then modify( i ) { alive = false } end Based on the Adventure in Prolog, over at the Amzi website, http://www.amzi.com/AdventureInProlog/, we started to work on a text adventure game for Drools. They are ideal as they can start off simple and build in complexity and size over time, they also demonstrate key aspects of declarative relational programming. The game allows you to play as the hero or the monster. If you click \"New Window\" you can open one window as the hero and another as the monster, and play them both at the same time. The game allows either character to move around rooms, pick up, drop or use things. Doors can be locked and unlocked, by using the key on teh exit room, and the hero can kill the monster by using the umbrella on the monster. You can view the 8 minute demonstration and introduction for the example at http://downloads.jboss.org/drools/videos/text-adventures.swf. Be aware the video is now much older than the current improved example. Each action follows the constructor arguments of the associated Command java class. To issue a move action, select the \"Move\" button, then select the exit room. Notice when you press \"Move\" it adds the text to the white bar at the bottom. When the exit room is selected, it also is added to the white bar. Then press send and the game engine will execute the command. Internally it uses reflection to instantiate the Command and insert it into the engine. If you select incorrect arguments, such as pressing exits multiple times, the reflection will fail and you can attempt it again. The Things list displays anything you can see in the room, not all things can be picked up. For instance you can pick up the key and the torch, but not the monster. When something is picked up it moves from the Things list to the Inventory List. The reverse is true when something is dropped. The key is in the office, move upstairs and into the office. Then pick up the key. Move back downstairs and into the kitchen. Try and walk into the basement, notice it’s locked. Select the \"Use\" action, the select the key and then the basement exit. This will unlock the door and you can now walk through. To kill the monster pick up the umbrella from the lounge and then select \"Use\", then select the imbrella and finally select the monster. Don’t forget to open a \"New Window\" to play as the monster, although you will not be able to exit the basement until the hero has opened it with the key. The monster and the hero can also give items to each other, moving items between each playsers inventory. The model is written in Java classes. Each classes uses @PropertyReactive and @Position. @PropertyReactive allows control of which fields patterns react to, and @Position maps a field to a argument position allowing positional as well as named arguments for patterns. @PropertyReactive public class Thing { @Position(0) private long id; @Position(1) private String name; public Thing(long id, String name) { this.id = id; this.name = name; } ... } An MVEL data file is used to populate our world, see \"data.mvel\". You can edit this file to add new rooms, items and characters, as well as locks for doors. rooms = [ \"basement\" : new Room(\"basement\"), \"lounge\" : new Room(\"lounge\"), \"kitchen\" : new Room(\"kitchen\"), \"ground floor hallway\" : new Room(\"ground floor hallway\"), \"bedroom\" : new Room(\"bedroom\"), \"office\" : new Room(\"office\"), \"first floor hallway\" : new Room(\"first floor hallway\") ]; doors = [ \"d1\" : new Door( rooms[\"kitchen\"], rooms[\"basement\"] ), \"d2\" : new Door( rooms[\"ground floor hallway\"], rooms[\"lounge\"]), \"d4\" : new Door( rooms[\"ground floor hallway\"], rooms[\"kitchen\"]), \"d5\" : new Door( rooms[\"ground floor hallway\"], rooms[ \"first floor hallway\"] ), \"d8\" : new Door( rooms[\"first floor hallway\"], rooms[ \"bedroom\"] ), \"d9\" : new Door( rooms[\"first floor hallway\"], rooms[ \"office\"] ) ]; locations = [ \"monster\" : new Location( characters[\"monster\"], rooms[\"basement\"] ), \"hero\" : new Location( characters[\"hero\"], rooms[\"ground floor hallway\"] ), \"umbrella\" : new Location( items[\"umbrella\"], rooms[\"lounge\"] ), \"key1\" : new Location( items[\"key1\"], rooms[\"office\"] ) ]; The game creates commands, which it inserts into the engine. These commands are then used to change the state of the world and that state is reflected back in the UI. The commands can be found in the \"commands.drl\" file. The following rule matches the MoveCommand and if it’s valid it will make the move happen. rule validMove agenda-group \"commands\" when mc : MoveCommand( c : character, r : room ) l : Location( thing == c, ltarget : target ) @watch( !target ) ?connect( d, r, ltarget; ) then exit = new ExitEvent( c, (Room) l.target ); enter = new EnterEvent( c, r ); modify( l ) { target = r }; insert( exit ); insert( enter ); mc.session.channels[\"output\"].send( \"You have entered the \" + l.target.name + \"\n\n\" ); end In the above rules notice the \"connect\" pattern, this is actually a query. In the MVEL data file doors are only described one way, we can use a query to check connections bi-directionally. The queries can be found in the \"queries.drl\" file. query connect( Door $d, Room $x, Room $y ) $d := Door($id, $name, $x, $y;) or $d :=Door($id, $name, $y, $x;) end The UI has its list boxes populated by rules found in \"UiView.drl\", those rules in turn use queries. Here is how the \"Things\" list box is populated, when ever the world changes. rule updateThings salience 5 when session : UserSession( $char : character ) things( $char, $things; ) then session.channels[\"things\"].send( $things ); end query things(Character $char, List $things) $char := Character() Location( $char, $room; ) $things := List() from accumulate( Location($thing, $room; thing != $char), collectList( $thing ) ) end A Conversion for the classic game Pong. Use the keys A, Z and K, M. The ball should get faster after each bounce. Wumpus World is an AI example covered in the book \"Artificial Intelligence : A Modern Approach\". When the game first starts all the cells are greyed out. As you walk around they become visible. The cave has pits, a wumpus and gold. When you are next to a pit you will feel a breeze, when you are next to the wumpus you will smell a stench and see glitter when next to gold. The sensor icons are shown above the move buttons. If you walk into a pit or the wumpus, you die. A more detailed overview of Wumpus World can be found at http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml. A 20 minute video showing how the game is created and works is at http://www.youtube.com/watch?v=4CvjKqUOEzM. Name: Miss Manners Main class: org.drools.benchmark.manners.MannersBenchmark Module: drools-examples Type: Java application Rules file: manners.drl Objective: Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth. Miss Manners is throwing a party and, being a good host, she wants to arrange good seating. Her initial design arranges everyone in male-female pairs, but then she worries about people have things to talk about. What is a good host to do? She decides to note the hobby of each guest so she can then arrange guests not only pairing them according to alternating sex but also ensuring that a guest has someone with a common hobby, at least on one side. Five benchmarks were established in the 1991 paper \"Effects of Database Size on Rule System Performance: Five Case Studies\" by David Brant, Timothy Grose, Bernie Lofaso and Daniel P. Miranker:\n• Manners uses a depth-first search approach to determine the seating arrangements alternating women and men and ensuring one common hobby for neighbors.\n• Waltz establishes a three-dimensional interpretation of a line drawing by line labeling by constraint propagation.\n• WaltzDB is a more general version of Waltz, supporting junctions of more than three lines and using a database.\n• ARP is a route planner for a robotic air vehicle using the A* search algorithm to achieve minimal cost.\n• Weaver VLSI router for channels and boxes using a black-board technique. Manners has become the de facto rule engine benchmark. Its behavior, however, is now well known and many engines optimize for this, thus negating its usefulness as a benchmark which is why Waltz is becoming more favorable. These five benchmarks are also published at the University of Texas http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/. After the first seating arrangement has been assigned, a depth-first recursion occurs which repeatedly assigns correct seating arrangements until the last seat is assigned. Manners uses a instance to control execution flow. The activity diagram is partitioned to show the relation of the rule execution to the current state. Before going deeper into the rules, let’s first take a look at the asserted data and the resulting seating arrangement. The data is a simple set of five guests who should be arranged so that sexes alternate and neighbors have a common hobby. The data is given in OPS5 syntax, with a parenthesized list of name and value pairs for each attribute. Each person has only one hobby. Each line of the results list is printed per execution of the \"Assign Seat\" rule. They key bit to notice is that each line has a \"pid\" value one greater than the last. (The significance of this will be explained in the discussion of the rule \"Assign Seating\".) The \"ls\", \"rs\", \"ln\" and \"rn\" refer to the left and right seat and neighbor’s name, respectively. The actual implementation uses longer attribute names (e.g., , but here we’ll stick to the notation from the original implementation. Manners has been designed to exercise cross product joins and Agenda activities. Many people not understanding this tweak the example to achieve better performance, making their port of the Manners benchmark pointless. Known cheats or porting errors for Miss Manners are:\n• Using arrays for a guests hobbies, instead of asserting each one as a single fact massively reduces the cross products.\n• Altering the sequence of data can also reduce the amount of matching, increasing execution speed.\n• It’s possible to change the Conditional Element so that the test algorithm only uses the \"first-best-match\", which is, basically, transforming the test algorithm to backward chaining. The results are only comparable to other backward chaining rule engines or ports of Manners.\n• Removing the context so the rule engine matches the guests and seats prematurely. A proper port will prevent facts from matching using the context start.\n• It’s possible to prevent the rule engine from performing combinatorial pattern matching.\n• If no facts are retracted in the reasoning cycle, as a result of the CE, the port is incorrect. The Manners benchmark was written for OPS5 which has two conflict resolution strategies, LEX and MEA. LEX is a chain of several strategies including salience, recency and complexity. The recency part of the strategy drives the depth first (LIFO) firing order. The CLIPS manual documents the Recency strategy as follows: Every fact and instance is marked internally with a \"time tag\" to indicate its relative recency with respect to every other fact and instance in the system. The pattern entities associated with each rule activation are sorted in descending order for determining placement. An activation with a more recent pattern entity is placed before activations with less recent pattern entities. To determine the placement order of two activations, compare the sorted time tags of the two activations one by one starting with the largest time tags. The comparison should continue until one activation’s time tag is greater than the other activation’s corresponding time tag. The activation with the greater time tag is placed before the other activation on the agenda. If one activation has more pattern entities than the other activation and the compared time tags are all identical, then the activation with more time tags is placed before the other activation on the agenda. However Jess and CLIPS both use the Depth strategy, which is simpler and lighter, which Drools also adopted. The CLIPS manual documents the Depth strategy as: Newly activated rules are placed above all rules of the same salience. For example, given that fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda. However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary. The initial Drools implementation for the Depth strategy would not work for Manners without the use of salience on the \"make_path\" rule. The CLIPS support team had this to say: The default conflict resolution strategy for CLIPS, Depth, is different than the default conflict resolution strategy used by OPS5. Therefore if you directly translate an OPS5 program to CLIPS, but use the default depth conflict resolution strategy, you’re only likely to get the correct behavior by coincidence. The LEX and MEA conflict resolution strategies are provided in CLIPS to allow you to quickly convert and correctly run an OPS5 program in CLIPS. Investigation into the CLIPS code reveals there is undocumented functionality in the Depth strategy. There is an accumulated time tag used in this strategy; it’s not an extensively fact by fact comparison as in the recency strategy, it simply adds the total of all the time tags for each activation and compares. Once the context is changed to , activations are created for all asserted guest. Because all activations are created as the result of a single Working Memory action, they all have the same Activation time tag. The last asserted object would have a higher fact time tag, and its Activation would fire because it has the highest accumulated fact time tag. The execution order in this rule has little importance, but has a big impact in the rule \"Assign Seat\". The activation fires and asserts the first arrangement and a , and then sets the attribute to create an activation for rule . rule assignFirstSeat when context : Context( state == Context.START_UP ) guest : Guest() count : Count() then String guestName = guest.getName(); Seating seating = new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName); insert( seating ); Path path = new Path( count.getValue(), 1, guestName ); insert( path ); modify( count ) { setValue ( count.getValue() + 1 ) } System.out.println( \"assign first seat : \" + seating + \" : \" + path ); modify( context ) { setState( Context.ASSIGN_SEATS ) } end This rule determines each of the arrangements. The rule creates cross product solutions for all asserted arrangements against all the asserted guests except against itself or any already assigned chosen solutions. rule findSeating when context : Context( state == Context.ASSIGN_SEATS ) $s : Seating( pathDone == true ) $g1 : Guest( name == $s.rightGuestName ) $g2 : Guest( sex != $g1.sex, hobby == $g1.hobby ) count : Count() not ( Path( id == $s.id, guestName == $g2.name) ) not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) ) then int rightSeat = $s.getRightSeat(); int seatId = $s.getId(); int countValue = count.getValue(); Seating seating = new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ); insert( seating ); Path path = new Path( countValue, rightSeat + 1, $g2.getName() ); insert( path ); Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() ); insert( chosen ); System.err.println( \"find seating : \" + seating + \" : \" + path + \" : \" + chosen); modify( count ) {setValue( countValue + 1 )} modify( context ) {setState( Context.MAKE_PATH )} end However, as can be seen from the printed results shown earlier, it is essential that only the with the highest cross product be chosen. How can this be possible if we have activations, of the same time tag, for nearly all existing and objects? For example, on the third iteration of the produced activations will be as shown below. Remember, this is from a very small data set, and with larger data sets there would be many more possible activated solutions, with multiple solutions per : The creation of all these redundant activations might seem pointless, but it must be remembered that Manners is not about good rule design; it’s purposefully designed as a bad ruleset to fully stress-test the cross product matching process and the Agenda, which this clearly does. Notice that each activation has the same time tag of 35, as they were all activated by the change in the object to . With OPS5 and LEX it would correctly fire the activation with the asserted last. With Depth, the accumulated fact time tag ensures that the activation with the last asserted fires. Rule must always fire before . A object is asserted for each arrangement, up to the last asserted . Notice that the conditions in are a subset of those in - so how do we ensure that fires first? rule makePath when Context( state == Context.MAKE_PATH ) Seating( seatingId:id, seatingPid:pid, pathDone == false ) Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat ) not Path( id == seatingId, guestName == pathGuestName ) then insert( new Path( seatingId, pathSeat, pathGuestName ) ); end Both rules end up on the Agenda in conflict and with identical activation time tags. However, the accumulate fact time tag is greater for \"Make Path\" so it gets priority. Rule only activates when the last seat is assigned, at which point both rules will be activated. For the same reason that always wins over , will take priority over rule . Assign First seat =>[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] =>[fid:14:14]:[Path id=1, seat=1, guest=n5] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1 , pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]* Assign Seating =>[fid:15:17] :[Seating id=2 , pid=1 , done=false, ls=1, lg=n5, rs=2, rn=n4] =>[fid:16:18]:[Path id=2, seat=2, guest=n4] =>[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1] =>[ActivationCreated(21): rule=makePath [fid:15:17] : [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] [fid:14:14] : [Path id=1, seat=1, guest=n5]* ==>[ActivationCreated(21): rule=pathDone [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]* Make Path =>[fid:18:22:[Path id=2, seat=1, guest=n5]] Path Done Continue Process =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:7:7]:[Guest name=n4, sex=f, hobbies=h3] [fid:4:4] : [Guest name=n3, sex=m, hobbies=h3]* =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3] =>[ActivationCreated(25): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]] =>[fid:20:27]:[Path id=3, seat=3, guest=n3]] =>[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}] =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:18:22]:[Path id=2, seat=1, guest=n5]* =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:16:18]:[Path id=2, seat=2, guest=n4]* =>[ActivationCreated(30): rule=done [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]* Make Path =>[fid:22:31]:[Path id=3, seat=1, guest=n5] Make Path =>[fid:23:32] [Path id=3, seat=2, guest=n4] Path Done Continue Processing =>[ActivationCreated(35): rule=findSeating [fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] [fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest name=n2, sex=f, hobbies=h3], [fid:12:29]* =>[ActivationCreated(35): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(35): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]] =>[fid:25:37]:[Path id=4, seat=4, guest=n2]] =>[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3] ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:23:32]:[Path id=3, seat=2, guest=n4]* ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:20:27]:[Path id=3, seat=3, guest=n3]* =>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:22:31]:[Path id=3, seat=1, guest=n5]* =>[ActivationCreated(40): rule=done [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]* Make Path =>fid:27:41:[Path id=4, seat=2, guest=n4] Make Path =>fid:28:42]:[Path id=4, seat=1, guest=n5]] Make Path =>fid:29:43]:[Path id=4, seat=3, guest=n3]] Path Done Continue Processing =>[ActivationCreated(46): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1], [fid:2:2] [Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(46): rule=findSeating [fid:24:44]:[Seating id=4, pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]* =>[ActivationCreated(46): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:30:47]:[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1] =>[fid:31:48]:[Path id=5, seat=5, guest=n1] =>[fid:32:49]:[Chosen id=4, name=n1, hobbies=h1] A backward-chaining rule system is goal-driven. This means the system starts with a conclusion which the engine tries to satisfy. If it cannot do so it searches for sub-goals, that is, conclusions that will complete part of the current goal. It continues this process until either the initial conclusion is satisfied or there are no more unsatisfied sub-goals. Prolog is an example of a backward-chaining engine. Backward-Chaining is a feature recently added to the JBoss Rules Engine. This process is often referred to as derivation queries, and it is not as common compared to reactive systems since JBoss Rules is primarily reactive forward chaining. That is, it responds to changes in your data. The backward-chaining added to the engine is for product-like derivations. The previous chart demonstrates a House example of transitive items. A similar reasoning chart can be created by implementing the following rules: 1. First, create some java rules to develop reasoning for transitive items. It inserts each of the locations. 2. Next, create the Location class; it has the item and where it is located. 3. Type the rules for the House example as depicted below: ksession.insert( new Location(\"office\", \"house\") ); ksession.insert( new Location(\"kitchen\", \"house\") ); ksession.insert( new Location(\"knife\", \"kitchen\") ); ksession.insert( new Location(\"cheese\", \"kitchen\") ); ksession.insert( new Location(\"desk\", \"office\") ); ksession.insert( new Location(\"chair\", \"office\") ); ksession.insert( new Location(\"computer\", \"desk\") ); ksession.insert( new Location(\"drawer\", \"desk\") ); 4. A transitive design is created in which the item is in its designated location such as a \"desk\" located in an \"office.\" 1. Create a query to look at the data inserted into the rules engine: Notice how the query is recursive and is calling \"isContainedIn.\" 2. Create a rule to print out every string inserted into the system to see how things are implemented. The rule should resemble the following format: rule \"go\" salience 10 when $s : String( ) then System.out.println( $s ); end 3. Using Step 2 as a model, create a rule that calls upon the Step 1 query \"isContainedIn.\" rule \"go1\" when String( this == \"go1\" ) isContainedIn(\"office\", \"house\"; ) then System.out.println( \"office is in the house\" ); end The \"go1\" rule will fire when the first string is inserted into the engine. That is, it asks if the item \"office\" is in the location \"house.\" Therefore, the Step 1 query is evoked by the previous rule when the \"go1\" String is inserted. 4. Create the \"go1,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go1\" ); ksession.fireAllRules(); --- go1 office is in the house The --- line indicates the separation of the output of the engine from the firing of the \"go\" rule and the \"go1\" rule. 1. Create a Transitive Closure by implementing the following rule: rule \"go2\" when String( this == \"go2\" ) isContainedIn(\"drawer\", \"house\"; ) then System.out.println( \"Drawer in the House\" ); end 2. Recall from the Cloning Transitive Closure’s topic, there was no instance of \"drawer\" in \"house.\" \"drawer\" was located in \"desk.\" 3. Use the previous query for this recursive information. 4. Create the \"go2,\" insert it into the engine, and call the fireAllRules. When the rule is fired, it correctly tells you \"go2\" has been inserted and that the \"drawer\" is in the \"house.\" 5. Check how the engine determined this outcome\n• The query has to recurse down several levels to determine this.\n• Instead of using Location( x, y; ), The query uses the value of (z, y; ) since \"drawer\" is not in \"house.\"\n• The z is currently unbound which means it has no value and will return everything that is in the argument.\n• y is currently bound to \"house,\" so z will return \"office\" and \"kitchen.\"\n• Information is gathered from \"office\" and checks recursively if the \"drawer\" is in the \"office.\" The following query line is being called for these parameters: isContainedIn (x ,z; ) There is no instance of \"drawer\" in \"office;\" therefore, it does not match. With z being unbound, it will return data that is within the \"office,\" and it will gather that z == desk. isContainedIn recurses three times. On the final recurse, an instance triggers of \"drawer\" in the \"desk.\" This matches on the first location and recurses back up, so we know that \"drawer\" is in the \"desk,\" the \"desk\" is in the \"office,\" and the \"office\" is in the \"house;\" therefore, the \"drawer\" is in the \"house\" and returns true. 1. Create a Reactive Transitive Query by implementing the following rule: rule \"go3\" when String( this == \"go3\" ) isContainedIn(\"key\", \"office\"; ) then System.out.println( \"Key in the Office\" ); end Reactive Transitive Queries can ask a question even if the answer can not be satisfied. Later, if it is satisfied, it will return an answer. 2. Use the same query for this reactive information. 3. Create the \"go3,\" insert it into the engine, and call the fireAllRules. The first rule that matches any String returns \"go3\" but nothing else is returned because there is no answer; however, while \"go3\" is inserted in the system, it will continuously wait until it is satisfied. 4. Insert a new location of \"key\" in the \"drawer\": ksession.insert( new Location(\"key\", \"drawer\") ); ksession.fireAllRules(); --- Key in the Office This new location satisfies the transitive closure because it is monitoring the entire graph. In addition, this process now has four recursive levels in which it goes through to match and fire the rule. 1. Create a Query with Unbound Arguments by implementing the following rule: rule \"go4\" when String( this == \"go4\" ) isContainedIn(thing, \"office\"; ) then System.out.println( \"thing\" + thing + \"is in the Office\" ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. 2. Use the query for the unbound arguments. 3. Create the \"go4,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go4\" ); ksession.fireAllRules(); --- go4 thing Key is in the Office thing Computer is in the Office thing Drawer is in the Office thing Desk is in the Office thing Chair is in the Office When \"go4\" is inserted, it returns all the previous information that is transitively below \"Office.\" 1. Create a query with Mulitple Unbound Arguments by implementing the following rule: rule \"go5\" when String( this == \"go5\" ) isContainedIn(thing, location; ) then System.out.println( \"thing\" + thing + \"is in\" + location ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. Both thing and location are unbound out variables, and without bound arguments, everything is called upon. 2. Use the query for multiple unbound arguments. 3. Create the \"go5,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go5\" ); ksession.fireAllRules(); --- go5 thing Knife is in House thing Cheese is in House thing Key is in House thing Computer is in House thing Drawer is in House thing Desk is in House thing Chair is in House thing Key is in Office thing Computer is in Office thing Drawer is in Office thing Key is in Desk thing Office is in House thing Computer is in Desk thing Knife is in Kitchen thing Cheese is in Kitchen thing Kitchen is in House thing Key is in Drawer thing Drawer is in Desk thing Desk is in Office thing Chair is in Office When \"go5\" is called, it returns everything within everything."
    },
    {
        "link": "https://docs.drools.org/7.0.0.Beta7/drools-docs/html_single",
        "document": "2.1. Breaking changes in Drools 7.0 from 6.x Property reactivity has been introduced in Drools 5.4 but users had to explicitly enable it on a class by class basis through the annotation or on the whole knowledge base using the builder option. However, since using this feature is considered a good practice both under correctness and performance points of view, it has been enabled by default in Drools 7.0. If required it is possible to disable property reactivity and reconfigure Drools 7.0 to work exactly as it did in version 6.x by adding the following configuration to the kmodule.xml file. In Drools 6 when using the function inside an accumulate pattern the result was always a Double regardless of the field type on which the sum was performed. This caused the following 3 problems:\n• Loss of precision: the sum of a long will incorrectly return . The BigDecimal sum of and will also be incorrect.\n• Loss of performance: summing with a Double total is significantly slower than summing with a Long or an Integer.\n• Leaked complexity: it enforced the user to pattern matching on Double, or more generically (suggested choice) on Number, while it may be expected that the result of summing on a field of type Integer would be an Integer as well. Conversely Drools 7 preserves the type of the expression on which the sum is executed, so it will be possible to directly match on that type as in: The KieSession option to control when timed rules have to be automatically executed has been renamed into fixing a typing mistake in its name which affected previous releases; the property has been aligned into . 2.2. What is New and Noteworthy in Drools 7.0 Historically Rete has always been a sequential algorithm and even if Phreak, its evolution introduced in Drools 6, allowed some degree of parallelization, this possibility wasn’t concretely leveraged yet. In Drools 7 is finally possible to make the engine to evaluate more rules in parallel. This is achieved by partitioning the Rete/Phreak in independent partitions and evaluating them in parallel. This feature is off by default, but it’s possible to create a parallel KieBase by enabling it via the as it follows: or alternatively through the system property: Rules using salience or agenda-group are currently not supported by the parallel engine. In case they are present inside the rule base and compiler emits a warning and automatically switches back using the single threaded implementation. OOPath has been introduced with Drools 6.3.0. In Drools 7.0.0 the support for standard Java Collection has been enhanced, with a dedicated implementation for and , as specialized and ; a is also available. This also includes out of the box reactive support when performing mutable operations through their and . public class School extends AbstractReactiveObject { private String name; private final List<Child> children = new ReactiveList<Child>(); (1) public void setName(String name) { this.name = name; notifyModification(); (2) } public void addChild(Child child) { children.add(child); (3) // no need to call notifyModification() here. } Using specialized for reactive support over standard Java . Usually is required to be called when a field is changed for reactive support but in the case of this is handled automatically, like every other mutating operations performed over the field . As a best-practice, it is recommended to declare reactive collection fields as per the example shown. The Kie Maven plug-in offers a new goal to instrument bytecode and automatically inject reactivity support for standard cases. The goal is disabled by default, and can be enabled via Maven plug-in configuration settings. The goal will instrument bytecode pertaining to the Maven project build’s output directory . It is possible to limit the scope of the goal to a specific package or hierarchy of packages via Maven plug-in configuration settings list. .Example: Limit scope of instrumentation specifically to package only. Limit scope of instrumentation to and its children packages. The plug-in will instrument bytecode for every field assignment under the following standard cases:\n• wrap any field defined as List with a\n• wrap any field defined as Set with a\n• wrap any field defined as Collection with a In order for a field of type List/Set to be wrapped correctly, the field member of the java class must be declared specifically using either , or (declaring for instance a field as will not be instrumented with the specialized reactive collections). It is not recommended to mix manual support for reactivity (implemented manually) and the bytecode instrumentation Maven plug-in; it is better envisaged to keep the two scopes distinct, for instance by making use of the plug-in configuration to instrument only specific packages as documented above. The following section present detailed examples of the plug-in instrumentation. A field assignment like in the following example: will be instrumented by intercepting the field assignment and triggering the : Please notice this instrumentation applies only if the field is not a . In the case the field assignment is referring a or a , the instrumentation will wrap the assignment with a or accordingly; for example: public class School { private final String name; private final List<Child> children = new ArrayList<Child>(); ... public School(String name) { this.name = name; } public List<Child> getChildren() { return children; } } will be instrumented by intercepting and wrapping with : public class School implements ReactiveObject { private final String name; private final List<Child> children; public School(final String name) { this.$$_drools_write_children(new ArrayList()); this.name = name; } public List<Child> getChildren() { return this.children; } public void $$_drools_write_children(final List list) { this.children = (List<Child>) new ReactiveList(list); } Rule units represent a purely declarative approach to partition a rules set into smaller units, binding different data sources to those units and orchestrate the execution of the individual unit. A rule unit is an aggregate of data sources, global variables and rules. It is possible to define a rule unit by just implementing the marker interface as in the following example: package org.mypackage.myunit; public static class AdultUnit implements RuleUnit { private int adultAge; private DataSource<Person> persons; public AdultUnit( ) { } public AdultUnit( DataSource<Person> persons, int age ) { this.persons = persons; this.age = age; } // A DataSource of Persons for this RuleUnit public DataSource<Person> getPersons() { return persons; } // A global variable valid in this RuleUnit public int getAdultAge() { return adultAge; } // --- life cycle methods @Override public void onStart() { System.out.println(getName() + \" started.\"); } @Override public void onEnd() { System.out.println(getName() + \" ended.\"); } } Here is a source of facts of type Person representing the part of working memory related to that specific entry-point used when the rule unit is evaluated, while is a global variable accessible from all the rules belonging to this rule unit. The last 2 methods are part of the rule unit’s life cycle and are invoked by the engine. More in general the lifecycle of a RuleUnit can be monitored overriding the following methods: the evaluation of this unit terminates the execution of unit is suspended (only for runUntilHalt) the execution of unit is resumed (only for runUntilHalt) the consequence of rule in a given rule unit triggers the execution of a different unit All these methods have an empty default implemention inside the interface, so their implementation is optional. At this point it is possible to add one or more rules to this rule unit. By default all the rules in a drl file are automatically associated to a rule unit following a naming convetion on the name of drl file itself: if the drl file is in the same package and has the same name of a class implementing the interface all the rules in that drl file will implicitly belong to that unit. So for example all the rules in the drl file named AdultUnit.drl in package org.mypackage.myunit will be automatically part of the rule unit . It is also allowed to avoid using this naming convention and explictly declare to which unit the rules in a drl file belongs by using the new keyword. The unit declaration must always immediately follow the package declaration and contains the name of the class (in that package) to which the rules of the drl file are part like in: package org.mypackage.myunit unit AdultUnit rule Adult when $p : Person(age >= adultAge) from persons then System.out.println($p.getName() + \" is adult and greater than \" + adultAge); end It is not allowed to mix rules with and without a rule unit in the same KieBase. It is also possible to rewrite the same pattern in a more convenient way using the oopath notation introduced in drools 6 as it follows: A rule belonging to a rule unit using the oopath notation package org.mypackage.myunit unit AdultUnit rule Adult when $p : /persons{age >= adultAge} then System.out.println($p.getName() + \" is adult and greater than \" + adultAge); end Here the persons matched by the left hand side of the rule comes from the contained in the RuleUnit class with the same name, while the variable is used in both the left and right hand side in the same way as it was a global defined at drl level. In other words the DataSource acts as a specific entry-point feeding the working memory. The easiest way to create a is using a fixed set of data as in: DataSource<Person> persons = DataSource.create( new Person( \"Mario\", 42 ), new Person( \"Marilena\", 44 ), new Person( \"Sofia\", 4 ) ); To execute one or more rule units defined in a given it is necessary to create a new and bind it to the itself: At this point it is possible to create the by passing to it the persons and run it on the that in this case will produce the following output: org.mypackage.myunit.AdultUnit started. Marilena is adult and greater than 18 Mario is adult and greater than 18 org.mypackage.myunit.AdultUnit ended. Other than explicitly creating the rule unit instance it is often more convenient to just pass to the executor the class of the rule unit that you want to run and let the executor to create an instance of it and to set on it the s and other variable before running it. In order to do so it is necessary to previously register those variables on the executor itself, so that the following code will produce exactly the same result than the former one. The name passed to the method is used at runtime to bind said variable to the field of the RuleUnit class having the same name. For instance in the former example the injects into the new rule unit the data source formerly bound to the \"persons\" name and the value 18 bound to the String \"adultAge\" to the fields with the corresponding names inside the class. It is possible to override this default and explictly define a logical binding name for each field of the rule unit class using the annotation. For example, the field binding in the following class can be redefined with alternative names: and then binding the variables to the executor using those alternative names and run the unit A rule unit can be executed in passive mode as shown above (corresponding to invoking on a whole session) or in active mode using the that is equivalent to the session’s . As for the fireUntilHalt, the runUntilHalt is blocking and therefore has to be issued on a separated thread like in: A is a source of the data processed by a given rule unit. A rule unit can have zero or more data sources and to each DataSource declared inside a rule unit corresponds a different entry-point into the rule unit executor. A DataSource can be shared by different units, but in this case there will be many different entry-points, one for each unit, through which the same objects will be inserted. In other terms the represents the entry-point of the rule unit, so it is possible to insert a new fact into it: modify that fact, optionally specifying the set of properties that have been modified in order to leverage property reactivity As anticipated, multiple rule units can be defined in the same knowledge base and these units can work in a coordinate way by invoking or guarding the execution of each other. To demonstrate this let’s suppose having the following 2 drl files each of them containing a rule belonging to a distinct rule unit. package org.mypackage.myunit unit AdultUnit rule Adult when Person(age >= 18, $name : name) from persons then System.out.println($name + \" is adult\"); end package org.mypackage.myunit unit NotAdultUnit rule NotAdult when $p : Person(age < 18, $name : name) from persons then System.out.println($name + \" is NOT adult\"); modify($p) { setAge(18); } drools.run( AdultUnit.class ); end Also suppose to have a created from the built out of these rules and a of Persons bound to it. RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase ); DataSource<Person> persons = executor.newDataSource( \"persons\", new Person( \"Mario\", 42 ), new Person( \"Marilena\", 44 ), new Person( \"Sofia\", 4 ) ); Note that in this case we are creating the directly out of the and binding it to the \"persons\" variable in a single statement. At this point trying to execute the NotAdultUnit unit we obtain the following output: Sofia is NOT adult Mario is adult Marilena is adult Sofia is adult In fact the NotAdult rule finds a match when evaluating the person \"Sofia\" who has an age lower than 18. Then it modifies her age to 18 and with the statement triggers the execution of the other unit which has a rule that now can fire for all the 3 persons in the . This means that the statement inside a consequence is the way to imperatively interrupt the execution of a rule unit and cede the control to a different rule unit. Conversely the statement allows to declaratively schedule the execution of another rule unit when the condition in the LHS of the rule containing that statement is met. More precisely, using this mechanism a rule in a given rule unit acts as a guard for a different unit. This means that, when the rule engine produces at least one match for the LHS of the guarding rule, the guarded RuleUnit is considered active. Of course a RuleUnit can have more than one guarding rule. Let’s see how this works with another practical example. Suppose of having a simple class and a with a data source of box offices. We introduce now the requirement to keep selling tickets for the event as long as there is at least one opened box office. To achieve this let’s define a second unit with a of person and a second one of tickets. Then we can define a first rule in the BoxOfficeUnit that guards for this second unit. In this way we achieved what we have anticipated: by running the BoxOfficeUnit at some point it will also evaluates the rules in the TicketIssuerUnit defined as package org.mypackage.myunit; unit TicketIssuerUnit; rule IssueAdultTicket when $p: /persons{ age >= 18 } then tickets.insert(new AdultTicket($p)); end rule RegisterAdultTicket when $t: /tickets then results.add( $t.getPerson().getName() ); end that is guarded by the BoxOfficeIsOpen rule, until there will exist at least a set of facts satisfying the LHS patterns of that rule. In other terms the existence of at least one open box office will keep the guarding rule and in turn its guarded unit active as it is evident in the following use case. DataSource<Person> persons = executor.newDataSource( \"persons\" ); DataSource<BoxOffice> boxOffices = executor.newDataSource( \"boxOffices\" ); DataSource<AdultTicket> tickets = executor.newDataSource( \"tickets\" ); List<String> list = new ArrayList<>(); executor.bindVariable( \"results\", list ); // two open box offices BoxOffice office1 = new BoxOffice(true); FactHandle officeFH1 = boxOffices.insert( office1 ); BoxOffice office2 = new BoxOffice(true); FactHandle officeFH2 = boxOffices.insert( office2 ); persons.insert(new Person(\"Mario\", 40)); // fire BoxOfficeIsOpen -> run TicketIssuerUnit -> fire RegisterAdultTicket executor.run(BoxOfficeUnit.class); assertEquals( 1, list.size() ); assertEquals( \"Mario\", list.get(0) ); list.clear(); persons.insert(new Person(\"Matteo\", 30)); executor.run(BoxOfficeUnit.class); // fire RegisterAdultTicket assertEquals( 1, list.size() ); assertEquals( \"Matteo\", list.get(0) ); list.clear(); // close one box office, the other is still open office1.setOpen(false); boxOffices.update(officeFH1, office1); persons.insert(new Person(\"Mark\", 35)); executor.run(BoxOfficeUnit.class); assertEquals( 1, list.size() ); assertEquals( \"Mark\", list.get(0) ); list.clear(); // all box offices, are now closed office2.setOpen(false); boxOffices.update(officeFH2, office2); // guarding rule no longer true persons.insert(new Person(\"Edson\", 35)); executor.run(BoxOfficeUnit.class); // no fire assertEquals( 0, list.size() ); Since a rule can guard multiple rule units and at the same time a unit can be guarded and then activated by multiple rules, it is necessary to clearly define what is the identity of a given unit. By the default the identity of a unit is simply the rule unit class. This is encoded in the default method of the interface and implies that each unit is threated as a singleton by the . To demonstrate this let’s suppose of having a simple class with only a accepting any kind of object together with a rule belonging to this unit that guards another unit using 2 different conditions. package org.mypackage.myunit unit Unit0 rule GuardAgeCheck when $i: /input{ #Integer } $s: /input{ #String } then drools.guard( new AgeCheckUnit($i) ); drools.guard( new AgeCheckUnit($s.length()) ); end This second is intended to check the age of a set of persons. Then it has a of the persons to check, a minAge variable against which doing this check and a list were accumulating the results while the corresponding rule actually performing the check of the persons in the is the following: At this point we can create a , bind it to the knowledge base containing these 2 units and also create the 2 s to feed the same units. RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase ); DataSource<Object> input = executor.newDataSource( \"input\" ); DataSource<Person> persons = executor.newDataSource( \"persons\", new Person( \"Mario\", 42 ), new Person( \"Sofia\", 4 ) ); List<String> results = new ArrayList<>(); executor.bindVariable( \"results\", results ); We are now ready to insert some objects into the input data source and execute the Unit0. As outcome of this execution the results list will contain the following: As anticipated the rule unit named AgeCheckUnit is seen as a singleton and then executed only once, this time with equals to 3 (but this is not deterministic). Both the String \"test\" and the Integer 4 inserted into the input data source could also trigger a second execution with set to 4, but this is not happening because another unit with the same identity has been already evaluated. To fix this problem it is enough to override the method in the class to also include the variable minAge in its identity. Having done so, the units with minAge 3 and 4 are considered two different units and then both evaluated, so trying to rerun the former example the result list will now contain 2.3. New and Noteworthy in KIE Workbench 7.0.0 With each Hit Policy, by default a row has priority over each row below it.\n• Unique Hit\n\n With unique hit policy each row has to be unique meaning there can be no overlap. There can never be a situation where two rows can fire, if there is the Verification feature warns about this on development time.\n• First Hit\n\n First hit fires only one row, the one that is satisfied first from top to bottom.\n• Resolved Hit\n\n Similar to First Hit, but you can for example give row 10 priority over row 5. This means you can keep the order of the rows you want for visual readability, but specify priority exceptions.\n• Rule Order\n\n Multiple rows can fire and Verification does not report about conflicts between the rows since they are expected to happen.\n• None\n\n This is the normal hit mode. Old decision tables will use this by default, but since 7.0 uses PHREAK the row order now matters. There is no migration tooling needed for the old tables. Multiple rows can fire. Verification warns about rows that conflict. Prior to 7.x the Workbench used to install pre-defined examples at startup. Version 7.x brings the ability to import examples from git repositories.\n\n The Authoring Perspective contains a menu item for 'Examples' clicking this launches a Wizard to guide you through the import. The Authoring Perspective contains a menu item for 'Examples'. Page 1 of the Wizard allows the User to select a pre-defined examples repository, or enter their own URL. Page 2 of the Wizard lists Projects available in the source repository. Page 3 of the Wizard allows the User to enter a target Repository name and associate it with an Organizational Unit. All system pop-ups had their UX improved. The \"comment\" field is hidden by default. Now, the destination package can be selected when a project file is copied from any package. Composite field constraints now support use of formulae. When adding constraints to a Pattern the \"Multiple Field Constraint\" selection (\"All of (and)\" and \"Any of (or)\") supports use of formulae in addition to expressions. The Guided Decision Table Editor has been extensively rewritten to support editing of multiple tables in the same editor. Tables that share an association are visibly linked making it easier to visualise relationships. Associations are infered from Actions that create or update a Fact consumed by the Conditions of another table.\n• Reordering of columns by dragging and dropping \"in table\"\n• Reordering of rows by dragging and dropping \"in table\"\n• Repositioning of tables with drag and drop\n• Zoomable view, so you can zoom \"out\" to see more content at once The Guided Decision Table Editor has long been capable of using enumeration definitions. However since a table can contain many cells performance of enumerations could sometimes be less than ideal if the definition required a server round-trip to retrieve the lookups from a helper class. Results from server round-trips are now cached in the client hence removing the need for successive network calls when cells are modified. The cache is initialised when the editor is opened and populated on demand. It is possible to disable the Verification & Validation with the system property org.kie.verification.disable-dtable-realtime-verification. This can be useful for large decision tables or if the users want to ignore V&V. The verification takes the first steps towards helping you to make complete decision tables. In the next release we add the support for checking if all the ranges are covered for boolean, numeric and date values. This means if your table has a check for if an Application is approved the verification report will remind you to make sure you also handle situations where the Application was not approved. In the past verification and validation has raised an issue if rows subsume each other. If a row subsumes another, then the conditions can be satisfied with the same set of facts. Meaning two rows from the same table can fire at the same time. In some cases subsumption does not matter, but in other cases you want to have a table where only one rule fires at the time. The table is then a single hit decision table. To help the making of single hit tables where only one row can fire, the verification keeps an eye on the conditions. Reporting situations when single hit is broken. The \"Reimport\" button invalidates all cached dependencies, in order to handle scenarios where a specific dependency was updated without having its version modified. The User and Group management perspectives released in version 6.4 have been unified into a single perspective which delivers a shared view for managing both users and groups as well as the permissions granted to any of the application roles. This very new perspective is placed under the Home section in the top menu bar. The next screenshot shows how this new perspective looks: A tabbed pane is shown on the left, allowing the User to select the Roles, Groups or Users tab. After clicking on a Role (or Group)\n\n a detailed screen is displayed allowing the user to configure some security settings.\n• Home Perspective: The target perspective where the user is directed after login, which makes it possible to have different home pages per role/group.\n• Priority: Used to determine what settings (home perspective, permissions, …​) have precedence for those users with more than one role or group assigned.\n• Permissions: A full ACL (Access Control List) editor for grant/deny permissions over the different resources available in the platform like Perspectives,\n\n Organizational Units, Repositories or Projects. Global permissions on top of any of those resource types can be ovewritten by means of adding individual exceptions\n\n which makes it possible to implement both the grant all deny a few or the deny all grant a few strategies. The command-line tool for managing remote repositories that was present in 6.x has been removed for the following reasons:\n• The security-related operations it provided ( , , , , , ) have been replaced by more comprehensive Security management feature.\n• The operations related to managing deployments ( , , ) no longer make sense, since jBPM Runtime has been removed from workbench. Deployments can still be managed programmatically using Kie Server REST API.\n• The remaining operations ( , , , , , , , , ) are available as a part of workbench remote API The workbench now has a new menu item: \"Admin\". In there, you can find some admin tools, like \"Users\", \"Groups\" and \"Roles\" management, and also general preferences. When a preference is changed there, it will affect all places that depend on it, but only for the logged user. Figure 9. User admin page, that contains user level tools and preferences Each project also has its own admin page, with admin tools and preferences. When a preference is changed there, it will affect only that project, and only for the logged user. Figure 11. Project admin page, that contains project level tools and preferences It is now possible, for each user, to set the GAV conflict check flag, and also allow or block child GAV edition for all their projects, or specifically for each project. The configuration can be found inside the admin tool \"Project\", in case the access is made through the \"Admin\" menu item. It can also be found by entering the admin tool \"General\", on the Project admin page. The new data source management system empowers the workbench with the ability of defining data sources and drivers for accessing external databases. Some of the included functionalities are:\n• A new perspective for managing the data sources:\n• A new wizard for guiding the data source creation.\n• A new wizard for guiding the drivers creation. And the ability of browsing the database information for the databases pointed to by the data sources. 2.4. What is New and Noteworthy in Drools 6.5.0 Some runtime environments (like for example Google App Engine) don’t allow to directly create new Threads.\n\n For this reason it is now possible to plug your own ThreadFactory implementation by setting the system property drools.threadFactory with its class name.\n\n For instance if you implemented your Google App Engine compatible ThreadFactory with the class you can make Drools to use it by setting: 2.4.2. Use of any expressions as input for a query It is now possible to use as input argument for a query both the field of a fact as in: query contains(String $s, String $c) $s := String( this.contains( $c ) ) end rule PersonNamesWithA when $p : Person() contains( $p.name, \"a\"; ) then end and more in general any kind of valid expression like in: Property reactivity has been introduced to avoid unwanted and useless (re)evaluations and allow the engine to react only to\n\n modification of properties actually constrained or bound inside of a given pattern. However this feature is automatically available\n\n only for modifications performed inside the consequence of a rule. Conversely a programmatic update is unaware of the object’s\n\n properties that have been changed, so it is unable of using this feature. To overcome this limitation it is now possible to optionally specify in an update statement the names of the properties that\n\n have been changed in the modified object as in the following example: Person me = new Person(\"me\", 40); FactHandle meHandle = ksession.insert( me ); me.setAge(41); me.setAddress(\"California Avenue\"); ksession.update( meHandle, me, \"age\", \"address\" ); A new type of MBean has been introduced in order to provide monitoring of the KieContainers, and the JMX MBeans hierarchical structure have been revisited to reflect the relationship with the related MBeans of the KieBases.\n\n The JMX objectnaming has been normalized to reflect the terminology used in the Kie API.\n\n A new type of MBean has been introduced in order to provide monitoring for Stateless KieSession, which was not available in previous releases. The KieSession MBeans consolidate the statistics data for all sessions instantiated under the same name. KieSession created via , will be monitored under a KieSession MBean having constant valorized to ; this MBean is not managed by the KieContainer directly, hence it requires to be manually deregistered from JMX, when monitoring is no longer needed. The new JMX objectnaming scheme now enforces proper JMX quoting for IDs, e.g.: The old DroolsManagementAgent (which was registered on JMX under ) is no longer necessary, hence no longer registered on JMX. The KieSession MBeans now have proper JMX and support, where applicable. The KieSession MBeans continue to support all process-related aggregated statistics monitoring, but no longer display start/end dates for each process instances: auditing and logging support is available in jBPM for this scope. The Drools RHQ/JON plug-in have been changed to reflect all the above mentioned changes, in addition to specific bug-fixing aiming to display hierarchical nesting correctly. 2.5. What is New and Noteworthy in Drools 6.4.0 It is now possible to use Java 8 syntax (lambdas and method references) in the Right Hand Side (then) part of a rule. The incremental compilation (dynamic rule-base update) had some relevant flaws when one or more rules with a subnetwork (rules with complex existential patterns) were involved, especially when the same subnetwork was shared among different rules.\n\n This issue required a partial rewriting of the existing incremental compilation algorithm, followed by a complete audit that has also been validated by brand new test suite made by more than 20,000 test cases only in this area. Engine’s code dealing with multi-threading has been partially rewritten in order to remove a large number of synchronisation points and improve stability and predictability.\n\n In particular this new implementation allows a clearer separation and better interaction between the User thread (performing the insert/update/delete actions on the session), the Engine thread (doing the proper rules evaluation) and the Timer one (performing time-based actions like events expiration). This improvement has been made possible by the new phreak algorithm introduced with Drools 6.\n\n In fact with in the ReteOO algorithm the network evaluation is performed during the User insert/update/delete action, meaning that each user action locks the entire engine.\n\n Conversely with phreak the insert/update/delete is separated and the network evaluation happens when fireAllRules or fireUntilHalt is called. More in detail this improvement has been made by 2 parts.\n\n First of all a new thread-safe queue has been added to store all user actions as commands.\n\n This queue is populated by the User thread while its entries are flushed and processed by the Engine thread during the rules evaluations phase.\n\n The second part introduced a state machine coordinating the User, Timer and Engine threads and then providing a clearer and self-documenting way to model their interactions. OOPath has been introduced with Drools 6.3.0.\n\n In Drools 6.4.0 it has been enhanced to support the following features:\n• A constraint can also have a beckreference to an object of the graph traversed before the currently iterated one. For example the following OOPath: will match only the grades having a result above the average for the passed exam.\n• A constraint can also recursively be another OOPath as it follows:\n• It is also possible to use the separator instead of the one. As in the following example: By doing so the engine will react to a change made to an exam, or if an exam is added to the plan, but not if a new grade is added to an existing exam.\n\n Of course if a OOPath chunk is not reactive, all remaining part of the OOPath from there till the end of the expression will be non-reactive as well.\n\n For instance the following OOPath will be completely non-reactive.\n\n For this reason it is not allowed to use the separator more than once in the same OOPath so an expression like: 2.6. New and Noteworthy in KIE Workbench 6.4.0 2.6.1. New look and feel The general look and feel in the entire workbench has been updated to adopt PatternFly.\n\n The update brings a cleaner, lightweight and more consistent user experience throughout every screen.\n\n Allowing users focus on the data and the tasks by removing all uncessary visual elements.\n\n Interactions and behaviors remain mostly unchanged, limiting the scope of this change to visual updates. Figure 19. Workbench - New look and feel In addition to the PatternFly update described above which targeted the general look and feel, many individual components in the workbench have been improved to create a better user experience.\n\n This involved making sure the default size of modal popup windows is appropriate to fit the corresponding content, adjusting the size of text fields as well as aligning labels, and improving the resize behaviour of various components when used on smaller screens. Locales (Russian) and (Chineses Traditional) have now been added. The locales now supported are: The Workbench used to have a section in the Project Editor for \"Import Suggestions\" which was really a way for Users to register classes provided by the Java Runtime environment to be available to Rule authoring.\n\n Furthermore Editors had a \"Config\" tab which was where Users were expected to import classes from other packages to that in which the rule resides. Neither term was clear and both were inconsistent with each other and other aspects of the Workbench. We have changed these terms to (hopefully) be clearer in their meaning and to be consistent with the \"Data Object\" term used in relation to authoring Java classes within the Workbench. The Data Object screen lists all Data Objects in the same package as the asset and allows other Data Objects from other packages to be imported. When navigating Projects with the Project Explorer the workbench automatically builds the selected project, displaying build messages in the Message Console.\n\n Whilst this is beneficial it can have a detremental impact on performance of the workbench when authoring large projects.\n\n The automatic build can now be disabled with the System Property.\n\n Set the value to to disable.\n\n The default value is . When cloning Repositories it is now possible to use style URLS, for example .\n\n If your Operating System’s public keystore is password protected the passphrase can be provided with the System Property. When performing any of the following operations a check is now made against all Maven Repositories, resolved for the Project, for whether the Project’s GroupId, ArtifactId and Version pre-exist.\n\n If a clash is found the operation is prevented; although this can be overridden by Users with the role. The feature can be disabled by setting the System Property to . Resolved repositories are those discovered in:\n• The Project’s section (or any parent ). Users with the role can override the list of Repositories checked using the \"Repositories\" settings in the Project Editor. The KIE Execution Server Management UI has been completely redesigned to adjust to major improvements introduced recently.\n\n Besides the fact that new UI has been built from scratch and following best practices provided by PatternFly, the new interface expands previous features giving users more control of their servers. Provides the backend services and an intuitive and friendly user interface that allows the workbench administrators to manage the application’s users and groups. This interface provides to the workbench administrators the ability to perform realm related operations such as create users, create groups, assign groups or roles to a given user, etc. It comes by default with built-in implementations for the administration of Wildfly, EAP and Tomcat default realms, and it’s designed to be extensible - any third party realm management system can be easily integrated into the workbench. 2.7. What is New and Noteworthy in Drools 6.3.0 When the field of a fact is a collection it is possible to bind and reason over all the items in that collection on by one using the keyword.\n\n Nevertheless, when it is required to browse a graph of object the extensive use of the conditional element may result in a verbose and cubersome syntax like in the following example: Example 5. Browsing a graph of objects with from rule \"Find all grades for Big Data exam\" when $student: Student( $plan: plan ) $exam: Exam( course == \"Big Data\" ) from $plan.exams $grade: Grade() from $exam.grades then /* RHS */ end In this example it has been assumed to use a domain model consisting of a who has a of study: a can have zero or more s and an zero or more s.\n\n Note that only the root object of the graph (the in this case) needs to be in the working memory in order to make this works. By borrowing ideas from XPath, this syntax can be made more succinct, as XPath has a compact notation for navigating through related elements while handling collections and filtering constraints.\n\n This XPath-inspired notation has been called since it is explictly intended to browse graph of objects.\n\n Using this notation the former example can be rewritten as it follows: Example 6. Browsing a graph of objects with OOPath rule \"Find all grades for Big Data exam\" when Student( $grade: /plan/exams{course == \"Big Data\"}/grades ) then /* RHS */ end Formally, the core grammar of an expression can be defined in EBNF notation in this way. In practice an expression has the following features.\n• It can dereference a single property of an object with the operator\n• It can dereference a multiple property of an object using the operator. If a collection is returned, it will iterate over the values in the collection\n• While traversing referenced objects it can filter away those not satisfying one or more constraints, written as predicate expressions between curly brackets like in:\n• Items can also be accessed by their index by putting it between square brackets like in: To adhere to Java convention OOPath indexes are 0-based, compared to XPath 1-based At the moment Drools is not able to react to updates involving a deeply nested traversed during the evaluation of an expression.\n\n To make these objects reactive to changes at the moment it is necessary to make them extend the class .\n\n It is planned to overcome this limitation by implementing a mechanism that automatically instruments the classes belonging to a specific domain model. Having extendend that class, the domain objects can notify the engine when one of its field has been updated by invoking the inherited method as in the following example: Example 7. Notifying the engine that an exam has been moved to a different course In this way if an exam is moved to a different course, the rule is re-triggered and the list of grades matching the rule recomputed. A new viewer has been added to the Eclipse Tooling.\n\n This Kie Navigator View is used to manage Kie Server installations and projects. Please read the chapter Kie Navigator View\n\n for more information about this new feature 2.8. New and Noteworthy in KIE Workbench 6.3.0 2.8.1. Real Time Validation and Verification for the Decision Tables Decision tables used to have a Validation-button for validating the table.\n\n This is now removed and the table is validated after each cell value change.\n\n The validation and verification checks include: These checks are explained in detail in the workbench documentation. The DRL Editor has undergone a face lift; moving from a plain TextArea to using ACE Editor and a custom DRL syntax highlighter. To avoid conflicts when editing assets, a new locking mechanism has been introduced that makes sure that only one user at a time can edit an asset.\n\n When a user begins to edit an asset, a lock will automatically be acquired.\n\n This is indicated by a lock symbol appearing on the asset title bar as well as in the project explorer view.\n\n If a user starts editing an already locked asset a pop-up notification will appear to inform the user that the asset can’t currently be edited, as it is being worked on by another user.\n\n As long as the editing user holds the lock, changes by other users will be prevented.\n\n Locks will automatically be released when the editing user saves or closes the asset, or logs out of the workbench.\n\n Every user further has the option to force a lock release in the metadata tab, if required. Figure 33. Locked assets cannot be edited by other users Drools and jBPM configurations, Persistence (see Generation of JPA enabled Data Models) and Advanced configurations were moved into \"Tool Windows\". \"Tool Windows\" are a new concept introduced in latest Uberfire version that enables the development of context aware screens.\n\n Each \"Tool Window\" will contain a domain editor that will manage a set of related Data Object parameters. Data modeller was extended to support the generation of persistable Data Objects.\n\n The persistable Data Objects are based on the JPA specification and all the underlying metadata are automatically generated.\n• \"The New → Data Object\" Data Objects can be marked as persistable at creation time.\n• The Persistence tool window contains the JPA Domain editors for both Data Object and Field. Each editor will manage the by default generated JPA metadata\n• Persistence configuration screen was added to the project editor. A new perspective for authoring data set definitions has been added.\n\n Data set definitions make it possible to retrieve data from external systems like databases, CSV/Excel files or even use a Java class to generate the data.\n\n Once the data is available it can be used, for instance, to create charts and dashboards from the Perspective Editor just feeding the charts from any of the data sets available. 2.9. What is New and Noteworthy in Drools 6.2.0 The introduction of PHREAK as default algorithm for the Drools engine made the rules' evaluation lazy.\n\n This new Drools lazy behavior allowed a relevant performance boost but, in some very specific cases, breaks the semantic of a few Drools features. More precisely in some circumstances it is necessary to propagate the insertion of new fact into th session immediately.\n\n For instance Drools allows a query to be executed in pull only (or passive) mode by prepending a '?' symbol to its invocation as in the following example: query Q (Integer i) String( this == i.toString() ) end rule R when $i : Integer() ?Q( $i; ) then System.out.println( $i ); end In this case, since the query is passive, it shouldn’t react to the insertion of a String matching the join condition in the query itself.\n\n In other words this sequence of commands shouldn’t cause the rule R to fire because the String satisfying the query condition has been inserted after the Integer and the passive query shouldn’t react to this insertion.\n\n Conversely the rule should fire if the insertion sequence is inverted because the insertion of the Integer, when the passive query can be satisfied by the presence of an already existing String, will trigger it. Unfortunately the lazy nature of PHREAK doesn’t allow the engine to make any distinction regarding the insertion sequence of the two facts, so the rule will fire in both cases.\n\n In circumstances like this it is necessary to evaluate the rule eagerly as done by the old RETEOO-based engine. In other cases it is required that the propagation is eager, meaning that it is not immedate, but anyway has to happen before the engine/agenda starts scheduled evaluations.\n\n For instance this is necessary when a rule has the no-loop or the lock-on-active attribute and in fact when this happens this propagation mode is automatically enforced by the engine. To cover these use cases, and in all other situations where an immediate or eager rule evaluation is required, it is possible to declaratively specify so by annotating the rule itself with @Propagation(Propagation.Type), where Propagation.Type is an enumeration with 3 possible values:\n• IMMEDIATE means that the propagation is performed immediately.\n• EAGER means that the propagation is performed lazily but eagerly evaluated before scheduled evaluations.\n• LAZY means that the propagation is totally lazy and this is default PHREAK behaviour This means that the following drl: query Q (Integer i) String( this == i.toString() ) end rule R @Propagation(IMMEDIATE) when $i : Integer() ?Q( $i; ) then System.out.println( $i ); end will make the rule R to fire if and only if the Integer is inserted after the String, thus behaving in accordance with the semantic of the passive query. 2.10. New and Noteworthy in KIE Workbench 6.2.0 2.10.1. Download Repository or Part of the Repository as a ZIP This feature makes it possible to download a repository or a folder from the repository as a ZIP file. The ability to configure role-based permissions for the Project Editor have been added. Permissions can be configured using the file. The following permissions are supported: All of our new screens use GWT-Bootstrap widgets and alert users to input errors in a consistent way. One of the most noticable differences was the Guided Decision Table Wizard that alerted errors in a way inconsistent with our use of GWT-Bootstrap. This Wizard has been updated to use the new look and feel. During the re-work of the Guided Decision Table’s Wizard to make it’s validation consistent with other areas of the application we took the opportunity to move the Wizard Framework to GWT-Bootstrap too. The resulting appearance is much more pleasing.\n\n We hope to migrate more legacy editors to GWT-Bootstrap as time and priorities permit. Consistency is a good thing for everybody.\n\n Users can expect different authoring metaphores to produce the same rule behaviour (and developers know when something is a bug!). There were a few inconsistencies in the way XLS Decision Tables, Guidied Decision Tables and Guided Rule Templates generated the underlying rules for empty cells.\n\n These have been eliminated making their operation consistent.\n• If all constraints have null values (empty cells) the Pattern is not created. Should you need the Pattern but no constraints; you will need to include the constraint . This operation is consistent with how XLS and Guided Decision Tables have always worked.\n• You can define a constraint on a String field for an empty String or white-space by delimiting it with double-quotation marks. The enclosing quotation-marks are removed from the value when generating the rules. The use of quotation marks for other String values is not required and they can be omitted.\n\n Their use is however essential to differentiate a constraint for an empty String from an empty cell - in which case the constraint is omitted. The Metadata tab provided in previous versions was redesigned to provide a better asset versioning information browsing and recovery.\n\n Now every workbench editor will provide an \"Overview tab\" that will enable the user to manage the following information.\n• The versions history shows a tabular view of the asset versions and provides a \"Select\" button that will enable the user to load a previously created version.\n• The metadata section gets access to additional file attributes.\n• The redesigned comments area enables much clearer discussions on a file.\n• The \"Version selector dropdown\" located at the menu bar provides the ability to load and restore previous versions from the \"Editor tab\", without having to open the \"Overview tab\" to load the \"Version history\". The Java editor was unified to the standard workbench editors functioning.\n\n It means that and now every data object is edited on his own editor window.\n• \"New → Data Object\" option was added to create the data objects.\n• Overview tab was added for every file to manage the file metadata and have access to the file versions history.\n• Editable \"Source Tab\" tab was added. Now the Java code can be modified by administrators using the workbench.\n• \"Editor\" - \"Source Tab\" round trip is provided. This will let administrators to do manual changes on the generated Java code and go back to the editor tab to continue working.\n• Class usages detection. Whenever a Data Object is about to be deleted or renamed, the project will be scanned for the class usages. If usages are found (e.g. in drl files, decision tables, etc.) the user will receive an alert. This will prevent the user from breaking the project build. A new perspective called Management has been added under Servers top level menu.\n\n This perspective provides users the ability to manage multiple execution servers with multiple containers.\n\n Available features includes connect to already deployed execution servers; create new, start, stop, delete or upgrade containers. A brand new feature called Social Activities has been added under a new top level menu item group called Activity. This new feature is divided in two different perspectives: Timeline Perspective and People Perspective. The Timeline Perspective shows on left side the recent assets created or edited by the logged user.\n\n In the main window there is the \"Latest Changes\" screen, showing all the recent updated assets and an option to filter the recent updates by repository. The People Perspective is the home page of an user.\n\n Showing his infos (including a gravatar picture from user e-mail), user connections (people that user follow) and user recent activities.\n\n There is also a way to edit an user info.\n\n The search suggestion can be used to navigate to a user profile, follow him and see his updates on your timeline. A brand new perspective called Contributors has been added under a new top level menu item group called Activity.\n\n The perspective itself is a dashboard which shows several indicators about the contributions made to the managed organizations / repositories within the workbench.\n\n Every time a organization/repository is added/removed from the workbench the dashboard itself is updated accordingly. This new perspective allows for the monitoring of the underlying activity on the managed repositories. The location of new assets whilst authoring was driven by the context of the Project Explorer. This has been replaced with a Package Selector in the New Resource Popup. The location defaults to the Project Explorer context but different packages can now be more easily chosen. All Popups have been refactored to use GWT-Bootstrap widgets. Whilst a simple change it brings greater visual consistency to the application as a whole. A new editor has been added to support modelling of simple decision trees. See the applicable section within the User Guide for more information about usage. A wizard has been created to guide the repository creation process.\n\n Now the user can decide at repository creation time if it should be a managed or unmanaged repository and configure all related parameters. The new Repository Structure Screen will let users to manage the projects for a given repository, as well as other operations related to managed repositories like: branch creation, assets promotion and project release. 2.11. New and Noteworthy in Integration 6.2.0 A new KIE Execution Server was created with the goal of supporting the deployment of kjars and the automatic creation of REST endpoints for remote rules execution.\n\n This initial implementation supports provisioning and execution of kjars via REST without any glue code. A user interface was also integrated into the workbench for remote provisioning.\n\n See the workbench’s New&Noteworthy for details. @Path(\"/server\") public interface KieServer { @GET @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response getInfo(); @POST @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response execute( CommandScript command ); @GET @Path(\"containers\") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response listContainers(); @GET @Path(\"containers/{id}\") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response getContainerInfo( @PathParam(\"id\") String id ); @PUT @Path(\"containers/{id}\") @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response createContainer( @PathParam(\"id\") String id, KieContainerResource container ); @DELETE @Path(\"containers/{id}\") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response disposeContainer( @PathParam(\"id\") String id ); @POST @Path(\"containers/{id}\") @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response execute( @PathParam(\"id\") String id, String cmdPayload ); @GET @Path(\"containers/{id}/release-id\") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response getReleaseId( @PathParam(\"id\") String id); @POST @Path(\"containers/{id}/release-id\") @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response updateReleaseId( @PathParam(\"id\") String id, ReleaseId releaseId ); @GET @Path(\"containers/{id}/scanner\") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response getScannerInfo( @PathParam(\"id\") String id ); @POST @Path(\"containers/{id}/scanner\") @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response updateScanner( @PathParam(\"id\") String id, KieScannerResource resource ); } 2.12. What is New and Noteworthy in Drools 6.1.0 Added support for JMX monitoring and management on KieScanner and KieContainer.\n\n To enable, set the property to , for example via Java command line: . KieScannerMBean will register under the name: It exposes the following properties:\n• Scanner Release Id: the release ID the scanner was configured with. May include maven range versions and special keywords like LATEST, SNAPSHOT, etc.\n• Current Release Id: the actual release ID the artifact resolved to. It also exposes the following operations:\n• scanNow(): forces an immediate scan of the maven repository looking for artifact updates\n• start(): starts polling the maven repository for artifact updates based on the polling interval parameter 2.13. New and Noteworthy in KIE Workbench 6.1.0 Full round trip between Data modeler and Java source code is now supported.\n\n No matter where the Java code was generated (e.g.\n\n Eclipse, Data modeller), data modeler will only update the necessary code blocks to maintain the model updated. New annotations @TypeSafe, @ClassReactive, @PropertyReactive, @Timestamp, @Duration and @Expires were added in order enrich current Drools annotations manged by the data modeler. 2.13.3. Standardization of the display of tabular data We have standardized the display of tabular data with a new table widget. The new table supports the following features: The table is used in the following scenarios: The Guided Rule Editor, Guided Template Editor and Guided Decision Table Editor have been changed to generate Historically these editors supported the older syntax and hence rules created within the Workbench would not respond correctly to and associated annotations within a model.\n\n This has now been rectified with the use of blocks. 2.14. New and Noteworthy in KIE API 6.0.0 KIE is the new umbrella name used to group together our related projects; as the family continues to grow.\n\n KIE is also used for the generic parts of unified API; such as building, deploying and loading.\n\n This replaces the droolsjbpm and knowledge keywords that would have been used before. One of the biggest complaints during the 5.x series was the lack of defined methodology for deployment.\n\n The mechanism used by Drools and jBPM was very flexible, but it was too flexible.\n\n A big focus for 6.0 was streamlining the build, deploy and loading (utilization) aspects of the system.\n\n Building and deploying activities are now aligned with Maven and Maven repositories.\n\n The utilization for loading rules and processess is now convention and configuration oriented, instead of programmatic, with sane defaults to minimise the configuration. Projects can be built with Maven and installed to the local M2_REPO or remote Maven repositories.\n\n Maven is then used to declare and build the classpath of dependencies, for KIE to access. The 'kmodule.xml' provides declarative configuration for KIE projects.\n\n Conventions and defaults are used to reduce the amount of configuration needed. KieServices ks = KieServices.Factory.get(); KieContainer kContainer = ks.getKieClasspathContainer(); KieSession kSession = kContainer.newKieSession(\"ksession1\"); kSession.insert(new Message(\"Dave\", \"Hello, HAL. Do you read me, HAL?\")); kSession.fireAllRules(); It is possible to include all the KIE artifacts belonging to a KieBase into a second KieBase.\n\n This means that the second KieBase, in addition to all the rules, function and processes directly defined into it, will also contain the ones created in the included KieBase.\n\n This inclusion can be done declaratively in the kmodule.xml file Example 12. Including a KieBase into another declaratively or programmatically using the . Example 13. Including a KieBase into another programmatically Any Maven produced JAR with a 'kmodule.xml' in it is considered a KieModule.\n\n This can be loaded from the classpath or dynamically at runtime from a Resource location.\n\n If the kie-ci dependency is on the classpath it embeds Maven and all resolving is done automatically using Maven and can access local or remote repositories.\n\n Settings.xml is obeyed for Maven configuration. The KieContainer provides a runtime to utilize the KieModule, versioning is built in throughout, via Maven.\n\n Kie-ci will create a classpath dynamically from all the Maven declared dependencies for the artifact being loaded.\n\n Maven LATEST, SNAPSHOT, RELEASE and version ranges are supported. KieServices ks = KieServices.Factory.get(); KieContainer kContainer = ks.newKieContainer( ks.newReleaseId(\"org.mygroup\", \"myartefact\", \"1.0\") ); KieSession kSession = kContainer.newKieSession(\"ksession1\"); kSession.insert(new Message(\"Dave\", \"Hello, HAL. Do you read me, HAL?\")); kSession.fireAllRules(); KieContainers can be dynamically updated to a specific version, and resolved through Maven if KIE-CI is on the classpath.\n\n For stateful KieSessions the existing sessions are incrementally updated. The is a Maven-oriented replacement of the KnowledgeAgent present in Drools 5.\n\n It continuously monitors your Maven repository to check if a new release of a Kie project has been installed and if so, deploys it in the wrapping that project.\n\n The use of the requires kie-ci.jar to be on the classpath. A can be registered on a as in the following example. Example 16. Registering and starting a KieScanner on a KieContainer KieServices kieServices = KieServices.Factory.get(); ReleaseId releaseId = kieServices.newReleaseId( \"org.acme\", \"myartifact\", \"1.0-SNAPSHOT\" ); KieContainer kContainer = kieServices.newKieContainer( releaseId ); KieScanner kScanner = kieServices.newKieScanner( kContainer ); // Start the KieScanner polling the Maven repository every 10 seconds kScanner.start( 10000L ); In this example the is configured to run with a fixed time interval, but it is also possible to run it on demand by invoking the method on it.\n\n If the finds, in the Maven repository, an updated version of the Kie project used by that it automatically downloads the new version and triggers an incremental build of the new project.\n\n From this moment all the new s and s created from that will use the new project version. The CompositeClassLoader is no longer used; as it was a constant source of performance problems and bugs.\n\n Traditional hierarchical classloaders are now used.\n\n The root classloader is at the KieContext level, with one child ClassLoader per namespace.\n\n This makes it cleaner to add and remove rules, but there can now be no referencing between namespaces in DRL files; i.e.\n\n functions can only be used by the namespaces that declared them.\n\n The recommendation is to use static Java methods in your project, which is visible to all namespaces; but those cannot (like other classes on the root KieContainer ClassLoader) be dynamically updated. The 5.x API for building and running with Drools and jBPM is still available through Maven dependency \"knowledge-api-legacy5-adapter\". Because the nature of deployment has significantly changed in 6.0, it was not possible to provide an adapter bridge for the KnowledgeAgent.\n\n If any other methods are missing or problematic, please open a JIRA, and we’ll fix for 6.1 While a lot of new documentation has been added for working with the new KIE API, the entire documentation has not yet been brought up to date.\n\n For this reason there will be continued references to old terminologies.\n\n Apologies in advance, and thank you for your patience.\n\n We hope those in the community will work with us to get the documentation updated throughout, for 6.1 2.15. What is New and Noteworthy in Drools 6.0.0 The main work done for Drools in 6.0 involves the new PREAK algorithm.\n\n This is a lazy algorithm that should enable Drools to handle a larger number of rules and facts.\n\n AngendaGroups can now help improvement performance, as rules are not evaluated until it attempts to fire them. Sequential mode continues to be supported for PHREAK but now 'modify' is allowed.\n\n While there is no 'inference' with sequential configuration, as rules are lazily evaluated, any rule not yet evaluated will see the more recent data as a result of 'modify'. This is more inline with how people intuitively think sequential works. The conflict resolution order has been tweaked for PHREAK, and now is ordered by salience and then rule order; based on the rule position in the file.. Prior to Drools 6.0.0, after salience, it was considered arbitrary.\n\n When KieModules and updateToVersion are used for dynamic deployment, the rule order in the file is preserved via the diff processing. When the rule engine runs in passive mode (i.e.: using fireAllRules) by default it doesn’t fire consequences of timed rules unless fireAllRules isn’t invoked again.\n\n Now it is possible to change this default behavior by configuring the KieSession with a as shown in the following example. It is also possible to have a finer grained control on the timed rules that have to be automatically executed.\n\n To do this it is necessary to set a `FILTERED that allows to define a callback to filter those rules, as done in the next example. Example 18. Configuring a filter to choose which timed rules should be automatically executed It is now possible to define both the delay and interval of an interval timer as an expression instead of a fixed value.\n\n To do that it is necessary to declare the timer as an expression one (indicated by \"expr:\") as in the following example: Example 19. An Expression Timer Example The expressions, $d and $p in this case, can use any variable defined in the pattern matching part of the rule and can be any String that can be parsed in a time duration or any numeric value that will be internally converted in a long representing a duration expressed in milliseconds. Both interval and expression timers can have 3 optional parameters named \"start\", \"end\" and \"repeat-limit\". When one or more of these parameters are used the first part of the timer definition must be followed by a semicolon ';' and the parameters have to be separated by a comma ',' as in the following example: Example 20. An Interval Timer with a start and an end The value for start and end parameters can be a Date, a String representing a Date or a long, or more in general any Number, that will be transformed in a Java Date applying the following conversion: Conversely the repeat-limit can be only an integer and it defines the maximum number of repetitions allowed by the timer.\n\n If both the end and the repeat-limit parameters are set the timer will stop when the first of the two will be matched. The using of the start parameter implies the definition of a phase for the timer, where the beginning of the phase is given by the start itself plus the eventual delay.\n\n In other words in this case the timed rule will then be scheduled at times: for up to repeat-limit times and no later than the end timestamp (whichever first). For instance the rule having the following interval timer will be scheduled at the 30th second of every minute after the midnight of the 3-JAN-2010.\n\n This also means that if for example you turn the system on at midnight of the 3-FEB-2010 it won’t be scheduled immediately but will preserve the phase defined by the timer and so it will be scheduled for the first time 30 seconds after the midnight.\n\n If for some reason the system is paused (e.g.\n\n the session is serialized and then deserialized after a while) the rule will be scheduled only once to recover from missing activations (regardless of how many activations we missed) and subsequently it will be scheduled again in phase with the timer. These two groups have been merged and now RuleFlowGroups behave the same as AgendaGroups.\n\n The get methods have been left, for deprecation reasons, but both return the same underlying data.\n\n When jBPM activates a group it now just calls setFocus.\n\n RuleFlowGroups and AgendaGroups when used together was a continued source of errors.\n\n It also aligns the codebase, towards PHREAK and the multi-core explotation that is planned in the future. 2.16. New and Noteworthy in KIE Workbench 6.0.0 The workbench has had a big overhaul using a new base project called UberFire.\n\n UberFire is inspired by Eclipse and provides a clean, extensible and flexible framework for the workbench.\n\n The end result is not only a richer experience for our end users, but we can now develop more rapidly with a clean component based architecture.\n\n If you like he Workbench experience you can use UberFire today to build your own web based dashboard and console efforts. As well as the move to a UberFire the other biggest change is the move from JCR to Git; there is an utility project to help with migration.\n\n Git is the most scalable and powerful source repository bar none.\n\n JGit provides a solid OSS implementation for Git.\n\n This addresses the continued performance problems with the various JCR implementations, which would slow down once the number of files and number of versions become too high.\n\n There has been a big \"low tech\" drive, to remove complexity.\n\n Everything is now stored as a file, including meta data.\n\n The database is only there to provide fast indexing and search.\n\n So importing and exporting is all standard Git and external sites, like GitHub, can be used to exchange repositories. In 5.x developers would work with their own source repository and then push JCR, via the team provider.\n\n This team provider was not full featured and not available outside Eclipse.\n\n Git enables our repository to work any existing Git tool or team provider.\n\n While not yet supported in the UI, this will be added over time, it is possible to connect to the repo and tag and branch and restore things. The Guvnor brand leaked too much from its intended role; such as the authoring metaphors, like Decision Tables, being considered Guvnor components instead of Drools components.\n\n This wasn’t helped by the monolithic projects structure used in 5.x for Guvnor.\n\n In 6.0 Guvnor 's focus has been narrowed to encapsulates the set of UberFire plugins that provide the basis for building a web based IDE.\n\n Such as Maven integration for building and deploying, management of Maven repositories and activity notifications via inboxes.\n\n Drools and jBPM build workbench distributions using Uberfire as the base and including a set of plugins, such as Guvnor, along with their own plugins for things like decision tables, guided editors, BPMN2 designer, human tasks. The \"Model Structure\" diagram outlines the new project anatomy.\n\n The Drools workbench is called KIE-Drools-WB.\n\n KIE-WB is the uber workbench that combines all the Guvnor, Drools and jBPM plugins.\n\n The jBPM-WB is ghosted out, as it doesn’t actually exist, being made redundant by KIE-WB. KIE Drools Workbench and KIE Workbench share a common set of components for generic workbench functionality such as Project navigation, Project definitions, Maven based Projects, Maven Artifact Repository.\n\n These common features are described in more detail throughout this documentation. The two primary distributions consist of:\n• New flexible Workbench environment, with perspectives and panels.\n• New packaging and build system following KIE API.\n• New Data Modeller replaces the declarative Fact Model Editor; bringing authoring of Java classes to the authoring environment. Java classes are packaged into the project and can be used within rules, processes etc and externally in your own applications.\n• \n• External modifications appear within the Workbench.\n• Incremental Build system showing, near real-time validation results of your project and assets. The editors themselves are largely unchanged; however of note imports have moved from the package definition to individual editors so you need only import types used for an asset and not the package as a whole. 2.17. New and Noteworthy in Integration 6.0.0 CDI is now tightly integrated into the KIE API.\n\n It can be used to inject versioned KieSession and KieBases. Spring has been revamped and now integrated with KIE.\n\n Spring can replace the 'kmodule.xml' with a more powerful spring version.\n\n The aim is for consistency with kmodule.xml Aries blueprints is now also supported, and follows the work done for spring.\n\n The aim is for consistency with spring and kmodule.xml All modules have been refactored to avoid package splitting, which was a problem in 5.x.\n\n Testing has been moved to PAX.\n\nSo where do we get started? There are so many use cases and so much functionality in a rule engine such as Drools that it becomes beguiling.\n\n Have no fear my intrepid adventurer, the complexity is layered and you can ease yourself in with simple use cases. Stateless session, not utilising inference, forms the simplest use case.\n\n A stateless session can be called like a function passing it some data and then receiving some results back.\n\n Some common use cases for stateless sessions are, but not limited to:\n• \n• Is this person eligible for a mortgage?\n• \n• Filter incoming messages, such as emails, into folders. So let’s start with a very simple example using a driving license application. public class Applicant { private String name; private int age; private boolean valid; // getter and setter methods here } Now that we have our data model we can write our first rule.\n\n We assume that the application uses rules to reject invalid applications.\n\n As this is a simple validation use case we will add a single rule to disqualify any applicant younger than 18. package com.company.license rule \"Is of valid age\" when $a : Applicant( age < 18 ) then $a.setValid( false ); end To make the engine aware of data, so it can be processed against the rules, we have to insert the data, much like with a database.\n\n When the Applicant instance is inserted into the engine it is evaluated against the constraints of the rules, in this case just two constraints for one rule.\n\n We say two because the type Applicant is the first object type constraint, and is the second field constraint.\n\n An object type constraint plus its zero or more field constraints is referred to as a pattern.\n\n When an inserted instance satisfies both the object type constraint and all the field constraints, it is said to be matched.\n\n The is a binding variable which permits us to reference the matched object in the consequence.\n\n There its properties can be updated.\n\n The dollar character ('$') is optional, but it helps to differentiate variable names from field names.\n\n The process of matching patterns against the inserted data is, not surprisingly, often referred to as pattern matching. To use this rule it is necessary to put it a Drools file, just a plain text file with .drl extension , short for \"Drools Rule Language\". Let’s call this file licenseApplication.drl, and store it in a Kie Project.\n\n A Kie Project has the structure of a normal Maven project with an additional file (kmodule.xml) defining the s and s that can be created.\n\n This file has to be placed in the resources/META-INF folder of the Maven project while all the other Drools artifacts, such as the licenseApplication.drl containing the former rule, must be stored in the resources folder or in any other subfolder under it. Since meaningful defaults have been provided for all configuration aspects, the simplest kmodule.xml file can contain just an empty kmodule tag like the following: At this point it is possible to create a that reads the files to be built, from the classpath. The above code snippet compiles all the DRL files found on the classpath and put the result of this compilation, a , in the .\n\n If there are no errors, we are now ready to create our session from the and execute against some data: The preceding code executes the data against the rules.\n\n Since the applicant is under the age of 18, the application is marked as invalid. So far we’ve only used a single instance, but what if we want to use more than one? We can execute against any object implementing Iterable, such as a collection.\n\n Let’s add another class called , which has the date of the application, and we’ll also move the boolean valid field to the class. public class Applicant { private String name; private int age; // getter and setter methods here } public class Application { private Date dateApplied; private boolean valid; // getter and setter methods here } We will also add another rule to validate that the application was made within a period of time. package com.company.license rule \"Is of valid age\" when Applicant( age < 18 ) $a : Application() then $a.setValid( false ); end rule \"Application was made this year\" when $a : Application( dateApplied > \"01-jan-2009\" ) then $a.setValid( false ); end Unfortunately a Java array does not implement the interface, so we have to use the JDK converter method .\n\n The code shown below executes against an iterable list, where all collection elements are inserted before any matched rules are fired. StatelessKieSession kSession = kContainer.newStatelessKieSession(); Applicant applicant = new Applicant( \"Mr John Smith\", 16 ); Application application = new Application(); assertTrue( application.isValid() ); ksession.execute( Arrays.asList( new Object[] { application, applicant } ) ); assertFalse( application.isValid() ); The two execute methods and are actually convenience methods for the interface 's method . The commands factory, obtainable from the like all other factories of the KIE API, is used to create commands, so that the following is equivalent to : Batch Executor and Command Factory are particularly useful when working with multiple Commands and with output identifiers for obtaining results. KieCommands kieCommands = kieServices.getCommands(); List<Command> cmds = new ArrayList<Command>(); cmds.add( kieCommands.newInsert( new Person( \"Mr John Smith\" ), \"mrSmith\", true, null ) ); cmds.add( kieCommands.newInsert( new Person( \"Mr John Doe\" ), \"mrDoe\", true, null ) ); BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) ); assertEquals( new Person( \"Mr John Smith\" ), results.getValue( \"mrSmith\" ) ); supports many other Commands that can be used in the like , , and . Stateful Sessions are long lived and allow iterative changes over time.\n\n Some common use cases for Stateful Sessions are, but not limited to: In contrast to a Stateless Session, the method must be called afterwards to ensure there are no memory leaks, as the KieBase contains references to Stateful Knowledge Sessions when they are created.\n\n Since Stateful Knowledge Session is the most commonly used session type it is just named in the KIE API. also supports the interface, like , the only difference being that the command is not automatically called at the end for a Stateful Session. We illustrate the monitoring use case with an example for raising a fire alarm.\n\n Using just four classes, we represent rooms in a house, each of which has one sprinkler.\n\n If a fire starts in a room, we represent that with a single instance. public class Room { private String name // getter and setter methods here } public class Sprinkler { private Room room; private boolean on; // getter and setter methods here } public class Fire { private Room room; // getter and setter methods here } public class Alarm { } In the previous section on Stateless Sessions the concepts of inserting and matching against data were introduced.\n\n That example assumed that only a single instance of each object type was ever inserted and thus only used literal constraints.\n\n However, a house has many rooms, so rules must express relationships between objects, such as a sprinkler being in a certain room.\n\n This is best done by using a binding variable as a constraint in a pattern.\n\n This \"join\" process results in what is called cross products, which are covered in the next section. When a fire occurs an instance of the class is created, for that room, and inserted into the session.\n\n The rule uses a binding on the field of the object to constrain matching to the sprinkler for that room, which is currently off.\n\n When this rule fires and the consequence is executed the sprinkler is turned on. rule \"When there is a fire turn on the sprinkler\" when Fire($room : room) $sprinkler : Sprinkler( room == $room, on == false ) then modify( $sprinkler ) { setOn( true ) }; System.out.println( \"Turn on the sprinkler for room \" + $room.getName() ); end Whereas the Stateless Session uses standard Java syntax to modify a field, in the above rule we use the statement, which acts as a sort of \"with\" statement.\n\n It may contain a series of comma separated Java expressions, i.e., calls to setters of the object selected by the statement’s control expression.\n\n This modifies the data, and makes the engine aware of those changes so it can reason over them once more.\n\n This process is called inference, and it’s essential for the working of a Stateful Session.\n\n Stateless Sessions typically do not use inference, so the engine does not need to be aware of changes to data.\n\n Inference can also be turned off explicitly by using the sequential mode. So far we have rules that tell us when matching data exists, but what about when it does not exist? How do we determine that a fire has been extinguished, i.e., that there isn’t a object any more? Previously the constraints have been sentences according to Propositional Logic, where the engine is constraining against individual instances.\n\n Drools also has support for First Order Logic that allows you to look at sets of data.\n\n A pattern under the keyword matches when something does not exist.\n\n The rule given below turns the sprinkler off as soon as the fire in that room has disappeared. rule \"When the fire is gone turn off the sprinkler\" when $room : Room( ) $sprinkler : Sprinkler( room == $room, on == true ) not Fire( room == $room ) then modify( $sprinkler ) { setOn( false ) }; System.out.println( \"Turn off the sprinkler for room \" + $room.getName() ); end While there is one sprinkler per room, there is just a single alarm for the building.\n\n An object is created when a fire occurs, but only one is needed for the entire building, no matter how many fires occur.\n\n Previously was introduced to match the absence of a fact; now we use its complement which matches for one or more instances of some category. rule \"Raise the alarm when we have one or more fires\" when exists Fire() then insert( new Alarm() ); System.out.println( \"Raise the alarm\" ); end Likewise, when there are no fires we want to remove the alarm, so the keyword can be used again. rule \"Cancel the alarm when all the fires have gone\" when not Fire() $alarm : Alarm() then delete( $alarm ); System.out.println( \"Cancel the alarm\" ); end Finally there is a general health status message that is printed when the application first starts and after the alarm is removed and all sprinklers have been turned off. rule \"Status output when things are ok\" when not Alarm() not Sprinkler( on == true ) then System.out.println( \"Everything is ok\" ); end As we did in the Stateless Session example, the above rules should be placed in a single DRL file and saved into the resouces folder of your Maven project or any of its subfolder.\n\n As before, we can then obtain a from the .\n\n The only difference is that this time we create a Stateful Session, whereas before we created a Stateless Session. With the session created it is now possible to iteratively work with it over time.\n\n Four objects are created and inserted, as well as one object for each room.\n\n At this point the engine has done all of its matching, but no rules have fired yet.\n\n Calling allows the matched rules to fire, but without a fire that will just produce the health message. String[] names = new String[]{\"kitchen\", \"bedroom\", \"office\", \"livingroom\"}; Map<String,Room> name2room = new HashMap<String,Room>(); for( String name: names ){ Room room = new Room( name ); name2room.put( name, room ); ksession.insert( room ); Sprinkler sprinkler = new Sprinkler( room ); ksession.insert( sprinkler ); } ksession.fireAllRules(); > Everything is ok We now create two fires and insert them; this time a reference is kept for the returned .\n\n A Fact Handle is an internal engine reference to the inserted instance and allows instances to be retracted or modified at a later point in time.\n\n With the fires now in the engine, once is called, the alarm is raised and the respective sprinklers are turned on. > Raise the alarm > Turn on the sprinkler for room kitchen > Turn on the sprinkler for room office After a while the fires will be put out and the instances are retracted.\n\n This results in the sprinklers being turned off, the alarm being cancelled, and eventually the health message is printed again. > Cancel the alarm > Turn off the sprinkler for room office > Turn off the sprinkler for room kitchen > Everything is ok Everyone still with me? That wasn’t so hard and already I’m hoping you can start to see the value and power of a declarative rule system. People often confuse methods and rules, and new rule users often ask, \"How do I call a rule?\" After the last section, you are now feeling like a rule expert and the answer to that is obvious, but let’s summarize the differences nonetheless. rule \"Hello World\" when Person( name == \"Chuck\" ) then System.out.println( \"Hello Chuck\" ); end\n• Rules execute by matching against any data as long it is inserted into the engine.\n• Rules can never be called directly.\n• Specific instances cannot be passed to a rule.\n• Depending on the matches, a rule may fire once or several times, or not at all. Earlier the term \"cross product\" was mentioned, which is the result of a join.\n\n Imagine for a moment that the data from the fire alarm example were used in combination with the following rule where there are no field constraints: In SQL terms this would be like doing and every row in the Room table would be joined with every row in the Sprinkler table resulting in the following output: These cross products can obviously become huge, and they may very well contain spurious data.\n\n The size of cross products is often the source of performance problems for new rule authors.\n\n From this it can be seen that it’s always desirable to constrain the cross products, which is done with the variable constraint. This results in just four rows of data, with the correct Sprinkler for each Room.\n\n In SQL (actually HQL) the corresponding query would be . The Agenda is a Rete feature.\n\n It maintains set of rules that are able to execute, its job is to schedule that execution in a deterministic order. During actions on the , rules may become fully matched and eligible for execution; a single Rule Runtime Action can result in multiple eligible rules.\n\n When a rule is fully matched a Rule Match is created, referencing the rule and the matched facts, and placed onto the Agenda.\n\n The Agenda controls the execution order of these Matches using a Conflict Resolution strategy. The engine cycles repeatedly through two phases:\n• Rule Runtime Actions. This is where most of the work takes place, either in the Consequence (the RHS itself) or the main Java application process. Once the Consequence has finished or the main Java application process calls the engine switches to the Agenda Evaluation phase.\n• Agenda Evaluation. This attempts to select a rule to fire. If no rule is found it exits, otherwise it fires the found rule, switching the phase back to Rule Runtime Actions. The process repeats until the agenda is clear, in which case control returns to the calling application.\n\n When Rule Runtime Actions are taking place, no rules are being fired. So far the data and the matching process has been simple and small.\n\n To mix things up a bit a new example will be explored that handles cashflow calculations over date periods.\n\n The state of the engine will be illustratively shown at key stages to help get a better understanding of what is actually going on under the hood.\n\n Three classes will be used, as shown below.\n\n This will help us grow our understanding of pattern matching and joins further.\n\n We will then use this to illustrate different techniques for execution control. public class CashFlow { private Date date; private double amount; private int type; long accountNo; // getter and setter methods here } public class Account { private long accountNo; private double balance; // getter and setter methods here } public AccountPeriod { private Date start; private Date end; // getter and setter methods here } By now you already know how to create KieBases and how to instantiate facts to populate the , so tables will be used to show the state of the inserted data, as it makes things clearer for illustration purposes.\n\n The tables below show that a single fact was inserted for the .\n\n Also inserted are a series of debits and credits as objects for that account, extending over two quarters. Two rules can be used to determine the debit and credit for that quarter and update the Account balance.\n\n The two rules below constrain the cashflows for an account for a given time period.\n\n Notice the \"&&\" which use short cut syntax to avoid repeating the field name twice. rule \"increase balance for credits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"decrease balance for debits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == DEBIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance -= $amount; end Earlier we showed how rules would equate to SQL, which can often help people with an SQL background to understand rules.\n\n The two rules above can be represented with two views and a trigger for each view, as below: select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == CREDIT and cf.date >= ap.start and cf.date <= ap.end select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == DEBIT and cf.date >= ap.start and cf.date <= ap.end If the is set to the first quarter we constrain the rule \"increase balance for credits\" to fire on two rows of data and \"decrease balance for debits\" to act on one row of data. The two cashflow tables above represent the matched data for the two rules.\n\n The data is matched during the insertion stage and, as you discovered in the previous chapter, does not fire straight away, but only after is called.\n\n Meanwhile, the rule plus its matched data is placed on the Agenda and referred to as an RuIe Match or Rule Instance.\n\n The Agenda is a table of Rule Matches that are able to fire and have their consequences executed, as soon as fireAllRules() is called.\n\n Rule Matches on the Agenda are referred to as a conflict set\n\n and their execution is determine by a conflict resolution strategy.\n\n Notice that the order of execution so far is considered arbitrary. After all of the above activations are fired, the account has a balance of -25. If the is updated to the second quarter, we have just a single matched row of data, and thus just a single Rule Match on the Agenda. The firing of that Activation results in a balance of 25. What if you don’t want the order of rule execution to be arbitrary? When there is one or more Rule Match on the Agenda they are said to be in conflict, and a conflict resolution strategy is used to determine the order of execution.\n\n The Drools strategy is very simple and based around a salience value, which assigns a priority to a rule.\n\n Each rule has a default value of 0, the higher the value the higher the priority. As a general rule, it is a good idea not to count on rules firing in any particular order, and to author the rules without worrying about a \"flow\". However when a flow is needed a number of possibilities exist beyond salience: agenda groups, rule flow groups, activation groups and control/semaphore facts. As of Drools 6.0 rule definition order in the source file is used to set priority after salience. To illustrate Salience we add a rule to print the account balance, where we want this rule to be executed after all the debits and credits have been applied for all accounts.\n\n We achieve this by assigning a negative salience to this rule so that it fires after all rules with the default salience 0. rule \"Print balance for AccountPeriod\" salience -50 when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end The table below depicts the resulting Agenda.\n\n The three debit and credit rules are shown to be in arbitrary order, while the print rule is ranked last, to execute afterwards. Agenda groups allow you to place rules into groups, and to place those groups onto a stack.\n\n The stack has push/pop bevaviour.\n\n Calling \"setFocus\" places the group onto the stack: The agenda always evaluates the top of the stack.\n\n When all the rules have fired for a group, it is popped from the stack and the next group is evaluated. rule \"increase balance for credits\" agenda-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" agenda-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end First set the focus to the \"report\" group and then by placing the focus on \"calculation\" we ensure that group is evaluated first. Drools also features ruleflow-group attributes which allows workflow diagrams to declaratively specify when rules are allowed to fire.\n\n The screenshot below is taken from Eclipse using the Drools plugin.\n\n It has two ruleflow-group nodes which ensures that the calculation rules are executed before the reporting rules. The use of the ruleflow-group attribute in a rule is shown below. rule \"increase balance for credits\" ruleflow-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" ruleflow-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end Inference has a bad name these days, as something not relevant to business use cases and just too complicated to be useful.\n\n It is true that contrived and complicated examples occur with inference, but that should not detract from the fact that simple and useful ones exist too.\n\n But more than this, correct use of inference can crate more agile and less error prone business rules, which are easier to maintain. So what is inference? Something is inferred when we gain knowledge of something from using previous knowledge.\n\n For example, given a Person fact with an age field and a rule that provides age policy control, we can infer whether a Person is an adult or a child and act on this. rule \"Infer Adult\" when $p : Person( age >= 18 ) then insert( new IsAdult( $p ) ) end Due to the preceding rule, every Person who is 18 or over will have an instance of IsAdult inserted for them.\n\n This fact is special in that it is known as a relation.\n\n We can use this inferred relation in any rule: So now we know what inference is, and have a basic example, how does this facilitate good rule design and maintenance? Let’s take a government department that are responsible for issuing ID cards when children become adults, henceforth referred to as ID department.\n\n They might have a decision table that includes logic like this, which says when an adult living in London is 18 or over, issue the card: However the ID department does not set the policy on who an adult is.\n\n That’s done at a central government level.\n\n If the central government were to change that age to 21, this would initiate a change management process.\n\n Someone would have to liaise with the ID department and make sure their systems are updated, in time for the law going live. This change management process and communication between departments is not ideal for an agile environment, and change becomes costly and error prone.\n\n Also the card department is managing more information than it needs to be aware of with its \"monolithic\" approach to rules management which is \"leaking\" information better placed elsewhere.\n\n By this I mean that it doesn’t care what explicit age ▸ = 18 information determines whether someone is an adult, only that they are an adult. In contrast to this, let’s pursue an approach where we split (de-couple) the authoring responsibilities, so that both the central government and the ID department maintain their own rules. It’s the central government’s job to determine who is an adult.\n\n If they change the law they just update their central repository with the new rules, which others use: The IsAdult fact, as discussed previously, is inferred from the policy rules.\n\n It encapsulates the seemingly arbitrary piece of logic age ▸ = 18 and provides semantic abstractions for its meaning.\n\n Now if anyone uses the above rules, they no longer need to be aware of explicit information that determines whether someone is an adult or not.\n\n They can just use the inferred fact: While the example is very minimal and trivial it illustrates some important points.\n\n We started with a monolithic and leaky approach to our knowledge engineering.\n\n We created a single decision table that had all possible information in it and that leaks information from central government that the ID department did not care about and did not want to manage. We first de-coupled the knowledge process so each department was responsible for only what it needed to know.\n\n We then encapsulated this leaky knowledge using an inferred fact IsAdult.\n\n The use of the term IsAdult also gave a semantic abstraction to the previously arbitrary logic age ▸ = 18. So a general rule of thumb when doing your knowledge engineering is: After regular inserts you have to retract facts explicitly.\n\n With logical assertions, the fact that was asserted will be automatically retracted when the conditions that asserted it in the first place are no longer true.\n\n Actually, it’s even cleverer then that, because it will be retracted only if there isn’t any single condition that supports the logical assertion. Normal insertions are said to be stated, i.e., just like the intuitive meaning of \"stating a fact\" implies.\n\n Using a and a counter, we track how many times a particular equality is stated; this means we count how many different instances are equal. When we logically insert an object during a RHS execution we are said to justify it, and it is considered to be justified by the firing rule.\n\n For each logical insertion there can only be one equal object, and each subsequent equal logical insertion increases the justification counter for this logical assertion.\n\n A justification is removed by the LHS of the creating rule becoming untrue, and the counter is decreased accordingly.\n\n As soon as we have no more justifications the logical object is automatically retracted. If we try to logically insert an object when there is an equal stated object, this will fail and return null.\n\n If we state an object that has an existing equal object that is justified we override the Fact; how this override works depends on the configuration setting .\n\n When the property is set to discard we use the existing handle and replace the existing instance with the new Object, which is the default behavior; otherwise we override it to stated but we create an new . This can be confusing on a first read, so hopefully the flow charts below help.\n\n When it says that it returns a new , this also indicates the was propagated through the network. 6.4.1.1. Bus Pass Example With Inference and TMS The previous example was issuing ID cards to over 18s, in this example we now issue bus passes, either a child or adult pass. rule \"Issue Child Bus Pass\" when $p : Person( age < 16 ) then insert(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) then insert(new AdultBusPass( $p ) ); end As before the above example is considered monolithic, leaky and providing poor separation of concerns. As before we can provide a more robust application with a separation of concerns using inference.\n\n Notice this time we don’t just insert the inferred object, we use \"insertLogical\": rule \"Infer Child\" when $p : Person( age < 16 ) then insertLogical( new IsChild( $p ) ) end rule \"Infer Adult\" when $p : Person( age >= 16 ) then insertLogical( new IsAdult( $p ) ) end A \"insertLogical\" is part of the Drools Truth Maintenance System (TMS). When a fact is logically inserted, this fact is dependant on the truth of the \"when\" clause.\n\n It means that when the rule becomes false the fact is automatically retracted.\n\n This works particularly well as the two rules are mutually exclusive.\n\n So in the above rules if the person is under 16 it inserts an IsChild fact, once the person is 16 or over the IsChild fact is automatically retracted and the IsAdult fact inserted. Returning to the code to issue bus passes, these two rules can + logically insert the ChildBusPass and AdultBusPass facts, as the TMS + supports chaining of logical insertions for a cascading set of retracts. rule \"Issue Child Bus Pass\" when $p : Person( ) IsChild( person == $p ) then insertLogical(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) IsAdult( person =$p ) then insertLogical(new AdultBusPass( $p ) ); end Now when a person changes from being 15 to 16, not only is the IsChild fact automatically retracted, so is the person’s ChildBusPass fact.\n\n For bonus points we can combine this with the 'not' conditional element to handle notifications, in this situation, a request for the returning of the pass.\n\n So when the TMS automatically retracts the ChildBusPass object, this rule triggers and sends a request to the person: rule \"Return ChildBusPass Request \"when $p : Person( ) not( ChildBusPass( person == $p ) ) then requestChildBusPass( $p ); end It is important to note that for Truth Maintenance (and logical assertions) to work at all, your Fact objects (which may be JavaBeans) must override equals and hashCode methods (from java.lang.Object) correctly.\n\n As the truth maintenance system needs to know when two different physical objects are equal in value, both equals and hashCode must be overridden correctly, as per the Java standard. Two objects are equal if and only if their equals methods return true for each other and if their hashCode methods return the same values.\n\n See the Java API for more details (but do keep in mind you MUST override both equals and hashCode). TMS behaviour is not affected by theruntime configuration of Identity vs Equality, TMS is always equality. 6.4.1.3. Deleting stated or logically asserted facts from the working memory By default when a fact is deleted from the working memory Drools attempts to remove it both from the set of stated facts and also from the Truth Maintenance System in case it has been logically asserted.\n\n However, using an overload of the delete method, it is also possible to remove it only from one of the 2.\n\n For instance invoking: the fact is removed only if it has been logically asserted, but not if it is a stated fact.\n\n In this case, if the fact has been stated its deletion fails silently and it is ignored. Decision tables are a \"precise yet compact\" (ref.\n\n Wikipedia) way of representing conditional logic, and are well suited to business level rules. Drools supports managing rules in a spreadsheet format.\n\n Supported formats are Excel (XLS), and CSV, which means that a variety of spreadsheet programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can be utilized.\n\n It is expected that web based decision table editors will be included in a near future release. Decision tables are an old concept (in software terms) but have proven useful over the years.\n\n Very briefly speaking, in Drools decision tables are a way to generate rules driven from the data entered into a spreadsheet.\n\n All the usual features of a spreadsheet for data capture and manipulation can be taken advantage of. 6.5.1. When to Use Decision Tables Consider decision tables as a course of action if rules exist that can be expressed as rule templates and data: each row of a decision table provides data that is combined with a template to generate a rule. Many businesses already use spreadsheets for managing data, calculations, etc.\n\n If you are happy to continue this way, you can also manage your business rules this way.\n\n This also assumes you are happy to manage packages of rules in .xls\n\n or .csv\n\n files.\n\n Decision tables are not recommended for rules that do not follow a set of templates, or where there are a small number of rules (or if there is a dislike towards software like Excel or OpenOffice.org). They are ideal in the sense that there can be control over what parameters of rules can be edited, without exposing the rules directly. Decision tables also provide a degree of insulation from the underlying object model. Here are some examples of real world decision tables (slightly edited to protect the innocent). In the above examples, the technical aspects of the decision table have been collapsed away (using a standard spreadsheet feature). The rules start from row 17, with each row resulting in a rule.\n\n The conditions are in columns C, D, E, etc., the actions being off-screen.\n\n The values in the cells are quite simple, and their meaning is indicated by the headers in Row 16.\n\n Column B is just a description.\n\n It is customary to use color to make it obvious what the different areas of the table mean. Note that although the decision tables look like they process top down, this is not necessarily the case.\n\n Ideally, rules are authored without regard for the order of rows, simply because this makes maintenance easier, as rows will not need to be shifted around all the time. As each row is a rule, the same principles apply.\n\n As the rule engine processes the facts, any rules that match may fire.\n\n (Some people are confused by this.\n\n It is possible to clear the agenda when a rule fires and simulate a very simple decision table where only the first match effects an action.) Also note that you can have multiple tables on one spreadsheet.\n\n This way, rules can be grouped where they share common templates, yet at the end of the day they are all combined into one rule package.\n\n Decision tables are essentially a tool to generate DRL rules automatically. Figure 126. A real world example using multiple tables for grouping like rules The key point to keep in mind is that in a decision table each row is a rule, and each column in that row is either a condition or action for that rule. The spreadsheet looks for the RuleTable\n\n keyword to indicate the start of a rule table (both the starting row and column). Other keywords are also used to define other package level attributes (covered later). It is important to keep the keywords in one column.\n\n By convention the second column (\"B\") is used for this, but it can be any column (convention is to leave a margin on the left for notes). In the following diagram, C is actually the column where it starts.\n\n Everything to the left of this is ignored. If we expand the hidden sections, it starts to make more sense how it works; note the keywords in column C. Now the hidden magic which makes it work can be seen.\n\n The RuleSet keyword indicates the name to be used in the rule package that will encompass all the rules.\n\n This name is optional, using a default, but it must have the RuleSet keyword in the cell immediately to the right. The other keywords visible in Column C are Import and Sequential which will be covered later.\n\n The RuleTable keyword is important as it indicates that a chunk of rules will follow, based on some rule templates.\n\n After the RuleTable keyword there is a name, used to prefix the names of the generated rules.\n\n The sheet name and row numbers are appended to guarantee unique rule names. The RuleTable name combined with the sheet name must be unique across all spreadsheet files in the same KieBase.\n\n If that’s not the case, some rules might have the same name and only 1 of them will be applied.\n\n To show such ignored rules, raise the severity of such rule name conflicts. The column of RuleTable indicates the column in which the rules start; columns to the left are ignored. In general the keywords make up name-value pairs. Referring to row 14 (the row immediately after RuleTable), the keywords CONDITION and ACTION indicate that the data in the columns below are for either the LHS or the RHS parts of a rule.\n\n There are other attributes on the rule which can also be optionally set this way. Row 15 contains declarations of ObjectTypes\n\n .\n\n The content in this row is optional, but if this option is not in use, the row must be left blank; however this option is usually found to be quite useful.\n\n When using this row, the values in the cells below (row 16) become constraints on that object type.\n\n In the above case, it generates and , where 42 and \"stilton\" come from row 18.\n\n In the above example, the \"==\" is implicit; if just a field name is given the translator assumes that it is to generate an exact match. An ObjectType declaration can span columns (via merged cells), meaning that all columns below the merged range are to be combined into one set of constraints within a single pattern matching a single fact at a time, as opposed to non-merged cells containing the same ObjectType, but resulting in different patterns, potentially matching different or identical facts. Row 16 contains the rule templates themselves.\n\n They can use the \"$param\" placeholder to indicate where data from the cells below should be interpolated.\n\n (For multiple insertions, use \"$1\", \"$2\", etc., indicating parameters from a comma-separated list in a cell below.) Row 17 is ignored; it may contain textual descriptions of the column’s purpose. Rows 18 and 19 show data, which will be combined (interpolated) with the templates in row 15, to generate rules.\n\n If a cell contains no data, then its template is ignored.\n\n (This would mean that some condition or action does not apply for that rule row.) Rule rows are read until there is a blank row.\n\n Multiple RuleTables can exist in a sheet.\n\n Row 20 contains another keyword, and a value.\n\n The row positions of keywords like this do not matter (most people put them at the top) but their column should be the same one where the RuleTable or RuleSet keywords should appear.\n\n In our case column C has been chosen to be significant, but any other column could be used instead. In the above example, rules would be rendered like the following (as it uses the \"ObjectType\" row): The constraints and are interpreted as single constraints, to be added to the respective ObjectType in the cell above.\n\n If the cells above were spanned, then there could be multiple constraints on one \"column\". Very large decision tables may have very large memory requirements. There are two types of rectangular areas defining data that is used for generating a DRL file.\n\n One, marked by a cell labelled , defines all DRL items except rules.\n\n The other one may occur repeatedly and is to the right and below a cell whose contents begin with .\n\n These areas represent the actual decision tables, each area resulting in a set of rules of similar structure. A Rule Set area may contain cell pairs, one below the cell and containing a keyword designating the kind of value contained in the other one that follows in the same row. The columns of a Rule Table area define patterns and constraints for the left hand sides of the rules derived from it, actions for the consequences of the rules, and the values of individual rule attributes.\n\n Thus, a Rule Table area should contain one or more columns, both for conditions and actions, and an arbitrary selection of columns for rule attributes, at most one column for each of these.\n\n The first four rows following the row with the cell marked with are earmarked as header area, mostly used for the definition of code to construct the rules.\n\n It is any additional row below these four header rows that spawns another rule, with its data providing for variations in the code defined in the Rule Table header. Only the first worksheet is examined for decision tables. Entries in a Rule Set area may define DRL constructs (except rules), and specify rule attributes.\n\n While entries for constructs may be used repeatedly, each rule attribute may be given at most once, and it applies to all rules unless it is overruled by the same attribute being defined within the Rule Table area. Entries must be given in a vertically stacked sequence of cell pairs.\n\n The first one contains a keyword and the one to its right the value, as shown in the table below.\n\n This sequence of cell pairs may be interrupted by blank rows or even a Rule Table, as long as the column marked by is upheld as the one containing the keyword. The package name for the generated DRL file. Optional, the default is\n\n . \"true\" or \"false\". If \"true\", then salience is used to ensure that rules fire from the top\n\n down. Optional, at most once. If omitted, no firing order is imposed. \"true\" or \"false\". If \"true\", then quotation marks are escaped so that they appear literally in the\n\n DRL. Optional, at most once. If omitted, quotation marks are escaped. \"true\" or \"false\". If \"true\", then a String representation is used for DRL instead of a double value\n\n from a Numeric cell Optional, at most once. If omitted, a double value is used. Optional, may be used repeatedly. Declarations of DRL globals, i.e., a type followed by a variable name. Multiple global definitions\n\n must be separated with a comma. Optional, may be used repeatedly. One or more function definitions, according to DRL syntax. Optional, may be used repeatedly. One or more query definitions, according to DRL syntax. Optional, may be used repeatedly. One or more declarative types, according to DRL syntax. Optional, may be used repeatedly. In some locales, MS Office, LibreOffice and OpenOffice will encode a double quote differently, which will cause a compilation error.\n\n The difference is often hard to see.\n\n For example: will fail, but will work. For defining rule attributes that apply to all rules in the generated DRL file you can use any of the entries in the following table.\n\n Notice, however, that the proper keyword must be used.\n\n Also, each of these attributes may be used only once. Rule attributes specified in a Rule Set area will affect all rule assets in the same package (not only in the spreadsheet). Unless you are sure that the spreadsheet is the only one rule asset in the package, the recommendation is to specify rule attributes not in a Rule Set area but in a Rule Table columns for each rule instead. An integer defining the \"salience\" value for the rule. Overridden by the \"Sequential\" flag. A long integer value defining the \"duration\" value for the rule. A Boolean value. \"true\" enables the rule; \"false\" disables the rule. A Boolean value. \"true\" inhibits looping of rules due to changes made by its consequence. A Boolean value. \"true\" inhibits additional activations of all rules with this flag set within the\n\n same ruleflow or agenda group. A Boolean value. \"true\" for a rule within an agenda group causes activations of the rule to\n\n automatically give the focus to the group. A string identifying an activation (or XOR) group. Only one rule within an activation group will\n\n fire, i.e., the first one to fire cancels any existing activations of other rules within the same\n\n group. A string identifying an agenda group, which has to be activated by giving it the \"focus\", which is\n\n one way of controlling the flow between groups of rules. All Rule Tables begin with a cell containing \"RuleTable\", optionally followed by a string within the same cell.\n\n The string is used as the initial part of the name for all rules derived from this Rule Table, with the row number appended for distinction.\n\n (This automatic naming can be overridden by using a NAME column.) All other cells defining rules of this Rule Table are below and to the right of this cell. The next row defines the column type, with each column resulting in a part of the condition or the consequence, or providing some rule attribute, the rule name or a comment.\n\n The table below shows which column headers are available; additional columns may be used according to the table showing rule attribute entries given in the preceding section.\n\n Note that each attribute column may be used at most once.\n\n For a column header, either use the keyword or any other word beginning with the letter given in the \"Initial\" column of these tables. Provides the name for the rule generated from that row. The default is constructed from the text\n\n following the RuleTable tag and the row number. A text, resulting in a comment within the generated rule. Code snippet and interpolated values for constructing a constraint within a pattern in a\n\n condition. At least one per rule table Code snippet and interpolated values for constructing an action for the consequence of the\n\n rule. At least one per rule table Code snippet and interpolated values for constructing a metadata entry for the rule. Given a column headed CONDITION, the cells in successive lines result in a conditional element.\n• Text in the first cell below CONDITION develops into a pattern for the rule condition, with the snippet in the next line becoming a constraint. If the cell is merged with one or more neighbours, a single pattern with multiple constraints is formed: all constraints are combined into a parenthesized list and appended to the text in this cell. The cell may be left blank, which means that the code snippet in the next row must result in a valid conditional element on its own. To include a pattern without constraints, you can write the pattern in front of the text for another pattern. The pattern may be written with or without an empty pair of parentheses.\n\n A \"from\" clause may be appended to the pattern. If the pattern ends with \"eval\", code snippets are supposed to produce boolean expressions for inclusion into a pair of parentheses after \"eval\".\n• Text in the second cell below CONDITION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using \"==\" with the value from the cells below, the field selector alone is sufficient. Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A text according to the pattern delimiter snippet is expanded by repeating the snippet once for each of the values of the comma-separated list of values in each of the cells below, inserting the value in place of the symbol and by joining these expansions by the given delimiter.\n\n Note that the forall construct may be surrounded by other text.\n• If the cell in the preceding row is not empty, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below CONDITION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the conditional element or constraint for this rule. Given a column headed ACTION, the cells in successive lines result in an action statement.\n• Text in the first cell below ACTION is optional. If present, it is interpreted as an object reference.\n• Text in the second cell below ACTION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A method call without interpolation can be achieved by a text without any marker symbols.\n\n In this case, use any non-blank entry in a row below to include the statement. The forall construct is available here, too.\n• If the first cell is not empty, its text, followed by a period, the text in the second cell and a terminating semicolon are stringed together, resulting in a method call which is added as an action statement for the consequence. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below ACTION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the action statement for this rule. Using instead of works in most cases, but it will fail if the replacement text contains a comma: then, only the part preceding the first comma is inserted.\n\n Use this \"abbreviation\" judiciously. Given a column headed METADATA, the cells in successive lines result in a metadata annotation for the generated rules.\n• Text in the first cell below METADATA is ignored.\n• Text in the second cell below METADATA is subject to interpolation, as described above, using values from the cells in the rule rows. The metadata marker character is prefixed automatically, and thus it should not be included in the text for this cell.\n• Text in the third cell below METADATA is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the metadata annotation for this rule. The various interpolations are illustrated in the following example. If the template is and the cell is , then the result is . If the template is and the cell contains , the result will be . The template with a cell containing results in . The next example demonstrates the joint effect of a cell defining the pattern type and the code snippet below it. This spreadsheet section shows how the type declaration spans 2 columns, and thus both constraints will appear as .\n\n Since only the field names are present in the snippet, they imply an equality test. In the following example the marker symbol is used. The result of this column is the pattern .\n\n You may have noticed that the marker and the operator \"==\" are redundant. The next example illustrates that a trailing insertion marker can be omitted. Here, appending the value from the cell is implied, resulting in You can provide the definition of a binding variable, as in the example below. Here, the result is Note that the quotes are provided automatically.\n\n Actually, anything can be placed in the object type row.\n\n Apart from the definition of a binding variable, it could also be an additional pattern that is to be inserted literally. A simple construction of an action statement with the insertion of a single value is shown below. The cell below the ACTION header is left blank.\n\n Using this style, anything can be placed in the consequence, not just a single method call.\n\n (The same technique is applicable within a CONDITION column as well.) Below is a comprehensive example, showing the use of various column headers.\n\n It is not an error to have no value below a column header (as in the NO-LOOP column): here, the attribute will not be applied in any of the rules. Figure 129. Example usage of keywords for imports, headers, etc. And, finally, here is an example of Import, Variables and Functions. Figure 130. Example usage of keywords for functions, etc. Multiple package names within the same cell must be separated by a comma.\n\n Also, the pairs of type and variable names must be comma-separated.\n\n Functions, however, must be written as they appear in a DRL file.\n\n This should appear in the same column as the \"RuleSet\" keyword; it could be above, between or below all the rule rows. It may be more convenient to use Import, Variables, Functions and Queries repeatedly rather than packing several definitions into a single cell. The API to use spreadsheet based decision tables is in the drools-decisiontables module.\n\n There is really only one class to look at: .\n\n This class will take spreadsheets in various formats, and generate rules in DRL (which you can then use in the normal way). The can just be used to generate partial rule files if it is wished, and assemble it into a complete rule package after the fact (this allows the separation of technical and non-technical aspects of the rules if needed). To get started, a sample spreadsheet can be used as a base.\n\n Alternatively, if the plug-in is being used (Rule Workbench IDE), the wizard can generate a spreadsheet from a template (to edit it an xls compatible spreadsheet editor will need to be used). Spreadsheets are well established business tools (in use for over 25 years). Decision tables lend themselves to close collaboration between IT and domain experts, while making the business rules clear to business analysts, it is an ideal separation of concerns. Typically, the whole process of authoring rules (coming up with a new decision table) would be something like:\n• Business analyst takes a template decision table (from a repository, or from IT)\n• Decision table business language descriptions are entered in the table(s)\n• Decision table is handed to a technical resource, who maps the business language (descriptions) to scripts (this may involve software development of course, if it is a new application or data model)\n• Technical person hands back and reviews the modifications with the business analyst.\n• The business analyst can continue editing the rule rows as needed (moving columns around is also fine etc).\n• In parallel, the technical person can develop test cases for the rules (liaising with business analysts) as these test cases can be used to verify rules and rule changes once the system is running. Features of applications like Excel can be used to provide assistance in entering data into spreadsheets, such as validating fields.\n\n Lists that are stored in other worksheets can be used to provide valid lists of values for cells, like in the following diagram. Some applications provide a limited ability to keep a history of changes, but it is recommended to use an alternative means of revision control.\n\n When changes are being made to rules over time, older versions are archived (many open source solutions exist for this, such as Subversion or Git). Related to decision tables (but not necessarily requiring a spreadsheet) are \"Rule Templates\" (in the drools-templates module). These use any tabular data source as a source of rule data - populating a template to generate many rules.\n\n This can allow both for more flexible spreadsheets, but also rules in existing databases for instance (at the cost of developing the template up front to generate the rules). With Rule Templates the data is separated from the rule and there are no restrictions on which part of the rule is data-driven.\n\n So whilst you can do everything you could do in decision tables you can also do the following:\n• store your data in a database (or any other format)\n• conditionally generate rules based on the values in the data\n• use data for any part of your rules (e.g. condition operator, class name, property name)\n• run different templates over the same data As an example, a more classic decision table is shown, but without any hidden rows for the rule meta data (so the spreadsheet only contains the raw data to generate the rules). See the ExampleCheese.xls in the examples download for the above spreadsheet. If this was a regular decision table there would be hidden rows before row 1 and between rows 1 and 2 containing rule metadata.\n\n With rule templates the data is completely separate from the rules.\n\n This has two handy consequences - you can apply multiple rule templates to the same data and your data is not tied to your rules at all.\n\n So what does the template look like?\n• Lines 2-4: Following the header is the list of columns in the order they appear in the data. In this case we are calling the first column , the second and the third .\n• Line 5: An empty line signifies the end of the column definitions.\n• Lines 6-9: Standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global and function definitions into this section.\n• Line 10: The keyword signals the start of a rule template. There can be more than one template in a template file, but each template should have a unique name.\n• Lines 11-18: The rule template - see below for details.\n• Line 20: The keywords signify the end of the template. The rule templates rely on MVEL to do substitution using the syntax @{token_name}. There is currently one built-in expression, @{row.rowNumber} which gives a unique number for each row of data and enables you to generate unique rule names.\n\n For each row of data a rule will be generated with the values in the data substituted for the tokens in the template. A rule template has to be included in a file with extension .drt and associated to the corresponding decision table when defining the kbase in the kmodule.xml file as in the following example With the example data above the following rule file would be generated: package org.drools.examples.templates; global java.util.List list; rule \"Cheese fans_1\" when Person(age == 42) Cheese(type == \"stilton\") then list.add(\"Old man stilton\"); end rule \"Cheese fans_2\" when Person(age == 21) Cheese(type == \"cheddar\") then list.add(\"Young man cheddar\"); end At this point the named \"TemplatesKS\" and containing the rules generated from the template can be simply created from the and used as any other . KieSession ksession = kc.newKieSession( \"TemplatesKS\" ); // now create some test data ksession.insert( new Cheese( \"stilton\", 42 ) ); ksession.insert( new Person( \"michael\", \"stilton\", 42 ) ); final List<String> list = new ArrayList<String>(); ksession.setGlobal( \"list\", list ); ksession.fireAllRules(); One way to illuminate the black box that is a rule engine, is to play with the logging level. Everything is logged to SLF4J, which is a simple logging facade that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging.\n\n Add a dependency to the logging adaptor for your logging framework of choice.\n\n If you’re not using any logging framework yet, you can use Logback by adding this Maven dependency: If you’re developing for an ultra light environment, use or instead. Configure the logging level on the package .\n\n For example: In Logback, configure it in your logback.xml\n\n file: In Log4J, configure it in your log4j.xml\n\n file:\n\nDrools has a \"native\" rule language.\n\n This format is very light in terms of punctuation, and supports natural and domain specific languages via \"expanders\" that allow the language to morph to your problem domain.\n\n This chapter is mostly concerted with this native rule format.\n\n The diagrams used to present the syntax are known as \"railroad\" diagrams, and they are basically flow charts for the language terms.\n\n The technically very keen may also refer to DRL.g\n\n which is the Antlr3 grammar for the rule language.\n\n If you use the Rule Workbench, a lot of the rule structure is done for you with content assistance, for example, type \"ru\" and press ctrl+space, and it will build the rule structure for you. A rule file is typically a file with a .drl extension.\n\n In a DRL file you can have multiple rules, queries and functions, as well as some resource declarations like imports, globals and attributes that are assigned and used by your rules and queries.\n\n However, you are also able to spread your rules across multiple rule files (in that case, the extension .rule is suggested, but not required) - spreading rules across files can help with managing large numbers of rules.\n\n A DRL file is simply a text file. The overall structure of a rule file is: The order in which the elements are declared is not important, except for the package name that, if declared, must be the first element in the rules file.\n\n All elements are optional, so you will use only those you need.\n\n We will discuss each of them in the following sections. For the impatient, just as an early view, a rule has the following rough structure: rule \"name\" attributes when LHS then RHS end It’s really that simple.\n\n Mostly punctuation is not needed, even the double quotes for \"name\" are optional, as are newlines.\n\n Attributes are simple (always optional) hints to how the rule should behave.\n\n LHS is the conditional parts of the rule, which follows a certain syntax which is covered below.\n\n RHS is basically a block that allows dialect specific semantic code to be executed. It is important to note that white space is not important, except in the case of domain specific languages, where lines are processed one by one and spaces may be significant to the domain language. Drools 5 introduces the concept of hard and soft keywords. Hard keywords are reserved, you cannot use any hard keyword when naming your domain objects, properties, methods, functions and other elements that are used in the rule text. Here is the list of hard keywords that must be avoided as identifiers when writing rules: Soft keywords are just recognized in their context, enabling you to use these words in any other place if you wish, although, it is still recommended to avoid them, to avoid confusions, if possible.\n\n Here is a list of the soft keywords: Of course, you can have these (hard and soft) words as part of a method name in camel case, like notSomething() or accumulateSomething() - there are no issues with that scenario. Although the 3 hard keywords above are unlikely to be used in your existing domain models, if you absolutely need to use them as identifiers instead of keywords, the DRL language provides the ability to escape hard keywords on rule text.\n\n To escape a word, simply enclose it in grave accents, like this: Holiday( `true` == \"yes\" ) // please note that Drools will resolve that reference to the method Holiday.isTrue() Comments are sections of text that are ignored by the rule engine.\n\n They are stripped out when they are encountered, except inside semantic code blocks, like the RHS of a rule. To create single line comments, you can use '//'. The parser will ignore anything in the line after the comment symbol.\n\n Example: rule \"Testing Comments\" when // this is a single line comment eval( true ) // this is a comment in the same line of a pattern then // this is a comment inside a semantic code block end '#' for comments has been removed. Multi-line comments are used to comment blocks of text, both in and outside semantic code blocks.\n\n Example: rule \"Test Multi-line Comments\" when /* this is a multi-line comment in the left hand side of a rule */ eval( true ) then /* and this is a multi-line comment in the right hand side of a rule */ end Drools 5 introduces standardized error messages.\n\n This standardization aims to help users to find and resolve problems in a easier and faster way.\n\n In this section you will learn how to identify and interpret those error messages, and you will also receive some tips on how to solve the problems associated with them. The standardization includes the error message format and to better explain this format, let’s use the following example: 4th Block: This is the first context.\n\n Usually indicates the rule, function, template or query where the error occurred.\n\n This block is not mandatory. 5th Block: Identifies the pattern where the error occurred.\n\n This block is not mandatory. Indicates the most common errors, where the parser came to a decision point but couldn’t identify an alternative.\n\n Here are some examples: 1: rule one 2: when 3: exists Foo() 4: exits Bar() // \"exits\" 5: then 6: end The above example generates this message:\n• [ERR 101] Line 4:4 no viable alternative at input 'exits' in rule one At first glance this seems to be valid syntax, but it is not (exits != exists). Let’s take a look at next example: Now the above code generates this message:\n• [ERR 101] Line 3:2 no viable alternative at input 'WHEN' This message means that the parser encountered the token WHEN, actually a hard keyword, but it’s in the wrong place since the the rule name is missing. The error \"no viable alternative\" also occurs when you make a simple lexical mistake.\n\n Here is a sample of a lexical problem: 1: rule simple_rule 2: when 3: Student( name == \"Andy ) 4: then 5: end The above code misses to close the quotes and because of this the parser generates this error message:\n• [ERR 101] Line 0:-1 no viable alternative at input '<eof>' in rule simple_rule in pattern Student Usually the Line and Column information are accurate, but in some cases (like unclosed quotes), the parser generates a 0:-1 position.\n\n In this case you should check whether you didn’t forget to close quotes, apostrophes or parentheses. This error indicates that the parser was looking for a particular symbol that it didn’t ﬁnd at the current input position.\n\n Here are some samples: The above example generates this message: To fix this problem, it is necessary to complete the rule statement. Usually when you get a 0:-1 position, it means that parser reached the end of source. The following code generates more than one error message: 1: package org.drools.examples; 2: 3: rule \"Avoid NPE on wrong syntax\" 4: when 5: not( Cheese( ( type == \"stilton\", price == 10 ) || ( type == \"brie\", price == 15 ) ) from $cheeseList ) 6: then 7: System.out.println(\"OK\"); 8: end These are the errors associated with this source:\n• [ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule \"Avoid NPE on wrong syntax\" in pattern Cheese\n• [ERR 101] Line 5:57 no viable alternative at input 'type' in rule \"Avoid NPE on wrong syntax\"\n• [ERR 102] Line 5:106 mismatched input ')' expecting 'then' in rule \"Avoid NPE on wrong syntax\" Note that the second problem is related to the first.\n\n To fix it, just replace the commas (',') by AND operator ('&&'). In some situations you can get more than one error message.\n\n Try to fix one by one, starting at the first one.\n\n Some error messages are generated merely as consequences of other errors. A validating semantic predicate evaluated to false.\n\n Usually these semantic predicates are used to identify soft keywords.\n\n This sample shows exactly this situation: 1: package nesting; 2: dialect \"mvel\" 3: 4: import org.drools.compiler.Person 5: import org.drools.compiler.Address 6: 7: fdsfdsfds 8: 9: rule \"test something\" 10: when 11: p: Person( name==\"Michael\" ) 12: then 13: p.name = \"other\"; 14: System.out.println(p.name); 15: end With this sample, we get this error message: The fdsfdsfds text is invalid and the parser couldn’t identify it as the soft keyword . This error is very similar to 102: Mismatched input, but usually involves soft keywords. This error is associated with the clause, where its expression may not be terminated with a semicolon.\n\n Check this example: Due to the trailing semicolon within eval, we get this error message: This problem is simple to fix: just remove the semi-colon. The recognizer came to a subrule in the grammar that must match an alternative at least once, but the subrule did not match anything.\n\n Simply put: the parser has entered a branch from where there is no way out.\n\n This example illustrates it: This is the message associated to the above sample:\n• [ERR 105] Line 2:2 required (…​)+ loop did not match anything at input 'aa' in template test_error To fix this problem it is necessary to remove the numeric value as it is neither a valid data type which might begin a new template slot nor a possible start for any other rule file construct. Any other message means that something bad has happened, so please contact the development team. A package is a collection of rules and other related constructs, such as imports and globals.\n\n The package members are typically related to each other - perhaps HR rules, for instance.\n\n A package represents a namespace, which ideally is kept unique for a given grouping of rules.\n\n The package name itself is the namespace, and is not related to files or folders in any way. It is possible to assemble rules from multiple rule sources, and have one top level package configuration that all the rules are kept under (when the rules are assembled). Although, it is not possible to merge into the same package resources declared under different names.\n\n A single Rulebase may, however, contain multiple packages built on it.\n\n A common structure is to have all the rules for a package in the same file as the package declaration (so that is it entirely self-contained). The following railroad diagram shows all the components that may make up a package.\n\n Note that a package must have a namespace and be declared using standard Java conventions for package names; i.e., no spaces, unlike rule names which allow spaces.\n\n In terms of the order of elements, they can appear in any order in the rule file, with the exception of the statement, which must be at the top of the file.\n\n In all cases, the semicolons are optional. Notice that any rule attribute (as described the section Rule Attributes) may also be written at package level, superseding the attribute’s default value.\n\n The modified default may still be replaced by an attribute setting within a rule. Import statements work like import statements in Java.\n\n You need to specify the fully qualified paths and type names for any objects you want to use in the rules.\n\n Drools automatically imports classes from the Java package of the same name, and also from the package . With you define global variables.\n\n They are used to make application objects available to the rules.\n\n Typically, they are used to provide data or services that the rules use, especially application services used in rule consequences, and to return data from the rules, like logs or values added in rule consequences, or for the rules to interact with the application, doing callbacks.\n\n Globals are not inserted into the Working Memory, and therefore a global should never be used to establish conditions in rules except when it has a constant immutable value.\n\n The engine cannot be notified about value changes of globals and does not track their changes.\n\n Incorrect use of globals in constraints may yield surprising results - surprising in a bad way. If multiple packages declare globals with the same identifier they must be of the same type and all of them will reference the same global value. In order to use globals you must:\n• Declare your global variable in your rules file and use it in rules.\n\n For example: global java.util.List myGlobalList; rule \"Using a global\" when eval( true ) then myGlobalList.add( \"Hello World\" ); end\n• Set the global value on your working memory. It is a best practice to set all global values before asserting any fact to the working memory. Example: Note that these are just named instances of objects that you pass in from your application to the working memory.\n\n This means you can pass in any object you want: you could pass in a service locator, or perhaps a service itself.\n\n With the new element it is now common to pass a Hibernate session as a global, to allow to pull data from a named Hibernate query. One example may be an instance of a Email service.\n\n In your integration code that is calling the rule engine, you obtain your emailService object, and then set it in the working memory.\n\n In the DRL, you declare that you have a global of type EmailService, and give it the name \"email\". Then in your rule consequences, you can use things like email.sendSMS(number, message). Globals are not designed to share data between rules and they should never be used for that purpose.\n\n Rules always reason and react to the working memory state, so if you want to pass data from rule to rule, assert the data as facts into the working memory. Care must be taken when changing data held by globals because the rule engine is not aware of those changes, hence cannot react to them. Functions are a way to put semantic code in your rule source file, as opposed to in normal Java classes.\n\n They can’t do anything more than what you can do with helper classes.\n\n (In fact, the compiler generates the helper class for you behind the scenes.) The main advantage of using functions in a rule is that you can keep the logic all in one place, and you can change the functions as needed (which can be a good or a bad thing). Functions are most useful for invoking actions on the consequence ( ) part of a rule, especially if that particular action is used over and over again, perhaps with only differing parameters for each rule. function String hello(String name) { return \"Hello \"+name+\"!\"; } Note that the keyword is used, even though its not really part of Java.\n\n Parameters to the function are defined as for a method, and you don’t have to have parameters if they are not needed.\n\n The return type is defined just like in a regular method. Alternatively, you could use a static method in a helper class, e.g., .\n\n Drools supports the use of function imports, so all you would need to do is: Irrespective of the way the function is defined or imported, you use a function by calling it by its name, in the consequence or inside a semantic code block.\n\n Example: rule \"using a static function\" when eval( true ) then System.out.println( hello( \"Bob\" ) ); end Type declarations have two main goals in the rules engine: to allow the declaration of new types, and to allow the declaration of metadata for types.\n• Declaring new types: Drools works out of the box with plain Java objects as facts. Sometimes, however, users may want to define the model directly to the rules engine, without worrying about creating models in a lower level language like Java. At other times, there is a domain model already built, but eventually the user wants or needs to complement this model with additional entities that are used mainly during the reasoning process.\n• Declaring metadata: facts may have meta information associated to them. Examples of meta information include any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. This meta information may be queried at runtime by the engine and used in the reasoning process. To declare a new type, all you need to do is use the keyword , followed by the list of fields, and the keyword .\n\n A new fact must have a list of fields, otherwise the engine will look for an existing fact class in the classpath and raise an error if not found. The previous example declares a new fact type called .\n\n This fact type will have three attributes: , and .\n\n Each attribute has a type that can be any valid Java type, including any other class created by the user or even other fact types previously declared. For instance, we may want to declare another fact type : As we can see on the previous example, is of type , from the Java API, while is of the previously defined fact type Address. You may avoid having to write the fully qualified name of a class every time you write it by using the clause, as previously discussed. Example 110. Avoiding the need to use fully qualified class names by using import When you declare a new fact type, Drools will, at compile time, generate bytecode that implements a Java class representing the fact type.\n\n The generated Java class will be a one-to-one Java Bean mapping of the type definition.\n\n So, for the previous example, the generated Java class would be: Example 111. generated Java class for the previous Person fact typedeclaration public class Person implements Serializable { private String name; private java.util.Date dateOfBirth; private Address address; // empty constructor public Person() {...} // constructor with all fields public Person( String name, Date dateOfBirth, Address address ) {...} // if keys are defined, constructor with keys public Person( ...keys... ) {...} // getters and setters // equals/hashCode // toString } Since the generated class is a simple Java class, it can be used transparently in the rules, like any other fact. Example 112. Using the declared types in rules rule \"Using a declared Type\" when< $p : Person( name == \"Bob\" ) then // Insert Mark, who is Bob's mate. Person mark = new Person(); mark.setName(\"Mark\"); insert( mark ); end DRL also supports the declaration of enumerative types.\n\n Such type declarations require the additional keyword enum, followed by a comma separated list of admissible values terminated by a semicolon. rule \"Using a declared Type\" when $p : Person( name == \"Bob\" ) then // Insert Mark, who is Bob's mate. Person mark = new Person(); mark.setName(\"Mark\"); insert( mark ); end The compiler will generate a valid Java enum, with static methods valueOf() and values(), as well as instance methods ordinal(), compareTo() and name(). Complex enums are also partially supported, declaring the internal fields similarly to a regular type declaration.\n\n Notice that as of version 6.x, enum fields do NOT support other declared types or enums Enumeratives can then be used in rules Example 113. Using declarative enumerations in rules rule \"Using a declared Enum\" when $p : Employee( dayOff == DaysOfWeek.MONDAY ) then ... end Metadata may be assigned to several different constructions in Drools: fact types, fact attributes and rules.\n\n Drools uses the at sign ('@') to introduce metadata, and it always uses the form: For instance, if you want to declare a metadata attribute like , whose value is Bob, you could simply write: Drools allows the declaration of any arbitrary metadata attribute, but some will have special meaning to the engine, while others are simply available for querying at runtime.\n\n Drools allows the declaration of metadata both for fact types and for fact attributes.\n\n Any metadata that is declared before the attributes of a fact type are assigned to the fact type, while metadata declared after an attribute are assigned to that particular attribute. Example 115. Declaring metadata attributes for fact types and attributes In the previous example, there are two metadata items declared for the fact type ( and ) and two more defined for the name attribute ( and ). Please note that the metadata has no required value, and so the parentheses and the value were omitted.: Some annotations have predefined semantics that are interpreted by the engine.\n\n The following is a list of some of these predefined annotations and their meaning. The @role annotation defines how the engine should handle instances of that type: either as regular facts or as events.\n\n It accepts two possible values:\n• fact : this is the default, declares that the type is to be handled as a regular fact.\n• event : declares that the type is to be handled as an event. The following example declares that the fact type StockTick in a stock broker application is to be handled as an event. Example 116. declaring a fact type as an event The same applies to facts declared inline.\n\n If StockTick was a fact type declared in the DRL itself, instead of a previously existing class, the code would be: Example 117. declaring a fact type and assigning it the event role By default all type declarations are compiled with type safety enabled; @typesafe( false ) provides a means to override this behaviour by permitting a fall-back, to type unsafe evaluation where all constraints are generated as MVEL constraints and executed dynamically.\n\n This can be important when dealing with collections that do not have any generics or mixed type collections. Every event has an associated timestamp assigned to it.\n\n By default, the timestamp for a given event is read from the Session Clock and assigned to the event at the time the event is inserted into the working memory.\n\n Although, sometimes, the event has the timestamp as one of its own attributes.\n\n In this case, the user may tell the engine to use the timestamp from the event’s attribute instead of reading it from the Session Clock. To tell the engine what attribute to use as the source of the event’s timestamp, just list the attribute name as a parameter to the @timestamp tag. Drools supports both event semantics: point-in-time events and interval-based events.\n\n A point-in-time event is represented as an interval-based event whose duration is zero.\n\n By default, all events have duration zero.\n\n The user may attribute a different duration for an event by declaring which attribute in the event type contains the duration of the event. So, for our VoiceCall fact type, the declaration would be: This tag is only considered when running the engine in STREAM mode.\n\n Also, additional discussion on the effects of using this tag is made on the Memory Management section.\n\n It is included here for completeness. Events may be automatically expired after some time in the working memory.\n\n Typically this happens when, based on the existing rules in the knowledge base, the event can no longer match and activate any rules.\n\n Although, it is possible to explicitly define when an event should expire. The value of timeOffset is a temporal interval in the form: Where [ ] means an optional parameter and \\# means a numeric value. So, to declare that the VoiceCall facts should be expired after 1 hour and 35 minutes after they are inserted into the working memory, the user would write: Example 120. declaring the expiration offset for the VoiceCall events The @expires policy will take precedence and override the implicit expiration offset calculated from temporal constraints and sliding windows in the knowledge base. Facts that implement support for property changes as defined in the Javabean(tm) spec, now can be annotated so that the engine register itself to listen for changes on fact properties.\n\n The boolean parameter that was used in the insert() method in the Drools 4 API is deprecated and does not exist in the drools-api module. Make this type property reactive.\n\n See Fine grained property change listeners section for details. As noted before, Drools also supports annotations in type attributes.\n\n Here is a list of predefined attribute annotations. Declaring an attribute as a key attribute has 2 major effects on generated types:\n• The attribute will be used as a key identifier for the type, and as so, the generated class will implement the equals() and hashCode() methods taking the attribute into account when comparing instances of this type.\n• Drools will generate a constructor using all the key attributes as parameters. Example 122. example of @key declarations for a type For the previous example, Drools will generate equals() and hashCode() methods that will check the firstName and lastName attributes to determine if two instances of Person are equal to each other, but will not check the age attribute.\n\n It will also generate a constructor taking firstName and lastName as parameters, allowing one to create instances with a code like this: Example 123. creating an instance using the key constructor Positional arguments are ones where you don’t need to specify the field name, as the position maps to a known named field.\n\n i.e.\n\n Person( name == \"mark\" ) can be rewritten as Person( \"mark\"; ). The semicolon ';' is important so that the engine knows that everything before it is a positional argument.\n\n Otherwise we might assume it was a boolean expression, which is how it could be interpreted after the semicolon.\n\n You can mix positional and named arguments on a pattern by using the semicolon ';' to separate them.\n\n Any variables used in a positional that have not yet been bound will be bound to the field that maps to that position. The default order is the declared order, but this can be overridden using @position The @Position annotation, in the org.drools.definition.type package, can be used to annotate original pojos on the classpath.\n\n Currently only fields on classes can be annotated.\n\n Inheritance of classes is supported, but not interfaces of methods yet. Example patterns, with two constraints and a binding.\n\n Remember semicolon ';' is used to differentiate the positional section from the named argument section.\n\n Variables and literals and expressions using just literals are supported in positional arguments, but not variables. @Position is inherited when beans extend each other; while not recommended, two fields may have the same @position value, and not all consecutive values need be declared.\n\n If a @position is repeated, the conflict is solved using inheritance (fields in the superclass have the precedence) and the declaration order.\n\n If a @position value is missing, the first field without an explicit @position (if any) is selected to fill the gap.\n\n As always, conflicts are resolved by inheritance and declaration order. In the example, the field order would be : price (@position 0 in the superclass), year (@position 0 in the subclass), name (first field with no @position), shop (@position 2), country (second field without @position), origin. Drools allows the declaration of metadata attributes for existing types in the same way as when declaring metadata attributes for new fact types.\n\n The only difference is that there are no fields in that declaration. For instance, if there is a class org.drools.examples.Person, and one wants to declare metadata for it, it’s possible to write the following code: Example 124. Declaring metadata for an existing type Instead of using the import, it is also possible to reference the class by its fully qualified name, but since the class will also be referenced in the rules, it is usually shorter to add the import and use the short class name everywhere. Example 125. Declaring metadata using the fully qualified class name Example: for a declared type like the following: The compiler will implicitly generate 3 constructors: one without parameters, one with the @key fields, and one with all fields. @typesafe( <boolean>) has been added to type declarations.\n\n By default all type declarations are compiled with type safety enabled; @typesafe( false ) provides a means to override this behaviour by permitting a fall-back, to type unsafe evaluation where all constraints are generated as MVEL constraints and executed dynamically.\n\n This can be important when dealing with collections that do not have any generics or mixed type collections. Declared types are usually used inside rules files, while Java models are used when sharing the model between rules and applications.\n\n Although, sometimes, the application may need to access and handle facts from the declared types, especially when the application is wrapping the rules engine and providing higher level, domain specific user interfaces for rules management. In such cases, the generated classes can be handled as usual with the Java Reflection API, but, as we know, that usually requires a lot of work for small results.\n\n Therefore, Drools provides a simplified API for the most common fact handling the application may want to do. The first important thing to realize is that a declared fact will belong to the package where it was declared.\n\n So, for instance, in the example below, will belong to the package, and so the fully qualified name of the generated class will be . Example 126. Declaring a type in the org.drools.examples package Declared types, as discussed previously, are generated at knowledge base compilation time, i.e., the application will only have access to them at application run time.\n\n Therefore, these classes are not available for direct reference from the application. Drools then provides an interface through which users can handle declared types from the application code: .\n\n Through this interface, the user can instantiate, read and write fields in the declared fact types. Example 127. Handling declared fact types through the API // get a reference to a knowledge base with a declared type: KieBase kbase = ... // get the declared FactType FactType personType = kbase.getFactType( \"org.drools.examples\", \"Person\" ); // handle the type as necessary: // create instances: Object bob = personType.newInstance(); // set attributes values personType.set( bob, \"name\", \"Bob\" ); personType.set( bob, \"age\", 42 ); // insert fact into a session KieSession ksession = ... ksession.insert( bob ); ksession.fireAllRules(); // read attributes String name = personType.get( bob, \"name\" ); int age = personType.get( bob, \"age\" ); The API also includes other helpful methods, like setting all the attributes at once, reading values from a Map, or reading all attributes at once, into a Map. Although the API is similar to Java reflection (yet much simpler to use), it does not use reflection underneath, relying on much more performant accessors implemented with generated bytecode. In order to extend a type declared in Java by a DRL declared subtype, repeat the supertype in a declare statement without any fields. A rule specifies that when a particular set of conditions occur, specified in the Left Hand Side\n\n (LHS), then do what queryis specified as a list of actions in the Right Hand Side (RHS). A\n\n common question from users is \"Why use when instead of if?\" \"When\" was chosen over \"if\" because\n\n \"if\" is normally part of a procedural execution flow, where, at a specific point in time, a\n\n condition is to be checked. In contrast, \"when\" indicates that the condition evaluation is not tied to a specific evaluation\n\n sequence or point in time, but that it happens continually, at any time during the life time of\n\n the engine; whenever the condition is met, the actions are executed. A rule must have a name, unique within its rule package.\n\n If you define a rule twice in the same DRL it produces an error while loading.\n\n If you add a DRL that includes a rule name already in the package, it replaces the previous rule.\n\n If a rule name is to have spaces, then it will need to be enclosed in double quotes (it is best to\n\n always use double quotes). Attributes - described below - are optional.\n\n They are best written one per line. The LHS of the rule follows the keyword (ideally on a new line), similarly the RHS follows\n\n the keyword (again, ideally on a newline). The rule is terminated by the keyword .\n\n Rules cannot be nested. rule \"<name>\" <attribute>* when <conditional element>* then <action>* end rule \"Approve if not rejected\" salience -100 agenda-group \"approval\" when not Rejection() p : Policy(approved == false, policyState:status) exists Driver(age > 25) Process(status == policyState) then log(\"APPROVED: due to no objections.\"); p.setApproved(true); end Rule attributes provide a declarative way to influence the behavior of the rule.\n\n Some are quite simple, while others are part of complex subsystems such as ruleflow.\n\n To get the most from Drools you should make sure you have a proper understanding of each attribute. When a rule’s consequence modifies a fact it may cause the rule to activate again, causing an\n\n infinite loop. Setting no-loop to true will skip the creation of another Activation for the rule\n\n with the current set of facts. Ruleflow is a Drools feature that lets you exercise control over the firing of rules.\n\n Rules that are assembled by the same ruleflow-group identifier fire only when their group is active. Whenever a ruleflow-group becomes active or an agenda-group receives the focus, any rule within\n\n that group that has lock-on-active set to true will not be activated any more; irrespective of the\n\n origin of the update, the activation of a matching rule is discarded. This is a stronger version\n\n of , because the change could now be caused not only by the rule itself. It’s ideal for calculation rules where you have a number of rules that modify a fact and you don’t want any rule re-matching and firing again.\n\n Only when the ruleflow-group is no longer active or the agenda-group loses the focus those rules with lock-on-active set to true become eligible again for their activations to be placed onto the agenda. Each rule has an integer salience attribute which defaults to zero and can be negative or positive.\n\n Salience is a form of priority where rules with higher salience values are given higher priority when ordered in the Activation queue. Drools also supports dynamic salience where you can use an expression involving bound variables. rule \"Fire in rank order 1,2,..\" salience( -$rank ) when Element( $rank : rank,... ) then ... end Agenda groups allow the user to partition the Agenda providing more execution control.\n\n Only rules in the agenda group that has acquired the focus are allowed to fire. When a rule is activated where the value is true and the rule’s agenda group does not have focus yet, then it is given focus, allowing the rule to potentially fire. Rules that belong to the same activation-group, identified by this attribute’s string value, will only fire exclusively.\n\n More precisely, the first rule in an activation-group to fire will cancel all pending activations of all rules in the group, i.e., stop them from firing. Note: This used to be called Xor group, but technically it’s not quite an Xor.\n\n You may still hear people mention Xor group; just swap that term in your mind with activation-group. default value: as specified by the package The dialect species the language to be used for any code expressions in the LHS or the RHS code block.\n\n Currently two dialects are available, Java and MVEL.\n\n While the dialect can be specified at the package level, this attribute allows the package definition to be overridden for a rule. A rule can only activate if the current date and time is after date-effective attribute. A rule cannot activate if the current date and time is after the date-expires attribute. default value: no default value The duration dictates that the rule will fire after a specified duration, if it is still true. Rules now support both interval and cron based timers, which replace the now deprecated duration attribute. Interval (indicated by \"int:\") timers follow the semantics of java.util.Timer objects, with an initial delay and an optional repeat interval.\n\n Cron (indicated by \"cron:\") timers follow standard Unix cron expressions: rule \"Send SMS every 15 minutes\" timer (cron:* 0/15 * * * ?) when $a : Alarm( on == true ) then channels[ \"sms\" ].insert( new Sms( $a.mobileNumber, \"The alarm is still on\" ); end A rule controlled by a timer becomes active when it matches, and once for each individual match.\n\n Its consequence is executed repeatedly, according to the timer’s settings.\n\n This stops as soon as the condition doesn’t match any more. Consequences are executed even after control returns from a call to fireUntilHalt.\n\n Moreover, the Engine remains reactive to any changes made to the Working Memory.\n\n For instance, removing a fact that was involved in triggering the timer rule’s execution causes the repeated execution to terminate, or inserting a fact so that some rule matches will cause that rule to fire.\n\n But the Engine is not continually active, only after a rule fires, for whatever reason.\n\n Thus, reactions to an insertion done asynchronously will not happen until the next execution of a timer-controlled rule.\n\n Disposing a session puts an end to all timer activity. Conversely when the rule engine runs in passive mode (i.e.: using fireAllRules instead of fireUntilHalt) by default it doesn’t fire consequences of timed rules unless fireAllRules isn’t invoked again.\n\n However it is possible to change this default behavior by configuring the KieSession with a as shown in the following example. It is also possible to have a finer grained control on the timed rules that have to be automatically executed.\n\n To do this it is necessary to set a that allows to define a\n\n callback to filter those rules, as done in the next example. Example 135. Configuring a filter to choose which timed rules should be automatically executed For what regards interval timers it is also possible to define both the delay and interval as an\n\n expression instead of a fixed value. To do that it is necessary to use an expression timer\n\n (indicated by \"expr:\") as in the following example: Example 136. An Expression Timer Example The expressions, and in this case, can use any variable defined in the pattern matching part\n\n of the rule and can be any String that can be parsed in a time duration or any numeric value that\n\n will be internally converted in a long representing a duration expressed in milliseconds. Both interval and expression timers can have 3 optional parameters named \"start\", \"end\" and\n\n \"repeat-limit\". When one or more of these parameters are used the first part of the timer\n\n definition must be followed by a semicolon ';' and the parameters have to be separated by a comma\n\n ',' as in the following example: Example 137. An Interval Timer with a start and an end The value for start and end parameters can be a Date, a String representing a Date or a long, or\n\n more in general any Number, that will be transformed in a Java Date applying the following\n\n conversion: Conversely the repeat-limit can be only an integer and it defines the maximum number of\n\n repetitions allowed by the timer. If both the end and the repeat-limit parameters are set the\n\n timer will stop when the first of the two will be matched. The using of the start parameter implies the definition of a phase for the timer, where the\n\n beginning of the phase is given by the start itself plus the eventual delay. In other words in\n\n this case the timed rule will then be scheduled at times: for up to repeat-limit times and no later than the end timestamp (whichever first). For instance\n\n the rule having the following interval timer will be scheduled at the 30th second of every minute after the midnight of the 3-JAN-2010.\n\n This also means that if for example you turn the system on at midnight of the 3-FEB-2010 it won’t\n\n be scheduled immediately but will preserve the phase defined by the timer and so it will be\n\n scheduled for the first time 30 seconds after the midnight. If for some reason the system is paused (e.g. the session is serialized and then deserialized\n\n after a while) the rule will be scheduled only once to recover from missing activations\n\n (regardless of how many activations we missed) and subsequently it will be scheduled again in\n\n phase with the timer. Calendars are used to control when rules can fire. The Calendar API is modelled on\n\n Quartz: Calendars are registered with the : They can be used in conjunction with normal rules and rules including timers. The rule attribute\n\n \"calendars\" may contain one or more comma-separated calendar names written as string literals. Example 140. Using Calendars and Timers together rule \"weekdays are high priority\" calendars \"weekday\" timer (int:0 1h) when Alarm() then send( \"priority high - we have an alarm\" ); end rule \"weekend are low priority\" calendars \"weekend\" timer (int:0 4h) when Alarm() then send( \"priority low - we have an alarm\" ); end 8.8.3.1. What is the Left Hand Side? The Left Hand Side (LHS) is a common name for the conditional part of the rule.\n\n It consists of zero or more Conditional Elements.\n\n If the LHS is empty, it will be considered as a condition element that is always true and it will be activated once, when a new WorkingMemory session is created. rule \"no CEs\" when // empty then ... // actions (executed once) end // The above rule is internally rewritten as: rule \"eval(true)\" when eval( true ) then ... // actions (executed once) end Conditional elements work on one or more patterns (which are described below). The most common\n\n conditional element is \" . Therefore it is implicit when you have multiple patterns in the\n\n LHS of a rule that are not connected in any way: rule \"2 unconnected patterns\" when Pattern1() Pattern2() then ... // actions end // The above rule is internally rewritten as: rule \"2 and connected patterns\" when Pattern1() and Pattern2() then ... // actions end An “and” cannot have a leading declaration binding (unlike for example ). This is obvious,\n\n since a declaration can only reference a single fact at a time, and when the “and” is satisfied\n\n it matches both facts - so which fact would the declaration bind to? // Compile error $person : (Person( name == \"Romeo\" ) and Person( name == \"Juliet\")) A pattern element is the most important Conditional Element.\n\n It can potentially match on each fact that is inserted in the working memory. A pattern contains of zero or more constraints and has an optional pattern binding.\n\n The railroad diagram below shows the syntax for this. In its simplest form, with no constraints, a pattern matches against a fact of the given type.\n\n In the following case the type is , which means that the pattern will match against all objects in the Working Memory: The type need not be the actual class of some fact object.\n\n Patterns may refer to superclasses or even interfaces, thereby potentially matching facts from many different classes. Object() // matches all objects in the working memory Inside of the pattern parenthesis is where all the action happens: it defines the constraints for that pattern.\n\n For example, with a age related constraint: For backwards compatibility reasons it’s allowed to suffix patterns with the character.\n\n But it is not recommended to do that. For referring to the matched object, use a pattern binding variable such as . The prefixed dollar symbol ( ) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields, but it is not mandatory. A constraint is an expression that returns or .\n\n This example has a constraint that states 5 is smaller than\n\n 6: Person( 5 < 6 ) // just an example, as constraints like this would be useless in a real pattern In essence, it’s a Java expression with some enhancements (such as property access) and a few differences (such as semantics for ). Let’s take a deeper look. Any bean property can be used directly.\n\n A bean property is exposed using a standard Java bean getter: a method (or for a primitive boolean) which takes no arguments and return something.\n\n For example: the age property is written as in DRL instead of the getter : Person( age == 50 ) // this is the same as: Person( getAge() == 50 ) Drools uses the standard JDK class to do this mapping, so it follows the standard Java bean specification. We recommend using property access ( ) over using getters explicitly ( ) because of performance enhancements through field indexing. Property accessors must not change the state of the object in a way that may effect the rules.\n\n Remember that the rule engine effectively caches the results of its matching in between invocations to make it faster. public int getAge() { age++; // Do NOT do this return age; } public int getAge() { Date now = DateUtil.now(); // Do NOT do this return DateUtil.differenceInYears(now, birthday); } To solve this latter case, insert a fact that wraps the current date into working memory and update that fact between as needed. The following fallback applies: if the getter of a property cannot be found, the compiler will resort to using the property name as a method name and without arguments: Person( age == 50 ) // If Person.getAge() does not exists, this falls back to: Person( age() == 50 ) Person( address.houseNumber == 50 ) // this is the same as: Person( getAddress().getHouseNumber() == 50 ) In a stateful session, care should be taken when using nested accessors as the Working Memory is not aware of any of the nested values, and does not know when they change.\n\n Either consider them immutable while any of their parent references are inserted into the Working Memory.\n\n Or, instead, if you wish to modify a nested value you should mark all of the outer facts as updated.\n\n In the above example, when the changes, any with that must be marked as updated. You can use any Java expression that returns a as a constraint inside the parentheses of a pattern.\n\n Java expressions can be mixed with other expression enhancements, such as property access: It is possible to change the evaluation priority by using parentheses, as in any logic or mathematical expression: It is possible to reuse Java methods: As for property accessors, methods must not change the state of the object in a way that may affect the rules.\n\n Any method executed on a fact in the LHS should be a read\n\n only method. Person( incrementAndGetAge() == 10 ) // Do NOT do this The state of a fact should not change between rule invocations (unless those facts are marked as updated to the working memory on every change): Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this Normal Java operator precedence applies, see the operator precedence list below. All operators have normal Java semantics except for and . // Similar to: java.util.Objects.equals(person.getFirstName(), \"John\") // so (because \"John\" is not null) similar to: // \"John\".equals(person.getFirstName()) Person( firstName == \"John\" ) Type coercion is always attempted if the field and the value are of different types; exceptions will be thrown if a bad coercion is attempted.\n\n For instance, if \"ten\" is provided as a string in a numeric evaluator, an exception is thrown, whereas \"10\" would coerce to a numeric 10.\n\n Coercion is always in favor of the field type and not the value type: The comma character (‘`,`’) is used to separate constraint groups.\n\n It has implicit AND connective semantics. // Person is at least 50 and weighs at least 80 kg Person( age > 50, weight > 80 ) // Person is at least 50, weighs at least 80 kg and is taller than 2 meter. Person( age > 50, weight > 80, height > 2 ) Although the and operators have the same semantics, they are resolved with different priorities: The operator precedes the operator.\n\n Both the and operator precede the operator.\n\n See the operator precedence list below. The comma operator should be preferred at the top level constraint, as it makes constraints easier to read and the engine will often be able to optimize them better. The comma ( ) operator cannot be embedded in a composite constraint expression, such as parentheses: Person( ( age > 50, weight > 80 ) || height > 2 ) // Do NOT do this: compile error // Use this instead Person( ( age > 50 && weight > 80 ) || height > 2 ) A property can be bound to a variable: // 2 persons of the same age Person( $firstAge : age ) // binding Person( age == $firstAge ) // constraint expression The prefixed dollar symbol ( ) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields. For backwards compatibility reasons, It’s allowed (but not recommended) to mix a constraint binding and constraint expressions as such: Bound variable restrictions using the operator provide for very fast execution as it use hash indexing to improve performance. Drools does not allow bindings to the same declaration.\n\n However this is an important aspect to derivation query unification.\n\n While positional arguments are always processed with unification a special unification symbol, ':=', was introduced for named arguments named arguments.\n\n The following \"unifies\" the age argument across two people. In essence unification will declare a binding for the first occurrence and constrain to the same value of the bound field for sequence occurrences. Often it happens that it is necessary to access multiple properties of a nested object as in the following example These accessors to nested objects can be grouped with a '.(…​)' syntax providing more readable rules as in Note the '.' prefix, this is necessary to differentiate the nested object constraints from a method call. When dealing with nested objects, it also quite common the need to cast to a subtype.\n\n It is possible to do that via the # symbol as in: This example casts Address to LongAddress, making its getters available.\n\n If the cast is not possible (instanceof returns false), the evaluation will be considered false.\n\n Also fully qualified names are supported: It is possible to use multiple inline casts in the same expression: moreover, since we also support the instanceof operator, if that is used we will infer its results for further uses of that field, within that pattern: Besides normal Java literals (including Java 5 enums), this literal is also supported: The date format is supported by default.\n\n You can customize this by providing an alternative date format mask as the System property named .\n\n If more control is required, use a restriction. It’s possible to directly access a value by index: It’s also possible to directly access a value by key: This allows you to place more than one restriction on a field using the restriction connectives or .\n\n Grouping via parentheses is permitted, resulting in a recursive syntax pattern. Coercion to the correct value for the evaluator and the field will be attempted. These operators can be used on properties with natural ordering.\n\n For example, for Date fields, means before, for fields, it means alphabetically lower. The !. operator allows to derefencing in a null-safe way.\n\n More in details the matching algorithm requires the value to the left of the !. operator to be not null in order to give a positive result for pattern matching itself.\n\n In other words the pattern: will be internally translated in: Matches a field against any valid Java\n\n \n\n Regular Expression.\n\n Typically that regexp is a string literal, but variables that resolve to a valid regexp are also allowed. Like in Java, regular expressions written as string literals need to escape '\\\\'. Only applies on properties.\n\n Using against a value always evaluates to false. The operator returns true if the String does not match the regular expression.\n\n The same rules apply as for the operator.\n\n Example: Only applies on properties.\n\n Using against a value always evaluates to true. The operator is used to check whether a field that is a\n\n \n\n Collection or elements contains the specified value. Example 147. Contains with Collections CheeseCounter( cheeses contains \"stilton\" ) // contains with a String literal CheeseCounter( cheeses contains $var ) // contains with a variable The operator can also be used in place of constraints checks. Example 148. Contains with String literals Cheese( name contains \"tilto\" ) Person( fullName contains \"Jr\" ) String( this contains \"foo\" ) The operator is used to check whether a field that is a\n\n \n\n Collection or elements does not contain the specified value. CheeseCounter( cheeses not contains \"cheddar\" ) // not contains with a String literal CheeseCounter( cheeses not contains $var ) // not contains with a variable For backward compatibility, the operator is supported as a synonym for . The operator can also be used in place of the logical negation of for constraints checks - i.e.: Example 150. Contains with String literals Cheese( name not contains \"tilto\" ) Person( fullName not contains \"Jr\" ) String( this not contains \"foo\" ) The operator is used to check whether a field is a member of a collection or elements; that collection must be a variable. The operator is used to check whether a field is not a member of a collection or elements; that collection must be a variable. This operator is similar to , but it checks whether a word has almost the same sound (using English pronunciation) as the given value.\n\n This is based on the Soundex algorithm (see ). This operator is used to check whether a field that is a starts with or ends with a certain value.\n\n It can also be used to check the length of the String. The operators and (compound value restriction) The compound value restriction is used where there is more than one possible value to match.\n\n Currently only the and evaluators support this.\n\n The second operand of this operator must be a comma-separated list of values, enclosed in parentheses.\n\n Values may be given as variables, literals, return values or qualified identifiers.\n\n Both evaluators are actually syntactic\n\n sugar, internally rewritten as a list of multiple restrictions using the operators and . Example 154. Compound Restriction using \"in\" An\n\n \n\n inline eval constraint can use any valid dialect expression as long as it results to a primitive boolean.\n\n The expression must be constant over time.\n\n Any previously bound variable, from the current or previous pattern, can be used; autovivification is also used to auto-create field binding variables.\n\n When an identifier is found that is not a current variable, the builder looks to see if the identifier is a field on the current object type, if it is, the field binding is auto-created as a variable of the same name.\n\n This is called autovivification of field variables inside of inline eval’s. This example will find all male-female pairs where the male is 2 years older than the female; the variable is auto-created in the second pattern by the autovivification process. Person( girlAge : age, sex = \"F\" ) Person( eval( age == girlAge + 2 ), sex = 'M' ) // eval() is actually obsolete in this example Inline eval’s are effectively obsolete as their inner syntax is now directly supported.\n\n It’s recommended not to use them.\n\n Simply write the expression without wrapping eval() around it. The operators are evaluated in this precedence: Does not use normal Java (not)\n\n same semantics: uses\n\n (not) equals\n\n semantics instead. Positional arguments are ones where you don’t need to specify the field name, as the position maps to a known named field.\n\n i.e.\n\n Person( name == \"mark\" ) can be rewritten as Person( \"mark\"; ). The semicolon ';' is important so that the engine knows that everything before it is a positional argument.\n\n Otherwise we might assume it was a boolean expression, which is how it could be interpreted after the semicolon.\n\n You can mix positional and named arguments on a pattern by using the semicolon ';' to separate them.\n\n Any variables used in a positional that have not yet been bound will be bound to the field that maps to that position. Example patterns, with two constraints and a binding.\n\n Remember semicolon ';' is used to differentiate the positional section from the named argument section.\n\n Variables and literals and expressions using just literals are supported in positional arguments, but not variables.\n\n Positional arguments are always resolved using unification. Positional arguments that are given a previously declared binding will constrain against that using unification; these are referred to as input arguments.\n\n If the binding does not yet exist, it will create the declaration binding it to the field represented by the position argument; these are referred to as output arguments. When you call modify() (see the modify statement section) on a given object it will trigger a revaluation of all patterns of the matching object type in the knowledge base.\n\n This can can lead to unwanted and useless evaluations and in the worst cases to infinite recursions.\n\n The only workaround to avoid it was to split up your objects into smaller ones having a 1 to 1 relationship with the original object. This feature allows the pattern matching to only react to modification of properties actually constrained or bound inside of a given pattern.\n\n That will help with performance and recursion and avoid artificial object splitting. By default this feature is off in order to make the behavior of the rule engine backward compatible with the former releases.\n\n When you want to activate it on a specific bean you have to annotate it with @propertyReactive.\n\n This annotation works both on DRL type declarations: In this way, for instance, if you have a rule like the following: rule \"Every person named Mario is a male\" when $person : Person( firstName == \"Mario\" ) then modify ( $person ) { setMale( true ) } end you won’t have to add the no-loop attribute to it in order to avoid an infinite recursion because the engine recognizes that the pattern matching is done on the 'firstName' property while the RHS of the rule modifies the 'male' one.\n\n Note that this feature does not work for update(), and this is one of the reasons why we promote modify() since it encapsulates the field changes within the statement.\n\n Moreover, on Java classes, you can also annotate any method to say that its invocation actually modifies other properties.\n\n For instance in the former Person class you could have a method like: That means that if a rule has a RHS like the following: it will correctly recognize that the values of both properties 'firstName' and 'lastName' could have potentially been modified and act accordingly, not missing of reevaluating the patterns constrained on them.\n\n At the moment the usage of @Modifies is not allowed on fields but only on methods.\n\n This is coherent with the most common scenario where the @Modifies will be used for methods that are not related with a class field as in the Person.setName() in the former example.\n\n Also note that @Modifies is not transitive, meaning that if another method internally invokes the Person.setName() one it won’t be enough to annotate it with @Modifies( { \"name\" } ), but it is necessary to use @Modifies( { \"firstName\", \"lastName\" } ) even on it.\n\n Very likely @Modifies transitivity will be implemented in the next release. For what regards nested accessors, the engine will be notified only for top level fields.\n\n In other words a pattern matching like: will be revaluated only for modification of the 'address' property of a Person object.\n\n In the same way the constraints analysis is currently strictly limited to what there is inside a pattern.\n\n Another example could help to clarify this.\n\n An LHS like the following: will not listen on modifications of the person’s name, while this one will do: Person( $name : name ) Car( owner = $name ) To overcome this problem it is possible to annotate a pattern with @watch as it follows: Indeed, annotating a pattern with @watch allows you to modify the inferred set of properties for which that pattern will react.\n\n Note that the properties named in the @watch annotation are actually added to the ones automatically inferred, but it is also possible to explicitly exclude one or more of them prepending their name with a ! and to make the pattern to listen for all or none of the properties of the type used in the pattern respectively with the wildcrds * and !*. So, for example, you can annotate a pattern in the LHS of a rule like: // listens for changes on both firstName (inferred) and lastName Person( firstName == $expectedFirstName ) @watch( lastName ) // listens for all the properties of the Person bean Person( firstName == $expectedFirstName ) @watch( * ) // listens for changes on lastName and explicitly exclude firstName Person( firstName == $expectedFirstName ) @watch( lastName, !firstName ) // listens for changes on all the properties except the age one Person( firstName == $expectedFirstName ) @watch( *, !age ) Since doesn’t make sense to use this annotation on a pattern using a type not annotated with @PropertyReactive the rule compiler will raise a compilation error if you try to do so.\n\n Also the duplicated usage of the same property in @watch (for example like in: @watch( firstName, ! firstName ) ) will end up in a compilation error.\n\n In a next release we will make the automatic detection of the properties to be listened smarter by doing analysis even outside of the pattern. It also possible to enable this feature by default on all the types of your model or to completely disallow it by using on option of the KnowledgeBuilderConfiguration.\n\n In particular this new PropertySpecificOption can have one of the following 3 values: - DISABLED => the feature is turned off and all the other related annotations are just ignored - ALLOWED => this is the default behavior: types are not property reactive unless they are not annotated with @PropertySpecific - ALWAYS => all types are property reactive by default So, for example, to have a KnowledgeBuilder generating property reactive types by default you could do: In this last case it will be possible to disable the property reactivity feature on a specific type by annotating it with @ClassReactive. The Conditional Element is used to group other Conditional Elements into a logical conjunction.\n\n Drools supports both prefix and infix . Explicit grouping with parentheses is also supported: //infixAnd with grouping ( Cheese( cheeseType : type ) and ( Person( favouriteCheese == cheeseType ) or Person( favouriteCheese == cheeseType ) ) The symbol (as an alternative to ) is deprecated.\n\n But it is still supported in the syntax for backwards compatibility. The root element of the LHS is an implicit prefix and doesn’t need to be specified: The Conditional Element is used to group other Conditional Elements into a logical disjunction.\n\n Drools supports both prefix and infix . Explicit grouping with parentheses is also supported: //infixOr with grouping ( Cheese( cheeseType : type ) or ( Person( favouriteCheese == cheeseType ) and Person( favouriteCheese == cheeseType ) ) The symbol (as an alternative to ) is deprecated.\n\n But it is still supported in the syntax for backwards compatibility. The behavior of the Conditional Element is different from the connective for constraints and restrictions in field constraints.\n\n The engine actually has no understanding of the Conditional Element .\n\n Instead, via a number of different logic transformations, a rule with is rewritten as a number of subrules.\n\n This process ultimately results in a rule that has a single as the root node and one subrule for each of its CEs.\n\n Each subrule can activate and fire like any normal rule; there is no special behavior or interaction between these subrules.\n\n - This can be most confusing to new rule authors. The Conditional Element also allows for optional pattern binding.\n\n This means that each resulting subrule will bind its pattern to the pattern binding.\n\n Each pattern must be bound separately, using eponymous variables: Since the conditional element results in multiple subrule generation, one for each possible logically outcome, the example above would result in the internal generation of two rules.\n\n These two rules work independently within the Working Memory, which means both can match, activate and fire - there is no shortcutting. The best way to think of the conditional element is as a shortcut for generating two or more similar rules.\n\n When you think of it that way, it’s clear that for a single rule there could be multiple activations if two or more terms of the disjunction are true. The CE is first order logic’s non-existential quantifier and checks for the non-existence of something in the Working Memory.\n\n Think of \"not\" as meaning \"there must be none of…​\". The keyword may be followed by parentheses around the CEs that it applies to.\n\n In the simplest case of a single pattern (like below) you may optionally omit the parentheses. // Brackets are optional: not Bus(color == \"red\") // Brackets are optional: not ( Bus(color == \"red\", number == 42) ) // \"not\" with nested infix and - two patterns, // brackets are requires: not ( Bus(color == \"red\") and Bus(color == \"blue\") ) The CE is first order logic’s existential quantifier and checks for the existence of something in the Working Memory.\n\n Think of \"exists\" as meaning \"there is at least one..\". It is different from just having the pattern on its own, which is more like saying \"for each one of…​\". If you use with a pattern, the rule will only activate at most once, regardless of how much data there is in working memory that matches the condition inside of the pattern.\n\n Since only the existence matters, no bindings will be established. The keyword must be followed by parentheses around the CEs that it applies to.\n\n In the simplest case of a single pattern (like below) you may omit the parentheses. Example 159. At least one Bus Example 160. At least one red Bus exists Bus(color == \"red\") // brackets are optional: exists ( Bus(color == \"red\", number == 42) ) // \"exists\" with nested infix and, // brackets are required: exists ( Bus(color == \"red\") and Bus(color == \"blue\") ) The Conditional Element completes the First Order Logic support in Drools.\n\n The Conditional Element evaluates to true when all facts that match the first pattern match all the remaining patterns.\n\n Example: rule \"All English buses are red\" when forall( $bus : Bus( type == 'english') Bus( this == $bus, color = 'red' ) ) then // all English buses are red end In the above rule, we \"select\" all Bus objects whose type is \"english\". Then, for each fact that matches this pattern we evaluate the following patterns and if they match, the forall CE will evaluate to true. To state that all facts of a given type in the working memory must match a set of constraints, can be written with a single pattern for simplicity.\n\n Example: rule \"All Buses are Red\" when forall( Bus( color == 'red' ) ) then // all Bus facts are red end Another example shows multiple patterns inside the : rule \"all employees have health and dental care programs\" when forall( $emp : Employee() HealthCare( employee == $emp ) DentalCare( employee == $emp ) ) then // all employees have health and dental care end Forall can be nested inside other CEs.\n\n For instance, can be used inside a CE.\n\n Note that only single patterns have optional parentheses, so that with a nested parentheses must be used: Example 163. Combining Forall with Not CE rule \"not all employees have health and dental care\" when not ( forall( $emp : Employee() HealthCare( employee == $emp ) DentalCare( employee == $emp ) ) ) then // not all employees have health and dental care end As a side note, is equivalent to writing: Also, it is important to note that is a scope delimiter.\n\n Therefore, it can use any previously bound variable, but no variable bound inside it will be available for use outside of it. The Conditional Element enables users to specify an arbitrary source for data to be matched by LHS patterns.\n\n This allows the engine to reason over data not in the Working Memory.\n\n The data source could be a sub-field on a bound variable or the results of a method call.\n\n It is a powerful construction that allows out of the box integration with other application components and frameworks.\n\n One common example is the integration with data retrieved on-demand from databases using hibernate named queries. The expression used to define the object source is any expression that follows regular MVEL syntax.\n\n Therefore, it allows you to easily use object property navigation, execute method calls and access maps and collections elements. Here is a simple example of reasoning and binding on another pattern sub-field: rule \"validate zipcode\" when Person( $personAddress : address ) Address( zipcode == \"23920W\") from $personAddress then // zip code is ok end With all the flexibility from the new expressiveness in the Drools engine you can slice and dice this problem many ways.\n\n This is the same but shows how you can use a graph notation with the 'from': rule \"validate zipcode\" when $p : Person( ) $a : Address( zipcode == \"23920W\") from $p.address then // zip code is ok end Previous examples were evaluations using a single pattern.\n\n The CE also support object sources that return a collection of objects.\n\n In that case, will iterate over all objects in the collection and try to match each of them individually.\n\n For instance, if we want a rule that applies 10% discount to each item in an order, we could do: rule \"apply 10% discount to all items over US$ 100,00 in an order\" when $order : Order() $item : OrderItem( value > 100 ) from $order.items then // apply discount to $item end The above example will cause the rule to fire once for each item whose value is greater than 100 for each given order. You must take caution, however, when using , especially in conjunction with the rule attribute as it may produce unexpected results.\n\n Consider the example provided earlier, but now slightly modified as follows: rule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $p : Person( ) $a : Address( state == \"NC\") from $p.address then modify ($p) {} // Assign person to sales region 1 in a modify block end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $p : Person( ) $a : Address( city == \"Raleigh\") from $p.address then modify ($p) {} // Apply discount to person in a modify block end In the above example, persons in Raleigh, NC should be assigned to sales region 1 and receive a discount; i.e., you would expect both rules to activate and fire.\n\n Instead you will find that only the second rule fires. If you were to turn on the audit log, you would also see that when the second rule fires, it deactivates the first rule.\n\n Since the rule attribute prevents a rule from creating new activations when a set of facts change, the first rule fails to reactivate.\n\n Though the set of facts have not changed, the use of returns a new fact for all intents and purposes each time it is evaluated. First, it’s important to review why you would use the above pattern.\n\n You may have many rules across different rule-flow groups.\n\n When rules modify working memory and other rules downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated, the use of is critical.\n\n You don’t, however, want other rules in the same rule-flow group to place activations on one another recursively.\n\n In this case, the attribute is ineffective, as it would only prevent a rule from activating itself recursively.\n\n Hence, you resort to . There are several ways to address this issue:\n• Avoid the use of when you can assert all facts into working memory or use nested object references in your constraint expressions (shown below).\n• Place the variable assigned used in the modify block as the last sentence in your condition (LHS).\n• Avoid the use of when you can explicitly manage how rules within the same rule-flow group place activations on one another (explained below). The preferred solution is to minimize use of when you can assert all your facts into working memory directly.\n\n In the example above, both the Person and Address instance can be asserted into working memory.\n\n In this case, because the graph is fairly simple, an even easier solution is to modify your rules as follows: rule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $p : Person(address.state == \"NC\" ) then modify ($p) {} // Assign person to sales region 1 in a modify block end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $p : Person(address.city == \"Raleigh\" ) then modify ($p) {} //Apply discount to person in a modify block end Now, you will find that both rules fire as expected.\n\n However, it is not always possible to access nested facts as above.\n\n Consider an example where a Person holds one or more Addresses and you wish to use an existential quantifier to match people with at least one address that meets certain conditions.\n\n In this case, you would have to resort to the use of to reason over the collection. There are several ways to use to achieve this and not all of them exhibit an issue with the use of .\n\n For example, the following use of causes both rules to fire as expected: rule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $p : Person($addresses : addresses) exists (Address(state == \"NC\") from $addresses) then modify ($p) {} // Assign person to sales region 1 in a modify block end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $p : Person($addresses : addresses) exists (Address(city == \"Raleigh\") from $addresses) then modify ($p) {} // Apply discount to person in a modify block end However, the following slightly different approach does exhibit the problem: rule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $assessment : Assessment() $p : Person() $addresses : List() from $p.addresses exists (Address( state == \"NC\") from $addresses) then modify ($assessment) {} // Modify assessment in a modify block end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $assessment : Assessment() $p : Person() $addresses : List() from $p.addresses exists (Address( city == \"Raleigh\") from $addresses) then modify ($assessment) {} // Modify assessment in a modify block end In the above example, the $addresses variable is returned from the use of .\n\n The example also introduces a new object, assessment, to highlight one possible solution in this case.\n\n If the $assessment variable assigned in the condition (LHS) is moved to the last condition in each rule, both rules fire as expected. Though the above examples demonstrate how to combine the use of with where no loss of rule activations occurs, they carry the drawback of placing a dependency on the order of conditions on the LHS.\n\n In addition, the solutions present greater complexity for the rule author in terms of keeping track of which conditions may create issues. A better alternative is to assert more facts into working memory.\n\n In this case, a person’s addresses may be asserted into working memory and the use of would not be necessary. There are cases, however, where asserting all data into working memory is not practical and we need to find other solutions.\n\n Another option is to reevaluate the need for .\n\n An alternative to is to directly manage how rules within the same rule-flow group activate one another by including conditions in each rule that prevent rules from activating each other recursively when working memory is modified.\n\n For example, in the case above where a discount is applied to citizens of Raleigh, a condition may be added to the rule that checks whether the discount has already been applied.\n\n If so, the rule does not activate. The pattern containing a from clause cannot be followed by another pattern starting with a parenthesis as in the following example rule R when $l : List( ) String() from $l (String() or Number()) then end This is because in that case the DRL parser reads the from expression as \"from $l (String() or Number())\" and it is impossible to disambiguate this expression from a function call. The straightforward fix to this is wrapping also the from clause in parenthesis as it follows: rule R when $l : List( ) (String() from $l) (String() or Number()) then end The Conditional Element allows rules to reason over a collection of objects obtained from the given source or from the working memory.\n\n In First Oder Logic terms this is the cardinality quantifier.\n\n A simple example: import java.util.ArrayList rule \"Raise priority if system has more than 3 pending alarms\" when $system : System() $alarms : ArrayList( size >= 3 ) from collect( Alarm( system == $system, status == 'pending' ) ) then // Raise priority, because system $system has // 3 or more alarms pending. The pending alarms // are $alarms. end In the above example, the rule will look for all pending alarms in the working memory for each given system and group them in ArrayLists.\n\n If 3 or more alarms are found for a given system, the rule will fire. The result pattern of can be any concrete class that implements the interface and provides a default no-arg public constructor.\n\n This means that you can use Java collections like ArrayList, LinkedList, HashSet, etc., or your own class, as long as it implements the interface and provide a default no-arg public constructor. Both source and result patterns can be constrained as any other pattern. Variables bound before the CE are in the scope of both source and result patterns and therefore you can use them to constrain both your source and result patterns.\n\n But note that is a scope delimiter for bindings, so that any binding made inside of it is not available for use outside of it. Collect accepts nested CEs.\n\n The following example is a valid use of \"collect\": import java.util.LinkedList; rule \"Send a message to all mothers\" when $town : Town( name == 'Paris' ) $mothers : LinkedList() from collect( Person( gender == 'F', children > 0 ) from $town.getPeople() ) then // send a message to all mothers end The Conditional Element is a more flexible and powerful form of , in the sense that it can be used to do what does and also achieve results that the CE is not capable of achieving.\n\n Accumulate allows a rule to iterate over a collection of objects, executing custom actions for each of the elements, and at the end, it returns a result object. Accumulate supports both the use of pre-defined accumulate functions, or the use of inline custom code.\n\n Inline custom code should be avoided though, as it is harder for rule authors to maintain, and frequently leads to code duplication.\n\n Accumulate functions are easier to test and reuse. The Accumulate CE also supports multiple different syntaxes.\n\n The preferred syntax is the top level accumulate, as noted bellow, but all other syntaxes are supported for backward compatibility. The top level accumulate syntax is the most compact and flexible syntax.\n\n The simplified syntax is as follows: For instance, a rule to calculate the minimum, maximum and average temperature reading for a given sensor and that raises an alarm if the minimum temperature is under 20C degrees and the average is over 70C degrees could be written in the following way, using Accumulate: The DRL language defines “`acc`” as a synonym of “`accumulate`”. The author might prefer to use “`acc`” as a less verbose keyword or the full keyword “`accumulate`” for legibility. rule \"Raise alarm\" when $s : Sensor() accumulate( Reading( sensor == $s, $temp : temperature ); $min : min( $temp ), $max : max( $temp ), $avg : average( $temp ); $min < 20, $avg > 70 ) then // raise the alarm end In the above example, min, max and average are Accumulate Functions and will calculate the minimum, maximum and average temperature values over all the readings for each sensor. These common functions accept any expression as input.\n\n For instance, if someone wants to calculate the average profit on all items of an order, a rule could be written using the average function: rule \"Average profit\" when $order : Order() accumulate( OrderItem( order == $order, $cost : cost, $price : price ); $avgProfit : average( 1 - $cost / $price ) ) then // average profit for $order is $avgProfit end Accumulate Functions are all pluggable.\n\n That means that if needed, custom, domain specific functions can easily be added to the engine and rules can start to use them without any restrictions.\n\n To implement a new Accumulate Function all one needs to do is to create a Java class that implements the interface.\n\n As an example of an Accumulate Function implementation, the following is the implementation of the function: /** * An implementation of an accumulator capable of calculating average values */ public class AverageAccumulateFunction implements org.kie.api.runtime.rule.AccumulateFunction<AverageAccumulateFunction.AverageData> { public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { } public void writeExternal(ObjectOutput out) throws IOException { } public static class AverageData implements Externalizable { public int count = 0; public double total = 0; public AverageData() {} public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { count = in.readInt(); total = in.readDouble(); } public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(count); out.writeDouble(total); } } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#createContext() */ public AverageData createContext() { return new AverageData(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#init(java.io.Serializable) */ public void init(AverageData context) { context.count = 0; context.total = 0; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#accumulate(java.io.Serializable, java.lang.Object) */ public void accumulate(AverageData context, Object value) { context.count++; context.total += ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#reverse(java.io.Serializable, java.lang.Object) */ public void reverse(AverageData context, Object value) { context.count--; context.total -= ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResult(java.io.Serializable) */ public Object getResult(AverageData context) { return new Double( context.count == 0 ? 0 : context.total / context.count ); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#supportsReverse() */ public boolean supportsReverse() { return true; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResultType() */ public Class< ? > getResultType() { return Number.class; } } The code for the function is very simple, as we could expect, as all the \"dirty\" integration work is done by the engine.\n\n Finally, to use the function in the rules, the author can import it using the \"import accumulate\" statement: For instance, if one implements the class function that implements the function and wants to use it in the rules, he would do the following: Example 164. Example of importing and using the custom “`variance`” accumulate function import accumulate some.package.VarianceFunction variance rule \"Calculate Variance\" when accumulate( Test( $s : score ), $v : variance( $s ) ) then // the variance of the test scores is $v end The built in functions (sum, average, etc) are imported automatically by the engine.\n\n Only user-defined custom accumulate functions need to be explicitly imported. For backward compatibility, Drools still supports the configuration of accumulate functions through configuration files and system properties, but this is a deprecated method.\n\n In order to configure the variance function from the previous example using the configuration file or system property, the user would set a property like this: Please note that \" \" is a prefix that must always be used,\n\n \" \" is how the function will be used in the drl files, and\n\n \" \" is the fully qualified name of the class that implements the\n\n function behavior. The accumulate syntax evolved over time with the goal of becoming more compact and expressive.\n\n Nevertheless, Drools still supports previous syntaxes for backward compatibility purposes. In case the rule is using a single accumulate function on a given accumulate, the author may add a pattern for the result object and use the \"from\" keyword to link it to the accumulate result.\n\n Example: a rule to apply a 10% discount on orders over $100 could be written in the following way: rule \"Apply 10% discount to orders over US$ 100,00\" when $order : Order() $total : Number( doubleValue > 100 ) from accumulate( OrderItem( order == $order, $value : value ), sum( $value ) ) then // apply discount to $order end In the above example, the accumulate element is using only one function (sum), and so, the rules author opted to explicitly write a pattern for the result type of the accumulate function (Number) and write the constraints inside it.\n\n There are no problems in using this syntax over the compact syntax presented before, except that is is a bit more verbose.\n\n Also note that it is not allowed to use both the return type and the functions binding in the same accumulate statement. Compile-time checks are performed in order to ensure the pattern used with the \" \" keyword is assignable from the result of the accumulate function used. With this syntax, the \" \" binds to the single result returned by the accumulate function, and it does not iterate. In the above example, \" \" is bound to the result returned by the accumulate sum() function. As another example however, if the result of the accumulate function is a collection, \" \" still binds to the single result and it does not iterate: rule \"Person names\" when $x : Object() from accumulate(MyPerson( $val : name ); collectList( $val ) ) then // $x is a List end The binded \" \" is the List itself, returned by the collectList accumulate function used. This is an important distinction to highlight, as the \" \" keyword can also be used separately of accumulate, to iterate over the elements of a collection: rule \"Iterate the numbers\" when $xs : List() $x : Integer() from $xs then // $x matches and binds to each Integer in the collection end While this syntax is still supported for backward compatibility purposes, for this and other reasons we encourage rule authors to make use instead of the Accumulate CE preferred syntax (described in the previous chapter), so to avoid any potential pitfalls, as described by these examples. The use of accumulate with inline custom code is not a good practice for several reasons, including difficulties on maintaining and testing rules that use them, as well as the inability of reusing that code.\n\n Implementing your own accumulate functions is very simple and straightforward, they are easy to unit test and to use.\n\n This form of accumulate is supported for backward compatibility only. Another possible syntax for the accumulate is to define inline custom code, instead of using accumulate functions.\n\n As noted on the previous warned, this is discouraged though for the stated reasons. The general syntax of the CE with inline custom code is: The meaning of each of the elements is the following:\n• <source pattern>: the source pattern is a regular pattern that the engine will try to match against each of the source objects.\n• <init code>: this is a semantic block of code in the selected dialect that will be executed once for each tuple, before iterating over the source objects.\n• <action code>: this is a semantic block of code in the selected dialect that will be executed for each of the source objects.\n• <reverse code>: this is an optional semantic block of code in the selected dialect that if present will be executed for each source object that no longer matches the source pattern. The objective of this code block is to undo any calculation done in the <action code> block, so that the engine can do decremental calculation when a source object is modified or deleted, hugely improving performance of these operations.\n• <result expression>: this is a semantic expression in the selected dialect that is executed after all source objects are iterated.\n• <result pattern>: this is a regular pattern that the engine tries to match against the object returned from the <result expression>. If it matches, the conditional element evaluates to true and the engine proceeds with the evaluation of the next CE in the rule. If it does not matches, the CE evaluates to false and the engine stops evaluating CEs for that rule. It is easier to understand if we look at an example: rule \"Apply 10% discount to orders over US$ 100,00\" when $order : Order() $total : Number( doubleValue > 100 ) from accumulate( OrderItem( order == $order, $value : value ), init( double total = 0; ), action( total += $value; ), reverse( total -= $value; ), result( total ) ) then // apply discount to $order end In the above example, for each in the Working Memory, the engine will execute the init\n\n code initializing the total variable to zero.\n\n Then it will iterate over all objects for that order, executing the action for each one (in the example, it will sum the value of all items into the total variable). After iterating over all objects, it will return the value corresponding to the result\n\n expression (in the above example, the value of variable ). Finally, the engine will try to match the result with the pattern, and if the double value is greater than 100, the rule will fire. The example used Java as the semantic dialect, and as such, note that the usage of the semicolon as statement delimiter is mandatory in the init, action and reverse code blocks.\n\n The result is an expression and, as such, it does not admit ';'. If the user uses any other dialect, he must comply to that dialect’s specific syntax. As mentioned before, the reverse code is optional, but it is strongly recommended that the user writes it in order to benefit from the improved performance on update\n\n and delete. The CE can be used to execute any action on source objects.\n\n The following example instantiates and populates a custom object: rule \"Accumulate using custom objects\" when $person : Person( $likes : likes ) $cheesery : Cheesery( totalAmount > 100 ) from accumulate( $cheese : Cheese( type == $likes ), init( Cheesery cheesery = new Cheesery(); ), action( cheesery.addCheese( $cheese ); ), reverse( cheesery.removeCheese( $cheese ); ), result( cheesery ) ); then // do something end The conditional element is essentially a catch-all which allows any semantic code (that returns a primitive boolean) to be executed.\n\n This code can refer to variables that were bound in the LHS of the rule, and functions in the rule package.\n\n Overuse of eval reduces the declarativeness of your rules and can result in a poorly performing engine.\n\n While can be used anywhere in the patterns, the best practice is to add it as the last conditional element in the LHS of a rule. Evals cannot be indexed and thus are not as efficient as Field Constraints.\n\n However this makes them ideal for being used when functions return values that change over time, which is not allowed within Field Constraints. For folks who are familiar with Drools 2.x lineage, the old Drools parameter and condition tags are equivalent to binding a variable to an appropriate type, and then using it in an eval node. 8.8.4. The Right Hand Side (then) The Right Hand Side (RHS) is a common name for the consequence or action part of the rule; this part should contain a list of actions to be executed.\n\n It is bad practice to use imperative or conditional code in the RHS of a rule; as a rule should be atomic in nature - \"when this, then do this\", not \"when this, maybe do this\". The RHS part of a rule should also be kept small, thus keeping it declarative and readable.\n\n If you find you need imperative and/or conditional code in the RHS, then maybe you should be breaking that rule down into multiple rules.\n\n The main purpose of the RHS is to insert, delete or modify working memory data.\n\n To assist with that there are a few convenience methods you can use to modify working memory; without having to first reference a working memory instance. object,\n\n handle will tell the engine that an object has changed (one that has been bound to something on the LHS) and rules may need to be reconsidered. object can also be used; here the Knowledge Helper will look up the facthandle for you, via an identity check, for the passed object.\n\n (Note that if you provide Property Change Listeners to your Java beans that you are inserting into the engine, you can avoid the need to call when the object changes.). After a fact’s field values have changed you must call update before changing another fact, or you will cause problems with the indexing within the rule engine.\n\n The modify keyword avoids this problem. Something will place a new object of your creation into the Working Memory. Something is similar to insert, but the object will be automatically deleted when there are no more facts to support the truth of the currently firing rule. These convenience methods are basically macros that provide short cuts to the instance that lets you access your Working Memory from rules files.\n\n The predefined variable of type lets you call several other useful methods.\n\n (Refer to the interface documentation for more advanced operations).\n• The call terminates rule execution immediately. This is required for returning control to the point whence the current session was put to work with .\n• Methods , and can be called on as well, but due to their frequent use they can be called without the object reference.\n• sets the focus to the specified agenda group.\n• , called from a rule’s RHS, returns the name of the rule.\n• returns the Tuple that matches the currently executing rule, and delivers the corresponding Activation. (These calls are useful for logging and debugging purposes.) The full Knowledge Runtime API is exposed through another predefined variable, , of type .\n\n Its method delivers an object of type , which, in turn, provides access to a wealth of methods, many of which are quite useful for coding RHS logic.\n• The accessor returns a reference to this session’s , which in turn provides access to the various rule groups: activation groups, agenda groups, and rule flow groups. A fairly common paradigm is the activation of some agenda group, which could be done with the lengthy call:\n• To run a query, you call , whereupon you may process the results, as explained in section Query. Using or using is the proper method of running a query from a rule’s RHS, and the only supported way.\n• A set of methods dealing with event management lets you, among other things, add and remove event listeners for the Working Memory and the Agenda.\n• Method returns the object, the backbone of all the Knowledge in your system, and the originator of the current session.\n• You can manage globals with , and .\n• Method returns the runtime’s which works much like what you know as your operating system’s environment. This language extension provides a structured approach to fact updates.\n\n It combines the update operation with a number of setter calls to change the object’s fields.\n\n This is the syntax schema for the statement: The parenthesized <fact-expression> must yield a fact object reference.\n\n The expression list in the block should consist of setter calls for the given object, to be written without the usual object reference, which is automatically prepended by the compiler. The advantages in using the modify statment are particularly clear when used in conjuction with fine grained property change listeners.\n\n See the corresponding section for more details. Sometimes the constraint of having one single consequence for each rule can be somewhat limiting and leads to verbose and difficult to be maintained repetitions like in the following example: rule \"Give 10% discount to customers older than 60\" when $customer : Customer( age > 60 ) then modify($customer) { setDiscount( 0.1 ) }; end rule \"Give free parking to customers older than 60\" when $customer : Customer( age > 60 ) $car : Car ( owner == $customer ) then modify($car) { setFreeParking( true ) }; end It is already possible to partially overcome this problem by making the second rule extending the first one like in: rule \"Give 10% discount to customers older than 60\" when $customer : Customer( age > 60 ) then modify($customer) { setDiscount( 0.1 ) }; end rule \"Give free parking to customers older than 60\" extends \"Give 10% discount to customers older than 60\" when $car : Car ( owner == $customer ) then modify($car) { setFreeParking( true ) }; end Anyway this feature makes it possible to define more labelled consequences other than the default one in a single rule, so, for example, the 2 former rules can be compacted in only one like it follows: rule \"Give 10% discount and free parking to customers older than 60\" when $customer : Customer( age > 60 ) do[giveDiscount] $car : Car ( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount] modify($customer) { setDiscount( 0.1 ) }; end This last rule has 2 consequences, the usual default one, plus another one named \"giveDiscount\" that is activated, using the keyword do, as soon as a customer older than 60 is found in the knowledge base, regardless of the fact that he owns a car or not.\n\n The activation of a named consequence can be also guarded by an additional condition like in this further example: rule \"Give free parking to customers older than 60 and 10% discount to golden ones among them\" when $customer : Customer( age > 60 ) if ( type == \"Golden\" ) do[giveDiscount] $car : Car ( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount] modify($customer) { setDiscount( 0.1 ) }; end The condition in the if statement is always evaluated on the pattern immediately preceding it.\n\n In the end this last, a bit more complicated, example shows how it is possible to switch over different conditions using a nested if/else statement: rule \"Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones\" when $customer : Customer( age > 60 ) if ( type == \"Golden\" ) do[giveDiscount10] else if ( type == \"Silver\" ) break[giveDiscount5] $car : Car ( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount10] modify($customer) { setDiscount( 0.1 ) }; then[giveDiscount5] modify($customer) { setDiscount( 0.05 ) }; end Here the purpose is to give a 10% discount AND a free parking to Golden customers over 60, but only a 5% discount (without free parking) to the Silver ones.\n\n This result is achieved by activating the consequence named \"giveDiscount5\" using the keyword break instead of do.\n\n In fact do just schedules a consequence in the agenda, allowing the remaining part of the LHS to continue of being evaluated as per normal, while break also blocks any further pattern matching evaluation.\n\n Note, of course, that the activation of a named consequence not guarded by any condition with break doesn’t make sense (and generates a compile time error) since otherwise the LHS part following it would be never reachable. Drools attempts to preserve numbers in their primitive or object wrapper form, so a variable bound to an int primitive when used in a code block or expression will no longer need manual unboxing; unlike Drools 3.0 where all primitives were autoboxed, requiring manual unboxing.\n\n A variable bound to an object wrapper will remain as an object; the existing JDK 1.5 and JDK 5 rules to handle auto-boxing and unboxing apply in this case.\n\n When evaluating field constraints, the system attempts to coerce one of the values into a comparable format; so a primitive is comparable to an object wrapper. A query is a simple way to search the working memory for facts that match the stated conditions.\n\n Therefore, it contains only the structure of the LHS of a rule, so that you specify neither \"when\" nor \"then\". A query has an optional set of parameters, each of which can be optionally typed.\n\n If the type is not given, the type Object is assumed.\n\n The engine will attempt to coerce the values as needed.\n\n Query names are global to the KieBase; so do not add queries of the same name to different packages for the same RuleBase. To return the results use , where \"name\" is the query’s name.\n\n This returns a list of query results, which allow you to retrieve the objects that matched the query. The first example presents a simple query for all the people over the age of 30.\n\n The second one, using parameters, combines the age limit with a location. Example 166. Query People over the age of 30 query \"people over the age of 30\" person : Person( age > 30 ) end Example 167. Query People over the age of x, and who live in y query \"people over the age of x\" (int x, String y) person : Person( age > x, location == y ) end We iterate over the returned QueryResults using a standard \"for\" loop.\n\n Each element is a QueryResultsRow which we can use to access each of the columns in the tuple.\n\n These columns can be accessed by bound declaration name or index position. Example 168. Query People over the age of 30 QueryResults results = ksession.getQueryResults( \"people over the age of 30\" ); System.out.println( \"we have \" + results.size() + \" people over the age of 30\" ); System.out.println( \"These people are are over 30:\" ); for ( QueryResultsRow row : results ) { Person person = ( Person ) row.get( \"person\" ); System.out.println( person.getName() + \"\n\n\" ); } Support for positional syntax has been added for more compact code.\n\n By default the declared type order in the type declaration matches the argument position.\n\n But it possible to override these using the @position annotation.\n\n This allows patterns to be used with positional arguments, instead of the more verbose named arguments. The @Position annotation, in the org.drools.definition.type package, can be used to annotate original pojos on the classpath.\n\n Currently only fields on classes can be annotated.\n\n Inheritance of classes is supported, but not interfaces or methods.\n\n The isContainedIn query below demonstrates the use of positional arguments in a pattern; instead of Queries can now call other queries, this combined with optional query arguments provides derivation query style backward chaining.\n\n Positional and named syntax is supported for arguments.\n\n It is also possible to mix both positional and named, but positional must come first, separated by a semi colon.\n\n Literal expressions can be passed as query arguments, but at this stage you cannot mix expressions with variables.\n\n Here is an example of a query that calls another query.\n\n Note that 'z' here will always be an 'out' variable.\n\n The '?' symbol means the query is pull only, once the results are returned you will not receive further results as the underlying data changes. As previously mentioned you can use live \"open\" queries to reactively receive changes over time from the query results, as the underlying data it queries against changes.\n\n Notice the \"look\" rule calls the query without using '?'. query isContainedIn( String x, String y ) Location(x, y;) or ( Location(z, y;) and isContainedIn(x, z;) ) end rule look when Person( $l : likes ) isContainedIn( $l, 'office'; ) then insertLogical( $l 'is in the office' ); end Drools supports unification for derivation queries, in short this means that arguments are optional.\n\n It is possible to call queries from Java leaving arguments unspecified using the static field org.drools.core.runtime.rule.Variable.v - note you must use 'v' and not an alternative instance of Variable.\n\n These are referred to as 'out' arguments.\n\n Note that the query itself does not declare at compile time whether an argument is in or an out, this can be defined purely at runtime on each use.\n\n The following example will return all objects contained in the office. results = ksession.getQueryResults( \"isContainedIn\", new Object[] { Variable.v, \"office\" } ); l = new ArrayList<List<String>>(); for ( QueryResultsRow r : results ) { l.add( Arrays.asList( new String[] { (String) r.get( \"x\" ), (String) r.get( \"y\" ) } ) ); } The algorithm uses stacks to handle recursion, so the method stack will not blow up. It is also possible to use as input argument for a query both the field of a fact as in: query contains(String $s, String $c) $s := String( this.contains( $c ) ) end rule PersonNamesWithA when $p : Person() contains( $p.name, \"a\"; ) then end and more in general any kind of valid expression like in: The following is not yet supported: \n\n Domain Specific Languages (or DSLs) are a way of creating a rule language that is dedicated to your problem domain.\n\n A set of DSL definitions consists of transformations from DSL \"sentences\" to DRL constructs, which lets you use of all the underlying rule language and engine features.\n\n Given a DSL, you write rules in DSL rule (or DSLR) files, which will be translated into DRL files. DSL and DSLR files are plain text files, and you can use any text editor to create and modify them.\n\n But there are also DSL and DSLR editors, both in the IDE as well as in the web based BRMS, and you can use those as well, although they may not provide you with the full DSL functionality. 8.10.1. When to Use a DSL DSLs can serve as a layer of separation between rule authoring (and rule authors) and the technical intricacies resulting from the modelling of domain object and the rule engine’s native language and methods.\n\n If your rules need to be read and validated by domain experts (such as business analysts, for instance) who are not programmers, you should consider using a DSL; it hides implementation details and focuses on the rule logic proper.\n\n DSL sentences can also act as \"templates\" for conditional elements and consequence actions that are used repeatedly in your rules, possibly with minor variations.\n\n You may define DSL sentences as being mapped to these repeated phrases, with parameters providing a means for accommodating those variations. DSLs have no impact on the rule engine at runtime, they are just a compile time feature, requiring a special parser and transformer. The Drools DSL mechanism allows you to customise conditional expressions and consequence actions.\n\n A global substitution mechanism (\"keyword\") is also available. In the preceding example, indicates the scope of the expression, i.e., whether it is valid for the LHS or the RHS of a rule.\n\n The part after the bracketed keyword is the expression that you use in the rule; typically a natural language expression, but it doesn’t have to be.\n\n The part to the right of the equal sign (\"=\") is the mapping of the expression into the rule language.\n\n The form of this string depends on its destination, RHS or LHS.\n\n If it is for the LHS, then it ought to be a term according to the regular LHS syntax; if it is for the RHS then it might be a Java statement. Whenever the DSL parser matches a line from the rule file written in the DSL with an expression in the DSL definition, it performs three steps of string manipulation.\n\n First, it extracts the string values appearing where the expression contains variable names in braces (here: ). Then, the values obtained from these captures are then interpolated wherever that name, again enclosed in braces, occurs on the right hand side of the mapping.\n\n Finally, the interpolated string replaces whatever was matched by the entire expression in the line of the DSL rule file. Note that the expressions (i.e., the strings on the left hand side of the equal sign) are used as regular expressions in a pattern matching operation against a line of the DSL rule file, matching all or part of a line.\n\n This means you can use (for instance) a '?' to indicate that the preceding character is optional.\n\n One good reason to use this is to overcome variations in natural language phrases of your DSL.\n\n But, given that these expressions are regular expression patterns, this also means that all \"magic\" characters of Java’s pattern syntax have to be escaped with a preceding backslash ('\\'). It is important to note that the compiler transforms DSL rule files line by line.\n\n In the above example, all the text after \"Something is \" to the end of the line is captured as the replacement value for \"{colour}\", and this is used for interpolating the target string.\n\n This may not be exactly what you want.\n\n For instance, when you intend to merge different DSL expressions to generate a composite DRL pattern, you need to transform a DSLR line in several independent operations.\n\n The best way to achieve this is to ensure that the captures are surrounded by characteristic text - words or even single characters.\n\n As a result, the matching operation done by the parser plucks out a substring from somewhere within the line.\n\n In the example below, quotes are used as distinctive characters.\n\n Note that the characters that surround the capture are not included during interpolation, just the contents between them. As a rule of thumb, use quotes for textual data that a rule editor may want to enter.\n\n You can also enclose the capture with words to ensure that the text is correctly matched.\n\n Both is illustrated by the following example.\n\n Note that a single line such as Something is \"green\" and\n\n another solid thing is now correctly expanded. Example 169. Example with quotes It is a good idea to avoid punctuation (other than quotes or apostrophes) in your DSL expressions as much as possible.\n\n The main reason is that punctuation is easy to forget for rule authors using your DSL.\n\n Another reason is that parentheses, the period and the question mark are magic characters, requiring escaping in the DSL definition. In a DSL mapping, the braces \"{\" and \"}\" should only be used to enclose a variable definition or reference, resulting in a capture.\n\n If they should occur literally, either in the expression or within the replacement text on the right hand side, they must be escaped with a preceding backslash (\"\\\"): If braces \"{\" and \"}\" should appear in the replacement string of a DSL definition, escape them with a backslash ('\\'). # This is a comment to be ignored. [when]There is a person with name of \"{name}\"=Person(name==\"{name}\") [when]Person is at least {age} years old and lives in \"{location}\"= Person(age >= {age}, location==\"{location}\") [then]Log \"{message}\"=System.out.println(\"{message}\"); [when]And = and Given the above DSL examples, the following examples show the expansion of various DSLR snippets: There is a person with name of \"Kitty\" ==> Person(name=\"Kitty\") Person is at least 42 years old and lives in \"Atlanta\" ==> Person(age >= 42, location=\"Atlanta\") Log \"boo\" ==> System.out.println(\"boo\"); There is a person with name of \"Bob\" and Person is at least 30 years old and lives in \"Utah\" ==> Person(name=\"Bob\") and Person(age >= 30, location=\"Utah\") Don’t forget that if you are capturing plain text from a DSL rule line and want to use it as a string literal in the expansion, you must provide the quotes on the right hand side of the mapping. You can chain DSL expressions together on one line, as long as it is clear to the parser where one ends and the next one begins and where the text representing a parameter ends.\n\n (Otherwise you risk getting all the text until the end of the line as a parameter value.) The DSL expressions are tried, one after the other, according to their order in the DSL definition file.\n\n After any match, all remaining DSL expressions are investigated, too. The resulting DRL text may consist of more than one line.\n\n Line ends are in the replacement text are written as . A common requirement when writing rule conditions is to be able to add an arbitrary combination of constraints to a pattern.\n\n Given that a fact type may have many fields, having to provide an individual DSL statement for each combination would be plain folly. The DSL facility allows you to add constraints to a pattern by a simple convention: if your DSL expression starts with a hyphen (minus character, \"-\") it is assumed to be a field constraint and, consequently, is is added to the last pattern line preceding it. For an example, lets take look at class , with the following fields: type, price, age and country.\n\n We can express some LHS condition in normal DRL like the following The DSL definitions given below result in three DSL phrases which may be used to create any combination of constraint involving these fields. [when]There is a Cheese with=Cheese() [when]- age is less than {age}=age<{age} [when]- type is '{type}'=type=='{type}' [when]- country equal to '{country}'=country=='{country}' You can then write rules with conditions like the following: There is a Cheese with - age is less than 42 - type is 'stilton' The parser will pick up a line beginning with \"-\" and add it as a constraint to the preceding pattern, inserting a comma when it is required. For the preceding example, the resulting DRL is: Combining all numeric fields with all relational operators (according to the DSL expression \"age is less than…​\" in the preceding example) produces an unwieldy amount of DSL entries.\n\n But you can define DSL phrases for the various operators and even a generic expression that handles any field constraint, as shown below.\n\n (Notice that the expression definition contains a regular expression in addition to the variable name.) [when][]is less than or equal to=<= [when][]is less than=< [when][]is greater than or equal to=>= [when][]is greater than=> [when][]is equal to=== [when][]equals=== [when][]There is a Cheese with=Cheese() [when][]- {field:\\w*} {operator} {value:\\d*}={field} {operator} {value} Given these DSL definitions, you can write rules with conditions such as: There is a Cheese with - age is less than 42 - rating is greater than 50 - type equals 'stilton' In this specific case, a phrase such as \"is less than\" is replaced by , and then the line matches the last DSL entry.\n\n This removes the hyphen, but the final result is still added as a constraint to the preceding pattern.\n\n After processing all of the lines, the resulting DRL text is: The order of the entries in the DSL is important if separate DSL expressions are intended to match the same line, one after the other. A good way to get started is to write representative samples of the rules your application requires, and to test them as you develop.\n\n This will provide you with a stable framework of conditional elements and their constraints.\n\n Rules, both in DRL and in DSLR, refer to entities according to the data model representing the application data that should be subject to the reasoning process defined in rules.\n\n Notice that writing rules is generally easier if most of the data model’s types are facts. Given an initial set of rules, it should be possible to identify recurring or similar code snippets and to mark variable parts as parameters.\n\n This provides reliable leads as to what might be a handy DSL entry.\n\n Also, make sure you have a full grasp of the jargon the domain experts are using, and base your DSL phrases on this vocabulary. You may postpone implementation decisions concerning conditions and actions during this first design phase by leaving certain conditional elements and actions in their DRL form by prefixing a line with a greater sign (\">\"). (This is also handy for inserting debugging statements.) During the next development phase, you should find that the DSL configuration stabilizes pretty quickly.\n\n New rules can be written by reusing the existing DSL definitions, or by adding a parameter to an existing condition or consequence entry. Try to keep the number of DSL entries small.\n\n Using parameters lets you apply the same DSL sentence for similar rule patterns or constraints.\n\n But do not exaggerate: authors using the DSL should still be able to identify DSL phrases by some fixed text. A DSL file is a text file in a line-oriented format.\n\n Its entries are used for transforming a DSLR file into a file according to DRL syntax.\n• A line starting with \" \" or \"//\" (with or without preceding white space) is treated as a comment. A comment line starting with \" /\" is scanned for words requesting a debug option, see below.\n• Any line starting with an opening bracket (\"[\") is assumed to be the first line of a DSL entry definition.\n• Any other line is appended to the preceding DSL entry definition, with the line end replaced by a space. A DSL entry consists of the following four parts:\n• A scope definition, written as one of the keywords \"when\" or \"condition\", \"then\" or \"consequence\", \"*\" and \"keyword\", enclosed in brackets (\"[\" and \"]\"). This indicates whether the DSL entry is valid for the condition or the consequence of a rule, or both. A scope indication of \"keyword\" means that the entry has global significance, i.e., it is recognized anywhere in a DSLR file.\n• A type definition, written as a Java class name, enclosed in brackets. This part is optional unless the the next part begins with an opening bracket. An empty pair of brackets is valid, too.\n• A DSL expression consists of a (Java) regular expression, with any number of embedded variable definitions, terminated by an equal sign (\"=\"). A variable definition is enclosed in braces (\"{\" and \"}\"). It consists of a variable name and two optional attachments, separated by colons (\":\"). If there is one attachment, it is a regular expression for matching text that is to be assigned to the variable; if there are two attachments, the first one is a hint for the GUI editor and the second one the regular expression. Note that all characters that are \"magic\" in regular expressions must be escaped with a preceding backslash (\"\\\") if they should occur literally within the expression.\n• The remaining part of the line after the delimiting equal sign is the replacement text for any DSLR text matching the regular expression. It may contain variable references, i.e., a variable name enclosed in braces. Optionally, the variable name may be followed by an exclamation mark (\"!\") and a transformation function, see below. Note that braces (\"{\" and \"}\") must be escaped with a preceding backslash (\"\\\") if they should occur literally within the replacement string. Debugging of DSL expansion can be turned on, selectively, by using a comment line starting with \"#/\" which may contain one or more words from the table presented below.\n\n The resulting output is written to standard output. Prints each expansion step of condition and consequence\n\n lines. Dumps the internal representation of all DSL entries with\n\n scope \"keyword\". Dumps the internal representation of all DSL entries with\n\n scope \"when\" or \"*\". Dumps the internal representation of all DSL entries with\n\n scope \"then\" or \"*\". Below are some sample DSL definitions, with comments describing the language features they illustrate. # Comment: DSL examples #/ debug: display result and usage # keyword definition: replaces \"regula\" by \"rule\" [keyword][]regula=rule # conditional element: \"T\" or \"t\", \"a\" or \"an\", convert matched word [when][][Tt]here is an? {entity:\\w+}= ${entity!lc}: {entity!ucfirst} () # consequence statement: convert matched word, literal braces [then][]update {entity:\\w+}=modify( ${entity!lc} )\\{ \\} The transformation of a DSLR file proceeds as follows:\n• The text is read into memory.\n• Each of the \"keyword\" entries is applied to the entire text. First, the regular expression from the keyword definition is modified by replacing white space sequences with a pattern matching any number of white space characters, and by replacing variable definitions with a capture made from the regular expression provided with the definition, or with the default (\".*?\"). Then, the DSLR text is searched exhaustively for occurrences of strings matching the modified regular expression. Substrings of a matching string corresponding to variable captures are extracted and replace variable references in the corresponding replacement text, and this text replaces the matching string in the DSLR text.\n• Sections of the DSLR text between \"when\" and \"then\", and \"then\" and \"end\", respectively, are located and processed in a uniform manner, line by line, as described below. For a line, each DSL entry pertaining to the line’s section is taken in turn, in the order it appears in the DSL file.\n\n Its regular expression part is modified: white space is replaced by a pattern matching any number of white space characters; variable definitions with a regular expression are replaced by a capture with this regular expression, its default being \".*?\". If the resulting regular expression matches all or part of the line, the matched part is replaced by the suitably modified replacement text. Modification of the replacement text is done by replacing variable references with the text corresponding to the regular expression capture.\n\n This text may be modified according to the string transformation function given in the variable reference; see below for details. If there is a variable reference naming a variable that is not defined in the same entry, the expander substitutes a value bound to a variable of that name, provided it was defined in one of the preceding lines of the current rule.\n• If a DSLR line in a condition is written with a leading hyphen, the expanded result is inserted into the last line, which should contain a pattern CE, i.e., a type name followed by a pair of parentheses. if this pair is empty, the expanded line (which should contain a valid constraint) is simply inserted, otherwise a comma (\",\") is inserted beforehand. If a DSLR line in a consequence is written with a leading hyphen, the expanded result is inserted into the last line, which should contain a \"modify\" statement, ending in a pair of braces (\"{\" and \"}\"). If this pair is empty, the expanded line (which should contain a valid method call) is simply inserted, otherwise a comma (\",\") is inserted beforehand. It is currently not possible to use a line with a leading hyphen to insert text into other conditional element forms (e.g., \"accumulate\") or it may only work for the first insertion (e.g., \"eval\"). All string transformation functions are described in the following table. Converts the first letter to upper case, and\n\n all other letters to lower case. Extracts all digits and \"-\" from the string. If the\n\n last two digits in the original string are preceded by \".\" or\n\n \",\", a decimal period is inserted in the corresponding position. Compares the string with string a, and if they\n\n are equal, replaces it with b, otherwise with\n\n c. But c can be another triplet\n\n a, b, c, so\n\n that the entire structure is, in fact, a translation table. The following DSL examples show how to use string transformation functions. # definitions for conditions [when][]There is an? {entity}=${entity!lc}: {entity!ucfirst}() [when][]- with an? {attr} greater than {amount}={attr} <= {amount!num} [when][]- with a {what} {attr}={attr} {what!positive?>0/negative?%lt;0/zero?==0/ERROR} A file containing a DSL definition has to be put under the resources folder or any of its subfolders like any other drools artifact.\n\n It must have the extension , or alternatively be marked with type .\n\n when programmatically added to a .\n\n For a file using DSL definition, the extension should be used, while it can be added to a with type . For parsing and expanding a DSLR file the DSL configuration is read and supplied to the parser.\n\n Thus, the parser can \"recognize\" the DSL expressions and transform them into native rule language expressions.\n\nUse the from the workbench distribution zip that corrsponds to your application server.\n\n The differences between these files are mainly superficial.\n\n For example, some JARs might be excluded if the application server already supplies them.\n• Apache Tomcat requires additional configuration to correctly install the Workbench.\n\n Please consult the in the for the most up to date procedure.\n• Oracle WebLogic requires additional configuration to correctly install the Workbench.\n\n Please consult the in the for the most up to date procedure. The workbench stores its data, by default in the directory , for example , but it can be overridden with the system property . In production, make sure to back up the workbench data directory.\n• org.uberfire.nio.git.daemon.host: If git daemon enabled, uses this property as local host identifier. Default:\n• org.uberfire.nio.git.daemon.port: If git daemon enabled, uses this property as port number. Default:\n• org.uberfire.nio.git.ssh.host: If ssh daemon enabled, uses this property as local host identifier. Default:\n• org.uberfire.nio.git.ssh.port: If ssh daemon enabled, uses this property as port number. Default:\n• org.uberfire.nio.git.ssh.cert.dir: Location of the directory where local certificates will be stored. Default: working directory\n• org.uberfire.nio.git.ssh.passphrase: Passphrase to access your Operating Systems public keystore when cloning repositories with style URLs; e.g. .\n• If you plan to use RSA or any algorithm other than DSA, make sure you setup properly your Application Server to use Bouncy Castle JCE library.\n• org.uberfire.metadata.index.dir: Place where Lucene folder will be stored. Default: working directory\n• org.uberfire.cluster.id: Name of the helix cluster, for example:\n• org.uberfire.cluster.zk: Connection string to zookeeper. This is of the form , for example:\n• org.uberfire.cluster.local.id: Unique id of the helix cluster node, note that ‘`:`’ is replaced with ‘`\\_`’, for example:\n• org.uberfire.cluster.vfs.lock: Name of the resource defined on helix cluster, for example:\n• org.uberfire.cluster.autostart: Delays VFS clustering until the application is fully initialized to avoid conflicts when all cluster members create local clones. Default:\n• org.uberfire.sys.repo.monitor.disabled: Disable configuration monitor (do not disable unless you know what you’re doing). Default:\n• org.uberfire.domain: security-domain name used by uberfire. Default:\n• org.guvnor.m2repo.dir: Place where Maven repository folder will be stored. Default: working-directory/repositories/kie\n• org.kie.example.repositories: Folder from where demo repositories will be cloned. The demo repositories need to have been obtained and placed in this folder. Demo repositories can be obtained from the kie-wb-6.2.0-SNAPSHOT-example-repositories.zip artifact. This System Property takes precedence over org.kie.demo and org.kie.example. Default: Not used.\n• org.kie.demo: Enables external clone of a demo application from GitHub. This System Property takes precedence over org.kie.example. Default:\n• org.kie.example: Enables example structure composed by Repository, Organization Unit and Project. Default:\n• org.kie.verification.disable-dtable-realtime-verification: Disables the realtime validation and verification of decision tables. Default: To change one of these system properties in a WildFly or JBoss EAP cluster:\n• Locate the XML elements that belong to the and add a system property, for example: 19.1.4.1. Loading.. does not disappear and Workbench fails to show There have been reports that Firewalls in between the server and the browser can interfere with Server Sent Events (SSE) used by the Workbench. The issue results in the \"Loading…​\" spinner remaining visible and the Workbench failing to materialize. The workaround is to disable the Workbench’s use of Server Sent Events by adding file to the exploded WAR containing the value .\n\n Re-package the WAR and re-deploy. Some Users have also reported disabling Server Sent Events does not resolve the issue. The solution found to work is to configure the JVM to use a different Entropy Gathering Device on Linux for . This can be configured by setting System Property to . See this Stack Overflow post for details. Please note however this affects the JVM’s random number generation and may present other challenges where strong cryptography is required. Configure with caution. These steps help you get started with minimum of effort. They should not be a substitute for reading the documentation in full. The Authoring Perspective contains a menu item for 'Examples' clicking this launches a Wizard to guide you through the import. Page 1 of the Wizard allows the User to select a pre-defined examples repository, or enter their own URL. Page 2 of the Wizard lists Projects available in the source repository. Page 3 of the Wizard allows the User to enter a target Repository name and associate it with an Organizational Unit. Alternatively, to importing an example, a new empty repository can be created. Create a new repository to hold your project by selecting the Administration Perspective. Select the \"New repository\" option from the menu. Select the Authoring Perspective to create a new project. Select \"Project\" from the \"New Item\" menu.\n• Artifact ID is pre-populated from the project name.\n• Version is set as 1.0 by default. After a project has been created you need to define Types to be used by your rules. Select \"Data Object\" from the \"New Item\" menu. You can also use types contained in existing JARs. Please consult the full documentation for details. Set the name and select a package for the new type. Set field name and type and click on \"Create\" to create a field for the type. Select \"DRL file\" (for example) from the \"New Item\" menu. Figure 188. Selecting \"DRL file\" from the \"New Item\" menu Enter a file name for the new rule. The definition process differs from asset type to asset type. The full documentation has details about the different editors. Once the rule has been defined it will need to be saved. Once rules have been defined within a project; the project can be built and deployed to the Workbench’s Maven Artifact Repository. To build a project select the \"Project Editor\" from the \"Project\" menu. Click \"Build and Deploy\" to build the project and deploy it to the Workbench’s Maven Artifact Repository. When you select Build & Deploy the workbench will deploy to any repositories defined in the Dependency Management section of the pom in your workbench project.\n\n You can edit the pom.xml file associated with your workbench project under the Repository View of the project explorer.\n\n Details on dependency management in maven can be found here : http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html If there are errors during the build process they will be reported in the \"Problems Panel\". Now the project has been built and deployed; it can be referenced from your own projects as any other Maven Artifact. The full documentation contains details about integrating projects with your own applications. A workbench is structured with Organization Units, VFS repositories and projects: Organization units are useful to model departments and divisions. Repositories are the place where assets are stored and each repository is organized by projects and belongs to a single organization unit. Repositories are in fact a Virtual File System based storage, that by default uses GIT as backend.\n\n Such setup allows workbench to work with multiple backends and, in the same time, take full advantage of backend specifics features like in GIT case versioning, branching and even external access. A new repository can be created from scratch or cloned from an existing repository. One of the biggest advantage of using GIT as backend is the ability to clone a repository from external and use your preferred tools to edit and build your assets. Never clone your repositories directly from .niogit directory.\n\n Use always the available protocol(s) displayed in repositories editor. One additional advantage to use GIT as backend is the possibility to revert your repository to a previous state.\n\n You can do it directly from the repository editor by browsing its commit history and clicking the Revert button. The workbench authenticates its users against the application server’s authentication and authorization (JAAS). On JBoss EAP and WildFly, add a user with the script (or ): There is no need to restart the application server. The Workbench uses the following roles:\n• Has full access to make any changes necessary Developer can do almost everything admin can do, except clone repositories.\n• Can use the JBDS connection to view processes Analyst is a weaker version of developer and does not have access to the asset repository or the ability to deploy projects. Daily user of the system to take actions on business tasks that are required for the processes to continue forward.\n\n Works primarily with the task lists. Viewer of the system that is interested in statistics around the business processes and their performance, business indicators, and other reporting of the system and people who interact with the system.\n• Only has access to dashboards 19.5.1. Log in and log out Create a user with the role and log in with those credentials. After successfully logging in, the account username is displayed at the top right.\n\n Click on it to review the roles of the current account. After logging in, the home screen shows.\n\n The actual content of the home screen depends on the workbench variant (Drools, jBPM, …​). The Workbench is comprised of different logical entities:\n• A Part is a screen or editor with which the user can interact to perform operations. Example Parts are \"Project Explorer\", \"Project Editor\", \"Guided Rule Editor\" etc.\n\n Parts can be repositioned.\n• A Panel is a container for one or more Parts.\n• A perspective is a logical grouping of related Panels and Parts. The user can switch between perspectives by clicking on one of the top-level menu items; such as \"Home\", \"Authoring\", \"Deploy\" etc. The Workbench consists of three main sections to begin; however its layout and content can be changed. The initial Workbench shows the following components:-\n• This provides the ability for the user to browse their configuration; of Organizational Units (in the above \"example\" is the Organizational Unit), Repositories (in the above \"uf-playground\" is the Repository) and Project (in the above \"mortgages\" is the Project).\n• This provides the user will real-time feedback about errors in the active Project.\n• This empty space will contain an editor for assets selected from the Project Explorer. Other screens will also occupy this space by default; such as the Project Editor. The default layout may not be suitable for a user.\n\n Panels can therefore be either resized or repositioned. This, for example, could be useful when running tests; as the test defintion and rule can be repositioned side-by-side. The following screenshot shows a Panel being resized. Move the mouse pointer over the panel splitter (a grey horizontal or vertical line in between panels). The cursor will changing indicating it is positioned correctly over the splitter.\n\n Press and hold the left mouse button and drag the splitter to the required position; then release the left mouse button. The following screenshot shows a Panel being repositioned. Move the mouse pointer over the Panel title (\"Guided Editor [No bad credit checks]\" in this example). The cursor will change indicating it is positioned correctly over the Panel title.\n\n Press and hold the left mouse button.\n\n Drag the mouse to the required location.\n\n The target position is indicated with a pale blue rectangle.\n\n Different positions can be chosen by hovering the mouse pointer over the different blue arrows. Projects often need external artifacts in their classpath in order to build, for example a domain model JARs.\n\n The artifact repository holds those artifacts. The Artifact Repository is a full blown Maven repository.\n\n It follows the semantics of a Maven remote repository: all snapshots are timestamped.\n\n But it is often stored on the local hard drive. By default the artifact repository is stored under , but it can be overridden with the system property .\n\n There is only 1 Maven repository per installation. The Artifact Repository screen shows a list of the artifacts in the Maven repository: To add a new artifact to that Maven repository, either:\n• Use the upload button and select a JAR. If the JAR contains a POM file under (which every JAR build by Maven has), no further information is needed. Otherwise, a groupId, artifactId and version need be given too.\n• Using Maven, to that Maven repository. Refresh the list to make it show up. This remote Maven repository is relatively simple.\n\n It does not support proxying, mirroring, …​ like Nexus or Archiva. The Asset Editor is the principle component of the workbench User-Interface.\n\n It consists of two main views Editor and Overview.\n• \n• A : The editing area - exactly what form the editor takes depends on the Asset type. An asset can only be edited by one user at a time to avoid conflicts. When a user begins to edit an asset, a lock will automatically be acquired. This is indicated by a lock symbol appearing on the asset title bar as well as in the project explorer view (see Project Explorer for details). If a user starts editing an already locked asset a pop-up notification will appear to inform the user that the asset can’t currently be edited, as it is being worked on by another user. Changes will be prevented until the editing user saves or closes the asset, or logs out of the workbench. Session timeouts will also cause locks to be released. Every user further has the option to force a lock release, if required (see the Metadata section below).\n• B : This menu bar contains various actions for the Asset; such as Save, Rename, Copy etc. Note that saving, renaming and deleting are deactivated if the asset is locked by a different user.\n• C : Different views for asset content or asset information.\n• Editor shows the main editor for the asset\n• Overview contains the metadata and conversation views for this editor. Explained in more detail below.\n• Source shows the asset in plain DRL. Note: This tab is only visible if the asset content can be generated into DRL.\n• Data Objects contains the model available for authoring. By default only Data Objects that reside within the same package as the asset are available for authoring. Data Objects outside of this package can be imported to become available for authoring the asset.\n• \n• A : General information about the asset and the asset’s description. \"Type:\" The format name of the type of Asset. \"Used in projects:\" Names the projects where this rule is used. \"Last Modified:\" Who made the last change and when. \"Created on:\" Who created the asset and when.\n• B : Version history for the asset. Selecting a version loads the selected version into this editor.\n• C : Meta data (from the \"Dublin Core\" standard)\n• D : Comments regarding the development of the Asset can be recorded here.\n• \n• \"Note:\" A comment made when the Asset was last updated (i.e.\n\n why a change was made) \"URI:\" URI to the asset inside the Git repository. \"Subject/Type/External link/Source\" : Other miscellaneous meta data for the Asset. \"Lock status\" : Shows the lock status of the asset and, if locked, allows to force unlocking the asset.\n• The Workbench supports pessimistic locking of assets.\n\n When one User starts editing an asset it is locked to change by other Users.\n\n The lock is held until a period of inactivity lapses, the Editor is closed or the application stopped and restarted.\n\n Locks can also be forcibly removed on the MetaData section of the Overview tab. A \"padlock\" icon is shown in the Editor’s title bar and beside the asset in the Project Explorer when an asset is locked. Figure 200. The Asset Editor - Locked assets cannot be edited by other users Tags allow assets to be labelled with any number of tags that you define.\n\n These tags can be used to filter assets on the Project Explorer enabling \"Tag filtering\". To create tags you simply have to write them on the Tags input and press the \"Add new Tag/s\" button.\n\n The Tag Editor allows creating tags one by one or writing more than one separated with a white space. Once you created new Tags they will appear over the Editor allowing you to remove them by pressing on them if you want. The Project Explorer provides the ability to browse different Organizational Units, Repositories, Projects and their files. The initial view could be empty when first opened. The user may have to select an Organizational Unit, Repository and Project from the drop-down boxes. In order to reveal packages click on the icon as indicated in the following screen-shot. After a suitable combination of Organizational Unit, Repository, Project and Package have been selected the Project Explorer will show the contents.\n\n The exact combination of selections depends wholly on the structures defined within the Workbench installation and projects.\n\n Each section contains groups of related files.\n\n If a file is currently being edited by another user, a lock symbol will be displayed in front of the file name.\n\n The symbol is blue in case the lock is owned by the currently authenticated user, otherwise black.\n\n Moving the mouse pointer over the lock symbol will display a tooltip providing the name of the user who is currently editing the file (and therefore owning the lock). To learn more about locking see Asset Editor\n\n for details.\n• A simplified view of the underlying project structure.\n\n Certain system files are hidden from view.\n• A complete view of the underlying project structure including all files; either user-defined or system generated. Views can be selected by clicking on the icon within the Project Explorer, as shown below. Both Project and Repository Views can be further refined by selecting either \"Show as Folders\" or \"Show as Links\". Download Download and Download Repository make it possible to download the project or repository as a zip file. A branch selector will be visible if the repository has more than a single branch. To make easy view the elements on packages that contain a lot of assets, is possible to enabling the Tag filter, whichs allows you to filter the assets by their tags. To see how to add tags to an asset look at: Tags Editor Copy, rename and delete actions are available on _Links _ mode, for packages (in of Project View) and for files and directories as well (in Repository View). Download action is available for directories.\n\n Download downloads the selected the selected directory as a zip file. Workbench roadmap includes a refactoring and an impact analyses tools, but currenctly doesn’t have it.\n\n Until both tools are provided make sure that your changes (copy/rename/delete) on packages, files or directories doesn’t have a major impact on your project. In cases that your change had an unexcepcted impact, Workbench allows you to restore your repository using the Repository\n\n editor. Files locked by other users as well as directories that contain such files cannot be renamed or deleted until the corresponding locks are released.\n\n If that is the case the rename and delete symbols will be deactivated.\n\n To learn more about locking see Asset Editor\n\n for details. The Project Editor screen can be accessed from Project Explorer.\n\n Project Editor shows the settings for the currently active project. Unlike most of the workbench editors, project editor edits more than one file.\n\n Showing everything that is needed for configuring the KIE project in one place. Figure 219. Project Screen and the different views Build & Depoy builds the current project and deploys the KJAR into the workbench internal Maven repository. Project Settings edits the pom.xml file used by Maven. General settings provide tools for project name and GAV-data (Group, Artifact, Version). GAV values are used as identifiers to differentiate projects and versions of the same project. The project may have any number of either internal or external dependencies.\n\n Dependency is a project that has been built and deployed to a Maven repository.\n\n Internal dependencies are projects build and deployed in the same workbench as the project.\n\n External dependencies are retrieved from repositories outside of the current workbench.\n\n Each dependency uses the GAV-values to specify the project name and version that is used by the project. Classes and declared types in white listed packages show up as Data Objects that can be imported in assets.\n\n The full list is stored in package-name-white-list file that is stored in each project root.\n• All packages included: Every package defined in this jar is white listed.\n• Packages not included: None of the packages listed in this jar are white listed.\n• Some packages included: Only part of the packages in the jar are white listed. Knowledge Base Settings edits the kmodule.xml file used by Drools. For more information about the Knowledge Base properties, check the Drools Expert documentation for kmodule.xml. Knowledge bases and sessions lists the knowledge bases and the knowledge sessions specified for the project. Lists all the knowledge bases by name.\n\n Only one knowledge base can be set as default. Knowledge base can include other knowledge bases.\n\n The models, rules and any other content in the included knowledge base will be visible and usable by the currently selected knowledge base. Rules and models are stored in packages.\n\n The packages property specifies what packages are included into this knowledge base. Equals behavior is explained in the Drools Expert part of the documentation. Event processing mode is explained in the Drools Fusion part of the documentation. The table lists all the knowledge sessions in the selected knowledge base.\n\n There can be only one default of each type.\n\n The types are stateless and stateful.\n\n Clicking the pen-icon opens a popup that shows more properties for the knowledge session. Settings edits the project.imports file used by the workbench editors. Data Objects provided by the Java Runtime environment may need to be registered to be available to rule authoring where such Data Objects are not implicitly available as part of an existing Data Object defined within the Workbench or a Project dependency.\n\n For example an Author may want to define a rule that checks for in Working Memory.\n\n If a domain Data Object has a field of type there is no need create a registraton. When performing any of the following operations a check is now made against all Maven Repositories, resolved for the Project, for whether the Project’s GroupId, ArtifactId and Version pre-exist.\n\n If a clash is found the operation is prevented; although this can be overridden by Users with the role. The feature can be disabled by setting the System Property to . Resolved repositories are those discovered in:-\n• The Project’s section (or any parent ). Users with the role can override the list of Repositories checked using the \"Repositories\" settings in the Project Editor. The Workbench provides a common and consistent service for users to understand whether files authored within the environment are valid. The Problems Panel shows real-time validation results of assets within a Project. When a Project is selected from the Project Explorer the Problems Panel will refresh with validation results of the chosen Project. When files are created, saved or deleted the Problems Panel content will update to show either new validation errors, or remove existing if a file was deleted. It is not always desirable to save a file in order to determine whether it is in a valid state. All of the file editors provide the ability to validate the content before it is saved. Clicking on the 'Validate' button shows validation errors, if any. By default, a data model is always constrained to the context of a project.\n\n For the purpose of this tutorial, we will assume that a correctly configured project already exists and the authoring perspective is open. To start the creation of a data model inside a project, take the following steps:\n• From the home panel, select the authoring perspective and use the project explorer to browse to the given project. Figure 228. Go to authoring perspective and select a project\n• Open the Data Modeller tool by clicking on a Data Object file, or using the \"New Item → Data Object\" menu option. This will start up the Data Modeller tool, which has the following general aspect: The \"Editor\" tab is divided into the following sections:\n• The new field section is dedicated to the creation of new fields, and is opened when the \"add field\" button is pressed.\n• The Data Object’s \"field browser\" section displays a list with the data object fields.\n• The \"Data Object / Field general properties\" section. This is the rightmost section of the Data Modeller editor and visualizes the \"Data Object\" or \"Field\" general properties, depending on user selection. Data Object general properties can be selected by clicking on the Data Object Selector. Field general properties can be selected by clicking on a field.\n• On workbench’s right side a new \"Tool Bar\" is provided that enables the selection of different context sensitive tool windows that will let the user do domain specific configurations. Currently four tool windows are provided for the following domains \"Drools & jBPM\", \"OptaPlanner\", \"Persistence\" and \"Advanced\" configurations. To see and use the OptaPlanner tool window, the user needs to have the role . The \"Source\" tab shows an editor that allows the visualization and modification of the generated java code.\n• Round trip between the \"Editor\" and \"Source\" tabs is possible, and also source code preservation is provided. It means that not matter where the Java code was generated (e.g. Eclipse, Data modeller), the data modeller will only update the necessary code blocks to maintain the model updated. The \"Overview\" tab shows the standard metadata and version information as the other workbench editors. A data model consists of data objects which are a logical representation of some real-world data.\n\n Such data objects have a fixed set of modeller (or application-owned) properties, such as its internal identifier, a label, description, package etc.\n\n Besides those, a data object also has a variable set of user-defined fields, which are an abstraction of a real-world property of the type of data that this logical data object represents. Creating a data object can be achieved using the workbench \"New Item - Data Object\" menu option. Both resource name and location are mandatory parameters.\n\n When the \"Ok\" button is pressed a new Java file will be created and a new editor instance will be opened for the file edition.\n\n The optional \"Persistable\" attribute will add by default configurations on the data object in order to make it a JPA entity.\n\n Use this option if your jBPM project needs to store data object’s information in a data base. Once the data object has been created, it now has to be completed by adding user-defined properties to its definition.\n\n This can be achieved by pressing the \"add field\" button.\n\n The \"New Field\" dialog will be opened and the new field can be created by pressing the \"Create\" button.\n\n The \"Create and continue\" button will also add the new field to the Data Object, but won’t close the dialog.\n\n In this way multiple fields can be created avoiding the popup opening multiple times.\n\n The following fields can (or must) be filled out:\n• The field’s internal identifier (mandatory). The value of this field must be unique per data object, i.e. if the proposed identifier already exists within current data object, an error message will be displayed.\n• A label (optional): as with the data object definition, the user can define a user-friendly label for the data object field which is about to be created. This has no further implications on how fields from objects of this data object will be treated. If a label is defined, then this is how the field will be displayed throughout the data modeller tool.\n• A field type (mandatory): each data object field needs to be assigned with a type. This type can be either of the following:\n• A 'primitive java object' type: these include most of the object equivalents of the standard Java primitive types, such as Boolean, Short, Float, etc, as well as String, Date, BigDecimal and BigInteger.\n• A 'data object' type: any user defined data object automatically becomes a candidate to be defined as a field type of another data object, thus enabling the creation of relationships between them. A data object field can be created either in 'single' or in 'multiple' form, the latter implying that the field will be defined as a collection of this type, which will be indicated by selecting \"List\" checkbox. When finished introducing the initial information for a new field, clicking the 'Create' button will add the newly created field to the end of the data object’s fields table below: Figure 247. New field has been created The new field will also automatically be selected in the data object’s field list, and its properties will be shown in the Field general properties editor.\n\n Additionally the field properties will be loaded in the different tool windows, in this way the field will be ready for edition in whatever selected tool window. At any time, any field (without restrictions) can be deleted from a data object definition by clicking on the corresponding 'x' icon in the data object’s fields table. As stated before, both Data Objects as well as Fields require some of their initial properties to be set upon creation.\n\n Additionally there are three domains of properties that can be configured for a given Data Object.\n\n A domain is basically a set of properties related to a given business area.\n\n Current available domains are, \"Drools & jJBPM\", \"Persistence\" and the \"Advanced\" domain.\n\n To work on a given domain the user should select the corresponding \"Tool window\" (see below) on the right side toolbar.\n\n Every tool window usually provides two editors, the \"Data Object\" level editor and the \"Field\" level editor, that will be shown depending on the last selected item, the Data Object or the Field. The Drools & jBPM domain editors manages the set of Data Object or Field properties related to drools applications.\n• TypeSafe: this property allows to enable/disable the type safe behaviour for current type. By default all type declarations are compiled with type safety enabled. (See Drools for more information on this matter).\n• ClassReactive: this property allows to mark this type to be treated as \"Class Reactive\" by the Drools engine. (See Drools for more information on this matter).\n• PropertyReactive: this property allows to mark this type to be treated as \"Property Reactive\" by the Drools engine. (See Drools for more information on this matter).\n• Role: this property allows to configure how the Drools engine should handle instances of this type: either as regular facts or as events. By default all types are handled as a regular fact, so for the time being the only value that can be set is \"Event\" to declare that this type should be handled as an event. (See Drools Fusion for more information on this matter).\n• Timestamp: this property allows to configure the \"timestamp\" for an event, by selecting one of his attributes. If set the engine will use the timestamp from the given attribute instead of reading it from the Session Clock. If not, the engine will automatically assign a timestamp to the event. (See Drools Fusion for more information on this matter).\n• Duration: this property allows to configure the \"duration\" for an event, by selecting one of his attributes. If set the engine will use the duration from the given attribute instead of using the default event duration = 0. (See Drools Fusion for more information on this matter).\n• Expires: this property allows to configure the \"time offset\" for an event expiration. If set, this value must be a temporal interval in the form: [ [ms]] Where [ ] means an optional parameter and # means a numeric value. e.g.: 1d2h, means one day and two hours. (See Drools Fusion for more information on this matter).\n• Remotable: If checked this property makes the Data Object available to be used with jBPM remote services as REST, JMS and WS. (See jBPM for more information on this matter).\n• Equals: checking this property for a Data Object field implies that it will be taken into account, at the code generation level, for the creation of both the equals() and hashCode() methods in the generated Java class. We will explain this in more detail in the following section.\n• Position: this field requires a zero or positive integer. When set, this field will be interpreted by the Drools engine as a positional argument (see the section below and also the Drools documentation for more information on this subject). The Persistence domain editors manages the set of Data Object or Field properties related to persistence.\n• Persistable: this property allows to configure current Data Object as persistable.\n• Table name: this property allows to set a user defined database table name for current Data Object. The persistence domain field editor manages the field level persistence properties and is divided in three sections. A persistable Data Object should have one and only one field defined as the Data Object identifier.\n\n The identifier is typically a unique number that distinguishes a given Data Object instance from all other instances of the same class.\n• Is Identifier: marks current field as the Data Object identifier. A persistable Data Object should have one and only one field marked as identifier, and it should be a base java type, like String, Integer, Long, etc. A field that references a Data Object, or is a multiple field can not be marked as identifier. And also composite identifiers are not supported in this version. When a persistable Data Object is created an identifier field is created by default with the properly initializations, it’s strongly recommended to use this identifier.\n• Generation Strategy: the generation strategy establishes how the identifier values will be automatically generated when the Data Object instances are created and stored in a database. (e.g. by the forms associated to jBPM processes human tasks.) When the by default Identifier field is created, the generation strategy will be also automatically set and it’s strongly recommended to use this configuration.\n• Sequence Generator: the generator represents the seed for the values that will be used by the Generation Strategy. When the by default Identifier field is created the Sequence Generator will be also automatically generated and properly configured to be used by the Generation Strategy. The column properties section enables the customization of some properties of the database column that will store the field value.\n• Column name: optional value that sets the database column name for the given field.\n• Unique: When checked the unique property establishes that current field value should be a unique key when stored in the database. (if not set the default value is false)\n• Nullable: When checked establishes that current field value can be null when stored in a database. (if not set the default value is true)\n• Insertable: When checked establishes that column will be included in SQL INSERT statements generated by the persistence provider. (if not set the default value is true)\n• Updatable: When checked establishes that the column will be included SQL UPDATE statements generated by the persistence provider. (if not set the default value is true) When the field’s type is a Data Object type, or a list of a Data Object type a relationship type should be set in order to let the persistence provider to manage the relation.\n\n Fortunately this relation type is automatically set when such kind of fields are added to an already marked as persistable Data Object.\n\n The relationship type is set by the following popup.\n• Relationship type: sets the type of relation from one of the following options: One to one: typically used for 1:1 relations where \"A is related to one instance of B\", and B exists only when A exists.\n\n e.g.\n\n PurchaseOrder → PurchaseOrderHeader (a PurchaseOrderHeader exists only if the PurchaseOrder exists) One to many: typically used for 1:N relations where \"A is related to N instances of B\", and the related instances of B exists only when A exists.\n\n e.g.\n\n PurchaseOrder → PurchaseOrderLine (a PurchaseOrderLine exists only if the PurchaseOrder exists) Many to one: typically used for 1:1 relations where \"A is related to one instance of B\", and B can exist even without A.\n\n e.g.\n\n PurchaseOrder → Client (a Client can exist in the database even without an associated PurchaseOrder) Many to many: typically used for N:N relations where \"A can be related to N instances of B, and B can be related to M instances of A at the same time\", and both B an A instances can exits in the database independently of the related instances.\n\n e.g.\n\n Course → Student.\n\n (Course can be related to N Students, and a given Student can attend to M courses) When a field of type \"Data Object\" is added to a given persistable Data Object, the \"Many to One\" relationship type is generated by default. And when a field of type \"list of Data Object\" is added to a given persistable Data Object , the \"One to Many\" relationship is generated by default.\n• Cascade mode: Defines the set of cascadable operations that are propagated to the associated entity. The value cascade=ALL is equivalent to cascade={PERSIST, MERGE, REMOVE, REFRESH}. e.g. when A → B, and cascade \"PERSIST or ALL\" is set, if A is saved, then B will be also saved. The by default cascade mode created by the data modeller is \"ALL\" and it’s strongly recommended to use this mode when Data Objects are being used by jBPM processes and forms.\n• Fetch mode: Defines how related data will be fetched from database at reading time. EAGER: related data will be read at the same time.\n\n e.g.\n\n If A → B, when A is read from database B will be read at the same time. LAZY: reading of related data will be delayed usually to the moment they are required.\n\n e.g.\n\n If PurchaseOrder → PurchaseOrderLine the lines reading will be postponed until a method \"getLines()\" is invoked on a PurchaseOrder instance. The default fetch mode created by the data modeller is \"EAGER\" and it’s strongly recommended to use this mode when Data Objects are being used by jBPM processes and forms.\n• Optional: establishes if the right side member of a relationship can be null.\n• Mapped by: used for reverse relations. The advanced domain enables the configuration of whatever parameter set by the other domains as well as the adding of arbitrary parameters.\n\n As it will be shown in the code generation section every \"Data Object / Field\" parameter is represented by a java annotation.\n\n The advanced mode enables the configuration of this annotations. The advanced domain editor has the same shape for both Data Object and Field. The following operations are available\n• delete: enables the deletion of a given Data Object or Field annotation.\n• edit: enables the edition of a given annotation parameter value.\n• add annotation: The add annotation button will start a wizard that will let the addition of whatever java annotation available in the project dependencies. Add annotation wizard step #1: the first step of the wizard requires the entering of a fully qualified class name of an annotation, and by pressing the \"search\" button the annotation definition will be loaded into the wizard.\n\n Additionally when the annotation definition is loaded, different wizard steps will be created in order to enable the completion of the different annotation parameters.\n\n Required parameters will be marked with \"*\". Whenever it’s possible the wizard will provide a suitable editor for the given parameters. A generic parameter editor will be provided when it’s not possible to calculate a customized editor When all required parameters has been entered and validated, the finish button will be enabled and the wizard can be completed by adding the annotation to the given Data Object or Field. The data model in itself is merely a visual tool that allows the user to define high-level data structures, for them to interact with the Drools Engine on the one hand, and the jBPM platform on the other.\n\n In order for this to become possible, these high-level visual structures have to be transformed into low-level artifacts that can effectively be consumed by these platforms.\n\n These artifacts are Java POJOs (Plain Old Java Objects), and they are generated every time the data model is saved, by pressing the \"Save\" button in the top Data Modeller Menu.\n\n Additionally when the user round trip between the \"Editor\" and \"Source\" tab, the code is auto generated to maintain the consistency with the Editor view and vice versa. Figure 257. Save the data model from the top menu The resulting code is generated according to the following transformation rules:\n• The data object’s identifier property will become the Java class’s name. It therefore needs to be a valid Java identifier.\n• The data object’s package property becomes the Java class’s package declaration.\n• The data object’s superclass property (if present) becomes the Java class’s extension declaration.\n• The data object’s label and description properties will translate into the Java annotations \"@org.kie.api.definition.type.Label\" and \"@org.kie.api.definition.type.Description\", respectively. These annotations are merely a way of preserving the associated information, and as yet are not processed any further.\n• The data object’s role property (if present) will be translated into the \"@org.kie.api.definition.type.Role\" Java annotation, that IS interpreted by the application platform, in the sense that it marks this Java class as a Drools Event Fact-Type.\n• The data object’s type safe property (if present) will be translated into the \"@org.kie.api.definition.type.TypeSafe Java annotation. (see Drools)\n• The data object’s class reactive property (if present) will be translated into the \"@org.kie.api.definition.type.ClassReactive Java annotation. (see Drools)\n• The data object’s property reactive property (if present) will be translated into the \"@org.kie.api.definition.type.PropertyReactive Java annotation. (see Drools)\n• The data object’s timestamp property (if present) will be translated into the \"@org.kie.api.definition.type.Timestamp Java annotation. (see Drools)\n• The data object’s duration property (if present) will be translated into the \"@org.kie.api.definition.type.Duration Java annotation. (see Drools)\n• The data object’s expires property (if present) will be translated into the \"@org.kie.api.definition.type.Expires Java annotation. (see Drools)\n• The data object’s remotable property (if present) will be translated into the \"@org.kie.api.remote.Remotable Java annotation. (see jBPM) A standard Java default (or no parameter) constructor is generated, as well as a full parameter constructor, i.e.\n\n a constructor that accepts as parameters a value for each of the data object’s user-defined fields. The data object’s user-defined fields are translated into Java class fields, each one of them with its own getter and setter method, according to the following transformation rules:\n• The data object field’s identifier will become the Java field identifier. It therefore needs to be a valid Java identifier.\n• The data object field’s type is directly translated into the Java class’s field type. In case the field was declared to be multiple (i.e. 'List'), then the generated field is of the \"java.util.List\" type.\n• The equals property: when it is set for a specific field, then this class property will be annotated with the \"@org.kie.api.definition.type.Key\" annotation, which is interpreted by the Drools Engine, and it will 'participate' in the generated equals() method, which overwrites the equals() method of the Object class. The latter implies that if the field is a 'primitive' type, the equals method will simply compares its value with the value of the corresponding field in another instance of the class. If the field is a sub-entity or a collection type, then the equals method will make a method-call to the equals method of the corresponding data object’s Java class, or of the java.util.List standard Java class, respectively. If the equals property is checked for ANY of the data object’s user defined fields, then this also implies that in addition to the default generated constructors another constructor is generated, accepting as parameters all of the fields that were marked with Equals.\n\n Furthermore, generation of the equals() method also implies that also the Object class’s hashCode() method is overwritten, in such a manner that it will call the hashCode() methods of the corresponding Java class types (be it 'primitive' or user-defined types) for all the fields that were marked with Equals in the Data Model.\n• The position property: this field property is automatically set for all user-defined fields, starting from 0, and incrementing by 1 for each subsequent new field. However the user can freely changes the position among the fields. At code generation time this property is translated into the \"@org.kie.api.definition.type.Position\" annotation, which can be interpreted by the Drools Engine. Also, the established property order determines the order of the constructor parameters in the generated Java class. As an example, the generated Java class code for the Purchase Order data object, corresponding to its definition as shown in the following figure purchase_example.jpg is visualized in the figure at the bottom of this chapter.\n\n Note that the two of the data object’s fields, namely 'header' and 'lines' were marked with Equals, and have been assigned with the positions 2 and 1, respectively). package org.jbpm.examples.purchases; /** * This class was automatically generated by the data modeler tool. */ @org.kie.api.definition.type.Label(\"Purchase Order\") @org.kie.api.definition.type.TypeSafe(true) @org.kie.api.definition.type.Role(org.kie.api.definition.type.Role.Type.EVENT) @org.kie.api.definition.type.Expires(\"2d\") @org.kie.api.remote.Remotable public class PurchaseOrder implements java.io.Serializable { static final long serialVersionUID = 1L; @org.kie.api.definition.type.Label(\"Total\") @org.kie.api.definition.type.Position(3) private java.lang.Double total; @org.kie.api.definition.type.Label(\"Description\") @org.kie.api.definition.type.Position(0) private java.lang.String description; @org.kie.api.definition.type.Label(\"Lines\") @org.kie.api.definition.type.Position(2) @org.kie.api.definition.type.Key private java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> lines; @org.kie.api.definition.type.Label(\"Header\") @org.kie.api.definition.type.Position(1) @org.kie.api.definition.type.Key private org.jbpm.examples.purchases.PurchaseOrderHeader header; @org.kie.api.definition.type.Position(4) private java.lang.Boolean requiresCFOApproval; public PurchaseOrder() { } public java.lang.Double getTotal() { return this.total; } public void setTotal(java.lang.Double total) { this.total = total; } public java.lang.String getDescription() { return this.description; } public void setDescription(java.lang.String description) { this.description = description; } public java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> getLines() { return this.lines; } public void setLines(java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> lines) { this.lines = lines; } public org.jbpm.examples.purchases.PurchaseOrderHeader getHeader() { return this.header; } public void setHeader(org.jbpm.examples.purchases.PurchaseOrderHeader header) { this.header = header; } public java.lang.Boolean getRequiresCFOApproval() { return this.requiresCFOApproval; } public void setRequiresCFOApproval(java.lang.Boolean requiresCFOApproval) { this.requiresCFOApproval = requiresCFOApproval; } public PurchaseOrder(java.lang.Double total, java.lang.String description, java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> lines, org.jbpm.examples.purchases.PurchaseOrderHeader header, java.lang.Boolean requiresCFOApproval) { this.total = total; this.description = description; this.lines = lines; this.header = header; this.requiresCFOApproval = requiresCFOApproval; } public PurchaseOrder(java.lang.String description, org.jbpm.examples.purchases.PurchaseOrderHeader header, java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> lines, java.lang.Double total, java.lang.Boolean requiresCFOApproval) { this.description = description; this.header = header; this.lines = lines; this.total = total; this.requiresCFOApproval = requiresCFOApproval; } public PurchaseOrder( java.util.List<org.jbpm.examples.purchases.PurchaseOrderLine> lines, org.jbpm.examples.purchases.PurchaseOrderHeader header) { this.lines = lines; this.header = header; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; org.jbpm.examples.purchases.PurchaseOrder that = (org.jbpm.examples.purchases.PurchaseOrder) o; if (lines != null ? !lines.equals(that.lines) : that.lines != null) return false; if (header != null ? !header.equals(that.header) : that.header != null) return false; return true; } @Override public int hashCode() { int result = 17; result = 31 * result + (lines != null ? lines.hashCode() : 0); result = 31 * result + (header != null ? header.hashCode() : 0); return result; } } Using an external model means the ability to use a set for already defined POJOs in current project context.\n\n In order to make those POJOs available a dependency to the given JAR should be added.\n\n Once the dependency has been added the external POJOs can be referenced from current project data model. There are two ways to add a dependency to an external JAR file:\n• Dependency to a JAR file already installed in current local M2 repository (typically associated the the user home).\n• Dependency to a JAR file installed in current KIE Workbench/Drools Workbench \"Guvnor M2 repository\". (internal to the application) To add a dependency to a JAR file in local M2 repository follow this steps. Open the Project Editor for current project and select the Dependencies view. Click on the \"Add\" button to add a new dependency line. Complete the GAV for the JAR file already installed in local M2 repository. When project is saved the POJOs defined in the external file will be available. To add a dependency to a JAR file in current \"Guvnor M2 repository\" follow this steps. Browse your local file system and select the JAR file to be uploaded using the Browse button. Upload the file using the Upload button. Once the file has been loaded it will be displayed in the repository files list. If the uploaded file is not a valid Maven JAR (don’t have a pom.xml file) the system will prompt the user in order to provide a GAV for the file to be installed. Open the project editor (see bellow) and click on the \"Add from repository\" button to open the JAR selector to see all the installed JAR files in current \"Guvnor M2 repository\". When the desired file is selected the project should be saved in order to make the new dependency available. When a dependency to an external JAR has been set, the external POJOs can be used in the context of current project data model in the following ways:\n• External POJOs can be extended by current model data objects.\n• External POJOs can be used as field types for current model data objects. The following screenshot shows how external objects are prefixed with the string \" -ext- \" in order to be quickly identified. Current version implements roundtrip and code preservation between Data modeller and Java source code.\n\n No matter where the Java code was generated (e.g.\n\n Eclipse, Data modeller), the data modeller will only create/delete/update the necessary code elements to maintain the model updated, i.e, fields, getter/setters, constructors, equals method and hashCode method.\n\n Also whatever Type or Field annotation not managed by the Data Modeler will be preserved when the Java sources are updated by the Data modeller. Aside from code preservation, like in the other workbench editors, concurrent modification scenarios are still possible.\n\n Common scenarios are when two different users are updating the model for the same project, e.g.\n\n using the data modeller or executing a 'git push command' that modifies project sources. From an application context’s perspective, we can basically identify two different main scenarios: No changes have been undertaken through the application In this scenario the application user has basically just been navigating through the data model, without making any changes to it.\n\n Meanwhile, another user modifies the data model externally. In this case, no immediate warning is issued to the application user.\n\n However, as soon as the user tries to make any kind of change, such as add or remove data objects or properties, or change any of the existing ones, the following pop-up will be shown: The user can choose to either:\n• Re-open the data model, thus loading any external changes, and then perform the modification he was about to undertake, or\n• Ignore any external changes, and go ahead with the modification to the model. In this case, when trying to persist these changes, another pop-up warning will be shown: The \"Force Save\" option will effectively overwrite any external changes, while \"Re-open\" will discard any local changes and reload the model. Changes have been undertaken through the application The application user has made changes to the data model.\n\n Meanwhile, another user simultaneously modifies the data model from outside the application context. In this alternative scenario, immediately after the external user commits his changes to the asset repository (or e.g.\n\n saves the model with the data modeller in a different session), a warning is issued to the application user: As with the previous scenario, the user can choose to either:\n• Re-open the data model, thus losing any modifications that where made through the application, or\n• Ignore any external changes, and continue working on the model. One of the following possibilities can now occur:\n\n ** The user tries to persist the changes he made to the model by clicking the \"Save\" button in the data modeller top level menu. This leads to the following warning message: The \"Force Save\" option will effectively overwrite any external changes, while \"Re-open\" will discard any local changes and reload the model. A data set is basically a set of columns populated with some rows, a matrix of data composed of timestamps, texts and numbers.\n\n A data set can be stored in different systems: a database, an excel file, in memory or in a lot of other different systems.\n\n On the other hand, a data set definition tells the workbench modules how such data can be accessed, read and parsed. Notice, it’s very important to make crystal clear the difference between a data set and its definition since the workbench does not take care of storing any data, it just provides an standard way to define access to those data sets regardless where the data is stored. Let’s take for instance the data stored in a remote database.\n\n A valid data set could be, for example, an entire database table or the result of an SQL query.\n\n In both cases, the database will return a bunch of columns and rows.\n\n Now, imagine we want to get access to such data to feed some charts in a new workbench perspective.\n\n First thing is to create and register a data set definition in order to indicate the following:\n• where the data set is stored,\n• how can be accessed, read and parsed and\n• what columns contains and of which type. This chapter introduces the available workbench tools for registering and handling data set definitions and how this definitions can be consumed in other workbench modules like, for instance, the Perspective Editor. For simplicity sake we will be using the term data set to refer to the actual data set definitions as Data set and Data set definition can be considered synonyms under the data set authoring context. Everything related to the authoring of data sets can be found under the Data Set Authoring perspective which is accessible from the following top level menu entry: Extensions>Data Sets, as shown in the following screenshot. The center panel, shows a welcome screen, whilst the left panel contains the Data Set Explorer listing all the data sets available This perspective is only intended to Administrator users, since defining data sets can be considered a low level task. The Data Set Explorer list the data sets present in the system.\n\n Every time the user clicks on the data set it shows a brief summary alongside the following information:\n• (2) The list of currently available Data sets\n• (6) The button for editing the Data set. Once clicked the Data set editor screen is opened on the center panel The next sections explains how to create, edit and fine tune data set definitions. Clicking on the New Data Set button opens a new screen from which the user is able to create a new data set definition in three steps:\n• Specify the kind of the remote storage system (BEAN, SQL, CSV, ElasticSearch)\n• Specify the attributes for being able to look up data from the remote system.\n\n The configuration varies depending on the data provider type selected. Allows the user’s specify the type of data provider of the data set being created. This screen lists all the current available data provider types and helper popovers with descriptions.\n\n Each data provider is represented with a descriptive image: Four types are currently supported:\n• SQL - For getting data from any ANSI-SQL compliant database\n• CSV - To upload the contents of a remote or local CSV file\n• Elastic Search - To query and get documents stored on Elastic Search nodes as data sets Once a type is selected, click on Next button to continue with the next workflow step. The provider type selected in the previous step will determine which configuration settings the system asks for. The UUID attribute is a read only field as it’s generated by the system.\n\n It’s only intended for usage in API calls or specific operations. After clicking on the Test button (see previous step), the system executes a data set lookup test call in order to check if the remote system is up and the data is available.\n\n If everything goes ok the user will see the following screen: This screen shows a live data preview along with the columns the user wants to be part of the resulting data set.\n\n The user can also navigate through the data and apply some changes to the data set structure.\n\n Once finished, we can click on the Save button in order to register the new data set definition. We can also change the configuration settings at any time just by going back to the configuration tab.\n\n We can repeat the Configuration>Test>Preview cycle as may times as needed until we consider it’s ready to be saved. In the Columns tab area the user can select what columns are part of the resulting data set definition.\n• (1) To add or remove columns. Select only those columns you want to be part of the resulting data set\n• (2) Use the drop down image selector to change the column type A data set may only contain columns of any of the following 4 types:\n• Label - For text values supporting group operations (similar to the SQL \"group by\" operator) which means you can perform data lookup calls and get one row per distinct value.\n• Text - For text values NOT supporting group operations. Typically for modeling large text columns such as abstracts, descriptions and the like.\n• Number - For numeric values. It does support aggregation functions on data lookup calls: sum, min, max, average, count, disctinct.\n• Date - For date or timestamp values. It does support time based group operations by different time intervals: minute, hour, day, month, year, …​ No matter which remote system you want to retrieve data from, the resulting data set will always return a set of columns of one of the four types above.\n\n There exists, by default, a mapping between the remote system column types and the data set types.\n\n The user is able to modify the type for some columns, depending on the data provider and the column type of the remote system.\n\n The system supports the following changes to column types:\n• Label <> Text - Useful when we want to enable/disable the categorization (grouping) for the target column. For instance, imagine a database table called \"document\" containing a large text column called \"abstract\". As we do not want the system to treat such column as a \"label\" we might change its column type to \"text\". Doing so, we are optimizing the way the system handles the data set and\n• Number <> Label - Useful when we want to treat numeric columns as labels. This can be used for instance to indicate that a given numeric column is not a numeric value that can be used in aggregation functions. Despite its values are stored as numbers we want to handle the column as a \"label\". One example of such columns are: an item’s code, an appraisal id., …​ BEAN data sets do not support changing column types as it’s up to the developer to decide which are the concrete types for each column. A data set definition may define a filter.\n\n The goal of the filter is to leave out rows the user does not consider necessary.\n\n The filter feature works on any data provider type and it lets the user to apply filter operations on any of the data set columns available. While adding or removing filter conditions and operations, the preview table on central area is updated with live data that reflects the current filter status. There exists two strategies for filtering data sets and it’s also important to note that choosing between the two have important implications.\n\n Imagine a dashboard with some charts feeding from a expense reports data set where such data set is built on top of an SQL table.\n\n Imagine also we only want to retrieve the expense reports from the \"London\" office.\n\n You may define a data set containing the filter \"office=London\" and then having several charts feeding from such data set.\n\n This is the recommended approach.\n\n Another option is to define a data set with no initial filter and then let the individual charts to specify their own filter.\n\n It’s up to the user to decide on the best approach. Depending on the case it might be better to define the filter at a data set level for reusing across other modules.\n\n The decision may also have impact on the performance since a filtered cached data set will have far better performance than a lot of individual non-cached data set lookup requests.\n\n (See the next section for more information about caching data sets). Notice, for SQL data sets, the user can use both the filter feature introduced or, alternatively, just add custom filter criteria to the SQL sentence.\n\n Although, the first approach is more appropriated for non technical users since they might not have the required SQL language skills. To edit an existing data set definition go the data set explorer, expand the desired data set definition and click on the Edit button.\n\n This will cause a new editor panel to be opened and placed on the center of the screen, as shown in the next screenshot:\n• Save - To validate the current changes and store the data set definition.\n• Delete - To remove permanently from storage the data set definition. Any client module referencing the data set may be affected.\n• Validate - To check that all the required parameters exists and are correct, as well as to validate the data set can be retrieved with no issues.\n• Copy - To create a brand new definition as a copy of the current one. Data set definitions are stored in the underlying GIT repository as JSON files.\n\n Any action performed is registered in the repository logs so it is possible to audit the change log later on. In the Advanced settings tab area the user can specify caching and refresh settings.\n\n Those are very important for making the most of the system capabilities thus improving the performance and having better application responsive levels.\n• (1) To enable or disable the client cache and specify the maximum size (bytes).\n• (2) To enable or disable the backend cache and specify the maximum cache size (number of rows).\n• (3) To enable or disable automatic refresh for the Data set and the refresh period.\n• (4) To enable or disable the refresh on stale data setting. Let’s dig into more details about the meaning of these settings. The system provides caching mechanisms out-of-the-box for holding data sets and performing data operations using in-memory strategies.\n\n The use of these features brings a lot of advantages, like reducing the network traffic, remote system payload, processing times etc.\n\n On the other hand, it’s up to the user to fine tune properly the caching settings to avoid hitting performance issues. The following diagram shows how caching is involved in any data set operation: Any data look up call produces a resulting data set, so the use of the caching techniques determines where the data lookup calls are executed and where the resulting data set is located. If ON then the data set involved in a look up operation is pushed into the web browser so that all the components that feed from this data set do not need to perform any requests to the backend since data set operations are resolved at a client side:\n• The data set is stored in the web browser’s memory\n• The client components feed from the data set stored in the browser\n• Data set operations (grouping, aggregations, filters and sort) are processed within the web browser, by means of a Javascript data set operation engine. If you know beforehand that your data set will remain small, you can enable the client cache.\n\n It will reduce the number of backend requests, including the requests to the storage system.\n\n On the other hand, if you consider that your data set will be quite big, disable the client cache so as to not hitting with browser issues such as slow performance or intermittent hangs. Its goal is to provide a caching mechanism for data sets on backend side. This feature allows to reduce the number of requests to the remote storage system , by holding the data set in memory and performing group, filter and sort operations using the in-memory engine. It’s useful for data sets that do not change very often and their size can be considered acceptable to be held and processed in memory.\n\n It can be also helpful on low latency connectivity issues with the remote storage.\n\n On the other hand, if your data set is going to be updated frequently, it’s better to disable the backend cache and perform the requests to the remote storage on each look up request, so the storage system is in charge of resolving the data set lookup request. BEAN and CSV data providers relies by default on the backend cache, as in both cases the data set must be always loaded into memory in order to resolve any data lookup operation using the in-memory engine.\n\n This is the reason why the backend settings are not visible in the Advanced settings tab. The refresh feature allows for the invalidation of any cached data when certain conditions are meet.\n• (1) To enable or disable the refresh feature.\n• (2) To specify the refresh interval.\n• (3) To enable or disable data set invalidation when the data is outdated. The data set refresh policy is tightly related to data set caching, detailed in previous section.\n\n This invalidation mechanism determines the cache life-cycle. Depending on the nature of the data there exist three main use cases:\n• Source data changes predictable - Imagine a database being updated every night. In that case, the suggested configuration is to use a \"refresh interval = 1 day\" and disable \"refresh on stale data\". That way, the system will always invalidate the cached data set every day. This is the right configuration when we know in advance that the data is going to change.\n• Source data changes unpredictable - On the other hand, if we do not know whether the database is updated every day, the suggested configuration is to use a \"refresh interval = 1 day\" and enable \"refresh on stale data\". If so the system, before invalidating any data, will check for modifications. On data modifications, the system will invalidate the current stale data set so that the cache is populated with fresh data on the next data set lookup call.\n• Real time scenarios - In real time scenarios caching makes no sense as data is going to be updated constantly. In this kind of scenarios the data sent to the client has to be constantly updated, so rather than enabling the refresh settings (remember this settings affect the caching, and caching is not enabled) it’s up to the clients consuming the data set to decide when to refresh. When the client is a dashboard then it’s just a matter of modifying the refresh settings in the Displayer Editor configuration screen and set a proper refresh period, \"refresh interval = 1 second\" for example. The data source management system provides the ability of defining data sources for accessing external databases.\n\n This data sources can be later used by other workbench components like the Data Sets. To be able to communicate with the target database a data source will need a database driver to access it.\n\n This is why the system additionally provides the ability of defining database drivers for the data sources operation.\n\n A database driver is basically a JDBC compliant driver. We will see them in the next topics. Everything related to the authoring of data sources and drivers can be found under the Data Source Authoring perspective accessible from the following top level menu entry: Extensions>Data Sources, as shown in the following screenshot. This perspective is only intended for Administrator users, since defining data sources can be considered a low level task. The Data Source Explorer lists the data sources and drivers currently defined in the system, at the same time it provides the required actions for managing them.\n• (2) List of currently available data sources\n• (4) List of currently available drivers Clicking on the New Data Source action link opens the New Data Source Wizard:\n• Name: A unique name for the data source definition.\n• Connection URL: A JDBC database connection url compliant with the selected driver type.\n\n This is an example of a connection url for a PostgreSQL database: jdbc:postgresql://localhost:5432/appformer.\n• User: A user name in the target database.\n• Driver: Selects the JDBC driver to be used for connecting to the target database. Note that the connection url format may vary depending on the driver, and different database vendors typically provides different drivers.\n• Test connection: Once clicked, the system will show a dialog similar to the one below showing the connection test status. While not required, it’s recommended to use the test connection button to check the correctness of the data source parameters prior to finishing the data source creation. The Data Source Editor is opened by clicking on a data source item in the Data Source Explorer. The following screenshot shows the Data Source Editor opened for the data source of the example above.\n• Main Panel: The main panel basically lets you modify the data source configuration parameters. The data source content browser is opened by clicking on the Browse Content button, and enables the navigation through the database structure pointed by the data source.\n\n The navigation is performed in three levels, Schemas level, Current schema level and Current table level.\n• Schemas level: lists all the database schemas accessible by current data source.\n\n Which schemas are listed depends on the database access rights granted to the user which was used in the connection configuration.\n\n Similarly for the following item.\n• Current schema level: shows all the database tables for the selected schema.\n• Current table level: shows the table content for the selected table. The following screenshots show the information shown at each level, for a user that realized the following navigation steps.\n\n Selects the \"public\" schema → Selects the \"country\" table. Clicking on the Open button opens the Current schema level for the selected schema. Clicking on the Open button opens the Current table level for the selected table. The rows for the selected table are shown at this level. External data sources are typically not defined in current workbench, instead they exist in current container and for some containers like Wildfly 10 or the JBoss EAP 7 servers they can still be listed in read only mode.\n\n In this cases only the Data Source Content Browser is enabled. Clicking on the New Driver action link opens the New Driver Wizard:\n• Name: A unique name for the driver definition.\n• Driver Class Name: The java fully qualified name for the class that implements the JDBC driver contract.\n• Group Id: The maven group id for the artifact that contains the JDBC driver implementation.\n• Artifact Id: The maven artifact id for the artifact that contains the JDBC driver implementation.\n• Version: The maven version for the artifact that contains the JDBC driver implementation. Some commercial database drivers (like Oracle) are not available in the maven central repository.\n\n You can use those by first uploading them via Artifact Repository perspective and then continue with the driver configuration as for the drivers available in the maven central repository. The Driver Editor is opened by clicking on a driver item in the Data Source Explorer. The following screenshot shows the Driver Editor opened for the driver of the example above.\n• Main Panel: The main panel basically lets you modify the driver configuration parameters.\n\n See New Driver Wizard. The system is shipped with a set of by default configured drivers for the most common used open source databases.\n\n And they are aligned with the latest database versions supported by the Wildfly 10 and the JBoss EAP 7 servers. This section describes how administrator users can manage the application’s users, groups and permissions using an intuitive and friendly user interface in order to\n\n configure who can access the different resources and features available. In order to understand the security management features provided, a few core concepts need to be introduced first. Users can be assigned with more than one role and/or group. It is always mandatory to assign at least one role to the user, otherwise he/she won’t be able to login. Roles are defined at application server level and they are part of the webapp’s web.xml descriptor. On the other hand, groups are a more flexible concept, since they can be defined at runtime. A permission is basically something the user can do within the application. Usually, an action related to a specific resource. For instance: A permission can be granted or denied and it can be global or resource specific. For instance: As you can see, a permission is a pair. In the concrete case of a perspective we have: read, update, delete and create as the available actions. That means that there are four possible permissions that could be granted for perspectives. Permissions do not necessarily need to be tied to a resource. Sometimes it is also neccessary to protect access to specific features, like for instance \"generate a sales report\". That means, permissions can be used not only to protect access to resources but also to custom features within the application. The set of permissions assigned to every role and/or group is called the authorization (or security) policy. Every application contains a single security policy which is used every time the system checks a permission. The authorization policy file is stored in a file called WEB-INF/classes/security-policy.properties under the application’s WAR structure. If no policy is defined then the authorization management features are disabled\n\n and the application behaves as if all the resources & features were granted by default. Here is an example of a security policy file: Every entry defines a single permission which is assigned to a role/group. On application start up, the policy file is loaded and stored into memory. A security environment is usually provided by the use of a realm.\n\n Realms are used to restrict access to the different application’s resources.\n\n So realms contains the information about the users, groups, roles, permissions and any other related information. In most typical scenarios the application’s security is delegated to the container’s security mechanism, which consumes a given realm at same time.\n\n It’s important to consider that there exist several realm implementations, for example Wildfly provides a realm based on the application-users.properties/application-roles.properties files, Tomcat provides a realm based on the tomcat-users.xml file, etc.\n\n So there is no single security realm to rely on, it can be different in each installation. Due to the potential different security environments that have to be supported, the security module provides a well defined API with some default built-in security providers.\n\n A security provider is the formal name given to a concrete user and group management service implementation for a given realm. The user & group management features available will depend on the security provider configured.\n\n If the built-in providers do not fit with the application’s security realm, it is easy to build and register your own provider. At the time of this writing, the application provides two pre-installed security providers:\n• Wildfly 10 / EAP 7 distribution - Both distributions use the Wildfly security provider configured for the use of the default realm files application-users.properties and application-roles.properties\n• Tomcat distribution - It uses the Tomcat security provider configured for the use of the default realm file tomcat-users.xml Please read each provider’s documentation in order to apply the concrete settings for the target deployment environment. On the other hand, when either using a custom security provider or using one of the availables, consider the following installation options:\n• Enable the security management feature on an existing WAR distribution\n• Setup and installation in an existing or new project NOTE: If no security provider is installed, there will be no available user interface for managing the security realm.\n\n Once a security provider is installed and setup, the user and group management features are automatically enabled in the security management UI (see the Usage section below). Given an existing WAR distribution, follow these steps in order to install and enable the user & group management features:\n• Ensure the following libraries are present on WEB-INF/lib:\n• Copy the the security provider library to WEB-INF/lib:\n• If the provider requires additional libraries, copy them as well (read each provider’s documentation for more information).\n• Replace the whole content of the WEB-INF/classes/security-management.properties file, or if not present, create it. The settings present on this file depend on the concrete implementation used. Please read each provider’s documentation for more information.\n• If deploying on Wildfly or EAP, check if the WEB-INF/jboss-deployment-structure.xml requires any update (read each provider’s documentation for more information). The user & groups management features can be disabled, and thus no services or user interface will be available, by means of either:\n• Uninstalling the security provider from the application When no concrete security provider is installed, the user and group management features will be disabled and no services or user interface will be displayed to the user. This is the case for instance, in\n\n Weblogic and Websphere installations as there is no a security provider implementation available at the time of this writing.\n• Removing or commenting all the lines in the configuration file located at WEB-INF/classes/security-management.properties is another way to disable the user and group management features. In versions prior to 7, the only way to grant access to resources like Organizational Units, Repositories or Projects was to indicate which roles were able to access a given instance. Those roles were stored in GIT as part of the instance persistent status. The CLI was the tool used to add/remove roles: As of version 7, the authorization policy is based on permissions. That means is no longer required to keep a list of roles per resource instance. What is required is to define proper permission entries into the active authorization policy using the security management UI (see the Usage section below). The commands above are no longer required so they have been removed. Basically, what those commands did is to set what roles were able to read a specific item. In order to guarantee backward compatibility with versions prior to 7, an automatic migration tool is bundled within the application, which converts the list of roles assigned to any organizational unit, repository or project into read permission entries of the security policy. This tool is executed when the application start ups for the first time, during the security policy deployment. So existing customers, do not have to worry about it, as they will keep their security settings. The Security Management perspective is available under the Home section in the top menu bar. The next screenshot shows how this new perspective looks:\n• List all the roles, groups and users available\n• \n• The home perspective a user will be directed to after login\n• The permissions granted or denied to the different workbench resources and features available All of the above together provides a complete users and groups management subsystem as well as a permission configuration UI for protecting access to specific resources or features. The next sections provide a deep insight into all these features. The user and group management related features can be entirely disabled. See the previous section\n\n Disabling user & group management. If that’s the case then both the Groups and _Users tabs will remain hidden from the user. By selecting the Users tab in the left sidebar, the application shows all the users present by default on the application’s security realm: In addition to listing all the users, search is also allowed: +\n\n When specifying the search pattern in the search box the users listed will be reduced to only those that matches the search pattern. +\n\n Search patterns depend on the concrete security provider being used by the application.\n\n Please read each provider’s documentation for more information.\n• By clicking on the \"New user +\" anchor, a form is displayed on the screen’s right. This is a wizard like interface where the application asks for the new user name, a password as well as what roles/groups to assign. After clicking on a user in the left sidebar, the user editor is opened on the screen’s right. For instance, the details screen for the admin user when using the Wildfly security provider looks like the following screenshot: Same screen but when using the Keycloak security provider looks as: Note that when using the Keycloak provider, a new user attributes section is displayed, but it’s not present when using the Wildfly provider.\n\n This is due to the fact that the information and actions available always depend on each provider’s capabilities as explained in the\n\n Security provider capabilities section below. Next is the type of information handled in the user’s details screen: In order to update or delete an existing user, click on the Edit button present near to the username in the user editor screen: Once the editor is in edit mode, different operations can be done (provided the security provider supports them): For instance, to modify the set of roles and groups assigned to the user or to change the user’s password as well. The Permissions tab shows a summary of all the permissions assigned to this particular user. This is a very helpful view as it allows\n\n administrator users to verify if a target user has the right permission levels according to the security settings of its roles and\n\n groups. Further details about how to assign permissions to roles and groups are in the Security Settings Editor section below.\n• User attributes can added or deleted using the actions available in the attributes table:\n• From the Groups tab, a group selection popup is presented when clicking on the Add to groups button: This popup screen allows the user to search and select or deselect the groups assigned to the user.\n• From the Roles tab, a role selection popup is presented when clicking on Add to roles button: This popup screen allows the user to search and select or deselect the roles assigned to the user.\n• A change password popup screen is presented when clicking on the Change password button:\n• The user currently being edited can be deleted from the realm by clicking on the Delete button. Each security realm can provide support for different operations.\n\n For example consider the use of a Wildfly’s realm based on properties files. The contents for the applications-users.properties is like: Notice that it’s based on key-value pairs where the key is the username, and the value is the hashed value for the user’s password.\n\n So a user is just represented by a key and its username, it does not have a name nor an address or any other meta information. On the other hand, consider the use of a realm provided by a Keycloak server.\n\n The user information is composed by more meta-data, such as the surname, address, etc, as in the following image: So the different services and client side components from the User and Group Management API are based on capabilities. Capabilities are used to expose or restrict the available functionality provided by the different services and client side components.\n\n Examples of capabilities are: Each security provider must specify a set of capabilities supported. From the previous examples, it is noted that the Wildfly security provider does not support the attributes management capability - the user is only composed by the user name. On the other hand the Keycloak provider does support this capability. The different views and user interface components rely on the capabilities supported by each provider, so if a capability is not supported by the provider in use, the UI does not\n\n provide the views for the management of that capability. As an example, consider that a concrete provider does not support deleting users - the delete user button on the user interface\n\n will be not available. Please take a look at the concrete service provider documentation to check all the supported capabilities for each one, the default ones can be found here. By selecting the Groups tab in the left sidebar, the application shows all the groups present by default on the application’s security realm: In addition to listing all the groups, search is also allowed: +\n\n When specifying the search pattern in the search box the groups listed will be reduced to only those that matches the search pattern. +\n\n Search patterns depend on the concrete security provider being used by the application.\n\n Please read each provider’s documentation for more information.\n• By clicking on the \"New group +\" anchor, a new screen will be presented on the center panel to perform a new group creation. After typing a name anc clicking Save, the next step is to assign users to it: +\n\n Clicking on the \"Add selected users\" button finishes the group creation. After clicking on a group in the left sidebar, the security settings editor for the selected group instance is opened on the screen’s right. Further details at the\n\n Security Settings Editor section. To delete an existing group just click on the Delete button. By selecting the Roles tab in the left sidebar, the application shows all the application roles: Unlike users and groups, roles can not be created nor deleted as they come from the application’s web.xml descriptor. After clicking on a role in the left sidebar, the role editor is opened on the screen’s\n\n right, which is exactly the same security settings editor used for groups. Further details at the Security Settings Editor section. That means both role and group based permissions can be defined. The main diference between roles and group are:\n• Roles are an application defined resource. They are defined as <security-role> entries in the application’s web.xml descriptor.\n• Groups are dynamic and can be defined at runtime. The installed security provider determines where groups instances are stored. They can be used together without any trouble. Groups are recommended though as they are a more flexible than roles. In addition to listing all the roles, search is also allowed: +\n\n When specifying the search pattern in the search box the roles listed will be reduced to only those that matches the search pattern. +\n\n Search patterns depend on the concrete security provider being used by the application.\n\n Please read each provider’s documentation for more information. This editor is used to set several security settings for both roles and groups. This is the perspective where the user is directed after login. This makes it possible to have different home pages for different users, since users can be assigned to\n\n different roles or groups. It is used to determine what settings (home perspective, permissions, …​) have precedence for those users with more that one role or group assigned. Without this setting, it won’t be possible to determine what role/group should take precedence. For instance, an administrative role has higher priority than a\n\n non-administrative one. For users with both administrative and non-administrative roles granted, administrative privileges will always win, provided the administrative role’s\n\n priority is greater than the other. Currently, the workbench support the following permission categories.\n• Workbench: General workbench permissions, not tied to any specific resource type.\n• Perspectives: If access to a perspective is denied then it will not be shown in any of application menus. Update, Delete and Create permissions change the behaviour of the perspective management plugin editor.\n• Organizational Units: Sets who can Create, Update or Delete organizational units from the Organizational Unit section at the Administration perspective. Sets also what organizational units are visible in the Project Explorer at the Project Authoring perspective.\n• Repositories: Sets who can Create, Update or Delete repositories from the Repositories section at the Administration perspective. Sets also what repositories are visible in the Project Explorer at the Project Authoring perspective.\n• Projects: In the Project Authoring perspective, sets who can Create, Update, Delete or Build projects from the Project Editor screen as well as what projects are visible in the Project Explorer. For perspectives, organizational units, repositories and projects it is possible to define global permissions and add single instance exceptions afterwards. For instance,\n\n Read access can be granted to all the perspectives and deny access just to an individual perspective. This is called the grant all deny a few strategy. The opposite, deny all grant a few strategy is also supported: In the example above, the Update and Delete permissions are disabled as it does not makes sense to define such permissions if the user is not even able to read\n\n perspectives. The security policy is stored under the workbench’s VFS. Most concrete, in a GIT repo called “security”.\n\n The ACL table is stored in a file called “security-policy.properties” under the “authz” directory. Next is an example of the entries this file contains: Every time the ACL is modified from the security settings UI the changes are stored into the GIT repo. Initially, when the application is deployed for the first time there is no security policy stored in GIT. However, the application might need to set-up a default policy with the different access profiles for each of the application roles. In order to support default policies the system allows for declaring a security policy as part of the webapp’s content. This can be done just by placing a security-policy.properties file under the webapp’s resource classpath (the WEB-INF/classes directory\n\n inside the WAR archive is a valid one). On app start-up the following steps are executed:\n• Check if an active policy is already stored in GIT\n• If not, then check if a policy has been defined under the webapp’s classpath\n• If found, such policy is stored under GIT The above is an auto-deploy mechanism which is used in the workbench to set-up its default security policy. One slight variation of the deployment process is the ability to split the “security-policy.properties” file into small pieces so that it is possible, for example, to define one file\n\n per role. The split files must start by the “security-module-” prefix, for instance: “security-module-admin.properties”. The deployment mechanism will read and deploy both the\n\n \"security-policy.properties\" and all the optional “security-module-?.properties” found on the classpath. Notice, despite using the split approach, the “security-policy.properties” must always be present as it is used as a marker file by the security subsystem in order to locate the other policy files.\n\n This split mechanism allows for a better organization of the whole security policy. As we already know, Workbench provides a set of editors to author assets in different formats.\n\n According to asset’s format a specialized editor is used. One additional feature provided by Workbench is the ability to embed it in your own (Web) Applications thru it’s standalone mode.\n\n So, if you want to edit rules, processes, decision tables, etc…​ in your own applications without switch to Workbench, you can. In order to embed Workbench in your application all you’ll need is the Workbench application deployed and running in a web/application server and, from within your own web applications, an iframe with proper HTTP query parameters as described in the following table. With just the presence of this parameter workbench will switch to standalone mode. Path to the asset to be edited. Note that asset should already exists. Reference to an existing perspective name. Defines the name of the header that should be displayed (useful for context menu headers). Path and Perspective parameters are mutual exclusive, so can’t be used together. This section of the documentation describes the main features included that contribute to the Asset Management functionality provided in the KIE Workbench and KIE Drools Workbench.\n\n All the features described here are entirely optional, but the usage is recommended if you are planning to have multiple projects.\n\n All the Asset Management features try to impose good practices on the repository structure that will make the maintainace, versioning and distribution of the projects simple and based on standards.\n\n All the Asset Management features are implemented using jBPM Business Processes, which means that the logic can be reused for external applications as well as adapted for domain specific requirements when needed. You must set the \"kiemgmt\" role to your user to be able to use the Asset Management Features Since the creation of the assets management features repositories can be classified into Managed or Unmanaged. All new assets management features are available for this type of repositories.\n\n Additionally a managed repository can be \"Single Project\" or \"Multi Project\". A \"Single Project\" managed repository will contain just one Project.\n\n And a \"Multi Project\" managed repository can contain multiple Projects.\n\n All of them related through the same parent, and they will share the same group and version information. Assets management features are not available for this type or repositories and they basically behaves the same as the repositories created with previous workbench versions. There are 4 main processes which represent the stages of the Asset Management feature: Configure Repository, Promote Changes, Build and Release. The Configure Repository process is in charge of the post initialization of the repository.\n\n This process will be automatically triggered if the user selects to create a Managed Repository on the New repository wizzard.\n\n If they decide to use the governance feature the process will kick in and as soon as the repository is created.\n\n A new development and release branches will be created.\n\n Notice that the first time that this process is called, the master branch is picked and both branches (dev and release) will be based on it. By default the asset management feature is not enabled so make sure to select Managed Repository on the New Repository Wizzard.\n\n When we work inside a managed repository, the development branch is selected for the users to work on.\n\n If multiple dev branches are created, the user will need to pick one. When some work is done in the developments branch and the users reach a point where the changes needs to be tested before going into production, they will start a new Promote Changes process so a more technical user can decide and review what needs to be promoted.\n\n The users belonging to the \"kiemgmt\" group will see a new Task in their Group Task List which will contain all the files that had being changed.\n\n The user needs to select the assets that will be promoting via the UI.\n\n The underlying process will be cherry-picking the commits selected by the user to the release branch.\n\n The user can specify that a review is needed by a more technical user. This process can be repeated multiple times if needed before creating the artifacts for the release. The Build process can be triggered to build our projects from different branches.\n\n This allows us to have a more flexible way to build and deploy our projects to different runtimes. The release process is triggered at any time when the user decided that it is time to generate a release of the project that he/she is working on.\n\n This process will build the project (calling the Build Process) and it will update all the maven artifacts to the next version. This section describes the common usage flow for the asset management features showing all the screens involved. The first contact with the Asset Management features starts on the Repository creation. If the user chooses to create a Managed Respository a new page in the wizzard is enabled: When a managed repository is created the assets management configuration process is automatically launched in order to create the repository branches, and the corresponding project structure is also created. Once a repository has been created it can be managed through the Repository Structure Screen. To open the Repository Structure Screen for a given repository open the Project Authoring Perspective, browse to the given repository and select the \"Repository → Repository Structure\" menu option. The following picture shows an example of a single project managed repository structure. The following picture shows an example of a multi project managed repository structure. The following picture shows an example of an unmanaged repository structure. The following picture shows the screen areas related to managed repositories operations. The branch selector lets to switch between the different branches created by the Configure Repository Process. From the repository structure screen it’s also possible to create, edit or delete projects from current repository. The assets management processes can also be launched from the Project Structure Screen. Filling the parameters bellow a new instance of the Configure Repository can be started.\n\n (see Configure Repository Process) Filling the parameters bellow a new instance of the Promote Changes Process can be started.\n\n (see Promote Changes Process) Filling the parameters bellow a new instance of the Release Process can be started.\n\n (see Release Process) The Execution Server Management UI allows users create and modify Server Templates and Containers, it also allows users manage Remote Servers.\n\n This screen is available via Deploy → Rule Deployments menu. The management UI is only available for KIE Managed Servers. Server templates are used to define a common configuration that can be used for multiple server, thus the name: Template. Server Templates can be created directly from the management UI or it’s automatically create when a server connects to controller and there isn’t a template definition for that remote server.\n\n Server templates may have one or more capabilities, such capabilities can’t be modified, if you need modify the capabilities you’ll have to create a new template.\n\n Here is the list of current capabilities: For Planner capability it’s mandatory to enable Rule’s capability too. In order to create a new Server Template you have to click at New Server Template button and follow the wizard.\n\n It’s also possible to create a container during Wizard, but for now let’s limit to just the template. Once created you’ll get the new Template listed on the left hand side, with the new Server Template highlighted.\n\n On the right hand side you get the 2nd level navigation that lists Containers and Remote Servers that are related to selected Server Template. On top of the navigation is also possible to delete the current Server Template or create a copy of it. A Container is a KIE Container configuration of the Server Template.\n\n Click the Add Container button to create a new container for the current Server Template. The search area can help users find an specific KJARs that they are looking for. For Server Templates that have Process capabilities enabled, the Wizard has a 2nd optional step where users can configure some process related behaviors. Once created the new Container will be displayed on the containers list just above the list of remote servers.\n\n Just after created a container is by default Stopped which is the only state that allows users to remove it. A Container has the following tabs available for management and/or configuration: Status tab lists all the Remote Servers that are running the active Container.\n\n Each Remote Server is rendered as a Card, which displays to users status and endpoint. Only started Containers are deployed to remote servers. Version Configuration tab allow users change the current version of the Container.\n\n User’s can upgrade manually to a specific version using the \"Upgrade\" button, or enable/disable the Scanner.\n\n It’s also possible to execute a ScanNow operation, that will scan for new versions only once. Process Configuration is the same form that is displayed during New Container Wizard for Template Servers that have Process Capability.\n\n If Template Server doesn’t have such capability, the action buttons will be disabled. Remote Server is a Managed KIE Server instance running that has a controller configured. By default Workbench comes with a Controller embedded. The list of Remote Servers are displayed just under the list of Containers.\n\n Once selected the screens reveals the Remote Server details and a list of cards, each card represents a running Container.\n\nMake sure the Drools Eclipse plugin is installed, which needs the Graphical Editing Framework (GEF) dependency installed first.\n\n Then download and extract the drools-examples zip file, which includes an already created Eclipse project.\n\n Import that project into a new Eclipse workspace.\n\n The rules all have example classes that execute the rules.\n\n If you want to try the examples in another project (or another IDE) then you will need to set up the dependencies by hand, of course.\n\n Many, but not all of the examples are documented below, enjoy! Name: Hello World Main class: org.drools.examples.helloworld.HelloWorldExample Module: drools-examples Type: Java application Rules file: HelloWorld.drl Objective: demonstrate basic rules in use The \"Hello World\" example shows a simple application using rules, written both using the MVEL and the Java dialects. This example demonstrates how to create and use a .\n\n Also, audit logging and debug outputs are shown, which is omitted from other examples as it’s all very similar. The following code snippet shows how the session is created with only 3 lines of code. Obtains the KieServices factory. This is the main interface applications use to interact with\n\n the engine. Creates a KieContainer from the project classpath. This will look for a /META-INF/kmodule.xml\n\n file to configure and instantiate the KieModule into the KieContainer. Drools has an event model that exposes much of what’s happening internally.\n\n Two default debug listeners are supplied, and which print out debug event information to the stream displayed in the Console window.\n\n Adding listeners to a Session is trivial, as shown in the next snippet.\n\n The provides execution auditing, the result of which can be viewed in a graphical viewer.\n\n The logger is actually a specialised implementation built on the and listeners.\n\n When the engine has finished executing, must be called. Most of the examples use the Audit logging features of Drools to record execution flow for later inspection. // The application can also setup listeners ksession.addEventListener( new DebugAgendaEventListener() ); ksession.addEventListener( new DebugRuleRuntimeEventListener() ); // To setup a file based audit logger, uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, \"./helloworld\" ); // To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging, // uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, \"./helloworld\", 1000 ); The single class used in this example is very simple.\n\n It has two fields: the message, which is a and the status which can be one of the two integers or . A single object is created with the message text \"Hello World\" and the status and then inserted into the engine, at which point is executed. // The application can insert facts into the session final Message message = new Message(); message.setMessage( \"Hello World\" ); message.setStatus( Message.HELLO ); ksession.insert( message ); // and fire the rules ksession.fireAllRules(); To execute the example as a Java application:\n• Open the class in your Eclipse IDE\n• Right-click the class and select \"Run as…​\" and then \"Java application\" If we put a breakpoint on the method and select the variable, we can see that the \"Hello World\" rule is already activate on the Agenda. The application print outs go to to while the debug listener print outs go to . Example 267. HelloWorld: System.out in the Console window Example 268. HelloWorld: System.err in the Console window The actual rules are inside the file src/main/resources/org/drools/examples/helloworld/HelloWorld.drl\n\n : rule \"Hello World\" dialect \"mvel\" when m : Message( status == Message.HELLO, message : message ) then System.out.println( message ); modify ( m ) { message = \"Goodbye cruel world\", status = Message.GOODBYE }; end The LHS (after ) section of the rule states that it will be activated for each object inserted into the Rule Runtime whose status is .\n\n Besides that, two variable bindings are created: the variable is bound to the attribute and the variable is bound to the matched object itself. The RHS (after ) or consequence part of the rule is written using the MVEL expression language, as declared by the rule’s attribute .\n\n After printing the content of the bound variable to , the rule changes the values of the and attributes of the object bound to .\n\n This is done using MVEL’s statement, which allows you to apply a block of assignments in one statement, with the engine being automatically notified of the changes at the end of the block. It is possible to set a breakpoint into the DRL, on the call, and inspect the Agenda view again during the execution of the rule’s consequence.\n\n This time we start the execution via \"Debug As\" and \"Drools application\" and not by running a \"Java application\":\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Debug as…​\" and then \"Drools application\". Now we can see that the other rule , which uses the Java dialect, is activated and placed on the Agenda. The \"Good Bye\" rule, which specifies the \"java\" dialect, is similar to the \"Hello World\" rule except that it matches objects whose status is . The Java code that instantiates the creates an audit log file that can be loaded into the Audit view.\n\n The Audit view is used in many of the examples to demonstrate the example execution flow.\n\n In the view screen shot below we can see that the object is inserted, which creates an activation for the \"Hello World\" rule; the activation is then executed which updates the object causing the \"Good Bye\" rule to activate; finally the \"Good Bye\" rule also executes.\n\n Selecting an event in the Audit view highlights the origin event in green; therefore the \"Activation created\" event is highlighted in green as the origin of the \"Activation executed\" event. This example is implemented in two different versions to demonstrate different ways of implementing the same basic behavior: forward chaining, i.e., the ability the engine has to evaluate, activate and fire rules in sequence, based on changes on the facts in the Working Memory. Name: State Example Main class: org.drools.examples.state.StateExampleUsingSalience Module: drools-examples Type: Java application Rules file: StateExampleUsingSalience.drl Objective: Demonstrates basic rule use and Conflict Resolution for rule firing priority. Each class has fields for its name and its current state (see the class ). The two possible states for each objects are: public class State { public static final int NOTRUN = 0; public static final int FINISHED = 1; private final PropertyChangeSupport changes = new PropertyChangeSupport( this ); private String name; private int state; ... setters and getters go here... } Ignoring the , which will be explained later, we see the creation of four objects named A, B, C and D.\n\n Initially their states are set to , which is default for the used constructor.\n\n Each instance is asserted in turn into the Session and then is called. final State a = new State( \"A\" ); final State b = new State( \"B\" ); final State c = new State( \"C\" ); final State d = new State( \"D\" ); ksession.insert( a ); ksession.insert( b ); ksession.insert( c ); ksession.insert( d ); ksession.fireAllRules(); ksession.dispose(); // Stateful rule session must always be disposed when finished\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" You will see the following output in the Eclipse console window: There are four rules in total.\n\n First, the rule fires, setting A to state , which then causes B to change its state to .\n\n C and D are both dependent on B, causing a conflict which is resolved by the salience values.\n\n Let’s look at the way this was executed. The best way to understand what is happening is to use the Audit Logging feature to graphically see the results of each operation.\n\n To view the Audit log generated by a run of this example:\n• If the Audit View is not visible, click on \"Window\" and then select \"Show View\", then \"Other…​\" and \"Drools\" and finally \"Audit View\".\n• In the \"Audit View\" click the \"Open Log\" button and select the file \"<drools-examples-dir>/log/state.log\". After that, the \"Audit view\" will look like the following screenshot: Reading the log in the \"Audit View\", top to bottom, we see every action and the corresponding changes in the Working Memory.\n\n This way we observe that the assertion of the State object A in the state activates the rule, while the assertions of the other objects have no immediate effect. The execution of rule Bootstrap changes the state of A to , which, in turn, activates rule \"A to B\". rule \"A to B\" when State(name == \"A\", state == State.FINISHED ) b : State(name == \"B\", state == State.NOTRUN ) then System.out.println(b.getName() + \" finished\" ); b.setState( State.FINISHED ); end The execution of rule \"A to B\" changes the state of B to , which activates both, rules \"B to C\" and \"B to D\", placing their Activations onto the Agenda.\n\n From this moment on, both rules may fire and, therefore, they are said to be \"in conflict\". The conflict resolution strategy allows the engine’s Agenda to decide which rule to fire.\n\n As rule \"B to C\" has the higher salience value (10 versus the default salience value of 0), it fires first, modifying object C to state .\n\n The Audit view shown above reflects the modification of the object in the rule \"A to B\", which results in two activations being in conflict.\n\n The Agenda view can also be used to investigate the state of the Agenda, with debug points being placed in the rules themselves and the Agenda view opened.\n\n The screen shot below shows the breakpoint in the rule \"A to B\" and the state of the Agenda with the two conflicting rules. Example 276. Salience State: Rule \"B to C\" rule \"B to C\" salience 10 when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); end Rule \"B to D\" fires last, modifying object D to state . rule \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end There are no more rules to execute and so the engine stops. Another notable concept in this example is the use of dynamic facts, based on objects.\n\n As described in the documentation, in order for the engine to see and react to changes of fact properties, the application must tell the engine that changes occurred.\n\n This can be done explicitly in the rules by using the statement, or implicitly by letting the engine know that the facts implement as defined by the JavaBeans\n\n specification.\n\n This example demonstrates how to use to avoid the need for explicit statements in the rules.\n\n To make use of this feature, ensure that your facts implement , the same way the class does, and use the following code in the rules file to configure the engine to listen for property changes on those facts: When using objects, each setter must implement a little extra code for the notification.\n\n Here is the setter for in the class : Example 279. Setter Example with PropertyChangeSupport There are another class in this example: .\n\n It executes from A to B to C to D, as just shown, but uses agenda-groups to control the rule conflict and which one fires first. Agenda groups are a way to partition the Agenda into groups and to control which groups can execute.\n\n By default, all rules are in the agenda group \"MAIN\". The \"agenda-group\" attribute lets you specify a different agenda group for the rule.\n\n Initially, a Working Memory has its focus on the Agenda group \"MAIN\". A group’s rules will only fire when the group receives the focus.\n\n This can be achieved either ny using the method by or the rule attribute .\n\n \"auto-focus\" means that the rule automatically sets the focus to its agenda group when the rule is matched and activated.\n\n It is this \"auto-focus\" that enables rule \"B to C\" to fire before \"B to D\". Example 280. Agenda Group State Example: Rule \"B to C\" rule \"B to C\" agenda-group \"B to C\" auto-focus true when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"B to D\" ).setFocus(); end The rule \"B to C\" calls on the agenda group \"B to D\", allowing its active rules to fire, which allows the rule \"B to D\" to fire. Example 281. Agenda Group State Example: Rule \"B to D\" rule \"B to D\" agenda-group \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end Name: Fibonacci Main class: org.drools.examples.fibonacci.FibonacciExample Module: drools-examples Type: Java application Rules file: Fibonacci.drl Objective: Demonstrates Recursion, the CE not and cross product matching The Fibonacci Numbers (see http://en.wikipedia.org/wiki/Fibonacci_number) discovered by Leonardo of Pisa (see http://en.wikipedia.org/wiki/Fibonacci) is a sequence that starts with 0 and 1.\n\n The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers.\n\n The Fibonacci sequence begins with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,…​ The Fibonacci Example demonstrates recursion and conflict resolution with salience values. The single fact class is used in this example.\n\n It has two fields, sequence and value.\n\n The sequence field is used to indicate the position of the object in the Fibonacci number sequence.\n\n The value field shows the value of that Fibonacci object for that sequence position, using -1 to indicate a value that still needs to be computed. public static class Fibonacci { private int sequence; private long value; public Fibonacci( final int sequence ) { this.sequence = sequence; this.value = -1; } ... setters and getters go here... }\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" Eclipse shows the following output in its console window (with \"…​snip…​\" indicating lines that were removed to save space): recurse for 50 recurse for 49 recurse for 48 recurse for 47 ...snip... recurse for 5 recurse for 4 recurse for 3 recurse for 2 1 == 1 2 == 1 3 == 2 4 == 3 5 == 5 6 == 8 ...snip... 47 == 2971215073 48 == 4807526976 49 == 7778742049 50 == 12586269025 To kick this off from Java we only insert a single Fibonacci object, with a sequence field of 50.\n\n A recursive rule is then used to insert the other 49 objects.\n\n This example doesn’t use .\n\n It uses the MVEL dialect, which means we can use the keyword, which allows a block setter action which also notifies the engine of changes. The rule Recurse is very simple.\n\n It matches each asserted object with a value of -1, creating and asserting a new object with a sequence of one less than the currently matched object.\n\n Each time a Fibonacci object is added while the one with a sequence field equal to 1 does not exist, the rule re-matches and fires again.\n\n The conditional element is used to stop the rule’s matching once we have all 50 Fibonacci objects in memory.\n\n The rule also has a salience value, because we need to have all 50 objects asserted before we execute the Bootstrap rule. rule Recurse salience 10 when f : Fibonacci ( value == -1 ) not ( Fibonacci ( sequence == 1 ) ) then insert( new Fibonacci( f.sequence - 1 ) ); System.out.println( \"recurse for \" + f.sequence ); end The Audit view shows the original assertion of the object with a sequence field of 50, done from Java code.\n\n From there on, the Audit view shows the continual recursion of the rule, where each asserted object causes the Recurse rule to become activated and to fire again. When a object with a sequence field of 2 is asserted the \"Bootstrap\" rule is matched and activated along with the \"Recurse\" rule.\n\n Note the multi-restriction on field , testing for equality with 1 or 2. rule Bootstrap when f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction then modify ( f ){ value = 1 }; System.out.println( f.sequence + \" == \" + f.value ); end At this point the Agenda looks as shown below.\n\n However, the \"Bootstrap\" rule does not fire because the \"Recurse\" rule has a higher salience. When a object with a sequence of 1 is asserted the Bootstrap rule is matched again, causing two activations for this rule.\n\n Note that the \"Recurse\" rule does not match and activate because the conditional element stops the rule’s matching as soon as a object with a sequence of 1 exists. Once we have two objects with values not equal to -1 the \"Calculate\" rule is able to match.\n\n It was the \"Bootstrap\" rule that set the objects with sequence 1 and 2 to values of 1.\n\n At this point we have 50 Fibonacci objects in the Working Memory.\n\n Now we need to select a suitable triple to calculate each of their values in turn.\n\n Using three Fibonacci patterns in a rule without field constraints to confine the possible cross products would result in 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect.\n\n The \"Calculate\" rule uses field constraints to correctly constraint the thee Fibonacci patterns in the correct order; this technique is called cross product matching.\n\n The first pattern finds any Fibonacci with a value != -1 and binds both the pattern and the field.\n\n The second Fibonacci does this, too, but it adds an additional field constraint to ensure that its sequence is greater by one than the Fibonacci bound to .\n\n When this rule fires for the first time, we know that only sequences 1 and 2 have values of 1, and the two constraints ensure that references sequence 1 and references sequence 2.\n\n The final pattern finds the Fibonacci with a value equal to -1 and with a sequence one greater than .\n\n At this point, we have three objects correctly selected from the available cross products, and we can calculate the value for the third object that’s bound to . rule Calculate when // Bind f1 and s1 f1 : Fibonacci( s1 : sequence, value != -1 ) // Bind f2 and v2; refer to bound variable s1 f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 ) // Bind f3 and s3; alternative reference of f2.sequence f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 ) then // Note the various referencing techniques. modify ( f3 ) { value = f1.value + v2 }; System.out.println( s3 + \" == \" + f3.value ); end The statement updated the value of the object bound to .\n\n This means we now have another new Fibonacci object with a value not equal to -1, which allows the \"Calculate\" rule to rematch and calculate the next Fibonacci number.\n\n The Audit view below shows how the firing of the last \"Bootstrap\" modifies the object, enabling the \"Calculate\" rule to match, which then modifies another Fibonacci object allowing the \"Calculate\" rule to match again.\n\n This continues till the value is set for all objects. This tutorial demonstrates the process of developing a complete personal banking application to handle credits and debits on multiple accounts.\n\n It uses a set of design patterns that have been created for the process. The class is a simple harness to execute one or more DRL files against a set of data.\n\n It compiles the Packages and creates the Knowledge Base for each execution, allowing us to easily execute each scenario and inspect the outputs.\n\n In reality this is not a good solution for a production system, where the Knowledge Base should be built just once and cached, but for the purposes of this tutorial it shall suffice. The first of our sample Java classes loads and executes a single DRL file, Example.drl\n\n , but without inserting any data. public class Example1 { public static void main(String[] args) throws Exception { new RuleRunner().runRules( new String[] { \"Example1.drl\" }, new Object[0] ); } } The first simple rule to execute has a single condition that will always be true, so that this rule will match and fire, once, after the start. The output for the rule is below, showing that the rule matches and executes the single print statement. The next step is to assert some simple facts and print them out. public class Example2 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example2.drl\" }, numbers ); } private static Integer wrap( int i ) { return new Integer(i); } } This doesn’t use any specific facts but instead asserts a set of objects.\n\n This is not considered \"best practice\" as a number is not a useful fact, but we use it here to demonstrate basic techniques before more complexity is added. Now we will create a simple rule to print out these numbers. rule \"Rule 02\" when Number( $intValue : intValue ) then System.out.println( \"Number found with value: \" + $intValue ); end Once again, this rule does nothing special.\n\n It identifies any facts that are objects and prints out the values.\n\n Notice the use of the abstract class : we inserted objects but we now look for any kind of number.\n\n The pattern matching engine is able to match interfaces and superclasses of asserted objects. The output shows the DRL being loaded, the facts inserted and then the matched and fired rules.\n\n We can see that each inserted number is matched and fired and thus printed. Loading file: Example2.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 5 Number found with value: 1 Number found with value: 4 Number found with value: 1 Number found with value: 3 There are certainly many better ways to sort numbers than using rules, but since we will need to apply some cashflows in date order when we start looking at banking rules we’ll develop simple rule based sorting technique. public class Example3 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example3.drl\" }, numbers ); } private static Integer wrap(int i) { return new Integer(i); } } Again we insert our objects, but this time the rule is slightly different: rule \"Rule 03\" when $number : Number( ) not Number( intValue < $number.intValue ) then System.out.println(\"Number found with value: \" + $number.intValue() ); retract( $number ); end The first line of the rule identifies a and extracts the value.\n\n The second line ensures that there does not exist a smaller number than the one found by the first pattern.\n\n We might expect to match only one number - the smallest in the set.\n\n However, the retraction of the number after it has been printed means that the smallest number has been removed, revealing the next smallest number, and so on. The resulting output shows that the numbers are now sorted numerically. Loading file: Example3.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 1 Number found with value: 1 Number found with value: 3 Number found with value: 4 Number found with value: 5 We are ready to start moving towards our personal accounting rules.\n\n The first step is to create a object. Class has two simple attributes, a date and an amount.\n\n (Note that using the type for monetary units is generally not a good idea because floating point numbers cannot represent most numbers accurately.) There is also an overloaded constructor to set the values, and a method to print a cashflow.\n\n The Java code of Example4.java\n\n inserts five Cashflow objects, with varying dates and amounts. public class Example4 { public static void main(String[] args) throws Exception { Object[] cashflows = { new Cashflow(new SimpleDate(\"01/01/2007\"), 300.00), new Cashflow(new SimpleDate(\"05/01/2007\"), 100.00), new Cashflow(new SimpleDate(\"11/01/2007\"), 500.00), new Cashflow(new SimpleDate(\"07/01/2007\"), 800.00), new Cashflow(new SimpleDate(\"02/01/2007\"), 400.00), }; new RuleRunner().runRules( new String[] { \"Example4.drl\" }, cashflows ); } } The convenience class extends , providing a constructor taking a String as input and defining a date format.\n\n The code is listed below Now, let’s look at Example4.drl\n\n to see how we print the sorted objects: rule \"Rule 04\" when $cashflow : Cashflow( $date : date, $amount : amount ) not Cashflow( date < $date) then System.out.println(\"Cashflow: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a and extract the date and the amount.\n\n In the second line of the rule we ensure that there is no Cashflow with an earlier date than the one found.\n\n In the consequence, we print the that satisfies the rule and then retract it, making way for the next earliest .\n\n So, the output we generate is: Next, we extend our , resulting in a which can be a credit or a debit operation.\n\n (Normally, we would just add this to the type, but we use extension to keep the previous version of the class intact.) There are lots of ways to improve this code, but for the sake of the example this will do. Now let’s create Example5, a class for running our code. public class Example5 { public static void main(String[] args) throws Exception { Object[] cashflows = { new TypedCashflow(new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new TypedCashflow(new SimpleDate(\"05/01/2007\"), TypedCashflow.CREDIT, 100.00), new TypedCashflow(new SimpleDate(\"11/01/2007\"), TypedCashflow.CREDIT, 500.00), new TypedCashflow(new SimpleDate(\"07/01/2007\"), TypedCashflow.DEBIT, 800.00), new TypedCashflow(new SimpleDate(\"02/01/2007\"), TypedCashflow.DEBIT, 400.00), }; new RuleRunner().runRules( new String[] { \"Example5.drl\" }, cashflows ); } } Here, we simply create a set of objects which are either credit or debit operations.\n\n We supply them and Example5.drl\n\n to the RuleEngine. Now, let’s look at a rule printing the sorted objects. rule \"Rule 05\" when $cashflow : TypedCashflow( $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not TypedCashflow( date < $date, type == TypedCashflow.CREDIT ) then System.out.println(\"Credit: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a fact with a type of and extract the date and the amount.\n\n In the second line of the rule we ensure that there is no of the same type with an earlier date than the one found.\n\n In the consequence, we print the cashflow satisfying the patterns and then retract it, making way for the next earliest cashflow of type . So, the output we generate is Continuing our banking exercise, we are now going to process both credits and debits on two bank accounts, calculating the account balance.\n\n In order to do this, we create two separate objects and inject them into the objects before passing them to the Rule Engine.\n\n The reason for this is to provide easy access to the correct account without having to resort to helper classes.\n\n Let’s take a look at the class first.\n\n This is a simple Java object with an account number and balance: Now let’s extend our , resulting in , to include an reference. The Java code of Example5.java\n\n creates two objects and passes one of them into each cashflow, in the constructor call. public class Example6 { public static void main(String[] args) throws Exception { Account acc1 = new Account(1); Account acc2 = new Account(2); Object[] cashflows = { new AllocatedCashflow(acc1,new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/02/2007\"), TypedCashflow.CREDIT, 100.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/03/2007\"), TypedCashflow.CREDIT, 500.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/02/2007\"), TypedCashflow.DEBIT, 800.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/03/2007\"), TypedCashflow.DEBIT, 400.00), new AllocatedCashflow(acc1,new SimpleDate(\"01/04/2007\"), TypedCashflow.CREDIT, 200.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/04/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/05/2007\"), TypedCashflow.CREDIT, 700.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/05/2007\"), TypedCashflow.DEBIT, 900.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/05/2007\"), TypedCashflow.DEBIT, 100.00) }; new RuleRunner().runRules( new String[] { \"Example6.drl\" }, cashflows ); } } Now, let’s look at the rule in Example6.drl\n\n to see how we apply each cashflow in date order and calculate and print the balance. rule \"Rule 06 - Credit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Credit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance()+$amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end rule \"Rule 06 - Debit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.DEBIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Debit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance() - $amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end Although we have separate rules for credits and debits, but we do not specify a type when checking for earlier cashflows.\n\n This is so that all cashflows are applied in date order, regardless of the cashflow type.\n\n In the conditions we identify the account to work with, and in the consequences we update it with the cashflow amount. Loading file: Example6.drl Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0] Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0 Account: 2 - new balance: -400.0 Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0 Account: 2 - new balance: 100.0 Debit: Wed May 02 00:00:00 BST 2007 :: 100.0 Account: 2 - new balance: 0.0 Credit: Fri May 11 00:00:00 BST 2007 :: 700.0 Account: 2 - new balance: 700.0 Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0 Account: 1 - new balance: 300.0 Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0 Account: 1 - new balance: 400.0 Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0 Account: 1 - new balance: -400.0 Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0 Account: 1 - new balance: -200.0 Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0 Account: 1 - new balance: 100.0 Debit: Mon May 07 00:00:00 BST 2007 :: 900.0 Account: 1 - new balance: -800.0 The Pricing Rule decision table demonstrates the use of a decision table in a spreadsheet, in Excel’s XLS format, in calculating the retail cost of an insurance policy.\n\n The purpose of the provide set of rules is to calculate a base price and a discount for a car driver applying for a specific policy.\n\n The driver’s age, history and the policy type all contribute to what the basic premium is, and an additional chunk of rules deals with refining this with a discount percentage. Open the file PricingRuleDTExample.java\n\n and execute it as a Java application.\n\n It should produce the following output in the Console window: Cheapest possible BASE PRICE IS: 120 DISCOUNT IS: 20 The code to execute the example follows the usual pattern.\n\n The rules are loaded, the facts inserted and a Stateless Session is created.\n\n What is different is how the rules are added. Note the use of the object.\n\n Its input type is set to .\n\n If you use the BRMS, all this is of course taken care of for you. There are two fact types used in this example, and .\n\n Both are used with their default values.\n\n The is 30 years old, has had no prior claims and currently has a risk profile of .\n\n The being applied for is , and it has not yet been approved. In this decision table, each row is a rule, and each column is a condition or an action. Referring to the spreadsheet show above, we have the declaration, which provides the package name.\n\n There are also other optional items you can have here, such as for global variables, and for importing classes.\n\n In this case, the namespace of the rules is the same as the fact classes we are using, so we can omit it. Moving further down, we can see the declaration.\n\n The name after this (Pricing bracket) is used as the prefix for all the generated rules.\n\n Below that, we have \"CONDITION or ACTION\", indicating the purpose of the column, i.e., whether it forms part of the condition or the consequence of the rule that will be generated. You can see that there is a driver, his data spanned across three cells, which means that the template expressions below it apply to that fact.\n\n We observe the driver’s age range (which uses and with comma-separated values), , and in the respective columns.\n\n In the action columns, we are set the policy base price and log a message. In the preceding spreadsheet section, there are broad category brackets, indicated by the comment in the leftmost column.\n\n As we know the details of our drivers and their policies, we can tell (with a bit of thought) that they should match row number 18, as they have no prior accidents, and are 30 years old.\n\n This gives us a base price of 120. The above section contains the conditions for the discount we might grant our driver.\n\n The discount results from the bracket, the number of prior claims, and the policy type.\n\n In our case, the driver is 30, with no prior claims, and is applying for a policy, which means we can give a discount of 20%. Note that this is actually a separate table, but in the same worksheet, so that different templates apply. It is important to note that decision tables generate rules.\n\n This means they aren’t simply top-down logic, but more a means to capture data resulting in rules.\n\n This is a subtle difference that confuses some people.\n\n The evaluation of the rules is not necessarily in the given order, since all the normal mechanics of the rule engine still apply. Name: Pet Store Main class: org.drools.examples.petstore.PetStoreExample Module: drools-examples Type: Java application Rules file: PetStore.drl Objective: Demonstrate use of Agenda Groups, Global Variables and integration with a GUI, including callbacks from within the rules The Pet Store example shows how to integrate Rules with a GUI, in this case a Swing based desktop application.\n\n Within the rules file, it demonstrates how to use Agenda groups and auto-focus to control which of a set of rules is allowed to fire at any given time.\n\n It also illustrates the mixing of the Java and MVEL dialects within the rules, the use of accumulate functions and the way of calling Java functions from within the ruleset. All of the Java code is contained in one file, PetStore.java\n\n , defining the following principal classes (in addition to several classes to handle Swing Events):\n• contains the method that we will look at shortly.\n• is responsible for creating and displaying the Swing based GUI. It contains several smaller classes, mainly for responding to various GUI events such as mouse button clicks.\n• holds the table data. Think of it as a JavaBean that extends the Swing class .\n• allows the GUI to interact with the Rules.\n• keeps the items that we wish to buy.\n• stores details of the order and the products we are buying.\n• is a JavaBean holding details of the product available for purchase, and its price. Much of the Java code is either plain JavaBeans or Swing-based.\n\n Only a few Swing-related points will be discussed in this section, but a good tutorial about Swing components can be found at Sun’s Swing website, in http://java.sun.com/docs/books/tutorial/uiswing/. The pieces of Java code in Petstore.java\n\n that relate to rules and facts are shown below. Example 312. Creating the PetStore KieContainer in PetStore.main // KieServices is the factory for all KIE services KieServices ks = KieServices.Factory.get(); // From the kie services, a container is created from the classpath KieContainer kc = ks.getKieClasspathContainer(); // Create the stock. Vector<Product> stock = new Vector<Product>(); stock.add( new Product( \"Gold Fish\", 5 ) ); stock.add( new Product( \"Fish Tank\", 25 ) ); stock.add( new Product( \"Fish Food\", 2 ) ); // A callback is responsible for populating the // Working Memory and for firing all rules. PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( kc ) ); ui.createAndShowGUI(); The code shown above create a from the classpath and based on the definitions in the kmodule.xml\n\n file.\n\n Unlike other examples where the facts are asserted and fired straight away, this example defers this step to later.\n\n The way it does this is via the second last line where a object is created using a constructor accepting the object collecting our products, and an instance of the class containing the Rule Base that we have just loaded. The Java code that fires the rules is within the method.\n\n This is triggered (eventually) when the Checkout button is pressed by the user. Example 313. Firing the Rules - extract from CheckoutCallBack.checkout() public String checkout(JFrame frame, List<Product> items) { Order order = new Order(); // Iterate through list and add to cart for ( Product p: items ) { order.addItem( new Purchase( order, p ) ); } // Add the JFrame to the ApplicationData to allow for user interaction // From the container, a session is created based on // its definition and configuration in the META-INF/kmodule.xml file KieSession ksession = kcontainer.newKieSession(\"PetStoreKS\"); ksession.setGlobal( \"frame\", frame ); ksession.setGlobal( \"textArea\", this.output ); ksession.insert( new Product( \"Gold Fish\", 5 ) ); ksession.insert( new Product( \"Fish Tank\", 25 ) ); ksession.insert( new Product( \"Fish Food\", 2 ) ); ksession.insert( new Product( \"Fish Food Sample\", 0 ) ); ksession.insert( order ); ksession.fireAllRules(); // Return the state of the cart return order.toString(); } Two items get passed into this method.\n\n One is the handle to the Swing component surrounding the output text frame, at the bottom of the GUI.\n\n The second is a list of order items; this comes from the storing the information from the \"Table\" area at the top right section of the GUI. The for loop transforms the list of order items coming from the GUI into the JavaBean, also contained in the file PetStore.java\n\n .\n\n Note that it would be possible to refer to the Swing dataset directly within the rules, but it is better coding practice to do it this way, using simple Java objects.\n\n It means that we are not tied to Swing if we wanted to transform the sample into a Web application. It is important to note that all state in this\n\n example is stored in the Swing components, and that the rules are\n\n effectively stateless. Each time the \"Checkout\" button is pressed, this code copies the contents of the Swing into the Session’s Working Memory. Within this code, there are nine calls to the .\n\n The first of these creates a new from the .\n\n Remember that we passed in this when we created the class in the method.\n\n The next two calls pass in two objects that we will hold as global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the , as well as the order list.\n\n The final call is the standard .\n\n Next, we look at what this method causes to happen within the rules file. Example 314. Package, Imports, Globals and Dialect: extract from PetStore.drl The first part of file PetStore.drl\n\n contains the standard package and import statements to make various Java classes available to the rules.\n\n New to us are the two globals and .\n\n They hold references to the Swing components and components that were previously passed on by the Java code calling the method.\n\n Unlike variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the Session. The next extract from the file PetStore.drl\n\n contains two functions that are referenced by the rules that we will look at shortly. Example 315. Java Functions in the Rules: extract from PetStore.drl function void doCheckout(JFrame frame, KieRuntime krt) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to checkout?\", \"\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (n == 0) { krt.getAgenda().getAgendaGroup( \"checkout\" ).setFocus(); } } function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to buy a tank for your \" + total + \" fish?\", \"Purchase Suggestion\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); System.out.print( \"SUGGESTION: Would you like to buy a tank for your \" + total + \" fish? - \" ); if (n == 0) { Purchase purchase = new Purchase( order, fishTank ); krt.insert( purchase ); order.addItem( purchase ); System.out.println( \"Yes\" ); } else { System.out.println( \"No\" ); } return true; } Having these functions in the rules file just makes the Pet Store example more compact.\n\n In real life you probably have the functions in a file of their own, within the same rules package, or as a static method on a standard Java class, and import them, using . The purpose of these two functions is:\n• displays a dialog asking users whether they wish to checkout. If they do, focus is set to the agenda-group, allowing rules in that group to (potentially) fire.\n• displays a dialog asking users whether they wish to buy a tank. If so, a new fish tank is added to the order list in Working Memory. We’ll see the rules that call these functions later on.\n\n The next set of examples are from the Pet Store rules themselves.\n\n The first extract is the one that happens to fire first, partly because it has the attribute set to true. Example 316. Putting items into working memory: extract from PetStore.drl // Insert each item in the shopping cart into the Working Memory // Insert each item in the shopping cart into the Working Memory rule \"Explode Cart\" agenda-group \"init\" auto-focus true salience 10 dialect \"java\" when $order : Order( grossTotal == -1 ) $item : Purchase() from $order.items then insert( $item ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"show items\" ).setFocus(); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"evaluate\" ).setFocus(); end This rule matches against all orders that do not yet have their calculated . It loops for each purchase item in that order.\n\n Some parts of the \"Explode Cart\" rule should be familiar: the rule name, the salience (suggesting the order for the rules being fired) and the dialect set to .\n\n There are three new features:\n• `agenda-group defines the name of the agenda group. In this case, there is only one rule in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the next attribute for its chance to fire.\n• auto-focus ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when `fireAllRules() is called from the Java code.\n• sets the focus to the and agenda groups in turn, permitting their rules to fire. In practice, we loop through all items on the order, inserting them into memory, then firing the other rules after each insert. The next two listings show the rules within the and agenda groups.\n\n We look at them in the order that they are called. Example 317. Show Items in the GUI - extract from PetStore.drl The agenda-group has only one rule, called \"Show Items\" (note the difference in case). For each purchase on the order currently in the Working Memory (or Session), it logs details to the text area at the bottom of the GUI.\n\n The variable used to do this is one of the global variables we looked at earlier. The Agenda group also gains focus from the rule listed previously.\n\n This Agenda group has two rules, and , shown below. // Free Fish Food sample when we buy a Gold Fish if we haven't already bought // Fish Food and don't already have a Fish Food Sample rule \"Free Fish Food Sample\" agenda-group \"evaluate\" dialect \"mvel\" when $order : Order() not ( $p : Product( name == \"Fish Food\") && Purchase( product == $p ) ) not ( $p : Product( name == \"Fish Food Sample\") && Purchase( product == $p ) ) exists ( $p : Product( name == \"Gold Fish\") && Purchase( product == $p ) ) $fishFoodSample : Product( name == \"Fish Food Sample\" ); then System.out.println( \"Adding free Fish Food Sample to cart\" ); purchase = new Purchase($order, $fishFoodSample); insert( purchase ); $order.addItem( purchase ); end // Suggest a tank if we have bought more than 5 gold fish and don't already have one rule \"Suggest Tank\" agenda-group \"evaluate\" dialect \"java\" when $order : Order() not ( $p : Product( name == \"Fish Tank\") && Purchase( product == $p ) ) ArrayList( $total : size > 5 ) from collect( Purchase( product.name == \"Gold Fish\" ) ) $fishTank : Product( name == \"Fish Tank\" ) then requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); end The rule will only fire if\n• we don’t already have any fish food, and\n• we don’t already have a free fish food sample, and\n• we do have a Gold Fish in our order. If the rule does fire, it creates a new product (Fish Food Sample), and adds it to the order in Working Memory. The rule will only fire if\n• we don’t already have a Fish Tank in our order, and\n• we do have more than 5 Gold Fish Products in our order. If the rule does fire, it calls the function that we looked at earlier (showing a Dialog to the user, and adding a Tank to the order / working memory if confirmed). When calling the requireTank() function the rule passes the global frame variable so that the function has a handle to the Swing GUI. The next rule we look at is . Example 319. Doing the Checkout - extract (6) from PetStore.drl rule \"do checkout\" dialect \"java\" when then doCheckout(frame, kcontext.getKieRuntime()); end The rule has no\n\n agenda group set and no auto-focus attribute.\n\n As such, is is deemed part of the default (MAIN) agenda group.\n\n This group gets focus by default when all the rules in agenda-groups that explicitly had focus set to them have run their course. There is no LHS to the rule, so the RHS will always call the function.\n\n When calling the function, the rule passes the global variable to give the function a handle to the Swing GUI.\n\n As we saw earlier, the function shows a confirmation dialog to the user.\n\n If confirmed, the function sets the focus to the checkout agenda-group, allowing the next lot of rules to fire. rule \"Gross Total\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal == -1) Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ), sum( $price ) ) then modify( $order ) { grossTotal = total }; textArea.append( \"\n\ngross total=\" + total + \"\n\n\" ); end rule \"Apply 5% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 10 && < 20 ) then $order.discountedTotal = $order.grossTotal * 0.95; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end rule \"Apply 10% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 20 ) then $order.discountedTotal = $order.grossTotal * 0.90; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end There are three rules in the checkout agenda-group:\n• If we haven’t already calculated the gross total, accumulates the product prices into a total, puts this total into the session, and displays it via the Swing , using the global variable yet again.\n• If our gross total is between 10 and 20, calculates the discounted total and adds it to the session and displays it in the text area.\n• If our gross total is not less than 20, calculates the discounted total and adds it to the session and displays it in the text area. Now that we’ve run through what happens in the code, let’s have a look at what happens when we actually run the code.\n\n The file PetStore.java\n\n contains a method, so that it can be run as a standard Java application, either from the command line or via the IDE.\n\n This assumes you have your classpath set correctly.\n\n (See the start of the examples section for more information.) The first screen that we see is the Pet Store Demo.\n\n It has a list of available products (top left), an empty list of selected products (top right), checkout and reset buttons (middle) and an empty system messages area (bottom). To get to this point, the following things have happened:\n• The method has run and loaded the Rule Base but not yet fired the rules. So far, this is the only code in connection with rules that has been run.\n• A new object has been created and given a handle to the Rule Base, for later use.\n• Various Swing components do their stuff, and the above screen is shown and waits for user input. Clicking on various products from the list might give you a screen similar to the one below. Note that no rules code has been fired here.\n\n This is only Swing code, listening for mouse click events, and adding some selected product to the object for display in the top right hand section.\n\n (As an aside, note that this is a classic use of the Model View Controller design pattern). It is only when we press the \"Checkout\" button that we fire our business rules, in roughly the same order that we walked through the code earlier.\n• Method is called (eventually) by the Swing class waiting for the click on the \"Checkout\" button. This inserts the data from the object (top right hand side of the GUI), and inserts it into the Session’s Working Memory. It then fires the rules.\n• The rule is the first to fire, given that it has set to true. It loops through all the products in the cart, ensures that the products are in the Working Memory, and then gives the and agenda groups a chance to fire. The rules in these groups add the contents of the cart to the text area (at the bottom of the window), decide whether or not to give us free fish food, and to ask us whether we want to buy a fish tank. This is shown in the figure below. Figure 413. Do we want to buy a fish tank?\n• The Do Checkout rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the doCheckout() function which displays a 'Would you like to Checkout?' Dialog Box.\n• The function sets the focus to the agenda-group, giving the rules in that group the option to fire.\n• The rules in the the agenda-group display the contents of the cart and apply the appropriate discount.\n• Swing then waits for user input to either checkout more products (and to cause the rules to fire again), or to close the GUI - see the figure below. Figure 414. Petstore Demo after all rules have fired. We could add more System.out calls to demonstrate this flow of events.\n\n The output, as it currently appears in the Console window, is given in the listing below. Example 321. Console (System.out) from running the PetStore GUI Adding free Fish Food Sample to cart SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes Name: Honest Politician Main class: org.drools.examples.honestpolitician.HonestPoliticianExample Module: drools-examples Type: Java application Rules file: HonestPoliticianExample.drl Objective: Illustrate the concept of \"truth maintenance\" based on the logical insertion of facts The Honest Politician example demonstrates truth maintenance with logical assertions.\n\n The basic premise is that an object can only exist while a statement is true.\n\n A rule’s consequence can logically insert an object with the method.\n\n This means the object will only remain in the Working Memory as long as the rule that logically inserted it remains true.\n\n When the rule is no longer true the object is automatically retracted. In this example there is the class , with a name and a boolean value for being honest.\n\n Four politicians with honest state set to true are inserted. Politician blair = new Politician(\"blair\", true); Politician bush = new Politician(\"bush\", true); Politician chirac = new Politician(\"chirac\", true); Politician schroder = new Politician(\"schroder\", true); ksession.insert( blair ); ksession.insert( bush ); ksession.insert( chirac ); ksession.insert( schroder ); ksession.fireAllRules(); The Console window output shows that, while there is at least one honest politician, democracy lives.\n\n However, as each politician is in turn corrupted by an evil corporation, so that all politicians become dishonest, democracy is dead. Hurrah!!! Democracy Lives I'm an evil corporation and I have corrupted schroder I'm an evil corporation and I have corrupted chirac I'm an evil corporation and I have corrupted bush I'm an evil corporation and I have corrupted blair We are all Doomed!!! Democracy is Dead As soon as there is at least one honest politician in the Working Memory a new object is logically asserted.\n\n This object will only exist while there is at least one honest politician.\n\n As soon as all politicians are dishonest, the object will be automatically retracted.\n\n This rule is given a salience of 10 to ensure that it fires before any other rule, as at this stage the \"Hope is Dead\" rule is actually true. Example 325. Honest Politician: Rule \"We have an honest politician\" rule \"We have an honest Politician\" salience 10 when exists( Politician( honest == true ) ) then insertLogical( new Hope() ); end As soon as a object exists the \"Hope Lives\" rule matches and fires.\n\n It has a salience of 10 so that it takes priority over \"Corrupt the Honest\". Now that there is hope and we have, at the start, four honest politicians, we have four activations for this rule, all in conflict.\n\n They will fire in turn, corrupting each politician so that they are no longer honest.\n\n When all four politicians have been corrupted we have no politicians with the property .\n\n Thus, the rule \"We have an honest Politician\" is no longer true and the object it logical inserted (due to the last execution of ) is automatically retracted. rule \"Corrupt the Honest\" when politician : Politician( honest == true ) exists( Hope() ) then System.out.println( \"I'm an evil corporation and I have corrupted \" + politician.getName() ); modify ( politician ) { honest = false }; end With the object being automatically retracted, via the truth maintenance system, the conditional element applied to is no longer true so that the following rule will match and fire. rule \"Hope is Dead\" when not( Hope() ) then System.out.println( \"We are all Doomed!!! Democracy is Dead\" ); end Let’s take a look at the Audit trail for this application: The moment we insert the first politician we have two activations.\n\n The rule \"We have an honest Politician\" is activated only once for the first inserted politician because it uses an conditional element, which matches once for any number.\n\n The rule \"Hope is Dead\" is also activated at this stage, because we have not yet inserted the object.\n\n Rule \"We have an honest Politician\" fires first, as it has a higher salience than \"Hope is Dead\", which inserts the object.\n\n (That action is highlighted green.) The insertion of the object activates \"Hope Lives\" and de-activates \"Hope is Dead\"; it also activates \"Corrupt the Honest\" for each inserted honest politician.\n\n Rule \"Hope Lives\" executes, printing \"Hurrah!!! Democracy Lives\". Then, for each politician, rule \"Corrupt the Honest\" fires, printing \"I’m an evil corporation and I have corrupted X\", where X is the name of the politician, and modifies the politician’s honest value to false.\n\n When the last honest politician is corrupted, is automatically retracted, by the truth maintenance system, as shown by the blue highlighted area.\n\n The green highlighted area shows the origin of the currently selected blue highlighted area.\n\n Once the fact is retracted, \"Hope is dead\" activates and fires printing \"We are all Doomed!!! Democracy is Dead\". Name: Sudoku Main class: org.drools.examples.sudoku.SudokuExample Type: Java application Rules file: sudoku.drl, validate.drl Objective: Demonstrates the solving of logic problems, and complex pattern matching. This example demonstrates how Drools can be used to find a solution in a large potential solution space based on a number of constraints.\n\n We use the popular puzzle of Sudoku.\n\n This example also shows how Drools can be integrated into a graphical interface and how callbacks can be used to interact with a running Drools rules engine in order to update the graphical interface based on changes in the Working Memory at runtime. Sudoku is a logic-based number placement puzzle.\n\n The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9, once, and only once. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints. The general strategy to solve the problem is to ensure that when you insert a new number it should be unique in its particular 3x3 zone, row and column. See Wikipedia for a more detailed description. Download and install drools-examples as described above and then execute java org.drools.examples.DroolsExamplesApp\n\n and click on \"SudokuExample\". The window contains an empty grid, but the program comes with a number of grids stored internally which can be loaded and solved.\n\n Click on \"File\", then \"Samples\" and select \"Simple\" to load one of the examples.\n\n Note that all buttons are disabled until a grid is loaded. Loading the \"Simple\" example fills the grid according to the puzzle’s initial state. Click on the \"Solve\" button and the Drools-based engine will fill out the remaining values, and the buttons are inactive once more. Alternatively, you may click on the \"Step\" button to see the next digit found by the rule set.\n\n The Console window will display detailed information about the rules which are executing to solve the step in a human readable form.\n\n Some examples of these messages are presented below. single 8 at [0,1] column elimination due to [1,2]: remove 9 from [4,2] hidden single 9 at [1,2] row elimination due to [2,8]: remove 7 from [2,4] remove 6 from [3,8] due to naked pair at [3,2] and [3,7] hidden pair in row at [4,6] and [4,4] Click on the \"Dump\" button to see the state of the grid, with cells showing either the established value or the remaining possibilitiescandidates. Now, let us load a Sudoku grid that is deliberately invalid.\n\n Click on \"File\", \"Samples\" and \"!DELIBERATELY BROKEN!\". Note that this grid starts with some issues, for example the value 5 appears twice in the first row. A few simple rules perform a sanity check, right after loading a grid.\n\n In this case, the following messages are printed on standard output: cell [0,8]: 5 has a duplicate in row 0 cell [0,0]: 5 has a duplicate in row 0 cell [6,0]: 8 has a duplicate in col 0 cell [4,0]: 8 has a duplicate in col 0 Validation complete. Nevertheless, click on the \"Solve\" button to apply the solving rules to this invalid grid.\n\n This will not complete; some cells remain empty. The solving functionality has been achieved by the use of rules that implement standard solving techniques.\n\n They are based on the sets of values that are still candidates for a cell.\n\n If, for instance, such a set contains a single value, then this is the value for the cell.\n\n A little less obvious is the single occurrence of a value in one of the groups of nine cells.\n\n The rules detecting these situations insert a fact of type Setting with the solution value for some specific cell.\n\n This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to.\n\n Finally, it is retracted. Other rules merely reduce the permissible values for some cells.\n\n Rules \"naked pair\", \"hidden pair in row\", \"hidden pair in column\" and \"hidden pair in square\" merely eliminate possibilities but do not establish solutions.\n\n More sophisticated eliminations are done by \"X-wings in rows\", \"X-wings in columns\", \"intersection removal row\" and \"intersection removal column\". The Java source code can be found in the /src/main/java/org/drools/examples/sudoku directory, with the two DRL files defining the rules located in the /src/main/rules/org/drools/examples/sudoku directory. The package contains a set of classes which implement a framework for Sudoku puzzles.\n\n Note that this package does not have any dependencies on the Drools libraries. defines an interface which can be implemented to store a Sudoku puzzle as a 9x9 grid of objects. is a Swing component which can visualize any implementation of . and are used to communicate state changes between the model and the view: events are fired when a cell’s value is resolved or changed.\n\n If you are familiar with the model-view-controller patterns in other Swing components such as then this pattern should be familiar. provides a number of partially filled Sudoku puzzles for demonstration purposes. Package contains a utility class with a method for compiling DRL files. The package contains a set of classes implementing the elementary object and its various aggregations: the subtypes and as well as , all of which are subtypes of .\n\n It’s interesting to note that and are subclasses of , which provides a property with the type .\n\n For a it represents the individual candidate set; for a the set is the union of all candidate sets of its cells, or, simply, the set of digits that still need to be allocated. With 81 and 27 objects and the linkage provided by the properties , and and the property , a list of objects, it is possible to write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set. An object of class is used for triggering the operations that accompany the allocation of a value: its removal from the candidate sets of sibling cells and associated cell groups.\n\n Moreover, the presence of a fact is used in all rules that should detect a new situation; this is to avoid reactions to inconsistent intermediary states. An object of class is used in a low priority rule to execute an emergency halt when a \"Step\" does not terminate regularly.\n\n This indicates that the puzzle cannot be solved by the program. The class implements a Java application combining the components described. Validation rules detect duplicate numbers in cell groups.\n\n They are combined in an agenda group which enables us to activate them, explicitly, after loading a puzzle. The three rules \"duplicate in cell…​\" are very similar.\n\n The first pattern locates a cell with an allocated value.\n\n The second pattern pulls in any of the three cell groups the cell belongs to.\n\n The final pattern would find a cell (other than the first one) with the same value as the first cell and in the same row, column or square, respectively. There are three types of rules in this file: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets. Rules \"set a value\", \"eliminate a value from Cell\" and \"retract setting\" depend on the presence of a object.\n\n The first rule handles the assignment to the cell and the operations for removing the value from the \"free\" sets of the cell’s three groups.\n\n Also, it decrements a counter that, when zero, returns control to the Java application that has called .\n\n The purpose of rule \"eliminate a value from Cell\" is to reduce the candidate lists of all cells that are related to the newly assigned cell.\n\n Finally, when all eliminations have been made, rule \"retract setting\" retracts the triggering fact. There are just two rules that detect a situation where an allocation of a number to a cell is possible.\n\n Rule \"single\" fires for a with a candidate set containing a single number.\n\n Rule \"hidden single\" fires when there is no cell with a single candidate but when there is a cell containing a candidate but this candidate is absent from all other cells in one of the three groups the cell belongs to.\n\n Both rules create and insert a fact. Rules from the largest group of rules implement, singly or in groups of two or three, various solving techniques, as they are employed when solving Sudoku puzzles manually. Rule \"naked pair\" detects identical candidate sets of size 2 in two cells of a group; these two values may be removed from all other candidate sets of that group. A similar idea motivates the three rules \"hidden pair in…​\"; here, the rules look for a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of this group.\n\n This, then, means that all other candidates can be eliminated from the two cells harbouring the hidden pair. A pair of rules deals with \"X-wings\" in rows and columns.\n\n When there are only two possible cells for a value in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated.\n\n If you follow the pattern sequence in one of these rules, you will see how the conditions that are conveniently expressed by words such as \"same\" or \"only\" result in patterns with suitable constraints or prefixed with \"not\". The rule pair \"intersection removal…​\" is based on the restricted occurrence of some number within one square, either in a single row or in a single column.\n\n This means that this number must be in one of those two or three cells of the row or column; hence it can be removed from the candidate sets of all other cells of the group.\n\n The pattern establishes the restricted occurrence and then fires for each cell outside the square and within the same cell file. These rules are sufficient for many but certainly not for all Sudoku puzzles.\n\n To solve very difficult grids, the rule set would need to be extended with more complex rules.\n\n (Ultimately, there are puzzles that cannot be solved except by trial and error.) Name: Number Guess Main class: org.drools.examples.numberguess.NumberGuessExample Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: NumberGuess.drl Objective: Demonstrate use of Rule Flow to organise Rules The \"Number Guess\" example shows the use of Rule Flow, a way of controlling the order in which rules are fired.\n\n It uses widely understood workflow diagrams for defining the order in which groups of rules will be executed. The creation of the package and the loading of the rules (using the method) is the same as the previous examples.\n\n There is an additional line to add the Rule Flow (NumberGuess.rf\n\n ), which provides the option of specifying different rule flows for the same Knowledge Base.\n\n Otherwise, the Knowledge Base is created in the same manner as before. final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession(); KnowledgeRuntimeLogger logger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/numberguess\"); ksession.insert( new GameRules( 100, 5 ) ); ksession.insert( new RandomNumber() ); ksession.insert( new Game() ); ksession.startProcess( \"Number Guess\" ); ksession.fireAllRules(); logger.close(); ksession.dispose(); Once we have a Knowledge Base, we can use it to obtain a Stateful Session.\n\n Into our session we insert our facts, i.e., standard Java objects.\n\n (For simplicity, in this sample, these classes are all contained within our NumberGuessExample.java\n\n file.\n\n Class provides the maximum range and the number of guesses allowed.\n\n Class automatically generates a number between 0 and 100 and makes it available to our rules, by insertion via the method.\n\n Class keeps track of the guesses we have made before, and their number. Note that before we call the standard method, we also start the process that we loaded earlier, via the method.\n\n We’ll learn where to obtain the parameter we pass (\"Number Guess\", i.e., the identifier of the rule flow) when we talk about the rule flow file and the graphical Rule Flow Editor below. Before we finish the discussion of our Java code, we note that in some real-life application we would examine the final state of the objects.\n\n (Here, we could retrieve the number of guesses, to add it to a high score table.) For this example we are content to ensure that the Working Memory session is cleared by calling the method. Figure 421. RuleFlow for the NumberGuess Example If you open the NumberGuess.rf\n\n file in the Drools IDE (provided you have the JBoss Rules extensions installed correctly in Eclipse) you should see the above diagram, similar to a standard flowchart.\n\n Its icons are similar (but not exactly the same) as in the JBoss jBPM workflow product.\n\n Should you wish to edit the diagram, a menu of available components should be available to the left of the diagram in the IDE, which is called the palette.\n\n This diagram is saved in XML, an (almost) human readable format, using XStream. If it is not already open, ensure that the Properties View is visible in the IDE.\n\n It can be opened by clicking \"Window\", then \"Show View\" and \"Other\", where you can select the \"Properties\" view.\n\n If you do this before you select any item on the rule flow (or click on the blank space in the rule flow) you should be presented with the following set of properties. Keep an eye on the Properties View as we progress through the example’s rule flow, as it presents valuable information.\n\n In this case, it provides us with the identification of the Rule Flow Process that we used in our earlier code snippet, when we called . In the \"Number Guess\" Rule Flow we encounter several node types, many of them identified by an icon.\n• The Start node (white arrow in a green circle) and the End node (red box) mark beginning and end of the rule flow.\n• A Rule Flow Group box (yellow, without an icon) represents a Rule Flow Groups defined in our rules (DRL) file that we will look at later. For example, when the flow reaches the Rule Flow Group \"Too High\", only those rules marked with an attribute of `ruleflow-group can potentially fire.\n• Action nodes (yellow, cog-shaped icon) perform standard Java method calls. Most action nodes in this example call , indicating the program’s progress to the user.\n• Split and Join Nodes (blue ovals, no icon) such as \"Guess Correct?\" and \"More guesses Join\" mark places where the flow of control can split, according to various conditions, and rejoin, respectively\n• Arrows indicate the flow between the various nodes. The various nodes in combination with the rules make the Number Guess game work.\n\n For example, the \"Guess\" Rule Flow Group allows only the rule \"Get user Guess\" to fire, because only that rule has a matching attribute of `ruleflow-group . Example 331. A Rule firing only at a specific point in the Rule Flow: NumberGuess.drl rule \"Get user Guess\" ruleflow-group \"Guess\" no-loop when $r : RandomNumber() rules : GameRules( allowed : allowedGuesses ) game : Game( guessCount < allowed ) not ( Guess() ) then System.out.println( \"You have \" + ( rules.allowedGuesses - game.guessCount ) + \" out of \" + rules.allowedGuesses + \" guesses left.\n\nPlease enter your guess from 0 to \" + rules.maxRange ); br = new BufferedReader( new InputStreamReader( System.in ) ); i = br.readLine(); modify ( game ) { guessCount = game.guessCount + 1 } insert( new Guess( i ) ); end The rest of this rule is fairly standard.\n\n The LHS section (after ) of the rule states that it will be activated for each object inserted into the Working Memory where is less than from the object and where the user has not guessed the correct number. The RHS section (or consequence, after ) prints a message to the user and then awaits user input from .\n\n After obtaining this input (the method call blocks until the return key is pressed) it modifies the guess count and inserts the new guess, making both available to the Working Memory. The rest of the rules file is fairly standard: the package declares the dialect as MVEL, and various Java classes are imported.\n\n In total, there are five rules in this file:\n• Get User Guess, the Rule we examined above.\n• A Rule to inspect the guess and retract it from memory if incorrect.\n• A Rule that notifies the user that all guesses have been used up. One point of integration between the standard Rules and the RuleFlow is via the attribute on the rules, as discussed above.\n\n A second point of integration\n\n between the rules (.drl) file and the Rules Flow .rf files is that the Split Nodes (the blue ovals) can use values in the Working Memory (as updated by the rules) to decide which flow of action to take.\n\n To see how this works, click on the \"Guess Correct Node\"; then within the Properties View, open the Constraints Editor by clicking the button at the right that appears once you click on the \"Constraints\" property line.\n\n You should see something similar to the diagram below. Click on the \"Edit\" button beside \"To node Too High\" and you’ll see a dialog like the one below.\n\n The values in the \"Textual Editor\" window follow the standard rule format for the LHS and can refer to objects in Working Memory.\n\n The consequence (RHS) is that the flow of control follows this node (i.e., \"To node Too High\") if the LHS expression evaluates to true. Figure 424. Constraint Editor for the \"Guess Correct\" Node: value too high Since the file NumberGuess.java\n\n contains a method, it can be run as a standard Java application, either from the command line or via the IDE.\n\n A typical game might result in the interaction below.\n\n The numbers in bold are typed in by the user. Example 332. Example Console output where the Number Guess Example beat the human! You have 5 out of 5 guesses left. Please enter your guess from 0 to 100 50 Your guess was too high You have 4 out of 5 guesses left. Please enter your guess from 0 to 100 25 Your guess was too low You have 3 out of 5 guesses left. Please enter your guess from 0 to 100 37 Your guess was too low You have 2 out of 5 guesses left. Please enter your guess from 0 to 100 44 Your guess was too low You have 1 out of 5 guesses left. Please enter your guess from 0 to 100 47 Your guess was too low You have no more guesses The correct guess was 48 A summary of what is happening in this sample is:\n• The method of NumberGuessExample.java loads a Rule Base, creates a Stateful Session and inserts , and (containing the target number) objects into it. The method also sets the process flow we are going to use, and fires all rules. Control passes to the Rule Flow.\n• File NumberGuess.rf , the Rule Flow, begins at the \"Start\" node.\n• Control passes (via the \"More guesses\" join node) to the Guess node.\n• At the Guess node, the appropriate Rule Flow Group (\"Get user Guess\") is enabled. In this case the Rule \"Guess\" (in the NumberGuess.drl file) is triggered. This rule displays a message to the user, takes the response, and puts it into Working Memory. Flow passes to the next Rule Flow Node.\n• At the next node, \"Guess Correct\", constraints inspect the current session and decide which path to take. If the guess in step 4 was too high or too low, flow proceeds along a path which has an action node with normal Java code printing a suitable message and a Rule Flow Group causing a highest guess or lowest guess rule to be triggered.\n\n Flow passes from these nodes to step 6. If the guess in step 4 was right, we proceed along the path towards the end of the Rule Flow.\n\n Before we get there, an action node with normal Java code prints a statement \"you guessed correctly\". There is a join node here (just before the Rule Flow end) so that our no-more-guesses path (step 7) can also terminate the Rule Flow.\n• Control passes as per the Rule Flow via a join node, a guess incorrect Rule Flow Group (triggering a rule to retract a guess from Working Memory) onto the \"More guesses\" decision node.\n• The \"More guesses\" decision node (on the right hand side of the rule flow) uses constraints, again looking at values that the rules have put into the working memory, to decide if we have more guesses and if so, goto step 3. If not, we proceed to the end of the rule flow, via a Rule Flow Group that triggers a rule stating \"you have no more guesses\".\n• The loop over steps 3 to 7 continues until the number is guessed correctly, or we run out of guesses. Name: Conway's Game Of Life Main class: org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: conway-ruleflow.drl conway-agendagroup.drl Objective: Demonstrates 'accumulate', 'collect' and 'from' Conway’s Game Of Life, described in http://en.wikipedia.org/wiki/Conway’s_Game_of_Life and in http://www.math.com/students/wonders/life/life.html, is a famous cellular automaton conceived in the early 1970’s by the mathematician John Conway.\n\n While the system is well known as \"Conway’s Game Of Life\", it really isn’t a game at all.\n\n Conway’s system is more like a simulation of a form of life.\n\n Don’t be intimidated.\n\n The system is terribly simple and terribly interesting.\n\n Math and Computer Science students alike have marvelled over Conway’s system for more than 30 years now.\n\n The application presented here is a Swing-based implementation of Conway’s Game of Life.\n\n The rules that govern the system are implemented as business rules using Drools.\n\n This document will explain the rules that drive the simulation and discuss the Drools parts of the implementation. We’ll first introduce the grid view, shown below, designed for the visualisation of the game, showing the \"arena\" where the life simulation takes place.\n\n Initially the grid is empty, meaning that there are no live cells in the system.\n\n Each cell is either alive or dead, with live cells showing a green ball.\n\n Preselected patterns of live cells can be chosen from the \"Pattern\" drop-down list.\n\n Alternatively, individual cells can be doubled-clicked to toggle them between live and dead.\n\n It’s important to understand that each cell is related to its neighboring cells, which is fundamental for the game’s rules.\n\n Neighbors include not only cells to the left, right, top and bottom but also cells that are connected diagonally, so that each cell has a total of 8 neighbors.\n\n Exceptions are the four corner cells which have only three neighbors, and the cells along the four border, with five neighbors each. So what are the basic rules that govern this game? Its goal is to show the development of a population, generation by generation.\n\n Each generation results from the preceding one, based on the simultaneous evaluation of all cells.\n\n This is the simple set of rules that govern what the next generation will look like:\n• If a live cell has fewer than 2 live neighbors, it dies of loneliness.\n• If a live cell has more than 3 live neighbors, it dies from overcrowding.\n• If a dead cell has exactly 3 live neighbors, it comes to life. That is all there is to it.\n\n Any cell that doesn’t meet any of those criteria is left as is for the next generation.\n\n With those simple rules in mind, go back and play with the system a little bit more and step through some generations, one at a time, and notice these rules taking their effect. The screenshot below shows an example generation, with a number of live cells.\n\n Don’t worry about matching the exact patterns represented in the screen shot.\n\n Just get some groups of cells added to the grid.\n\n Once you have groups of live cells in the grid, or select a pre-designed pattern, click the \"Next Generation\" button and notice what happens.\n\n Some of the live cells are killed (the green ball disappears) and some dead cells come to life (a green ball appears). Step through several generations and see if you notice any patterns.\n\n If you click on the \"Start\" button, the system will evolve itself so you don’t need to click the \"Next Generation\" button over and over.\n\n Play with the system a little and then come back here for more details of how the application works. Now lets delve into the code.\n\n As this is an advanced example we’ll assume that by now you know your way around the Drools framework and are able to connect the presented highlight, so that we’ll just focus at a high level overview.\n\n The example has two ways to execute, one way uses Agenda Groups to manage execution flow, and the other one uses Rule Flow Groups to manage execution flow.\n\n These two versions are implemented in and , respectively.\n\n Here, we’ll discuss the Rule Flow version, as it’s what most people will use. All the objects are inserted into the Session and the rules in the \"register neighbor\" are allowed to execute by the Rule Flow process.\n\n This group of four rules creates relations between some cell and its northeastern, northern, northwestern and western neighbors.\n\n This relation is bidirectional, which takes care of the other four directions.\n\n Border cells don’t need any special treatment - they simply won’t be paired with neighboring cells where there isn’t any.\n\n By the time all activations have fired for these rules, all cells are related to all their neighboring cells. rule \"register north east\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northEast : Cell( row == ($row - 1), col == ( $col + 1 ) ) then insert( new Neighbor( $cell, $northEast ) ); insert( new Neighbor( $northEast, $cell ) ); end rule \"register north\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $north : Cell( row == ($row - 1), col == $col ) then insert( new Neighbor( $cell, $north ) ); insert( new Neighbor( $north, $cell ) ); end rule \"register north west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northWest : Cell( row == ($row - 1), col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $northWest ) ); insert( new Neighbor( $northWest, $cell ) ); end rule \"register west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $west : Cell( row == $row, col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $west ) ); insert( new Neighbor( $west, $cell ) ); end Once all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to Live.\n\n Then, when the user clicks \"Start\" or \"Next Generation\", it executes the \"Generation\" ruleflow.\n\n This ruleflow is responsible for the management of all changes of cells in each generation cycle. The rule flow process first enters the \"evaluate\" group, which means that any active rule in the group can fire.\n\n The rules in this group apply the Game-of-Life rules discussed in the beginning of the example, determining the cells to be killed and the ones to be given life.\n\n We use the \"phase\" attribute to drive the reasoning of the Cell by specific groups of rules; typically the phase is tied to a Rule Flow Group in the Rule Flow process definition.\n\n Notice that it doesn’t actually change the state of any objectss at this point; this is because it’s evaluating the grid in turn and it must complete the full evaluation until those changes can be applied.\n\n To achieve this, it sets the cell to a \"phase\" which is either or , used later to control actions applied to the object. Example 334. Conway’s Game of Life: Evaluate Cells with state changes rule \"Kill The Lonely\" ruleflow-group \"evaluate\" no-loop when // A live cell has fewer than 2 live neighbors theCell: Cell( liveNeighbors < 2, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Kill The Overcrowded\" ruleflow-group \"evaluate\" no-loop when // A live cell has more than 3 live neighbors theCell: Cell( liveNeighbors > 3, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Give Birth\" ruleflow-group \"evaluate\" no-loop when // A dead cell has 3 live neighbors theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE ) then modify( theCell ){ theCell.setPhase( Phase.BIRTH ); } end Once all objects in the grid have been evaluated, we first clear any calculation activations that occurred from any previous data changes.\n\n This is done via the \"reset calculate\" rule, which clears any activations in the \"calculate\" group.\n\n We then enter a split in the rule flow which allows any activations in both the \"kill\" and the \"birth\" group to fire.\n\n These rules are responsible for applying the state change. Example 335. Conway’s Game of Life: Apply the state changes rule \"reset calculate\" ruleflow-group \"reset calculate\" when then WorkingMemory wm = drools.getWorkingMemory(); wm.clearRuleFlowGroup( \"calculate\" ); end rule \"kill\" ruleflow-group \"kill\" no-loop when theCell: Cell( phase == Phase.KILL ) then modify( theCell ){ setCellState( CellState.DEAD ), setPhase( Phase.DONE ); } end rule \"birth\" ruleflow-group \"birth\" no-loop when theCell: Cell( phase == Phase.BIRTH ) then modify( theCell ){ setCellState( CellState.LIVE ), setPhase( Phase.DONE ); } end At this stage, a number of objects have been modified with the state changed to either or .\n\n Now we get to see the power of the facts defining the cell relations.\n\n When a cell becomes live or dead, we use the relation to iterate over all surrounding cells, increasing or decreasing the count.\n\n Any cell that has its count changed is also set to to the phase, to make sure it is included in the reasoning during the evaluation stage of the Rule Flow Process.\n\n Notice that we don’t have to do any iteration ourselves; simply by applying the relations in the rules we make the rule engine do all the hard work for us, with a minimal amount of code.\n\n Once the live count has been determined and set for all cells, the Rule Flow Process comes to and end.\n\n If the user has initially clicked the \"Start\" button, the engine will restart the rule flow; otherwise the user may request another generation. Example 336. Conway’s Game of Life: Evaluate cells with state changes rule \"Calculate Live\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.LIVE ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ), setPhase( Phase.EVALUATE ); } end rule \"Calculate Dead\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.DEAD ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ), setPhase( Phase.EVALUATE ); } end A simplifed version of the Space Invaders game.\n\n Use the keys Z and K, to move left and right and M to fire a misile.\n\n The example is built up over 6 projects, each adding slightly more complexity to the last. Invaders1Main creates the frame and attaches the KeyListener, feeding key events into the engine.\n\n It also sets up the main game loop which can be found in \"Main.drl\". The typical convention used through out the example is to have one agenda group per file, and all rules in that file in the same agenda group. The Run fact is used to drive the repeat of the Game loop.\n\n Initially there are only one groups that is evaluated, Keys.\n\n The \"keys.drl\" file is shared by several examples, and illustrates rule re-use across multipel projects. rule \"init\" when then insert( new Run() ); setFocus( \"Init\" ); end rule GameLoop when r : Run() then setFocus( \"Keys\" ); end rule Draw when r : Run() then ui.show(); modify( r ) {} // force loop end Invaders2Main adds the \"Draw\" stage to the game loop and draws the SpaceShip Invaders3Main adds move controls to the spaceship, notice the ship moves out of the boundaries of the screen.\n\n KeyPressed is detected and that sets a delta of dx on the ship direction.\n\n That delta is then repeated applied to the x position of the ship rule ShipDeltaMoveLeft agenda-group \"Move\" when s : Ship() KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 - s.speed } end rule ShipDeltaStopLeft agenda-group \"Move\" when s : Ship() not KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 } end rule ShipMove agenda-group \"Move\" when s : Ship( dx != 0 ) Run() then modify( s ) { x = s.x + s.dx } end Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen.\n\n Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. Invaders6Main adds a lot more meat.\n\n Pressing the \"M\" key fires a missile that travels up the screen, while moving collision between the missile and the invader is checked. Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen.\n\n Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. rule InsertBullet agenda-group \"Bullet\" when KeyPressed( keyText == \"M\" ) s : Ship() not Bullet() then b = new Bullet(); b.x = s.x + (s.width/2) - (b.width/2); b.y = s.y - s.height - b.height; b.width = conf.bulletWidth; b.height = conf.bulletHeight; b.dy = 0 - conf.bulletSpeed; insert( b ); end rule BulletMove agenda-group \"Bullet\" when b : Bullet( y > 0 ) @watch( !y ) Run() then modify( b ) { y = b.y + b.dy } end rule Collision agenda-group \"Bullet\" when b : Bullet( ) @watch( y ) i : Invader( x < b.x, x + width > b.x, y > b.y) Run() then modify( i ) { alive = false } end Based on the Adventure in Prolog, over at the Amzi website, http://www.amzi.com/AdventureInProlog/, we started to work on a text adventure game for Drools.\n\n They are ideal as they can start off simple and build in complexity and size over time, they also demonstrate key aspects of declarative relational programming. The game allows you to play as the hero or the monster.\n\n If you click \"New Window\" you can open one window as the hero and another as the monster, and play them both at the same time.\n\n The game allows either character to move around rooms, pick up, drop or use things.\n\n Doors can be locked and unlocked, by using the key on teh exit room, and the hero can kill the monster by using the umbrella on the monster. You can view the 8 minute demonstration and introduction for the example at http://downloads.jboss.org/drools/videos/text-adventures.swf.\n\n Be aware the video is now much older than the current improved example. Each action follows the constructor arguments of the associated Command java class. To issue a move action, select the \"Move\" button, then select the exit room.\n\n Notice when you press \"Move\" it adds the text to the white bar at the bottom.\n\n When the exit room is selected, it also is added to the white bar.\n\n Then press send and the game engine will execute the command.\n\n Internally it uses reflection to instantiate the Command and insert it into the engine.\n\n If you select incorrect arguments, such as pressing exits multiple times, the reflection will fail and you can attempt it again. The Things list displays anything you can see in the room, not all things can be picked up.\n\n For instance you can pick up the key and the torch, but not the monster.\n\n When something is picked up it moves from the Things list to the Inventory List.\n\n The reverse is true when something is dropped. The key is in the office, move upstairs and into the office.\n\n Then pick up the key.\n\n Move back downstairs and into the kitchen.\n\n Try and walk into the basement, notice it’s locked. Select the \"Use\" action, the select the key and then the basement exit.\n\n This will unlock the door and you can now walk through. To kill the monster pick up the umbrella from the lounge and then select \"Use\", then select the imbrella and finally select the monster. Don’t forget to open a \"New Window\" to play as the monster, although you will not be able to exit the basement until the hero has opened it with the key.\n\n The monster and the hero can also give items to each other, moving items between each playsers inventory. The model is written in Java classes.\n\n Each classes uses @PropertyReactive and @Position.\n\n @PropertyReactive allows control of which fields patterns react to, and @Position maps a field to a argument position allowing positional as well as named arguments for patterns. @PropertyReactive public class Thing { @Position(0) private long id; @Position(1) private String name; public Thing(long id, String name) { this.id = id; this.name = name; } ... } An MVEL data file is used to populate our world, see \"data.mvel\". You can edit this file to add new rooms, items and characters, as well as locks for doors. rooms = [ \"basement\" : new Room(\"basement\"), \"lounge\" : new Room(\"lounge\"), \"kitchen\" : new Room(\"kitchen\"), \"ground floor hallway\" : new Room(\"ground floor hallway\"), \"bedroom\" : new Room(\"bedroom\"), \"office\" : new Room(\"office\"), \"first floor hallway\" : new Room(\"first floor hallway\") ]; doors = [ \"d1\" : new Door( rooms[\"kitchen\"], rooms[\"basement\"] ), \"d2\" : new Door( rooms[\"ground floor hallway\"], rooms[\"lounge\"]), \"d4\" : new Door( rooms[\"ground floor hallway\"], rooms[\"kitchen\"]), \"d5\" : new Door( rooms[\"ground floor hallway\"], rooms[ \"first floor hallway\"] ), \"d8\" : new Door( rooms[\"first floor hallway\"], rooms[ \"bedroom\"] ), \"d9\" : new Door( rooms[\"first floor hallway\"], rooms[ \"office\"] ) ]; locations = [ \"monster\" : new Location( characters[\"monster\"], rooms[\"basement\"] ), \"hero\" : new Location( characters[\"hero\"], rooms[\"ground floor hallway\"] ), \"umbrella\" : new Location( items[\"umbrella\"], rooms[\"lounge\"] ), \"key1\" : new Location( items[\"key1\"], rooms[\"office\"] ) ]; The game creates commands, which it inserts into the engine.\n\n These commands are then used to change the state of the world and that state is reflected back in the UI.\n\n The commands can be found in the \"commands.drl\" file.\n\n The following rule matches the MoveCommand and if it’s valid it will make the move happen. rule validMove agenda-group \"commands\" when mc : MoveCommand( c : character, r : room ) l : Location( thing == c, ltarget : target ) @watch( !target ) ?connect( d, r, ltarget; ) then exit = new ExitEvent( c, (Room) l.target ); enter = new EnterEvent( c, r ); modify( l ) { target = r }; insert( exit ); insert( enter ); mc.session.channels[\"output\"].send( \"You have entered the \" + l.target.name + \"\n\n\" ); end In the above rules notice the \"connect\" pattern, this is actually a query.\n\n In the MVEL data file doors are only described one way, we can use a query to check connections bi-directionally.\n\n The queries can be found in the \"queries.drl\" file. query connect( Door $d, Room $x, Room $y ) $d := Door($id, $name, $x, $y;) or $d :=Door($id, $name, $y, $x;) end The UI has its list boxes populated by rules found in \"UiView.drl\", those rules in turn use queries.\n\n Here is how the \"Things\" list box is populated, when ever the world changes. rule updateThings salience 5 when session : UserSession( $char : character ) things( $char, $things; ) then session.channels[\"things\"].send( $things ); end query things(Character $char, List $things) $char := Character() Location( $char, $room; ) $things := List() from accumulate( Location($thing, $room; thing != $char), collectList( $thing ) ) end A Conversion for the classic game Pong.\n\n Use the keys A, Z and K, M.\n\n The ball should get faster after each bounce. Wumpus World is an AI example covered in the book \"Artificial Intelligence : A Modern Approach\". When the game first starts all the cells are greyed out.\n\n As you walk around they become visible.\n\n The cave has pits, a wumpus and gold.\n\n When you are next to a pit you will feel a breeze, when you are next to the wumpus you will smell a stench and see glitter when next to gold.\n\n The sensor icons are shown above the move buttons.\n\n If you walk into a pit or the wumpus, you die.\n\n A more detailed overview of Wumpus World can be found at http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml.\n\n A 20 minute video showing how the game is created and works is at http://www.youtube.com/watch?v=4CvjKqUOEzM. Name: Miss Manners Main class: org.drools.benchmark.manners.MannersBenchmark Module: drools-examples Type: Java application Rules file: manners.drl Objective: Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth. Miss Manners is throwing a party and, being a good host, she wants to arrange good seating.\n\n Her initial design arranges everyone in male-female pairs, but then she worries about people have things to talk about.\n\n What is a good host to do? She decides to note the hobby of each guest so she can then arrange guests not only pairing them according to alternating sex but also ensuring that a guest has someone with a common hobby, at least on one side. Five benchmarks were established in the 1991 paper \"Effects of Database Size on Rule System Performance: Five Case Studies\" by David Brant, Timothy Grose, Bernie Lofaso and Daniel P.\n\n Miranker:\n• Manners uses a depth-first search approach to determine the seating arrangements alternating women and men and ensuring one common hobby for neighbors.\n• Waltz establishes a three-dimensional interpretation of a line drawing by line labeling by constraint propagation.\n• WaltzDB is a more general version of Waltz, supporting junctions of more than three lines and using a database.\n• ARP is a route planner for a robotic air vehicle using the A* search algorithm to achieve minimal cost.\n• Weaver VLSI router for channels and boxes using a black-board technique. Manners has become the de facto rule engine benchmark.\n\n Its behavior, however, is now well known and many engines optimize for this, thus negating its usefulness as a benchmark which is why Waltz is becoming more favorable.\n\n These five benchmarks are also published at the University of Texas http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/. After the first seating arrangement has been assigned, a depth-first recursion occurs which repeatedly assigns correct seating arrangements until the last seat is assigned.\n\n Manners uses a instance to control execution flow.\n\n The activity diagram is partitioned to show the relation of the rule execution to the current state. Before going deeper into the rules, let’s first take a look at the asserted data and the resulting seating arrangement.\n\n The data is a simple set of five guests who should be arranged so that sexes alternate and neighbors have a common hobby. The data is given in OPS5 syntax, with a parenthesized list of name and value pairs for each attribute.\n\n Each person has only one hobby. Each line of the results list is printed per execution of the \"Assign Seat\" rule.\n\n They key bit to notice is that each line has a \"pid\" value one greater than the last.\n\n (The significance of this will be explained in the discussion of the rule \"Assign Seating\".) The \"ls\", \"rs\", \"ln\" and \"rn\" refer to the left and right seat and neighbor’s name, respectively.\n\n The actual implementation uses longer attribute names (e.g., , but here we’ll stick to the notation from the original implementation. Manners has been designed to exercise cross product joins and Agenda activities.\n\n Many people not understanding this tweak the example to achieve better performance, making their port of the Manners benchmark pointless.\n\n Known cheats or porting errors for Miss Manners are:\n• Using arrays for a guests hobbies, instead of asserting each one as a single fact massively reduces the cross products.\n• Altering the sequence of data can also reduce the amount of matching, increasing execution speed.\n• It’s possible to change the Conditional Element so that the test algorithm only uses the \"first-best-match\", which is, basically, transforming the test algorithm to backward chaining. The results are only comparable to other backward chaining rule engines or ports of Manners.\n• Removing the context so the rule engine matches the guests and seats prematurely. A proper port will prevent facts from matching using the context start.\n• It’s possible to prevent the rule engine from performing combinatorial pattern matching.\n• If no facts are retracted in the reasoning cycle, as a result of the CE, the port is incorrect. The Manners benchmark was written for OPS5 which has two conflict resolution strategies, LEX and MEA.\n\n LEX is a chain of several strategies including salience, recency and complexity.\n\n The recency part of the strategy drives the depth first (LIFO) firing order.\n\n The CLIPS manual documents the Recency strategy as follows: Every fact and instance is marked internally with a \"time tag\" to indicate its relative recency with respect to every other fact and instance in the system.\n\n The pattern entities associated with each rule activation are sorted in descending order for determining placement.\n\n An activation with a more recent pattern entity is placed before activations with less recent pattern entities.\n\n To determine the placement order of two activations, compare the sorted time tags of the two activations one by one starting with the largest time tags.\n\n The comparison should continue until one activation’s time tag is greater than the other activation’s corresponding time tag.\n\n The activation with the greater time tag is placed before the other activation on the agenda.\n\n If one activation has more pattern entities than the other activation and the compared time tags are all identical, then the activation with more time tags is placed before the other activation on the agenda. However Jess and CLIPS both use the Depth strategy, which is simpler and lighter, which Drools also adopted.\n\n The CLIPS manual documents the Depth strategy as: Newly activated rules are placed above all rules of the same salience.\n\n For example, given that fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda.\n\n However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary. The initial Drools implementation for the Depth strategy would not work for Manners without the use of salience on the \"make_path\" rule.\n\n The CLIPS support team had this to say: The default conflict resolution strategy for CLIPS, Depth, is different than the default conflict resolution strategy used by OPS5.\n\n Therefore if you directly translate an OPS5 program to CLIPS, but use the default depth conflict resolution strategy, you’re only likely to get the correct behavior by coincidence.\n\n The LEX and MEA conflict resolution strategies are provided in CLIPS to allow you to quickly convert and correctly run an OPS5 program in CLIPS. Investigation into the CLIPS code reveals there is undocumented functionality in the Depth strategy.\n\n There is an accumulated time tag used in this strategy; it’s not an extensively fact by fact comparison as in the recency strategy, it simply adds the total of all the time tags for each activation and compares. Once the context is changed to , activations are created for all asserted guest.\n\n Because all activations are created as the result of a single Working Memory action, they all have the same Activation time tag.\n\n The last asserted object would have a higher fact time tag, and its Activation would fire because it has the highest accumulated fact time tag.\n\n The execution order in this rule has little importance, but has a big impact in the rule \"Assign Seat\". The activation fires and asserts the first arrangement and a , and then sets the attribute to create an activation for rule . rule assignFirstSeat when context : Context( state == Context.START_UP ) guest : Guest() count : Count() then String guestName = guest.getName(); Seating seating = new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName); insert( seating ); Path path = new Path( count.getValue(), 1, guestName ); insert( path ); modify( count ) { setValue ( count.getValue() + 1 ) } System.out.println( \"assign first seat : \" + seating + \" : \" + path ); modify( context ) { setState( Context.ASSIGN_SEATS ) } end This rule determines each of the arrangements.\n\n The rule creates cross product solutions for all asserted arrangements against all the asserted guests except against itself or any already assigned chosen solutions. rule findSeating when context : Context( state == Context.ASSIGN_SEATS ) $s : Seating( pathDone == true ) $g1 : Guest( name == $s.rightGuestName ) $g2 : Guest( sex != $g1.sex, hobby == $g1.hobby ) count : Count() not ( Path( id == $s.id, guestName == $g2.name) ) not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) ) then int rightSeat = $s.getRightSeat(); int seatId = $s.getId(); int countValue = count.getValue(); Seating seating = new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ); insert( seating ); Path path = new Path( countValue, rightSeat + 1, $g2.getName() ); insert( path ); Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() ); insert( chosen ); System.err.println( \"find seating : \" + seating + \" : \" + path + \" : \" + chosen); modify( count ) {setValue( countValue + 1 )} modify( context ) {setState( Context.MAKE_PATH )} end However, as can be seen from the printed results shown earlier, it is essential that only the with the highest cross product be chosen.\n\n How can this be possible if we have activations, of the same time tag, for nearly all existing and objects? For example, on the third iteration of the produced activations will be as shown below.\n\n Remember, this is from a very small data set, and with larger data sets there would be many more possible activated solutions, with multiple solutions per : The creation of all these redundant activations might seem pointless, but it must be remembered that Manners is not about good rule design; it’s purposefully designed as a bad ruleset to fully stress-test the cross product matching process and the Agenda, which this clearly does.\n\n Notice that each activation has the same time tag of 35, as they were all activated by the change in the object to .\n\n With OPS5 and LEX it would correctly fire the activation with the asserted last.\n\n With Depth, the accumulated fact time tag ensures that the activation with the last asserted fires. Rule must always fire before .\n\n A object is asserted for each arrangement, up to the last asserted .\n\n Notice that the conditions in are a subset of those in - so how do we ensure that fires first? rule makePath when Context( state == Context.MAKE_PATH ) Seating( seatingId:id, seatingPid:pid, pathDone == false ) Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat ) not Path( id == seatingId, guestName == pathGuestName ) then insert( new Path( seatingId, pathSeat, pathGuestName ) ); end Both rules end up on the Agenda in conflict and with identical activation time tags.\n\n However, the accumulate fact time tag is greater for \"Make Path\" so it gets priority. Rule only activates when the last seat is assigned, at which point both rules will be activated.\n\n For the same reason that always wins over , will take priority over rule . Assign First seat =>[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] =>[fid:14:14]:[Path id=1, seat=1, guest=n5] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1 , pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]* Assign Seating =>[fid:15:17] :[Seating id=2 , pid=1 , done=false, ls=1, lg=n5, rs=2, rn=n4] =>[fid:16:18]:[Path id=2, seat=2, guest=n4] =>[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1] =>[ActivationCreated(21): rule=makePath [fid:15:17] : [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] [fid:14:14] : [Path id=1, seat=1, guest=n5]* ==>[ActivationCreated(21): rule=pathDone [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]* Make Path =>[fid:18:22:[Path id=2, seat=1, guest=n5]] Path Done Continue Process =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:7:7]:[Guest name=n4, sex=f, hobbies=h3] [fid:4:4] : [Guest name=n3, sex=m, hobbies=h3]* =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3] =>[ActivationCreated(25): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]] =>[fid:20:27]:[Path id=3, seat=3, guest=n3]] =>[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}] =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:18:22]:[Path id=2, seat=1, guest=n5]* =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:16:18]:[Path id=2, seat=2, guest=n4]* =>[ActivationCreated(30): rule=done [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]* Make Path =>[fid:22:31]:[Path id=3, seat=1, guest=n5] Make Path =>[fid:23:32] [Path id=3, seat=2, guest=n4] Path Done Continue Processing =>[ActivationCreated(35): rule=findSeating [fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] [fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest name=n2, sex=f, hobbies=h3], [fid:12:29]* =>[ActivationCreated(35): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(35): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]] =>[fid:25:37]:[Path id=4, seat=4, guest=n2]] =>[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3] ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:23:32]:[Path id=3, seat=2, guest=n4]* ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:20:27]:[Path id=3, seat=3, guest=n3]* =>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:22:31]:[Path id=3, seat=1, guest=n5]* =>[ActivationCreated(40): rule=done [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]* Make Path =>fid:27:41:[Path id=4, seat=2, guest=n4] Make Path =>fid:28:42]:[Path id=4, seat=1, guest=n5]] Make Path =>fid:29:43]:[Path id=4, seat=3, guest=n3]] Path Done Continue Processing =>[ActivationCreated(46): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1], [fid:2:2] [Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(46): rule=findSeating [fid:24:44]:[Seating id=4, pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]* =>[ActivationCreated(46): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:30:47]:[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1] =>[fid:31:48]:[Path id=5, seat=5, guest=n1] =>[fid:32:49]:[Chosen id=4, name=n1, hobbies=h1] A backward-chaining rule system is goal-driven.\n\n This means the system starts with a conclusion which the engine tries to satisfy.\n\n If it cannot do so it searches for sub-goals, that is, conclusions that will complete part of the current goal.\n\n It continues this process until either the initial conclusion is satisfied or there are no more unsatisfied sub-goals. Prolog is an example of a backward-chaining engine. Backward-Chaining is a feature recently added to the JBoss Rules Engine.\n\n This process is often referred to as derivation queries, and it is not as common compared to reactive systems since JBoss Rules is primarily reactive forward chaining.\n\n That is, it responds to changes in your data.\n\n The backward-chaining added to the engine is for product-like derivations. The previous chart demonstrates a House example of transitive items.\n\n A similar reasoning chart can be created by implementing the following rules: 1.\n\n First, create some java rules to develop reasoning for transitive items.\n\n It inserts each of the locations. 2.\n\n Next, create the Location class; it has the item and where it is located. 3.\n\n Type the rules for the House example as depicted below: ksession.insert( new Location(\"office\", \"house\") ); ksession.insert( new Location(\"kitchen\", \"house\") ); ksession.insert( new Location(\"knife\", \"kitchen\") ); ksession.insert( new Location(\"cheese\", \"kitchen\") ); ksession.insert( new Location(\"desk\", \"office\") ); ksession.insert( new Location(\"chair\", \"office\") ); ksession.insert( new Location(\"computer\", \"desk\") ); ksession.insert( new Location(\"drawer\", \"desk\") ); 4.\n\n A transitive design is created in which the item is in its designated location such as a \"desk\" located in an \"office.\" 1.\n\n Create a query to look at the data inserted into the rules engine: Notice how the query is recursive and is calling \"isContainedIn.\" 2.\n\n Create a rule to print out every string inserted into the system to see how things are implemented.\n\n The rule should resemble the following format: rule \"go\" salience 10 when $s : String( ) then System.out.println( $s ); end 3.\n\n Using Step 2 as a model, create a rule that calls upon the Step 1 query \"isContainedIn.\" rule \"go1\" when String( this == \"go1\" ) isContainedIn(\"office\", \"house\"; ) then System.out.println( \"office is in the house\" ); end The \"go1\" rule will fire when the first string is inserted into the engine.\n\n That is, it asks if the item \"office\" is in the location \"house.\" Therefore, the Step 1 query is evoked by the previous rule when the \"go1\" String is inserted. 4.\n\n Create the \"go1,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go1\" ); ksession.fireAllRules(); --- go1 office is in the house The --- line indicates the separation of the output of the engine from the firing of the \"go\" rule and the \"go1\" rule. 1.\n\n Create a Transitive Closure by implementing the following rule: rule \"go2\" when String( this == \"go2\" ) isContainedIn(\"drawer\", \"house\"; ) then System.out.println( \"Drawer in the House\" ); end 2.\n\n Recall from the Cloning Transitive Closure’s topic, there was no instance of \"drawer\" in \"house.\" \"drawer\" was located in \"desk.\" 3.\n\n Use the previous query for this recursive information. 4.\n\n Create the \"go2,\" insert it into the engine, and call the fireAllRules. When the rule is fired, it correctly tells you \"go2\" has been inserted and that the \"drawer\" is in the \"house.\" 5.\n\n Check how the engine determined this outcome\n• The query has to recurse down several levels to determine this.\n• Instead of using Location( x, y; ), The query uses the value of (z, y; ) since \"drawer\" is not in \"house.\"\n• The z is currently unbound which means it has no value and will return everything that is in the argument.\n• y is currently bound to \"house,\" so z will return \"office\" and \"kitchen.\"\n• Information is gathered from \"office\" and checks recursively if the \"drawer\" is in the \"office.\" The following query line is being called for these parameters: isContainedIn (x ,z; ) There is no instance of \"drawer\" in \"office;\" therefore, it does not match.\n\n With z being unbound, it will return data that is within the \"office,\" and it will gather that z == desk. isContainedIn recurses three times.\n\n On the final recurse, an instance triggers of \"drawer\" in the \"desk.\" This matches on the first location and recurses back up, so we know that \"drawer\" is in the \"desk,\" the \"desk\" is in the \"office,\" and the \"office\" is in the \"house;\" therefore, the \"drawer\" is in the \"house\" and returns true. 1.\n\n Create a Reactive Transitive Query by implementing the following rule: rule \"go3\" when String( this == \"go3\" ) isContainedIn(\"key\", \"office\"; ) then System.out.println( \"Key in the Office\" ); end Reactive Transitive Queries can ask a question even if the answer can not be satisfied.\n\n Later, if it is satisfied, it will return an answer. 2.\n\n Use the same query for this reactive information. 3.\n\n Create the \"go3,\" insert it into the engine, and call the fireAllRules. The first rule that matches any String returns \"go3\" but nothing else is returned because there is no answer; however, while \"go3\" is inserted in the system, it will continuously wait until it is satisfied. 4.\n\n Insert a new location of \"key\" in the \"drawer\": ksession.insert( new Location(\"key\", \"drawer\") ); ksession.fireAllRules(); --- Key in the Office This new location satisfies the transitive closure because it is monitoring the entire graph.\n\n In addition, this process now has four recursive levels in which it goes through to match and fire the rule. 1.\n\n Create a Query with Unbound Arguments by implementing the following rule: rule \"go4\" when String( this == \"go4\" ) isContainedIn(thing, \"office\"; ) then System.out.println( \"thing\" + thing + \"is in the Office\" ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below.\n\n The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. 2.\n\n Use the query for the unbound arguments. 3.\n\n Create the \"go4,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go4\" ); ksession.fireAllRules(); --- go4 thing Key is in the Office thing Computer is in the Office thing Drawer is in the Office thing Desk is in the Office thing Chair is in the Office When \"go4\" is inserted, it returns all the previous information that is transitively below \"Office.\" 1.\n\n Create a query with Mulitple Unbound Arguments by implementing the following rule: rule \"go5\" when String( this == \"go5\" ) isContainedIn(thing, location; ) then System.out.println( \"thing\" + thing + \"is in\" + location ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below.\n\n The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. Both thing and location are unbound out variables, and without bound arguments, everything is called upon. 2.\n\n Use the query for multiple unbound arguments. 3.\n\n Create the \"go5,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go5\" ); ksession.fireAllRules(); --- go5 thing Knife is in House thing Cheese is in House thing Key is in House thing Computer is in House thing Drawer is in House thing Desk is in House thing Chair is in House thing Key is in Office thing Computer is in Office thing Drawer is in Office thing Key is in Desk thing Office is in House thing Computer is in Desk thing Knife is in Kitchen thing Cheese is in Kitchen thing Kitchen is in House thing Key is in Drawer thing Drawer is in Desk thing Desk is in Office thing Chair is in Office When \"go5\" is called, it returns everything within everything."
    },
    {
        "link": "https://docs.drools.org/7.4.1.Final/drools-docs/html_single",
        "document": "So where do we get started? There are so many use cases and so much functionality in a rule engine such as Drools that it becomes beguiling. Have no fear my intrepid adventurer, the complexity is layered and you can ease yourself in with simple use cases. Stateless session, not utilising inference, forms the simplest use case. A stateless session can be called like a function passing it some data and then receiving some results back. Some common use cases for stateless sessions are, but not limited to:\n• \n• Is this person eligible for a mortgage?\n• \n• Filter incoming messages, such as emails, into folders. So let’s start with a very simple example using a driving license application. public class Applicant { private String name; private int age; private boolean valid; // getter and setter methods here } Now that we have our data model we can write our first rule. We assume that the application uses rules to reject invalid applications. As this is a simple validation use case we will add a single rule to disqualify any applicant younger than 18. package com.company.license rule \"Is of valid age\" when $a : Applicant( age < 18 ) then $a.setValid( false ); end To make the engine aware of data, so it can be processed against the rules, we have to insert the data, much like with a database. When the Applicant instance is inserted into the engine it is evaluated against the constraints of the rules, in this case just two constraints for one rule. We say two because the type Applicant is the first object type constraint, and is the second field constraint. An object type constraint plus its zero or more field constraints is referred to as a pattern. When an inserted instance satisfies both the object type constraint and all the field constraints, it is said to be matched. The is a binding variable which permits us to reference the matched object in the consequence. There its properties can be updated. The dollar character ('$') is optional, but it helps to differentiate variable names from field names. The process of matching patterns against the inserted data is, not surprisingly, often referred to as pattern matching. To use this rule it is necessary to put it a Drools file, just a plain text file with .drl extension , short for \"Drools Rule Language\". Let’s call this file licenseApplication.drl, and store it in a Kie Project. A Kie Project has the structure of a normal Maven project with an additional file (kmodule.xml) defining the s and s that can be created. This file has to be placed in the resources/META-INF folder of the Maven project while all the other Drools artifacts, such as the licenseApplication.drl containing the former rule, must be stored in the resources folder or in any other subfolder under it. Since meaningful defaults have been provided for all configuration aspects, the simplest kmodule.xml file can contain just an empty kmodule tag like the following: At this point it is possible to create a that reads the files to be built, from the classpath. The above code snippet compiles all the DRL files found on the classpath and put the result of this compilation, a , in the . If there are no errors, we are now ready to create our session from the and execute against some data: The preceding code executes the data against the rules. Since the applicant is under the age of 18, the application is marked as invalid. So far we’ve only used a single instance, but what if we want to use more than one? We can execute against any object implementing Iterable, such as a collection. Let’s add another class called , which has the date of the application, and we’ll also move the boolean valid field to the class. public class Applicant { private String name; private int age; // getter and setter methods here } public class Application { private Date dateApplied; private boolean valid; // getter and setter methods here } We will also add another rule to validate that the application was made within a period of time. package com.company.license rule \"Is of valid age\" when Applicant( age < 18 ) $a : Application() then $a.setValid( false ); end rule \"Application was made this year\" when $a : Application( dateApplied > \"01-jan-2009\" ) then $a.setValid( false ); end Unfortunately a Java array does not implement the interface, so we have to use the JDK converter method . The code shown below executes against an iterable list, where all collection elements are inserted before any matched rules are fired. StatelessKieSession kSession = kContainer.newStatelessKieSession(); Applicant applicant = new Applicant( \"Mr John Smith\", 16 ); Application application = new Application(); assertTrue( application.isValid() ); ksession.execute( Arrays.asList( new Object[] { application, applicant } ) ); assertFalse( application.isValid() ); The two execute methods and are actually convenience methods for the interface 's method . The commands factory, obtainable from the like all other factories of the KIE API, is used to create commands, so that the following is equivalent to : Batch Executor and Command Factory are particularly useful when working with multiple Commands and with output identifiers for obtaining results. KieCommands kieCommands = kieServices.getCommands(); List<Command> cmds = new ArrayList<Command>(); cmds.add( kieCommands.newInsert( new Person( \"Mr John Smith\" ), \"mrSmith\", true, null ) ); cmds.add( kieCommands.newInsert( new Person( \"Mr John Doe\" ), \"mrDoe\", true, null ) ); BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) ); assertEquals( new Person( \"Mr John Smith\" ), results.getValue( \"mrSmith\" ) ); supports many other Commands that can be used in the like , , and . Stateful Sessions are long lived and allow iterative changes over time. Some common use cases for Stateful Sessions are, but not limited to: In contrast to a Stateless Session, the method must be called afterwards to ensure there are no memory leaks, as the KieBase contains references to Stateful Knowledge Sessions when they are created. Since Stateful Knowledge Session is the most commonly used session type it is just named in the KIE API. also supports the interface, like , the only difference being that the command is not automatically called at the end for a Stateful Session. We illustrate the monitoring use case with an example for raising a fire alarm. Using just four classes, we represent rooms in a house, each of which has one sprinkler. If a fire starts in a room, we represent that with a single instance. public class Room { private String name // getter and setter methods here } public class Sprinkler { private Room room; private boolean on; // getter and setter methods here } public class Fire { private Room room; // getter and setter methods here } public class Alarm { } In the previous section on Stateless Sessions the concepts of inserting and matching against data were introduced. That example assumed that only a single instance of each object type was ever inserted and thus only used literal constraints. However, a house has many rooms, so rules must express relationships between objects, such as a sprinkler being in a certain room. This is best done by using a binding variable as a constraint in a pattern. This \"join\" process results in what is called cross products, which are covered in the next section. When a fire occurs an instance of the class is created, for that room, and inserted into the session. The rule uses a binding on the field of the object to constrain matching to the sprinkler for that room, which is currently off. When this rule fires and the consequence is executed the sprinkler is turned on. rule \"When there is a fire turn on the sprinkler\" when Fire($room : room) $sprinkler : Sprinkler( room == $room, on == false ) then modify( $sprinkler ) { setOn( true ) }; System.out.println( \"Turn on the sprinkler for room \" + $room.getName() ); end Whereas the Stateless Session uses standard Java syntax to modify a field, in the above rule we use the statement, which acts as a sort of \"with\" statement. It may contain a series of comma separated Java expressions, i.e., calls to setters of the object selected by the statement’s control expression. This modifies the data, and makes the engine aware of those changes so it can reason over them once more. This process is called inference, and it’s essential for the working of a Stateful Session. Stateless Sessions typically do not use inference, so the engine does not need to be aware of changes to data. Inference can also be turned off explicitly by using the sequential mode. So far we have rules that tell us when matching data exists, but what about when it does not exist? How do we determine that a fire has been extinguished, i.e., that there isn’t a object any more? Previously the constraints have been sentences according to Propositional Logic, where the engine is constraining against individual instances. Drools also has support for First Order Logic that allows you to look at sets of data. A pattern under the keyword matches when something does not exist. The rule given below turns the sprinkler off as soon as the fire in that room has disappeared. rule \"When the fire is gone turn off the sprinkler\" when $room : Room( ) $sprinkler : Sprinkler( room == $room, on == true ) not Fire( room == $room ) then modify( $sprinkler ) { setOn( false ) }; System.out.println( \"Turn off the sprinkler for room \" + $room.getName() ); end While there is one sprinkler per room, there is just a single alarm for the building. An object is created when a fire occurs, but only one is needed for the entire building, no matter how many fires occur. Previously was introduced to match the absence of a fact; now we use its complement which matches for one or more instances of some category. rule \"Raise the alarm when we have one or more fires\" when exists Fire() then insert( new Alarm() ); System.out.println( \"Raise the alarm\" ); end Likewise, when there are no fires we want to remove the alarm, so the keyword can be used again. rule \"Cancel the alarm when all the fires have gone\" when not Fire() $alarm : Alarm() then delete( $alarm ); System.out.println( \"Cancel the alarm\" ); end Finally there is a general health status message that is printed when the application first starts and after the alarm is removed and all sprinklers have been turned off. rule \"Status output when things are ok\" when not Alarm() not Sprinkler( on == true ) then System.out.println( \"Everything is ok\" ); end As we did in the Stateless Session example, the above rules should be placed in a single DRL file and saved into the resouces folder of your Maven project or any of its subfolder. As before, we can then obtain a from the . The only difference is that this time we create a Stateful Session, whereas before we created a Stateless Session. With the session created it is now possible to iteratively work with it over time. Four objects are created and inserted, as well as one object for each room. At this point the engine has done all of its matching, but no rules have fired yet. Calling allows the matched rules to fire, but without a fire that will just produce the health message. String[] names = new String[]{\"kitchen\", \"bedroom\", \"office\", \"livingroom\"}; Map<String,Room> name2room = new HashMap<String,Room>(); for( String name: names ){ Room room = new Room( name ); name2room.put( name, room ); ksession.insert( room ); Sprinkler sprinkler = new Sprinkler( room ); ksession.insert( sprinkler ); } ksession.fireAllRules(); > Everything is ok We now create two fires and insert them; this time a reference is kept for the returned . A Fact Handle is an internal engine reference to the inserted instance and allows instances to be retracted or modified at a later point in time. With the fires now in the engine, once is called, the alarm is raised and the respective sprinklers are turned on. > Raise the alarm > Turn on the sprinkler for room kitchen > Turn on the sprinkler for room office After a while the fires will be put out and the instances are retracted. This results in the sprinklers being turned off, the alarm being cancelled, and eventually the health message is printed again. > Cancel the alarm > Turn off the sprinkler for room office > Turn off the sprinkler for room kitchen > Everything is ok Everyone still with me? That wasn’t so hard and already I’m hoping you can start to see the value and power of a declarative rule system. People often confuse methods and rules, and new rule users often ask, \"How do I call a rule?\" After the last section, you are now feeling like a rule expert and the answer to that is obvious, but let’s summarize the differences nonetheless. rule \"Hello World\" when Person( name == \"Chuck\" ) then System.out.println( \"Hello Chuck\" ); end\n• Rules execute by matching against any data as long it is inserted into the engine.\n• Rules can never be called directly.\n• Specific instances cannot be passed to a rule.\n• Depending on the matches, a rule may fire once or several times, or not at all. Earlier the term \"cross product\" was mentioned, which is the result of a join. Imagine for a moment that the data from the fire alarm example were used in combination with the following rule where there are no field constraints: In SQL terms this would be like doing and every row in the Room table would be joined with every row in the Sprinkler table resulting in the following output: These cross products can obviously become huge, and they may very well contain spurious data. The size of cross products is often the source of performance problems for new rule authors. From this it can be seen that it’s always desirable to constrain the cross products, which is done with the variable constraint. This results in just four rows of data, with the correct Sprinkler for each Room. In SQL (actually HQL) the corresponding query would be . The Agenda is a Rete feature. It maintains set of rules that are able to execute, its job is to schedule that execution in a deterministic order. During actions on the , rules may become fully matched and eligible for execution; a single Rule Runtime Action can result in multiple eligible rules. When a rule is fully matched a Rule Match is created, referencing the rule and the matched facts, and placed onto the Agenda. The Agenda controls the execution order of these Matches using a Conflict Resolution strategy. The engine cycles repeatedly through two phases:\n• Rule Runtime Actions. This is where most of the work takes place, either in the Consequence (the RHS itself) or the main Java application process. Once the Consequence has finished or the main Java application process calls the engine switches to the Agenda Evaluation phase.\n• Agenda Evaluation. This attempts to select a rule to fire. If no rule is found it exits, otherwise it fires the found rule, switching the phase back to Rule Runtime Actions. The process repeats until the agenda is clear, in which case control returns to the calling application. When Rule Runtime Actions are taking place, no rules are being fired. So far the data and the matching process has been simple and small. To mix things up a bit a new example will be explored that handles cashflow calculations over date periods. The state of the engine will be illustratively shown at key stages to help get a better understanding of what is actually going on under the hood. Three classes will be used, as shown below. This will help us grow our understanding of pattern matching and joins further. We will then use this to illustrate different techniques for execution control. public class CashFlow { private Date date; private double amount; private int type; long accountNo; // getter and setter methods here } public class Account { private long accountNo; private double balance; // getter and setter methods here } public AccountPeriod { private Date start; private Date end; // getter and setter methods here } By now you already know how to create KieBases and how to instantiate facts to populate the , so tables will be used to show the state of the inserted data, as it makes things clearer for illustration purposes. The tables below show that a single fact was inserted for the . Also inserted are a series of debits and credits as objects for that account, extending over two quarters. Two rules can be used to determine the debit and credit for that quarter and update the Account balance. The two rules below constrain the cashflows for an account for a given time period. Notice the \"&&\" which use short cut syntax to avoid repeating the field name twice. rule \"increase balance for credits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"decrease balance for debits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == DEBIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance -= $amount; end Earlier we showed how rules would equate to SQL, which can often help people with an SQL background to understand rules. The two rules above can be represented with two views and a trigger for each view, as below: select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == CREDIT and cf.date >= ap.start and cf.date <= ap.end select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == DEBIT and cf.date >= ap.start and cf.date <= ap.end If the is set to the first quarter we constrain the rule \"increase balance for credits\" to fire on two rows of data and \"decrease balance for debits\" to act on one row of data. The two cashflow tables above represent the matched data for the two rules. The data is matched during the insertion stage and, as you discovered in the previous chapter, does not fire straight away, but only after is called. Meanwhile, the rule plus its matched data is placed on the Agenda and referred to as an RuIe Match or Rule Instance. The Agenda is a table of Rule Matches that are able to fire and have their consequences executed, as soon as fireAllRules() is called. Rule Matches on the Agenda are referred to as a conflict set and their execution is determine by a conflict resolution strategy. Notice that the order of execution so far is considered arbitrary. After all of the above activations are fired, the account has a balance of -25. If the is updated to the second quarter, we have just a single matched row of data, and thus just a single Rule Match on the Agenda. The firing of that Activation results in a balance of 25. What if you don’t want the order of rule execution to be arbitrary? When there is one or more Rule Match on the Agenda they are said to be in conflict, and a conflict resolution strategy is used to determine the order of execution. The Drools strategy is very simple and based around a salience value, which assigns a priority to a rule. Each rule has a default value of 0, the higher the value the higher the priority. As a general rule, it is a good idea not to count on rules firing in any particular order, and to author the rules without worrying about a \"flow\". However when a flow is needed a number of possibilities exist beyond salience: agenda groups, rule flow groups, activation groups and control/semaphore facts. As of Drools 6.0 rule definition order in the source file is used to set priority after salience. To illustrate Salience we add a rule to print the account balance, where we want this rule to be executed after all the debits and credits have been applied for all accounts. We achieve this by assigning a negative salience to this rule so that it fires after all rules with the default salience 0. rule \"Print balance for AccountPeriod\" salience -50 when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end The table below depicts the resulting Agenda. The three debit and credit rules are shown to be in arbitrary order, while the print rule is ranked last, to execute afterwards. Agenda groups allow you to place rules into groups, and to place those groups onto a stack. The stack has push/pop bevaviour. Calling \"setFocus\" places the group onto the stack: The agenda always evaluates the top of the stack. When all the rules have fired for a group, it is popped from the stack and the next group is evaluated. rule \"increase balance for credits\" agenda-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" agenda-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end First set the focus to the \"report\" group and then by placing the focus on \"calculation\" we ensure that group is evaluated first. Drools also features ruleflow-group attributes which allows workflow diagrams to declaratively specify when rules are allowed to fire. The screenshot below is taken from Eclipse using the Drools plugin. It has two ruleflow-group nodes which ensures that the calculation rules are executed before the reporting rules. The use of the ruleflow-group attribute in a rule is shown below. rule \"increase balance for credits\" ruleflow-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" ruleflow-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end Inference has a bad name these days, as something not relevant to business use cases and just too complicated to be useful. It is true that contrived and complicated examples occur with inference, but that should not detract from the fact that simple and useful ones exist too. But more than this, correct use of inference can crate more agile and less error prone business rules, which are easier to maintain. So what is inference? Something is inferred when we gain knowledge of something from using previous knowledge. For example, given a Person fact with an age field and a rule that provides age policy control, we can infer whether a Person is an adult or a child and act on this. rule \"Infer Adult\" when $p : Person( age >= 18 ) then insert( new IsAdult( $p ) ) end Due to the preceding rule, every Person who is 18 or over will have an instance of IsAdult inserted for them. This fact is special in that it is known as a relation. We can use this inferred relation in any rule: So now we know what inference is, and have a basic example, how does this facilitate good rule design and maintenance? Let’s take a government department that are responsible for issuing ID cards when children become adults, henceforth referred to as ID department. They might have a decision table that includes logic like this, which says when an adult living in London is 18 or over, issue the card: However the ID department does not set the policy on who an adult is. That’s done at a central government level. If the central government were to change that age to 21, this would initiate a change management process. Someone would have to liaise with the ID department and make sure their systems are updated, in time for the law going live. This change management process and communication between departments is not ideal for an agile environment, and change becomes costly and error prone. Also the card department is managing more information than it needs to be aware of with its \"monolithic\" approach to rules management which is \"leaking\" information better placed elsewhere. By this I mean that it doesn’t care what explicit age ▸ = 18 information determines whether someone is an adult, only that they are an adult. In contrast to this, let’s pursue an approach where we split (de-couple) the authoring responsibilities, so that both the central government and the ID department maintain their own rules. It’s the central government’s job to determine who is an adult. If they change the law they just update their central repository with the new rules, which others use: The IsAdult fact, as discussed previously, is inferred from the policy rules. It encapsulates the seemingly arbitrary piece of logic age ▸ = 18 and provides semantic abstractions for its meaning. Now if anyone uses the above rules, they no longer need to be aware of explicit information that determines whether someone is an adult or not. They can just use the inferred fact: While the example is very minimal and trivial it illustrates some important points. We started with a monolithic and leaky approach to our knowledge engineering. We created a single decision table that had all possible information in it and that leaks information from central government that the ID department did not care about and did not want to manage. We first de-coupled the knowledge process so each department was responsible for only what it needed to know. We then encapsulated this leaky knowledge using an inferred fact IsAdult. The use of the term IsAdult also gave a semantic abstraction to the previously arbitrary logic age ▸ = 18. So a general rule of thumb when doing your knowledge engineering is: After regular inserts you have to retract facts explicitly. With logical assertions, the fact that was asserted will be automatically retracted when the conditions that asserted it in the first place are no longer true. Actually, it’s even cleverer then that, because it will be retracted only if there isn’t any single condition that supports the logical assertion. Normal insertions are said to be stated, i.e., just like the intuitive meaning of \"stating a fact\" implies. Using a and a counter, we track how many times a particular equality is stated; this means we count how many different instances are equal. When we logically insert an object during a RHS execution we are said to justify it, and it is considered to be justified by the firing rule. For each logical insertion there can only be one equal object, and each subsequent equal logical insertion increases the justification counter for this logical assertion. A justification is removed by the LHS of the creating rule becoming untrue, and the counter is decreased accordingly. As soon as we have no more justifications the logical object is automatically retracted. If we try to logically insert an object when there is an equal stated object, this will fail and return null. If we state an object that has an existing equal object that is justified we override the Fact; how this override works depends on the configuration setting . When the property is set to discard we use the existing handle and replace the existing instance with the new Object, which is the default behavior; otherwise we override it to stated but we create an new . This can be confusing on a first read, so hopefully the flow charts below help. When it says that it returns a new , this also indicates the was propagated through the network. 6.4.1.1. Bus Pass Example With Inference and TMS The previous example was issuing ID cards to over 18s, in this example we now issue bus passes, either a child or adult pass. rule \"Issue Child Bus Pass\" when $p : Person( age < 16 ) then insert(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) then insert(new AdultBusPass( $p ) ); end As before the above example is considered monolithic, leaky and providing poor separation of concerns. As before we can provide a more robust application with a separation of concerns using inference. Notice this time we don’t just insert the inferred object, we use \"insertLogical\": rule \"Infer Child\" when $p : Person( age < 16 ) then insertLogical( new IsChild( $p ) ) end rule \"Infer Adult\" when $p : Person( age >= 16 ) then insertLogical( new IsAdult( $p ) ) end A \"insertLogical\" is part of the Drools Truth Maintenance System (TMS). When a fact is logically inserted, this fact is dependant on the truth of the \"when\" clause. It means that when the rule becomes false the fact is automatically retracted. This works particularly well as the two rules are mutually exclusive. So in the above rules if the person is under 16 it inserts an IsChild fact, once the person is 16 or over the IsChild fact is automatically retracted and the IsAdult fact inserted. Returning to the code to issue bus passes, these two rules can + logically insert the ChildBusPass and AdultBusPass facts, as the TMS + supports chaining of logical insertions for a cascading set of retracts. rule \"Issue Child Bus Pass\" when $p : Person( ) IsChild( person == $p ) then insertLogical(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) IsAdult( person =$p ) then insertLogical(new AdultBusPass( $p ) ); end Now when a person changes from being 15 to 16, not only is the IsChild fact automatically retracted, so is the person’s ChildBusPass fact. For bonus points we can combine this with the 'not' conditional element to handle notifications, in this situation, a request for the returning of the pass. So when the TMS automatically retracts the ChildBusPass object, this rule triggers and sends a request to the person: rule \"Return ChildBusPass Request \"when $p : Person( ) not( ChildBusPass( person == $p ) ) then requestChildBusPass( $p ); end It is important to note that for Truth Maintenance (and logical assertions) to work at all, your Fact objects (which may be JavaBeans) must override equals and hashCode methods (from java.lang.Object) correctly. As the truth maintenance system needs to know when two different physical objects are equal in value, both equals and hashCode must be overridden correctly, as per the Java standard. Two objects are equal if and only if their equals methods return true for each other and if their hashCode methods return the same values. See the Java API for more details (but do keep in mind you MUST override both equals and hashCode). TMS behaviour is not affected by theruntime configuration of Identity vs Equality, TMS is always equality. 6.4.1.3. Deleting stated or logically asserted facts from the working memory By default when a fact is deleted from the working memory Drools attempts to remove it both from the set of stated facts and also from the Truth Maintenance System in case it has been logically asserted. However, using an overload of the delete method, it is also possible to remove it only from one of the 2. For instance invoking: the fact is removed only if it has been logically asserted, but not if it is a stated fact. In this case, if the fact has been stated its deletion fails silently and it is ignored. Decision tables are a \"precise yet compact\" (ref. Wikipedia) way of representing conditional logic, and are well suited to business level rules. Drools supports managing rules in a spreadsheet format. Supported formats are Excel (XLS), and CSV, which means that a variety of spreadsheet programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can be utilized. It is expected that web based decision table editors will be included in a near future release. Decision tables are an old concept (in software terms) but have proven useful over the years. Very briefly speaking, in Drools decision tables are a way to generate rules driven from the data entered into a spreadsheet. All the usual features of a spreadsheet for data capture and manipulation can be taken advantage of. 6.5.1. When to Use Decision Tables Consider decision tables as a course of action if rules exist that can be expressed as rule templates and data: each row of a decision table provides data that is combined with a template to generate a rule. Many businesses already use spreadsheets for managing data, calculations, etc. If you are happy to continue this way, you can also manage your business rules this way. This also assumes you are happy to manage packages of rules in .xls or .csv files. Decision tables are not recommended for rules that do not follow a set of templates, or where there are a small number of rules (or if there is a dislike towards software like Excel or OpenOffice.org). They are ideal in the sense that there can be control over what parameters of rules can be edited, without exposing the rules directly. Decision tables also provide a degree of insulation from the underlying object model. Here are some examples of real world decision tables (slightly edited to protect the innocent). In the above examples, the technical aspects of the decision table have been collapsed away (using a standard spreadsheet feature). The rules start from row 17, with each row resulting in a rule. The conditions are in columns C, D, E, etc., the actions being off-screen. The values in the cells are quite simple, and their meaning is indicated by the headers in Row 16. Column B is just a description. It is customary to use color to make it obvious what the different areas of the table mean. Note that although the decision tables look like they process top down, this is not necessarily the case. Ideally, rules are authored without regard for the order of rows, simply because this makes maintenance easier, as rows will not need to be shifted around all the time. As each row is a rule, the same principles apply. As the rule engine processes the facts, any rules that match may fire. (Some people are confused by this. It is possible to clear the agenda when a rule fires and simulate a very simple decision table where only the first match effects an action.) Also note that you can have multiple tables on one spreadsheet. This way, rules can be grouped where they share common templates, yet at the end of the day they are all combined into one rule package. Decision tables are essentially a tool to generate DRL rules automatically. Figure 141. A real world example using multiple tables for grouping like rules The key point to keep in mind is that in a decision table each row is a rule, and each column in that row is either a condition or action for that rule. The spreadsheet looks for the RuleTable keyword to indicate the start of a rule table (both the starting row and column). Other keywords are also used to define other package level attributes (covered later). It is important to keep the keywords in one column. By convention the second column (\"B\") is used for this, but it can be any column (convention is to leave a margin on the left for notes). In the following diagram, C is actually the column where it starts. Everything to the left of this is ignored. If we expand the hidden sections, it starts to make more sense how it works; note the keywords in column C. Now the hidden magic which makes it work can be seen. The RuleSet keyword indicates the name to be used in the rule package that will encompass all the rules. This name is optional, using a default, but it must have the RuleSet keyword in the cell immediately to the right. The other keywords visible in Column C are Import and Sequential which will be covered later. The RuleTable keyword is important as it indicates that a chunk of rules will follow, based on some rule templates. After the RuleTable keyword there is a name, used to prefix the names of the generated rules. The sheet name and row numbers are appended to guarantee unique rule names. The RuleTable name combined with the sheet name must be unique across all spreadsheet files in the same KieBase. If that’s not the case, some rules might have the same name and only 1 of them will be applied. To show such ignored rules, raise the severity of such rule name conflicts. The column of RuleTable indicates the column in which the rules start; columns to the left are ignored. In general the keywords make up name-value pairs. Referring to row 14 (the row immediately after RuleTable), the keywords CONDITION and ACTION indicate that the data in the columns below are for either the LHS or the RHS parts of a rule. There are other attributes on the rule which can also be optionally set this way. Row 15 contains declarations of ObjectTypes . The content in this row is optional, but if this option is not in use, the row must be left blank; however this option is usually found to be quite useful. When using this row, the values in the cells below (row 16) become constraints on that object type. In the above case, it generates and , where 42 and \"stilton\" come from row 18. In the above example, the \"==\" is implicit; if just a field name is given the translator assumes that it is to generate an exact match. An ObjectType declaration can span columns (via merged cells), meaning that all columns below the merged range are to be combined into one set of constraints within a single pattern matching a single fact at a time, as opposed to non-merged cells containing the same ObjectType, but resulting in different patterns, potentially matching different or identical facts. Row 16 contains the rule templates themselves. They can use the \"$param\" placeholder to indicate where data from the cells below should be interpolated. (For multiple insertions, use \"$1\", \"$2\", etc., indicating parameters from a comma-separated list in a cell below.) Row 17 is ignored; it may contain textual descriptions of the column’s purpose. Rows 18 and 19 show data, which will be combined (interpolated) with the templates in row 15, to generate rules. If a cell contains no data, then its template is ignored. (This would mean that some condition or action does not apply for that rule row.) Rule rows are read until there is a blank row. Multiple RuleTables can exist in a sheet. Row 20 contains another keyword, and a value. The row positions of keywords like this do not matter (most people put them at the top) but their column should be the same one where the RuleTable or RuleSet keywords should appear. In our case column C has been chosen to be significant, but any other column could be used instead. In the above example, rules would be rendered like the following (as it uses the \"ObjectType\" row): The constraints and are interpreted as single constraints, to be added to the respective ObjectType in the cell above. If the cells above were spanned, then there could be multiple constraints on one \"column\". Very large decision tables may have very large memory requirements. There are two types of rectangular areas defining data that is used for generating a DRL file. One, marked by a cell labelled , defines all DRL items except rules. The other one may occur repeatedly and is to the right and below a cell whose contents begin with . These areas represent the actual decision tables, each area resulting in a set of rules of similar structure. A Rule Set area may contain cell pairs, one below the cell and containing a keyword designating the kind of value contained in the other one that follows in the same row. The columns of a Rule Table area define patterns and constraints for the left hand sides of the rules derived from it, actions for the consequences of the rules, and the values of individual rule attributes. Thus, a Rule Table area should contain one or more columns, both for conditions and actions, and an arbitrary selection of columns for rule attributes, at most one column for each of these. The first four rows following the row with the cell marked with are earmarked as header area, mostly used for the definition of code to construct the rules. It is any additional row below these four header rows that spawns another rule, with its data providing for variations in the code defined in the Rule Table header. Only the first worksheet is examined for decision tables. Entries in a Rule Set area may define DRL constructs (except rules), and specify rule attributes. While entries for constructs may be used repeatedly, each rule attribute may be given at most once, and it applies to all rules unless it is overruled by the same attribute being defined within the Rule Table area. Entries must be given in a vertically stacked sequence of cell pairs. The first one contains a keyword and the one to its right the value, as shown in the table below. This sequence of cell pairs may be interrupted by blank rows or even a Rule Table, as long as the column marked by is upheld as the one containing the keyword. The package name for the generated DRL file. Optional, the default is . \"true\" or \"false\". If \"true\", then salience is used to ensure that rules fire from the top down. Optional, at most once. If omitted, no firing order is imposed. Optional, at most once. In sequential mode, this option is used to set the start value of the salience. If omitted, the default value is 65535. Optional, at most once. In sequential mode this option is used to check if this minimum salience value is not violated. If omitted the default value is 0. \"true\" or \"false\". If \"true\", then quotation marks are escaped so that they appear literally in the DRL. Optional, at most once. If omitted, quotation marks are escaped. \"true\" or \"false\". If \"true\", then a String representation is used for DRL instead of a double value from a Numeric cell Optional, at most once. If omitted, a double value is used. Optional, may be used repeatedly. Declarations of DRL globals, i.e., a type followed by a variable name. Multiple global definitions must be separated with a comma. Optional, may be used repeatedly. One or more function definitions, according to DRL syntax. Optional, may be used repeatedly. One or more query definitions, according to DRL syntax. Optional, may be used repeatedly. One or more declarative types, according to DRL syntax. Optional, may be used repeatedly. In some locales, MS Office, LibreOffice and OpenOffice will encode a double quote differently, which will cause a compilation error. The difference is often hard to see. For example: will fail, but will work. For defining rule attributes that apply to all rules in the generated DRL file you can use any of the entries in the following table. Notice, however, that the proper keyword must be used. Also, each of these attributes may be used only once. Rule attributes specified in a Rule Set area will affect all rule assets in the same package (not only in the spreadsheet). Unless you are sure that the spreadsheet is the only one rule asset in the package, the recommendation is to specify rule attributes not in a Rule Set area but in a Rule Table columns for each rule instead. An integer defining the \"salience\" value for the rule. Overridden by the \"Sequential\" flag. A long integer value defining the \"duration\" value for the rule. A Boolean value. \"true\" enables the rule; \"false\" disables the rule. A Boolean value. \"true\" inhibits looping of rules due to changes made by its consequence. A Boolean value. \"true\" inhibits additional activations of all rules with this flag set within the same ruleflow or agenda group. A Boolean value. \"true\" for a rule within an agenda group causes activations of the rule to automatically give the focus to the group. A string identifying an activation (or XOR) group. Only one rule within an activation group will fire, i.e., the first one to fire cancels any existing activations of other rules within the same group. A string identifying an agenda group, which has to be activated by giving it the \"focus\", which is one way of controlling the flow between groups of rules. All Rule Tables begin with a cell containing \"RuleTable\", optionally followed by a string within the same cell. The string is used as the initial part of the name for all rules derived from this Rule Table, with the row number appended for distinction. (This automatic naming can be overridden by using a NAME column.) All other cells defining rules of this Rule Table are below and to the right of this cell. The next row defines the column type, with each column resulting in a part of the condition or the consequence, or providing some rule attribute, the rule name or a comment. The table below shows which column headers are available; additional columns may be used according to the table showing rule attribute entries given in the preceding section. Note that each attribute column may be used at most once. For a column header, either use the keyword or any other word beginning with the letter given in the \"Initial\" column of these tables. Provides the name for the rule generated from that row. The default is constructed from the text following the RuleTable tag and the row number. A text, resulting in a comment within the generated rule. Code snippet and interpolated values for constructing a constraint within a pattern in a condition. At least one per rule table Code snippet and interpolated values for constructing an action for the consequence of the rule. At least one per rule table Code snippet and interpolated values for constructing a metadata entry for the rule. Given a column headed CONDITION, the cells in successive lines result in a conditional element.\n• Text in the first cell below CONDITION develops into a pattern for the rule condition, with the snippet in the next line becoming a constraint. If the cell is merged with one or more neighbours, a single pattern with multiple constraints is formed: all constraints are combined into a parenthesized list and appended to the text in this cell. The cell may be left blank, which means that the code snippet in the next row must result in a valid conditional element on its own. To include a pattern without constraints, you can write the pattern in front of the text for another pattern. The pattern may be written with or without an empty pair of parentheses. A \"from\" clause may be appended to the pattern. If the pattern ends with \"eval\", code snippets are supposed to produce boolean expressions for inclusion into a pair of parentheses after \"eval\".\n• Text in the second cell below CONDITION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using \"==\" with the value from the cells below, the field selector alone is sufficient. Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A text according to the pattern delimiter snippet is expanded by repeating the snippet once for each of the values of the comma-separated list of values in each of the cells below, inserting the value in place of the symbol and by joining these expansions by the given delimiter. Note that the forall construct may be surrounded by other text.\n• If the cell in the preceding row is not empty, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below CONDITION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the conditional element or constraint for this rule. Given a column headed ACTION, the cells in successive lines result in an action statement.\n• Text in the first cell below ACTION is optional. If present, it is interpreted as an object reference.\n• Text in the second cell below ACTION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A method call without interpolation can be achieved by a text without any marker symbols. In this case, use any non-blank entry in a row below to include the statement. The forall construct is available here, too.\n• If the first cell is not empty, its text, followed by a period, the text in the second cell and a terminating semicolon are stringed together, resulting in a method call which is added as an action statement for the consequence. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below ACTION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the action statement for this rule. Using instead of works in most cases, but it will fail if the replacement text contains a comma: then, only the part preceding the first comma is inserted. Use this \"abbreviation\" judiciously. Given a column headed METADATA, the cells in successive lines result in a metadata annotation for the generated rules.\n• Text in the first cell below METADATA is ignored.\n• Text in the second cell below METADATA is subject to interpolation, as described above, using values from the cells in the rule rows. The metadata marker character is prefixed automatically, and thus it should not be included in the text for this cell.\n• Text in the third cell below METADATA is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the metadata annotation for this rule. The various interpolations are illustrated in the following example. If the template is and the cell is , then the result is . If the template is and the cell contains , the result will be . The template with a cell containing results in . The next example demonstrates the joint effect of a cell defining the pattern type and the code snippet below it. This spreadsheet section shows how the type declaration spans 2 columns, and thus both constraints will appear as . Since only the field names are present in the snippet, they imply an equality test. In the following example the marker symbol is used. The result of this column is the pattern . You may have noticed that the marker and the operator \"==\" are redundant. The next example illustrates that a trailing insertion marker can be omitted. Here, appending the value from the cell is implied, resulting in You can provide the definition of a binding variable, as in the example below. Here, the result is Note that the quotes are provided automatically. Actually, anything can be placed in the object type row. Apart from the definition of a binding variable, it could also be an additional pattern that is to be inserted literally. A simple construction of an action statement with the insertion of a single value is shown below. The cell below the ACTION header is left blank. Using this style, anything can be placed in the consequence, not just a single method call. (The same technique is applicable within a CONDITION column as well.) Below is a comprehensive example, showing the use of various column headers. It is not an error to have no value below a column header (as in the NO-LOOP column): here, the attribute will not be applied in any of the rules. Figure 144. Example usage of keywords for imports, headers, etc. And, finally, here is an example of Import, Variables and Functions. Figure 145. Example usage of keywords for functions, etc. Multiple package names within the same cell must be separated by a comma. Also, the pairs of type and variable names must be comma-separated. Functions, however, must be written as they appear in a DRL file. This should appear in the same column as the \"RuleSet\" keyword; it could be above, between or below all the rule rows. It may be more convenient to use Import, Variables, Functions and Queries repeatedly rather than packing several definitions into a single cell. The API to use spreadsheet based decision tables is in the drools-decisiontables module. There is really only one class to look at: . This class will take spreadsheets in various formats, and generate rules in DRL (which you can then use in the normal way). The can just be used to generate partial rule files if it is wished, and assemble it into a complete rule package after the fact (this allows the separation of technical and non-technical aspects of the rules if needed). To get started, a sample spreadsheet can be used as a base. Alternatively, if the plug-in is being used (Rule Workbench IDE), the wizard can generate a spreadsheet from a template (to edit it an xls compatible spreadsheet editor will need to be used). Spreadsheets are well established business tools (in use for over 25 years). Decision tables lend themselves to close collaboration between IT and domain experts, while making the business rules clear to business analysts, it is an ideal separation of concerns. Typically, the whole process of authoring rules (coming up with a new decision table) would be something like:\n• Business analyst takes a template decision table (from a repository, or from IT)\n• Decision table business language descriptions are entered in the table(s)\n• Decision table is handed to a technical resource, who maps the business language (descriptions) to scripts (this may involve software development of course, if it is a new application or data model)\n• Technical person hands back and reviews the modifications with the business analyst.\n• The business analyst can continue editing the rule rows as needed (moving columns around is also fine etc).\n• In parallel, the technical person can develop test cases for the rules (liaising with business analysts) as these test cases can be used to verify rules and rule changes once the system is running. Features of applications like Excel can be used to provide assistance in entering data into spreadsheets, such as validating fields. Lists that are stored in other worksheets can be used to provide valid lists of values for cells, like in the following diagram. Some applications provide a limited ability to keep a history of changes, but it is recommended to use an alternative means of revision control. When changes are being made to rules over time, older versions are archived (many open source solutions exist for this, such as Subversion or Git). Related to decision tables (but not necessarily requiring a spreadsheet) are \"Rule Templates\" (in the drools-templates module). These use any tabular data source as a source of rule data - populating a template to generate many rules. This can allow both for more flexible spreadsheets, but also rules in existing databases for instance (at the cost of developing the template up front to generate the rules). With Rule Templates the data is separated from the rule and there are no restrictions on which part of the rule is data-driven. So whilst you can do everything you could do in decision tables you can also do the following:\n• store your data in a database (or any other format)\n• conditionally generate rules based on the values in the data\n• use data for any part of your rules (e.g. condition operator, class name, property name)\n• run different templates over the same data As an example, a more classic decision table is shown, but without any hidden rows for the rule meta data (so the spreadsheet only contains the raw data to generate the rules). See the ExampleCheese.xls in the examples download for the above spreadsheet. If this was a regular decision table there would be hidden rows before row 1 and between rows 1 and 2 containing rule metadata. With rule templates the data is completely separate from the rules. This has two handy consequences - you can apply multiple rule templates to the same data and your data is not tied to your rules at all. So what does the template look like?\n• Lines 2-4: Following the header is the list of columns in the order they appear in the data. In this case we are calling the first column , the second and the third .\n• Line 5: An empty line signifies the end of the column definitions.\n• Lines 6-9: Standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global and function definitions into this section.\n• Line 10: The keyword signals the start of a rule template. There can be more than one template in a template file, but each template should have a unique name.\n• Lines 11-18: The rule template - see below for details.\n• Line 20: The keywords signify the end of the template. The rule templates rely on MVEL to do substitution using the syntax @{token_name}. There is currently one built-in expression, @{row.rowNumber} which gives a unique number for each row of data and enables you to generate unique rule names. For each row of data a rule will be generated with the values in the data substituted for the tokens in the template. A rule template has to be included in a file with extension .drt and associated to the corresponding decision table when defining the kbase in the kmodule.xml file as in the following example With the example data above the following rule file would be generated: package org.drools.examples.templates; global java.util.List list; rule \"Cheese fans_1\" when Person(age == 42) Cheese(type == \"stilton\") then list.add(\"Old man stilton\"); end rule \"Cheese fans_2\" when Person(age == 21) Cheese(type == \"cheddar\") then list.add(\"Young man cheddar\"); end At this point the named \"TemplatesKS\" and containing the rules generated from the template can be simply created from the and used as any other . KieSession ksession = kc.newKieSession( \"TemplatesKS\" ); // now create some test data ksession.insert( new Cheese( \"stilton\", 42 ) ); ksession.insert( new Person( \"michael\", \"stilton\", 42 ) ); final List<String> list = new ArrayList<String>(); ksession.setGlobal( \"list\", list ); ksession.fireAllRules(); One way to illuminate the black box that is a rule engine, is to play with the logging level. Everything is logged to SLF4J, which is a simple logging facade that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a dependency to the logging adaptor for your logging framework of choice. If you’re not using any logging framework yet, you can use Logback by adding this Maven dependency: If you’re developing for an ultra light environment, use or instead. Configure the logging level on the package . For example: In Logback, configure it in your logback.xml file: In Log4J, configure it in your log4j.xml file:\n\nMake sure the Drools Eclipse plugin is installed, which needs the Graphical Editing Framework (GEF) dependency installed first. Then download and extract the drools-examples zip file, which includes an already created Eclipse project. Import that project into a new Eclipse workspace. The rules all have example classes that execute the rules. If you want to try the examples in another project (or another IDE) then you will need to set up the dependencies by hand, of course. Many, but not all of the examples are documented below, enjoy! Name: Hello World Main class: org.drools.examples.helloworld.HelloWorldExample Module: drools-examples Type: Java application Rules file: HelloWorld.drl Objective: demonstrate basic rules in use The \"Hello World\" example shows a simple application using rules, written both using the MVEL and the Java dialects. This example demonstrates how to create and use a . Also, audit logging and debug outputs are shown, which is omitted from other examples as it’s all very similar. The following code snippet shows how the session is created with only 3 lines of code. Obtains the KieServices factory. This is the main interface applications use to interact with the engine. Creates a KieContainer from the project classpath. This will look for a /META-INF/kmodule.xml file to configure and instantiate the KieModule into the KieContainer. Drools has an event model that exposes much of what’s happening internally. Two default debug listeners are supplied, and which print out debug event information to the stream displayed in the Console window. Adding listeners to a Session is trivial, as shown in the next snippet. The provides execution auditing, the result of which can be viewed in a graphical viewer. The logger is actually a specialised implementation built on the and listeners. When the engine has finished executing, must be called. Most of the examples use the Audit logging features of Drools to record execution flow for later inspection. // The application can also setup listeners ksession.addEventListener( new DebugAgendaEventListener() ); ksession.addEventListener( new DebugRuleRuntimeEventListener() ); // To setup a file based audit logger, uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, \"./helloworld\" ); // To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging, // uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, \"./helloworld\", 1000 ); The single class used in this example is very simple. It has two fields: the message, which is a and the status which can be one of the two integers or . A single object is created with the message text \"Hello World\" and the status and then inserted into the engine, at which point is executed. // The application can insert facts into the session final Message message = new Message(); message.setMessage( \"Hello World\" ); message.setStatus( Message.HELLO ); ksession.insert( message ); // and fire the rules ksession.fireAllRules(); To execute the example as a Java application:\n• Open the class in your Eclipse IDE\n• Right-click the class and select \"Run as…​\" and then \"Java application\" If we put a breakpoint on the method and select the variable, we can see that the \"Hello World\" rule is already activate on the Agenda. The application print outs go to to while the debug listener print outs go to . Example 260. HelloWorld: System.out in the Console window Example 261. HelloWorld: System.err in the Console window The actual rules are inside the file src/main/resources/org/drools/examples/helloworld/HelloWorld.drl : rule \"Hello World\" dialect \"mvel\" when m : Message( status == Message.HELLO, message : message ) then System.out.println( message ); modify ( m ) { message = \"Goodbye cruel world\", status = Message.GOODBYE }; end The LHS (after ) section of the rule states that it will be activated for each object inserted into the Rule Runtime whose status is . Besides that, two variable bindings are created: the variable is bound to the attribute and the variable is bound to the matched object itself. The RHS (after ) or consequence part of the rule is written using the MVEL expression language, as declared by the rule’s attribute . After printing the content of the bound variable to , the rule changes the values of the and attributes of the object bound to . This is done using MVEL’s statement, which allows you to apply a block of assignments in one statement, with the engine being automatically notified of the changes at the end of the block. It is possible to set a breakpoint into the DRL, on the call, and inspect the Agenda view again during the execution of the rule’s consequence. This time we start the execution via \"Debug As\" and \"Drools application\" and not by running a \"Java application\":\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Debug as…​\" and then \"Drools application\". Now we can see that the other rule , which uses the Java dialect, is activated and placed on the Agenda. The \"Good Bye\" rule, which specifies the \"java\" dialect, is similar to the \"Hello World\" rule except that it matches objects whose status is . The Java code that instantiates the creates an audit log file that can be loaded into the Audit view. The Audit view is used in many of the examples to demonstrate the example execution flow. In the view screen shot below we can see that the object is inserted, which creates an activation for the \"Hello World\" rule; the activation is then executed which updates the object causing the \"Good Bye\" rule to activate; finally the \"Good Bye\" rule also executes. Selecting an event in the Audit view highlights the origin event in green; therefore the \"Activation created\" event is highlighted in green as the origin of the \"Activation executed\" event. This example is implemented in two different versions to demonstrate different ways of implementing the same basic behavior: forward chaining, i.e., the ability the engine has to evaluate, activate and fire rules in sequence, based on changes on the facts in the Working Memory. Name: State Example Main class: org.drools.examples.state.StateExampleUsingSalience Module: drools-examples Type: Java application Rules file: StateExampleUsingSalience.drl Objective: Demonstrates basic rule use and Conflict Resolution for rule firing priority. Each class has fields for its name and its current state (see the class ). The two possible states for each objects are: public class State { public static final int NOTRUN = 0; public static final int FINISHED = 1; private final PropertyChangeSupport changes = new PropertyChangeSupport( this ); private String name; private int state; ... setters and getters go here... } Ignoring the , which will be explained later, we see the creation of four objects named A, B, C and D. Initially their states are set to , which is default for the used constructor. Each instance is asserted in turn into the Session and then is called. final State a = new State( \"A\" ); final State b = new State( \"B\" ); final State c = new State( \"C\" ); final State d = new State( \"D\" ); ksession.insert( a ); ksession.insert( b ); ksession.insert( c ); ksession.insert( d ); ksession.fireAllRules(); ksession.dispose(); // Stateful rule session must always be disposed when finished\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" You will see the following output in the Eclipse console window: There are four rules in total. First, the rule fires, setting A to state , which then causes B to change its state to . C and D are both dependent on B, causing a conflict which is resolved by the salience values. Let’s look at the way this was executed. The best way to understand what is happening is to use the Audit Logging feature to graphically see the results of each operation. To view the Audit log generated by a run of this example:\n• If the Audit View is not visible, click on \"Window\" and then select \"Show View\", then \"Other…​\" and \"Drools\" and finally \"Audit View\".\n• In the \"Audit View\" click the \"Open Log\" button and select the file \"<drools-examples-dir>/log/state.log\". After that, the \"Audit view\" will look like the following screenshot: Reading the log in the \"Audit View\", top to bottom, we see every action and the corresponding changes in the Working Memory. This way we observe that the assertion of the State object A in the state activates the rule, while the assertions of the other objects have no immediate effect. The execution of rule Bootstrap changes the state of A to , which, in turn, activates rule \"A to B\". rule \"A to B\" when State(name == \"A\", state == State.FINISHED ) b : State(name == \"B\", state == State.NOTRUN ) then System.out.println(b.getName() + \" finished\" ); b.setState( State.FINISHED ); end The execution of rule \"A to B\" changes the state of B to , which activates both, rules \"B to C\" and \"B to D\", placing their Activations onto the Agenda. From this moment on, both rules may fire and, therefore, they are said to be \"in conflict\". The conflict resolution strategy allows the engine’s Agenda to decide which rule to fire. As rule \"B to C\" has the higher salience value (10 versus the default salience value of 0), it fires first, modifying object C to state . The Audit view shown above reflects the modification of the object in the rule \"A to B\", which results in two activations being in conflict. The Agenda view can also be used to investigate the state of the Agenda, with debug points being placed in the rules themselves and the Agenda view opened. The screen shot below shows the breakpoint in the rule \"A to B\" and the state of the Agenda with the two conflicting rules. Example 269. Salience State: Rule \"B to C\" rule \"B to C\" salience 10 when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); end Rule \"B to D\" fires last, modifying object D to state . rule \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end There are no more rules to execute and so the engine stops. Another notable concept in this example is the use of dynamic facts, based on objects. As described in the documentation, in order for the engine to see and react to changes of fact properties, the application must tell the engine that changes occurred. This can be done explicitly in the rules by using the statement, or implicitly by letting the engine know that the facts implement as defined by the JavaBeans specification. This example demonstrates how to use to avoid the need for explicit statements in the rules. To make use of this feature, ensure that your facts implement , the same way the class does, and use the following code in the rules file to configure the engine to listen for property changes on those facts: When using objects, each setter must implement a little extra code for the notification. Here is the setter for in the class : Example 272. Setter Example with PropertyChangeSupport There are another class in this example: . It executes from A to B to C to D, as just shown, but uses agenda-groups to control the rule conflict and which one fires first. Agenda groups are a way to partition the Agenda into groups and to control which groups can execute. By default, all rules are in the agenda group \"MAIN\". The \"agenda-group\" attribute lets you specify a different agenda group for the rule. Initially, a Working Memory has its focus on the Agenda group \"MAIN\". A group’s rules will only fire when the group receives the focus. This can be achieved either ny using the method by or the rule attribute . \"auto-focus\" means that the rule automatically sets the focus to its agenda group when the rule is matched and activated. It is this \"auto-focus\" that enables rule \"B to C\" to fire before \"B to D\". Example 273. Agenda Group State Example: Rule \"B to C\" rule \"B to C\" agenda-group \"B to C\" auto-focus true when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"B to D\" ).setFocus(); end The rule \"B to C\" calls on the agenda group \"B to D\", allowing its active rules to fire, which allows the rule \"B to D\" to fire. Example 274. Agenda Group State Example: Rule \"B to D\" rule \"B to D\" agenda-group \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end Name: Fibonacci Main class: org.drools.examples.fibonacci.FibonacciExample Module: drools-examples Type: Java application Rules file: Fibonacci.drl Objective: Demonstrates Recursion, the CE not and cross product matching The Fibonacci Numbers (see http://en.wikipedia.org/wiki/Fibonacci_number) discovered by Leonardo of Pisa (see http://en.wikipedia.org/wiki/Fibonacci) is a sequence that starts with 0 and 1. The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers. The Fibonacci sequence begins with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,…​ The Fibonacci Example demonstrates recursion and conflict resolution with salience values. The single fact class is used in this example. It has two fields, sequence and value. The sequence field is used to indicate the position of the object in the Fibonacci number sequence. The value field shows the value of that Fibonacci object for that sequence position, using -1 to indicate a value that still needs to be computed. public static class Fibonacci { private int sequence; private long value; public Fibonacci( final int sequence ) { this.sequence = sequence; this.value = -1; } ... setters and getters go here... }\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" Eclipse shows the following output in its console window (with \"…​snip…​\" indicating lines that were removed to save space): recurse for 50 recurse for 49 recurse for 48 recurse for 47 ...snip... recurse for 5 recurse for 4 recurse for 3 recurse for 2 1 == 1 2 == 1 3 == 2 4 == 3 5 == 5 6 == 8 ...snip... 47 == 2971215073 48 == 4807526976 49 == 7778742049 50 == 12586269025 To kick this off from Java we only insert a single Fibonacci object, with a sequence field of 50. A recursive rule is then used to insert the other 49 objects. This example doesn’t use . It uses the MVEL dialect, which means we can use the keyword, which allows a block setter action which also notifies the engine of changes. The rule Recurse is very simple. It matches each asserted object with a value of -1, creating and asserting a new object with a sequence of one less than the currently matched object. Each time a Fibonacci object is added while the one with a sequence field equal to 1 does not exist, the rule re-matches and fires again. The conditional element is used to stop the rule’s matching once we have all 50 Fibonacci objects in memory. The rule also has a salience value, because we need to have all 50 objects asserted before we execute the Bootstrap rule. rule Recurse salience 10 when f : Fibonacci ( value == -1 ) not ( Fibonacci ( sequence == 1 ) ) then insert( new Fibonacci( f.sequence - 1 ) ); System.out.println( \"recurse for \" + f.sequence ); end The Audit view shows the original assertion of the object with a sequence field of 50, done from Java code. From there on, the Audit view shows the continual recursion of the rule, where each asserted object causes the Recurse rule to become activated and to fire again. When a object with a sequence field of 2 is asserted the \"Bootstrap\" rule is matched and activated along with the \"Recurse\" rule. Note the multi-restriction on field , testing for equality with 1 or 2. rule Bootstrap when f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction then modify ( f ){ value = 1 }; System.out.println( f.sequence + \" == \" + f.value ); end At this point the Agenda looks as shown below. However, the \"Bootstrap\" rule does not fire because the \"Recurse\" rule has a higher salience. When a object with a sequence of 1 is asserted the Bootstrap rule is matched again, causing two activations for this rule. Note that the \"Recurse\" rule does not match and activate because the conditional element stops the rule’s matching as soon as a object with a sequence of 1 exists. Once we have two objects with values not equal to -1 the \"Calculate\" rule is able to match. It was the \"Bootstrap\" rule that set the objects with sequence 1 and 2 to values of 1. At this point we have 50 Fibonacci objects in the Working Memory. Now we need to select a suitable triple to calculate each of their values in turn. Using three Fibonacci patterns in a rule without field constraints to confine the possible cross products would result in 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect. The \"Calculate\" rule uses field constraints to correctly constraint the thee Fibonacci patterns in the correct order; this technique is called cross product matching. The first pattern finds any Fibonacci with a value != -1 and binds both the pattern and the field. The second Fibonacci does this, too, but it adds an additional field constraint to ensure that its sequence is greater by one than the Fibonacci bound to . When this rule fires for the first time, we know that only sequences 1 and 2 have values of 1, and the two constraints ensure that references sequence 1 and references sequence 2. The final pattern finds the Fibonacci with a value equal to -1 and with a sequence one greater than . At this point, we have three objects correctly selected from the available cross products, and we can calculate the value for the third object that’s bound to . rule Calculate when // Bind f1 and s1 f1 : Fibonacci( s1 : sequence, value != -1 ) // Bind f2 and v2; refer to bound variable s1 f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 ) // Bind f3 and s3; alternative reference of f2.sequence f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 ) then // Note the various referencing techniques. modify ( f3 ) { value = f1.value + v2 }; System.out.println( s3 + \" == \" + f3.value ); end The statement updated the value of the object bound to . This means we now have another new Fibonacci object with a value not equal to -1, which allows the \"Calculate\" rule to rematch and calculate the next Fibonacci number. The Audit view below shows how the firing of the last \"Bootstrap\" modifies the object, enabling the \"Calculate\" rule to match, which then modifies another Fibonacci object allowing the \"Calculate\" rule to match again. This continues till the value is set for all objects. This tutorial demonstrates the process of developing a complete personal banking application to handle credits and debits on multiple accounts. It uses a set of design patterns that have been created for the process. The class is a simple harness to execute one or more DRL files against a set of data. It compiles the Packages and creates the Knowledge Base for each execution, allowing us to easily execute each scenario and inspect the outputs. In reality this is not a good solution for a production system, where the Knowledge Base should be built just once and cached, but for the purposes of this tutorial it shall suffice. The first of our sample Java classes loads and executes a single DRL file, Example.drl , but without inserting any data. public class Example1 { public static void main(String[] args) throws Exception { new RuleRunner().runRules( new String[] { \"Example1.drl\" }, new Object[0] ); } } The first simple rule to execute has a single condition that will always be true, so that this rule will match and fire, once, after the start. The output for the rule is below, showing that the rule matches and executes the single print statement. The next step is to assert some simple facts and print them out. public class Example2 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example2.drl\" }, numbers ); } private static Integer wrap( int i ) { return new Integer(i); } } This doesn’t use any specific facts but instead asserts a set of objects. This is not considered \"best practice\" as a number is not a useful fact, but we use it here to demonstrate basic techniques before more complexity is added. Now we will create a simple rule to print out these numbers. rule \"Rule 02\" when Number( $intValue : intValue ) then System.out.println( \"Number found with value: \" + $intValue ); end Once again, this rule does nothing special. It identifies any facts that are objects and prints out the values. Notice the use of the abstract class : we inserted objects but we now look for any kind of number. The pattern matching engine is able to match interfaces and superclasses of asserted objects. The output shows the DRL being loaded, the facts inserted and then the matched and fired rules. We can see that each inserted number is matched and fired and thus printed. Loading file: Example2.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 5 Number found with value: 1 Number found with value: 4 Number found with value: 1 Number found with value: 3 There are certainly many better ways to sort numbers than using rules, but since we will need to apply some cashflows in date order when we start looking at banking rules we’ll develop simple rule based sorting technique. public class Example3 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example3.drl\" }, numbers ); } private static Integer wrap(int i) { return new Integer(i); } } Again we insert our objects, but this time the rule is slightly different: rule \"Rule 03\" when $number : Number( ) not Number( intValue < $number.intValue ) then System.out.println(\"Number found with value: \" + $number.intValue() ); retract( $number ); end The first line of the rule identifies a and extracts the value. The second line ensures that there does not exist a smaller number than the one found by the first pattern. We might expect to match only one number - the smallest in the set. However, the retraction of the number after it has been printed means that the smallest number has been removed, revealing the next smallest number, and so on. The resulting output shows that the numbers are now sorted numerically. Loading file: Example3.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 1 Number found with value: 1 Number found with value: 3 Number found with value: 4 Number found with value: 5 We are ready to start moving towards our personal accounting rules. The first step is to create a object. Class has two simple attributes, a date and an amount. (Note that using the type for monetary units is generally not a good idea because floating point numbers cannot represent most numbers accurately.) There is also an overloaded constructor to set the values, and a method to print a cashflow. The Java code of Example4.java inserts five Cashflow objects, with varying dates and amounts. public class Example4 { public static void main(String[] args) throws Exception { Object[] cashflows = { new Cashflow(new SimpleDate(\"01/01/2007\"), 300.00), new Cashflow(new SimpleDate(\"05/01/2007\"), 100.00), new Cashflow(new SimpleDate(\"11/01/2007\"), 500.00), new Cashflow(new SimpleDate(\"07/01/2007\"), 800.00), new Cashflow(new SimpleDate(\"02/01/2007\"), 400.00), }; new RuleRunner().runRules( new String[] { \"Example4.drl\" }, cashflows ); } } The convenience class extends , providing a constructor taking a String as input and defining a date format. The code is listed below Now, let’s look at Example4.drl to see how we print the sorted objects: rule \"Rule 04\" when $cashflow : Cashflow( $date : date, $amount : amount ) not Cashflow( date < $date) then System.out.println(\"Cashflow: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a and extract the date and the amount. In the second line of the rule we ensure that there is no Cashflow with an earlier date than the one found. In the consequence, we print the that satisfies the rule and then retract it, making way for the next earliest . So, the output we generate is: Next, we extend our , resulting in a which can be a credit or a debit operation. (Normally, we would just add this to the type, but we use extension to keep the previous version of the class intact.) There are lots of ways to improve this code, but for the sake of the example this will do. Now let’s create Example5, a class for running our code. public class Example5 { public static void main(String[] args) throws Exception { Object[] cashflows = { new TypedCashflow(new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new TypedCashflow(new SimpleDate(\"05/01/2007\"), TypedCashflow.CREDIT, 100.00), new TypedCashflow(new SimpleDate(\"11/01/2007\"), TypedCashflow.CREDIT, 500.00), new TypedCashflow(new SimpleDate(\"07/01/2007\"), TypedCashflow.DEBIT, 800.00), new TypedCashflow(new SimpleDate(\"02/01/2007\"), TypedCashflow.DEBIT, 400.00), }; new RuleRunner().runRules( new String[] { \"Example5.drl\" }, cashflows ); } } Here, we simply create a set of objects which are either credit or debit operations. We supply them and Example5.drl to the RuleEngine. Now, let’s look at a rule printing the sorted objects. rule \"Rule 05\" when $cashflow : TypedCashflow( $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not TypedCashflow( date < $date, type == TypedCashflow.CREDIT ) then System.out.println(\"Credit: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a fact with a type of and extract the date and the amount. In the second line of the rule we ensure that there is no of the same type with an earlier date than the one found. In the consequence, we print the cashflow satisfying the patterns and then retract it, making way for the next earliest cashflow of type . So, the output we generate is Continuing our banking exercise, we are now going to process both credits and debits on two bank accounts, calculating the account balance. In order to do this, we create two separate objects and inject them into the objects before passing them to the Rule Engine. The reason for this is to provide easy access to the correct account without having to resort to helper classes. Let’s take a look at the class first. This is a simple Java object with an account number and balance: Now let’s extend our , resulting in , to include an reference. The Java code of Example5.java creates two objects and passes one of them into each cashflow, in the constructor call. public class Example6 { public static void main(String[] args) throws Exception { Account acc1 = new Account(1); Account acc2 = new Account(2); Object[] cashflows = { new AllocatedCashflow(acc1,new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/02/2007\"), TypedCashflow.CREDIT, 100.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/03/2007\"), TypedCashflow.CREDIT, 500.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/02/2007\"), TypedCashflow.DEBIT, 800.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/03/2007\"), TypedCashflow.DEBIT, 400.00), new AllocatedCashflow(acc1,new SimpleDate(\"01/04/2007\"), TypedCashflow.CREDIT, 200.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/04/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/05/2007\"), TypedCashflow.CREDIT, 700.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/05/2007\"), TypedCashflow.DEBIT, 900.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/05/2007\"), TypedCashflow.DEBIT, 100.00) }; new RuleRunner().runRules( new String[] { \"Example6.drl\" }, cashflows ); } } Now, let’s look at the rule in Example6.drl to see how we apply each cashflow in date order and calculate and print the balance. rule \"Rule 06 - Credit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Credit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance()+$amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end rule \"Rule 06 - Debit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.DEBIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Debit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance() - $amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end Although we have separate rules for credits and debits, but we do not specify a type when checking for earlier cashflows. This is so that all cashflows are applied in date order, regardless of the cashflow type. In the conditions we identify the account to work with, and in the consequences we update it with the cashflow amount. Loading file: Example6.drl Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0] Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0 Account: 2 - new balance: -400.0 Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0 Account: 2 - new balance: 100.0 Debit: Wed May 02 00:00:00 BST 2007 :: 100.0 Account: 2 - new balance: 0.0 Credit: Fri May 11 00:00:00 BST 2007 :: 700.0 Account: 2 - new balance: 700.0 Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0 Account: 1 - new balance: 300.0 Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0 Account: 1 - new balance: 400.0 Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0 Account: 1 - new balance: -400.0 Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0 Account: 1 - new balance: -200.0 Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0 Account: 1 - new balance: 100.0 Debit: Mon May 07 00:00:00 BST 2007 :: 900.0 Account: 1 - new balance: -800.0 The Pricing Rule decision table demonstrates the use of a decision table in a spreadsheet, in Excel’s XLS format, in calculating the retail cost of an insurance policy. The purpose of the provide set of rules is to calculate a base price and a discount for a car driver applying for a specific policy. The driver’s age, history and the policy type all contribute to what the basic premium is, and an additional chunk of rules deals with refining this with a discount percentage. Open the file PricingRuleDTExample.java and execute it as a Java application. It should produce the following output in the Console window: Cheapest possible BASE PRICE IS: 120 DISCOUNT IS: 20 The code to execute the example follows the usual pattern. The rules are loaded, the facts inserted and a Stateless Session is created. What is different is how the rules are added. Note the use of the object. Its input type is set to . If you use the BRMS, all this is of course taken care of for you. There are two fact types used in this example, and . Both are used with their default values. The is 30 years old, has had no prior claims and currently has a risk profile of . The being applied for is , and it has not yet been approved. In this decision table, each row is a rule, and each column is a condition or an action. Referring to the spreadsheet show above, we have the declaration, which provides the package name. There are also other optional items you can have here, such as for global variables, and for importing classes. In this case, the namespace of the rules is the same as the fact classes we are using, so we can omit it. Moving further down, we can see the declaration. The name after this (Pricing bracket) is used as the prefix for all the generated rules. Below that, we have \"CONDITION or ACTION\", indicating the purpose of the column, i.e., whether it forms part of the condition or the consequence of the rule that will be generated. You can see that there is a driver, his data spanned across three cells, which means that the template expressions below it apply to that fact. We observe the driver’s age range (which uses and with comma-separated values), , and in the respective columns. In the action columns, we are set the policy base price and log a message. In the preceding spreadsheet section, there are broad category brackets, indicated by the comment in the leftmost column. As we know the details of our drivers and their policies, we can tell (with a bit of thought) that they should match row number 18, as they have no prior accidents, and are 30 years old. This gives us a base price of 120. The above section contains the conditions for the discount we might grant our driver. The discount results from the bracket, the number of prior claims, and the policy type. In our case, the driver is 30, with no prior claims, and is applying for a policy, which means we can give a discount of 20%. Note that this is actually a separate table, but in the same worksheet, so that different templates apply. It is important to note that decision tables generate rules. This means they aren’t simply top-down logic, but more a means to capture data resulting in rules. This is a subtle difference that confuses some people. The evaluation of the rules is not necessarily in the given order, since all the normal mechanics of the rule engine still apply. Name: Pet Store Main class: org.drools.examples.petstore.PetStoreExample Module: drools-examples Type: Java application Rules file: PetStore.drl Objective: Demonstrate use of Agenda Groups, Global Variables and integration with a GUI, including callbacks from within the rules The Pet Store example shows how to integrate Rules with a GUI, in this case a Swing based desktop application. Within the rules file, it demonstrates how to use Agenda groups and auto-focus to control which of a set of rules is allowed to fire at any given time. It also illustrates the mixing of the Java and MVEL dialects within the rules, the use of accumulate functions and the way of calling Java functions from within the ruleset. All of the Java code is contained in one file, PetStore.java , defining the following principal classes (in addition to several classes to handle Swing Events):\n• contains the method that we will look at shortly.\n• is responsible for creating and displaying the Swing based GUI. It contains several smaller classes, mainly for responding to various GUI events such as mouse button clicks.\n• holds the table data. Think of it as a JavaBean that extends the Swing class .\n• allows the GUI to interact with the Rules.\n• keeps the items that we wish to buy.\n• stores details of the order and the products we are buying.\n• is a JavaBean holding details of the product available for purchase, and its price. Much of the Java code is either plain JavaBeans or Swing-based. Only a few Swing-related points will be discussed in this section, but a good tutorial about Swing components can be found at Sun’s Swing website, in http://java.sun.com/docs/books/tutorial/uiswing/. The pieces of Java code in Petstore.java that relate to rules and facts are shown below. Example 305. Creating the PetStore KieContainer in PetStore.main // KieServices is the factory for all KIE services KieServices ks = KieServices.Factory.get(); // From the kie services, a container is created from the classpath KieContainer kc = ks.getKieClasspathContainer(); // Create the stock. Vector<Product> stock = new Vector<Product>(); stock.add( new Product( \"Gold Fish\", 5 ) ); stock.add( new Product( \"Fish Tank\", 25 ) ); stock.add( new Product( \"Fish Food\", 2 ) ); // A callback is responsible for populating the // Working Memory and for firing all rules. PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( kc ) ); ui.createAndShowGUI(); The code shown above create a from the classpath and based on the definitions in the kmodule.xml file. Unlike other examples where the facts are asserted and fired straight away, this example defers this step to later. The way it does this is via the second last line where a object is created using a constructor accepting the object collecting our products, and an instance of the class containing the Rule Base that we have just loaded. The Java code that fires the rules is within the method. This is triggered (eventually) when the Checkout button is pressed by the user. Example 306. Firing the Rules - extract from CheckoutCallBack.checkout() public String checkout(JFrame frame, List<Product> items) { Order order = new Order(); // Iterate through list and add to cart for ( Product p: items ) { order.addItem( new Purchase( order, p ) ); } // Add the JFrame to the ApplicationData to allow for user interaction // From the container, a session is created based on // its definition and configuration in the META-INF/kmodule.xml file KieSession ksession = kcontainer.newKieSession(\"PetStoreKS\"); ksession.setGlobal( \"frame\", frame ); ksession.setGlobal( \"textArea\", this.output ); ksession.insert( new Product( \"Gold Fish\", 5 ) ); ksession.insert( new Product( \"Fish Tank\", 25 ) ); ksession.insert( new Product( \"Fish Food\", 2 ) ); ksession.insert( new Product( \"Fish Food Sample\", 0 ) ); ksession.insert( order ); ksession.fireAllRules(); // Return the state of the cart return order.toString(); } Two items get passed into this method. One is the handle to the Swing component surrounding the output text frame, at the bottom of the GUI. The second is a list of order items; this comes from the storing the information from the \"Table\" area at the top right section of the GUI. The for loop transforms the list of order items coming from the GUI into the JavaBean, also contained in the file PetStore.java . Note that it would be possible to refer to the Swing dataset directly within the rules, but it is better coding practice to do it this way, using simple Java objects. It means that we are not tied to Swing if we wanted to transform the sample into a Web application. It is important to note that all state in this example is stored in the Swing components, and that the rules are effectively stateless. Each time the \"Checkout\" button is pressed, this code copies the contents of the Swing into the Session’s Working Memory. Within this code, there are nine calls to the . The first of these creates a new from the . Remember that we passed in this when we created the class in the method. The next two calls pass in two objects that we will hold as global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the , as well as the order list. The final call is the standard . Next, we look at what this method causes to happen within the rules file. Example 307. Package, Imports, Globals and Dialect: extract from PetStore.drl The first part of file PetStore.drl contains the standard package and import statements to make various Java classes available to the rules. New to us are the two globals and . They hold references to the Swing components and components that were previously passed on by the Java code calling the method. Unlike variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the Session. The next extract from the file PetStore.drl contains two functions that are referenced by the rules that we will look at shortly. Example 308. Java Functions in the Rules: extract from PetStore.drl function void doCheckout(JFrame frame, KieRuntime krt) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to checkout?\", \"\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (n == 0) { krt.getAgenda().getAgendaGroup( \"checkout\" ).setFocus(); } } function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to buy a tank for your \" + total + \" fish?\", \"Purchase Suggestion\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); System.out.print( \"SUGGESTION: Would you like to buy a tank for your \" + total + \" fish? - \" ); if (n == 0) { Purchase purchase = new Purchase( order, fishTank ); krt.insert( purchase ); order.addItem( purchase ); System.out.println( \"Yes\" ); } else { System.out.println( \"No\" ); } return true; } Having these functions in the rules file just makes the Pet Store example more compact. In real life you probably have the functions in a file of their own, within the same rules package, or as a static method on a standard Java class, and import them, using . The purpose of these two functions is:\n• displays a dialog asking users whether they wish to checkout. If they do, focus is set to the agenda-group, allowing rules in that group to (potentially) fire.\n• displays a dialog asking users whether they wish to buy a tank. If so, a new fish tank is added to the order list in Working Memory. We’ll see the rules that call these functions later on. The next set of examples are from the Pet Store rules themselves. The first extract is the one that happens to fire first, partly because it has the attribute set to true. Example 309. Putting items into working memory: extract from PetStore.drl // Insert each item in the shopping cart into the Working Memory // Insert each item in the shopping cart into the Working Memory rule \"Explode Cart\" agenda-group \"init\" auto-focus true salience 10 dialect \"java\" when $order : Order( grossTotal == -1 ) $item : Purchase() from $order.items then insert( $item ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"show items\" ).setFocus(); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"evaluate\" ).setFocus(); end This rule matches against all orders that do not yet have their calculated . It loops for each purchase item in that order. Some parts of the \"Explode Cart\" rule should be familiar: the rule name, the salience (suggesting the order for the rules being fired) and the dialect set to . There are three new features:\n• `agenda-group defines the name of the agenda group. In this case, there is only one rule in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the next attribute for its chance to fire.\n• auto-focus ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when `fireAllRules() is called from the Java code.\n• sets the focus to the and agenda groups in turn, permitting their rules to fire. In practice, we loop through all items on the order, inserting them into memory, then firing the other rules after each insert. The next two listings show the rules within the and agenda groups. We look at them in the order that they are called. Example 310. Show Items in the GUI - extract from PetStore.drl The agenda-group has only one rule, called \"Show Items\" (note the difference in case). For each purchase on the order currently in the Working Memory (or Session), it logs details to the text area at the bottom of the GUI. The variable used to do this is one of the global variables we looked at earlier. The Agenda group also gains focus from the rule listed previously. This Agenda group has two rules, and , shown below. // Free Fish Food sample when we buy a Gold Fish if we haven't already bought // Fish Food and don't already have a Fish Food Sample rule \"Free Fish Food Sample\" agenda-group \"evaluate\" dialect \"mvel\" when $order : Order() not ( $p : Product( name == \"Fish Food\") && Purchase( product == $p ) ) not ( $p : Product( name == \"Fish Food Sample\") && Purchase( product == $p ) ) exists ( $p : Product( name == \"Gold Fish\") && Purchase( product == $p ) ) $fishFoodSample : Product( name == \"Fish Food Sample\" ); then System.out.println( \"Adding free Fish Food Sample to cart\" ); purchase = new Purchase($order, $fishFoodSample); insert( purchase ); $order.addItem( purchase ); end // Suggest a tank if we have bought more than 5 gold fish and don't already have one rule \"Suggest Tank\" agenda-group \"evaluate\" dialect \"java\" when $order : Order() not ( $p : Product( name == \"Fish Tank\") && Purchase( product == $p ) ) ArrayList( $total : size > 5 ) from collect( Purchase( product.name == \"Gold Fish\" ) ) $fishTank : Product( name == \"Fish Tank\" ) then requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); end The rule will only fire if\n• we don’t already have any fish food, and\n• we don’t already have a free fish food sample, and\n• we do have a Gold Fish in our order. If the rule does fire, it creates a new product (Fish Food Sample), and adds it to the order in Working Memory. The rule will only fire if\n• we don’t already have a Fish Tank in our order, and\n• we do have more than 5 Gold Fish Products in our order. If the rule does fire, it calls the function that we looked at earlier (showing a Dialog to the user, and adding a Tank to the order / working memory if confirmed). When calling the requireTank() function the rule passes the global frame variable so that the function has a handle to the Swing GUI. The next rule we look at is . Example 312. Doing the Checkout - extract (6) from PetStore.drl rule \"do checkout\" dialect \"java\" when then doCheckout(frame, kcontext.getKieRuntime()); end The rule has no agenda group set and no auto-focus attribute. As such, is is deemed part of the default (MAIN) agenda group. This group gets focus by default when all the rules in agenda-groups that explicitly had focus set to them have run their course. There is no LHS to the rule, so the RHS will always call the function. When calling the function, the rule passes the global variable to give the function a handle to the Swing GUI. As we saw earlier, the function shows a confirmation dialog to the user. If confirmed, the function sets the focus to the checkout agenda-group, allowing the next lot of rules to fire. rule \"Gross Total\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal == -1) Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ), sum( $price ) ) then modify( $order ) { grossTotal = total }; textArea.append( \"\n\ngross total=\" + total + \"\n\n\" ); end rule \"Apply 5% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 10 && < 20 ) then $order.discountedTotal = $order.grossTotal * 0.95; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end rule \"Apply 10% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 20 ) then $order.discountedTotal = $order.grossTotal * 0.90; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end There are three rules in the checkout agenda-group:\n• If we haven’t already calculated the gross total, accumulates the product prices into a total, puts this total into the session, and displays it via the Swing , using the global variable yet again.\n• If our gross total is between 10 and 20, calculates the discounted total and adds it to the session and displays it in the text area.\n• If our gross total is not less than 20, calculates the discounted total and adds it to the session and displays it in the text area. Now that we’ve run through what happens in the code, let’s have a look at what happens when we actually run the code. The file PetStore.java contains a method, so that it can be run as a standard Java application, either from the command line or via the IDE. This assumes you have your classpath set correctly. (See the start of the examples section for more information.) The first screen that we see is the Pet Store Demo. It has a list of available products (top left), an empty list of selected products (top right), checkout and reset buttons (middle) and an empty system messages area (bottom). To get to this point, the following things have happened:\n• The method has run and loaded the Rule Base but not yet fired the rules. So far, this is the only code in connection with rules that has been run.\n• A new object has been created and given a handle to the Rule Base, for later use.\n• Various Swing components do their stuff, and the above screen is shown and waits for user input. Clicking on various products from the list might give you a screen similar to the one below. Note that no rules code has been fired here. This is only Swing code, listening for mouse click events, and adding some selected product to the object for display in the top right hand section. (As an aside, note that this is a classic use of the Model View Controller design pattern). It is only when we press the \"Checkout\" button that we fire our business rules, in roughly the same order that we walked through the code earlier.\n• Method is called (eventually) by the Swing class waiting for the click on the \"Checkout\" button. This inserts the data from the object (top right hand side of the GUI), and inserts it into the Session’s Working Memory. It then fires the rules.\n• The rule is the first to fire, given that it has set to true. It loops through all the products in the cart, ensures that the products are in the Working Memory, and then gives the and agenda groups a chance to fire. The rules in these groups add the contents of the cart to the text area (at the bottom of the window), decide whether or not to give us free fish food, and to ask us whether we want to buy a fish tank. This is shown in the figure below. Figure 392. Do we want to buy a fish tank?\n• The Do Checkout rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the doCheckout() function which displays a 'Would you like to Checkout?' Dialog Box.\n• The function sets the focus to the agenda-group, giving the rules in that group the option to fire.\n• The rules in the the agenda-group display the contents of the cart and apply the appropriate discount.\n• Swing then waits for user input to either checkout more products (and to cause the rules to fire again), or to close the GUI - see the figure below. Figure 393. Petstore Demo after all rules have fired. We could add more System.out calls to demonstrate this flow of events. The output, as it currently appears in the Console window, is given in the listing below. Example 314. Console (System.out) from running the PetStore GUI Adding free Fish Food Sample to cart SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes Name: Honest Politician Main class: org.drools.examples.honestpolitician.HonestPoliticianExample Module: drools-examples Type: Java application Rules file: HonestPoliticianExample.drl Objective: Illustrate the concept of \"truth maintenance\" based on the logical insertion of facts The Honest Politician example demonstrates truth maintenance with logical assertions. The basic premise is that an object can only exist while a statement is true. A rule’s consequence can logically insert an object with the method. This means the object will only remain in the Working Memory as long as the rule that logically inserted it remains true. When the rule is no longer true the object is automatically retracted. In this example there is the class , with a name and a boolean value for being honest. Four politicians with honest state set to true are inserted. Politician blair = new Politician(\"blair\", true); Politician bush = new Politician(\"bush\", true); Politician chirac = new Politician(\"chirac\", true); Politician schroder = new Politician(\"schroder\", true); ksession.insert( blair ); ksession.insert( bush ); ksession.insert( chirac ); ksession.insert( schroder ); ksession.fireAllRules(); The Console window output shows that, while there is at least one honest politician, democracy lives. However, as each politician is in turn corrupted by an evil corporation, so that all politicians become dishonest, democracy is dead. Hurrah!!! Democracy Lives I'm an evil corporation and I have corrupted schroder I'm an evil corporation and I have corrupted chirac I'm an evil corporation and I have corrupted bush I'm an evil corporation and I have corrupted blair We are all Doomed!!! Democracy is Dead As soon as there is at least one honest politician in the Working Memory a new object is logically asserted. This object will only exist while there is at least one honest politician. As soon as all politicians are dishonest, the object will be automatically retracted. This rule is given a salience of 10 to ensure that it fires before any other rule, as at this stage the \"Hope is Dead\" rule is actually true. Example 318. Honest Politician: Rule \"We have an honest politician\" rule \"We have an honest Politician\" salience 10 when exists( Politician( honest == true ) ) then insertLogical( new Hope() ); end As soon as a object exists the \"Hope Lives\" rule matches and fires. It has a salience of 10 so that it takes priority over \"Corrupt the Honest\". Now that there is hope and we have, at the start, four honest politicians, we have four activations for this rule, all in conflict. They will fire in turn, corrupting each politician so that they are no longer honest. When all four politicians have been corrupted we have no politicians with the property . Thus, the rule \"We have an honest Politician\" is no longer true and the object it logical inserted (due to the last execution of ) is automatically retracted. rule \"Corrupt the Honest\" when politician : Politician( honest == true ) exists( Hope() ) then System.out.println( \"I'm an evil corporation and I have corrupted \" + politician.getName() ); modify ( politician ) { honest = false }; end With the object being automatically retracted, via the truth maintenance system, the conditional element applied to is no longer true so that the following rule will match and fire. rule \"Hope is Dead\" when not( Hope() ) then System.out.println( \"We are all Doomed!!! Democracy is Dead\" ); end Let’s take a look at the Audit trail for this application: The moment we insert the first politician we have two activations. The rule \"We have an honest Politician\" is activated only once for the first inserted politician because it uses an conditional element, which matches once for any number. The rule \"Hope is Dead\" is also activated at this stage, because we have not yet inserted the object. Rule \"We have an honest Politician\" fires first, as it has a higher salience than \"Hope is Dead\", which inserts the object. (That action is highlighted green.) The insertion of the object activates \"Hope Lives\" and de-activates \"Hope is Dead\"; it also activates \"Corrupt the Honest\" for each inserted honest politician. Rule \"Hope Lives\" executes, printing \"Hurrah!!! Democracy Lives\". Then, for each politician, rule \"Corrupt the Honest\" fires, printing \"I’m an evil corporation and I have corrupted X\", where X is the name of the politician, and modifies the politician’s honest value to false. When the last honest politician is corrupted, is automatically retracted, by the truth maintenance system, as shown by the blue highlighted area. The green highlighted area shows the origin of the currently selected blue highlighted area. Once the fact is retracted, \"Hope is dead\" activates and fires printing \"We are all Doomed!!! Democracy is Dead\". Name: Sudoku Main class: org.drools.examples.sudoku.SudokuExample Type: Java application Rules file: sudoku.drl, validate.drl Objective: Demonstrates the solving of logic problems, and complex pattern matching. This example demonstrates how Drools can be used to find a solution in a large potential solution space based on a number of constraints. We use the popular puzzle of Sudoku. This example also shows how Drools can be integrated into a graphical interface and how callbacks can be used to interact with a running Drools rules engine in order to update the graphical interface based on changes in the Working Memory at runtime. Sudoku is a logic-based number placement puzzle. The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9, once, and only once. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints. The general strategy to solve the problem is to ensure that when you insert a new number it should be unique in its particular 3x3 zone, row and column. See Wikipedia for a more detailed description. Download and install drools-examples as described above and then execute java org.drools.examples.DroolsExamplesApp and click on \"SudokuExample\". The window contains an empty grid, but the program comes with a number of grids stored internally which can be loaded and solved. Click on \"File\", then \"Samples\" and select \"Simple\" to load one of the examples. Note that all buttons are disabled until a grid is loaded. Loading the \"Simple\" example fills the grid according to the puzzle’s initial state. Click on the \"Solve\" button and the Drools-based engine will fill out the remaining values, and the buttons are inactive once more. Alternatively, you may click on the \"Step\" button to see the next digit found by the rule set. The Console window will display detailed information about the rules which are executing to solve the step in a human readable form. Some examples of these messages are presented below. single 8 at [0,1] column elimination due to [1,2]: remove 9 from [4,2] hidden single 9 at [1,2] row elimination due to [2,8]: remove 7 from [2,4] remove 6 from [3,8] due to naked pair at [3,2] and [3,7] hidden pair in row at [4,6] and [4,4] Click on the \"Dump\" button to see the state of the grid, with cells showing either the established value or the remaining possibilitiescandidates. Now, let us load a Sudoku grid that is deliberately invalid. Click on \"File\", \"Samples\" and \"!DELIBERATELY BROKEN!\". Note that this grid starts with some issues, for example the value 5 appears twice in the first row. A few simple rules perform a sanity check, right after loading a grid. In this case, the following messages are printed on standard output: cell [0,8]: 5 has a duplicate in row 0 cell [0,0]: 5 has a duplicate in row 0 cell [6,0]: 8 has a duplicate in col 0 cell [4,0]: 8 has a duplicate in col 0 Validation complete. Nevertheless, click on the \"Solve\" button to apply the solving rules to this invalid grid. This will not complete; some cells remain empty. The solving functionality has been achieved by the use of rules that implement standard solving techniques. They are based on the sets of values that are still candidates for a cell. If, for instance, such a set contains a single value, then this is the value for the cell. A little less obvious is the single occurrence of a value in one of the groups of nine cells. The rules detecting these situations insert a fact of type Setting with the solution value for some specific cell. This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to. Finally, it is retracted. Other rules merely reduce the permissible values for some cells. Rules \"naked pair\", \"hidden pair in row\", \"hidden pair in column\" and \"hidden pair in square\" merely eliminate possibilities but do not establish solutions. More sophisticated eliminations are done by \"X-wings in rows\", \"X-wings in columns\", \"intersection removal row\" and \"intersection removal column\". The Java source code can be found in the /src/main/java/org/drools/examples/sudoku directory, with the two DRL files defining the rules located in the /src/main/rules/org/drools/examples/sudoku directory. The package contains a set of classes which implement a framework for Sudoku puzzles. Note that this package does not have any dependencies on the Drools libraries. defines an interface which can be implemented to store a Sudoku puzzle as a 9x9 grid of objects. is a Swing component which can visualize any implementation of . and are used to communicate state changes between the model and the view: events are fired when a cell’s value is resolved or changed. If you are familiar with the model-view-controller patterns in other Swing components such as then this pattern should be familiar. provides a number of partially filled Sudoku puzzles for demonstration purposes. Package contains a utility class with a method for compiling DRL files. The package contains a set of classes implementing the elementary object and its various aggregations: the subtypes and as well as , all of which are subtypes of . It’s interesting to note that and are subclasses of , which provides a property with the type . For a it represents the individual candidate set; for a the set is the union of all candidate sets of its cells, or, simply, the set of digits that still need to be allocated. With 81 and 27 objects and the linkage provided by the properties , and and the property , a list of objects, it is possible to write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set. An object of class is used for triggering the operations that accompany the allocation of a value: its removal from the candidate sets of sibling cells and associated cell groups. Moreover, the presence of a fact is used in all rules that should detect a new situation; this is to avoid reactions to inconsistent intermediary states. An object of class is used in a low priority rule to execute an emergency halt when a \"Step\" does not terminate regularly. This indicates that the puzzle cannot be solved by the program. The class implements a Java application combining the components described. Validation rules detect duplicate numbers in cell groups. They are combined in an agenda group which enables us to activate them, explicitly, after loading a puzzle. The three rules \"duplicate in cell…​\" are very similar. The first pattern locates a cell with an allocated value. The second pattern pulls in any of the three cell groups the cell belongs to. The final pattern would find a cell (other than the first one) with the same value as the first cell and in the same row, column or square, respectively. Rule \"terminate group\" fires last. It prints a message and calls halt. There are three types of rules in this file: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets. Rules \"set a value\", \"eliminate a value from Cell\" and \"retract setting\" depend on the presence of a object. The first rule handles the assignment to the cell and the operations for removing the value from the \"free\" sets of the cell’s three groups. Also, it decrements a counter that, when zero, returns control to the Java application that has called . The purpose of rule \"eliminate a value from Cell\" is to reduce the candidate lists of all cells that are related to the newly assigned cell. Finally, when all eliminations have been made, rule \"retract setting\" retracts the triggering fact. There are just two rules that detect a situation where an allocation of a number to a cell is possible. Rule \"single\" fires for a with a candidate set containing a single number. Rule \"hidden single\" fires when there is no cell with a single candidate but when there is a cell containing a candidate but this candidate is absent from all other cells in one of the three groups the cell belongs to. Both rules create and insert a fact. Rules from the largest group of rules implement, singly or in groups of two or three, various solving techniques, as they are employed when solving Sudoku puzzles manually. Rule \"naked pair\" detects identical candidate sets of size 2 in two cells of a group; these two values may be removed from all other candidate sets of that group. A similar idea motivates the three rules \"hidden pair in…​\"; here, the rules look for a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of this group. This, then, means that all other candidates can be eliminated from the two cells harbouring the hidden pair. A pair of rules deals with \"X-wings\" in rows and columns. When there are only two possible cells for a value in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated. If you follow the pattern sequence in one of these rules, you will see how the conditions that are conveniently expressed by words such as \"same\" or \"only\" result in patterns with suitable constraints or prefixed with \"not\". The rule pair \"intersection removal…​\" is based on the restricted occurrence of some number within one square, either in a single row or in a single column. This means that this number must be in one of those two or three cells of the row or column; hence it can be removed from the candidate sets of all other cells of the group. The pattern establishes the restricted occurrence and then fires for each cell outside the square and within the same cell file. These rules are sufficient for many but certainly not for all Sudoku puzzles. To solve very difficult grids, the rule set would need to be extended with more complex rules. (Ultimately, there are puzzles that cannot be solved except by trial and error.) Name: Number Guess Main class: org.drools.examples.numberguess.NumberGuessExample Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: NumberGuess.drl Objective: Demonstrate use of Rule Flow to organise Rules The \"Number Guess\" example shows the use of Rule Flow, a way of controlling the order in which rules are fired. It uses widely understood workflow diagrams for defining the order in which groups of rules will be executed. The creation of the package and the loading of the rules (using the method) is the same as the previous examples. There is an additional line to add the Rule Flow (NumberGuess.rf ), which provides the option of specifying different rule flows for the same Knowledge Base. Otherwise, the Knowledge Base is created in the same manner as before. final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession(); KnowledgeRuntimeLogger logger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/numberguess\"); ksession.insert( new GameRules( 100, 5 ) ); ksession.insert( new RandomNumber() ); ksession.insert( new Game() ); ksession.startProcess( \"Number Guess\" ); ksession.fireAllRules(); logger.close(); ksession.dispose(); Once we have a Knowledge Base, we can use it to obtain a Stateful Session. Into our session we insert our facts, i.e., standard Java objects. (For simplicity, in this sample, these classes are all contained within our NumberGuessExample.java file. Class provides the maximum range and the number of guesses allowed. Class automatically generates a number between 0 and 100 and makes it available to our rules, by insertion via the method. Class keeps track of the guesses we have made before, and their number. Note that before we call the standard method, we also start the process that we loaded earlier, via the method. We’ll learn where to obtain the parameter we pass (\"Number Guess\", i.e., the identifier of the rule flow) when we talk about the rule flow file and the graphical Rule Flow Editor below. Before we finish the discussion of our Java code, we note that in some real-life application we would examine the final state of the objects. (Here, we could retrieve the number of guesses, to add it to a high score table.) For this example we are content to ensure that the Working Memory session is cleared by calling the method. Figure 400. RuleFlow for the NumberGuess Example If you open the NumberGuess.rf file in the Drools IDE (provided you have the JBoss Rules extensions installed correctly in Eclipse) you should see the above diagram, similar to a standard flowchart. Its icons are similar (but not exactly the same) as in the JBoss jBPM workflow product. Should you wish to edit the diagram, a menu of available components should be available to the left of the diagram in the IDE, which is called the palette. This diagram is saved in XML, an (almost) human readable format, using XStream. If it is not already open, ensure that the Properties View is visible in the IDE. It can be opened by clicking \"Window\", then \"Show View\" and \"Other\", where you can select the \"Properties\" view. If you do this before you select any item on the rule flow (or click on the blank space in the rule flow) you should be presented with the following set of properties. Keep an eye on the Properties View as we progress through the example’s rule flow, as it presents valuable information. In this case, it provides us with the identification of the Rule Flow Process that we used in our earlier code snippet, when we called . In the \"Number Guess\" Rule Flow we encounter several node types, many of them identified by an icon.\n• The Start node (white arrow in a green circle) and the End node (red box) mark beginning and end of the rule flow.\n• A Rule Flow Group box (yellow, without an icon) represents a Rule Flow Groups defined in our rules (DRL) file that we will look at later. For example, when the flow reaches the Rule Flow Group \"Too High\", only those rules marked with an attribute of `ruleflow-group can potentially fire.\n• Action nodes (yellow, cog-shaped icon) perform standard Java method calls. Most action nodes in this example call , indicating the program’s progress to the user.\n• Split and Join Nodes (blue ovals, no icon) such as \"Guess Correct?\" and \"More guesses Join\" mark places where the flow of control can split, according to various conditions, and rejoin, respectively\n• Arrows indicate the flow between the various nodes. The various nodes in combination with the rules make the Number Guess game work. For example, the \"Guess\" Rule Flow Group allows only the rule \"Get user Guess\" to fire, because only that rule has a matching attribute of `ruleflow-group . Example 324. A Rule firing only at a specific point in the Rule Flow: NumberGuess.drl rule \"Get user Guess\" ruleflow-group \"Guess\" no-loop when $r : RandomNumber() rules : GameRules( allowed : allowedGuesses ) game : Game( guessCount < allowed ) not ( Guess() ) then System.out.println( \"You have \" + ( rules.allowedGuesses - game.guessCount ) + \" out of \" + rules.allowedGuesses + \" guesses left.\n\nPlease enter your guess from 0 to \" + rules.maxRange ); br = new BufferedReader( new InputStreamReader( System.in ) ); i = br.readLine(); modify ( game ) { guessCount = game.guessCount + 1 } insert( new Guess( i ) ); end The rest of this rule is fairly standard. The LHS section (after ) of the rule states that it will be activated for each object inserted into the Working Memory where is less than from the object and where the user has not guessed the correct number. The RHS section (or consequence, after ) prints a message to the user and then awaits user input from . After obtaining this input (the method call blocks until the return key is pressed) it modifies the guess count and inserts the new guess, making both available to the Working Memory. The rest of the rules file is fairly standard: the package declares the dialect as MVEL, and various Java classes are imported. In total, there are five rules in this file:\n• Get User Guess, the Rule we examined above.\n• A Rule to inspect the guess and retract it from memory if incorrect.\n• A Rule that notifies the user that all guesses have been used up. One point of integration between the standard Rules and the RuleFlow is via the attribute on the rules, as discussed above. A second point of integration between the rules (.drl) file and the Rules Flow .rf files is that the Split Nodes (the blue ovals) can use values in the Working Memory (as updated by the rules) to decide which flow of action to take. To see how this works, click on the \"Guess Correct Node\"; then within the Properties View, open the Constraints Editor by clicking the button at the right that appears once you click on the \"Constraints\" property line. You should see something similar to the diagram below. Click on the \"Edit\" button beside \"To node Too High\" and you’ll see a dialog like the one below. The values in the \"Textual Editor\" window follow the standard rule format for the LHS and can refer to objects in Working Memory. The consequence (RHS) is that the flow of control follows this node (i.e., \"To node Too High\") if the LHS expression evaluates to true. Figure 403. Constraint Editor for the \"Guess Correct\" Node: value too high Since the file NumberGuess.java contains a method, it can be run as a standard Java application, either from the command line or via the IDE. A typical game might result in the interaction below. The numbers in bold are typed in by the user. Example 325. Example Console output where the Number Guess Example beat the human! You have 5 out of 5 guesses left. Please enter your guess from 0 to 100 50 Your guess was too high You have 4 out of 5 guesses left. Please enter your guess from 0 to 100 25 Your guess was too low You have 3 out of 5 guesses left. Please enter your guess from 0 to 100 37 Your guess was too low You have 2 out of 5 guesses left. Please enter your guess from 0 to 100 44 Your guess was too low You have 1 out of 5 guesses left. Please enter your guess from 0 to 100 47 Your guess was too low You have no more guesses The correct guess was 48 A summary of what is happening in this sample is:\n• The method of NumberGuessExample.java loads a Rule Base, creates a Stateful Session and inserts , and (containing the target number) objects into it. The method also sets the process flow we are going to use, and fires all rules. Control passes to the Rule Flow.\n• File NumberGuess.rf , the Rule Flow, begins at the \"Start\" node.\n• Control passes (via the \"More guesses\" join node) to the Guess node.\n• At the Guess node, the appropriate Rule Flow Group (\"Get user Guess\") is enabled. In this case the Rule \"Guess\" (in the NumberGuess.drl file) is triggered. This rule displays a message to the user, takes the response, and puts it into Working Memory. Flow passes to the next Rule Flow Node.\n• At the next node, \"Guess Correct\", constraints inspect the current session and decide which path to take. If the guess in step 4 was too high or too low, flow proceeds along a path which has an action node with normal Java code printing a suitable message and a Rule Flow Group causing a highest guess or lowest guess rule to be triggered. Flow passes from these nodes to step 6. If the guess in step 4 was right, we proceed along the path towards the end of the Rule Flow. Before we get there, an action node with normal Java code prints a statement \"you guessed correctly\". There is a join node here (just before the Rule Flow end) so that our no-more-guesses path (step 7) can also terminate the Rule Flow.\n• Control passes as per the Rule Flow via a join node, a guess incorrect Rule Flow Group (triggering a rule to retract a guess from Working Memory) onto the \"More guesses\" decision node.\n• The \"More guesses\" decision node (on the right hand side of the rule flow) uses constraints, again looking at values that the rules have put into the working memory, to decide if we have more guesses and if so, goto step 3. If not, we proceed to the end of the rule flow, via a Rule Flow Group that triggers a rule stating \"you have no more guesses\".\n• The loop over steps 3 to 7 continues until the number is guessed correctly, or we run out of guesses. Name: Conway's Game Of Life Main class: org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: conway-ruleflow.drl conway-agendagroup.drl Objective: Demonstrates 'accumulate', 'collect' and 'from' Conway’s Game Of Life, described in http://en.wikipedia.org/wiki/Conway’s_Game_of_Life and in http://www.math.com/students/wonders/life/life.html, is a famous cellular automaton conceived in the early 1970’s by the mathematician John Conway. While the system is well known as \"Conway’s Game Of Life\", it really isn’t a game at all. Conway’s system is more like a simulation of a form of life. Don’t be intimidated. The system is terribly simple and terribly interesting. Math and Computer Science students alike have marvelled over Conway’s system for more than 30 years now. The application presented here is a Swing-based implementation of Conway’s Game of Life. The rules that govern the system are implemented as business rules using Drools. This document will explain the rules that drive the simulation and discuss the Drools parts of the implementation. We’ll first introduce the grid view, shown below, designed for the visualisation of the game, showing the \"arena\" where the life simulation takes place. Initially the grid is empty, meaning that there are no live cells in the system. Each cell is either alive or dead, with live cells showing a green ball. Preselected patterns of live cells can be chosen from the \"Pattern\" drop-down list. Alternatively, individual cells can be doubled-clicked to toggle them between live and dead. It’s important to understand that each cell is related to its neighboring cells, which is fundamental for the game’s rules. Neighbors include not only cells to the left, right, top and bottom but also cells that are connected diagonally, so that each cell has a total of 8 neighbors. Exceptions are the four corner cells which have only three neighbors, and the cells along the four border, with five neighbors each. So what are the basic rules that govern this game? Its goal is to show the development of a population, generation by generation. Each generation results from the preceding one, based on the simultaneous evaluation of all cells. This is the simple set of rules that govern what the next generation will look like:\n• If a live cell has fewer than 2 live neighbors, it dies of loneliness.\n• If a live cell has more than 3 live neighbors, it dies from overcrowding.\n• If a dead cell has exactly 3 live neighbors, it comes to life. That is all there is to it. Any cell that doesn’t meet any of those criteria is left as is for the next generation. With those simple rules in mind, go back and play with the system a little bit more and step through some generations, one at a time, and notice these rules taking their effect. The screenshot below shows an example generation, with a number of live cells. Don’t worry about matching the exact patterns represented in the screen shot. Just get some groups of cells added to the grid. Once you have groups of live cells in the grid, or select a pre-designed pattern, click the \"Next Generation\" button and notice what happens. Some of the live cells are killed (the green ball disappears) and some dead cells come to life (a green ball appears). Step through several generations and see if you notice any patterns. If you click on the \"Start\" button, the system will evolve itself so you don’t need to click the \"Next Generation\" button over and over. Play with the system a little and then come back here for more details of how the application works. Now lets delve into the code. As this is an advanced example we’ll assume that by now you know your way around the Drools framework and are able to connect the presented highlight, so that we’ll just focus at a high level overview. The example has two ways to execute, one way uses Agenda Groups to manage execution flow, and the other one uses Rule Flow Groups to manage execution flow. These two versions are implemented in and , respectively. Here, we’ll discuss the Rule Flow version, as it’s what most people will use. All the objects are inserted into the Session and the rules in the \"register neighbor\" are allowed to execute by the Rule Flow process. This group of four rules creates relations between some cell and its northeastern, northern, northwestern and western neighbors. This relation is bidirectional, which takes care of the other four directions. Border cells don’t need any special treatment - they simply won’t be paired with neighboring cells where there isn’t any. By the time all activations have fired for these rules, all cells are related to all their neighboring cells. rule \"register north east\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northEast : Cell( row == ($row - 1), col == ( $col + 1 ) ) then insert( new Neighbor( $cell, $northEast ) ); insert( new Neighbor( $northEast, $cell ) ); end rule \"register north\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $north : Cell( row == ($row - 1), col == $col ) then insert( new Neighbor( $cell, $north ) ); insert( new Neighbor( $north, $cell ) ); end rule \"register north west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northWest : Cell( row == ($row - 1), col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $northWest ) ); insert( new Neighbor( $northWest, $cell ) ); end rule \"register west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $west : Cell( row == $row, col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $west ) ); insert( new Neighbor( $west, $cell ) ); end Once all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to Live. Then, when the user clicks \"Start\" or \"Next Generation\", it executes the \"Generation\" ruleflow. This ruleflow is responsible for the management of all changes of cells in each generation cycle. The rule flow process first enters the \"evaluate\" group, which means that any active rule in the group can fire. The rules in this group apply the Game-of-Life rules discussed in the beginning of the example, determining the cells to be killed and the ones to be given life. We use the \"phase\" attribute to drive the reasoning of the Cell by specific groups of rules; typically the phase is tied to a Rule Flow Group in the Rule Flow process definition. Notice that it doesn’t actually change the state of any objectss at this point; this is because it’s evaluating the grid in turn and it must complete the full evaluation until those changes can be applied. To achieve this, it sets the cell to a \"phase\" which is either or , used later to control actions applied to the object. Example 327. Conway’s Game of Life: Evaluate Cells with state changes rule \"Kill The Lonely\" ruleflow-group \"evaluate\" no-loop when // A live cell has fewer than 2 live neighbors theCell: Cell( liveNeighbors < 2, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Kill The Overcrowded\" ruleflow-group \"evaluate\" no-loop when // A live cell has more than 3 live neighbors theCell: Cell( liveNeighbors > 3, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Give Birth\" ruleflow-group \"evaluate\" no-loop when // A dead cell has 3 live neighbors theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE ) then modify( theCell ){ theCell.setPhase( Phase.BIRTH ); } end Once all objects in the grid have been evaluated, we first clear any calculation activations that occurred from any previous data changes. This is done via the \"reset calculate\" rule, which clears any activations in the \"calculate\" group. We then enter a split in the rule flow which allows any activations in both the \"kill\" and the \"birth\" group to fire. These rules are responsible for applying the state change. Example 328. Conway’s Game of Life: Apply the state changes rule \"reset calculate\" ruleflow-group \"reset calculate\" when then WorkingMemory wm = drools.getWorkingMemory(); wm.clearRuleFlowGroup( \"calculate\" ); end rule \"kill\" ruleflow-group \"kill\" no-loop when theCell: Cell( phase == Phase.KILL ) then modify( theCell ){ setCellState( CellState.DEAD ), setPhase( Phase.DONE ); } end rule \"birth\" ruleflow-group \"birth\" no-loop when theCell: Cell( phase == Phase.BIRTH ) then modify( theCell ){ setCellState( CellState.LIVE ), setPhase( Phase.DONE ); } end At this stage, a number of objects have been modified with the state changed to either or . Now we get to see the power of the facts defining the cell relations. When a cell becomes live or dead, we use the relation to iterate over all surrounding cells, increasing or decreasing the count. Any cell that has its count changed is also set to to the phase, to make sure it is included in the reasoning during the evaluation stage of the Rule Flow Process. Notice that we don’t have to do any iteration ourselves; simply by applying the relations in the rules we make the rule engine do all the hard work for us, with a minimal amount of code. Once the live count has been determined and set for all cells, the Rule Flow Process comes to and end. If the user has initially clicked the \"Start\" button, the engine will restart the rule flow; otherwise the user may request another generation. Example 329. Conway’s Game of Life: Evaluate cells with state changes rule \"Calculate Live\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.LIVE ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ), setPhase( Phase.EVALUATE ); } end rule \"Calculate Dead\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.DEAD ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ), setPhase( Phase.EVALUATE ); } end A simplifed version of the Space Invaders game. Use the keys Z and K, to move left and right and M to fire a misile. The example is built up over 6 projects, each adding slightly more complexity to the last. Invaders1Main creates the frame and attaches the KeyListener, feeding key events into the engine. It also sets up the main game loop which can be found in \"Main.drl\". The typical convention used through out the example is to have one agenda group per file, and all rules in that file in the same agenda group. The Run fact is used to drive the repeat of the Game loop. Initially there are only one groups that is evaluated, Keys. The \"keys.drl\" file is shared by several examples, and illustrates rule re-use across multipel projects. rule \"init\" when then insert( new Run() ); setFocus( \"Init\" ); end rule GameLoop when r : Run() then setFocus( \"Keys\" ); end rule Draw when r : Run() then ui.show(); modify( r ) {} // force loop end Invaders2Main adds the \"Draw\" stage to the game loop and draws the SpaceShip Invaders3Main adds move controls to the spaceship, notice the ship moves out of the boundaries of the screen. KeyPressed is detected and that sets a delta of dx on the ship direction. That delta is then repeated applied to the x position of the ship rule ShipDeltaMoveLeft agenda-group \"Move\" when s : Ship() KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 - s.speed } end rule ShipDeltaStopLeft agenda-group \"Move\" when s : Ship() not KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 } end rule ShipMove agenda-group \"Move\" when s : Ship( dx != 0 ) Run() then modify( s ) { x = s.x + s.dx } end Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. Invaders6Main adds a lot more meat. Pressing the \"M\" key fires a missile that travels up the screen, while moving collision between the missile and the invader is checked. Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. rule InsertBullet agenda-group \"Bullet\" when KeyPressed( keyText == \"M\" ) s : Ship() not Bullet() then b = new Bullet(); b.x = s.x + (s.width/2) - (b.width/2); b.y = s.y - s.height - b.height; b.width = conf.bulletWidth; b.height = conf.bulletHeight; b.dy = 0 - conf.bulletSpeed; insert( b ); end rule BulletMove agenda-group \"Bullet\" when b : Bullet( y > 0 ) @watch( !y ) Run() then modify( b ) { y = b.y + b.dy } end rule Collision agenda-group \"Bullet\" when b : Bullet( ) @watch( y ) i : Invader( x < b.x, x + width > b.x, y > b.y) Run() then modify( i ) { alive = false } end Based on the Adventure in Prolog, over at the Amzi website, http://www.amzi.com/AdventureInProlog/, we started to work on a text adventure game for Drools. They are ideal as they can start off simple and build in complexity and size over time, they also demonstrate key aspects of declarative relational programming. The game allows you to play as the hero or the monster. If you click \"New Window\" you can open one window as the hero and another as the monster, and play them both at the same time. The game allows either character to move around rooms, pick up, drop or use things. Doors can be locked and unlocked, by using the key on teh exit room, and the hero can kill the monster by using the umbrella on the monster. You can view the 8 minute demonstration and introduction for the example at http://downloads.jboss.org/drools/videos/text-adventures.swf. Be aware the video is now much older than the current improved example. Each action follows the constructor arguments of the associated Command java class. To issue a move action, select the \"Move\" button, then select the exit room. Notice when you press \"Move\" it adds the text to the white bar at the bottom. When the exit room is selected, it also is added to the white bar. Then press send and the game engine will execute the command. Internally it uses reflection to instantiate the Command and insert it into the engine. If you select incorrect arguments, such as pressing exits multiple times, the reflection will fail and you can attempt it again. The Things list displays anything you can see in the room, not all things can be picked up. For instance you can pick up the key and the torch, but not the monster. When something is picked up it moves from the Things list to the Inventory List. The reverse is true when something is dropped. The key is in the office, move upstairs and into the office. Then pick up the key. Move back downstairs and into the kitchen. Try and walk into the basement, notice it’s locked. Select the \"Use\" action, the select the key and then the basement exit. This will unlock the door and you can now walk through. To kill the monster pick up the umbrella from the lounge and then select \"Use\", then select the imbrella and finally select the monster. Don’t forget to open a \"New Window\" to play as the monster, although you will not be able to exit the basement until the hero has opened it with the key. The monster and the hero can also give items to each other, moving items between each playsers inventory. The model is written in Java classes. Each classes uses @PropertyReactive and @Position. @PropertyReactive allows control of which fields patterns react to, and @Position maps a field to a argument position allowing positional as well as named arguments for patterns. @PropertyReactive public class Thing { @Position(0) private long id; @Position(1) private String name; public Thing(long id, String name) { this.id = id; this.name = name; } ... } An MVEL data file is used to populate our world, see \"data.mvel\". You can edit this file to add new rooms, items and characters, as well as locks for doors. rooms = [ \"basement\" : new Room(\"basement\"), \"lounge\" : new Room(\"lounge\"), \"kitchen\" : new Room(\"kitchen\"), \"ground floor hallway\" : new Room(\"ground floor hallway\"), \"bedroom\" : new Room(\"bedroom\"), \"office\" : new Room(\"office\"), \"first floor hallway\" : new Room(\"first floor hallway\") ]; doors = [ \"d1\" : new Door( rooms[\"kitchen\"], rooms[\"basement\"] ), \"d2\" : new Door( rooms[\"ground floor hallway\"], rooms[\"lounge\"]), \"d4\" : new Door( rooms[\"ground floor hallway\"], rooms[\"kitchen\"]), \"d5\" : new Door( rooms[\"ground floor hallway\"], rooms[ \"first floor hallway\"] ), \"d8\" : new Door( rooms[\"first floor hallway\"], rooms[ \"bedroom\"] ), \"d9\" : new Door( rooms[\"first floor hallway\"], rooms[ \"office\"] ) ]; locations = [ \"monster\" : new Location( characters[\"monster\"], rooms[\"basement\"] ), \"hero\" : new Location( characters[\"hero\"], rooms[\"ground floor hallway\"] ), \"umbrella\" : new Location( items[\"umbrella\"], rooms[\"lounge\"] ), \"key1\" : new Location( items[\"key1\"], rooms[\"office\"] ) ]; The game creates commands, which it inserts into the engine. These commands are then used to change the state of the world and that state is reflected back in the UI. The commands can be found in the \"commands.drl\" file. The following rule matches the MoveCommand and if it’s valid it will make the move happen. rule validMove agenda-group \"commands\" when mc : MoveCommand( c : character, r : room ) l : Location( thing == c, ltarget : target ) @watch( !target ) ?connect( d, r, ltarget; ) then exit = new ExitEvent( c, (Room) l.target ); enter = new EnterEvent( c, r ); modify( l ) { target = r }; insert( exit ); insert( enter ); mc.session.channels[\"output\"].send( \"You have entered the \" + l.target.name + \"\n\n\" ); end In the above rules notice the \"connect\" pattern, this is actually a query. In the MVEL data file doors are only described one way, we can use a query to check connections bi-directionally. The queries can be found in the \"queries.drl\" file. query connect( Door $d, Room $x, Room $y ) $d := Door($id, $name, $x, $y;) or $d :=Door($id, $name, $y, $x;) end The UI has its list boxes populated by rules found in \"UiView.drl\", those rules in turn use queries. Here is how the \"Things\" list box is populated, when ever the world changes. rule updateThings salience 5 when session : UserSession( $char : character ) things( $char, $things; ) then session.channels[\"things\"].send( $things ); end query things(Character $char, List $things) $char := Character() Location( $char, $room; ) $things := List() from accumulate( Location($thing, $room; thing != $char), collectList( $thing ) ) end A Conversion for the classic game Pong. Use the keys A, Z and K, M. The ball should get faster after each bounce. Wumpus World is an AI example covered in the book \"Artificial Intelligence : A Modern Approach\". When the game first starts all the cells are greyed out. As you walk around they become visible. The cave has pits, a wumpus and gold. When you are next to a pit you will feel a breeze, when you are next to the wumpus you will smell a stench and see glitter when next to gold. The sensor icons are shown above the move buttons. If you walk into a pit or the wumpus, you die. A more detailed overview of Wumpus World can be found at http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml. A 20 minute video showing how the game is created and works is at http://www.youtube.com/watch?v=4CvjKqUOEzM. Name: Miss Manners Main class: org.drools.benchmark.manners.MannersBenchmark Module: drools-examples Type: Java application Rules file: manners.drl Objective: Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth. Miss Manners is throwing a party and, being a good host, she wants to arrange good seating. Her initial design arranges everyone in male-female pairs, but then she worries about people have things to talk about. What is a good host to do? She decides to note the hobby of each guest so she can then arrange guests not only pairing them according to alternating sex but also ensuring that a guest has someone with a common hobby, at least on one side. Five benchmarks were established in the 1991 paper \"Effects of Database Size on Rule System Performance: Five Case Studies\" by David Brant, Timothy Grose, Bernie Lofaso and Daniel P. Miranker:\n• Manners uses a depth-first search approach to determine the seating arrangements alternating women and men and ensuring one common hobby for neighbors.\n• Waltz establishes a three-dimensional interpretation of a line drawing by line labeling by constraint propagation.\n• WaltzDB is a more general version of Waltz, supporting junctions of more than three lines and using a database.\n• ARP is a route planner for a robotic air vehicle using the A* search algorithm to achieve minimal cost.\n• Weaver VLSI router for channels and boxes using a black-board technique. Manners has become the de facto rule engine benchmark. Its behavior, however, is now well known and many engines optimize for this, thus negating its usefulness as a benchmark which is why Waltz is becoming more favorable. These five benchmarks are also published at the University of Texas http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/. After the first seating arrangement has been assigned, a depth-first recursion occurs which repeatedly assigns correct seating arrangements until the last seat is assigned. Manners uses a instance to control execution flow. The activity diagram is partitioned to show the relation of the rule execution to the current state. Before going deeper into the rules, let’s first take a look at the asserted data and the resulting seating arrangement. The data is a simple set of five guests who should be arranged so that sexes alternate and neighbors have a common hobby. The data is given in OPS5 syntax, with a parenthesized list of name and value pairs for each attribute. Each person has only one hobby. Each line of the results list is printed per execution of the \"Assign Seat\" rule. They key bit to notice is that each line has a \"pid\" value one greater than the last. (The significance of this will be explained in the discussion of the rule \"Assign Seating\".) The \"ls\", \"rs\", \"ln\" and \"rn\" refer to the left and right seat and neighbor’s name, respectively. The actual implementation uses longer attribute names (e.g., , but here we’ll stick to the notation from the original implementation. Manners has been designed to exercise cross product joins and Agenda activities. Many people not understanding this tweak the example to achieve better performance, making their port of the Manners benchmark pointless. Known cheats or porting errors for Miss Manners are:\n• Using arrays for a guests hobbies, instead of asserting each one as a single fact massively reduces the cross products.\n• Altering the sequence of data can also reduce the amount of matching, increasing execution speed.\n• It’s possible to change the Conditional Element so that the test algorithm only uses the \"first-best-match\", which is, basically, transforming the test algorithm to backward chaining. The results are only comparable to other backward chaining rule engines or ports of Manners.\n• Removing the context so the rule engine matches the guests and seats prematurely. A proper port will prevent facts from matching using the context start.\n• It’s possible to prevent the rule engine from performing combinatorial pattern matching.\n• If no facts are retracted in the reasoning cycle, as a result of the CE, the port is incorrect. The Manners benchmark was written for OPS5 which has two conflict resolution strategies, LEX and MEA. LEX is a chain of several strategies including salience, recency and complexity. The recency part of the strategy drives the depth first (LIFO) firing order. The CLIPS manual documents the Recency strategy as follows: Every fact and instance is marked internally with a \"time tag\" to indicate its relative recency with respect to every other fact and instance in the system. The pattern entities associated with each rule activation are sorted in descending order for determining placement. An activation with a more recent pattern entity is placed before activations with less recent pattern entities. To determine the placement order of two activations, compare the sorted time tags of the two activations one by one starting with the largest time tags. The comparison should continue until one activation’s time tag is greater than the other activation’s corresponding time tag. The activation with the greater time tag is placed before the other activation on the agenda. If one activation has more pattern entities than the other activation and the compared time tags are all identical, then the activation with more time tags is placed before the other activation on the agenda. However Jess and CLIPS both use the Depth strategy, which is simpler and lighter, which Drools also adopted. The CLIPS manual documents the Depth strategy as: Newly activated rules are placed above all rules of the same salience. For example, given that fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda. However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary. The initial Drools implementation for the Depth strategy would not work for Manners without the use of salience on the \"make_path\" rule. The CLIPS support team had this to say: The default conflict resolution strategy for CLIPS, Depth, is different than the default conflict resolution strategy used by OPS5. Therefore if you directly translate an OPS5 program to CLIPS, but use the default depth conflict resolution strategy, you’re only likely to get the correct behavior by coincidence. The LEX and MEA conflict resolution strategies are provided in CLIPS to allow you to quickly convert and correctly run an OPS5 program in CLIPS. Investigation into the CLIPS code reveals there is undocumented functionality in the Depth strategy. There is an accumulated time tag used in this strategy; it’s not an extensively fact by fact comparison as in the recency strategy, it simply adds the total of all the time tags for each activation and compares. Once the context is changed to , activations are created for all asserted guest. Because all activations are created as the result of a single Working Memory action, they all have the same Activation time tag. The last asserted object would have a higher fact time tag, and its Activation would fire because it has the highest accumulated fact time tag. The execution order in this rule has little importance, but has a big impact in the rule \"Assign Seat\". The activation fires and asserts the first arrangement and a , and then sets the attribute to create an activation for rule . rule assignFirstSeat when context : Context( state == Context.START_UP ) guest : Guest() count : Count() then String guestName = guest.getName(); Seating seating = new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName); insert( seating ); Path path = new Path( count.getValue(), 1, guestName ); insert( path ); modify( count ) { setValue ( count.getValue() + 1 ) } System.out.println( \"assign first seat : \" + seating + \" : \" + path ); modify( context ) { setState( Context.ASSIGN_SEATS ) } end This rule determines each of the arrangements. The rule creates cross product solutions for all asserted arrangements against all the asserted guests except against itself or any already assigned chosen solutions. rule findSeating when context : Context( state == Context.ASSIGN_SEATS ) $s : Seating( pathDone == true ) $g1 : Guest( name == $s.rightGuestName ) $g2 : Guest( sex != $g1.sex, hobby == $g1.hobby ) count : Count() not ( Path( id == $s.id, guestName == $g2.name) ) not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) ) then int rightSeat = $s.getRightSeat(); int seatId = $s.getId(); int countValue = count.getValue(); Seating seating = new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ); insert( seating ); Path path = new Path( countValue, rightSeat + 1, $g2.getName() ); insert( path ); Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() ); insert( chosen ); System.err.println( \"find seating : \" + seating + \" : \" + path + \" : \" + chosen); modify( count ) {setValue( countValue + 1 )} modify( context ) {setState( Context.MAKE_PATH )} end However, as can be seen from the printed results shown earlier, it is essential that only the with the highest cross product be chosen. How can this be possible if we have activations, of the same time tag, for nearly all existing and objects? For example, on the third iteration of the produced activations will be as shown below. Remember, this is from a very small data set, and with larger data sets there would be many more possible activated solutions, with multiple solutions per : The creation of all these redundant activations might seem pointless, but it must be remembered that Manners is not about good rule design; it’s purposefully designed as a bad ruleset to fully stress-test the cross product matching process and the Agenda, which this clearly does. Notice that each activation has the same time tag of 35, as they were all activated by the change in the object to . With OPS5 and LEX it would correctly fire the activation with the asserted last. With Depth, the accumulated fact time tag ensures that the activation with the last asserted fires. Rule must always fire before . A object is asserted for each arrangement, up to the last asserted . Notice that the conditions in are a subset of those in - so how do we ensure that fires first? rule makePath when Context( state == Context.MAKE_PATH ) Seating( seatingId:id, seatingPid:pid, pathDone == false ) Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat ) not Path( id == seatingId, guestName == pathGuestName ) then insert( new Path( seatingId, pathSeat, pathGuestName ) ); end Both rules end up on the Agenda in conflict and with identical activation time tags. However, the accumulate fact time tag is greater for \"Make Path\" so it gets priority. Rule only activates when the last seat is assigned, at which point both rules will be activated. For the same reason that always wins over , will take priority over rule . Assign First seat =>[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] =>[fid:14:14]:[Path id=1, seat=1, guest=n5] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1 , pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]* Assign Seating =>[fid:15:17] :[Seating id=2 , pid=1 , done=false, ls=1, lg=n5, rs=2, rn=n4] =>[fid:16:18]:[Path id=2, seat=2, guest=n4] =>[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1] =>[ActivationCreated(21): rule=makePath [fid:15:17] : [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] [fid:14:14] : [Path id=1, seat=1, guest=n5]* ==>[ActivationCreated(21): rule=pathDone [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]* Make Path =>[fid:18:22:[Path id=2, seat=1, guest=n5]] Path Done Continue Process =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:7:7]:[Guest name=n4, sex=f, hobbies=h3] [fid:4:4] : [Guest name=n3, sex=m, hobbies=h3]* =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3] =>[ActivationCreated(25): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]] =>[fid:20:27]:[Path id=3, seat=3, guest=n3]] =>[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}] =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:18:22]:[Path id=2, seat=1, guest=n5]* =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:16:18]:[Path id=2, seat=2, guest=n4]* =>[ActivationCreated(30): rule=done [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]* Make Path =>[fid:22:31]:[Path id=3, seat=1, guest=n5] Make Path =>[fid:23:32] [Path id=3, seat=2, guest=n4] Path Done Continue Processing =>[ActivationCreated(35): rule=findSeating [fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] [fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest name=n2, sex=f, hobbies=h3], [fid:12:29]* =>[ActivationCreated(35): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(35): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]] =>[fid:25:37]:[Path id=4, seat=4, guest=n2]] =>[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3] ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:23:32]:[Path id=3, seat=2, guest=n4]* ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:20:27]:[Path id=3, seat=3, guest=n3]* =>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:22:31]:[Path id=3, seat=1, guest=n5]* =>[ActivationCreated(40): rule=done [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]* Make Path =>fid:27:41:[Path id=4, seat=2, guest=n4] Make Path =>fid:28:42]:[Path id=4, seat=1, guest=n5]] Make Path =>fid:29:43]:[Path id=4, seat=3, guest=n3]] Path Done Continue Processing =>[ActivationCreated(46): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1], [fid:2:2] [Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(46): rule=findSeating [fid:24:44]:[Seating id=4, pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]* =>[ActivationCreated(46): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:30:47]:[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1] =>[fid:31:48]:[Path id=5, seat=5, guest=n1] =>[fid:32:49]:[Chosen id=4, name=n1, hobbies=h1] A backward-chaining rule system is goal-driven. This means the system starts with a conclusion which the engine tries to satisfy. If it cannot do so it searches for sub-goals, that is, conclusions that will complete part of the current goal. It continues this process until either the initial conclusion is satisfied or there are no more unsatisfied sub-goals. Prolog is an example of a backward-chaining engine. Backward-Chaining is a feature recently added to the JBoss Rules Engine. This process is often referred to as derivation queries, and it is not as common compared to reactive systems since JBoss Rules is primarily reactive forward chaining. That is, it responds to changes in your data. The backward-chaining added to the engine is for product-like derivations. The previous chart demonstrates a House example of transitive items. A similar reasoning chart can be created by implementing the following rules: 1. First, create some java rules to develop reasoning for transitive items. It inserts each of the locations. 2. Next, create the Location class; it has the item and where it is located. 3. Type the rules for the House example as depicted below: ksession.insert( new Location(\"office\", \"house\") ); ksession.insert( new Location(\"kitchen\", \"house\") ); ksession.insert( new Location(\"knife\", \"kitchen\") ); ksession.insert( new Location(\"cheese\", \"kitchen\") ); ksession.insert( new Location(\"desk\", \"office\") ); ksession.insert( new Location(\"chair\", \"office\") ); ksession.insert( new Location(\"computer\", \"desk\") ); ksession.insert( new Location(\"drawer\", \"desk\") ); 4. A transitive design is created in which the item is in its designated location such as a \"desk\" located in an \"office.\" 1. Create a query to look at the data inserted into the rules engine: Notice how the query is recursive and is calling \"isContainedIn.\" 2. Create a rule to print out every string inserted into the system to see how things are implemented. The rule should resemble the following format: rule \"go\" salience 10 when $s : String( ) then System.out.println( $s ); end 3. Using Step 2 as a model, create a rule that calls upon the Step 1 query \"isContainedIn.\" rule \"go1\" when String( this == \"go1\" ) isContainedIn(\"office\", \"house\"; ) then System.out.println( \"office is in the house\" ); end The \"go1\" rule will fire when the first string is inserted into the engine. That is, it asks if the item \"office\" is in the location \"house.\" Therefore, the Step 1 query is evoked by the previous rule when the \"go1\" String is inserted. 4. Create the \"go1,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go1\" ); ksession.fireAllRules(); --- go1 office is in the house The --- line indicates the separation of the output of the engine from the firing of the \"go\" rule and the \"go1\" rule. 1. Create a Transitive Closure by implementing the following rule: rule \"go2\" when String( this == \"go2\" ) isContainedIn(\"drawer\", \"house\"; ) then System.out.println( \"Drawer in the House\" ); end 2. Recall from the Cloning Transitive Closure’s topic, there was no instance of \"drawer\" in \"house.\" \"drawer\" was located in \"desk.\" 3. Use the previous query for this recursive information. 4. Create the \"go2,\" insert it into the engine, and call the fireAllRules. When the rule is fired, it correctly tells you \"go2\" has been inserted and that the \"drawer\" is in the \"house.\" 5. Check how the engine determined this outcome\n• The query has to recurse down several levels to determine this.\n• Instead of using Location( x, y; ), The query uses the value of (z, y; ) since \"drawer\" is not in \"house.\"\n• The z is currently unbound which means it has no value and will return everything that is in the argument.\n• y is currently bound to \"house,\" so z will return \"office\" and \"kitchen.\"\n• Information is gathered from \"office\" and checks recursively if the \"drawer\" is in the \"office.\" The following query line is being called for these parameters: isContainedIn (x ,z; ) There is no instance of \"drawer\" in \"office;\" therefore, it does not match. With z being unbound, it will return data that is within the \"office,\" and it will gather that z == desk. isContainedIn recurses three times. On the final recurse, an instance triggers of \"drawer\" in the \"desk.\" This matches on the first location and recurses back up, so we know that \"drawer\" is in the \"desk,\" the \"desk\" is in the \"office,\" and the \"office\" is in the \"house;\" therefore, the \"drawer\" is in the \"house\" and returns true. 1. Create a Reactive Transitive Query by implementing the following rule: rule \"go3\" when String( this == \"go3\" ) isContainedIn(\"key\", \"office\"; ) then System.out.println( \"Key in the Office\" ); end Reactive Transitive Queries can ask a question even if the answer can not be satisfied. Later, if it is satisfied, it will return an answer. 2. Use the same query for this reactive information. 3. Create the \"go3,\" insert it into the engine, and call the fireAllRules. The first rule that matches any String returns \"go3\" but nothing else is returned because there is no answer; however, while \"go3\" is inserted in the system, it will continuously wait until it is satisfied. 4. Insert a new location of \"key\" in the \"drawer\": ksession.insert( new Location(\"key\", \"drawer\") ); ksession.fireAllRules(); --- Key in the Office This new location satisfies the transitive closure because it is monitoring the entire graph. In addition, this process now has four recursive levels in which it goes through to match and fire the rule. 1. Create a Query with Unbound Arguments by implementing the following rule: rule \"go4\" when String( this == \"go4\" ) isContainedIn(thing, \"office\"; ) then System.out.println( \"thing\" + thing + \"is in the Office\" ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. 2. Use the query for the unbound arguments. 3. Create the \"go4,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go4\" ); ksession.fireAllRules(); --- go4 thing Key is in the Office thing Computer is in the Office thing Drawer is in the Office thing Desk is in the Office thing Chair is in the Office When \"go4\" is inserted, it returns all the previous information that is transitively below \"Office.\" 1. Create a query with Mulitple Unbound Arguments by implementing the following rule: rule \"go5\" when String( this == \"go5\" ) isContainedIn(thing, location; ) then System.out.println( \"thing\" + thing + \"is in\" + location ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. Both thing and location are unbound out variables, and without bound arguments, everything is called upon. 2. Use the query for multiple unbound arguments. 3. Create the \"go5,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go5\" ); ksession.fireAllRules(); --- go5 thing Knife is in House thing Cheese is in House thing Key is in House thing Computer is in House thing Drawer is in House thing Desk is in House thing Chair is in House thing Key is in Office thing Computer is in Office thing Drawer is in Office thing Key is in Desk thing Office is in House thing Computer is in Desk thing Knife is in Kitchen thing Cheese is in Kitchen thing Kitchen is in House thing Key is in Drawer thing Drawer is in Desk thing Desk is in Office thing Chair is in Office When \"go5\" is called, it returns everything within everything."
    },
    {
        "link": "https://docs.jboss.org/drools/release/7.1.0.Final/drools-docs/html_single",
        "document": "So where do we get started? There are so many use cases and so much functionality in a rule engine such as Drools that it becomes beguiling. Have no fear my intrepid adventurer, the complexity is layered and you can ease yourself in with simple use cases. Stateless session, not utilising inference, forms the simplest use case. A stateless session can be called like a function passing it some data and then receiving some results back. Some common use cases for stateless sessions are, but not limited to:\n• \n• Is this person eligible for a mortgage?\n• \n• Filter incoming messages, such as emails, into folders. So let’s start with a very simple example using a driving license application. public class Applicant { private String name; private int age; private boolean valid; // getter and setter methods here } Now that we have our data model we can write our first rule. We assume that the application uses rules to reject invalid applications. As this is a simple validation use case we will add a single rule to disqualify any applicant younger than 18. package com.company.license rule \"Is of valid age\" when $a : Applicant( age < 18 ) then $a.setValid( false ); end To make the engine aware of data, so it can be processed against the rules, we have to insert the data, much like with a database. When the Applicant instance is inserted into the engine it is evaluated against the constraints of the rules, in this case just two constraints for one rule. We say two because the type Applicant is the first object type constraint, and is the second field constraint. An object type constraint plus its zero or more field constraints is referred to as a pattern. When an inserted instance satisfies both the object type constraint and all the field constraints, it is said to be matched. The is a binding variable which permits us to reference the matched object in the consequence. There its properties can be updated. The dollar character ('$') is optional, but it helps to differentiate variable names from field names. The process of matching patterns against the inserted data is, not surprisingly, often referred to as pattern matching. To use this rule it is necessary to put it a Drools file, just a plain text file with .drl extension , short for \"Drools Rule Language\". Let’s call this file licenseApplication.drl, and store it in a Kie Project. A Kie Project has the structure of a normal Maven project with an additional file (kmodule.xml) defining the s and s that can be created. This file has to be placed in the resources/META-INF folder of the Maven project while all the other Drools artifacts, such as the licenseApplication.drl containing the former rule, must be stored in the resources folder or in any other subfolder under it. Since meaningful defaults have been provided for all configuration aspects, the simplest kmodule.xml file can contain just an empty kmodule tag like the following: At this point it is possible to create a that reads the files to be built, from the classpath. The above code snippet compiles all the DRL files found on the classpath and put the result of this compilation, a , in the . If there are no errors, we are now ready to create our session from the and execute against some data: The preceding code executes the data against the rules. Since the applicant is under the age of 18, the application is marked as invalid. So far we’ve only used a single instance, but what if we want to use more than one? We can execute against any object implementing Iterable, such as a collection. Let’s add another class called , which has the date of the application, and we’ll also move the boolean valid field to the class. public class Applicant { private String name; private int age; // getter and setter methods here } public class Application { private Date dateApplied; private boolean valid; // getter and setter methods here } We will also add another rule to validate that the application was made within a period of time. package com.company.license rule \"Is of valid age\" when Applicant( age < 18 ) $a : Application() then $a.setValid( false ); end rule \"Application was made this year\" when $a : Application( dateApplied > \"01-jan-2009\" ) then $a.setValid( false ); end Unfortunately a Java array does not implement the interface, so we have to use the JDK converter method . The code shown below executes against an iterable list, where all collection elements are inserted before any matched rules are fired. StatelessKieSession kSession = kContainer.newStatelessKieSession(); Applicant applicant = new Applicant( \"Mr John Smith\", 16 ); Application application = new Application(); assertTrue( application.isValid() ); ksession.execute( Arrays.asList( new Object[] { application, applicant } ) ); assertFalse( application.isValid() ); The two execute methods and are actually convenience methods for the interface 's method . The commands factory, obtainable from the like all other factories of the KIE API, is used to create commands, so that the following is equivalent to : Batch Executor and Command Factory are particularly useful when working with multiple Commands and with output identifiers for obtaining results. KieCommands kieCommands = kieServices.getCommands(); List<Command> cmds = new ArrayList<Command>(); cmds.add( kieCommands.newInsert( new Person( \"Mr John Smith\" ), \"mrSmith\", true, null ) ); cmds.add( kieCommands.newInsert( new Person( \"Mr John Doe\" ), \"mrDoe\", true, null ) ); BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) ); assertEquals( new Person( \"Mr John Smith\" ), results.getValue( \"mrSmith\" ) ); supports many other Commands that can be used in the like , , and . Stateful Sessions are long lived and allow iterative changes over time. Some common use cases for Stateful Sessions are, but not limited to: In contrast to a Stateless Session, the method must be called afterwards to ensure there are no memory leaks, as the KieBase contains references to Stateful Knowledge Sessions when they are created. Since Stateful Knowledge Session is the most commonly used session type it is just named in the KIE API. also supports the interface, like , the only difference being that the command is not automatically called at the end for a Stateful Session. We illustrate the monitoring use case with an example for raising a fire alarm. Using just four classes, we represent rooms in a house, each of which has one sprinkler. If a fire starts in a room, we represent that with a single instance. public class Room { private String name // getter and setter methods here } public class Sprinkler { private Room room; private boolean on; // getter and setter methods here } public class Fire { private Room room; // getter and setter methods here } public class Alarm { } In the previous section on Stateless Sessions the concepts of inserting and matching against data were introduced. That example assumed that only a single instance of each object type was ever inserted and thus only used literal constraints. However, a house has many rooms, so rules must express relationships between objects, such as a sprinkler being in a certain room. This is best done by using a binding variable as a constraint in a pattern. This \"join\" process results in what is called cross products, which are covered in the next section. When a fire occurs an instance of the class is created, for that room, and inserted into the session. The rule uses a binding on the field of the object to constrain matching to the sprinkler for that room, which is currently off. When this rule fires and the consequence is executed the sprinkler is turned on. rule \"When there is a fire turn on the sprinkler\" when Fire($room : room) $sprinkler : Sprinkler( room == $room, on == false ) then modify( $sprinkler ) { setOn( true ) }; System.out.println( \"Turn on the sprinkler for room \" + $room.getName() ); end Whereas the Stateless Session uses standard Java syntax to modify a field, in the above rule we use the statement, which acts as a sort of \"with\" statement. It may contain a series of comma separated Java expressions, i.e., calls to setters of the object selected by the statement’s control expression. This modifies the data, and makes the engine aware of those changes so it can reason over them once more. This process is called inference, and it’s essential for the working of a Stateful Session. Stateless Sessions typically do not use inference, so the engine does not need to be aware of changes to data. Inference can also be turned off explicitly by using the sequential mode. So far we have rules that tell us when matching data exists, but what about when it does not exist? How do we determine that a fire has been extinguished, i.e., that there isn’t a object any more? Previously the constraints have been sentences according to Propositional Logic, where the engine is constraining against individual instances. Drools also has support for First Order Logic that allows you to look at sets of data. A pattern under the keyword matches when something does not exist. The rule given below turns the sprinkler off as soon as the fire in that room has disappeared. rule \"When the fire is gone turn off the sprinkler\" when $room : Room( ) $sprinkler : Sprinkler( room == $room, on == true ) not Fire( room == $room ) then modify( $sprinkler ) { setOn( false ) }; System.out.println( \"Turn off the sprinkler for room \" + $room.getName() ); end While there is one sprinkler per room, there is just a single alarm for the building. An object is created when a fire occurs, but only one is needed for the entire building, no matter how many fires occur. Previously was introduced to match the absence of a fact; now we use its complement which matches for one or more instances of some category. rule \"Raise the alarm when we have one or more fires\" when exists Fire() then insert( new Alarm() ); System.out.println( \"Raise the alarm\" ); end Likewise, when there are no fires we want to remove the alarm, so the keyword can be used again. rule \"Cancel the alarm when all the fires have gone\" when not Fire() $alarm : Alarm() then delete( $alarm ); System.out.println( \"Cancel the alarm\" ); end Finally there is a general health status message that is printed when the application first starts and after the alarm is removed and all sprinklers have been turned off. rule \"Status output when things are ok\" when not Alarm() not Sprinkler( on == true ) then System.out.println( \"Everything is ok\" ); end As we did in the Stateless Session example, the above rules should be placed in a single DRL file and saved into the resouces folder of your Maven project or any of its subfolder. As before, we can then obtain a from the . The only difference is that this time we create a Stateful Session, whereas before we created a Stateless Session. With the session created it is now possible to iteratively work with it over time. Four objects are created and inserted, as well as one object for each room. At this point the engine has done all of its matching, but no rules have fired yet. Calling allows the matched rules to fire, but without a fire that will just produce the health message. String[] names = new String[]{\"kitchen\", \"bedroom\", \"office\", \"livingroom\"}; Map<String,Room> name2room = new HashMap<String,Room>(); for( String name: names ){ Room room = new Room( name ); name2room.put( name, room ); ksession.insert( room ); Sprinkler sprinkler = new Sprinkler( room ); ksession.insert( sprinkler ); } ksession.fireAllRules(); > Everything is ok We now create two fires and insert them; this time a reference is kept for the returned . A Fact Handle is an internal engine reference to the inserted instance and allows instances to be retracted or modified at a later point in time. With the fires now in the engine, once is called, the alarm is raised and the respective sprinklers are turned on. > Raise the alarm > Turn on the sprinkler for room kitchen > Turn on the sprinkler for room office After a while the fires will be put out and the instances are retracted. This results in the sprinklers being turned off, the alarm being cancelled, and eventually the health message is printed again. > Cancel the alarm > Turn off the sprinkler for room office > Turn off the sprinkler for room kitchen > Everything is ok Everyone still with me? That wasn’t so hard and already I’m hoping you can start to see the value and power of a declarative rule system. People often confuse methods and rules, and new rule users often ask, \"How do I call a rule?\" After the last section, you are now feeling like a rule expert and the answer to that is obvious, but let’s summarize the differences nonetheless. rule \"Hello World\" when Person( name == \"Chuck\" ) then System.out.println( \"Hello Chuck\" ); end\n• Rules execute by matching against any data as long it is inserted into the engine.\n• Rules can never be called directly.\n• Specific instances cannot be passed to a rule.\n• Depending on the matches, a rule may fire once or several times, or not at all. Earlier the term \"cross product\" was mentioned, which is the result of a join. Imagine for a moment that the data from the fire alarm example were used in combination with the following rule where there are no field constraints: In SQL terms this would be like doing and every row in the Room table would be joined with every row in the Sprinkler table resulting in the following output: These cross products can obviously become huge, and they may very well contain spurious data. The size of cross products is often the source of performance problems for new rule authors. From this it can be seen that it’s always desirable to constrain the cross products, which is done with the variable constraint. This results in just four rows of data, with the correct Sprinkler for each Room. In SQL (actually HQL) the corresponding query would be . The Agenda is a Rete feature. It maintains set of rules that are able to execute, its job is to schedule that execution in a deterministic order. During actions on the , rules may become fully matched and eligible for execution; a single Rule Runtime Action can result in multiple eligible rules. When a rule is fully matched a Rule Match is created, referencing the rule and the matched facts, and placed onto the Agenda. The Agenda controls the execution order of these Matches using a Conflict Resolution strategy. The engine cycles repeatedly through two phases:\n• Rule Runtime Actions. This is where most of the work takes place, either in the Consequence (the RHS itself) or the main Java application process. Once the Consequence has finished or the main Java application process calls the engine switches to the Agenda Evaluation phase.\n• Agenda Evaluation. This attempts to select a rule to fire. If no rule is found it exits, otherwise it fires the found rule, switching the phase back to Rule Runtime Actions. The process repeats until the agenda is clear, in which case control returns to the calling application. When Rule Runtime Actions are taking place, no rules are being fired. So far the data and the matching process has been simple and small. To mix things up a bit a new example will be explored that handles cashflow calculations over date periods. The state of the engine will be illustratively shown at key stages to help get a better understanding of what is actually going on under the hood. Three classes will be used, as shown below. This will help us grow our understanding of pattern matching and joins further. We will then use this to illustrate different techniques for execution control. public class CashFlow { private Date date; private double amount; private int type; long accountNo; // getter and setter methods here } public class Account { private long accountNo; private double balance; // getter and setter methods here } public AccountPeriod { private Date start; private Date end; // getter and setter methods here } By now you already know how to create KieBases and how to instantiate facts to populate the , so tables will be used to show the state of the inserted data, as it makes things clearer for illustration purposes. The tables below show that a single fact was inserted for the . Also inserted are a series of debits and credits as objects for that account, extending over two quarters. Two rules can be used to determine the debit and credit for that quarter and update the Account balance. The two rules below constrain the cashflows for an account for a given time period. Notice the \"&&\" which use short cut syntax to avoid repeating the field name twice. rule \"increase balance for credits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"decrease balance for debits\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == DEBIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance -= $amount; end Earlier we showed how rules would equate to SQL, which can often help people with an SQL background to understand rules. The two rules above can be represented with two views and a trigger for each view, as below: select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == CREDIT and cf.date >= ap.start and cf.date <= ap.end select * from Account acc, Cashflow cf, AccountPeriod ap where acc.accountNo == cf.accountNo and cf.type == DEBIT and cf.date >= ap.start and cf.date <= ap.end If the is set to the first quarter we constrain the rule \"increase balance for credits\" to fire on two rows of data and \"decrease balance for debits\" to act on one row of data. The two cashflow tables above represent the matched data for the two rules. The data is matched during the insertion stage and, as you discovered in the previous chapter, does not fire straight away, but only after is called. Meanwhile, the rule plus its matched data is placed on the Agenda and referred to as an RuIe Match or Rule Instance. The Agenda is a table of Rule Matches that are able to fire and have their consequences executed, as soon as fireAllRules() is called. Rule Matches on the Agenda are referred to as a conflict set and their execution is determine by a conflict resolution strategy. Notice that the order of execution so far is considered arbitrary. After all of the above activations are fired, the account has a balance of -25. If the is updated to the second quarter, we have just a single matched row of data, and thus just a single Rule Match on the Agenda. The firing of that Activation results in a balance of 25. What if you don’t want the order of rule execution to be arbitrary? When there is one or more Rule Match on the Agenda they are said to be in conflict, and a conflict resolution strategy is used to determine the order of execution. The Drools strategy is very simple and based around a salience value, which assigns a priority to a rule. Each rule has a default value of 0, the higher the value the higher the priority. As a general rule, it is a good idea not to count on rules firing in any particular order, and to author the rules without worrying about a \"flow\". However when a flow is needed a number of possibilities exist beyond salience: agenda groups, rule flow groups, activation groups and control/semaphore facts. As of Drools 6.0 rule definition order in the source file is used to set priority after salience. To illustrate Salience we add a rule to print the account balance, where we want this rule to be executed after all the debits and credits have been applied for all accounts. We achieve this by assigning a negative salience to this rule so that it fires after all rules with the default salience 0. rule \"Print balance for AccountPeriod\" salience -50 when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end The table below depicts the resulting Agenda. The three debit and credit rules are shown to be in arbitrary order, while the print rule is ranked last, to execute afterwards. Agenda groups allow you to place rules into groups, and to place those groups onto a stack. The stack has push/pop bevaviour. Calling \"setFocus\" places the group onto the stack: The agenda always evaluates the top of the stack. When all the rules have fired for a group, it is popped from the stack and the next group is evaluated. rule \"increase balance for credits\" agenda-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" agenda-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end First set the focus to the \"report\" group and then by placing the focus on \"calculation\" we ensure that group is evaluated first. Drools also features ruleflow-group attributes which allows workflow diagrams to declaratively specify when rules are allowed to fire. The screenshot below is taken from Eclipse using the Drools plugin. It has two ruleflow-group nodes which ensures that the calculation rules are executed before the reporting rules. The use of the ruleflow-group attribute in a rule is shown below. rule \"increase balance for credits\" ruleflow-group \"calculation\" when ap : AccountPeriod() acc : Account( $accountNo : accountNo ) CashFlow( type == CREDIT, accountNo == $accountNo, date >= ap.start && <= ap.end, $amount : amount ) then acc.balance += $amount; end rule \"Print balance for AccountPeriod\" ruleflow-group \"report\" when ap : AccountPeriod() acc : Account() then System.out.println( acc.accountNo + \" : \" + acc.balance ); end Inference has a bad name these days, as something not relevant to business use cases and just too complicated to be useful. It is true that contrived and complicated examples occur with inference, but that should not detract from the fact that simple and useful ones exist too. But more than this, correct use of inference can crate more agile and less error prone business rules, which are easier to maintain. So what is inference? Something is inferred when we gain knowledge of something from using previous knowledge. For example, given a Person fact with an age field and a rule that provides age policy control, we can infer whether a Person is an adult or a child and act on this. rule \"Infer Adult\" when $p : Person( age >= 18 ) then insert( new IsAdult( $p ) ) end Due to the preceding rule, every Person who is 18 or over will have an instance of IsAdult inserted for them. This fact is special in that it is known as a relation. We can use this inferred relation in any rule: So now we know what inference is, and have a basic example, how does this facilitate good rule design and maintenance? Let’s take a government department that are responsible for issuing ID cards when children become adults, henceforth referred to as ID department. They might have a decision table that includes logic like this, which says when an adult living in London is 18 or over, issue the card: However the ID department does not set the policy on who an adult is. That’s done at a central government level. If the central government were to change that age to 21, this would initiate a change management process. Someone would have to liaise with the ID department and make sure their systems are updated, in time for the law going live. This change management process and communication between departments is not ideal for an agile environment, and change becomes costly and error prone. Also the card department is managing more information than it needs to be aware of with its \"monolithic\" approach to rules management which is \"leaking\" information better placed elsewhere. By this I mean that it doesn’t care what explicit age ▸ = 18 information determines whether someone is an adult, only that they are an adult. In contrast to this, let’s pursue an approach where we split (de-couple) the authoring responsibilities, so that both the central government and the ID department maintain their own rules. It’s the central government’s job to determine who is an adult. If they change the law they just update their central repository with the new rules, which others use: The IsAdult fact, as discussed previously, is inferred from the policy rules. It encapsulates the seemingly arbitrary piece of logic age ▸ = 18 and provides semantic abstractions for its meaning. Now if anyone uses the above rules, they no longer need to be aware of explicit information that determines whether someone is an adult or not. They can just use the inferred fact: While the example is very minimal and trivial it illustrates some important points. We started with a monolithic and leaky approach to our knowledge engineering. We created a single decision table that had all possible information in it and that leaks information from central government that the ID department did not care about and did not want to manage. We first de-coupled the knowledge process so each department was responsible for only what it needed to know. We then encapsulated this leaky knowledge using an inferred fact IsAdult. The use of the term IsAdult also gave a semantic abstraction to the previously arbitrary logic age ▸ = 18. So a general rule of thumb when doing your knowledge engineering is: After regular inserts you have to retract facts explicitly. With logical assertions, the fact that was asserted will be automatically retracted when the conditions that asserted it in the first place are no longer true. Actually, it’s even cleverer then that, because it will be retracted only if there isn’t any single condition that supports the logical assertion. Normal insertions are said to be stated, i.e., just like the intuitive meaning of \"stating a fact\" implies. Using a and a counter, we track how many times a particular equality is stated; this means we count how many different instances are equal. When we logically insert an object during a RHS execution we are said to justify it, and it is considered to be justified by the firing rule. For each logical insertion there can only be one equal object, and each subsequent equal logical insertion increases the justification counter for this logical assertion. A justification is removed by the LHS of the creating rule becoming untrue, and the counter is decreased accordingly. As soon as we have no more justifications the logical object is automatically retracted. If we try to logically insert an object when there is an equal stated object, this will fail and return null. If we state an object that has an existing equal object that is justified we override the Fact; how this override works depends on the configuration setting . When the property is set to discard we use the existing handle and replace the existing instance with the new Object, which is the default behavior; otherwise we override it to stated but we create an new . This can be confusing on a first read, so hopefully the flow charts below help. When it says that it returns a new , this also indicates the was propagated through the network. 6.4.1.1. Bus Pass Example With Inference and TMS The previous example was issuing ID cards to over 18s, in this example we now issue bus passes, either a child or adult pass. rule \"Issue Child Bus Pass\" when $p : Person( age < 16 ) then insert(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) then insert(new AdultBusPass( $p ) ); end As before the above example is considered monolithic, leaky and providing poor separation of concerns. As before we can provide a more robust application with a separation of concerns using inference. Notice this time we don’t just insert the inferred object, we use \"insertLogical\": rule \"Infer Child\" when $p : Person( age < 16 ) then insertLogical( new IsChild( $p ) ) end rule \"Infer Adult\" when $p : Person( age >= 16 ) then insertLogical( new IsAdult( $p ) ) end A \"insertLogical\" is part of the Drools Truth Maintenance System (TMS). When a fact is logically inserted, this fact is dependant on the truth of the \"when\" clause. It means that when the rule becomes false the fact is automatically retracted. This works particularly well as the two rules are mutually exclusive. So in the above rules if the person is under 16 it inserts an IsChild fact, once the person is 16 or over the IsChild fact is automatically retracted and the IsAdult fact inserted. Returning to the code to issue bus passes, these two rules can + logically insert the ChildBusPass and AdultBusPass facts, as the TMS + supports chaining of logical insertions for a cascading set of retracts. rule \"Issue Child Bus Pass\" when $p : Person( ) IsChild( person == $p ) then insertLogical(new ChildBusPass( $p ) ); end rule \"Issue Adult Bus Pass\" when $p : Person( age >= 16 ) IsAdult( person =$p ) then insertLogical(new AdultBusPass( $p ) ); end Now when a person changes from being 15 to 16, not only is the IsChild fact automatically retracted, so is the person’s ChildBusPass fact. For bonus points we can combine this with the 'not' conditional element to handle notifications, in this situation, a request for the returning of the pass. So when the TMS automatically retracts the ChildBusPass object, this rule triggers and sends a request to the person: rule \"Return ChildBusPass Request \"when $p : Person( ) not( ChildBusPass( person == $p ) ) then requestChildBusPass( $p ); end It is important to note that for Truth Maintenance (and logical assertions) to work at all, your Fact objects (which may be JavaBeans) must override equals and hashCode methods (from java.lang.Object) correctly. As the truth maintenance system needs to know when two different physical objects are equal in value, both equals and hashCode must be overridden correctly, as per the Java standard. Two objects are equal if and only if their equals methods return true for each other and if their hashCode methods return the same values. See the Java API for more details (but do keep in mind you MUST override both equals and hashCode). TMS behaviour is not affected by theruntime configuration of Identity vs Equality, TMS is always equality. 6.4.1.3. Deleting stated or logically asserted facts from the working memory By default when a fact is deleted from the working memory Drools attempts to remove it both from the set of stated facts and also from the Truth Maintenance System in case it has been logically asserted. However, using an overload of the delete method, it is also possible to remove it only from one of the 2. For instance invoking: the fact is removed only if it has been logically asserted, but not if it is a stated fact. In this case, if the fact has been stated its deletion fails silently and it is ignored. Decision tables are a \"precise yet compact\" (ref. Wikipedia) way of representing conditional logic, and are well suited to business level rules. Drools supports managing rules in a spreadsheet format. Supported formats are Excel (XLS), and CSV, which means that a variety of spreadsheet programs (such as Microsoft Excel, OpenOffice.org Calc amongst others) can be utilized. It is expected that web based decision table editors will be included in a near future release. Decision tables are an old concept (in software terms) but have proven useful over the years. Very briefly speaking, in Drools decision tables are a way to generate rules driven from the data entered into a spreadsheet. All the usual features of a spreadsheet for data capture and manipulation can be taken advantage of. 6.5.1. When to Use Decision Tables Consider decision tables as a course of action if rules exist that can be expressed as rule templates and data: each row of a decision table provides data that is combined with a template to generate a rule. Many businesses already use spreadsheets for managing data, calculations, etc. If you are happy to continue this way, you can also manage your business rules this way. This also assumes you are happy to manage packages of rules in .xls or .csv files. Decision tables are not recommended for rules that do not follow a set of templates, or where there are a small number of rules (or if there is a dislike towards software like Excel or OpenOffice.org). They are ideal in the sense that there can be control over what parameters of rules can be edited, without exposing the rules directly. Decision tables also provide a degree of insulation from the underlying object model. Here are some examples of real world decision tables (slightly edited to protect the innocent). In the above examples, the technical aspects of the decision table have been collapsed away (using a standard spreadsheet feature). The rules start from row 17, with each row resulting in a rule. The conditions are in columns C, D, E, etc., the actions being off-screen. The values in the cells are quite simple, and their meaning is indicated by the headers in Row 16. Column B is just a description. It is customary to use color to make it obvious what the different areas of the table mean. Note that although the decision tables look like they process top down, this is not necessarily the case. Ideally, rules are authored without regard for the order of rows, simply because this makes maintenance easier, as rows will not need to be shifted around all the time. As each row is a rule, the same principles apply. As the rule engine processes the facts, any rules that match may fire. (Some people are confused by this. It is possible to clear the agenda when a rule fires and simulate a very simple decision table where only the first match effects an action.) Also note that you can have multiple tables on one spreadsheet. This way, rules can be grouped where they share common templates, yet at the end of the day they are all combined into one rule package. Decision tables are essentially a tool to generate DRL rules automatically. Figure 138. A real world example using multiple tables for grouping like rules The key point to keep in mind is that in a decision table each row is a rule, and each column in that row is either a condition or action for that rule. The spreadsheet looks for the RuleTable keyword to indicate the start of a rule table (both the starting row and column). Other keywords are also used to define other package level attributes (covered later). It is important to keep the keywords in one column. By convention the second column (\"B\") is used for this, but it can be any column (convention is to leave a margin on the left for notes). In the following diagram, C is actually the column where it starts. Everything to the left of this is ignored. If we expand the hidden sections, it starts to make more sense how it works; note the keywords in column C. Now the hidden magic which makes it work can be seen. The RuleSet keyword indicates the name to be used in the rule package that will encompass all the rules. This name is optional, using a default, but it must have the RuleSet keyword in the cell immediately to the right. The other keywords visible in Column C are Import and Sequential which will be covered later. The RuleTable keyword is important as it indicates that a chunk of rules will follow, based on some rule templates. After the RuleTable keyword there is a name, used to prefix the names of the generated rules. The sheet name and row numbers are appended to guarantee unique rule names. The RuleTable name combined with the sheet name must be unique across all spreadsheet files in the same KieBase. If that’s not the case, some rules might have the same name and only 1 of them will be applied. To show such ignored rules, raise the severity of such rule name conflicts. The column of RuleTable indicates the column in which the rules start; columns to the left are ignored. In general the keywords make up name-value pairs. Referring to row 14 (the row immediately after RuleTable), the keywords CONDITION and ACTION indicate that the data in the columns below are for either the LHS or the RHS parts of a rule. There are other attributes on the rule which can also be optionally set this way. Row 15 contains declarations of ObjectTypes . The content in this row is optional, but if this option is not in use, the row must be left blank; however this option is usually found to be quite useful. When using this row, the values in the cells below (row 16) become constraints on that object type. In the above case, it generates and , where 42 and \"stilton\" come from row 18. In the above example, the \"==\" is implicit; if just a field name is given the translator assumes that it is to generate an exact match. An ObjectType declaration can span columns (via merged cells), meaning that all columns below the merged range are to be combined into one set of constraints within a single pattern matching a single fact at a time, as opposed to non-merged cells containing the same ObjectType, but resulting in different patterns, potentially matching different or identical facts. Row 16 contains the rule templates themselves. They can use the \"$param\" placeholder to indicate where data from the cells below should be interpolated. (For multiple insertions, use \"$1\", \"$2\", etc., indicating parameters from a comma-separated list in a cell below.) Row 17 is ignored; it may contain textual descriptions of the column’s purpose. Rows 18 and 19 show data, which will be combined (interpolated) with the templates in row 15, to generate rules. If a cell contains no data, then its template is ignored. (This would mean that some condition or action does not apply for that rule row.) Rule rows are read until there is a blank row. Multiple RuleTables can exist in a sheet. Row 20 contains another keyword, and a value. The row positions of keywords like this do not matter (most people put them at the top) but their column should be the same one where the RuleTable or RuleSet keywords should appear. In our case column C has been chosen to be significant, but any other column could be used instead. In the above example, rules would be rendered like the following (as it uses the \"ObjectType\" row): The constraints and are interpreted as single constraints, to be added to the respective ObjectType in the cell above. If the cells above were spanned, then there could be multiple constraints on one \"column\". Very large decision tables may have very large memory requirements. There are two types of rectangular areas defining data that is used for generating a DRL file. One, marked by a cell labelled , defines all DRL items except rules. The other one may occur repeatedly and is to the right and below a cell whose contents begin with . These areas represent the actual decision tables, each area resulting in a set of rules of similar structure. A Rule Set area may contain cell pairs, one below the cell and containing a keyword designating the kind of value contained in the other one that follows in the same row. The columns of a Rule Table area define patterns and constraints for the left hand sides of the rules derived from it, actions for the consequences of the rules, and the values of individual rule attributes. Thus, a Rule Table area should contain one or more columns, both for conditions and actions, and an arbitrary selection of columns for rule attributes, at most one column for each of these. The first four rows following the row with the cell marked with are earmarked as header area, mostly used for the definition of code to construct the rules. It is any additional row below these four header rows that spawns another rule, with its data providing for variations in the code defined in the Rule Table header. Only the first worksheet is examined for decision tables. Entries in a Rule Set area may define DRL constructs (except rules), and specify rule attributes. While entries for constructs may be used repeatedly, each rule attribute may be given at most once, and it applies to all rules unless it is overruled by the same attribute being defined within the Rule Table area. Entries must be given in a vertically stacked sequence of cell pairs. The first one contains a keyword and the one to its right the value, as shown in the table below. This sequence of cell pairs may be interrupted by blank rows or even a Rule Table, as long as the column marked by is upheld as the one containing the keyword. The package name for the generated DRL file. Optional, the default is . \"true\" or \"false\". If \"true\", then salience is used to ensure that rules fire from the top down. Optional, at most once. If omitted, no firing order is imposed. Optional, at most once. In sequential mode, this option is used to set the start value of the salience. If omitted, the default value is 65535. Optional, at most once. In sequential mode this option is used to check if this minimum salience value is not violated. If omitted the default value is 0. \"true\" or \"false\". If \"true\", then quotation marks are escaped so that they appear literally in the DRL. Optional, at most once. If omitted, quotation marks are escaped. \"true\" or \"false\". If \"true\", then a String representation is used for DRL instead of a double value from a Numeric cell Optional, at most once. If omitted, a double value is used. Optional, may be used repeatedly. Declarations of DRL globals, i.e., a type followed by a variable name. Multiple global definitions must be separated with a comma. Optional, may be used repeatedly. One or more function definitions, according to DRL syntax. Optional, may be used repeatedly. One or more query definitions, according to DRL syntax. Optional, may be used repeatedly. One or more declarative types, according to DRL syntax. Optional, may be used repeatedly. In some locales, MS Office, LibreOffice and OpenOffice will encode a double quote differently, which will cause a compilation error. The difference is often hard to see. For example: will fail, but will work. For defining rule attributes that apply to all rules in the generated DRL file you can use any of the entries in the following table. Notice, however, that the proper keyword must be used. Also, each of these attributes may be used only once. Rule attributes specified in a Rule Set area will affect all rule assets in the same package (not only in the spreadsheet). Unless you are sure that the spreadsheet is the only one rule asset in the package, the recommendation is to specify rule attributes not in a Rule Set area but in a Rule Table columns for each rule instead. An integer defining the \"salience\" value for the rule. Overridden by the \"Sequential\" flag. A long integer value defining the \"duration\" value for the rule. A Boolean value. \"true\" enables the rule; \"false\" disables the rule. A Boolean value. \"true\" inhibits looping of rules due to changes made by its consequence. A Boolean value. \"true\" inhibits additional activations of all rules with this flag set within the same ruleflow or agenda group. A Boolean value. \"true\" for a rule within an agenda group causes activations of the rule to automatically give the focus to the group. A string identifying an activation (or XOR) group. Only one rule within an activation group will fire, i.e., the first one to fire cancels any existing activations of other rules within the same group. A string identifying an agenda group, which has to be activated by giving it the \"focus\", which is one way of controlling the flow between groups of rules. All Rule Tables begin with a cell containing \"RuleTable\", optionally followed by a string within the same cell. The string is used as the initial part of the name for all rules derived from this Rule Table, with the row number appended for distinction. (This automatic naming can be overridden by using a NAME column.) All other cells defining rules of this Rule Table are below and to the right of this cell. The next row defines the column type, with each column resulting in a part of the condition or the consequence, or providing some rule attribute, the rule name or a comment. The table below shows which column headers are available; additional columns may be used according to the table showing rule attribute entries given in the preceding section. Note that each attribute column may be used at most once. For a column header, either use the keyword or any other word beginning with the letter given in the \"Initial\" column of these tables. Provides the name for the rule generated from that row. The default is constructed from the text following the RuleTable tag and the row number. A text, resulting in a comment within the generated rule. Code snippet and interpolated values for constructing a constraint within a pattern in a condition. At least one per rule table Code snippet and interpolated values for constructing an action for the consequence of the rule. At least one per rule table Code snippet and interpolated values for constructing a metadata entry for the rule. Given a column headed CONDITION, the cells in successive lines result in a conditional element.\n• Text in the first cell below CONDITION develops into a pattern for the rule condition, with the snippet in the next line becoming a constraint. If the cell is merged with one or more neighbours, a single pattern with multiple constraints is formed: all constraints are combined into a parenthesized list and appended to the text in this cell. The cell may be left blank, which means that the code snippet in the next row must result in a valid conditional element on its own. To include a pattern without constraints, you can write the pattern in front of the text for another pattern. The pattern may be written with or without an empty pair of parentheses. A \"from\" clause may be appended to the pattern. If the pattern ends with \"eval\", code snippets are supposed to produce boolean expressions for inclusion into a pair of parentheses after \"eval\".\n• Text in the second cell below CONDITION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using \"==\" with the value from the cells below, the field selector alone is sufficient. Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A text according to the pattern delimiter snippet is expanded by repeating the snippet once for each of the values of the comma-separated list of values in each of the cells below, inserting the value in place of the symbol and by joining these expansions by the given delimiter. Note that the forall construct may be surrounded by other text.\n• If the cell in the preceding row is not empty, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below CONDITION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the conditional element or constraint for this rule. Given a column headed ACTION, the cells in successive lines result in an action statement.\n• Text in the first cell below ACTION is optional. If present, it is interpreted as an object reference.\n• Text in the second cell below ACTION is processed in two steps.\n• The code snippet in this cell is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol . Multiple insertions are possible by using the symbols , , etc., and a comma-separated list of values in the cells below. A method call without interpolation can be achieved by a text without any marker symbols. In this case, use any non-blank entry in a row below to include the statement. The forall construct is available here, too.\n• If the first cell is not empty, its text, followed by a period, the text in the second cell and a terminating semicolon are stringed together, resulting in a method call which is added as an action statement for the consequence. If the cell above is empty, the interpolated result is used as is.\n• Text in the third cell below ACTION is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the action statement for this rule. Using instead of works in most cases, but it will fail if the replacement text contains a comma: then, only the part preceding the first comma is inserted. Use this \"abbreviation\" judiciously. Given a column headed METADATA, the cells in successive lines result in a metadata annotation for the generated rules.\n• Text in the first cell below METADATA is ignored.\n• Text in the second cell below METADATA is subject to interpolation, as described above, using values from the cells in the rule rows. The metadata marker character is prefixed automatically, and thus it should not be included in the text for this cell.\n• Text in the third cell below METADATA is for documentation only. It should be used to indicate the column’s purpose to a human reader.\n• From the fourth row on, non-blank entries provide data for interpolation as described above. A blank cell results in the omission of the metadata annotation for this rule. The various interpolations are illustrated in the following example. If the template is and the cell is , then the result is . If the template is and the cell contains , the result will be . The template with a cell containing results in . The next example demonstrates the joint effect of a cell defining the pattern type and the code snippet below it. This spreadsheet section shows how the type declaration spans 2 columns, and thus both constraints will appear as . Since only the field names are present in the snippet, they imply an equality test. In the following example the marker symbol is used. The result of this column is the pattern . You may have noticed that the marker and the operator \"==\" are redundant. The next example illustrates that a trailing insertion marker can be omitted. Here, appending the value from the cell is implied, resulting in You can provide the definition of a binding variable, as in the example below. Here, the result is Note that the quotes are provided automatically. Actually, anything can be placed in the object type row. Apart from the definition of a binding variable, it could also be an additional pattern that is to be inserted literally. A simple construction of an action statement with the insertion of a single value is shown below. The cell below the ACTION header is left blank. Using this style, anything can be placed in the consequence, not just a single method call. (The same technique is applicable within a CONDITION column as well.) Below is a comprehensive example, showing the use of various column headers. It is not an error to have no value below a column header (as in the NO-LOOP column): here, the attribute will not be applied in any of the rules. Figure 141. Example usage of keywords for imports, headers, etc. And, finally, here is an example of Import, Variables and Functions. Figure 142. Example usage of keywords for functions, etc. Multiple package names within the same cell must be separated by a comma. Also, the pairs of type and variable names must be comma-separated. Functions, however, must be written as they appear in a DRL file. This should appear in the same column as the \"RuleSet\" keyword; it could be above, between or below all the rule rows. It may be more convenient to use Import, Variables, Functions and Queries repeatedly rather than packing several definitions into a single cell. The API to use spreadsheet based decision tables is in the drools-decisiontables module. There is really only one class to look at: . This class will take spreadsheets in various formats, and generate rules in DRL (which you can then use in the normal way). The can just be used to generate partial rule files if it is wished, and assemble it into a complete rule package after the fact (this allows the separation of technical and non-technical aspects of the rules if needed). To get started, a sample spreadsheet can be used as a base. Alternatively, if the plug-in is being used (Rule Workbench IDE), the wizard can generate a spreadsheet from a template (to edit it an xls compatible spreadsheet editor will need to be used). Spreadsheets are well established business tools (in use for over 25 years). Decision tables lend themselves to close collaboration between IT and domain experts, while making the business rules clear to business analysts, it is an ideal separation of concerns. Typically, the whole process of authoring rules (coming up with a new decision table) would be something like:\n• Business analyst takes a template decision table (from a repository, or from IT)\n• Decision table business language descriptions are entered in the table(s)\n• Decision table is handed to a technical resource, who maps the business language (descriptions) to scripts (this may involve software development of course, if it is a new application or data model)\n• Technical person hands back and reviews the modifications with the business analyst.\n• The business analyst can continue editing the rule rows as needed (moving columns around is also fine etc).\n• In parallel, the technical person can develop test cases for the rules (liaising with business analysts) as these test cases can be used to verify rules and rule changes once the system is running. Features of applications like Excel can be used to provide assistance in entering data into spreadsheets, such as validating fields. Lists that are stored in other worksheets can be used to provide valid lists of values for cells, like in the following diagram. Some applications provide a limited ability to keep a history of changes, but it is recommended to use an alternative means of revision control. When changes are being made to rules over time, older versions are archived (many open source solutions exist for this, such as Subversion or Git). Related to decision tables (but not necessarily requiring a spreadsheet) are \"Rule Templates\" (in the drools-templates module). These use any tabular data source as a source of rule data - populating a template to generate many rules. This can allow both for more flexible spreadsheets, but also rules in existing databases for instance (at the cost of developing the template up front to generate the rules). With Rule Templates the data is separated from the rule and there are no restrictions on which part of the rule is data-driven. So whilst you can do everything you could do in decision tables you can also do the following:\n• store your data in a database (or any other format)\n• conditionally generate rules based on the values in the data\n• use data for any part of your rules (e.g. condition operator, class name, property name)\n• run different templates over the same data As an example, a more classic decision table is shown, but without any hidden rows for the rule meta data (so the spreadsheet only contains the raw data to generate the rules). See the ExampleCheese.xls in the examples download for the above spreadsheet. If this was a regular decision table there would be hidden rows before row 1 and between rows 1 and 2 containing rule metadata. With rule templates the data is completely separate from the rules. This has two handy consequences - you can apply multiple rule templates to the same data and your data is not tied to your rules at all. So what does the template look like?\n• Lines 2-4: Following the header is the list of columns in the order they appear in the data. In this case we are calling the first column , the second and the third .\n• Line 5: An empty line signifies the end of the column definitions.\n• Lines 6-9: Standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global and function definitions into this section.\n• Line 10: The keyword signals the start of a rule template. There can be more than one template in a template file, but each template should have a unique name.\n• Lines 11-18: The rule template - see below for details.\n• Line 20: The keywords signify the end of the template. The rule templates rely on MVEL to do substitution using the syntax @{token_name}. There is currently one built-in expression, @{row.rowNumber} which gives a unique number for each row of data and enables you to generate unique rule names. For each row of data a rule will be generated with the values in the data substituted for the tokens in the template. A rule template has to be included in a file with extension .drt and associated to the corresponding decision table when defining the kbase in the kmodule.xml file as in the following example With the example data above the following rule file would be generated: package org.drools.examples.templates; global java.util.List list; rule \"Cheese fans_1\" when Person(age == 42) Cheese(type == \"stilton\") then list.add(\"Old man stilton\"); end rule \"Cheese fans_2\" when Person(age == 21) Cheese(type == \"cheddar\") then list.add(\"Young man cheddar\"); end At this point the named \"TemplatesKS\" and containing the rules generated from the template can be simply created from the and used as any other . KieSession ksession = kc.newKieSession( \"TemplatesKS\" ); // now create some test data ksession.insert( new Cheese( \"stilton\", 42 ) ); ksession.insert( new Person( \"michael\", \"stilton\", 42 ) ); final List<String> list = new ArrayList<String>(); ksession.setGlobal( \"list\", list ); ksession.fireAllRules(); One way to illuminate the black box that is a rule engine, is to play with the logging level. Everything is logged to SLF4J, which is a simple logging facade that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a dependency to the logging adaptor for your logging framework of choice. If you’re not using any logging framework yet, you can use Logback by adding this Maven dependency: If you’re developing for an ultra light environment, use or instead. Configure the logging level on the package . For example: In Logback, configure it in your logback.xml file: In Log4J, configure it in your log4j.xml file:\n\nMake sure the Drools Eclipse plugin is installed, which needs the Graphical Editing Framework (GEF) dependency installed first. Then download and extract the drools-examples zip file, which includes an already created Eclipse project. Import that project into a new Eclipse workspace. The rules all have example classes that execute the rules. If you want to try the examples in another project (or another IDE) then you will need to set up the dependencies by hand, of course. Many, but not all of the examples are documented below, enjoy! Name: Hello World Main class: org.drools.examples.helloworld.HelloWorldExample Module: drools-examples Type: Java application Rules file: HelloWorld.drl Objective: demonstrate basic rules in use The \"Hello World\" example shows a simple application using rules, written both using the MVEL and the Java dialects. This example demonstrates how to create and use a . Also, audit logging and debug outputs are shown, which is omitted from other examples as it’s all very similar. The following code snippet shows how the session is created with only 3 lines of code. Obtains the KieServices factory. This is the main interface applications use to interact with the engine. Creates a KieContainer from the project classpath. This will look for a /META-INF/kmodule.xml file to configure and instantiate the KieModule into the KieContainer. Drools has an event model that exposes much of what’s happening internally. Two default debug listeners are supplied, and which print out debug event information to the stream displayed in the Console window. Adding listeners to a Session is trivial, as shown in the next snippet. The provides execution auditing, the result of which can be viewed in a graphical viewer. The logger is actually a specialised implementation built on the and listeners. When the engine has finished executing, must be called. Most of the examples use the Audit logging features of Drools to record execution flow for later inspection. // The application can also setup listeners ksession.addEventListener( new DebugAgendaEventListener() ); ksession.addEventListener( new DebugRuleRuntimeEventListener() ); // To setup a file based audit logger, uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, \"./helloworld\" ); // To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging, // uncomment the next line // KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, \"./helloworld\", 1000 ); The single class used in this example is very simple. It has two fields: the message, which is a and the status which can be one of the two integers or . A single object is created with the message text \"Hello World\" and the status and then inserted into the engine, at which point is executed. // The application can insert facts into the session final Message message = new Message(); message.setMessage( \"Hello World\" ); message.setStatus( Message.HELLO ); ksession.insert( message ); // and fire the rules ksession.fireAllRules(); To execute the example as a Java application:\n• Open the class in your Eclipse IDE\n• Right-click the class and select \"Run as…​\" and then \"Java application\" If we put a breakpoint on the method and select the variable, we can see that the \"Hello World\" rule is already activate on the Agenda. The application print outs go to to while the debug listener print outs go to . Example 260. HelloWorld: System.out in the Console window Example 261. HelloWorld: System.err in the Console window The actual rules are inside the file src/main/resources/org/drools/examples/helloworld/HelloWorld.drl : rule \"Hello World\" dialect \"mvel\" when m : Message( status == Message.HELLO, message : message ) then System.out.println( message ); modify ( m ) { message = \"Goodbye cruel world\", status = Message.GOODBYE }; end The LHS (after ) section of the rule states that it will be activated for each object inserted into the Rule Runtime whose status is . Besides that, two variable bindings are created: the variable is bound to the attribute and the variable is bound to the matched object itself. The RHS (after ) or consequence part of the rule is written using the MVEL expression language, as declared by the rule’s attribute . After printing the content of the bound variable to , the rule changes the values of the and attributes of the object bound to . This is done using MVEL’s statement, which allows you to apply a block of assignments in one statement, with the engine being automatically notified of the changes at the end of the block. It is possible to set a breakpoint into the DRL, on the call, and inspect the Agenda view again during the execution of the rule’s consequence. This time we start the execution via \"Debug As\" and \"Drools application\" and not by running a \"Java application\":\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Debug as…​\" and then \"Drools application\". Now we can see that the other rule , which uses the Java dialect, is activated and placed on the Agenda. The \"Good Bye\" rule, which specifies the \"java\" dialect, is similar to the \"Hello World\" rule except that it matches objects whose status is . The Java code that instantiates the creates an audit log file that can be loaded into the Audit view. The Audit view is used in many of the examples to demonstrate the example execution flow. In the view screen shot below we can see that the object is inserted, which creates an activation for the \"Hello World\" rule; the activation is then executed which updates the object causing the \"Good Bye\" rule to activate; finally the \"Good Bye\" rule also executes. Selecting an event in the Audit view highlights the origin event in green; therefore the \"Activation created\" event is highlighted in green as the origin of the \"Activation executed\" event. This example is implemented in two different versions to demonstrate different ways of implementing the same basic behavior: forward chaining, i.e., the ability the engine has to evaluate, activate and fire rules in sequence, based on changes on the facts in the Working Memory. Name: State Example Main class: org.drools.examples.state.StateExampleUsingSalience Module: drools-examples Type: Java application Rules file: StateExampleUsingSalience.drl Objective: Demonstrates basic rule use and Conflict Resolution for rule firing priority. Each class has fields for its name and its current state (see the class ). The two possible states for each objects are: public class State { public static final int NOTRUN = 0; public static final int FINISHED = 1; private final PropertyChangeSupport changes = new PropertyChangeSupport( this ); private String name; private int state; ... setters and getters go here... } Ignoring the , which will be explained later, we see the creation of four objects named A, B, C and D. Initially their states are set to , which is default for the used constructor. Each instance is asserted in turn into the Session and then is called. final State a = new State( \"A\" ); final State b = new State( \"B\" ); final State c = new State( \"C\" ); final State d = new State( \"D\" ); ksession.insert( a ); ksession.insert( b ); ksession.insert( c ); ksession.insert( d ); ksession.fireAllRules(); ksession.dispose(); // Stateful rule session must always be disposed when finished\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" You will see the following output in the Eclipse console window: There are four rules in total. First, the rule fires, setting A to state , which then causes B to change its state to . C and D are both dependent on B, causing a conflict which is resolved by the salience values. Let’s look at the way this was executed. The best way to understand what is happening is to use the Audit Logging feature to graphically see the results of each operation. To view the Audit log generated by a run of this example:\n• If the Audit View is not visible, click on \"Window\" and then select \"Show View\", then \"Other…​\" and \"Drools\" and finally \"Audit View\".\n• In the \"Audit View\" click the \"Open Log\" button and select the file \"<drools-examples-dir>/log/state.log\". After that, the \"Audit view\" will look like the following screenshot: Reading the log in the \"Audit View\", top to bottom, we see every action and the corresponding changes in the Working Memory. This way we observe that the assertion of the State object A in the state activates the rule, while the assertions of the other objects have no immediate effect. The execution of rule Bootstrap changes the state of A to , which, in turn, activates rule \"A to B\". rule \"A to B\" when State(name == \"A\", state == State.FINISHED ) b : State(name == \"B\", state == State.NOTRUN ) then System.out.println(b.getName() + \" finished\" ); b.setState( State.FINISHED ); end The execution of rule \"A to B\" changes the state of B to , which activates both, rules \"B to C\" and \"B to D\", placing their Activations onto the Agenda. From this moment on, both rules may fire and, therefore, they are said to be \"in conflict\". The conflict resolution strategy allows the engine’s Agenda to decide which rule to fire. As rule \"B to C\" has the higher salience value (10 versus the default salience value of 0), it fires first, modifying object C to state . The Audit view shown above reflects the modification of the object in the rule \"A to B\", which results in two activations being in conflict. The Agenda view can also be used to investigate the state of the Agenda, with debug points being placed in the rules themselves and the Agenda view opened. The screen shot below shows the breakpoint in the rule \"A to B\" and the state of the Agenda with the two conflicting rules. Example 269. Salience State: Rule \"B to C\" rule \"B to C\" salience 10 when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); end Rule \"B to D\" fires last, modifying object D to state . rule \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end There are no more rules to execute and so the engine stops. Another notable concept in this example is the use of dynamic facts, based on objects. As described in the documentation, in order for the engine to see and react to changes of fact properties, the application must tell the engine that changes occurred. This can be done explicitly in the rules by using the statement, or implicitly by letting the engine know that the facts implement as defined by the JavaBeans specification. This example demonstrates how to use to avoid the need for explicit statements in the rules. To make use of this feature, ensure that your facts implement , the same way the class does, and use the following code in the rules file to configure the engine to listen for property changes on those facts: When using objects, each setter must implement a little extra code for the notification. Here is the setter for in the class : Example 272. Setter Example with PropertyChangeSupport There are another class in this example: . It executes from A to B to C to D, as just shown, but uses agenda-groups to control the rule conflict and which one fires first. Agenda groups are a way to partition the Agenda into groups and to control which groups can execute. By default, all rules are in the agenda group \"MAIN\". The \"agenda-group\" attribute lets you specify a different agenda group for the rule. Initially, a Working Memory has its focus on the Agenda group \"MAIN\". A group’s rules will only fire when the group receives the focus. This can be achieved either ny using the method by or the rule attribute . \"auto-focus\" means that the rule automatically sets the focus to its agenda group when the rule is matched and activated. It is this \"auto-focus\" that enables rule \"B to C\" to fire before \"B to D\". Example 273. Agenda Group State Example: Rule \"B to C\" rule \"B to C\" agenda-group \"B to C\" auto-focus true when State(name == \"B\", state == State.FINISHED ) c : State(name == \"C\", state == State.NOTRUN ) then System.out.println(c.getName() + \" finished\" ); c.setState( State.FINISHED ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"B to D\" ).setFocus(); end The rule \"B to C\" calls on the agenda group \"B to D\", allowing its active rules to fire, which allows the rule \"B to D\" to fire. Example 274. Agenda Group State Example: Rule \"B to D\" rule \"B to D\" agenda-group \"B to D\" when State(name == \"B\", state == State.FINISHED ) d : State(name == \"D\", state == State.NOTRUN ) then System.out.println(d.getName() + \" finished\" ); d.setState( State.FINISHED ); end Name: Fibonacci Main class: org.drools.examples.fibonacci.FibonacciExample Module: drools-examples Type: Java application Rules file: Fibonacci.drl Objective: Demonstrates Recursion, the CE not and cross product matching The Fibonacci Numbers (see http://en.wikipedia.org/wiki/Fibonacci_number) discovered by Leonardo of Pisa (see http://en.wikipedia.org/wiki/Fibonacci) is a sequence that starts with 0 and 1. The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers. The Fibonacci sequence begins with 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,…​ The Fibonacci Example demonstrates recursion and conflict resolution with salience values. The single fact class is used in this example. It has two fields, sequence and value. The sequence field is used to indicate the position of the object in the Fibonacci number sequence. The value field shows the value of that Fibonacci object for that sequence position, using -1 to indicate a value that still needs to be computed. public static class Fibonacci { private int sequence; private long value; public Fibonacci( final int sequence ) { this.sequence = sequence; this.value = -1; } ... setters and getters go here... }\n• Open the class in your Eclipse IDE.\n• Right-click the class and select \"Run as…​\" and then \"Java application\" Eclipse shows the following output in its console window (with \"…​snip…​\" indicating lines that were removed to save space): recurse for 50 recurse for 49 recurse for 48 recurse for 47 ...snip... recurse for 5 recurse for 4 recurse for 3 recurse for 2 1 == 1 2 == 1 3 == 2 4 == 3 5 == 5 6 == 8 ...snip... 47 == 2971215073 48 == 4807526976 49 == 7778742049 50 == 12586269025 To kick this off from Java we only insert a single Fibonacci object, with a sequence field of 50. A recursive rule is then used to insert the other 49 objects. This example doesn’t use . It uses the MVEL dialect, which means we can use the keyword, which allows a block setter action which also notifies the engine of changes. The rule Recurse is very simple. It matches each asserted object with a value of -1, creating and asserting a new object with a sequence of one less than the currently matched object. Each time a Fibonacci object is added while the one with a sequence field equal to 1 does not exist, the rule re-matches and fires again. The conditional element is used to stop the rule’s matching once we have all 50 Fibonacci objects in memory. The rule also has a salience value, because we need to have all 50 objects asserted before we execute the Bootstrap rule. rule Recurse salience 10 when f : Fibonacci ( value == -1 ) not ( Fibonacci ( sequence == 1 ) ) then insert( new Fibonacci( f.sequence - 1 ) ); System.out.println( \"recurse for \" + f.sequence ); end The Audit view shows the original assertion of the object with a sequence field of 50, done from Java code. From there on, the Audit view shows the continual recursion of the rule, where each asserted object causes the Recurse rule to become activated and to fire again. When a object with a sequence field of 2 is asserted the \"Bootstrap\" rule is matched and activated along with the \"Recurse\" rule. Note the multi-restriction on field , testing for equality with 1 or 2. rule Bootstrap when f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction then modify ( f ){ value = 1 }; System.out.println( f.sequence + \" == \" + f.value ); end At this point the Agenda looks as shown below. However, the \"Bootstrap\" rule does not fire because the \"Recurse\" rule has a higher salience. When a object with a sequence of 1 is asserted the Bootstrap rule is matched again, causing two activations for this rule. Note that the \"Recurse\" rule does not match and activate because the conditional element stops the rule’s matching as soon as a object with a sequence of 1 exists. Once we have two objects with values not equal to -1 the \"Calculate\" rule is able to match. It was the \"Bootstrap\" rule that set the objects with sequence 1 and 2 to values of 1. At this point we have 50 Fibonacci objects in the Working Memory. Now we need to select a suitable triple to calculate each of their values in turn. Using three Fibonacci patterns in a rule without field constraints to confine the possible cross products would result in 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect. The \"Calculate\" rule uses field constraints to correctly constraint the thee Fibonacci patterns in the correct order; this technique is called cross product matching. The first pattern finds any Fibonacci with a value != -1 and binds both the pattern and the field. The second Fibonacci does this, too, but it adds an additional field constraint to ensure that its sequence is greater by one than the Fibonacci bound to . When this rule fires for the first time, we know that only sequences 1 and 2 have values of 1, and the two constraints ensure that references sequence 1 and references sequence 2. The final pattern finds the Fibonacci with a value equal to -1 and with a sequence one greater than . At this point, we have three objects correctly selected from the available cross products, and we can calculate the value for the third object that’s bound to . rule Calculate when // Bind f1 and s1 f1 : Fibonacci( s1 : sequence, value != -1 ) // Bind f2 and v2; refer to bound variable s1 f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 ) // Bind f3 and s3; alternative reference of f2.sequence f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 ) then // Note the various referencing techniques. modify ( f3 ) { value = f1.value + v2 }; System.out.println( s3 + \" == \" + f3.value ); end The statement updated the value of the object bound to . This means we now have another new Fibonacci object with a value not equal to -1, which allows the \"Calculate\" rule to rematch and calculate the next Fibonacci number. The Audit view below shows how the firing of the last \"Bootstrap\" modifies the object, enabling the \"Calculate\" rule to match, which then modifies another Fibonacci object allowing the \"Calculate\" rule to match again. This continues till the value is set for all objects. This tutorial demonstrates the process of developing a complete personal banking application to handle credits and debits on multiple accounts. It uses a set of design patterns that have been created for the process. The class is a simple harness to execute one or more DRL files against a set of data. It compiles the Packages and creates the Knowledge Base for each execution, allowing us to easily execute each scenario and inspect the outputs. In reality this is not a good solution for a production system, where the Knowledge Base should be built just once and cached, but for the purposes of this tutorial it shall suffice. The first of our sample Java classes loads and executes a single DRL file, Example.drl , but without inserting any data. public class Example1 { public static void main(String[] args) throws Exception { new RuleRunner().runRules( new String[] { \"Example1.drl\" }, new Object[0] ); } } The first simple rule to execute has a single condition that will always be true, so that this rule will match and fire, once, after the start. The output for the rule is below, showing that the rule matches and executes the single print statement. The next step is to assert some simple facts and print them out. public class Example2 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example2.drl\" }, numbers ); } private static Integer wrap( int i ) { return new Integer(i); } } This doesn’t use any specific facts but instead asserts a set of objects. This is not considered \"best practice\" as a number is not a useful fact, but we use it here to demonstrate basic techniques before more complexity is added. Now we will create a simple rule to print out these numbers. rule \"Rule 02\" when Number( $intValue : intValue ) then System.out.println( \"Number found with value: \" + $intValue ); end Once again, this rule does nothing special. It identifies any facts that are objects and prints out the values. Notice the use of the abstract class : we inserted objects but we now look for any kind of number. The pattern matching engine is able to match interfaces and superclasses of asserted objects. The output shows the DRL being loaded, the facts inserted and then the matched and fired rules. We can see that each inserted number is matched and fired and thus printed. Loading file: Example2.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 5 Number found with value: 1 Number found with value: 4 Number found with value: 1 Number found with value: 3 There are certainly many better ways to sort numbers than using rules, but since we will need to apply some cashflows in date order when we start looking at banking rules we’ll develop simple rule based sorting technique. public class Example3 { public static void main(String[] args) throws Exception { Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)}; new RuleRunner().runRules( new String[] { \"Example3.drl\" }, numbers ); } private static Integer wrap(int i) { return new Integer(i); } } Again we insert our objects, but this time the rule is slightly different: rule \"Rule 03\" when $number : Number( ) not Number( intValue < $number.intValue ) then System.out.println(\"Number found with value: \" + $number.intValue() ); retract( $number ); end The first line of the rule identifies a and extracts the value. The second line ensures that there does not exist a smaller number than the one found by the first pattern. We might expect to match only one number - the smallest in the set. However, the retraction of the number after it has been printed means that the smallest number has been removed, revealing the next smallest number, and so on. The resulting output shows that the numbers are now sorted numerically. Loading file: Example3.drl Inserting fact: 3 Inserting fact: 1 Inserting fact: 4 Inserting fact: 1 Inserting fact: 5 Number found with value: 1 Number found with value: 1 Number found with value: 3 Number found with value: 4 Number found with value: 5 We are ready to start moving towards our personal accounting rules. The first step is to create a object. Class has two simple attributes, a date and an amount. (Note that using the type for monetary units is generally not a good idea because floating point numbers cannot represent most numbers accurately.) There is also an overloaded constructor to set the values, and a method to print a cashflow. The Java code of Example4.java inserts five Cashflow objects, with varying dates and amounts. public class Example4 { public static void main(String[] args) throws Exception { Object[] cashflows = { new Cashflow(new SimpleDate(\"01/01/2007\"), 300.00), new Cashflow(new SimpleDate(\"05/01/2007\"), 100.00), new Cashflow(new SimpleDate(\"11/01/2007\"), 500.00), new Cashflow(new SimpleDate(\"07/01/2007\"), 800.00), new Cashflow(new SimpleDate(\"02/01/2007\"), 400.00), }; new RuleRunner().runRules( new String[] { \"Example4.drl\" }, cashflows ); } } The convenience class extends , providing a constructor taking a String as input and defining a date format. The code is listed below Now, let’s look at Example4.drl to see how we print the sorted objects: rule \"Rule 04\" when $cashflow : Cashflow( $date : date, $amount : amount ) not Cashflow( date < $date) then System.out.println(\"Cashflow: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a and extract the date and the amount. In the second line of the rule we ensure that there is no Cashflow with an earlier date than the one found. In the consequence, we print the that satisfies the rule and then retract it, making way for the next earliest . So, the output we generate is: Next, we extend our , resulting in a which can be a credit or a debit operation. (Normally, we would just add this to the type, but we use extension to keep the previous version of the class intact.) There are lots of ways to improve this code, but for the sake of the example this will do. Now let’s create Example5, a class for running our code. public class Example5 { public static void main(String[] args) throws Exception { Object[] cashflows = { new TypedCashflow(new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new TypedCashflow(new SimpleDate(\"05/01/2007\"), TypedCashflow.CREDIT, 100.00), new TypedCashflow(new SimpleDate(\"11/01/2007\"), TypedCashflow.CREDIT, 500.00), new TypedCashflow(new SimpleDate(\"07/01/2007\"), TypedCashflow.DEBIT, 800.00), new TypedCashflow(new SimpleDate(\"02/01/2007\"), TypedCashflow.DEBIT, 400.00), }; new RuleRunner().runRules( new String[] { \"Example5.drl\" }, cashflows ); } } Here, we simply create a set of objects which are either credit or debit operations. We supply them and Example5.drl to the RuleEngine. Now, let’s look at a rule printing the sorted objects. rule \"Rule 05\" when $cashflow : TypedCashflow( $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not TypedCashflow( date < $date, type == TypedCashflow.CREDIT ) then System.out.println(\"Credit: \"+$date+\" :: \"+$amount); retract($cashflow); end Here, we identify a fact with a type of and extract the date and the amount. In the second line of the rule we ensure that there is no of the same type with an earlier date than the one found. In the consequence, we print the cashflow satisfying the patterns and then retract it, making way for the next earliest cashflow of type . So, the output we generate is Continuing our banking exercise, we are now going to process both credits and debits on two bank accounts, calculating the account balance. In order to do this, we create two separate objects and inject them into the objects before passing them to the Rule Engine. The reason for this is to provide easy access to the correct account without having to resort to helper classes. Let’s take a look at the class first. This is a simple Java object with an account number and balance: Now let’s extend our , resulting in , to include an reference. The Java code of Example5.java creates two objects and passes one of them into each cashflow, in the constructor call. public class Example6 { public static void main(String[] args) throws Exception { Account acc1 = new Account(1); Account acc2 = new Account(2); Object[] cashflows = { new AllocatedCashflow(acc1,new SimpleDate(\"01/01/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/02/2007\"), TypedCashflow.CREDIT, 100.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/03/2007\"), TypedCashflow.CREDIT, 500.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/02/2007\"), TypedCashflow.DEBIT, 800.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/03/2007\"), TypedCashflow.DEBIT, 400.00), new AllocatedCashflow(acc1,new SimpleDate(\"01/04/2007\"), TypedCashflow.CREDIT, 200.00), new AllocatedCashflow(acc1,new SimpleDate(\"05/04/2007\"), TypedCashflow.CREDIT, 300.00), new AllocatedCashflow(acc2,new SimpleDate(\"11/05/2007\"), TypedCashflow.CREDIT, 700.00), new AllocatedCashflow(acc1,new SimpleDate(\"07/05/2007\"), TypedCashflow.DEBIT, 900.00), new AllocatedCashflow(acc2,new SimpleDate(\"02/05/2007\"), TypedCashflow.DEBIT, 100.00) }; new RuleRunner().runRules( new String[] { \"Example6.drl\" }, cashflows ); } } Now, let’s look at the rule in Example6.drl to see how we apply each cashflow in date order and calculate and print the balance. rule \"Rule 06 - Credit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.CREDIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Credit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance()+$amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end rule \"Rule 06 - Debit\" when $cashflow : AllocatedCashflow( $account : account, $date : date, $amount : amount, type == TypedCashflow.DEBIT ) not AllocatedCashflow( account == $account, date < $date) then System.out.println(\"Debit: \" + $date + \" :: \" + $amount); $account.setBalance($account.getBalance() - $amount); System.out.println(\"Account: \" + $account.getAccountNo() + \" - new balance: \" + $account.getBalance()); retract($cashflow); end Although we have separate rules for credits and debits, but we do not specify a type when checking for earlier cashflows. This is so that all cashflows are applied in date order, regardless of the cashflow type. In the conditions we identify the account to work with, and in the consequences we update it with the cashflow amount. Loading file: Example6.drl Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0] Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0] Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0 Account: 2 - new balance: -400.0 Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0 Account: 2 - new balance: 100.0 Debit: Wed May 02 00:00:00 BST 2007 :: 100.0 Account: 2 - new balance: 0.0 Credit: Fri May 11 00:00:00 BST 2007 :: 700.0 Account: 2 - new balance: 700.0 Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0 Account: 1 - new balance: 300.0 Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0 Account: 1 - new balance: 400.0 Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0 Account: 1 - new balance: -400.0 Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0 Account: 1 - new balance: -200.0 Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0 Account: 1 - new balance: 100.0 Debit: Mon May 07 00:00:00 BST 2007 :: 900.0 Account: 1 - new balance: -800.0 The Pricing Rule decision table demonstrates the use of a decision table in a spreadsheet, in Excel’s XLS format, in calculating the retail cost of an insurance policy. The purpose of the provide set of rules is to calculate a base price and a discount for a car driver applying for a specific policy. The driver’s age, history and the policy type all contribute to what the basic premium is, and an additional chunk of rules deals with refining this with a discount percentage. Open the file PricingRuleDTExample.java and execute it as a Java application. It should produce the following output in the Console window: Cheapest possible BASE PRICE IS: 120 DISCOUNT IS: 20 The code to execute the example follows the usual pattern. The rules are loaded, the facts inserted and a Stateless Session is created. What is different is how the rules are added. Note the use of the object. Its input type is set to . If you use the BRMS, all this is of course taken care of for you. There are two fact types used in this example, and . Both are used with their default values. The is 30 years old, has had no prior claims and currently has a risk profile of . The being applied for is , and it has not yet been approved. In this decision table, each row is a rule, and each column is a condition or an action. Referring to the spreadsheet show above, we have the declaration, which provides the package name. There are also other optional items you can have here, such as for global variables, and for importing classes. In this case, the namespace of the rules is the same as the fact classes we are using, so we can omit it. Moving further down, we can see the declaration. The name after this (Pricing bracket) is used as the prefix for all the generated rules. Below that, we have \"CONDITION or ACTION\", indicating the purpose of the column, i.e., whether it forms part of the condition or the consequence of the rule that will be generated. You can see that there is a driver, his data spanned across three cells, which means that the template expressions below it apply to that fact. We observe the driver’s age range (which uses and with comma-separated values), , and in the respective columns. In the action columns, we are set the policy base price and log a message. In the preceding spreadsheet section, there are broad category brackets, indicated by the comment in the leftmost column. As we know the details of our drivers and their policies, we can tell (with a bit of thought) that they should match row number 18, as they have no prior accidents, and are 30 years old. This gives us a base price of 120. The above section contains the conditions for the discount we might grant our driver. The discount results from the bracket, the number of prior claims, and the policy type. In our case, the driver is 30, with no prior claims, and is applying for a policy, which means we can give a discount of 20%. Note that this is actually a separate table, but in the same worksheet, so that different templates apply. It is important to note that decision tables generate rules. This means they aren’t simply top-down logic, but more a means to capture data resulting in rules. This is a subtle difference that confuses some people. The evaluation of the rules is not necessarily in the given order, since all the normal mechanics of the rule engine still apply. Name: Pet Store Main class: org.drools.examples.petstore.PetStoreExample Module: drools-examples Type: Java application Rules file: PetStore.drl Objective: Demonstrate use of Agenda Groups, Global Variables and integration with a GUI, including callbacks from within the rules The Pet Store example shows how to integrate Rules with a GUI, in this case a Swing based desktop application. Within the rules file, it demonstrates how to use Agenda groups and auto-focus to control which of a set of rules is allowed to fire at any given time. It also illustrates the mixing of the Java and MVEL dialects within the rules, the use of accumulate functions and the way of calling Java functions from within the ruleset. All of the Java code is contained in one file, PetStore.java , defining the following principal classes (in addition to several classes to handle Swing Events):\n• contains the method that we will look at shortly.\n• is responsible for creating and displaying the Swing based GUI. It contains several smaller classes, mainly for responding to various GUI events such as mouse button clicks.\n• holds the table data. Think of it as a JavaBean that extends the Swing class .\n• allows the GUI to interact with the Rules.\n• keeps the items that we wish to buy.\n• stores details of the order and the products we are buying.\n• is a JavaBean holding details of the product available for purchase, and its price. Much of the Java code is either plain JavaBeans or Swing-based. Only a few Swing-related points will be discussed in this section, but a good tutorial about Swing components can be found at Sun’s Swing website, in http://java.sun.com/docs/books/tutorial/uiswing/. The pieces of Java code in Petstore.java that relate to rules and facts are shown below. Example 305. Creating the PetStore KieContainer in PetStore.main // KieServices is the factory for all KIE services KieServices ks = KieServices.Factory.get(); // From the kie services, a container is created from the classpath KieContainer kc = ks.getKieClasspathContainer(); // Create the stock. Vector<Product> stock = new Vector<Product>(); stock.add( new Product( \"Gold Fish\", 5 ) ); stock.add( new Product( \"Fish Tank\", 25 ) ); stock.add( new Product( \"Fish Food\", 2 ) ); // A callback is responsible for populating the // Working Memory and for firing all rules. PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( kc ) ); ui.createAndShowGUI(); The code shown above create a from the classpath and based on the definitions in the kmodule.xml file. Unlike other examples where the facts are asserted and fired straight away, this example defers this step to later. The way it does this is via the second last line where a object is created using a constructor accepting the object collecting our products, and an instance of the class containing the Rule Base that we have just loaded. The Java code that fires the rules is within the method. This is triggered (eventually) when the Checkout button is pressed by the user. Example 306. Firing the Rules - extract from CheckoutCallBack.checkout() public String checkout(JFrame frame, List<Product> items) { Order order = new Order(); // Iterate through list and add to cart for ( Product p: items ) { order.addItem( new Purchase( order, p ) ); } // Add the JFrame to the ApplicationData to allow for user interaction // From the container, a session is created based on // its definition and configuration in the META-INF/kmodule.xml file KieSession ksession = kcontainer.newKieSession(\"PetStoreKS\"); ksession.setGlobal( \"frame\", frame ); ksession.setGlobal( \"textArea\", this.output ); ksession.insert( new Product( \"Gold Fish\", 5 ) ); ksession.insert( new Product( \"Fish Tank\", 25 ) ); ksession.insert( new Product( \"Fish Food\", 2 ) ); ksession.insert( new Product( \"Fish Food Sample\", 0 ) ); ksession.insert( order ); ksession.fireAllRules(); // Return the state of the cart return order.toString(); } Two items get passed into this method. One is the handle to the Swing component surrounding the output text frame, at the bottom of the GUI. The second is a list of order items; this comes from the storing the information from the \"Table\" area at the top right section of the GUI. The for loop transforms the list of order items coming from the GUI into the JavaBean, also contained in the file PetStore.java . Note that it would be possible to refer to the Swing dataset directly within the rules, but it is better coding practice to do it this way, using simple Java objects. It means that we are not tied to Swing if we wanted to transform the sample into a Web application. It is important to note that all state in this example is stored in the Swing components, and that the rules are effectively stateless. Each time the \"Checkout\" button is pressed, this code copies the contents of the Swing into the Session’s Working Memory. Within this code, there are nine calls to the . The first of these creates a new from the . Remember that we passed in this when we created the class in the method. The next two calls pass in two objects that we will hold as global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the , as well as the order list. The final call is the standard . Next, we look at what this method causes to happen within the rules file. Example 307. Package, Imports, Globals and Dialect: extract from PetStore.drl The first part of file PetStore.drl contains the standard package and import statements to make various Java classes available to the rules. New to us are the two globals and . They hold references to the Swing components and components that were previously passed on by the Java code calling the method. Unlike variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the Session. The next extract from the file PetStore.drl contains two functions that are referenced by the rules that we will look at shortly. Example 308. Java Functions in the Rules: extract from PetStore.drl function void doCheckout(JFrame frame, KieRuntime krt) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to checkout?\", \"\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (n == 0) { krt.getAgenda().getAgendaGroup( \"checkout\" ).setFocus(); } } function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) { Object[] options = {\"Yes\", \"No\"}; int n = JOptionPane.showOptionDialog(frame, \"Would you like to buy a tank for your \" + total + \" fish?\", \"Purchase Suggestion\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); System.out.print( \"SUGGESTION: Would you like to buy a tank for your \" + total + \" fish? - \" ); if (n == 0) { Purchase purchase = new Purchase( order, fishTank ); krt.insert( purchase ); order.addItem( purchase ); System.out.println( \"Yes\" ); } else { System.out.println( \"No\" ); } return true; } Having these functions in the rules file just makes the Pet Store example more compact. In real life you probably have the functions in a file of their own, within the same rules package, or as a static method on a standard Java class, and import them, using . The purpose of these two functions is:\n• displays a dialog asking users whether they wish to checkout. If they do, focus is set to the agenda-group, allowing rules in that group to (potentially) fire.\n• displays a dialog asking users whether they wish to buy a tank. If so, a new fish tank is added to the order list in Working Memory. We’ll see the rules that call these functions later on. The next set of examples are from the Pet Store rules themselves. The first extract is the one that happens to fire first, partly because it has the attribute set to true. Example 309. Putting items into working memory: extract from PetStore.drl // Insert each item in the shopping cart into the Working Memory // Insert each item in the shopping cart into the Working Memory rule \"Explode Cart\" agenda-group \"init\" auto-focus true salience 10 dialect \"java\" when $order : Order( grossTotal == -1 ) $item : Purchase() from $order.items then insert( $item ); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"show items\" ).setFocus(); kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( \"evaluate\" ).setFocus(); end This rule matches against all orders that do not yet have their calculated . It loops for each purchase item in that order. Some parts of the \"Explode Cart\" rule should be familiar: the rule name, the salience (suggesting the order for the rules being fired) and the dialect set to . There are three new features:\n• `agenda-group defines the name of the agenda group. In this case, there is only one rule in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the next attribute for its chance to fire.\n• auto-focus ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when `fireAllRules() is called from the Java code.\n• sets the focus to the and agenda groups in turn, permitting their rules to fire. In practice, we loop through all items on the order, inserting them into memory, then firing the other rules after each insert. The next two listings show the rules within the and agenda groups. We look at them in the order that they are called. Example 310. Show Items in the GUI - extract from PetStore.drl The agenda-group has only one rule, called \"Show Items\" (note the difference in case). For each purchase on the order currently in the Working Memory (or Session), it logs details to the text area at the bottom of the GUI. The variable used to do this is one of the global variables we looked at earlier. The Agenda group also gains focus from the rule listed previously. This Agenda group has two rules, and , shown below. // Free Fish Food sample when we buy a Gold Fish if we haven't already bought // Fish Food and don't already have a Fish Food Sample rule \"Free Fish Food Sample\" agenda-group \"evaluate\" dialect \"mvel\" when $order : Order() not ( $p : Product( name == \"Fish Food\") && Purchase( product == $p ) ) not ( $p : Product( name == \"Fish Food Sample\") && Purchase( product == $p ) ) exists ( $p : Product( name == \"Gold Fish\") && Purchase( product == $p ) ) $fishFoodSample : Product( name == \"Fish Food Sample\" ); then System.out.println( \"Adding free Fish Food Sample to cart\" ); purchase = new Purchase($order, $fishFoodSample); insert( purchase ); $order.addItem( purchase ); end // Suggest a tank if we have bought more than 5 gold fish and don't already have one rule \"Suggest Tank\" agenda-group \"evaluate\" dialect \"java\" when $order : Order() not ( $p : Product( name == \"Fish Tank\") && Purchase( product == $p ) ) ArrayList( $total : size > 5 ) from collect( Purchase( product.name == \"Gold Fish\" ) ) $fishTank : Product( name == \"Fish Tank\" ) then requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); end The rule will only fire if\n• we don’t already have any fish food, and\n• we don’t already have a free fish food sample, and\n• we do have a Gold Fish in our order. If the rule does fire, it creates a new product (Fish Food Sample), and adds it to the order in Working Memory. The rule will only fire if\n• we don’t already have a Fish Tank in our order, and\n• we do have more than 5 Gold Fish Products in our order. If the rule does fire, it calls the function that we looked at earlier (showing a Dialog to the user, and adding a Tank to the order / working memory if confirmed). When calling the requireTank() function the rule passes the global frame variable so that the function has a handle to the Swing GUI. The next rule we look at is . Example 312. Doing the Checkout - extract (6) from PetStore.drl rule \"do checkout\" dialect \"java\" when then doCheckout(frame, kcontext.getKieRuntime()); end The rule has no agenda group set and no auto-focus attribute. As such, is is deemed part of the default (MAIN) agenda group. This group gets focus by default when all the rules in agenda-groups that explicitly had focus set to them have run their course. There is no LHS to the rule, so the RHS will always call the function. When calling the function, the rule passes the global variable to give the function a handle to the Swing GUI. As we saw earlier, the function shows a confirmation dialog to the user. If confirmed, the function sets the focus to the checkout agenda-group, allowing the next lot of rules to fire. rule \"Gross Total\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal == -1) Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ), sum( $price ) ) then modify( $order ) { grossTotal = total }; textArea.append( \"\n\ngross total=\" + total + \"\n\n\" ); end rule \"Apply 5% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 10 && < 20 ) then $order.discountedTotal = $order.grossTotal * 0.95; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end rule \"Apply 10% Discount\" agenda-group \"checkout\" dialect \"mvel\" when $order : Order( grossTotal >= 20 ) then $order.discountedTotal = $order.grossTotal * 0.90; textArea.append( \"discountedTotal total=\" + $order.discountedTotal + \"\n\n\" ); end There are three rules in the checkout agenda-group:\n• If we haven’t already calculated the gross total, accumulates the product prices into a total, puts this total into the session, and displays it via the Swing , using the global variable yet again.\n• If our gross total is between 10 and 20, calculates the discounted total and adds it to the session and displays it in the text area.\n• If our gross total is not less than 20, calculates the discounted total and adds it to the session and displays it in the text area. Now that we’ve run through what happens in the code, let’s have a look at what happens when we actually run the code. The file PetStore.java contains a method, so that it can be run as a standard Java application, either from the command line or via the IDE. This assumes you have your classpath set correctly. (See the start of the examples section for more information.) The first screen that we see is the Pet Store Demo. It has a list of available products (top left), an empty list of selected products (top right), checkout and reset buttons (middle) and an empty system messages area (bottom). To get to this point, the following things have happened:\n• The method has run and loaded the Rule Base but not yet fired the rules. So far, this is the only code in connection with rules that has been run.\n• A new object has been created and given a handle to the Rule Base, for later use.\n• Various Swing components do their stuff, and the above screen is shown and waits for user input. Clicking on various products from the list might give you a screen similar to the one below. Note that no rules code has been fired here. This is only Swing code, listening for mouse click events, and adding some selected product to the object for display in the top right hand section. (As an aside, note that this is a classic use of the Model View Controller design pattern). It is only when we press the \"Checkout\" button that we fire our business rules, in roughly the same order that we walked through the code earlier.\n• Method is called (eventually) by the Swing class waiting for the click on the \"Checkout\" button. This inserts the data from the object (top right hand side of the GUI), and inserts it into the Session’s Working Memory. It then fires the rules.\n• The rule is the first to fire, given that it has set to true. It loops through all the products in the cart, ensures that the products are in the Working Memory, and then gives the and agenda groups a chance to fire. The rules in these groups add the contents of the cart to the text area (at the bottom of the window), decide whether or not to give us free fish food, and to ask us whether we want to buy a fish tank. This is shown in the figure below. Figure 389. Do we want to buy a fish tank?\n• The Do Checkout rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the doCheckout() function which displays a 'Would you like to Checkout?' Dialog Box.\n• The function sets the focus to the agenda-group, giving the rules in that group the option to fire.\n• The rules in the the agenda-group display the contents of the cart and apply the appropriate discount.\n• Swing then waits for user input to either checkout more products (and to cause the rules to fire again), or to close the GUI - see the figure below. Figure 390. Petstore Demo after all rules have fired. We could add more System.out calls to demonstrate this flow of events. The output, as it currently appears in the Console window, is given in the listing below. Example 314. Console (System.out) from running the PetStore GUI Adding free Fish Food Sample to cart SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes Name: Honest Politician Main class: org.drools.examples.honestpolitician.HonestPoliticianExample Module: drools-examples Type: Java application Rules file: HonestPoliticianExample.drl Objective: Illustrate the concept of \"truth maintenance\" based on the logical insertion of facts The Honest Politician example demonstrates truth maintenance with logical assertions. The basic premise is that an object can only exist while a statement is true. A rule’s consequence can logically insert an object with the method. This means the object will only remain in the Working Memory as long as the rule that logically inserted it remains true. When the rule is no longer true the object is automatically retracted. In this example there is the class , with a name and a boolean value for being honest. Four politicians with honest state set to true are inserted. Politician blair = new Politician(\"blair\", true); Politician bush = new Politician(\"bush\", true); Politician chirac = new Politician(\"chirac\", true); Politician schroder = new Politician(\"schroder\", true); ksession.insert( blair ); ksession.insert( bush ); ksession.insert( chirac ); ksession.insert( schroder ); ksession.fireAllRules(); The Console window output shows that, while there is at least one honest politician, democracy lives. However, as each politician is in turn corrupted by an evil corporation, so that all politicians become dishonest, democracy is dead. Hurrah!!! Democracy Lives I'm an evil corporation and I have corrupted schroder I'm an evil corporation and I have corrupted chirac I'm an evil corporation and I have corrupted bush I'm an evil corporation and I have corrupted blair We are all Doomed!!! Democracy is Dead As soon as there is at least one honest politician in the Working Memory a new object is logically asserted. This object will only exist while there is at least one honest politician. As soon as all politicians are dishonest, the object will be automatically retracted. This rule is given a salience of 10 to ensure that it fires before any other rule, as at this stage the \"Hope is Dead\" rule is actually true. Example 318. Honest Politician: Rule \"We have an honest politician\" rule \"We have an honest Politician\" salience 10 when exists( Politician( honest == true ) ) then insertLogical( new Hope() ); end As soon as a object exists the \"Hope Lives\" rule matches and fires. It has a salience of 10 so that it takes priority over \"Corrupt the Honest\". Now that there is hope and we have, at the start, four honest politicians, we have four activations for this rule, all in conflict. They will fire in turn, corrupting each politician so that they are no longer honest. When all four politicians have been corrupted we have no politicians with the property . Thus, the rule \"We have an honest Politician\" is no longer true and the object it logical inserted (due to the last execution of ) is automatically retracted. rule \"Corrupt the Honest\" when politician : Politician( honest == true ) exists( Hope() ) then System.out.println( \"I'm an evil corporation and I have corrupted \" + politician.getName() ); modify ( politician ) { honest = false }; end With the object being automatically retracted, via the truth maintenance system, the conditional element applied to is no longer true so that the following rule will match and fire. rule \"Hope is Dead\" when not( Hope() ) then System.out.println( \"We are all Doomed!!! Democracy is Dead\" ); end Let’s take a look at the Audit trail for this application: The moment we insert the first politician we have two activations. The rule \"We have an honest Politician\" is activated only once for the first inserted politician because it uses an conditional element, which matches once for any number. The rule \"Hope is Dead\" is also activated at this stage, because we have not yet inserted the object. Rule \"We have an honest Politician\" fires first, as it has a higher salience than \"Hope is Dead\", which inserts the object. (That action is highlighted green.) The insertion of the object activates \"Hope Lives\" and de-activates \"Hope is Dead\"; it also activates \"Corrupt the Honest\" for each inserted honest politician. Rule \"Hope Lives\" executes, printing \"Hurrah!!! Democracy Lives\". Then, for each politician, rule \"Corrupt the Honest\" fires, printing \"I’m an evil corporation and I have corrupted X\", where X is the name of the politician, and modifies the politician’s honest value to false. When the last honest politician is corrupted, is automatically retracted, by the truth maintenance system, as shown by the blue highlighted area. The green highlighted area shows the origin of the currently selected blue highlighted area. Once the fact is retracted, \"Hope is dead\" activates and fires printing \"We are all Doomed!!! Democracy is Dead\". Name: Sudoku Main class: org.drools.examples.sudoku.SudokuExample Type: Java application Rules file: sudoku.drl, validate.drl Objective: Demonstrates the solving of logic problems, and complex pattern matching. This example demonstrates how Drools can be used to find a solution in a large potential solution space based on a number of constraints. We use the popular puzzle of Sudoku. This example also shows how Drools can be integrated into a graphical interface and how callbacks can be used to interact with a running Drools rules engine in order to update the graphical interface based on changes in the Working Memory at runtime. Sudoku is a logic-based number placement puzzle. The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9, once, and only once. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints. The general strategy to solve the problem is to ensure that when you insert a new number it should be unique in its particular 3x3 zone, row and column. See Wikipedia for a more detailed description. Download and install drools-examples as described above and then execute java org.drools.examples.DroolsExamplesApp and click on \"SudokuExample\". The window contains an empty grid, but the program comes with a number of grids stored internally which can be loaded and solved. Click on \"File\", then \"Samples\" and select \"Simple\" to load one of the examples. Note that all buttons are disabled until a grid is loaded. Loading the \"Simple\" example fills the grid according to the puzzle’s initial state. Click on the \"Solve\" button and the Drools-based engine will fill out the remaining values, and the buttons are inactive once more. Alternatively, you may click on the \"Step\" button to see the next digit found by the rule set. The Console window will display detailed information about the rules which are executing to solve the step in a human readable form. Some examples of these messages are presented below. single 8 at [0,1] column elimination due to [1,2]: remove 9 from [4,2] hidden single 9 at [1,2] row elimination due to [2,8]: remove 7 from [2,4] remove 6 from [3,8] due to naked pair at [3,2] and [3,7] hidden pair in row at [4,6] and [4,4] Click on the \"Dump\" button to see the state of the grid, with cells showing either the established value or the remaining possibilitiescandidates. Now, let us load a Sudoku grid that is deliberately invalid. Click on \"File\", \"Samples\" and \"!DELIBERATELY BROKEN!\". Note that this grid starts with some issues, for example the value 5 appears twice in the first row. A few simple rules perform a sanity check, right after loading a grid. In this case, the following messages are printed on standard output: cell [0,8]: 5 has a duplicate in row 0 cell [0,0]: 5 has a duplicate in row 0 cell [6,0]: 8 has a duplicate in col 0 cell [4,0]: 8 has a duplicate in col 0 Validation complete. Nevertheless, click on the \"Solve\" button to apply the solving rules to this invalid grid. This will not complete; some cells remain empty. The solving functionality has been achieved by the use of rules that implement standard solving techniques. They are based on the sets of values that are still candidates for a cell. If, for instance, such a set contains a single value, then this is the value for the cell. A little less obvious is the single occurrence of a value in one of the groups of nine cells. The rules detecting these situations insert a fact of type Setting with the solution value for some specific cell. This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to. Finally, it is retracted. Other rules merely reduce the permissible values for some cells. Rules \"naked pair\", \"hidden pair in row\", \"hidden pair in column\" and \"hidden pair in square\" merely eliminate possibilities but do not establish solutions. More sophisticated eliminations are done by \"X-wings in rows\", \"X-wings in columns\", \"intersection removal row\" and \"intersection removal column\". The Java source code can be found in the /src/main/java/org/drools/examples/sudoku directory, with the two DRL files defining the rules located in the /src/main/rules/org/drools/examples/sudoku directory. The package contains a set of classes which implement a framework for Sudoku puzzles. Note that this package does not have any dependencies on the Drools libraries. defines an interface which can be implemented to store a Sudoku puzzle as a 9x9 grid of objects. is a Swing component which can visualize any implementation of . and are used to communicate state changes between the model and the view: events are fired when a cell’s value is resolved or changed. If you are familiar with the model-view-controller patterns in other Swing components such as then this pattern should be familiar. provides a number of partially filled Sudoku puzzles for demonstration purposes. Package contains a utility class with a method for compiling DRL files. The package contains a set of classes implementing the elementary object and its various aggregations: the subtypes and as well as , all of which are subtypes of . It’s interesting to note that and are subclasses of , which provides a property with the type . For a it represents the individual candidate set; for a the set is the union of all candidate sets of its cells, or, simply, the set of digits that still need to be allocated. With 81 and 27 objects and the linkage provided by the properties , and and the property , a list of objects, it is possible to write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set. An object of class is used for triggering the operations that accompany the allocation of a value: its removal from the candidate sets of sibling cells and associated cell groups. Moreover, the presence of a fact is used in all rules that should detect a new situation; this is to avoid reactions to inconsistent intermediary states. An object of class is used in a low priority rule to execute an emergency halt when a \"Step\" does not terminate regularly. This indicates that the puzzle cannot be solved by the program. The class implements a Java application combining the components described. Validation rules detect duplicate numbers in cell groups. They are combined in an agenda group which enables us to activate them, explicitly, after loading a puzzle. The three rules \"duplicate in cell…​\" are very similar. The first pattern locates a cell with an allocated value. The second pattern pulls in any of the three cell groups the cell belongs to. The final pattern would find a cell (other than the first one) with the same value as the first cell and in the same row, column or square, respectively. Rule \"terminate group\" fires last. It prints a message and calls halt. There are three types of rules in this file: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets. Rules \"set a value\", \"eliminate a value from Cell\" and \"retract setting\" depend on the presence of a object. The first rule handles the assignment to the cell and the operations for removing the value from the \"free\" sets of the cell’s three groups. Also, it decrements a counter that, when zero, returns control to the Java application that has called . The purpose of rule \"eliminate a value from Cell\" is to reduce the candidate lists of all cells that are related to the newly assigned cell. Finally, when all eliminations have been made, rule \"retract setting\" retracts the triggering fact. There are just two rules that detect a situation where an allocation of a number to a cell is possible. Rule \"single\" fires for a with a candidate set containing a single number. Rule \"hidden single\" fires when there is no cell with a single candidate but when there is a cell containing a candidate but this candidate is absent from all other cells in one of the three groups the cell belongs to. Both rules create and insert a fact. Rules from the largest group of rules implement, singly or in groups of two or three, various solving techniques, as they are employed when solving Sudoku puzzles manually. Rule \"naked pair\" detects identical candidate sets of size 2 in two cells of a group; these two values may be removed from all other candidate sets of that group. A similar idea motivates the three rules \"hidden pair in…​\"; here, the rules look for a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of this group. This, then, means that all other candidates can be eliminated from the two cells harbouring the hidden pair. A pair of rules deals with \"X-wings\" in rows and columns. When there are only two possible cells for a value in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated. If you follow the pattern sequence in one of these rules, you will see how the conditions that are conveniently expressed by words such as \"same\" or \"only\" result in patterns with suitable constraints or prefixed with \"not\". The rule pair \"intersection removal…​\" is based on the restricted occurrence of some number within one square, either in a single row or in a single column. This means that this number must be in one of those two or three cells of the row or column; hence it can be removed from the candidate sets of all other cells of the group. The pattern establishes the restricted occurrence and then fires for each cell outside the square and within the same cell file. These rules are sufficient for many but certainly not for all Sudoku puzzles. To solve very difficult grids, the rule set would need to be extended with more complex rules. (Ultimately, there are puzzles that cannot be solved except by trial and error.) Name: Number Guess Main class: org.drools.examples.numberguess.NumberGuessExample Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: NumberGuess.drl Objective: Demonstrate use of Rule Flow to organise Rules The \"Number Guess\" example shows the use of Rule Flow, a way of controlling the order in which rules are fired. It uses widely understood workflow diagrams for defining the order in which groups of rules will be executed. The creation of the package and the loading of the rules (using the method) is the same as the previous examples. There is an additional line to add the Rule Flow (NumberGuess.rf ), which provides the option of specifying different rule flows for the same Knowledge Base. Otherwise, the Knowledge Base is created in the same manner as before. final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession(); KnowledgeRuntimeLogger logger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/numberguess\"); ksession.insert( new GameRules( 100, 5 ) ); ksession.insert( new RandomNumber() ); ksession.insert( new Game() ); ksession.startProcess( \"Number Guess\" ); ksession.fireAllRules(); logger.close(); ksession.dispose(); Once we have a Knowledge Base, we can use it to obtain a Stateful Session. Into our session we insert our facts, i.e., standard Java objects. (For simplicity, in this sample, these classes are all contained within our NumberGuessExample.java file. Class provides the maximum range and the number of guesses allowed. Class automatically generates a number between 0 and 100 and makes it available to our rules, by insertion via the method. Class keeps track of the guesses we have made before, and their number. Note that before we call the standard method, we also start the process that we loaded earlier, via the method. We’ll learn where to obtain the parameter we pass (\"Number Guess\", i.e., the identifier of the rule flow) when we talk about the rule flow file and the graphical Rule Flow Editor below. Before we finish the discussion of our Java code, we note that in some real-life application we would examine the final state of the objects. (Here, we could retrieve the number of guesses, to add it to a high score table.) For this example we are content to ensure that the Working Memory session is cleared by calling the method. Figure 397. RuleFlow for the NumberGuess Example If you open the NumberGuess.rf file in the Drools IDE (provided you have the JBoss Rules extensions installed correctly in Eclipse) you should see the above diagram, similar to a standard flowchart. Its icons are similar (but not exactly the same) as in the JBoss jBPM workflow product. Should you wish to edit the diagram, a menu of available components should be available to the left of the diagram in the IDE, which is called the palette. This diagram is saved in XML, an (almost) human readable format, using XStream. If it is not already open, ensure that the Properties View is visible in the IDE. It can be opened by clicking \"Window\", then \"Show View\" and \"Other\", where you can select the \"Properties\" view. If you do this before you select any item on the rule flow (or click on the blank space in the rule flow) you should be presented with the following set of properties. Keep an eye on the Properties View as we progress through the example’s rule flow, as it presents valuable information. In this case, it provides us with the identification of the Rule Flow Process that we used in our earlier code snippet, when we called . In the \"Number Guess\" Rule Flow we encounter several node types, many of them identified by an icon.\n• The Start node (white arrow in a green circle) and the End node (red box) mark beginning and end of the rule flow.\n• A Rule Flow Group box (yellow, without an icon) represents a Rule Flow Groups defined in our rules (DRL) file that we will look at later. For example, when the flow reaches the Rule Flow Group \"Too High\", only those rules marked with an attribute of `ruleflow-group can potentially fire.\n• Action nodes (yellow, cog-shaped icon) perform standard Java method calls. Most action nodes in this example call , indicating the program’s progress to the user.\n• Split and Join Nodes (blue ovals, no icon) such as \"Guess Correct?\" and \"More guesses Join\" mark places where the flow of control can split, according to various conditions, and rejoin, respectively\n• Arrows indicate the flow between the various nodes. The various nodes in combination with the rules make the Number Guess game work. For example, the \"Guess\" Rule Flow Group allows only the rule \"Get user Guess\" to fire, because only that rule has a matching attribute of `ruleflow-group . Example 324. A Rule firing only at a specific point in the Rule Flow: NumberGuess.drl rule \"Get user Guess\" ruleflow-group \"Guess\" no-loop when $r : RandomNumber() rules : GameRules( allowed : allowedGuesses ) game : Game( guessCount < allowed ) not ( Guess() ) then System.out.println( \"You have \" + ( rules.allowedGuesses - game.guessCount ) + \" out of \" + rules.allowedGuesses + \" guesses left.\n\nPlease enter your guess from 0 to \" + rules.maxRange ); br = new BufferedReader( new InputStreamReader( System.in ) ); i = br.readLine(); modify ( game ) { guessCount = game.guessCount + 1 } insert( new Guess( i ) ); end The rest of this rule is fairly standard. The LHS section (after ) of the rule states that it will be activated for each object inserted into the Working Memory where is less than from the object and where the user has not guessed the correct number. The RHS section (or consequence, after ) prints a message to the user and then awaits user input from . After obtaining this input (the method call blocks until the return key is pressed) it modifies the guess count and inserts the new guess, making both available to the Working Memory. The rest of the rules file is fairly standard: the package declares the dialect as MVEL, and various Java classes are imported. In total, there are five rules in this file:\n• Get User Guess, the Rule we examined above.\n• A Rule to inspect the guess and retract it from memory if incorrect.\n• A Rule that notifies the user that all guesses have been used up. One point of integration between the standard Rules and the RuleFlow is via the attribute on the rules, as discussed above. A second point of integration between the rules (.drl) file and the Rules Flow .rf files is that the Split Nodes (the blue ovals) can use values in the Working Memory (as updated by the rules) to decide which flow of action to take. To see how this works, click on the \"Guess Correct Node\"; then within the Properties View, open the Constraints Editor by clicking the button at the right that appears once you click on the \"Constraints\" property line. You should see something similar to the diagram below. Click on the \"Edit\" button beside \"To node Too High\" and you’ll see a dialog like the one below. The values in the \"Textual Editor\" window follow the standard rule format for the LHS and can refer to objects in Working Memory. The consequence (RHS) is that the flow of control follows this node (i.e., \"To node Too High\") if the LHS expression evaluates to true. Figure 400. Constraint Editor for the \"Guess Correct\" Node: value too high Since the file NumberGuess.java contains a method, it can be run as a standard Java application, either from the command line or via the IDE. A typical game might result in the interaction below. The numbers in bold are typed in by the user. Example 325. Example Console output where the Number Guess Example beat the human! You have 5 out of 5 guesses left. Please enter your guess from 0 to 100 50 Your guess was too high You have 4 out of 5 guesses left. Please enter your guess from 0 to 100 25 Your guess was too low You have 3 out of 5 guesses left. Please enter your guess from 0 to 100 37 Your guess was too low You have 2 out of 5 guesses left. Please enter your guess from 0 to 100 44 Your guess was too low You have 1 out of 5 guesses left. Please enter your guess from 0 to 100 47 Your guess was too low You have no more guesses The correct guess was 48 A summary of what is happening in this sample is:\n• The method of NumberGuessExample.java loads a Rule Base, creates a Stateful Session and inserts , and (containing the target number) objects into it. The method also sets the process flow we are going to use, and fires all rules. Control passes to the Rule Flow.\n• File NumberGuess.rf , the Rule Flow, begins at the \"Start\" node.\n• Control passes (via the \"More guesses\" join node) to the Guess node.\n• At the Guess node, the appropriate Rule Flow Group (\"Get user Guess\") is enabled. In this case the Rule \"Guess\" (in the NumberGuess.drl file) is triggered. This rule displays a message to the user, takes the response, and puts it into Working Memory. Flow passes to the next Rule Flow Node.\n• At the next node, \"Guess Correct\", constraints inspect the current session and decide which path to take. If the guess in step 4 was too high or too low, flow proceeds along a path which has an action node with normal Java code printing a suitable message and a Rule Flow Group causing a highest guess or lowest guess rule to be triggered. Flow passes from these nodes to step 6. If the guess in step 4 was right, we proceed along the path towards the end of the Rule Flow. Before we get there, an action node with normal Java code prints a statement \"you guessed correctly\". There is a join node here (just before the Rule Flow end) so that our no-more-guesses path (step 7) can also terminate the Rule Flow.\n• Control passes as per the Rule Flow via a join node, a guess incorrect Rule Flow Group (triggering a rule to retract a guess from Working Memory) onto the \"More guesses\" decision node.\n• The \"More guesses\" decision node (on the right hand side of the rule flow) uses constraints, again looking at values that the rules have put into the working memory, to decide if we have more guesses and if so, goto step 3. If not, we proceed to the end of the rule flow, via a Rule Flow Group that triggers a rule stating \"you have no more guesses\".\n• The loop over steps 3 to 7 continues until the number is guessed correctly, or we run out of guesses. Name: Conway's Game Of Life Main class: org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun Module: droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.) Type: Java application Rules file: conway-ruleflow.drl conway-agendagroup.drl Objective: Demonstrates 'accumulate', 'collect' and 'from' Conway’s Game Of Life, described in http://en.wikipedia.org/wiki/Conway’s_Game_of_Life and in http://www.math.com/students/wonders/life/life.html, is a famous cellular automaton conceived in the early 1970’s by the mathematician John Conway. While the system is well known as \"Conway’s Game Of Life\", it really isn’t a game at all. Conway’s system is more like a simulation of a form of life. Don’t be intimidated. The system is terribly simple and terribly interesting. Math and Computer Science students alike have marvelled over Conway’s system for more than 30 years now. The application presented here is a Swing-based implementation of Conway’s Game of Life. The rules that govern the system are implemented as business rules using Drools. This document will explain the rules that drive the simulation and discuss the Drools parts of the implementation. We’ll first introduce the grid view, shown below, designed for the visualisation of the game, showing the \"arena\" where the life simulation takes place. Initially the grid is empty, meaning that there are no live cells in the system. Each cell is either alive or dead, with live cells showing a green ball. Preselected patterns of live cells can be chosen from the \"Pattern\" drop-down list. Alternatively, individual cells can be doubled-clicked to toggle them between live and dead. It’s important to understand that each cell is related to its neighboring cells, which is fundamental for the game’s rules. Neighbors include not only cells to the left, right, top and bottom but also cells that are connected diagonally, so that each cell has a total of 8 neighbors. Exceptions are the four corner cells which have only three neighbors, and the cells along the four border, with five neighbors each. So what are the basic rules that govern this game? Its goal is to show the development of a population, generation by generation. Each generation results from the preceding one, based on the simultaneous evaluation of all cells. This is the simple set of rules that govern what the next generation will look like:\n• If a live cell has fewer than 2 live neighbors, it dies of loneliness.\n• If a live cell has more than 3 live neighbors, it dies from overcrowding.\n• If a dead cell has exactly 3 live neighbors, it comes to life. That is all there is to it. Any cell that doesn’t meet any of those criteria is left as is for the next generation. With those simple rules in mind, go back and play with the system a little bit more and step through some generations, one at a time, and notice these rules taking their effect. The screenshot below shows an example generation, with a number of live cells. Don’t worry about matching the exact patterns represented in the screen shot. Just get some groups of cells added to the grid. Once you have groups of live cells in the grid, or select a pre-designed pattern, click the \"Next Generation\" button and notice what happens. Some of the live cells are killed (the green ball disappears) and some dead cells come to life (a green ball appears). Step through several generations and see if you notice any patterns. If you click on the \"Start\" button, the system will evolve itself so you don’t need to click the \"Next Generation\" button over and over. Play with the system a little and then come back here for more details of how the application works. Now lets delve into the code. As this is an advanced example we’ll assume that by now you know your way around the Drools framework and are able to connect the presented highlight, so that we’ll just focus at a high level overview. The example has two ways to execute, one way uses Agenda Groups to manage execution flow, and the other one uses Rule Flow Groups to manage execution flow. These two versions are implemented in and , respectively. Here, we’ll discuss the Rule Flow version, as it’s what most people will use. All the objects are inserted into the Session and the rules in the \"register neighbor\" are allowed to execute by the Rule Flow process. This group of four rules creates relations between some cell and its northeastern, northern, northwestern and western neighbors. This relation is bidirectional, which takes care of the other four directions. Border cells don’t need any special treatment - they simply won’t be paired with neighboring cells where there isn’t any. By the time all activations have fired for these rules, all cells are related to all their neighboring cells. rule \"register north east\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northEast : Cell( row == ($row - 1), col == ( $col + 1 ) ) then insert( new Neighbor( $cell, $northEast ) ); insert( new Neighbor( $northEast, $cell ) ); end rule \"register north\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $north : Cell( row == ($row - 1), col == $col ) then insert( new Neighbor( $cell, $north ) ); insert( new Neighbor( $north, $cell ) ); end rule \"register north west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $northWest : Cell( row == ($row - 1), col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $northWest ) ); insert( new Neighbor( $northWest, $cell ) ); end rule \"register west\" ruleflow-group \"register neighbor\" when $cell: Cell( $row : row, $col : col ) $west : Cell( row == $row, col == ( $col - 1 ) ) then insert( new Neighbor( $cell, $west ) ); insert( new Neighbor( $west, $cell ) ); end Once all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to Live. Then, when the user clicks \"Start\" or \"Next Generation\", it executes the \"Generation\" ruleflow. This ruleflow is responsible for the management of all changes of cells in each generation cycle. The rule flow process first enters the \"evaluate\" group, which means that any active rule in the group can fire. The rules in this group apply the Game-of-Life rules discussed in the beginning of the example, determining the cells to be killed and the ones to be given life. We use the \"phase\" attribute to drive the reasoning of the Cell by specific groups of rules; typically the phase is tied to a Rule Flow Group in the Rule Flow process definition. Notice that it doesn’t actually change the state of any objectss at this point; this is because it’s evaluating the grid in turn and it must complete the full evaluation until those changes can be applied. To achieve this, it sets the cell to a \"phase\" which is either or , used later to control actions applied to the object. Example 327. Conway’s Game of Life: Evaluate Cells with state changes rule \"Kill The Lonely\" ruleflow-group \"evaluate\" no-loop when // A live cell has fewer than 2 live neighbors theCell: Cell( liveNeighbors < 2, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Kill The Overcrowded\" ruleflow-group \"evaluate\" no-loop when // A live cell has more than 3 live neighbors theCell: Cell( liveNeighbors > 3, cellState == CellState.LIVE, phase == Phase.EVALUATE ) then modify( theCell ){ setPhase( Phase.KILL ); } end rule \"Give Birth\" ruleflow-group \"evaluate\" no-loop when // A dead cell has 3 live neighbors theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE ) then modify( theCell ){ theCell.setPhase( Phase.BIRTH ); } end Once all objects in the grid have been evaluated, we first clear any calculation activations that occurred from any previous data changes. This is done via the \"reset calculate\" rule, which clears any activations in the \"calculate\" group. We then enter a split in the rule flow which allows any activations in both the \"kill\" and the \"birth\" group to fire. These rules are responsible for applying the state change. Example 328. Conway’s Game of Life: Apply the state changes rule \"reset calculate\" ruleflow-group \"reset calculate\" when then WorkingMemory wm = drools.getWorkingMemory(); wm.clearRuleFlowGroup( \"calculate\" ); end rule \"kill\" ruleflow-group \"kill\" no-loop when theCell: Cell( phase == Phase.KILL ) then modify( theCell ){ setCellState( CellState.DEAD ), setPhase( Phase.DONE ); } end rule \"birth\" ruleflow-group \"birth\" no-loop when theCell: Cell( phase == Phase.BIRTH ) then modify( theCell ){ setCellState( CellState.LIVE ), setPhase( Phase.DONE ); } end At this stage, a number of objects have been modified with the state changed to either or . Now we get to see the power of the facts defining the cell relations. When a cell becomes live or dead, we use the relation to iterate over all surrounding cells, increasing or decreasing the count. Any cell that has its count changed is also set to to the phase, to make sure it is included in the reasoning during the evaluation stage of the Rule Flow Process. Notice that we don’t have to do any iteration ourselves; simply by applying the relations in the rules we make the rule engine do all the hard work for us, with a minimal amount of code. Once the live count has been determined and set for all cells, the Rule Flow Process comes to and end. If the user has initially clicked the \"Start\" button, the engine will restart the rule flow; otherwise the user may request another generation. Example 329. Conway’s Game of Life: Evaluate cells with state changes rule \"Calculate Live\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.LIVE ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ), setPhase( Phase.EVALUATE ); } end rule \"Calculate Dead\" ruleflow-group \"calculate\" lock-on-active when theCell: Cell( cellState == CellState.DEAD ) Neighbor( cell == theCell, $neighbor : neighbor ) then modify( $neighbor ){ setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ), setPhase( Phase.EVALUATE ); } end A simplifed version of the Space Invaders game. Use the keys Z and K, to move left and right and M to fire a misile. The example is built up over 6 projects, each adding slightly more complexity to the last. Invaders1Main creates the frame and attaches the KeyListener, feeding key events into the engine. It also sets up the main game loop which can be found in \"Main.drl\". The typical convention used through out the example is to have one agenda group per file, and all rules in that file in the same agenda group. The Run fact is used to drive the repeat of the Game loop. Initially there are only one groups that is evaluated, Keys. The \"keys.drl\" file is shared by several examples, and illustrates rule re-use across multipel projects. rule \"init\" when then insert( new Run() ); setFocus( \"Init\" ); end rule GameLoop when r : Run() then setFocus( \"Keys\" ); end rule Draw when r : Run() then ui.show(); modify( r ) {} // force loop end Invaders2Main adds the \"Draw\" stage to the game loop and draws the SpaceShip Invaders3Main adds move controls to the spaceship, notice the ship moves out of the boundaries of the screen. KeyPressed is detected and that sets a delta of dx on the ship direction. That delta is then repeated applied to the x position of the ship rule ShipDeltaMoveLeft agenda-group \"Move\" when s : Ship() KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 - s.speed } end rule ShipDeltaStopLeft agenda-group \"Move\" when s : Ship() not KeyPressed( keyText == \"Z\" ) then modify( s ) { dx = 0 } end rule ShipMove agenda-group \"Move\" when s : Ship( dx != 0 ) Run() then modify( s ) { x = s.x + s.dx } end Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. Invaders6Main adds a lot more meat. Pressing the \"M\" key fires a missile that travels up the screen, while moving collision between the missile and the invader is checked. Invaders4Main adds boundari control to the ShipMove rule, so it doesn’t move off the screen. Notice the use of \"@watch( !x )\", this ensures that while the rule wil modify the x property, it will not react to changes to x, which avoids recursion issues. rule InsertBullet agenda-group \"Bullet\" when KeyPressed( keyText == \"M\" ) s : Ship() not Bullet() then b = new Bullet(); b.x = s.x + (s.width/2) - (b.width/2); b.y = s.y - s.height - b.height; b.width = conf.bulletWidth; b.height = conf.bulletHeight; b.dy = 0 - conf.bulletSpeed; insert( b ); end rule BulletMove agenda-group \"Bullet\" when b : Bullet( y > 0 ) @watch( !y ) Run() then modify( b ) { y = b.y + b.dy } end rule Collision agenda-group \"Bullet\" when b : Bullet( ) @watch( y ) i : Invader( x < b.x, x + width > b.x, y > b.y) Run() then modify( i ) { alive = false } end Based on the Adventure in Prolog, over at the Amzi website, http://www.amzi.com/AdventureInProlog/, we started to work on a text adventure game for Drools. They are ideal as they can start off simple and build in complexity and size over time, they also demonstrate key aspects of declarative relational programming. The game allows you to play as the hero or the monster. If you click \"New Window\" you can open one window as the hero and another as the monster, and play them both at the same time. The game allows either character to move around rooms, pick up, drop or use things. Doors can be locked and unlocked, by using the key on teh exit room, and the hero can kill the monster by using the umbrella on the monster. You can view the 8 minute demonstration and introduction for the example at http://downloads.jboss.org/drools/videos/text-adventures.swf. Be aware the video is now much older than the current improved example. Each action follows the constructor arguments of the associated Command java class. To issue a move action, select the \"Move\" button, then select the exit room. Notice when you press \"Move\" it adds the text to the white bar at the bottom. When the exit room is selected, it also is added to the white bar. Then press send and the game engine will execute the command. Internally it uses reflection to instantiate the Command and insert it into the engine. If you select incorrect arguments, such as pressing exits multiple times, the reflection will fail and you can attempt it again. The Things list displays anything you can see in the room, not all things can be picked up. For instance you can pick up the key and the torch, but not the monster. When something is picked up it moves from the Things list to the Inventory List. The reverse is true when something is dropped. The key is in the office, move upstairs and into the office. Then pick up the key. Move back downstairs and into the kitchen. Try and walk into the basement, notice it’s locked. Select the \"Use\" action, the select the key and then the basement exit. This will unlock the door and you can now walk through. To kill the monster pick up the umbrella from the lounge and then select \"Use\", then select the imbrella and finally select the monster. Don’t forget to open a \"New Window\" to play as the monster, although you will not be able to exit the basement until the hero has opened it with the key. The monster and the hero can also give items to each other, moving items between each playsers inventory. The model is written in Java classes. Each classes uses @PropertyReactive and @Position. @PropertyReactive allows control of which fields patterns react to, and @Position maps a field to a argument position allowing positional as well as named arguments for patterns. @PropertyReactive public class Thing { @Position(0) private long id; @Position(1) private String name; public Thing(long id, String name) { this.id = id; this.name = name; } ... } An MVEL data file is used to populate our world, see \"data.mvel\". You can edit this file to add new rooms, items and characters, as well as locks for doors. rooms = [ \"basement\" : new Room(\"basement\"), \"lounge\" : new Room(\"lounge\"), \"kitchen\" : new Room(\"kitchen\"), \"ground floor hallway\" : new Room(\"ground floor hallway\"), \"bedroom\" : new Room(\"bedroom\"), \"office\" : new Room(\"office\"), \"first floor hallway\" : new Room(\"first floor hallway\") ]; doors = [ \"d1\" : new Door( rooms[\"kitchen\"], rooms[\"basement\"] ), \"d2\" : new Door( rooms[\"ground floor hallway\"], rooms[\"lounge\"]), \"d4\" : new Door( rooms[\"ground floor hallway\"], rooms[\"kitchen\"]), \"d5\" : new Door( rooms[\"ground floor hallway\"], rooms[ \"first floor hallway\"] ), \"d8\" : new Door( rooms[\"first floor hallway\"], rooms[ \"bedroom\"] ), \"d9\" : new Door( rooms[\"first floor hallway\"], rooms[ \"office\"] ) ]; locations = [ \"monster\" : new Location( characters[\"monster\"], rooms[\"basement\"] ), \"hero\" : new Location( characters[\"hero\"], rooms[\"ground floor hallway\"] ), \"umbrella\" : new Location( items[\"umbrella\"], rooms[\"lounge\"] ), \"key1\" : new Location( items[\"key1\"], rooms[\"office\"] ) ]; The game creates commands, which it inserts into the engine. These commands are then used to change the state of the world and that state is reflected back in the UI. The commands can be found in the \"commands.drl\" file. The following rule matches the MoveCommand and if it’s valid it will make the move happen. rule validMove agenda-group \"commands\" when mc : MoveCommand( c : character, r : room ) l : Location( thing == c, ltarget : target ) @watch( !target ) ?connect( d, r, ltarget; ) then exit = new ExitEvent( c, (Room) l.target ); enter = new EnterEvent( c, r ); modify( l ) { target = r }; insert( exit ); insert( enter ); mc.session.channels[\"output\"].send( \"You have entered the \" + l.target.name + \"\n\n\" ); end In the above rules notice the \"connect\" pattern, this is actually a query. In the MVEL data file doors are only described one way, we can use a query to check connections bi-directionally. The queries can be found in the \"queries.drl\" file. query connect( Door $d, Room $x, Room $y ) $d := Door($id, $name, $x, $y;) or $d :=Door($id, $name, $y, $x;) end The UI has its list boxes populated by rules found in \"UiView.drl\", those rules in turn use queries. Here is how the \"Things\" list box is populated, when ever the world changes. rule updateThings salience 5 when session : UserSession( $char : character ) things( $char, $things; ) then session.channels[\"things\"].send( $things ); end query things(Character $char, List $things) $char := Character() Location( $char, $room; ) $things := List() from accumulate( Location($thing, $room; thing != $char), collectList( $thing ) ) end A Conversion for the classic game Pong. Use the keys A, Z and K, M. The ball should get faster after each bounce. Wumpus World is an AI example covered in the book \"Artificial Intelligence : A Modern Approach\". When the game first starts all the cells are greyed out. As you walk around they become visible. The cave has pits, a wumpus and gold. When you are next to a pit you will feel a breeze, when you are next to the wumpus you will smell a stench and see glitter when next to gold. The sensor icons are shown above the move buttons. If you walk into a pit or the wumpus, you die. A more detailed overview of Wumpus World can be found at http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml. A 20 minute video showing how the game is created and works is at http://www.youtube.com/watch?v=4CvjKqUOEzM. Name: Miss Manners Main class: org.drools.benchmark.manners.MannersBenchmark Module: drools-examples Type: Java application Rules file: manners.drl Objective: Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth. Miss Manners is throwing a party and, being a good host, she wants to arrange good seating. Her initial design arranges everyone in male-female pairs, but then she worries about people have things to talk about. What is a good host to do? She decides to note the hobby of each guest so she can then arrange guests not only pairing them according to alternating sex but also ensuring that a guest has someone with a common hobby, at least on one side. Five benchmarks were established in the 1991 paper \"Effects of Database Size on Rule System Performance: Five Case Studies\" by David Brant, Timothy Grose, Bernie Lofaso and Daniel P. Miranker:\n• Manners uses a depth-first search approach to determine the seating arrangements alternating women and men and ensuring one common hobby for neighbors.\n• Waltz establishes a three-dimensional interpretation of a line drawing by line labeling by constraint propagation.\n• WaltzDB is a more general version of Waltz, supporting junctions of more than three lines and using a database.\n• ARP is a route planner for a robotic air vehicle using the A* search algorithm to achieve minimal cost.\n• Weaver VLSI router for channels and boxes using a black-board technique. Manners has become the de facto rule engine benchmark. Its behavior, however, is now well known and many engines optimize for this, thus negating its usefulness as a benchmark which is why Waltz is becoming more favorable. These five benchmarks are also published at the University of Texas http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/. After the first seating arrangement has been assigned, a depth-first recursion occurs which repeatedly assigns correct seating arrangements until the last seat is assigned. Manners uses a instance to control execution flow. The activity diagram is partitioned to show the relation of the rule execution to the current state. Before going deeper into the rules, let’s first take a look at the asserted data and the resulting seating arrangement. The data is a simple set of five guests who should be arranged so that sexes alternate and neighbors have a common hobby. The data is given in OPS5 syntax, with a parenthesized list of name and value pairs for each attribute. Each person has only one hobby. Each line of the results list is printed per execution of the \"Assign Seat\" rule. They key bit to notice is that each line has a \"pid\" value one greater than the last. (The significance of this will be explained in the discussion of the rule \"Assign Seating\".) The \"ls\", \"rs\", \"ln\" and \"rn\" refer to the left and right seat and neighbor’s name, respectively. The actual implementation uses longer attribute names (e.g., , but here we’ll stick to the notation from the original implementation. Manners has been designed to exercise cross product joins and Agenda activities. Many people not understanding this tweak the example to achieve better performance, making their port of the Manners benchmark pointless. Known cheats or porting errors for Miss Manners are:\n• Using arrays for a guests hobbies, instead of asserting each one as a single fact massively reduces the cross products.\n• Altering the sequence of data can also reduce the amount of matching, increasing execution speed.\n• It’s possible to change the Conditional Element so that the test algorithm only uses the \"first-best-match\", which is, basically, transforming the test algorithm to backward chaining. The results are only comparable to other backward chaining rule engines or ports of Manners.\n• Removing the context so the rule engine matches the guests and seats prematurely. A proper port will prevent facts from matching using the context start.\n• It’s possible to prevent the rule engine from performing combinatorial pattern matching.\n• If no facts are retracted in the reasoning cycle, as a result of the CE, the port is incorrect. The Manners benchmark was written for OPS5 which has two conflict resolution strategies, LEX and MEA. LEX is a chain of several strategies including salience, recency and complexity. The recency part of the strategy drives the depth first (LIFO) firing order. The CLIPS manual documents the Recency strategy as follows: Every fact and instance is marked internally with a \"time tag\" to indicate its relative recency with respect to every other fact and instance in the system. The pattern entities associated with each rule activation are sorted in descending order for determining placement. An activation with a more recent pattern entity is placed before activations with less recent pattern entities. To determine the placement order of two activations, compare the sorted time tags of the two activations one by one starting with the largest time tags. The comparison should continue until one activation’s time tag is greater than the other activation’s corresponding time tag. The activation with the greater time tag is placed before the other activation on the agenda. If one activation has more pattern entities than the other activation and the compared time tags are all identical, then the activation with more time tags is placed before the other activation on the agenda. However Jess and CLIPS both use the Depth strategy, which is simpler and lighter, which Drools also adopted. The CLIPS manual documents the Depth strategy as: Newly activated rules are placed above all rules of the same salience. For example, given that fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda. However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary. The initial Drools implementation for the Depth strategy would not work for Manners without the use of salience on the \"make_path\" rule. The CLIPS support team had this to say: The default conflict resolution strategy for CLIPS, Depth, is different than the default conflict resolution strategy used by OPS5. Therefore if you directly translate an OPS5 program to CLIPS, but use the default depth conflict resolution strategy, you’re only likely to get the correct behavior by coincidence. The LEX and MEA conflict resolution strategies are provided in CLIPS to allow you to quickly convert and correctly run an OPS5 program in CLIPS. Investigation into the CLIPS code reveals there is undocumented functionality in the Depth strategy. There is an accumulated time tag used in this strategy; it’s not an extensively fact by fact comparison as in the recency strategy, it simply adds the total of all the time tags for each activation and compares. Once the context is changed to , activations are created for all asserted guest. Because all activations are created as the result of a single Working Memory action, they all have the same Activation time tag. The last asserted object would have a higher fact time tag, and its Activation would fire because it has the highest accumulated fact time tag. The execution order in this rule has little importance, but has a big impact in the rule \"Assign Seat\". The activation fires and asserts the first arrangement and a , and then sets the attribute to create an activation for rule . rule assignFirstSeat when context : Context( state == Context.START_UP ) guest : Guest() count : Count() then String guestName = guest.getName(); Seating seating = new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName); insert( seating ); Path path = new Path( count.getValue(), 1, guestName ); insert( path ); modify( count ) { setValue ( count.getValue() + 1 ) } System.out.println( \"assign first seat : \" + seating + \" : \" + path ); modify( context ) { setState( Context.ASSIGN_SEATS ) } end This rule determines each of the arrangements. The rule creates cross product solutions for all asserted arrangements against all the asserted guests except against itself or any already assigned chosen solutions. rule findSeating when context : Context( state == Context.ASSIGN_SEATS ) $s : Seating( pathDone == true ) $g1 : Guest( name == $s.rightGuestName ) $g2 : Guest( sex != $g1.sex, hobby == $g1.hobby ) count : Count() not ( Path( id == $s.id, guestName == $g2.name) ) not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) ) then int rightSeat = $s.getRightSeat(); int seatId = $s.getId(); int countValue = count.getValue(); Seating seating = new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ); insert( seating ); Path path = new Path( countValue, rightSeat + 1, $g2.getName() ); insert( path ); Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() ); insert( chosen ); System.err.println( \"find seating : \" + seating + \" : \" + path + \" : \" + chosen); modify( count ) {setValue( countValue + 1 )} modify( context ) {setState( Context.MAKE_PATH )} end However, as can be seen from the printed results shown earlier, it is essential that only the with the highest cross product be chosen. How can this be possible if we have activations, of the same time tag, for nearly all existing and objects? For example, on the third iteration of the produced activations will be as shown below. Remember, this is from a very small data set, and with larger data sets there would be many more possible activated solutions, with multiple solutions per : The creation of all these redundant activations might seem pointless, but it must be remembered that Manners is not about good rule design; it’s purposefully designed as a bad ruleset to fully stress-test the cross product matching process and the Agenda, which this clearly does. Notice that each activation has the same time tag of 35, as they were all activated by the change in the object to . With OPS5 and LEX it would correctly fire the activation with the asserted last. With Depth, the accumulated fact time tag ensures that the activation with the last asserted fires. Rule must always fire before . A object is asserted for each arrangement, up to the last asserted . Notice that the conditions in are a subset of those in - so how do we ensure that fires first? rule makePath when Context( state == Context.MAKE_PATH ) Seating( seatingId:id, seatingPid:pid, pathDone == false ) Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat ) not Path( id == seatingId, guestName == pathGuestName ) then insert( new Path( seatingId, pathSeat, pathGuestName ) ); end Both rules end up on the Agenda in conflict and with identical activation time tags. However, the accumulate fact time tag is greater for \"Make Path\" so it gets priority. Rule only activates when the last seat is assigned, at which point both rules will be activated. For the same reason that always wins over , will take priority over rule . Assign First seat =>[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] =>[fid:14:14]:[Path id=1, seat=1, guest=n5] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] ==>[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1 , pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]* Assign Seating =>[fid:15:17] :[Seating id=2 , pid=1 , done=false, ls=1, lg=n5, rs=2, rn=n4] =>[fid:16:18]:[Path id=2, seat=2, guest=n4] =>[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1] =>[ActivationCreated(21): rule=makePath [fid:15:17] : [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] [fid:14:14] : [Path id=1, seat=1, guest=n5]* ==>[ActivationCreated(21): rule=pathDone [Seating id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]* Make Path =>[fid:18:22:[Path id=2, seat=1, guest=n5]] Path Done Continue Process =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:7:7]:[Guest name=n4, sex=f, hobbies=h3] [fid:4:4] : [Guest name=n3, sex=m, hobbies=h3]* =>[ActivationCreated(25): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3] =>[ActivationCreated(25): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]] =>[fid:20:27]:[Path id=3, seat=3, guest=n3]] =>[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}] =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:18:22]:[Path id=2, seat=1, guest=n5]* =>[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:16:18]:[Path id=2, seat=2, guest=n4]* =>[ActivationCreated(30): rule=done [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]* Make Path =>[fid:22:31]:[Path id=3, seat=1, guest=n5] Make Path =>[fid:23:32] [Path id=3, seat=2, guest=n4] Path Done Continue Processing =>[ActivationCreated(35): rule=findSeating [fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] [fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest name=n2, sex=f, hobbies=h3], [fid:12:29]* =>[ActivationCreated(35): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(35): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]] =>[fid:25:37]:[Path id=4, seat=4, guest=n2]] =>[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3] ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:23:32]:[Path id=3, seat=2, guest=n4]* ==>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:20:27]:[Path id=3, seat=3, guest=n3]* =>[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:22:31]:[Path id=3, seat=1, guest=n5]* =>[ActivationCreated(40): rule=done [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]* Make Path =>fid:27:41:[Path id=4, seat=2, guest=n4] Make Path =>fid:28:42]:[Path id=4, seat=1, guest=n5]] Make Path =>fid:29:43]:[Path id=4, seat=3, guest=n3]] Path Done Continue Processing =>[ActivationCreated(46): rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1], [fid:2:2] [Guest name=n2, sex=f, hobbies=h1] =>[ActivationCreated(46): rule=findSeating [fid:24:44]:[Seating id=4, pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2] [fid:2:2]:[Guest name=n2, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]* =>[ActivationCreated(46): rule=findSeating [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] Assign Seating =>[fid:30:47]:[Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1] =>[fid:31:48]:[Path id=5, seat=5, guest=n1] =>[fid:32:49]:[Chosen id=4, name=n1, hobbies=h1] A backward-chaining rule system is goal-driven. This means the system starts with a conclusion which the engine tries to satisfy. If it cannot do so it searches for sub-goals, that is, conclusions that will complete part of the current goal. It continues this process until either the initial conclusion is satisfied or there are no more unsatisfied sub-goals. Prolog is an example of a backward-chaining engine. Backward-Chaining is a feature recently added to the JBoss Rules Engine. This process is often referred to as derivation queries, and it is not as common compared to reactive systems since JBoss Rules is primarily reactive forward chaining. That is, it responds to changes in your data. The backward-chaining added to the engine is for product-like derivations. The previous chart demonstrates a House example of transitive items. A similar reasoning chart can be created by implementing the following rules: 1. First, create some java rules to develop reasoning for transitive items. It inserts each of the locations. 2. Next, create the Location class; it has the item and where it is located. 3. Type the rules for the House example as depicted below: ksession.insert( new Location(\"office\", \"house\") ); ksession.insert( new Location(\"kitchen\", \"house\") ); ksession.insert( new Location(\"knife\", \"kitchen\") ); ksession.insert( new Location(\"cheese\", \"kitchen\") ); ksession.insert( new Location(\"desk\", \"office\") ); ksession.insert( new Location(\"chair\", \"office\") ); ksession.insert( new Location(\"computer\", \"desk\") ); ksession.insert( new Location(\"drawer\", \"desk\") ); 4. A transitive design is created in which the item is in its designated location such as a \"desk\" located in an \"office.\" 1. Create a query to look at the data inserted into the rules engine: Notice how the query is recursive and is calling \"isContainedIn.\" 2. Create a rule to print out every string inserted into the system to see how things are implemented. The rule should resemble the following format: rule \"go\" salience 10 when $s : String( ) then System.out.println( $s ); end 3. Using Step 2 as a model, create a rule that calls upon the Step 1 query \"isContainedIn.\" rule \"go1\" when String( this == \"go1\" ) isContainedIn(\"office\", \"house\"; ) then System.out.println( \"office is in the house\" ); end The \"go1\" rule will fire when the first string is inserted into the engine. That is, it asks if the item \"office\" is in the location \"house.\" Therefore, the Step 1 query is evoked by the previous rule when the \"go1\" String is inserted. 4. Create the \"go1,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go1\" ); ksession.fireAllRules(); --- go1 office is in the house The --- line indicates the separation of the output of the engine from the firing of the \"go\" rule and the \"go1\" rule. 1. Create a Transitive Closure by implementing the following rule: rule \"go2\" when String( this == \"go2\" ) isContainedIn(\"drawer\", \"house\"; ) then System.out.println( \"Drawer in the House\" ); end 2. Recall from the Cloning Transitive Closure’s topic, there was no instance of \"drawer\" in \"house.\" \"drawer\" was located in \"desk.\" 3. Use the previous query for this recursive information. 4. Create the \"go2,\" insert it into the engine, and call the fireAllRules. When the rule is fired, it correctly tells you \"go2\" has been inserted and that the \"drawer\" is in the \"house.\" 5. Check how the engine determined this outcome\n• The query has to recurse down several levels to determine this.\n• Instead of using Location( x, y; ), The query uses the value of (z, y; ) since \"drawer\" is not in \"house.\"\n• The z is currently unbound which means it has no value and will return everything that is in the argument.\n• y is currently bound to \"house,\" so z will return \"office\" and \"kitchen.\"\n• Information is gathered from \"office\" and checks recursively if the \"drawer\" is in the \"office.\" The following query line is being called for these parameters: isContainedIn (x ,z; ) There is no instance of \"drawer\" in \"office;\" therefore, it does not match. With z being unbound, it will return data that is within the \"office,\" and it will gather that z == desk. isContainedIn recurses three times. On the final recurse, an instance triggers of \"drawer\" in the \"desk.\" This matches on the first location and recurses back up, so we know that \"drawer\" is in the \"desk,\" the \"desk\" is in the \"office,\" and the \"office\" is in the \"house;\" therefore, the \"drawer\" is in the \"house\" and returns true. 1. Create a Reactive Transitive Query by implementing the following rule: rule \"go3\" when String( this == \"go3\" ) isContainedIn(\"key\", \"office\"; ) then System.out.println( \"Key in the Office\" ); end Reactive Transitive Queries can ask a question even if the answer can not be satisfied. Later, if it is satisfied, it will return an answer. 2. Use the same query for this reactive information. 3. Create the \"go3,\" insert it into the engine, and call the fireAllRules. The first rule that matches any String returns \"go3\" but nothing else is returned because there is no answer; however, while \"go3\" is inserted in the system, it will continuously wait until it is satisfied. 4. Insert a new location of \"key\" in the \"drawer\": ksession.insert( new Location(\"key\", \"drawer\") ); ksession.fireAllRules(); --- Key in the Office This new location satisfies the transitive closure because it is monitoring the entire graph. In addition, this process now has four recursive levels in which it goes through to match and fire the rule. 1. Create a Query with Unbound Arguments by implementing the following rule: rule \"go4\" when String( this == \"go4\" ) isContainedIn(thing, \"office\"; ) then System.out.println( \"thing\" + thing + \"is in the Office\" ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. 2. Use the query for the unbound arguments. 3. Create the \"go4,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go4\" ); ksession.fireAllRules(); --- go4 thing Key is in the Office thing Computer is in the Office thing Drawer is in the Office thing Desk is in the Office thing Chair is in the Office When \"go4\" is inserted, it returns all the previous information that is transitively below \"Office.\" 1. Create a query with Mulitple Unbound Arguments by implementing the following rule: rule \"go5\" when String( this == \"go5\" ) isContainedIn(thing, location; ) then System.out.println( \"thing\" + thing + \"is in\" + location ); end This rule is asking for everything in the \"office,\" and it will tell everything in all the rows below. The unbound argument (out variable thing) in this example will return every possible value; accordingly, it is very similar to the z value used in the Reactive Transitive Query example. Both thing and location are unbound out variables, and without bound arguments, everything is called upon. 2. Use the query for multiple unbound arguments. 3. Create the \"go5,\" insert it into the engine, and call the fireAllRules. ksession.insert( \"go5\" ); ksession.fireAllRules(); --- go5 thing Knife is in House thing Cheese is in House thing Key is in House thing Computer is in House thing Drawer is in House thing Desk is in House thing Chair is in House thing Key is in Office thing Computer is in Office thing Drawer is in Office thing Key is in Desk thing Office is in House thing Computer is in Desk thing Knife is in Kitchen thing Cheese is in Kitchen thing Kitchen is in House thing Key is in Drawer thing Drawer is in Desk thing Desk is in Office thing Chair is in Office When \"go5\" is called, it returns everything within everything."
    },
    {
        "link": "https://docs.drools.org/8.39.0.Final/drools-docs/docs-website/drools/language-reference/index.html",
        "document": "Drools Rule Language (DRL) is a notation established by the Drools open source business automation project for defining and describing business rules. You define DRL rules in text files. A DRL file can contain one or more rules that define at a minimum the rule conditions ( ) and actions ( ). DRL files consist of the following components: package unit import declare // Optional query // Optional rule \"rule name\" // Attributes when // Conditions then // Actions end rule \"rule2 name\" ... The following example DRL rule determines the age limit in a loan application decision service: rule \"Underage\" when /applicants[ applicantName : name, age < 21 ] $application : /loanApplications[ applicant == applicantName ] then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); update($application); end A DRL file can contain single or multiple rules and queries, and can define resource declarations and attributes that are assigned and used by your rules and queries. The components in a DRL file are grouped in a defined rule unit that serves as a unique namespace for each group of rules. The DRL package followed by the rule unit definition must be listed at the top of a DRL file, and the rules are typically listed last. All other DRL components can follow any order. Each rule must have a unique name within the rule unit. If you use the same rule name more than once in any DRL file in the unit, the rules fail to compile. Rule names generally must follow standard Java identifier conventions. However, you can enclose rule names with double quotation marks ( ) to prevent possible compilation errors, especially if you use spaces in rule names. In Drools 8, we promote a new DRL syntax based on rule unit, data source, and OOPath. Hence, you will see such a new syntax in DRL syntax examples. However, Drools 8 still fully supports traditional DRL syntax that has been used in version 7 and prior. Example rule for loan application with traditional syntax rule \"Underage\" when Applicant( applicantName : name, age < 21 ) $application : LoanApplication( applicant == applicantName ) then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); update($application); end A package is a folder of related assets in Drools, such as data objects, DRL files, decision tables, and other asset types. A package also serves as a unique namespace for each group of rules. A single rule base can contain multiple packages. You typically store all the rules for a package in the same file as the package declaration so that the package is self-contained. However, you can import objects from other packages that you want to use in the rules. The following example is a package name and namespace for a DRL file in a mortgage application decision service: The following railroad diagram shows all the components that may make up a package: Note that a package must have a namespace and be declared using standard Java conventions for package names; i.e., no spaces, unlike rule names which allow spaces. In terms of the order of elements, they can appear in any order in the rule file, with the exception of the and statements, which must be at the top of the file. In all cases, the semicolons are optional. Notice that any rule attribute (as described in the section Rule attributes in DRL) may also be written at package level, superseding the attribute’s default value. The modified default may still be replaced by an attribute setting within a rule. Rule Unit API is explained in Rule Unit API. This section focuses on how to use rule units in DRL. The following example is a rule unit designated in a DRL file in a mortgage application decision service: Example package definition and rule unit designation in a DRL file To define a rule unit, you need to write a Java class that implements as written in Rule Unit API. Alternatively, you can declare the rule unit by implementing the interface directly in DRL: package org.mortgages; unit MortgageRules; import org.drools.ruleunits.api.RuleUnitData; import org.drools.ruleunits.api.DataStream; declare Person name : String dateOfBirth : Date address : Address end declare MortgageRules extends RuleUnitData persons: DataStream<Person> end rule \"Using a rule unit with a declared type\" when $p : /persons[ name == \"James\" ] then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); persons.append( mark ); end To separate the fact types from the rule unit for use with other DRL rules, you can declare the types in a separate DRL file and then use the DRL rule file to declare the data sources by using the interface implementation: package org.mortgages; unit MortgageRules; import org.drools.ruleunits.api.RuleUnitData; import org.drools.ruleunits.api.DataStream; declare MortgageRules extends RuleUnitData persons: DataStream<Person> end rule \"Using a rule unit with a declared type\" when $p : /persons[ name == \"James\" ] then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); persons.append( mark ); end In this example, is a data source for facts of type . Data sources are typed sources of data that rule units can subscribe to for updates. You interact with the rule unit through the data sources it exposes. A data source can be a source for append-only storage, a source for writable storage to add or remove data, or a source for writable storage to set and clear a single element. As part of your data source declaration, you also import and the relevant data source support, such as in this example. You can add several rules to the same DRL file, or further break down the rule set and type declarations by creating more files. However you construct your rule sets, ensure that all DRL rule files exist in the same directory and start with the correct and declarations. As an additional rule unit use case, consider the following example decision service that evaluates incoming data from a heat sensor for temperature measurements and produces alerts when the temperature is above a specified threshold. This example service uses the following file in the folder of the Drools project to declare the and the fact types: To define DRL rules that pattern-match against values, the example service must expose an entry point for the incoming data to the Drools rule engine and publish alerts on a separate channel. To establish this data source for decision data, the example service uses a rule unit with data sources for objects and for objects. The data source is an append-only store for incoming data, similar to a queue. This type of data source is logical for both sources in this example because the temperature data is coming from an external source (the sensor) and the service publishes the alerts externally as they are produced. The example service uses the following file in the same folder of the Drools project to declare the data sources for the fact types and defines the rules for the rule unit: The rule unit implements the required interface and declares the data sources for the previously defined types. The sample rule raises an alert when the temperature reaches or exceeds 80 degrees. Similar to import statements in Java, imports in DRL files identify the fully qualified paths and type names for any objects that you want to use in the rules. You specify the package and data object in the format , with multiple imports on separate lines. The Drools rule engine automatically imports classes from the Java package with the same name as the DRL package and from the package . The following example is an import statement for a loan application object in a mortgage application decision service: Declarations in DRL files define new fact types or metadata for fact types to be used by rules in the DRL file:\n• New fact types: The default fact type in the package of Drools is , but you can declare other types in DRL files as needed. Declaring fact types in DRL files enables you to define a new fact model directly in the Drools rule engine, without creating models in a lower-level language like Java. You can also declare a new type when a domain model is already built and you want to complement this model with additional entities that are used mainly during the reasoning process.\n• Metadata for fact types: You can associate metadata in the format with new or existing facts. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the Drools rule engine and used in the reasoning process. A declaration of a new fact does not require any metadata, but must include a list of attributes or fields. If a type declaration does not include identifying attributes, the Drools rule engine searches for an existing fact class in the classpath and raises an error if the class is missing. For example, the following DRL file contains a declaration of a new fact type from a data source and uses no metadata: Example declaration of a new fact type with a rule declare Person name : String dateOfBirth : java.util.Date address : Address end rule \"Using a declared type\" when $p : /persons[ name == \"James\" ] then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); persons.append( mark ); end In this example, the new fact type has the three attributes , , and . Each attribute has a type that can be any valid Java type, including another class that you create or a fact type that you previously declared. The attribute has the type , from the Java API, and the attribute has the previously defined fact type . To avoid writing the fully qualified name of a class every time you declare it, you can define the full class name as part of the clause: Example type declaration with the fully qualified class name in the import When you declare a new fact type, the Drools rule engine generates at compile time a Java class representing the fact type. The generated Java class is a one-to-one JavaBeans mapping of the type definition. For example, the following Java class is generated from the example type declaration: public class Person implements Serializable { private String name; private java.util.Date dateOfBirth; private Address address; // Empty constructor public Person() {...} // Constructor with all fields public Person( String name, Date dateOfBirth, Address address ) {...} // If keys are defined, constructor with keys public Person( ...keys... ) {...} // Getters and setters // `equals` and `hashCode` // `toString` } You can then use the generated class in your rules like any other fact, as illustrated in the previous rule example with the type declaration from a data source: Example rule that uses the declared Person fact type rule \"Using a declared type\" when $p : /persons[ name == \"James\" ] then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); persons.append( mark ); end DRL supports the declaration of enumerative types in the format , followed by a comma-separated list of values ending with a semicolon. You can then use the enumerative list in the rules in the DRL file. For example, the following enumerative type declaration defines days of the week for an employee scheduling rule: declare enum DaysOfWeek SUN(\"Sunday\"),MON(\"Monday\"),TUE(\"Tuesday\"),WED(\"Wednesday\"),THU(\"Thursday\"),FRI(\"Friday\"),SAT(\"Saturday\"); fullName : String end rule \"Using a declared Enum\" when $emp : /employees[ dayOff == DaysOfWeek.MONDAY ] then ... end DRL supports type declaration inheritance in the format . To extend a type declared in Java by a subtype declared in DRL, you repeat the parent type in a declaration statement without any fields. For example, the following type declarations extend a type from a top-level type, and a type from the subtype: You can associate metadata in the format (the value is optional) with fact types or fact attributes. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the Drools rule engine and used in the reasoning process. Any metadata that you declare before the attributes of a fact type are assigned to the fact type, while metadata that you declare after an attribute are assigned to that particular attribute. In the following example, the two metadata attributes and are declared for the fact type, and the two metadata items (literal) and are declared for the attribute. The literal metadata attribute has no required value, so the parentheses and the value are omitted. Example metadata declaration for fact types and attributes For declarations of metadata attributes for existing types, you can identify the fully qualified class name as part of the clause for all declarations or as part of the individual clause: Example metadata declaration for an imported type Although you can define custom metadata attributes in DRL declarations, the Drools rule engine also supports the following predefined metadata tags for declarations of fact types or fact type attributes. The examples in this section that refer to the class assume that the sample application domain model includes the following class details: VoiceCall fact class in an example Telecom domain model This tag determines whether a given fact type is handled as a regular fact or an event in the Drools rule engine during complex event processing. This tag is automatically assigned to every event in the Drools rule engine. By default, the time is provided by the session clock and assigned to the event when it is inserted into the working memory of the Drools rule engine. You can specify a custom time stamp attribute instead of the default time stamp added by the session clock. Default parameter: The time added by the Drools rule engine session clock This tag determines the duration time for events in the Drools rule engine. Events can be interval-based events or point-in-time events. Interval-based events have a duration time and persist in the working memory of the Drools rule engine until their duration time has lapsed. Point-in-time events have no duration and are essentially interval-based events with a duration of zero. By default, every event in the Drools rule engine has a duration of zero. You can specify a custom duration attribute instead of the default. This tag determines the time duration before an event expires in the working memory of the Drools rule engine. By default, an event expires when the event can no longer match and activate any of the current rules. You can define an amount of time after which an event should expire. This tag definition also overrides the implicit expiration offset calculated from temporal constraints and sliding windows in the KIE base. This tag is available only when the Drools rule engine is running in stream mode. Default parameter: Null (event expires after event can no longer match and activate rules) This tab determines whether a given fact type is compiled with or without type safety. By default, all type declarations are compiled with type safety enabled. You can override this behavior to type-unsafe evaluation, where all constraints are generated as MVEL constraints and executed dynamically. This is useful when dealing with collections that do not have any generics or mixed type collections. This tag defines an identifying value for a serializable class in a fact declaration. If a serializable class does not explicitly declare a , the serialization run time calculates a default value for that class based on various aspects of the class, as described in the Java Object Serialization Specification. However, for optimal deserialization results and for greater compatibility with serialized KIE sessions, set the as needed in the relevant class or in your DRL declarations. This tag enables a fact type attribute to be used as a key identifier for the fact type. The generated class can then implement the and methods to determine if two instances of the type are equal to each other. The Drools rule engine can also generate a constructor using all the key attributes as parameters. For this example, the Drools rule engine checks the and attributes to determine if two instances of are equal to each other, but it does not check the attribute. The Drools rule engine also implicitly generates three constructors: one without parameters, one with the fields, and one with all fields: Example constructors from the key declarations You can then create instances of the type based on the key constructors, as shown in the following example: Example instance using the key constructor Queries in DRL files search the working memory of the Drools rule engine for facts related to the rules in the DRL file. You add the query definitions in DRL files and then obtain the matching results in your application code. Queries search for a set of defined conditions and do not require or specifications. Query names are scoped to the rule unit, so each query name must be unique within the same rule unit. In Drools, queries are automatically exposed as REST endpoints. The following example is a query definition for an object with a field set to : Drools automatically exposes this query through an endpoint . For this example, assume that the rule unit class has the following form: In this case, you can invoke the query using the following command: Example POST request to the endpoint This example submits the data to the data source and returns the result of the query as a response. Rule attributes are additional specifications that you can add to business rules to modify rule behavior. In DRL files, you typically define rule attributes above the rule conditions and actions, with multiple attributes on separate lines, in the following format: The following table lists the names and supported values of the attributes that you can assign to rules: An integer defining the priority of the rule. Rules with a higher salience value are given higher priority when ordered in the internalMatch queue. A Boolean value. When the option is selected, the rule is enabled. When the option is not selected, the rule is disabled. A string containing a date and time definition. The rule can be activated only if the current date and time is after a attribute. A string containing a date and time definition. The rule cannot be activated if the current date and time is after the attribute. A Boolean value. When the option is selected, the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition. When the condition is not selected, the rule can be looped in these circumstances. A string identifying an internalMatch (or XOR) group to which you want to assign the rule. In internalMatch groups, only one rule can be activated. The first rule to fire will cancel all pending internalMatches of all rules in the internalMatch group. A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met. A string identifying either (initialDelay interval) or timer definitions for scheduling the rule. Example: (every 5 minutes after a 30-second delay) A Boolean value, applicable only to rules within agenda groups. When the option is selected, the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned. A Boolean value, applicable only to rules within rule flow groups or agenda groups. When the option is selected, the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the attribute, because the internalMatch of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again. A string identifying either or as the language to be used for code expressions in the rule. By default, the rule uses the dialect specified at the package level. Any dialect specified here overrides the package dialect setting for the rule. Timers and calendars are DRL rule attributes that enable you to apply scheduling and timing constraints to your DRL rules. These attributes require additional configurations depending on the use case. The attribute in DRL rules is a string identifying either (interval) or timer definitions for scheduling a rule and supports the following formats: // Run after a 30-second delay timer ( int: 30s ) // Run every 5 minutes after a 30-second delay each time timer ( int: 30s 5m ) Interval timers follow the semantics of objects, with an initial delay and an optional repeat interval. Cron timers follow standard Unix cron expressions. The following example DRL rule uses a cron timer to send an SMS text message every 15 minutes: rule \"Send SMS message every 15 minutes\" timer ( cron:* 0/15 * * * ? ) when $a : Alarm( on == true ) then channels[ \"sms\" ].insert( new Sms( $a.mobileNumber, \"The alarm is still on.\" ); end Generally, a rule that is controlled by a timer becomes active when the rule is triggered and the rule consequence is executed repeatedly, according to the timer settings. The execution stops when the rule condition no longer matches incoming facts. However, the way the Drools rule engine handles rules with timers depends on whether the Drools rule engine is in active mode or in passive mode. By default, the Drools rule engine runs in passive mode and evaluates rules, according to the defined timer settings, when a user or an application explicitly calls . Conversely, if a user or application calls , the Drools rule engine starts in active mode and evaluates rules continually until the user or application explicitly calls . When the Drools rule engine is in active mode, rule consequences are executed even after control returns from a call to and the Drools rule engine remains reactive to any changes made to the working memory. For example, removing a fact that was involved in triggering the timer rule execution causes the repeated execution to terminate, and inserting a fact so that some rule matches causes that rule to be executed. However, the Drools rule engine is not continually active, but is active only after a rule is executed. Therefore, the Drools rule engine does not react to asynchronous fact insertions until the next execution of a timer-controlled rule. Disposing a KIE session terminates all timer activity. When the Drools rule engine is in passive mode, rule consequences of timed rules are evaluated only when is invoked again. However, you can change the default timer-execution behavior in passive mode by configuring the KIE session with a option, as shown in the following example: You can additionally set a specification on the option that enables you to define a callback to filter those rules, as shown in the following example: KIE session configuration to filter which timed rules are automatically executed For interval timers, you can also use an expression timer with instead of to define both the delay and interval as an expression instead of a fixed value. The following example DRL file declares a fact type with a delay and period that are then used in the subsequent rule with an expression timer: Example rule with an expression timer The expressions, such as and in this example, can use any variable defined in the pattern-matching part of the rule. The variable can be any value that can be parsed into a time duration or any numeric value that is internally converted in a value for a duration in milliseconds. Both interval and expression timers can use the following optional parameters:\n• and : A or a representing a or a value. The value can also be a that is transformed into a Java in the format .\n• : An integer that defines the maximum number of repetitions allowed by the timer. If both the and the parameters are set, the timer stops when the first of the two is reached. Example timer attribute with optional , , and parameters In this example, the rule is scheduled for every hour, after a delay of 30 seconds each hour, beginning on 3 January 2020 and ending either on 4 January 2020 or when the cycle repeats 50 times. If the system is paused (for example, the session is serialized and then later deserialized), the rule is scheduled only one time to recover from missing internalMatches regardless of how many internalMatches were missed during the pause, and then the rule is subsequently scheduled again to continue in sync with the timer setting. The attribute in DRL rules is a Quartz calendar definition for scheduling a rule and supports the following format: // Exclude non-business hours calendars \"* * 0-7,18-23 ? * *\" // Weekdays only, as registered in the KIE session calendars \"weekday\" You can adapt a Quartz calendar based on the Quartz calendar API and then register the calendar in the KIE session, as shown in the following example: Registering the calendar in the KIE session You can use calendars with standard rules and with rules that use timers. The calendar attribute can contain one or more comma-separated calendar names written as literals. The following example rules use both calendars and timers to schedule the rules: Example rules with calendars and timers rule \"Weekdays are high priority\" calendars \"weekday\" timer ( int:0 1h ) when Alarm() then send( \"priority high - we have an alarm\" ); end rule \"Weekends are low priority\" calendars \"weekend\" timer ( int:0 4h ) when Alarm() then send( \"priority low - we have an alarm\" ); end The part of a DRL rule (also known as the Left Hand Side (LHS) of the rule) contains the conditions that must be met to execute an action. Conditions consist of a series of stated OOPath expressions of patterns and constraints, with optional bindings and supported rule condition elements (keywords), based on the available data objects in the package. OOPath is an object-oriented syntax extension to XPath for navigating through related elements while handling collections and filtering constraints. For example, in a decision service that raises alerts when the temperature reaches or exceeds 80 degrees, a rule contains the condition . DRL uses instead of because is typically part of a procedural execution flow during which a condition is checked at a specific point in time. In contrast, indicates that the condition evaluation is not limited to a specific evaluation sequence or point in time, but instead occurs continually at any time. Whenever the condition is met, the actions are executed. If the section is empty, then the conditions are considered to be true and the actions in the section are executed the first time the rules are fired. This is useful if you want to use rules to set up the Drools rule engine state. The following example rule uses empty conditions to insert a fact every time the rule is executed: rule \"start-up\" when // Empty then // Actions to be executed once alerts.add( new Alert(\"INFO\", \"System started\") ); end Formally, the core grammar of an OOPath expression is defined in extended Backus-Naur form (EBNF) notation in the following way: An OOPath expression of a pattern in a DRL rule condition is the segment to be matched by the Drools rule engine. An OOPath expression can potentially match each fact that is inserted into the working memory of the Drools rule engine. It can also contain constraints to further define the facts to be matched. In the simplest form, with no constraints, an OOPath expression matches a fact in the given data source. In the following example with a named , the expression matches against all objects in the data source of the Drools rule engine: Patterns can also refer to superclasses or even interfaces, potentially matching facts from many different classes. For example, the following pattern matches all subtypes of the object: Square brackets in a pattern enclose the constraints, such as the following constraint on the person’s age: A constraint is an expression that returns or . Constraints in DRL are essentially Java expressions with some enhancements, such as property access, and some differences, such as and semantics for and (instead of the usual and semantics). Any JavaBeans property can be accessed directly from pattern constraints. A JavaBeans property is exposed internally using a standard JavaBeans getter that takes no arguments and returns something. For example, the property is written as in DRL instead of the getter : /persons[ age == 50 ] // This is equivalent to the following getter format: /persons[ getAge() == 50 ] Drools uses the standard JDK class to achieve this mapping and follows the standard JavaBeans specification. For optimal Drools rule engine performance, use the property access format, such as , instead of using getters explicitly, such as . Do not use property accessors to change the state of the object in a way that might affect the rules because the Drools rule engine caches the results of the match between invocations for higher efficiency. For example, do not use property accessors in the following ways: public int getAge() { age++; // Do not do this. return age; } public int getAge() { Date now = DateUtil.now(); // Do not do this. return DateUtil.differenceInYears(now, birthday); } Instead of following the second example, insert a fact that wraps the current date in the working memory and update that fact between rule executions as needed. However, if the getter of a property cannot be found, the compiler uses the property name as a fallback method name, without arguments: Fallback method if object is not found /persons[ age == 50 ] // If `Person.getAge()` does not exist, the compiler uses the following syntax: /persons[ age() == 50 ] You can also nest access properties in patterns, as shown in the following example. Nested properties are indexed by the Drools rule engine. /persons[ address.houseNumber == 50 ] // This is equivalent to the following expression: /persons[ getAddress().getHouseNumber() == 50 ] You can use any Java expression that returns a value as a constraint inside the parentheses of a pattern. Java expressions can be mixed with other expression enhancements, such as property access: Example pattern with a constraint using property access and Java expression You can change the evaluation priority by using parentheses, as in any logical or mathematical expression: You can also reuse Java methods in constraints, as shown in the following example: Do not use constraints to change the state of the object in a way that might affect the rules because the Drools rule engine caches the results of the match between invocations for higher efficiency. Any method that is executed on a fact in the rule conditions must be a read-only method. Also, the state of a fact should not change between rule invocations unless those facts are marked as updated in the working memory on every change. For example, do not use a pattern constraint in the following ways: /persons[ incrementAndGetAge() == 10 ] // Do not do this. /persons[ System.currentTimeMillis() % 1000 == 0 ] // Do not do this. Standard Java operator precedence applies to constraint operators in DRL, and DRL operators follow standard Java semantics except for the and operators. The operator uses null-safe semantics instead of the usual semantics. For example, the pattern is similar to , and because is not null, the pattern is also similar to . The operator uses null-safe semantics instead of the usual semantics. For example, the pattern is similar to . If the field and the value of a constraint are of different types, the Drools rule engine uses type coercion to resolve the conflict and reduce compilation errors. For instance, if is provided as a string in a numeric evaluator, a compilation error occurs, whereas is coerced to a numeric 10. In coercion, the field type always takes precedence over the value type: Example constraint with a value that is coerced For groups of constraints, you can use a delimiting comma to use implicit connective semantics: // Person is at least 50 years old and weighs at least 80 kilograms: /persons[ age > 50, weight > 80 ] // Person is at least 50 years old, weighs at least 80 kilograms, and is taller than 2 meters: /persons[ age > 50, weight > 80, height > 2 ] Although the and operators have the same semantics, they are resolved with different priorities. The operator precedes the operator, and both the and operators together precede the operator. Use the comma operator at the top-level constraint for optimal Drools rule engine performance and human readability. You cannot embed a comma operator in a composite constraint expression, such as in parentheses: Example of misused comma in composite constraint expression // Do not use the following format: /persons[ ( age > 50, weight > 80 ) || height > 2 ] // Use the following format instead: /persons[ ( age > 50 && weight > 80 ) || height > 2 ] You can bind variables to OOPath expressions of patterns and constraints to refer to matched objects in other portions of a rule. Bound variables can help you define rules more efficiently or more consistently with how you annotate facts in your data model. For example, the following DRL rule uses the variable for an OOPath expression with the fact: Similarly, you can also bind variables to nested properties, as shown in the following example: // Two persons of the same age: /persons[ firstAge : age ] // Binding and /persons[ age == firstAge ] // Constraint expression Ensure that you separate constraint bindings and constraint expressions for clearer and more efficient rule definitions. Although mixed bindings and expressions are supported, they can complicate patterns and affect evaluation efficiency. // Do not use the following format: /persons[ age : age * 2 < 100 ] // Use the following format instead: /persons[ age * 2 < 100, $age : age ] In some cases, you might need to access multiple properties of a nested object, as shown in the following example: You can group these property accessors to nested objects for more readable rules, as shown in the following example: When you work with nested objects, you can use the syntax to cast to a subtype and make the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes, as shown in the following examples: Example patterns with inline casting to a subtype // Inline casting with subtype name: /persons[ name == \"mark\"]/address#LongAddress[ country == \"uk\" ] // Inline casting with fully qualified class name: /persons[ name == \"mark\"]/address#org.domain.LongAddress[ country == \"uk\" ] // Multiple inline casts: /persons[ name == \"mark\" ]/address#LongAddress/country#DetailedCountry[ population > 10000000 ] These example patterns cast to , and additionally to in the last example, making the parent getters available to the subtypes in each case. By default, the Drools rule engine supports the date format . You can customize the date format, including a time format mask if needed, by providing an alternative format mask with the system property . You can also customize the date format by changing the language locale with the and system properties. For example, the locale of Thailand is set as and . Drools attempts to preserve numbers in their primitive or object wrapper form, so a variable bound to an int primitive when used in a code block or expression will no longer need manual unboxing; unlike early Drools versions where all primitives were autoboxed, requiring manual unboxing. A variable bound to an object wrapper will remain as an object; the existing JDK 1.5 and JDK 5 rules to handle auto-boxing and unboxing apply in this case. When evaluating field constraints, the system attempts to coerce one of the values into a comparable format; so a primitive is comparable to an object wrapper. DRL supports standard Java semantics for operators in constraints, with some exceptions and with some additional operators that are unique in DRL. The following list summarizes the operators that are handled differently in DRL constraints than in standard Java semantics or that are unique in DRL constraints. Use the operator to group property accessors to nested objects, and use the operator to cast to a subtype in nested objects. Casting to a subtype makes the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes. Example constraints with inline casting to a subtype // Inline casting with subtype name: /persons[ name == \"mark\", address#LongAddress.country == \"uk\" ] // Inline casting with fully qualified class name: /persons[ name == \"mark\", address#org.domain.LongAddress.country == \"uk\" ] // Multiple inline casts: /persons[ name == \"mark\", address#LongAddress.country#DetailedCountry.population > 10000000 ] Use this operator to dereference a property in a null-safe way. The value to the left of the operator must be not null (interpreted as ) in order to give a positive result for pattern matching. /persons[ $streetName : address!.street ] // This is internally rewritten in the following way: /persons[ address != null, $streetName : address.street ] Use this operator to access a value by index or a value by key. Example constraints with and access // The following format is the same as `childList(0).getAge() == 18`: /persons[childList[0].age == 18] // The following format is the same as `credentialMap.get(\"jdoe\").isValid()`: /persons[credentialMap[\"jdoe\"].valid] Use these operators on properties with natural ordering. For example, for fields, the operator means before, and for fields, the operator means alphabetically before. These properties apply only to comparable properties. Use these operators as and methods in constraints, instead of the usual and semantics. /persons[ firstName == \"John\" ] // This is similar to the following formats: java.util.Objects.equals(person.getFirstName(), \"John\") \"John\".equals(person.getFirstName()) Example constraint with null-safe not equality /persons[ firstName != \"John\" ] // This is similar to the following format: !java.util.Objects.equals(person.getFirstName(), \"John\") Use these operators to create an abbreviated combined relation condition that adds more than one restriction on a field. You can group constraints with parentheses to create a recursive syntax pattern. // Simple abbreviated combined relation condition using a single `&&`: /persons[age > 30 && < 40] // Complex abbreviated combined relation using groupings: /persons[age ((> 30 && < 40) || (> 20 && < 25))] // Mixing abbreviated combined relation with constraint connectives: /persons[age > 30 && < 40 || location == \"london\"] Use these operators to indicate that a field matches or does not match a specified Java regular expression. Typically, the regular expression is a literal, but variables that resolve to a valid regular expression are also supported. These operators apply only to properties. If you use against a value, the resulting evaluation is always . If you use against a value, the resulting evaluation is always . As in Java, regular expressions that you write as literals must use a double backslash to escape. Example constraint to match or not match a regular expression Use these operators to verify whether a field that is an or a contains or does not contain a specified value. These operators apply to or properties, but you can also use these operators in place of and constraints checks. Example constraints with and for a Collection // Collection with a specified field: /familyTree[ countries contains \"UK\" ] /familyTree[ countries not contains \"UK\" ] // Collection with a variable: /familyTree[ countries contains $var ] /familyTree[ countries not contains $var ] Example constraints with and for a String literal // Sting literal with a specified field: /persons[ fullName contains \"Jr\" ] /persons[ fullName not contains \"Jr\" ] // String literal with a variable: /persons[ fullName contains $var ] /persons[ fullName not contains $var ] For backward compatibility, the operator is a supported synonym for . Use these operators to verify whether a field is a member of or is not a member of an or a that is defined as a variable. The or must be a variable. Example constraints with and with a Collection Use this operator to verify whether a word has almost the same sound, using English pronunciation, as the given value (similar to the operator). This operator uses the Soundex algorithm. Use this operator to verify whether a field that is a starts with or ends with a specified value. You can also use this operator to verify the length of the . // Verify what the String starts with: /messages[ routingValue str[startsWith] \"R1\" ] // Verify what the String ends with: /messages[ routingValue str[endsWith] \"R2\" ] // Verify the length of the String: /messages[ routingValue str[length] 17 ] Use these operators to specify more than one possible value to match in a constraint (compound value restriction). This functionality of compound value restriction is supported only in the and operators. The second operand of these operators must be a comma-separated list of values enclosed in parentheses. You can provide values as variables, literals, return values, or qualified identifiers. These operators are internally rewritten as a list of multiple restrictions using the operators or . Example constraints with and DRL supports standard Java operator precedence for applicable constraint operators, with some exceptions and with some additional operators that are unique in DRL. The following table lists DRL operator precedence where applicable, from highest to lowest precedence: Uses and semantics, not standard Java and semantics DRL supports the following rule condition elements (keywords) that you can use with the patterns that you define in DRL rule conditions: Use this to group conditional components into a logical conjunction. Infix and prefix are supported. You can group patterns explicitly with parentheses . By default, all listed patterns are combined with when no conjunction is specified. //Infix `and`: colorType: /colors/type and /persons[ favoriteColor == colorType ] //Infix `and` with grouping: (colorType: /colors/type and (/persons[ favoriteColor == colorType ] or /persons[ favoriteColor == colorType ]) // Prefix `and`: (and colorType: /colors/type /persons[ favoriteColor == colorType ]) // Default implicit `and`: colorType: /colors/type /persons[ favoriteColor == colorType ] Do not use a leading declaration binding with the keyword (as you can with , for example). A declaration can only reference a single fact at a time, and if you use a declaration binding with , then when is satisfied, it matches both facts and results in an error. // Causes compile error: $person : (/persons[ name == \"Romeo\" ] and /persons[ name == \"Juliet\"]) Use this to group conditional components into a logical disjunction. Infix and prefix are supported. You can group patterns explicitly with parentheses . You can also use pattern binding with , but each pattern must be bound separately. //Infix `or`: colorType: /colors/type or /persons[ favoriteColor == colorType] //Infix `or` with grouping: colorType: /colors/type or (/persons[ favoriteColor == colorType] and /persons[ favoriteColor == colorType]) // Prefix `or`: (or colorType: /colors/type /persons[ favoriteColor == colorType]) Example patterns with and pattern binding The behavior of the condition element is different from the connective operator for constraints and restrictions in field constraints. The Drools rule engine does not directly interpret the element but uses logical transformations to rewrite a rule with as a number of sub-rules. This process ultimately results in a rule that has a single as the root node and one sub-rule for each of its condition elements. Each sub-rule is activated and executed like any normal rule, with no special behavior or interaction between the sub-rules. Therefore, consider the condition element a shortcut for generating two or more similar rules that, in turn, can create multiple internalMatches when two or more terms of the disjunction are true. Use this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches. If you use this element with multiple patterns, enclose the patterns with parentheses . Use this to specify facts and constraints that must not exist. If you use this element with multiple patterns, enclose the patterns with parentheses . not /persons[ firstName == \"John\"] not (/persons[ firstName == \"John\", age == 42 )] not (/persons[ firstName == \"John\" ] and /persons[ lastName == \"Doe\" ]) Use this to verify whether all facts that match the first pattern match all the remaining patterns. When a construct is satisfied, the rule evaluates to . This element is a scope delimiter, so it can use any previously bound variable, but no variable bound inside of it is available for use outside of it. rule \"All full-time employees have red ID badges\" when forall( $emp : /employees[ type == \"fulltime\" ] /employees[ this == $emp, badgeColor = \"red\" ] ) then // True, all full-time employees have red ID badges. end In this example, the rule selects all objects whose type is . For each fact that matches this pattern, the rule evaluates the patterns that follow (badge color) and if they match, the rule evaluates to . To state that all facts of a given type in the working memory of the Drools rule engine must match a set of constraints, you can use with a single pattern for simplicity. Example rule with and a single pattern rule \"All full-time employees have red ID badges\" when forall( /employees[ badgeColor = \"red\" ] ) then // True, all full-time employees have red ID badges. end You can use constructs with multiple patterns or nest them with other condition elements, such as inside a element construct. Example rule with and multiple patterns rule \"All employees have health and dental care programs\" when forall( $emp : /employees /healthCare[ employee == $emp ] /dentalCare[ employee == $emp ] ) then // True, all employees have health and dental care. end Example rule with and rule \"Not all employees have health and dental care\" when not ( forall( $emp : /employees /healthCare[ employee == $emp ] /dentalCare[ employee == $emp ] ) ) then // True, not all employees have health and dental care. end The format is equivalent to not( p1 and not( and p2 p3 …​ ) ) . Use this to iterate over a collection of objects, execute custom actions for each of the elements, and return one or more result objects (if the constraints evaluate to ). You can use predefined functions in your conditions or implement custom functions as needed. You can also use the abbreviation for in rule conditions. Use the following format to define conditions in rules: Although the Drools rule engine supports alternate formats for the element for backward compatibility, this format is preferred for optimal performance in rules and applications. The Drools rule engine supports the following predefined functions. These functions accept any expression as input. In the following example rule, , , and are functions that calculate the minimum, maximum, and average temperature values over all the readings for each sensor: Example rule with to calculate temperature values rule \"Raise alarm\" when s : /sensors accumulate( /readings( sensor == $s, $temp : temperature ); $min : min( $temp ), $max : max( $temp ), $avg : average( $temp ); $min < 20, $avg > 70 ) then // Raise the alarm. end The following example rule uses the function with to calculate the average profit for all items in an order: Example rule with to calculate average profit rule \"Average profit\" when $order : /orders accumulate( /orderItems( order == $order, $cost : cost, $price : price ); $avgProfit : average( 1 - $cost / $price ) ) then // Average profit for `$order` is `$avgProfit`. end Built-in accumulate functions' return types may vary depend on parameter types. and can take parameters even if they are not numeric types, for example, . In this case, the return type would be , so you may need to cast the bind variable of the return value in the rule. To use custom, domain-specific functions in conditions, create a Java class that implements the interface. For example, the following Java class defines a custom implementation of an function: Example Java class with custom implementation of function // An implementation of an accumulator capable of calculating average values public class AverageAccumulateFunction implements org.kie.api.runtime.rule.AccumulateFunction<AverageAccumulateFunction.AverageData> { public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { } public void writeExternal(ObjectOutput out) throws IOException { } public static class AverageData implements Externalizable { public int count = 0; public double total = 0; public AverageData() {} public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { count = in.readInt(); total = in.readDouble(); } public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(count); out.writeDouble(total); } } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#createContext() */ public AverageData createContext() { return new AverageData(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#init(java.io.Serializable) */ public void init(AverageData context) { context.count = 0; context.total = 0; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#accumulate(java.io.Serializable, java.lang.Object) */ public void accumulate(AverageData context, Object value) { context.count++; context.total += ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#reverse(java.io.Serializable, java.lang.Object) */ public void reverse(AverageData context, Object value) { context.count--; context.total -= ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResult(java.io.Serializable) */ public Object getResult(AverageData context) { return new Double( context.count == 0 ? 0 : context.total / context.count ); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#supportsReverse() */ public boolean supportsReverse() { return true; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResultType() */ public Class< ? > getResultType() { return Number.class; } } To use the custom function in a DRL rule, import the function using the statement: Example rule with the imported function import accumulate AverageAccumulateFunction.AverageData average rule \"Average profit\" when $order : /orders accumulate( /orderItems[ order == $order, $cost : cost, $price : price ]; $avgProfit : average( 1 - $cost / $price ) ) then // Average profit for `$order` is `$avgProfit`. end For backward compatibility, the Drools rule engine also supports the configuration of functions through configuration files and system properties, but this is a deprecated method. To configure the function from the previous example using the configuration file or system property, set a property as shown in the following example: Note that is a required prefix, is how the function is used in the DRL files, and is the fully qualified name of the class that implements the function behavior. The part of the rule (also known as the Right Hand Side (RHS) of the rule) contains the actions to be performed when the conditional part of the rule has been met. Rule actions are typically determined by one or more data sources that you define as part of your DRL rule unit. For example, if a bank requires loan applicants to have over 21 years of age (with a rule condition ) and a loan applicant is under 21 years old, the action of an rule would be based on a defined data source, declining the loan because the applicant is under age. The main purpose of rule actions is to to insert, delete, or modify data in the working memory of the Drools rule engine. Effective rule actions are small, declarative, and readable. If you need to use imperative or conditional code in rule actions, then divide the rule into multiple smaller and more declarative rules. rule \"Underage\" when /applicants[ applicantName : name, age < 21 ] $application : /loanApplications[ applicant == applicantName ] then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); end For more information about using data sources for rule actions, see Rule units in DRL.\n\nIn addition to the standard rule action methods, the Drools rule engine supports methods in conjunction with the predefined variable that you can also use in rule actions. You can use the variable to call methods from the class in your Drools distribution, which is also the class that the standard rule action methods are based on. For all rule action options, see the Drools RuleContext.java page in GitHub. The variable contains methods that provide information about the firing rule and the set of facts that activated the firing rule:\n• : Returns the name of the currently firing rule.\n• : Returns the that activated the currently firing rule. It contains information that is useful for logging and debugging purposes, for instance returns the list of objects, enabling rule to fire in the proper tuple order. From the variable, you can also obtain a reference to the providing useful methods to interact with the running session, for example:\n• : Terminates rule execution if a user or application previously called . When a user or application calls method, the Drools rule engine starts in mode and evaluates rules until the user or application explicitly calls method. Otherwise, by default, the Drools rule engine runs in mode and evaluates rules only when a user or an application explicitly calls method.\n• : Returns a reference to the KIE session , and in turn provides access to rule internalMatch groups, rule agenda groups, and ruleflow groups. Example call to access agenda group \"CleanUp\" and set the focus + This example sets the focus to a specified agenda group to which the rule belongs.\n• : Returns the runtime , similar to your operating system environment. When you use rule units, is not available, because rule units use lightweight sessions. DRL supports single-line comments prefixed with a double forward slash and multi-line comments enclosed with a forward slash and asterisk . You can use DRL comments to annotate rules or any related components in DRL files. DRL comments are ignored by the Drools rule engine when the DRL file is processed. rule \"Underage\" // This is a single-line comment. when /applicants[ applicantName : name, age < 21 ] // This is an in-line comment $application : /loanApplications[ applicant == applicantName ] then /* This is a multi-line comment in the rule actions. */ $application.setApproved( false ); $application.setExplanation( \"Underage\" ); end The hash symbol is not supported for DRL comments. Drools provides standardized messages for DRL errors to help you troubleshoot and resolve problems in your DRL files. The error messages use the following format:\n• 2nd Block: Line and column in the DRL source where the error occurred\n• 4th Block: Component in the DRL source (rule, function, query) where the error occurred\n• 5th Block: Pattern in the DRL source where the error occurred (if applicable) Indicates that the parser reached a decision point but could not identify an alternative. 1: rule \"simple rule\" 2: when 3: exists /persons 4: exits /students // Must be `exists` 5: then 6: end [ERR 101] Line 4:4 no viable alternative at input 'exits' in rule \"simple rule\" Example rule without a rule name 1: package org.drools.examples; 2: rule // Must be `rule \"rule name\"` (or `rule rule_name` if no spacing) 3: when 4: Object() 5: then 6: System.out.println(\"A RHS\"); 7: end [ERR 101] Line 3:2 no viable alternative at input 'when' In this example, the parser encountered the keyword but expected the rule name, so it flags as the incorrect expected token. 1: rule \"simple rule\" 2: when 3: /students[ name == \"Andy ] // Must be `\"Andy\"` 4: then 5: end [ERR 101] Line 0:-1 no viable alternative at input '<eof>' in rule \"simple rule\" in pattern student A line and column value of means the parser reached the end of the source file ( ) but encountered incomplete constructs, usually due to missing quotation marks , apostrophes , or parentheses . Indicates that the parser expected a particular symbol that is missing at the current input position. Example rule with an incomplete rule statement 1: rule \"simple rule\" 2: when 3: $p : /persons[ // Must be a complete rule statement A line and column value of means the parser reached the end of the source file ( ) but encountered incomplete constructs, usually due to missing quotation marks , apostrophes , or parentheses . 1: package org.drools.examples; 2: 3: rule \"Wrong syntax\" 4: when 5: not /cars[ ( type == \"tesla\", price == 10000 ) || ( type == \"kia\", price == 1000 ) ] // Must use `&&` operators instead of commas `,` 6: then 7: System.out.println(\"OK\"); 8: end [ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule \"Wrong syntax\" in pattern car [ERR 101] Line 5:57 no viable alternative at input 'type' in rule \"Wrong syntax\" [ERR 102] Line 5:106 mismatched input ']' expecting 'then' in rule \"Wrong syntax\" In this example, the syntactic problem results in multiple error messages related to each other. The single solution of replacing the commas with operators resolves all errors. If you encounter multiple errors, resolve one at a time in case errors are consequences of previous errors. Indicates that a validating semantic predicate evaluated to . These semantic predicates are typically used to identify component keywords in DRL files, such as , , , , and others. Example rule with an invalid keyword 1: package nesting; 2: 3: import org.drools.compiler.Person 4: import org.drools.compiler.Address 5: 6: Some text // Must be a valid DRL keyword 7: 8: rule \"test something\" 9: when 10: $p: /persons[ name==\"Michael\" ] 11: then 12: $p.name = \"other\"; 13: System.out.println(p.name); 14: end The line is invalid because it does not begin with or is not a part of a DRL keyword construct, so the parser fails to validate the rest of the DRL file. This error is similar to , but usually involves DRL keywords. 105: did not match anything Indicates that the parser reached a sub-rule in the grammar that must match an alternative at least once, but the sub-rule did not match anything. The parser has entered a branch with no way out. Example rule with invalid text in an empty condition 1: rule \"empty condition\" 2: when 3: None // Must remove `None` if condition is empty 4: then 5: insert( new Person() ); 6: end [ERR 105] Line 2:2 required (...)+ loop did not match anything at input 'WHEN' in rule \"empty condition\" In this example, the condition is intended to be empty but the word is used. This error is resolved by removing , which is not a valid DRL keyword, data type, or pattern construct. The following Drools Rule Language (DRL) conventions are no longer applicable or optimal in Drools but might be available for backward compatibility. Functions in DRL files put semantic code in your rule source file instead of in Java classes. Functions are especially useful if an action ( ) part of a rule is used repeatedly and only the parameters differ for each rule. Above the rules in the DRL file, you can declare the function or import a static method from a helper class as a function, and then use the function by name in an action ( ) part of the rule. The following examples illustrate a function that is either declared or an imported static method in a DRL file: function String hello(String applicantName) { return \"Hello \" + applicantName + \"!\"; } rule \"Using a function\" when // Empty then System.out.println( hello( \"James\" ) ); end import static org.example.applicant.MyFunctions.hello; rule \"Using a function\" when // Empty then System.out.println( hello( \"James\" ) ); end A function declared in a DRL file cannot be imported to a rule in a different package while a Java static method in a different package can be imported. From the RHS of a rule, you can always pass a global as a function parameter when invoking the function, for exmaple: global List names; rule \"Using a function with parameters\" when // Empty then addName( names, \"James\" ); end function void addName(List names, String applicantName) { names.add(applicantName); } The following attributes were used in earlier versions of the Drools rule engine to provide grouping of rules across a rule base. These attributes are superseded by DRL rule units and are only available for backward compatibility reasons. If you need to group your rules, use DRL rule units as a clearer and simpler grouping method. A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated. A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow. In Drools, the preferred syntax for DRL rule conditions is through OOPath expressions. For legacy use cases, you can write rules using traditional pattern matching. In this case, you must explicitly indicate the data source using the clause, as shown in the following comparative examples: package org.acme unit PersonRules; import org.acme.Person; rule isAdult when $person: Person(age > 18) from person then modify($person) { setAdult(true) }; end Using OOPath, you can write nested paths. For example, . The first path is translated into a normal pattern matching, but all other paths after that first one are rendered with a clause that has performance inefficiency. Hence, you have to be careful about using nested paths the same as too much use of . The following rule condition elements (keywords) are obsolete in Drools: Use this to specify a data source for a pattern. This enables the Drools rule engine to reason over data that is not in the working memory. The data source can be a sub-field on a bound variable or the result of a method call. The expression used to define the object source is any expression that follows regular MVEL syntax. Therefore, the element enables you to easily use object property navigation, execute method calls, and access maps and collection elements. Example rule with and pattern binding rule \"Validate zipcode\" when Person( $personAddress : address ) Address( zipcode == \"23920W\" ) from $personAddress then // Zip code is okay. end Example rule with and a graph notation rule \"Validate zipcode\" when $p : Person() $a : Address( zipcode == \"23920W\" ) from $p.address then // Zip code is okay. end Example rule with to iterate over all objects rule \"Apply 10% discount to all items over US$ 100 in an order\" when $order : Order() $item : OrderItem( value > 100 ) from $order.items then // Apply discount to `$item`. end For large collections of objects, instead of adding an object with a large graph that the Drools rule engine must iterate over frequently, add the collection directly to the KIE session and then join the collection in the condition, as shown in the following example: Example rule with and rule attribute rule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $p : Person() $a : Address( state == \"NC\" ) from $p.address then modify ($p) {} // Assign the person to sales region 1. end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $p : Person() $a : Address( city == \"Raleigh\" ) from $p.address then modify ($p) {} // Apply discount to the person. end Using with rule attribute can result in rules not being executed. You can address this issue in one of the following ways:\n• Avoid using the element when you can insert all facts into the working memory of the Drools rule engine or use nested object references in your constraint expressions.\n• Place the variable used in the block as the last sentence in your rule condition.\n• Avoid using the rule attribute when you can explicitly manage how rules within the same ruleflow group place internalMatches on one another. The pattern that contains a clause cannot be followed by another pattern starting with a parenthesis. The reason for this restriction is that the DRL parser reads the expression as and it cannot differentiate this expression from a function call. The simplest workaround to this is to wrap the clause in parentheses, as shown in the following example: Example rules with used incorrectly and correctly // Do not use `from` in this way: rule R when $l : List() String() from $l (String() or Number()) then // Actions end // Use `from` in this way instead: rule R when $l : List() (String() from $l) (String() or Number()) then // Actions end Use this to define an entry point, or event stream, corresponding to a data source for the pattern. This element is typically used with the condition element. You can declare an entry point for events so that the Drools rule engine uses data from only that entry point to evaluate the rules. You can declare an entry point either implicitly by referencing it in DRL rules or explicitly in your Java application. rule \"Authorize withdrawal\" when WithdrawRequest( $ai : accountId, $am : amount ) from entry-point \"ATM Stream\" CheckingAccount( accountId == $ai, balance > $am ) then // Authorize withdrawal. end Use this to define a collection of objects that the rule can use as part of the condition. The rule obtains the collection either from a specified source or from the working memory of the Drools rule engine. The result pattern of the element can be any concrete class that implements the interface and provides a default no-arg public constructor. You can use Java collections like , , and , or your own class. If variables are bound before the element in a condition, you can use the variables to constrain both your source and result patterns. However, any binding made inside the element is not available for use outside of it. import java.util.List rule \"Raise priority when system has more than three pending alarms\" when $system : System() $alarms : List( size >= 3 ) from collect( Alarm( system == $system, status == 'pending' ) ) then // Raise priority because `$system` has three or more `$alarms` pending. end In this example, the rule assesses all pending alarms in the working memory of the Drools rule engine for each given system and groups them in a . If three or more alarms are found for a given system, the rule is executed. You can also use the element with nested elements, as shown in the following example: Example rule with and nested import java.util.LinkedList; rule \"Send a message to all parents\" when $town : Town( name == 'Paris' ) $mothers : LinkedList() from collect( Person( children > 0 ) from $town.getPeople() ) then // Send a message to all parents. end The accumulate syntax evolved over time with the goal of becoming more compact and expressive. Nevertheless, Drools still supports previous syntaxes for backward compatibility purposes. In case the rule is using a single accumulate function on a given accumulate, the author may add a pattern for the result object and use the \"from\" keyword to link it to the accumulate result. Example: a rule to apply a 10% discount on orders over $100 could be written in the following way: rule \"Apply 10% discount to orders over US$ 100,00\" when $order : /orders $total : Number( doubleValue > 100 ) from accumulate( OrderItem( order == $order, $value : value ), sum( $value ) ) then // apply discount to $order end In the above example, the accumulate element is using only one function (sum), and so, the rules author opted to explicitly write a pattern for the result type of the accumulate function (Number) and write the constraints inside it. There are no problems in using this syntax over the compact syntax presented before, except that is is a bit more verbose. Also note that it is not allowed to use both the return type and the functions binding in the same accumulate statement. Compile-time checks are performed in order to ensure the pattern used with the \" \" keyword is assignable from the result of the accumulate function used. With this syntax, the \" \" binds to the single result returned by the accumulate function, and it does not iterate. In the above example, \" \" is bound to the result returned by the accumulate sum() function. As another example however, if the result of the accumulate function is a collection, \" \" still binds to the single result and it does not iterate: rule \"Person names\" when $x : Object() from accumulate(MyPerson( $val : name ); collectList( $val ) ) then // $x is a List end The bound \" \" is the List itself, returned by the collectList accumulate function used. This is an important distinction to highlight, as the \" \" keyword can also be used separately of accumulate, to iterate over the elements of a collection: rule \"Iterate the numbers\" when $xs : List() $x : Integer() from $xs then // $x matches and binds to each Integer in the collection end While this syntax is still supported for backward compatibility purposes, for this and other reasons we encourage rule authors to make use instead of the preferred syntax (described previously), to avoid any potential pitfalls. Another possible syntax for the is to define inline custom code, instead of using accumulate functions. The use of accumulate with inline custom code is not a good practice for several reasons, including difficulties on maintaining and testing rules that use them, as well as the inability of reusing that code. Implementing your own accumulate functions is very simple and straightforward, they are easy to unit test and to use. This form of accumulate is supported for backward compatibility only. Only limited support for inline accumulate is provided while using the executable model. For example, you cannot use an external binding in the code while using the MVEL dialect: The general syntax of the CE with inline custom code is: The meaning of each of the elements is the following:\n• SOURCE_PATTERN: the source pattern is a regular pattern that the Drools rule engine will try to match against each of the source objects.\n• INIT_CODE: this is a semantic block of code in the selected dialect that will be executed once for each tuple, before iterating over the source objects.\n• ACTION_CODE: this is a semantic block of code in the selected dialect that will be executed for each of the source objects.\n• REVERSE_CODE: this is an optional semantic block of code in the selected dialect that if present will be executed for each source object that no longer matches the source pattern. The objective of this code block is to undo any calculation done in the ACTION_CODE block, so that the Drools rule engine can do decremental calculation when a source object is modified or deleted, hugely improving performance of these operations.\n• RESULT_EXPRESSION: this is a semantic expression in the selected dialect that is executed after all source objects are iterated.\n• RESULT_PATTERN: this is a regular pattern that the Drools rule engine tries to match against the object returned from the RESULT_EXPRESSION. If it matches, the conditional element evaluates to true and the Drools rule engine proceeds with the evaluation of the next CE in the rule. If it does not matches, the CE evaluates to false and the Drools rule engine stops evaluating CEs for that rule. It is easier to understand if we look at an example: rule \"Apply 10% discount to orders over US$ 100,00\" when $order : Order() $total : Number( doubleValue > 100 ) from accumulate( OrderItem( order == $order, $value : value ), init( double total = 0; ), action( total += $value; ), reverse( total -= $value; ), result( total ) ) then // apply discount to $order end In the above example, for each in the Working Memory, the Drools rule engine will execute the INIT_CODE initializing the total variable to zero. Then it will iterate over all objects for that order, executing the action for each one (in the example, it will sum the value of all items into the total variable). After iterating over all objects, it will return the value corresponding to the result expression (in the above example, the value of variable ). Finally, the Drools rule engine will try to match the result with the pattern, and if the double value is greater than 100, the rule will fire. The example used Java as the semantic dialect, and as such, note that the usage of the semicolon as statement delimiter is mandatory in the init, action and reverse code blocks. The result is an expression and, as such, it does not admit ';'. If the user uses any other dialect, he must comply to that dialect’s specific syntax. As mentioned before, the REVERSE_CODE is optional, but it is strongly recommended that the user writes it in order to benefit from the improved performance on update and delete. The CE can be used to execute any action on source objects. The following example instantiates and populates a custom object: rule \"Accumulate using custom objects\" when $person : Person( $likes : likes ) $cheesery : Cheesery( totalAmount > 100 ) from accumulate( $cheese : Cheese( type == $likes ), init( Cheesery cheesery = new Cheesery(); ), action( cheesery.addCheese( $cheese ); ), reverse( cheesery.removeCheese( $cheese ); ), result( cheesery ) ); then // do something end You can create and manage DRL rules for your Drools project in your integrated development environment (IDE). For Drools service, VSCode is the preferred IDE. In each DRL rule file, you define rule conditions, actions, and other components related to the rule, based on the data objects you create or import in the package. In Drools, you typically define DRL rules in rule units. A DRL rule unit is a module for rules and a unit of execution. A rule unit collects a set of rules with the declaration of the type of facts that the rules act on. A rule unit also serves as a unique namespace for each group of rules. A single rule base can contain multiple rule units. You typically store all the rules for a unit in the same file as the unit declaration so that the unit is self-contained. For this procedure, create the following example DRL type declarations and DRL rule unit to define DRL rules in a decision service for a loan application: package org.mortgages; unit MortgageRules; import org.drools.ruleunits.api.RuleUnitData; import org.drools.ruleunits.api.DataStore; declare MortgageRules extends RuleUnitData bankruptcies: DataStore<Bankruptcy> applicants: DataStore<Applicant> loanApplications: DataStore<LoanApplication> end rule \"Bankruptcy history\" salience 10 when $a : /loanApplications[ applicantName: applicant ] exists (/bankruptcies[ name == applicantName, yearOfOccurrence > 1990 || amountOwed > 100000 ]) then $a.setApproved( false ); $a.setExplanation( \"has been bankrupt\" ); loanApplications.remove( $a ); end rule \"Underage\" salience 15 when /applicants[ applicantName : name, age < 21 ] $application : /loanApplications[ applicant == applicantName ] then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); loanApplications.remove( $a ); end\n• You have created a Drools project and have included any Java data objects required for your Drools service.\n• In your VSCode IDE, open your Drools project and create a folder. This folder serves as the package for your DRL files in this example.\n• In your new folder, add the following file to define the fact types for the loan application service: This DRL file defines the fact types that you can declare in any rule units in the same package for the decision service. Declarations in DRL files define new fact types or metadata for fact types to be used by rules in a DRL files. If you declare these types directly in the DRL rule unit file, you cannot declare them in any other rule units. This example defines the following fact types:\n• : Provides data for bankruptcy status, if applicable\n• : Provides data about the loan applicant\n• : Provides data about loan approval status for a specified applicant, with an explanation if needed\n• In the same folder of your Drools project, create the following file to declare the DRL rule unit and data sources: Example DRL file with rule unit and data sources In this example, the rule unit is named and the previously defined fact types are declared as data sources. Data sources are typed sources of data that rule units can subscribe to for updates. You interact with the rule unit through the data sources it exposes. A data source can be a source for append-only storage, a source for writable storage to add or remove data, or a source for writable storage to set and clear a single element. This example uses the data source to enable application data to be added or removed as part of the decision service.\n• To complete the DRL rule unit file, add the following rules for and logic: package org.mortgages; unit MortgageRules; import org.drools.ruleunits.api.RuleUnitData; import org.drools.ruleunits.api.DataStore; declare MortgageRules extends RuleUnitData bankruptcies: DataStore<Bankruptcy> applicants: DataStore<Applicant> loanApplications: DataStore<LoanApplication> end rule \"Bankruptcy history\" salience 10 when $a : /loanApplications[ applicantName: applicant ] exists (/bankruptcies[ name == applicantName, yearOfOccurrence > 1990 || amountOwed > 100000 ]) then $a.setApproved( false ); $a.setExplanation( \"has been bankrupt\" ); loanApplications.remove( $a ); end rule \"Underage\" salience 15 when /applicants[ applicantName : name, age < 21 ] $application : /loanApplications[ applicant == applicantName ] then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); loanApplications.remove( $a ); end The example rules consist of the following rule components:\n• : Use this segment to define each rule in the DRL file. Rules consist of a rule name in the format , followed by optional attributes that define rule behavior, such as or , followed by and definitions. Each rule must have a unique name within the rule package. In this example, the rule has a defined salience of and the rule has a defined salience of . These values ensure that the rule is executed first.\n• and : Use the portion to define the condition patterns and constraints in OOPath syntax and use the portion to define the actions to be executed when the conditions are met. In this example, the rule states that if an applicant has owed more than 100,000 USD of unresolved debt since 1990 (beginning 1991), then the applicant is considered to have been bankrupt and is not approved for a loan. The application is removed from memory. If the applicant passes the bankruptcy check, then the rule states that if the applicant is younger than 21 years old, then the applicant is not approved for the loan. The application is removed from memory. If the applicant passes both checks, then the loan is approved.\n• After you define all components of the data sources and rules, save all DRL files. The following key concepts or suggested practices can help you optimize DRL rules and Drools rule engine performance. These concepts are summarized in this section as a convenience and are explained in more detail in the cross-referenced documentation, where applicable. This section will expand or change as needed with new releases of Drools. Define the property and value of pattern constraints from left to right In DRL pattern constraints, ensure that the fact property name is on the left side of the operator and that the value (constant or a variable) is on the right side. The property name must always be the key in the index and not the value. For example, write instead of . Defining the constraint property and value from right to left can hinder Drools rule engine performance. For more information about DRL patterns and constraints, see Rule conditions in DRL. Use equality operators more than other operator types in pattern constraints when possible Although the Drools rule engine supports many DRL operator types that you can use to define your business rule logic, the equality operator is evaluated most efficiently by the Drools rule engine. Whenever practical, use this operator instead of other operator types. For example, the pattern is evaluated more efficiently than . In some cases, using only equality operators might be impractical, so consider all of your business logic needs and options as you use DRL operators. List the most restrictive rule conditions first For rules with multiple conditions, list the conditions from most to least restrictive so that the Drools rule engine can avoid assessing the entire set of conditions if the more restrictive conditions are not met. For example, the following conditions are part of a travel-booking rule that applies a discount to travelers who book both a flight and a hotel together. In this scenario, customers rarely book hotels with flights to receive this discount, so the hotel condition is rarely met and the rule is rarely executed. Therefore, the first condition ordering is more efficient because it prevents the Drools rule engine from evaluating the flight condition frequently and unnecessarily when the hotel condition is not met. For more information about DRL patterns and constraints, see Rule conditions in DRL. Avoid iterating over large collections of objects with excessive clauses Avoid using the condition element in DRL rules to iterate over large collections of objects, as shown in the following example: when $c: Company() $e : Employee ( salary > 100000.00) from $c.employees In such cases, the Drools rule engine iterates over the large graph every time the rule condition is evaluated and impedes rule evaluation. Alternatively, instead of adding an object with a large graph that the Drools rule engine must iterate over frequently, add the collection directly to the KIE session and then join the collection in the condition, as shown in the following example: when $c: Company(); Employee (salary > 100000.00, company == $c) In this example, the Drools rule engine iterates over the list only one time and can evaluate rules more efficiently. For more information about the element or other DRL condition elements, see Rule conditions in DRL. Use Drools rule engine event listeners instead of statements in rules for debug logging You can use statements in your rule actions for debug logging and console output, but doing this for many rules can impede rule evaluation. As a more efficient alternative, use the built-in Drools rule engine event listeners when possible. If these listeners do not meet your requirements, use a system logging utility supported by the Drools rule engine, such as Logback, Apache Commons Logging, or Apache Log4j. For more information about supported Drools rule engine event listeners and logging utilities, see Drools rule engine event listeners and debug logging. Use the module to identify the obstruction in your rules You can use the module to identify slow rules especially when you process many rules. The module can also assist in analyzing the Drools rule engine performance. Note that the module is not for production environment use. However, you can perform the analysis in your test environment. To analyze the Drools rule engine performance using , first add to your project dependencies: If you want to use to enable trace logging, configure a logger for as shown in the following example: Alternatively, you can use to expose the data using Micrometer. To expose the data, enable the Micrometer registry of your choice as shown in the following example: Regardless of whether you want to use logging or Micrometer, you need to enable by setting the system property to . Optionally, you can change the microseconds threshold of metric reporting by setting the system property. Only node executions exceeding the threshold are reported. The default value is . After configuring the to use logging, rule execution produces logs as shown in the following example: This example includes the following key parameters:\n• is the number of constraint evaluations against inserted facts during the node execution. When is used with Micrometer, a counter with the data is called .\n• is the elapsed time of the node execution in microseconds. When is used with Micrometer, look for a timer called . If you find an outstanding or log, correlate the node name with output to identify the rule associated with the node.\n\nDomain Specific Languages (or DSLs) are a way of creating a rule language that is dedicated to your problem domain. A set of DSL definitions consists of transformations from DSL \"sentences\" to DRL constructs, which lets you use of all the underlying rule language and engine features. Given a DSL, you write rules in DSL rule (or DSLR) files, which will be translated into DRL files. DSL and DSLR files are plain text files, and you can use any text editor to create and modify them. But there are also DSL and DSLR editors, both in the IDE as well as in the web based BRMS, and you can use those as well, although they may not provide you with the full DSL functionality. When to Use a DSL DSLs can serve as a layer of separation between rule authoring (and rule authors) and the technical intricacies resulting from the modelling of domain object and the Drools rule engine’s native language and methods. If your rules need to be read and validated by domain experts (such as business analysts, for instance) who are not programmers, you should consider using a DSL; it hides implementation details and focuses on the rule logic proper. DSL sentences can also act as \"templates\" for conditional elements and consequence actions that are used repeatedly in your rules, possibly with minor variations. You may define DSL sentences as being mapped to these repeated phrases, with parameters providing a means for accommodating those variations. DSLs have no impact on the Drools rule engine at runtime, they are just a compile time feature, requiring a special parser and transformer. The Drools DSL mechanism allows you to customise conditional expressions and consequence actions. A global substitution mechanism (\"keyword\") is also available. In the preceding example, indicates the scope of the expression, i.e., whether it is valid for the LHS or the RHS of a rule. The part after the bracketed keyword is the expression that you use in the rule; typically a natural language expression, but it doesn’t have to be. The part to the right of the equal sign (\"=\") is the mapping of the expression into the rule language. The form of this string depends on its destination, RHS or LHS. If it is for the LHS, then it ought to be a term according to the regular LHS syntax; if it is for the RHS then it might be a Java statement. Whenever the DSL parser matches a line from the rule file written in the DSL with an expression in the DSL definition, it performs three steps of string manipulation. First, it extracts the string values appearing where the expression contains variable names in braces (here: ). Then, the values obtained from these captures are then interpolated wherever that name, again enclosed in braces, occurs on the right hand side of the mapping. Finally, the interpolated string replaces whatever was matched by the entire expression in the line of the DSL rule file. Note that the expressions (i.e., the strings on the left hand side of the equal sign) are used as regular expressions in a pattern matching operation against a line of the DSL rule file, matching all or part of a line. This means you can use (for instance) a '?' to indicate that the preceding character is optional. One good reason to use this is to overcome variations in natural language phrases of your DSL. But, given that these expressions are regular expression patterns, this also means that all \"magic\" characters of Java’s pattern syntax have to be escaped with a preceding backslash ('\\'). It is important to note that the compiler transforms DSL rule files line by line. In the previous example, all the text after \"Something is \" to the end of the line is captured as the replacement value for \"{colour}\", and this is used for interpolating the target string. This may not be exactly what you want. For instance, when you intend to merge different DSL expressions to generate a composite DRL pattern, you need to transform a DSLR line in several independent operations. The best way to achieve this is to ensure that the captures are surrounded by characteristic text - words or even single characters. As a result, the matching operation done by the parser plucks out a substring from somewhere within the line. In the example below, quotes are used as distinctive characters. Note that the characters that surround the capture are not included during interpolation, just the contents between them. As a rule of thumb, use quotes for textual data that a rule editor may want to enter. You can also enclose the capture with words to ensure that the text is correctly matched. Both is illustrated by the following example. Note that a single line such as Something is \"green\" and another solid thing is now correctly expanded. Example 2. Example with quotes It is a good idea to avoid punctuation (other than quotes or apostrophes) in your DSL expressions as much as possible. The main reason is that punctuation is easy to forget for rule authors using your DSL. Another reason is that parentheses, the period and the question mark are magic characters, requiring escaping in the DSL definition. In a DSL mapping, the braces \"{\" and \"}\" should only be used to enclose a variable definition or reference, resulting in a capture. If they should occur literally, either in the expression or within the replacement text on the right hand side, they must be escaped with a preceding backslash (\"\\\"): If braces \"{\" and \"}\" should appear in the replacement string of a DSL definition, escape them with a backslash ('\\'). # This is a comment to be ignored. [when]There is a person with name of \"{name}\"=Person(name==\"{name}\") [when]Person is at least {age} years old and lives in \"{location}\"= Person(age >= {age}, location==\"{location}\") [then]Log \"{message}\"=System.out.println(\"{message}\"); [when]And = and Given the above DSL examples, the following examples show the expansion of various DSLR snippets: There is a person with name of \"Kitty\" ==> Person(name=\"Kitty\") Person is at least 42 years old and lives in \"Atlanta\" ==> Person(age >= 42, location=\"Atlanta\") Log \"boo\" ==> System.out.println(\"boo\"); There is a person with name of \"Bob\" And Person is at least 30 years old and lives in \"Utah\" ==> Person(name=\"Bob\") and Person(age >= 30, location=\"Utah\") Don’t forget that if you are capturing plain text from a DSL rule line and want to use it as a string literal in the expansion, you must provide the quotes on the right hand side of the mapping. You can chain DSL expressions together on one line, as long as it is clear to the parser where one ends and the next one begins and where the text representing a parameter ends. (Otherwise you risk getting all the text until the end of the line as a parameter value.) The DSL expressions are tried, one after the other, according to their order in the DSL definition file. After any match, all remaining DSL expressions are investigated, too. The resulting DRL text may consist of more than one line. Line ends are in the replacement text are written as . A common requirement when writing rule conditions is to be able to add an arbitrary combination of constraints to a pattern. Given that a fact type may have many fields, having to provide an individual DSL statement for each combination would be plain folly. The DSL facility allows you to add constraints to a pattern by a simple convention: if your DSL expression starts with a hyphen (minus character, \"-\") it is assumed to be a field constraint and, consequently, is is added to the last pattern line preceding it. For an example, lets take look at class , with the following fields: type, price, age and country. We can express some LHS condition in normal DRL like the following The DSL definitions given below result in three DSL phrases which may be used to create any combination of constraint involving these fields. [when]There is a Cheese with=Cheese() [when]- age is less than {age}=age<{age} [when]- type is '{type}'=type=='{type}' [when]- country equal to '{country}'=country=='{country}' You can then write rules with conditions like the following: There is a Cheese with - age is less than 42 - type is 'stilton' The parser will pick up a line beginning with \"-\" and add it as a constraint to the preceding pattern, inserting a comma when it is required. For the preceding example, the resulting DRL is: Combining all numeric fields with all relational operators (according to the DSL expression \"age is less than…​\" in the preceding example) produces an unwieldy amount of DSL entries. But you can define DSL phrases for the various operators and even a generic expression that handles any field constraint, as shown below. (Notice that the expression definition contains a regular expression in addition to the variable name.) [when][]is less than or equal to=<= [when][]is less than=< [when][]is greater than or equal to=>= [when][]is greater than=> [when][]is equal to=== [when][]equals=== [when][]There is a Cheese with=Cheese() [when][]- {field:\\w*} {operator} {value:\\d*}={field} {operator} {value} Given these DSL definitions, you can write rules with conditions such as: There is a Cheese with - age is less than 42 - rating is greater than 50 - type equals 'stilton' In this specific case, a phrase such as \"is less than\" is replaced by , and then the line matches the last DSL entry. This removes the hyphen, but the final result is still added as a constraint to the preceding pattern. After processing all of the lines, the resulting DRL text is: The order of the entries in the DSL is important if separate DSL expressions are intended to match the same line, one after the other. A good way to get started is to write representative samples of the rules your application requires, and to test them as you develop. This will provide you with a stable framework of conditional elements and their constraints. Rules, both in DRL and in DSLR, refer to entities according to the data model representing the application data that should be subject to the reasoning process defined in rules. Notice that writing rules is generally easier if most of the data model’s types are facts. Given an initial set of rules, it should be possible to identify recurring or similar code snippets and to mark variable parts as parameters. This provides reliable leads as to what might be a handy DSL entry. Also, make sure you have a full grasp of the jargon the domain experts are using, and base your DSL phrases on this vocabulary. You may postpone implementation decisions concerning conditions and actions during this first design phase by leaving certain conditional elements and actions in their DRL form by prefixing a line with a greater sign (\">\"). (This is also handy for inserting debugging statements.) During the next development phase, you should find that the DSL configuration stabilizes pretty quickly. New rules can be written by reusing the existing DSL definitions, or by adding a parameter to an existing condition or consequence entry. Try to keep the number of DSL entries small. Using parameters lets you apply the same DSL sentence for similar rule patterns or constraints. But do not exaggerate: authors using the DSL should still be able to identify DSL phrases by some fixed text. A DSL file is a text file in a line-oriented format. Its entries are used for transforming a DSLR file into a file according to DRL syntax.\n• A line starting with \"#\" or \"//\" (with or without preceding white space) is treated as a comment. A comment line starting with \"#/\" is scanned for words requesting a debug option, see below.\n• Any line starting with an opening bracket (\"[\") is assumed to be the first line of a DSL entry definition.\n• Any other line is appended to the preceding DSL entry definition, with the line end replaced by a space. A DSL entry consists of the following four parts:\n• A scope definition, written as one of the keywords \"when\" or \"condition\", \"then\" or \"consequence\", \"*\" and \"keyword\", enclosed in brackets (\"[\" and \"]\"). This indicates whether the DSL entry is valid for the condition or the consequence of a rule, or both. A scope indication of \"keyword\" means that the entry has global significance, i.e., it is recognized anywhere in a DSLR file.\n• A type definition, written as a Java class name, enclosed in brackets. This part is optional unless the next part begins with an opening bracket. An empty pair of brackets is valid, too.\n• A DSL expression consists of a (Java) regular expression, with any number of embedded variable definitions, terminated by an equal sign (\"=\"). A variable definition is enclosed in braces (\"{\" and \"}\"). It consists of a variable name and two optional attachments, separated by colons (\":\"). If there is one attachment, it is a regular expression for matching text that is to be assigned to the variable; if there are two attachments, the first one is a hint for the GUI editor and the second one the regular expression. Note that all characters that are \"magic\" in regular expressions must be escaped with a preceding backslash (\"\\\") if they should occur literally within the expression.\n• The remaining part of the line after the delimiting equal sign is the replacement text for any DSLR text matching the regular expression. It may contain variable references, i.e., a variable name enclosed in braces. Optionally, the variable name may be followed by an exclamation mark (\"!\") and a transformation function, see below. Note that braces (\"{\" and \"}\") must be escaped with a preceding backslash (\"\\\") if they should occur literally within the replacement string. Debugging of DSL expansion can be turned on, selectively, by using a comment line starting with \"#/\" which may contain one or more words from the table presented below. The resulting output is written to standard output. Prints each expansion step of condition and consequence lines. Dumps the internal representation of all DSL entries with scope \"keyword\". Dumps the internal representation of all DSL entries with scope \"when\" or \"*\". Dumps the internal representation of all DSL entries with scope \"then\" or \"*\". Below are some sample DSL definitions, with comments describing the language features they illustrate. # Comment: DSL examples #/ debug: display result and usage # keyword definition: replaces \"regula\" by \"rule\" [keyword][]regula=rule # conditional element: \"T\" or \"t\", \"a\" or \"an\", convert matched word [when][][Tt]here is an? {entity:\\w+}= ${entity!lc}: {entity!ucfirst} () # consequence statement: convert matched word, literal braces [then][]update {entity:\\w+}=modify( ${entity!lc} )\\{ \\} The transformation of a DSLR file proceeds as follows:\n• The text is read into memory.\n• Each of the \"keyword\" entries is applied to the entire text. First, the regular expression from the keyword definition is modified by replacing white space sequences with a pattern matching any number of white space characters, and by replacing variable definitions with a capture made from the regular expression provided with the definition, or with the default (\".*?\"). Then, the DSLR text is searched exhaustively for occurrences of strings matching the modified regular expression. Substrings of a matching string corresponding to variable captures are extracted and replace variable references in the corresponding replacement text, and this text replaces the matching string in the DSLR text.\n• Sections of the DSLR text between \"when\" and \"then\", and \"then\" and \"end\", respectively, are located and processed in a uniform manner, line by line, as described below. For a line, each DSL entry pertaining to the line’s section is taken in turn, in the order it appears in the DSL file. Its regular expression part is modified: white space is replaced by a pattern matching any number of white space characters; variable definitions with a regular expression are replaced by a capture with this regular expression, its default being \".*?\". If the resulting regular expression matches all or part of the line, the matched part is replaced by the suitably modified replacement text. Modification of the replacement text is done by replacing variable references with the text corresponding to the regular expression capture. This text may be modified according to the string transformation function given in the variable reference; see below for details. If there is a variable reference naming a variable that is not defined in the same entry, the expander substitutes a value bound to a variable of that name, provided it was defined in one of the preceding lines of the current rule.\n• If a DSLR line in a condition is written with a leading hyphen, the expanded result is inserted into the last line, which should contain a pattern CE, i.e., a type name followed by a pair of parentheses. if this pair is empty, the expanded line (which should contain a valid constraint) is simply inserted, otherwise a comma (\",\") is inserted beforehand. If a DSLR line in a consequence is written with a leading hyphen, the expanded result is inserted into the last line, which should contain a \"modify\" statement, ending in a pair of braces (\"{\" and \"}\"). If this pair is empty, the expanded line (which should contain a valid method call) is simply inserted, otherwise a comma (\",\") is inserted beforehand. It is currently not possible to use a line with a leading hyphen to insert text into other conditional element forms (e.g., \"accumulate\") or it may only work for the first insertion (e.g., \"eval\"). All string transformation functions are described in the following table. Converts the first letter to upper case, and all other letters to lower case. Extracts all digits and \"-\" from the string. If the last two digits in the original string are preceded by \".\" or \",\", a decimal period is inserted in the corresponding position. Compares the string with string a, and if they are equal, replaces it with b, otherwise with c. But c can be another triplet a, b, c, so that the entire structure is, in fact, a translation table. The following DSL examples show how to use string transformation functions. # definitions for conditions [when][]There is an? {entity}=${entity!lc}: {entity!ucfirst}() [when][]- with an? {attr} greater than {amount}={attr} <= {amount!num} [when][]- with a {what} {attr}={attr} {what!positive?>0/negative?%lt;0/zero?==0/ERROR} A file containing a DSL definition has to be put under the resources folder or any of its subfolders like any other drools artifact. It must have the extension , or alternatively be marked with type . when programmatically added to a . For a file using DSL definition, the extension should be used, while it can be added to a with type . For parsing and expanding a DSLR file the DSL configuration is read and supplied to the parser. Thus, the parser can \"recognize\" the DSL expressions and transform them into native rule language expressions.\n\nSpreadsheet decision tables are XLS or XLSX spreadsheets that contain business rules defined in a tabular format. Each row in a decision table is a rule, and each column is a condition, an action, or another rule attribute. After you create and upload your spreadsheet decision tables, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets. All data objects related to a spreadsheet decision table must be in the same project package as the spreadsheet decision table. Assets in the same package are imported by default. Existing assets in other packages can be imported with the decision table. An online shopping site lists the shipping charges for ordered items. The site provides free shipping under the following conditions:\n• The number of items ordered is 4 or more and the checkout total is $300 or more.\n• Standard shipping is selected (4 or 5 business days from the date of purchase). The following are the shipping rates under these conditions: Table 6. For orders less than $300 Table 7. For orders more than $300 These conditions and rates are shown in the following example spreadsheet decision table: In order for a decision table to be executed in Drools rule engine, the table must comply with certain structure and syntax requirements, within an XLS or XLSX spreadsheet, as shown in this example. For more information, see Defining spreadsheet decision tables. Spreadsheet decision tables (XLS or XLSX) require two key areas that define rule data: a area and a area. The area of the spreadsheet defines elements that you want to apply globally to all rules in the same package (not only the spreadsheet), such as a rule set name or universal rule attributes. The area defines the actual rules (rows) and the conditions, actions, and other rule attributes (columns) that constitute that rule table within the specified rule set. A spreadsheet of decision tables can contain multiple areas, but only one area. Starting with Drools v8, file extension must end in either , , or as mentioned in the Release Notes. You should typically write only one spreadsheet of decision tables, containing all necessary definitions, per rule package. You can write separate decision table spreadsheets for separate packages, but writing multiple spreadsheets in the same package can cause compilation errors from conflicting or attributes and is therefore not recommended. Refer to the following sample spreadsheet as you define your decision table:\n• In a new XLS or XLSX spreadsheet, go to the second or third column and label a cell (row 1 in example). Reserve the column or columns to the left for descriptive metadata (optional).\n• In the next cell to the right, enter a name for the . This named rule set will contain all rules defined in the rule package.\n• Under the cell, define any rule attributes (one per cell) that you want to apply globally to all rule tables in the package. Specify attribute values in the cells to the right. For example, you can enter an label and in the cell to the right, specify relevant data objects from other packages that you want to import into the package for the decision table (in the format ). For supported cell labels and values, see RuleSet definitions.\n• Below the area and in the same column as the cell, skip a row and label a new cell (row 7 in example) and enter a table name in the same cell. The name is used as the initial part of the name for all rules derived from this rule table, with the row number appended for distinction. You can override this automatic naming by inserting a attribute column.\n• Use the next four rows to define the following elements as needed (rows 8-11 in example):\n• Rule attributes: Conditions, actions, or other attributes. For supported cell labels and values, see RuleTable definitions.\n• Object types: The data objects to which the rule attributes apply. If the same object type applies to multiple columns, merge the object cells into one cell across multiple columns (as shown in the sample decision table), instead of repeating the object type in multiple cells. When an object type is merged, all columns below the merged range will be combined into one set of constraints within a single pattern for matching a single fact at a time. When an object is repeated in separate columns, the separate columns can create different patterns, potentially matching different or identical facts.\n• Column label: (Optional) Any descriptive label for the column, as a visual aid. Leave blank if unused. As an alternative to populating both the object type and constraint cells, you can leave the object type cell or cells empty and enter the full expression in the corresponding constraint cell or cells. For example, instead of as the object type and as a constraint (separate cells), you can leave the object type cell empty and enter in the constraint cell, and then do the same for other constraint cells.\n• After you have defined all necessary rule attributes (columns), enter values for each column as needed, row by row, to generate rules (rows 12-17 in example). Cells with no data are ignored (such as when a condition or action does not apply). If you need to add more rule tables to this decision table spreadsheet, skip a row after the last rule in the previous table, label another cell in the same column as the previous and cells, and create the new table following the same steps in this section (rows 19-29 in example).\n• Save your XLS or XLSX spreadsheet to finish. By default, only the first worksheet in a spreadsheet workbook is processed as a decision table. Each name combined with the name must be unique across all decision table files in the same package. If you want to process multiple worksheet decision tables, then create a file with the same name as the spreadsheet workbook. The file must contain a property sheet with comma-separated values (CSV) for the names of the worksheets, for example: After Drools rule engine loads the decision table, the rules are internally rendered as DRL rules like the following example, from the sample spreadsheet: //row 12 rule \"Basic_12\" salience 10 when $order : Order( itemsCount > 0, itemsCount <= 3, deliverInDays == 1 ) then insert( new Charge( 35 ) ); end By default, any white space before or after values in decision table cells is removed before the decision table is processed by the Drools rule engine. To retain white space that you use intentionally before or after values in cells, set the system property to in your Drools application. Entries in the area of a decision table define DRL constructs and rule attributes that you want to apply to all rules in a package (not only in the spreadsheet). Entries must be in a vertically stacked sequence of cell pairs, where the first cell contains a label and the cell to the right contains the value. A decision table spreadsheet can have only one area. The following table lists the supported labels and values for definitions: The package name for the generated DRL file. Optional, the default is . or . If , then salience is used to ensure that rules fire from the top down. Optional, at most once. If omitted, no firing order is imposed. Optional, at most once. In sequential mode, this option is used to set the start value of the salience. If omitted, the default value is 65535. Optional, at most once. In sequential mode, this option is used to check if this minimum salience value is not violated. If omitted, the default value is 0. or . If , then quotation marks are escaped so that they appear literally in the DRL. Optional, at most once. If omitted, quotation marks are escaped. or . If , then a String representation is used for DRL instead of a double value from a Numeric cell. It would also skip additional numeric processing for the double value. For example, date formatting based on Drools system property. Optional, at most once. If omitted, a double value is used. or . If , then the format for numeric values is ignored, for example, percent and currency. Optional, at most once. If omitted, DRL takes formatted values. A comma-separated list of Java classes to import from another package. Optional, may be used repeatedly. Declarations of DRL globals (a type followed by a variable name). Multiple global definitions must be separated by commas. Optional, may be used repeatedly. One or more function definitions, according to DRL syntax. Optional, may be used repeatedly. One or more query definitions, according to DRL syntax. Optional, may be used repeatedly. One or more declarative types, according to DRL syntax. Optional, may be used repeatedly. The rule units that the rules generated from this decision table belong to. Optional, at most once. If omitted, the rules do not belong to any unit. or . The dialect used in the actions of the decision table. Optional, at most once. If omitted, is imposed. In some cases, Microsoft Office, LibreOffice, and OpenOffice might encode a double quotation mark differently, causing a compilation error. For example, will fail, but will pass. Entries in the area of a decision table define conditions, actions, and other rule attributes for the rules in that rule table. A spreadsheet of decision tables can contain multiple areas. The following table lists the supported labels (column headers) and values for definitions. For column headers, you can use either the given labels or any custom labels that begin with the letters listed in the table. Or custom label that begins with Provides the name for the rule generated from that row. The default is constructed from the text following the tag and the row number. Results in a comment within the generated rule. Code snippet and interpolated values for constructing a constraint within a pattern in a condition. At least one per rule table. Code snippet and interpolated values for constructing an action for the consequence of the rule. At least one per rule table. Code snippet and interpolated values for constructing a metadata entry for the rule. The following sections provide more details about how condition, action, and metadata columns use cell data: For columns headed , the cells in consecutive lines result in a conditional element:\n• First cell: Text in the first cell below develops into a pattern for the rule condition, and uses the snippet in the next line as a constraint. If the cell is merged with one or more neighboring cells, a single pattern with multiple constraints is formed. All constraints are combined into a parenthesized list and appended to the text in this cell. If this cell is empty, the code snippet in the cell below it must result in a valid conditional element on its own. For example, instead of as the object type and as a constraint (separate cells), you can leave the object type cell empty and enter in the constraint cell, and then do the same for any other constraint cells. To include a pattern without constraints, you can write the pattern in front of the text of another pattern, with or without an empty pair of parentheses. You can also append a clause to the pattern. If the pattern ends with , code snippets produce boolean expressions for inclusion into a pair of parentheses after . You can terminate the pattern with annotation, which is used to customize the properties that the pattern is reactive on.\n• Second cell: Text in the second cell below is processed as a constraint on the object reference in the first cell. The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using with the value from the cells below, then the field selector alone is sufficient. If you use the field selector alone, but you want to use the condition as it is without appending any comparison, you must terminate the condition with the symbol . Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol . Multiple insertions are possible if you use the symbols , , and so on, and a comma-separated list of values in the cells below. However, do not separate , , and so on, by commas, or the table will fail to process. To expand a text according to the pattern , repeat the once for each of the values of the comma-separated list in each of the cells below, insert the value in place of the symbol , and join these expansions by the given . Note that the construct may be surrounded by other text. If the first cell contains an object, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the first cell is empty, the code snippet in this cell must result in a valid conditional element on its own. For example, instead of as the object type and as a constraint (separate cells), you can leave the object type cell empty and enter in the constraint cell, and then do the same for any other constraint cells.\n• Third cell: Text in the third cell below is a descriptive label that you define for the column, as a visual aid.\n• Fourth cell: From the fourth row on, non-blank entries provide data for interpolation. A blank cell omits the condition or constraint for this rule. For columns headed , the cells in consecutive lines result in an action statement:\n• First cell: Text in the first cell below is optional. If present, the text is interpreted as an object reference.\n• Second cell: Text in the second cell below is a code snippet that is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol . Multiple insertions are possible if you use the symbols , , and so on, and a comma-separated list of values in the cells below. However, do not separate , , and so on, by commas, or the table will fail to process. A text without any marker symbols can execute a method call without interpolation. In this case, use any non-blank entry in a row below the cell to include the statement. The construct is supported. If the first cell contains an object, then the cell text (followed by a period), the text in the second cell, and a terminating semicolon are strung together, resulting in a method call that is added as an action statement for the consequence. If the first cell is empty, the code snippet in this cell must result in a valid action element on its own.\n• Third cell: Text in the third cell below is a descriptive label that you define for the column, as a visual aid.\n• Fourth cell: From the fourth row on, non-blank entries provide data for interpolation. A blank cell omits the condition or constraint for this rule. For columns headed , the cells in consecutive lines result in a metadata annotation for the generated rules:\n• First cell: Text in the first cell below is ignored.\n• Second cell: Text in the second cell below is subject to interpolation, using values from the cells in the rule rows. The metadata marker character is prefixed automatically, so you do not need to include that character in the text for this cell.\n• Third cell: Text in the third cell below is a descriptive label that you define for the column, as a visual aid.\n• Fourth cell: From the fourth row on, non-blank entries provide data for interpolation. A blank cell results in the omission of the metadata annotation for this rule. The and areas also support labels and values for other rule attributes, such as or . Rule attributes specified in a area will affect all rule assets in the same package (not only in the spreadsheet). Rule attributes specified in a area will affect only the rules in that rule table. You can use each rule attribute only once in a area and once in a area. If the same attribute is used in both and areas within the spreadsheet, then takes priority and the attribute in the area is overridden. The following table lists the supported labels (column headers) and values for additional or definitions. For column headers, you can use either the given labels or any custom labels that begin with the letters listed in the table. Or custom label that begins with An integer defining the value of the rule. Rules with a higher salience value are given higher priority when ordered in the internalMatch queue. Overridden by the flag. A string containing a date and time definition. The rule can be activated only if the current date and time is after a attribute. A string containing a date and time definition. The rule cannot be activated if the current date and time is after the attribute. A Boolean value. When this option is set to , the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition. A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated. A string identifying an internalMatch (or XOR) group to which you want to assign the rule. In internalMatch groups, only one rule can be activated. The first rule to fire will cancel all pending internalMatches of all rules in the internalMatch group. A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met. A string identifying either (interval) or timer definitions for scheduling the rule. A Boolean value, applicable only to rules within agenda groups. When this option is set to , the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned. A Boolean value, applicable only to rules within rule flow groups or agenda groups. When this option is set to , the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the attribute, because the internalMatch of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again. A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow. The various interpolations of data in decision tables are illustrated in the following example. If the template is and the cell is , then the result is . If the template is and the cell contains , the result will be . The template with a cell containing results in . The next example demonstrates the joint effect of a cell defining the pattern type and the code snippet below it. This spreadsheet section shows how the type declaration spans 2 columns, and thus both constraints will appear as . Since only the field names are present in the snippet, they imply an equality test. In the following example the marker symbol is used. The result of this column is the pattern . You may have noticed that the marker and the operator \"==\" are redundant. The next example illustrates that a trailing insertion marker can be omitted. Here, appending the value from the cell is implied, resulting in You can provide the definition of a binding variable, as in the example below. Here, the result is Note that the quotes are provided automatically. Actually, anything can be placed in the object type row. Apart from the definition of a binding variable, it could also be an additional pattern that is to be inserted literally. A simple construction of an action statement with the insertion of a single value is shown below. The cell below the ACTION header is left blank. Using this style, anything can be placed in the consequence, not just a single method call. (The same technique is applicable within a CONDITION column as well.) Below is a comprehensive example, showing the use of various column headers. It is not an error to have no value below a column header (as in the NO-LOOP column): here, the attribute will not be applied in any of the rules. Figure 28. Example usage of keywords for imports, headers, etc. And, finally, here is an example of Import and Functions. Table 11. Example of functions for computing price and discount claim. function int computePrice(Cheese cheese) { if (cheese.getType() == \"cheddar\") { return 10; } else if (cheese.getType() == \"stilton\") { return 15; } else { return 20; } } function boolean hasDiscount(Person person) { if (person.getAge() > 60) { return true; } else { return false; } } Multiple package names within the same cell must be separated by a comma. Also, the pairs of type and variable names must be comma-separated. Functions, however, must be written as they appear in a DRL file. This should appear in the same column as the \"RuleSet\" keyword; it could be above, between, or below all the rule rows. It may be more convenient to use Import, Variables, Functions and Queries repeatedly rather than packing several definitions into a single cell. The API to use spreadsheet decision tables is in the module. When including in your project, you might encounter the following error: ; this happens because the underlying library to process spreadsheet files Apache POI uses the Log4j API (reference). To avoid that error, you must include either the SLF4J adapter or the Log4j 2 SLF4J Binding, depending on whether your project is using Log4j as a logging backend. There is only one class to look at: . This class will take spreadsheets in various formats, and generate rules in DRL (which you can then use in the normal way). The can just be used to generate partial rule files if it is wished and assemble them into a complete rule package after the fact (this allows the separation of technical and non-technical aspects of the rules if needed). Spreadsheets are well-established business tools (in use for over 25 years). Decision tables lend themselves to close collaboration between IT and domain experts while making the business rules clear to business analysts, it is an ideal separation of concerns. Typically, the whole process of authoring rules (coming up with a new decision table) would be something like:\n• A business analyst takes a template decision table (from a repository, or IT)\n• Decision table business language descriptions are entered in the table(s)\n• A decision table is handed to a technical resource, who maps the business language (descriptions) to scripts (this may involve software development of course if it is a new application or data model)\n• The technical person hands back and reviews the modifications with the business analyst.\n• The business analyst can continue editing the rule rows as needed (moving columns around is also fine etc).\n• In parallel, the technical person can develop test cases for the rules (liaising with business analysts) as these test cases can be used to verify rules and rule changes once the system is running. Features of applications like Excel can be used to provide assistance in entering data into spreadsheets, such as validating fields. Lists that are stored in other worksheets can be used to provide valid lists of values for cells, like in the following diagram. Some applications provide a limited ability to keep a history of changes, but it is recommended to use an alternative means of revision control. When changes are being made to rules over time, older versions are archived (many open source solutions exist for this, such as Subversion or Git). DRT (Drools Rule Template) is deprecated. Please consider this decision table capability or third party templating features if needed."
    },
    {
        "link": "https://geeksforgeeks.org/encapsulation-in-java",
        "document": "Encapsulation in Java is a fundamental OOP (object-oriented programming) principle that combines data and methods in a class. It allows implementation details to be hidden while exposing a public interface for interaction.\n\nExample: Below is a simple example of Encapsulation in Java.\n\nExplanation: In this example, the class restricts direct access to it from outside. The and methods, known as getters and setters, provide controlled access to the attribute. This encapsulation mechanism protects the internal state of the object and allows for better control and flexibility in how the attribute is accessed and modified.\n\nIn Java, encapsulation is implemented by declaring instance variables as private, restricting direct access. Public getter methods retrieve variable values, while setter methods modify them, enabling controlled access. This approach allows the class to enforce data validation and maintain a consistent internal state, enhancing security and flexibility.\n\nEncapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. Another way to think about encapsulation is, that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n• None In encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of its own class.\n• None A private class can hide its members or methods from the end user, using abstraction to hide implementation details, by combining data hiding abstraction.\n• None Encapsulation can be achieved by Declaring all the variables in the class as private and writing public methods in the class to set and get the values of variables.\n• None It is more defined with the setter and getter method.\n\nExample 1: Here is another example of encapsulation in Java\n\nExplanation: Here the encapsulation is achieved by restricting direct access to the name and age fields of the Person class. These fields are marked as private and can only be accessed or modified through public getter and setter methods (getName(), setName(), getAge(), setAge()). This approach ensures data hiding and maintains control over the values of these fields.\n\nExample 2: In this example, we use abstraction to hide the implementation and show the functionality.\n\nExample 2: The program to access variables of the class EncapsulateDemo is shown below:\n\nExplanation: In the above program, the class Encapsulate is encapsulated as the variables are declared private. The get methods like getAge(), getName(), and getRoll() are set as public, these methods are used to access these variables. The setter methods like setName(), setAge(), and setRoll() are also declared as public and are used to set the values of the variables.\n\nExample 4: Below is the implementation of the Java Encapsulation:\n\nExplanation: in the above code we can easily get the values and set the values easily by using the methods. Here the implementation is hidden and we can perform the tasks which makes it easy to use for end users.\n• Data Hiding: Encapsulation provides data hiding. Users don’t see the implementation of the class. The user only knows that we are passing the values to a setter method and variables are getting initialized with that value.\n• Data Integrity : By using getter and setter methods, we can ensure that only valid data is assigned to variables. If we omit the setter methods, we make the variables read-only, and if we omit the getter methods, we make them write-only. This ensures the internal state of the object is protected and maintains data integrity.\n• Reusability: Encapsulation also improves the re-usability and is easy to change with new requirements.\n• Testing code is easy: Encapsulated code is easy to test for unit testing.\n• Freedom of the details: one of the major advantages of encapsulation is that it gives the programmer freedom to implement the details of a system. The only constraint on the programmer is to maintain the abstract interface that outsiders see.\n• None It can lead to increased complexity, especially if not used properly.\n• None It can make it more difficult to understand how the system works.\n• None This may limit the flexibility of the implementation."
    },
    {
        "link": "https://skillsoft.com/course/java-se-11-encapsulation-b2d54be0-ef08-11e8-bd32-7758c3a3b2b2",
        "document": ""
    },
    {
        "link": "https://oracle.com/java/technologies/javase/seccodeguide.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/classes-objects-java",
        "document": "In Java, classes and objects are basic concepts of Object Oriented Programming (OOPs) that are used to represent real-world concepts and entities. The class represents a group of objects having similar properties and behavior. For example, the animal type Dog is a class while a particular dog named Tommy is an object of the Dog class. In this article, we will discuss Java classes and objects and how to implement them in our program.\n\nThe main differences between class and object in Java are as follows:\n\nA class in Java is a set of objects which shares common characteristics and common properties. It is a user-defined blueprint or prototype from which objects are created. For example, Student is a class while a particular student named Ravi is an object.\n• None Class is not a real-world entity. It is just a template or blueprint or prototype from which objects are created.\n• None Class is a group of variables of different data types and a group of methods.\n• None A Class in Java can contain:\n\nIn general, class declarations can include these components, in order:\n• Modifiers : A class can be public or has default access (Refer\n• Class keyword: Class keyword is used to create a class.\n• Class name : The name should begin with an initial letter (capitalized by convention).\n• Superclass (if any) : The name of the class’s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.\n• Interfaces(if any) : A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.\n• Body : The class body is surrounded by braces, { }.\n\nConstructors are used for initializing new objects. Fields are variables that provide the state of the class and its objects, and methods are used to implement the behavior of the class and its objects. There are various types of classes that are used in real-time applications such as nested classes, anonymous classes and lambda expressions.\n\nExample 1: Here, the below Java code demonstrates the basic use of class in Java.\n\nExample 2: Here, the below Java code demonstrates creating an object using the newInstance() method.\n\nAn object in Java is a basic unit of Object-Oriented Programming and represents real-life entities. Objects are the instances of a class that are created to use the attributes and methods of a class. A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of:\n• State : It is represented by attributes of an object. It also reflects the properties of an object.\n• Behavior : It is represented by the methods of an object. It also reflects the response of an object with other objects.\n• Identity : It gives a unique name to an object and enables one object to interact with other objects.\n\nExample of an object: Dog\n\nObjects correspond to things found in the real world. For example, a graphics program may have objects such as “circle”, “square”, and “menu”. An online shopping system might have objects such as “shopping cart”, “customer”, and “product”.\n\nWhen an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.\n\nAs we declare variables like (type name;). This notifies the compiler that we will use the name to refer to data whose type is type. With a primitive variable, this declaration also reserves the proper amount of memory for the variable. So for reference variables , the type must be strictly a concrete class name. In general, we can’t create objects of an abstract class or an interface.\n\nIf we declare a reference variable(tuffy) like this, its value will be undetermined(null) until an object is actually created and assigned to it. Simply declaring a reference variable does not create an object.\n\nThe new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the class constructor.\n\nExplanation: Here, the above program demonstrate a class Dog with some instance variables. The constructor is used to initializes value to these variables. The toString() method is used to provide a string representation of the dog object. In the method, a object named is created with specific values and its details are printed using the method.\n\nThis class contains a single constructor. We can recognize a constructor because its declaration uses the same name as the class and it has no return type. The Java compiler differentiates the constructors based on the number and the type of the arguments. The constructor in the Dog class takes four arguments. The following statement provides “tuffy”, “papillon”,5, and “white” as values for those arguments:\n\nThe result of executing this statement can be illustrated as :\n\nWays to Create an Object of a Class\n\nThere are four ways to create objects in Java. Although the new keyword is the primary way to create an object, the other methods also internally rely on the new keyword to create instances.\n\nIt is the most common and general way to create an object in Java.\n\nThere is a pre-defined class in java.lang package with name Class. The forName(String className) method returns the Class object associated with the class with the given string name. We have to give a fully qualified name for a class. On calling the new Instance() method on this Class object returns a new instance of the class with the given string name.\n\nThe clone() method is present in the Object class. It creates and returns a copy of the object.\n\nDe-serialization is a technique of reading an object from the saved state in a file. Refer to Serialization/De-Serialization in Java.\n\nCreating Multiple Objects by one type only (A good practice)\n\nIn real-time, we need different objects of a class in different methods. Creating a number of references for storing them is not a good practice and therefore we declare a static reference variable and use it whenever required. In this case, the wastage of memory is less. The objects that are not referenced anymore will be destroyed by the Garbage Collector of Java.\n\nIn the inheritance system, we use a parent class reference variable to store a sub-class object. In this case, we can switch into different subclass objects using the same referenced variable.\n\nAnonymous objects are objects that are instantiated but are not stored in a reference variable.\n• None They are used for immediate method calls.\n• None They will be destroyed after method calling.\n• None They are widely used in different libraries. For example, in AWT libraries, they are used to perform some action on capturing an event(eg a key press).\n• None In the example below, when a key button(referred to by the btn) is pressed, we are simply creating an anonymous object of EventHandler class for just calling the handle method."
    },
    {
        "link": "https://medium.com/@barbieri.santiago/ocp-java-11-objects-and-classes-cf4e82107bce",
        "document": "Classes and objects are fundamental concepts of object-oriented programming (OOP).\n\nA class is a blueprint from which individual objects are created. It defines a data structure that contains data members (fields or attributes) and methods. Data members represent the state of an object and methods define its behavior. An example of a class could be , which has attributes like brand, speed and behaviors such as drive.\n\nAn object is an instance of a class. Each object has its own state and behavior as defined by its class. Objects encapsulate data and operations on data. For example, if is a class, then a specific car like \"myCar\" is an object of the class, with its own brand, speed values.\n\nWhen an object is instantiated, it resides in a region of memory known as the heap. The heap is a key component of the Java Virtual Machine (JVM) that is dedicated to storing all runtime data, including objects and their instance variables.\n\nThe keyword creates an object, Java dynamically allocates memory for that object in the heap. The amount of memory allocated depends on the size of the object, which is determined by the combined size of its instance variables.\n\nEach object gets a unique memory address within the heap. This address is used internally by the JVM to access the object.\n\nThe heap allows for dynamic allocation and deallocation of memory. Objects can be created as needed, and when they are no longer reachable (i.e., there are no references to them), they can be removed from memory by the garbage collector.\n\nJava provides automatic garbage collection for the heap, which helps manage memory by reclaiming space occupied by objects that are no longer in use. This process reduces the risk of memory leaks and helps ensure efficient use of memory.\n\npublic class GarbageCollectionExample {\n\n \n\n public static void main(String[] args) {\n\n \n\n // Create an object of MyClass\n\n MyClass object1 = new MyClass(\"Object 1\");\n\n \n\n // Create another object of MyClass\n\n MyClass object2 = new MyClass(\"Object 2\");\n\n \n\n // Initially, object1 and object2 are not null and refer to objects in memory\n\n \n\n // Now, let's print them to confirm they exist\n\n System.out.println(object1.getName());\n\n System.out.println(object2.getName());\n\n \n\n // Make object1 reference the same object as object2\n\n // Now both object1 and object2 refer to the \"Object 2\" in memory\n\n object1 = object2;\n\n \n\n // At this point, the original object referred to by \"object1\"\n\n // is no longer accessible since its only reference was overwritten.\n\n // It becomes eligible for garbage collection.\n\n \n\n // Now explicitly nullify the object2 reference\n\n object2 = null;\n\n \n\n // At this point, the object with name \"Object 2\" is still accessible via object1,\n\n // so it's not eligible for garbage collection.\n\n \n\n // Nullify object1 as well\n\n object1 = null;\n\n \n\n // Now, both objects initially created (\"Object 1\" and \"Object 2\") are eligible for garbage collection\n\n // since there are no references to them anymore.\n\n \n\n // Note: Actual garbage collection is controlled by the JVM and happens at its discretion.\n\n // We cannot force it directly.\n\n \n\n // Suggest the JVM to run Garbage Collector\n\n System.gc();\n\n \n\n // Main method ends here, and any unreferenced objects are now eligible for garbage collection.\n\n }\n\n}\n\n\n\nclass MyClass {\n\n private String name;\n\n \n\n public MyClass(String name) {\n\n this.name = name;\n\n }\n\n \n\n public String getName() {\n\n return name;\n\n }\n\n \n\n @Override\n\n protected void finalize() throws Throwable {\n\n // This method is called by the garbage collector on an object when garbage collection\n\n // determines that there are no more references to the object.\n\n System.out.println(this.name + \" is being garbage collected\");\n\n super.finalize();\n\n }\n\n}\n\nPackage Statement (Optional, but must be the first line if present):\n• The package statement declares the namespace in which the classes, interfaces, enums, and annotations defined in the file belong.\n• If used, it must be the very first line of code, excluding comments and whitespace.\n\nImport Statements (Zero or Many)\n• Following the package statement, a source file may include zero or many import statements.\n• These statements allow the current file to use classes, interfaces, and static members from other packages.\n\nA class is defined by two main components: the class declaration and the class body.\n• The class declaration begins with the reserved word , followed by the class name (TypeIdentifier).\n• The class name should be a valid identifier and is case-sensitive.\n• The class declaration can also include modifiers (such as , , or ) and can specify the superclass (using ) and interfaces (using ).\n• The class body is enclosed in curly braces and contains all the code that defines the class's members, including variables (fields), methods, constructors, and nested types.\n• The class body is where the functionality of the class is implemented.\n\nInstance initializers are blocks of code that run whenever an instance of a class is created. They are used to initialize instance variables. Instance initializers are not commonly used.\n\nInstance initializers are written as blocks of code enclosed in braces and are placed within the class body but outside any method or constructor. The Java compiler inserts these blocks into each constructor of the class, running them in the order they appear before the constructor's code.\n• Execution Order: Instance initializers run each time a class instance is created, after all superclass constructors have completed and before the class’s own constructor’s code.\n• Static Initializers vs. Instance Initializers: static initializers, which are similar to instance initializers but are declared with the keyword, run once when the class is loaded. In contrast, instance initializers run every time an instance of the class is created.\n\nStatic initializers are blocks of code that are run once when the class is loaded by the JVM. They are used to initialize static variables.\n\nStatic initializers are written as blocks of code enclosed in braces and preceded by the keyword. They can appear anywhere within the class body. If a class contains multiple static initializers, they are executed in the order they appear in the class definition.\n\nStatic Initializers: Run once when the class is first loaded. This happens the first time the class is referenced, such as accessing a static field or method, or creating an instance of the class.\n\nCan only access static variables and methods directly. They operate at the class level.\n\nInstance Initializers: Run every time a class instance is created, before the constructor’s code is executed.\n\nCan access both instance and static variables and methods. They operate at the instance level.\n\nAn “illegal forward reference” occurs when a variable is used before it has been declared or before its declaration is definitely assigned. This error happens within initializer blocks (both static and instance initializers) when trying to access a variable ahead of its declaration. The variables must be declared or, in the case of instance variables, at least initialized by default, before they can be used.\n\nAn illegal forward reference in a static initializer block happens when you try to use a static variable before it has been declared or initialized within the block or class.\n\nSimilarly, an illegal forward reference can occur in instance initializer blocks if you try to access an instance variable before it is declared in the class body.\n• First, the JVM checks if the class of the object being created has been loaded and initialized. If not, the JVM proceeds to load the class and execute any static initializations (static blocks and static variables).\n• The JVM allocates memory for the new object instance, creating a space in the heap to store instance data.\n• Before any custom initialization code runs, the JVM sets all instance variables to their default values (e.g., for numeric types, for , for object references).\n• The JVM then executes custom initialization code, which includes:\n• Assignments made in the declaration of instance variables.\n• This custom initialization provides the specific values and states necessary for the object beyond the default initialization.\n\nFields, also known as variables declared within a class but outside any method, are of two main types: static (class variables) and non-static (instance variables).\n• Static Fields: Belong to the class itself rather than any instance. There’s only one copy of a static field per class, regardless of how many instances (objects) of that class might be created.\n• Non-static Fields: Each object of the class has its own copy of the instance variable.\n\nFinal fields can’t be modified once initialized. They can be either static or non-static. A final field must be initialized at the point of declaration or in the constructor for instance variables, and in a static block for static variables.\n• Volatile Fields: Ensure that multiple threads see the consistent value of the variable.\n\nIt serves as a reference to the current object, allowing access to its fields and methods, and can be used to invoke constructors within the same class.\n\nUsing to Call Another Constructor\n\nJava allows using to call another constructor in the same class. This is useful for constructor chaining, where one constructor initializes the object using another constructor in the same class.\n• Classes: A class is a blueprint for creating objects. It encapsulates data for the object in attributes and methods to manipulate that data.\n• Objects: An object is an instance of a class. It has a state defined by the attributes of the class and behavior defined by the methods of the class. Each object has its own copy of the instance variables of its class.\n• Heap Memory: Objects are stored in a region of memory known as the heap. This is where Java dynamically allocates memory for new objects. The heap’s management, including the allocation and deallocation of memory, is handled by the Java Virtual Machine (JVM).\n• Garbage Collection: Java provides automatic garbage collection for managing memory. Objects that are no longer in use and have no references pointing to them are eligible for garbage collection, which frees up their memory for reuse.\n• Class Structure: A Java class can contain a package statement (optional), import statements (to use classes and interfaces from other packages), a class declaration, and a class body. The class body includes attributes, methods, constructors, and possibly nested types.\n• Instance and Static Initializers: Instance initializers are blocks of code that run every time a class instance is created. Static initializers run once when the class is first loaded. They are used for initializing class’s static and instance variables, respectively.\n• Attributes: Attributes can be static (class level) or non-static (instance level). Static fields are shared among all instances of a class, while non-static atrributes are unique to each instance. Final fields cannot be modified once initialized.\n• Transient and Volatile Attributes: Transient attributes are not part of the serialization process, while volatile fields are used to ensure that changes made by one thread are visible to other threads.\n• The Keyword: This keyword is a reference to the current object. It is used to access the current object's fields and methods, and to invoke other constructors within the same class for constructor chaining."
    }
]