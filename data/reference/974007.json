[
    {
        "link": "https://docs.sublimetext.info/en/latest/extensibility/macros.html",
        "document": "Macros are a basic automation facility comprising sequences of commands. Use them whenever you need to repeat the exact same steps to perform an operation.\n\nMacro files are JSON files with the extension . Sublime Text ships with a few macros providing core functionality, such as line and word deletion. You can find these under Tools | Macros or in +:file: .\n\nTo start recording a macro, press and subsequently execute the desired steps one by one. When you’re done, press again to stop the macro recorder. Your new macro won’t be saved to a file, but kept in the macro buffer instead. Now you will be able to run the recorded macro by pressing , or save it to a file by selecting Tools | Save macro... Note that the macro buffer will remember only the latest recorded macro. Also, macros only record commands sent to the buffer: window-level commands, such creating a new file, will be ignored.\n\nAs an alternative to recording a macro, you can edit it by hand. Just save a new file with the extension under and add commands to it. Macro files have this format: See the Commands section for more information on commands. If you’re editing a macro by hand, you need to escape quotation marks, blank spaces and backslashes by preceding them with ."
    },
    {
        "link": "https://docs.sublimetext.io/guide/extensibility/macros.html",
        "document": "Macros are a basic automation facility comprising sequences of commands. Use them whenever you need to repeat the exact same steps to perform an operation.\n\nMacro files are JSON files with the extension . Sublime Text ships with a few macros providing core functionality, such as line and word deletion. You can find these under Tools | Macros or in .\n\nTo start recording a macro, press and subsequently execute the desired steps one by one. When you're done, press again to stop the macro recorder. Your new macro won't be saved to a file, but kept in the macro buffer instead. Now you will be able to run the recorded macro by pressing , or save it to a file by selecting Tools | Save macro...\n\nNote that the macro buffer will remember only the latest recorded macro. Also, macros only record commands sent to the buffer: window-level commands, such creating a new file, will be ignored.\n\nAs an alternative to recording a macro, you can edit it by hand. Just save a new file with the extension under and add commands to it. Macro files have this format:\n\nSee the Commands section for more information on commands.\n\nIf you're editing a macro by hand, you need to escape quotation marks, blank spaces and backslashes by preceding them with .\n\nMacro files can be stored in any package folder, and then will show up under Tools | Macros | <PackageName>.\n\nMacro files can be bound to key combinations by passing the macro file path to the command like so:"
    },
    {
        "link": "https://tutorialspoint.com/sublime_text/sublime_text_macros.htm",
        "document": "Macros are the basic automation facility that includes a sequence of commands. You can use macros whenever you need to perform an operation which includes same steps.\n\nMacro files are JSON files with an extension called .sublime-micro and are considered to be very helpful.\n\nRecording a macro defines the procedure to keep a set of commands needed for the given file. You can record a macro in two ways −\n• None Use the shortcut key Ctrl+Q for recording a macro in Windows and Cmd+Q in Mac.\n• None Use the record option in Tools → Record Macro.\n\nOnce the macro has started recording, you can see the following message in Sublime Text editor −\n\nYou can use the shortcut key Ctrl+Shift+Q on Windows and Cmd+Shift+Q for Mac, to play a macro recorded by the user in Sublime Text. Note that this shortcut plays the last recorded macro in Sublime.\n\nYou can save a recorded macro using the option Tools → Save Macro. The following screenshot shows how to save a macro using this option.\n\nYou can also redefine the macros using various options in Tool menu bar, as shown below −"
    },
    {
        "link": "https://sublime-text-unofficial-documentation.readthedocs.io/en/stable/extensibility/macros.html",
        "document": "Macros are a basic automation facility consisting in sequences of commands. Use them whenever you need to repeat the exact same steps to perform an operation.\n\nMacro files are JSON files with the extension . Sublime Text ships with a few macros providing core functionality, such as line and word deletion. You can find these under Tools | Macros.\n\nTo start recording a macro, press and subsequently execute the desired steps one by one. When you’re done, press again to stop the macro recorder. Your new macro won’t be saved to a file, but kept in the macro buffer instead. You will now be able to run the recorded macro by pressing or save it to a file by selecting Tools | Save macro…. Note that the macro buffer will only remember the macro recorded latest. Also, recorded macros only capture commands sent to the buffer: window level commands, such as creating a new file, will be ignored.\n\nAlternatively to recording a macro, you can edit it by hand. Save a new file with the extension under and add commands to it. This is how a macro file looks like: See the Commands section for more information on commands. If you’re editing a macro by hand, you need to escape quotation marks, blank spaces and backslashes by preceding them with ."
    },
    {
        "link": "https://forum.sublimetext.com/t/sublimetext-macros-are-no-good/23851",
        "document": "I posted in the previous thread on this subject about a year ago, and have mentioned it in other posts too. A number of people are chiming in with the position that extensions are more powerful than macros, which obviates the need for macros to record things like Find/Replace. I sit firmly on the side of the argument that macros should record everything that makes sense, with a few documented exceptions that should also make sense.\n\nWhile I agree that extensions are more powerful and can always do the work of a macro - though I feel that Sublime’s API needs some work to really unleash that power - they’re no substitute for macros. The reason is simple: Being programmers, we would rather avoid having to write more programs to achieve sophisticated editing operations wherever possible. For many of us, Python and Sublime’s API are not our primary programming environment so the process can become overly time consuming. The editor is there to save us time and make complex editing operations a breeze. Extensions are useful where we might want to do something complex, repeatedly over time and with necessary logic that might change based on a variety of conditions or variables. Such functionality will often be useful to others. Macros should allow us to record a sequence of operations by doing them, optionally allow refinement by editing the macro’s code, then allow macro playback to be triggered with a keystroke.\n\nThe power of a programmer’s editor becomes evident to most when they discover the ability to build complex editing operations out of simple building blocks. Originally a Brief user whose editor of evolved through Emacs, Vim and Crisp for many years (I still use the latter), the ability to record and repeat a series of operations, including and beyond text entry and cursor movements, and play them back with a keystroke or say ‘repeat playback 20 times or until EOF’, is a workflow that can surmount complex editing tasks over large files in record speed. While Sublime’s multi-cursors and multi-selections can get you to the same place in some cases, it often can’t. So I’m left falling back to Crisp as others fall back to Notepad++ etc. to do such things - and that’s a real shame.\n\nMany ask why this is the case. I don’t have insight into Jon’s design choices but I am a programmer, and the reason seems fairly obvious. Jon engineered macros to sequence simple keystroke-based operations like text entry, deletion and cursor movement into atomic language specific operations. Any text editor will need a wealth of these, and a dumb ‘sequencer’ which avoids functional code seems a logical, quick to implement approach. Beyond actual keystrokes, TextCommands are the lowest level operations falling into this category so Jon implemented the facility this way. Adding other types of function adds complexity because they might potentially affect the state of entire buffers, require input etc… So if I’m right the reason is simplicity, justified perhaps by the thinking that multi-cursors/selections would be an alternative workflow to the same ends.\n\nWith the time that’s passed it’s become clear that, while useful, multi-cursors/selections are not a panacea for the challenges of complex editing tasks. We need macros that can record and playback everything, which can then be used in extensions or as part of eg. ‘repeat X times or until EOF’.\n\nAddressing Sublime’s key limitations should probably be high on the priority pile moving forward. For me, more powerful macros that record everything, and extensions that can do more by virtue of a richer API should be right at the top of the list."
    },
    {
        "link": "https://forum.sublimetext.com/t/tutorials-and-examples-for-plugin-development/69836",
        "document": "Unfortunately, I don’t know if there is a good tutorial article online\n\nbut did you know that most plugins are opensource?\n\nHere are documentations (not really tutorials)\n\nThe official doc is hard to use so I suggest you drop by Discord and ask\n\n Check out the Sublime Text community on Discord - hang out with 2425 other members and enjoy free voice and text chat.\n\nNow as for the plugin, think of something simple for now. How about a plugin that prints “ ” in the console whenever your cursor touches “E” or “e”. Then in the API reference, look at the ViewListener and read about it. That’ll get you started."
    },
    {
        "link": "https://docs.sublimetext.io/guide/extensibility/plugins",
        "document": "This section is intended for users with programming skills.\n\nSublime Text can be extended through Python plugins. Plugins build features by reusing existing commands or creating new ones. Plugins are a logical entity, rather than a physical one.\n\nIn order to write plugins, you must be able to program in Python. At the time of this writing, Sublime Text uses Python 3.3.\n\nSublime Text will look for plugins only in these places:\n\nAs a consequence, any plugin nested deeper in won't be loaded.\n\nKeeping plugins directly under is discouraged. Sublime Text sorts packages in a predefined way before loading them, so if you save plugin files directly under you might get confusing results.\n• Select Tools | Developer | New Plugin... in the menu.\n\nYou've just written your first plugin! Let's put it to use:\n\nYou should see the text \"Hello, World!\" in the newly created buffer.\n\nThe plugin created in the previous section should look roughly like this:\n\nBoth the and modules are provided by Sublime Text; they are not part of the Python standard library.\n\nAs we mentioned earlier, plugins reuse or create commands. Commands are an essential building block in Sublime Text. They are simply Python classes that can be called in similar ways from different Sublime Text facilities, like the plugin API, menu files, macros, etc.\n\nSublime Text Commands derive from the classes defined in (more on this later).\n\nThe rest of the code in our example is concerned with particulars of or with the API. We'll discuss those topics in later sections.\n\nBefore moving on, though, we'll look at how we invoked the new command: first we opened the Python console and then we issued a call to . This is a rather inconvenient way of calling commands, but it's often useful when you're in the development phase of a plugin. For now, keep in mind that your commands can be accessed through key bindings and by other means, just like other commands.\n\nYou may have noticed that our command is named , but we passed the string to the API call instead. This is necessary because Sublime Text standardizes command names by stripping the suffix, splitting subwords of with underscores, and lower-casing it, like so: .\n\nNew commands should follow the same naming pattern.\n\nYou can create the following types of commands:\n\nWhen writing plugins, consider your goal and choose the appropriate type of commands.\n\nAll commands need to implement a method in order to work. Additionally, they can receive an arbitrarily long number of keyword parameters.\n\nNote: Parameters to commands must be valid JSON values due to how ST serializes them internally.\n\nWindow commands operate at the window level. This doesn't mean that you can't manipulate views from window commands, but rather that you don't need views in order for window commands to be available. For instance, the built-in command is defined as a so it works even when no view is open. Requiring a view to exist in that case wouldn't make sense.\n\nWindow command instances have a attribute to point to the window instance that created them.\n\nThe method of a window command doesn't require any positional parameter.\n\nWindow commands are able to route text commands to their window's active view.\n\nText commands operate at the view level, so they require a view to exist in order to be available.\n\nText command instances have a attribute pointing to the view instance that created them.\n\nThe method of text commands requires an instance as its first positional argument.\n\nThe edit object groups modifications to the view so that undo and macros work sensibly.\n\nNote: Contrary to older versions, Sublime Text 3 doesn't allow programmatic control over edit objects. The API is in charge of managing their life cycle. Plugin creators must ensure that all modifying operations occur inside the method of new text commands. To call existing commands, you can use or similar API calls.\n\nAny command deriving from will be able to respond to events.\n\nAnother Plugin Example: Feeding the Completions List ​\n\nLet's create a plugin that fetches data from Google's Autocomplete service and then feeds it to the Sublime Text completions list. Please note that, as ideas for plugins go, this a very bad one.\n\nThe API reference is documented at https://www.sublimetext.com/docs/api_reference.html.\n\nTo get acquainted with the Sublime Text API and the available commands, it may be helpful to read existing code and learn from it.\n\nIn particular, the contains many examples of undocumented commands and API calls. Note that you will first have to extract its contents to a folder if you want to take a look at the code within. The View Package File command in the Command Palette helps with this."
    },
    {
        "link": "https://stackoverflow.com/questions/23701935/basic-sublime-text-plugin-development-view-run-commandexample-does-not-work",
        "document": "I'm trying to use Will Bond's guide to creating a Sublime Text plugin (http://code.tutsplus.com/tutorials/how-to-create-a-sublime-text-2-plugin--net-22685).\n\nStep 1 of the guide says to create a default plugin with the following code:\n\nThis plugin gets saved as Prefixr.py in:\n\nI then type the following command into the Sublime Text console:\n\nAnd this should insert \"Hello, World!\" at the beginning of my currently viewed file.\n\nHowever, when I enter the command, nothing happens. No \"Hello, World!\" appears in my file. Restarting Sublime Text does not fix it. Neither does running the command from different files.\n\nAny idea why the command does not work?"
    },
    {
        "link": "https://sublimetext.com/docs/1/plugin-basics",
        "document": "Sublime Text is extensible via Python. Extending is simply a matter of placing a python file under the Packages directory (For example C:\\Documents and Settings\\ username \\Application Data\\Sublime Text\\Packages\\User).\n\nEach python file within the Packages directory is automatically scanned for Plugins, and automatically reloaded when changed.\n\nTo make a command that may be bound to a key, placed in a menu, etc, simply create a class extending sublimeplugin.TextCommand and override the run() method.\n\nTo make a plugin that receives notification of file load, save, etc, create a class extending sublimeplugin.Plugin, and implement one or more of the event methods (onLoad, onPostSave, etc). Note that TextCommand and friends themselves extend from Plugin, and may receive events.\n\nWhen developing plugins, all syntax errors and print statements are directed to the console (accessible via Ctrl+~).\n\nNext step: Take a look at some of the examples, or have a look over the API reference."
    },
    {
        "link": "https://1klb.com/posts/2013/07/18/building-a-sublimetext-command-from-scratch-and-other-useful-bits",
        "document": "Note: Since I started writing this, SublimeText3 came out. Hopefully I've caught any problems ST3 has with my methods.\n\nSublimeText is my current text editor of choice. While I use a few others for specific tasks , if I'm just going to chuck words in a file I'll probably find myself using Sublime Text. One of the nice things about ST is the extensive plugin framework: a series of python files in a pretty simple file hierarchy makes for a bunch of hackability.\n\nA while back I decided to make a ST plugin for collecting markdown reference links. I know that this plugin exists in a number of packages, but for whatever stubborn reason I didn't want to install someone else's scripts, I wanted to do it myself. While I found a couple of tutorials on the web for this task, there was nothing that really told me everything I wanted to know, so I had to muddle through it myself. Now I know what's going on, I figure I should write this down, either to help others in their quest to write ST plugins, or simply for future reference.\n\nThe many sections of a SublimeText plugin\n\nA basic SublimeText plugin looks like this:\n\nThis is a really, really bare-bones plugin. If you save this to SublimeText's directory (available via ), or into a folder within this directory , it'll get scanned and added to ST's list of commands (assuming you save it with the extension).\n\nNote: this is not the same as having it pop up in the Command Palette (that is, the menu you get when you his ). As it stands, you can run your plugin by opening up SublimeText's console ( `) and typing . is equal to the name of the class you just created, in . If your plugin ends with , leave that off. So would be , but would just be . I'll go over how to put this in the command palette and make pretty shortcuts for it later on - for the moment we'll just run it through the command palette.\n\nYou'll note that this is a text command. It's possible to make other commands, but I have the most experience with text commands, so I'll stick with them for now.\n\nThere's only a few other methods that SublimeText plugins take. The main one that's of use is the method:\n\nThis method tells you if a given plugin is enabled. If it's not, it won't show up in the command palette ever and generally won't run. It's handy because you can combine it with some pretty nifty in-program logic:\n\nThis plugin will only run when your syntax is set to Markdown.\n\nThis is all good only if we can do something in our plugin. Thankfully, SublimeText has a pretty good API for this sort of thing. I think you can do a lot with just getting the document's contents, scanning through it, and making modifications based on simple logic, so I'm going to go through some of the commands for doing just that.\n\nMost text-related commands are contained within SublimeText's object, accessible in text commands via . As an example, if you want to search the document for a particular string, you can use the 's method:\n\nYou can do similar things with , which will grab all instances of the string. The string also accepts regular expressions, which is handy.\n\nand return s, which are basically a set of beginning and ending positions. A number of methods will take regions as arguments, so sometime you just have to pass it from one place to another; if you want to start poking around inside it, the above-mentioned API reference has a pretty good guide to its methods.\n\nAll modifications to a SublimeText document are done within a given . When you undo a change, it undoes all the work of the last edit. This means if you make a command that does fifteen find-and-replaces in your document, but does these all under the one , when you undo that last command it'll undo all fifteen find-and-replaces.\n\nYou can make your own objects if you want to split your command into a number of bits , but really, most of the time you can just use the edit that gets passed into the command.\n\nLet's make a command that will replace every instance of the word \"FOO\" with \"BAR\", as a simple example:\n\nThe only new thing here is calling . This replaces a given region with a string. We wrap this all up in the one edit command.\n\nBetween these examples and the API, you should be able to make your command do what you want with the document. It may require some fiddling around, but hopefully you now have enough tools to do a bunch of fiddling and go from there.\n\nSo far, your best way of getting to the command is through SublimeText's control panel. Which, let's face it, isn't very user-friendly. You can access most commands through:\n• The command palette, and sometimes also\n\nThe command palette is populated on a by-syntax basis. If you're currently using language foo on a file, then you'll get commands that are defined in (mine is in the folder in the plugins directory), and those defined in any files called .\n\nUnlike files, SublimeText seems to find files wherever they are in your plugin hierarchy.\n\nfiles are JSON files that have the following syntax:\n\nGenerally, I make sure my commands are available via the command palette. Since the command palette is filtered by language, and fuzzy-text searching is ridiculously fast, it doesn't matter if you stick ten extra commands in there.\n\nThis is the best way of accessing commands that you use all the time. However, it does require another set of files.\n\nFirst, you need to put your key bindings in a file called \"Default.sublime-keymap\". You can't call it \"\n\nThis is also a JSON file, and the layout looks something like this:\n\nThis is a simple keybinding that maps (which is ⌘+i on OS X, Ctrl+i on Windows/Linux) to a little snippet. Now, wherever you are, you can type and have your text italicised.\n\nIf you don't want to use the snippet outside of the keybinding, you can always specify it inline with the key:\n\nThere is a slight problem here - regardless of where you store your keybinding file, this keybinding will work wherever you are. All is not lost, however, since you can limit where key bindings apply with contexts. Here's an example of a keybinding with a context:\n\nA context is an array of criteria that need to be fulfilled for Sublime Text to trigger a key binding. A handy list of possible contexts is available here. While the syntax is a little bulky, by using contexts you can ensure that your keybindings only trigger when you want them to.\n\nBased on this guide, you should be able to make a series of SublimeText commands, give them applicable names in the comand palette, and assign shortcuts as required. You should also be able to limit the scope in which a command applies, so it doesn't show up in your command palette (and the keybinding doesn't trigger) when you don't want it to. The last thing to do is to store and organise commands in packages.\n\nYou can get to your packages directory in SublimeText by selecting from the menu. In OS X this is . Sublime Text loads files from folders in the package directory in the following order:\n\nFiles will overwrite previous key bindings, commands, etc. So if you have the key bound in keymaps in , and , hitting in SublimeText will trigger the command as specified in .\n\nIt's generally good practise to put \"miscellaneous\" snippets, commands, key bindings etc. in the directory, but once you have two or three files for one language you might want to split them off and put them in their own folder. If you want to transfer your files between computers (or share them with others), you can make a file in the following manner:\n• Zip up the directory containing your files.\n• Change the extension from to\n\nYou can place this in the directory and SublimeText will read it as if it were a folder.\n\nBut where's all the default packages?\n\nIn Sublime Text 3, the directory looks practically abandoned compared to ST2. This is because all the default packages are stored alongside the program itself. In OS X you can find the packages inside the app bundle under . These are all stored as files, so if you want to examine the contents of them you just have to make a copy somewhere else, then rename to and unzip them.\n\nHopefully at the end of this you can create commands for Sublime Text 3, bind them to the command palette or key combinations, and store them properly. Some of this I'm still learning (and the release of ST3 has meant I've had to re-learn some things), but this guide contains most of the stuff I had no luck googling or ended up figuring out by myself. SublimeText's API reference is pretty robust, so between this guide and the references linked to throughout the article, you should be able to work out how to get SublimeText to do what you want."
    }
]