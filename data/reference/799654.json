[
    {
        "link": "https://requests.readthedocs.io/en/master/user/quickstart",
        "document": "Eager to get started? This page gives a good introduction in how to get started with Requests.\n\nFirst, make sure that:\n\nLet’s get started with some simple examples.\n\nMaking a request with Requests is very simple. Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline: Now, we have a object called . We can get all the information we need from this object. Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request: Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple: That’s all well and good, but it’s also only the start of what Requests can do.\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a dictionary of strings, using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL: Note that any dictionary key whose value is will not be added to the URL’s query string. You can also pass a list of items as a value:\n\nWe can read the content of the server’s response. Consider the GitHub timeline again: Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access . You can find out what encoding Requests is using, and change it, using the property: If you change the encoding, Requests will use the new value of whenever you call . You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTML and XML have the ability to specify their encoding in their body. In situations like this, you should use to find the encoding, and then set . This will let you use with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the module, you can simply use the codec name as the value of and Requests will handle the decoding for you.\n\nThere’s also a builtin JSON decoder, in case you’re dealing with JSON data: In case the JSON decoding fails, raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting raises . This wrapper exception provides interoperability for multiple exceptions that may be thrown by different python versions and json serialization libraries. It should be noted that the success of the call to does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use or check is what you expect.\n\nIn the rare case that you’d like to get the raw socket response from the server, you can access . If you want to do this, make sure you set in your initial request. Once you do, you can do this: In general, however, you should use a pattern like this to save what is being streamed to a file: Using will handle a lot of what you would otherwise have to handle when using directly. When streaming a download, the above is the preferred and recommended way to retrieve the content. Note that can be freely adjusted to a number that may better fit your use cases. An important note about using versus . will automatically decode the and transfer-encodings. is a raw stream of bytes – it does not transform the response content. If you really need access to the bytes as they were returned, use .\n\nIf you’d like to add HTTP headers to a request, simply pass in a to the parameter. For example, we didn’t specify our user-agent in the previous example: Note: Custom headers are given less precedence than more specific sources of information. For instance:\n• None Authorization headers set with will be overridden if credentials are specified in , which in turn will be overridden by the parameter. Requests will search for the netrc file at , , or at the path specified by the environment variable.\n• None Authorization headers will be removed if you get redirected off-host.\n• None Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n• None Content-Length headers will be overridden when we can determine the length of the content. Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request. Note: All header values must be a , bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values.\n\nTypically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the argument. Your dictionary of data will automatically be form-encoded when the request is made: The argument can also have multiple values for each key. This can be done by making either a list of tuples or a dictionary with lists as values. This is particularly useful when the form has multiple elements that use the same key: There are times that you may want to send data that is not form-encoded. If you pass in a instead of a , that data will be posted directly. For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data: Please note that the above code will NOT add the header (so in particular it will NOT set it to ). If you need that header set and you don’t want to encode the yourself, you can also pass it directly using the parameter (added in version 2.4.2) and it will be encoded automatically: Note, the parameter is ignored if either or is passed.\n\nYou can set the filename, content_type and headers explicitly: If you want, you can send strings to be received as files: In the event you are posting a very large file as a request, you may want to stream the request. By default, does not support this, but there is a separate package which does - . You should read the toolbelt’s documentation for more details about how to use it. For sending multiple files in one request refer to the advanced section. It is strongly recommended that you open files in binary mode. This is because Requests may attempt to provide the header for you, and if it does this value will be set to the number of bytes in the file. Errors may occur if you open the file in text mode.\n\nWe can view the server’s response headers using a Python dictionary: The dictionary is special, though: it’s made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive. So, we can access the headers using any capitalization we want: It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.\n\nYou can tell Requests to stop waiting for a response after a given number of seconds with the parameter. Nearly all production code should use this parameter in nearly all requests. Failure to do so can cause your program to hang indefinitely: is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for seconds (more precisely, if no bytes have been received on the underlying socket for seconds). If no timeout is specified explicitly, requests do not time out.\n\nIn the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a exception. will raise an if the HTTP request returned an unsuccessful status code. If a request times out, a exception is raised. If a request exceeds the configured number of maximum redirections, a exception is raised. All exceptions that Requests explicitly raises inherit from . Ready for more? Check out the advanced section."
    },
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://stackoverflow.com/questions/9733638/how-to-post-json-data-with-python-requests",
        "document": "I need to POST a JSON from a client to a server. I'm using Python 2.7.1 and simplejson. The client is using Requests. The server is CherryPy. I can GET a hard-coded JSON from the server (code not shown), but when I try to POST a JSON to the server, I get \"400 Bad Request\".\n\nHere is my client code:\n\nHere is the server code."
    },
    {
        "link": "https://w3schools.com/python/ref_requests_post.asp",
        "document": "The method sends a POST request to the specified url.\n\nThe method is used when you want to send some data to the server.\n\nargs means zero or more of the named arguments in the parameter table below. Example:"
    },
    {
        "link": "https://reqbin.com/code/python/m2g4va4a/python-requests-post-json-example",
        "document": "What is the Python Requests library?\n\nThe Requests Library is a library for sending HTTP requests in Python, developed initially by Kenneth Reitz. Because of its simplicity and ease of use has become the standard way to send HTTP POST and GET requests (and other types), although it is not included in the Python distribution. The Requests Library is based on the urllib3 library and hides the complexity of making HTTP requests behind a simple API. The Requests Library supports SSL connections, international domain names, and session cookies. It automatically encodes POST data, formats JSON, decompresses server responses, and has built-in proxy support. A complete list of features can be found on the official Requests Library site.\n\nJavaScript Object Notation (JSON) is a language-independent text format for storing and exchanging data. Web applications use JSON to exchange data between a web browser and a server and exchange data between servers via REST API. For many programming languages, including JavaScript, Java, C ++, C #, Go, PHP, Python, there are ready-made code libraries for creating and manipulating JSON data. JSON file names use the .json file extension.\n\nHTTP POST method requests the webserver to accept the data enclosed in the POST request message body to process or store it. The POST method is used to upload files and submit web forms. The POST is one of the nine standard methods of the HTTP protocol. The POST method is used for CRUD operations to create or update a resource on the server. POST requests can change the server's state and are not idempotent, unlike GET and HEAD requests.\n\nHow to use the Python Requests library?\n\nTo install the Python Requests library, run the following command:\n\nAfter installing the Request Library, you can use it in your application.\n• data (optional): can be a dictionary, a list of tuples, bytes, or a file to send in the body of the POST request.\n• json (optional): a dictionary that will be converted to a JSON string and included in the body of the POST request.\n• arguments (optional): the arguments that the POST request accepts.\n\nHow to make a POST request with Python?\n\nTo make a POST request using Requests library, you need to call the requests.post() method and pass the data with the the data= or json= parameter.\n\nHow to send custom HTTP headers with a POST request?\n\nHTTP headers can be passed to a POST request using the headers= parameter.\n\nAn example of sending JSON with using the Python Requests library to the ReqBin echo URL:\n\nThe server response to our POST JSON request:\n• How do I add comments to JSON?\n• How do I split strings in Python?\n• How do I compare strings in Python?\n• How to read XML in Python?"
    },
    {
        "link": "https://dateutil.readthedocs.io/en/stable/relativedelta.html",
        "document": "The relativedelta type is designed to be applied to an existing datetime and can replace specific components of that datetime, or represents an interval of time.\n\nIt is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime extension. However, notice that this type does implement the same algorithm as his work. Do expect it to behave like mx.DateTime’s counterpart.\n\nThere are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:\n\nThe second one is passing it any number of the following keyword arguments:\n\nThere are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute).\n\nThe order of attributes considered when this relativedelta is added to a datetime is:\n\nFinally, weekday is applied, using the rule described above.\n\nFirst, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect."
    },
    {
        "link": "https://dateutil.readthedocs.io/en/2.6.1/relativedelta.html",
        "document": "The relativedelta type is based on the specification of the excellent work done by M.-A. Lemburg in his mx.DateTime extension. However, notice that this type does implement the same algorithm as his work. Do expect it to behave like mx.DateTime’s counterpart.\n\nThere are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:\n\nThe second one is passing it any number of the following keyword arguments:\n\nHere is the behavior of operations with relativedelta:\n• Calculate the absolute year, using the ‘year’ argument, or the original datetime year, if the argument is not present.\n• Add the relative ‘years’ argument to the absolute year.\n• Do steps 1 and 2 for month/months.\n• Calculate the absolute day, using the ‘day’ argument, or the original datetime day, if the argument is not present. Then, subtract from the day until it fits in the year and month found after their operations.\n• Add the relative ‘days’ argument to the absolute day. Notice that the ‘weeks’ argument is multiplied by 7 and added to ‘days’.\n• Do steps 1 and 2 for hour/hours, minute/minutes, second/seconds, microsecond/microseconds.\n• If the ‘weekday’ argument is present, calculate the weekday, with the given (wday, nth) tuple. wday is the index of the weekday (0-6, 0=Mon), and nth is the number of weeks to add forward or backward, depending on its signal. Notice that if the calculated date is already Monday, for example, using (0, 1) or (0, -1) won’t change the day."
    },
    {
        "link": "https://stackoverflow.com/questions/12433233/what-is-the-difference-between-datetime-timedelta-and-dateutil-relativedelta",
        "document": "One major difference not highlighted in other answers is the presence of singular and plural nouns for each time difference primitive. While only offers plural nouns (e.g. , ) to denote relative time difference, offers singular nouns as well (e.g. , ) to denote absolute time information.\n\nThis is clear from the definition of the 2 classes:\n\nNow, exactly what does the singular form do? Singular form creates a delta which when added to a object, sets that specific date/time primitive in the object to that mentioned in the . Here is a small example:\n\nThis can lead to being used for some interesting applications, which can be complicated to implement using . One that quickly comes to mind is rounding-off.\n\nI will now show you how is more expressive when doing rounding off a object to the nearest minute, hour, day etc.\n\nRounding off to the nearest hour:\n\nNotice how straightforward it is to round-off using :\n\nOther more complicated rounding-offs are easily achievable using . However, note that all the round-offs that can be done by can also be done using functions and , only in a slightly more convoluted way."
    },
    {
        "link": "https://influxdata.com/blog/guide-dateutil-module-python",
        "document": "This post was written by Siddhant Varma. Scroll down to view the author’s profile.\n\nPython is a highly versatile language. From software engineering to machine learning and data analysis, it’s everywhere. As a multipurpose scripting and programming language, it’s often utilized for manipulating and working with data. So, when you’re working with Python, whether you’re analyzing data or writing scripts, you’re likely to encounter dates and time stamps.\n\nDealing with dates can be challenging if you attempt to create your own logic for manipulating them from scratch. To simplify this process, Python offers a dateutil module. In this post, we’ll teach you about the dateutil module, what it is, and how it operates. Then we’ll show you some common examples of frequently used date functions that you can implement using the dateutil module.\n\nThe dateutil module is a predefined module in Python that helps you manipulate and work with dates and time stamps. You can use it for a number of purposes when working with dates, such as adding dates, parsing dates in different formats, subtracting dates, calculating the difference between two dates, etc. We’ll explore some common examples later in the post.\n\nThe dateutil module is an extension of the datetime module.\n\nThe dateutil module is not a part of Python 3’s standard library, but that doesn’t mean you can’t use it. You can easily install it using pip. Once you do that, you can import the dateutil module into any of your Python scripts using the standard import statement the way you normally use other Python modules.\n\nWe’ll show you how you can use the dateutil module with Python 3 in the section below.\n\nHow does it work?\n\nFirst, we’ll show you how dateutil works under the hood since it’s an abstraction of the datetime module. The dateutil module was built on top of the datetime module by adding some functions and classes to the existing functions and classes. These functions and classes make it easier to work with dates and times in a variety of ways. For example, dateutil includes functions for parsing dates and times from strings in a wide variety of formats.\n\nNow we’ll show you how to install the dateutil module in Python 3.\n\nFor this tutorial, I’m using pip3 and Python 3, but you can follow the equivalent steps and code for other versions of Python. First, install the dateutil module using pip3 by running the following command:\n\nRunning that command should install the dateutil module for you.\n\nNow, in order to verify the installation and check that the dateutil module is correctly installed, you can try to import the module. I’m using ipython to run these Python commands directly in the terminal, but you can also create a .py file and run it.\n\nIf dateutil is somehow not correctly installed, the above program will throw an error. Otherwise, it should give you the path reference where the dateutil module exists in your system.\n\nNow that you’ve installed the module, let’s look at how you can use it with examples.\n\nThe dateutil module provides a parse function that you can use to parse dates into desired string formats. First, you’ll need to import the parse function:\n\nThen you can use the parse function to return a parsed version of the date string. Take a look at the following code:\n\nWhen you print the value of parsed_today, you should get the date string parsed in ISO format as shown below:\n\nHere’s how you can use the parse function to parse a date string in a relative format:\n\nIn the code above, we pass the fuzzy parameter as true to the parse function, which tells the parse function to generate the formatted date based on the date string passed.\n\nNow we’ll show you how you can compute the difference between two dates using the dateutil module. This is a common operation to find the relative time elapsed of a date from a certain date.\n\nFirst, import the relativedelta function from the dateutil module:\n\nThe relativedelta function will be used to calculate the difference between two date strings. Have a look at the following code:\n\nLet’s see what the output is:\n\nIf you look closely, the diff variable reveals the difference between the two dates, i.e., five days. But let’s only print the difference in days between these two dates:\n\nThe diff itself is an object, and the days property gives you the difference in the number of days. In a similar way, you can find the difference between two dates in months and years by accessing the months and years property on the difference variable.\n\nAnother common date manipulation that you might need is adding or subtracting time from a given date. We’ll now show you how you can add a specific number of days to the current date:\n\nThat should give you a date seven days in the future from today:\n\nAwesome! Similarly, you can subtract a specific number of days from a given date:\n\nAnd that should give you a date seven days in the past:\n\nBy now you’ve seen enough examples to understand how the dateutil module works. But what’s the practical use case or real-life scenario where you’d want to use it? You can use the dateutil module to work with a time series database.\n\nA time series database is a special kind of database that’s optimized for storing and querying time series data. Unlike regular data that’s only written into the database once when needed, time series data is recorded and stored in the database over time. Some common examples of time series data include data that you need to measure from an Internet of Things sensor, the changing prices of a stock over a period of a few days, weather data that’s updated daily, and so on. Time series databases are designed to handle large volumes of data that are recorded at regular intervals.\n\nCurious to learn more and get your hands dirty with a time series database? Check out Influx DB. It allows you to handle high-speed and high-volume data to simplify time series data management.\n\nIn this post, you learned about the dateutil module in Python. You saw how to add, subtract, and format dates using various functions available on the module. Since the dateutil module is itself derived from the datetime module, you can also use the datetime module for some of these operations.\n\nThis post was written by Siddhant Varma. Siddhant is a full stack JavaScript developer with expertise in frontend engineering. He’s worked with scaling multiple startups in India and has experience building products in the Ed-Tech and healthcare industries. Siddhant has a passion for teaching and a knack for writing. He’s also taught programming to many graduates, helping them become better future developers."
    },
    {
        "link": "https://pypi.org/project/python-dateutil",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    }
]