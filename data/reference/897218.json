[
    {
        "link": "https://docs.oracle.com/javaee/7/tutorial/bean-validation-advanced001.htm",
        "document": "Bean Validation defines annotations, interfaces, and classes to allow developers to create custom constraints.\n\nUsing the Built-In Constraints to Make a New Constraint Bean Validation includes several built-in constraints that can be combined to create new, reusable constraints. This can simplify constraint definition by allowing developers to define a custom constraint made up of several built-in constraints that may then be applied to component attributes with a single annotation. This custom constraint can then be applied to an attribute.\n\nCustom constraints that can be applied to both return values and method parameters require a element to identify the target of the constraint. This constraint sets the target by default to the method parameters. In the preceding example, the target is set to the return value of the method."
    },
    {
        "link": "https://stackoverflow.com/questions/12920884/is-there-a-way-to-enforce-unique-constraint-on-a-property-field-other-than-the",
        "document": "DynamoDB is a key:value store. It is very good at quickly retrieving/saving Items because it does a couple of compromise. This is a constraint you have to handle yourself.\n\nNonethess, depending on your actual model, it might be a good idea to use this field as you or consider using a\n\nIf this is not possible, I advise you to de-normalize your data. You currently have something like:\n\nTo ensure unicity, add a new table with this schema:\n\nTo make sure an e-mail is unique, just issue a to before.\n\nThis kind of de-normalization is quite common with No-SQL databases."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/21/docs/api/allclasses-index.html",
        "document": "Deprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version.\n\nDeprecated, for removal: This API element is subject to removal in a future version."
    },
    {
        "link": "https://stackoverflow.com/questions/63501943/is-there-a-way-to-ensure-uniqueness-of-a-field-without-relying-on-database",
        "document": "NoSQL databases provide different, weaker, guarantees than relational databases. Generally, the tradeoff is you give up ACID guarantees in exchange for increased scalability in the dimensions that matter for your application.\n\nIt's possible to provide some kind of uniqueness guarantee, but subject to certain tradeoffs. With NoSQL, there are always tradeoffs.\n\nIf your NoSQL store supports optimistic concurrency control, maybe this approach will work:\n\nStore a separate document that contains the set of all values, across all documents in your NoSQL table. This is one instance of this document at a given time.\n\nEach time you want to save a document containing , first confirm email address uniqueness:\n\nPerform the following actions, protected by optimistic locking. You can on the backend if this due to a concurrent update:\n• If not present, add the email address to the \"all emails document\"\n\nYou've now traded one problem ... the lack of unique constraints, for another ... the inability to synchronise updates across your original document and this new \"all emails\" document. This may or may not be acceptable, it depends on the guarantees that your application needs to provide.\n\ne.g. Maybe you can accept that an email may be added to \"all emails\", that saving the related document to your other \"table\" subsequently fails, and that that email address is now not able to be used. You could clean this up with a batch job somehow. Not sure.\n\nThe index of emails could be stored in some other service (e.g. a persistent cache). The same problem exists, you need to keep the index and your document store in sync somehow.\n\nThere's no easy solution. For a detailed overview of the relevant concepts, I'd recommend Designing Data-Intensive Applications by Martin Kleppmann."
    },
    {
        "link": "https://dbeaver.com/docs/dbeaver/Implementing-Constraints",
        "document": "As you continue to explore the intricacies of table structures, understanding the role and functionality of constraints becomes essential. Constraints are rules that we apply to data columns in a table when we want to limit the type of data that can go into a table. This can help ensure the accuracy and reliability of our data.\n\nWhile creating constraints is not always necessary, it can be a powerful tool in the table creation process. Just like you create columns, you can also define constraints that uphold the integrity of your data. Constraints can be as simple as ensuring uniqueness in a column or as complex as a check expression that defines acceptable values for a column.\n\nIn this guide, you'll learn how to create, modify, and delete constraints, as well as how to customize their settings to suit your needs. You'll discover how to create primary keys, unique keys, and check expressions. You'll also learn about the restrictions and considerations you need to keep in mind when working with constraints.\n\nPrimary keys are a crucial part of your database structure, uniquely identifying each record in a table. When you define a primary key, the database ensures no duplicate values exist in the specified column(s), maintaining data integrity and improving performance. DBeaver simplifies this process, providing an intuitive interface for creating, modifying, and deleting primary keys.\n\nCreating a new primary key in DBeaver involves a series of steps that guide you through the process. Here's how you can do it:\n\n1) You can start the process of creating a new constraint in three ways:\n• None Using the Properties editor: Open the Properties Editor and navigate to the Constraints tab of the corresponding table. This is where you'll find all the existing constraints for the table and where you'll create new ones.\n• None Using the Database Navigator: Navigate to the database where the table you want to add a constraint to is located. Find and select the table for which you want to create a new constraint. Within the selected table, you'll find a folder named Constraints.\n• None You can also utilize the Create New Constraint button located at the bottom of the Properties editor.\n\n2) Depending on the method you chose in step 1, either right-click on the window (in the Properties Editor) or within the Constraints folder (in the Database Navigator), and select Create New Constraint. If you're using the third method, simply click the Create New Constraint button. This will open a new window where you'll be able to define the details of your new constraint.\n\n3) After selecting the column, click OK to save your new constraint. A window will appear displaying the newly created primary key. This is a good time to double-check that everything is correct.\n\nOnce you have configured the constraint properties, it is essential to save these changes to the database. Until you commit your modifications, the new constraint will only exist within DBeaver and will not be added to the actual database table. Here are three options for committing the changes:\n• Select the desired table in the Database Navigator and press (or for Mac OS), choose Persist to save the changes.\n• None Utilize the Save button located at the bottom of the Properties editor and press Persist to save the changes.\n\nTo modify an existing primary key, you need to first delete it and then add a new primary key with the updated parameters.\n\nNote: Remember, modifying primary keys should be done with care. Primary keys are integral to maintaining the integrity of your data, and changing them can have significant effects on your database. Always double-check your changes and make sure they align with your data requirements.\n\n1) You can delete a primary key either through the Properties Editor or the Database Navigator:\n• None Using the Properties Editor: Open the Properties Editor, navigate to the Constraints tab of the corresponding table, and find the constraint you want to delete.\n• None Using the Database Navigator: Navigate to the database where the table with the constraint is located. Find and select the constraint, open the Constraints folder, and find the constraint you want to delete.\n\n2) To delete a primary key, right-click on the key's name and select Delete, or you can select the necessary primary key and press the key, or Delete button (in the Bottom Menu of the Properties Editor).\n\n3) A confirmation dialog will appear, asking you to confirm the deletion. Before proceeding, ensure that you've selected the correct constraint for deletion.\n\n4) After confirming the deletion, you'll need to persist the changes to apply them to the database.\n\nImportant: Be particularly cautious if you're considering using the Cascade delete option. This option will not only delete the primary key but also any dependent records in your database. This can lead to significant data loss if not handled carefully.\n\nA unique key is a tool that ensures distinct values within a column or a group of columns in a table. While it can identify unique records, it doesn't have to be the primary key. You can create a unique key on a single column or multiple columns, ensuring that each value is unique. This is crucial for maintaining data integrity within your table. If you attempt to insert a duplicate value into a column with a unique key constraint, you'll encounter an error.\n\nThe processes of creating, deleting and modifying a unique key are similar to those for a primary key.\n\nA check expression in a database is also a constraint, it defines acceptable values for a column. It enforces specific conditions, ensuring that the data in the column complies with the defined rules. The processes of creating, deleting and modifying a check expression are similar to those for a primary key.\n\nFor instance, suppose you have a column named \"name\" and you want to ensure that its value is never an empty string. You could create a check expression as follows:\n\nThis would prevent any records from being inserted or updated with an empty string for the \"name\" column.\n\nNote: Check expressions are a powerful tool for maintaining data integrity. They enforce specific conditions on your data, preventing invalid entries. Always consider the implications of your actions when working with check expressions.\n\nWorking with constraints comes with certain restrictions that you need to be aware of. These restrictions are in place to maintain the integrity of your data and prevent unwanted changes. Here's what you need to know:\n• None Unique Values: When creating a primary key or unique constraint, the column(s) you choose must contain unique values. If there are duplicate values in the column(s), the constraint creation will fail.\n• None Null Values: Primary keys cannot contain null values. If the column(s) you choose for a primary key contains null values, you will need to either remove or replace these before creating the constraint. Unique constraints, on the other hand, typically allow for multiple null values.\n• None Data Type Compatibility: The type of constraint you want to create may have specific data type requirements. For example, check constraints require a Boolean expression, so the column(s) involved must be able to participate in such an expression.\n• None Existing Data Compliance: When creating a check constraint, all existing data in the table must comply with the check condition. If any rows violate the condition, the constraint creation will fail.\n• None Performance Impact: Creating constraints, especially on large tables, can have a performance impact. This is because the database needs to check the constraint condition for all existing rows. This might take considerable time and resources for large tables.\n• None Modifying Constraints: Constraints cannot be directly modified. This is because constraints are defined with specific parameters that can't be changed directly.\n• None Deleting Constraints with Dependencies: You can't delete a primary key in a table with records unless you first remove all dependent foreign keys. This is because the primary key is likely being referenced by these foreign keys, and deleting it would break these references and potentially cause data integrity issues."
    },
    {
        "link": "https://geeksforgeeks.org/queue-interface-java",
        "document": "The Queue Interface is present in java.util package and extends the Collection interface. It stores and processes the data in FIFO(First In First Out) order. It is an ordered list of objects limited to inserting elements at the end of the list and deleting elements from the start of the list.\n• No Null Elements do not allow null elements.\n• Use Cases : Commonly used for Task scheduling, Message passing, and Buffer management in applications.\n• Iteration : Supports iterating through elements. The order of iteration depends on the implementation.\n\nBeing an interface the queue needs a concrete class for the declaration and the most common classes are the PriorityQueue and LinkedList in Java. Note that neither of these implementations is thread-safe. PriorityBlockingQueue is one alternative implementation if the thread-safe implementation is needed.\n\nThe Queue interface is declared as:\n\nSince Queue is an interface, objects cannot be created of the type queue. We always need a class which extends this list in order to create an object. And also, after the introduction of Generics in Java 1.5, it is possible to restrict the type of object that can be stored in the Queue. This type-safe queue can be defined as:\n\nIn Java, the Queue interface is a subtype of the Collection interface and represents a collection of elements in a specific order. It follows the first-in, first-out (FIFO) principle, which means that the elements are retrieved in the order in which they were added to the queue.\n\nThe Queue interface provides several methods for adding, removing, and inspecting elements in the queue. Here are some of the most commonly used methods:\n• add(element) : Adds an element to the rear of the queue. If the queue is full, it throws an exception.\n• offer(element) : Adds an element to the rear of the queue. If the queue is full, it returns false.\n• remove() : Removes and returns the element at the front of the queue. If the queue is empty, it throws an exception.\n• poll() : Removes and returns the element at the front of the queue. If the queue is empty, it returns null.\n• element() : Returns the element at the front of the queue without removing it. If the queue is empty, it throws an exception.\n• peek() : Returns the element at the front of the queue without removing it. If the queue is empty, it returns null.\n\nThe Queue interface is implemented by several classes in Java, including LinkedList, ArrayDeque, and PriorityQueue. Each of these classes provides different implementations of the queue interface, with different performance characteristics and features.\n\nOverall, the Queue interface is a useful tool for managing collections of elements in a specific order, and is widely used in many different applications and industries.\n\nLet’s see how to perform a few frequently used operations on the queue using the Priority Queue class.\n\nIn order to add an element in a queue, we can use the add() method. The insertion order is not retained in the PriorityQueue. The elements are stored based on the priority order which is ascending by default.\n\nIn order to remove an element from a queue, we can use the remove() method. If there are multiple such objects, then the first occurrence of the object is removed. Apart from that, poll() method is also used to remove the head and return it.\n\nThere are multiple ways to iterate through the Queue. The most famous way is converting the queue to the array and traversing using the for loop. However, the queue also has an inbuilt iterator which can be used to iterate through the queue.\n\nThe following are the characteristics of the queue:\n• None The Queue is used to insert elements at the end of the queue and removes from the beginning of the queue. It follows FIFO concept.\n• None The Java Queue supports all methods of Collection interface including insertion, deletion, etc.\n• None are the most frequently used implementations.\n• None If any null operation is performed on BlockingQueues, NullPointerException is thrown.\n• None The Queues which are available in java.util package are Unbounded Queues.\n• None The Queues which are available in java.util.concurrent package are the Bounded Queues.\n• None All Queues except the Deques supports insertion and removal at the tail and head of the queue respectively. The Deques support element insertion and removal at both ends.\n\nPriorityQueue class which is implemented in the collection framework provides us a way to process the objects based on the priority. It is known that a queue follows the First-In-First-Out algorithm, but sometimes the elements of the queue are needed to be processed according to the priority, that’s when the PriorityQueue comes into play. Let’s see how to create a queue object using this class.\n\nLinkedList is a class which is implemented in the collection framework which inherently implements the linked list data structure. It is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses. Each element is known as a node. Due to the dynamicity and ease of insertions and deletions, they are preferred over the arrays or queues. Let’s see how to create a queue object using this class.\n\nIt is to be noted that both the implementations, the PriorityQueue and LinkedList are not thread-safe. PriorityBlockingQueue is one alternative implementation if thread-safe implementation is needed. PriorityBlockingQueue is an unbounded blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. \n\nSince it is unbounded, adding elements may sometimes fail due to resource exhaustion resulting in OutOfMemoryError. Let’s see how to create a queue object using this class.\n\nThe queue interface inherits all the methods present in the collections interface while implementing the following methods:\n\nThis method is used to add an element at a particular index in the queue. When a single parameter is passed, it simply adds the element at the end of the queue. This method is used to add all the elements in the given collection to the queue. When a single parameter is passed, it adds all the elements of the given collection at the end of the queue. This method is used to return the size of the queue. This method is used to remove all the elements in the queue. However, the reference of the queue created is still stored. This method is used to remove the element from the front of the queue. This method removes an element from the specified index. It shifts subsequent elements(if any) to left and decreases their indexes by 1. This method is used to remove and return the first occurrence of the given element in the queue. This method returns elements at the specified index. This method replaces elements at a given index with the new element. This function returns the element which was just replaced by a new element. This method returns the first occurrence of the given element or -1 if the element is not present in the queue. This method returns the last occurrence of the given element or -1 if the element is not present in the queue. This method is used to compare the equality of the given element with the elements of the queue. This method is used to return the hashcode value of the given queue. This method is used to check if the queue is empty or not. It returns true if the queue is empty, else false. This method is used to check if the queue contains the given element or not. It returns true if the queue contains the element. This method is used to check if the queue contains all the collection of elements. This method is used to sort the elements of the queue on the basis of the given This method is used to insert the specified element into a queue and return true upon success. This method is used to insert the specified element into the queue. This method is used to retrieve and removes the head of the queue, or returns null if the queue is empty. This method is used to retrieves, but does not remove, the head of queue. This method is used to retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.\n\nAdvantages of using the Queue Interface in Java\n• Order preservation : The Queue interface provides a way to store and retrieve elements in a specific order, following the first-in, first-out (FIFO) principle.\n• Flexibility : The Queue interface is a subtype of the Collection interface, which means that it can be used with many different data structures and algorithms, depending on the requirements of the application.\n• Thread safety : Some implementations of the Queue interface, such as the java.util.concurrent.ConcurrentLinkedQueue class, are thread-safe, which means that they can be accessed by multiple threads simultaneously without causing conflicts.\n• Performance : The Queue interface provides efficient implementations for adding, removing, and inspecting elements, making it a useful tool for managing collections of elements in performance-critical applications.\n\nDisadvantages of using the Queue Interface in Java\n• Limited functionality: The Queue interface is designed specifically for managing collections of elements in a specific order, which means that it may not be suitable for more complex data structures or algorithms.\n• Size restrictions: Some implementations of the Queue interface, such as the ArrayDeque class, have a fixed size, which means that they cannot grow beyond a certain number of elements.\n• Memory usage: Depending on the implementation, the Queue interface may require more memory than other data structures, especially if it needs to store additional information about the order of the elements.\n• Complexity : The Queue interface can be difficult to use and understand for novice programmers, especially if they are not familiar with the principles of data structures and algorithms."
    },
    {
        "link": "https://baeldung.com/java-queue",
        "document": "In this tutorial, we’ll be discussing Java’s Queue interface.\n\nFirst, we’ll take a peek at what a Queue does, and some of its core methods. Next, we’ll dive into a number of implementations that Java provides as standard.\n\nFinally, we’ll talk about thread safety before wrapping it all up.\n\nImagine we’ve just opened our first business – a hot dog stand. We want to serve our new potential clients in the most efficient way possible for our small business; one at a time. First, we ask them to form an orderly line in front of our stand, with new customers joining at the rear. Thanks to our organization skills, we can now distribute our tasty hot dogs in a fair way.\n\nQueues in Java work in a similar way. After we declare our Queue, we can add new elements to the back, and remove them from the front.\n\nIn fact, most Queues we’ll encounter in Java work in this first in, first out manner – often abbreviated to FIFO.\n\nHowever, there’s one exception that we’ll touch upon later.\n\nThe Queue declares a number of methods that need to be coded by all implementing classes. Let’s outline a few of the more important ones now:\n• offer() – Inserts a new element onto the Queue\n• poll() – Removes an element from the front of the Queue\n• peek() – Inspects the element at the front of the Queue, without removing it\n\nAbstractQueue is the simplest possible Queue implementation that Java provides. It includes a skeletal implementation of some of the Queue interface’s methods, excluding offer.\n\nWhen we create a custom queue extending the AbstractQueue class, we must provide an implementation of the offer method which does not allow the insertion of null elements.\n\nAdditionally, we must provide the methods peek, poll, size, and java.util‘s iterator.\n\nFirst, let’s define our class with a LinkedList to store our Queue’s elements:\n\nNext, let’s override the required methods and provide the code:\n\nExcellent, let’s check that it works with a quick unit test:\n\nGenerally, the Queue interface is inherited by 3 main sub-interfaces. Blocking Queues, Transfer Queues, and Deques.\n\nTogether, these 3 interfaces are implemented by the vast majority of Java’s available Queues. Let’s take a quick look at what these interfaces have been set out to do.\n\nThe BlockingQueue interface supports additional operations which force threads to wait on the Queue depending on the current state. A thread may wait on the Queue to be non-empty when attempting a retrieval, or for it to become empty when adding a new element.\n\nFor more information, head over to our article on Blocking Queues.\n\nThe TransferQueue interface extends the BlockingQueue interface but is tailored toward the producer-consumer pattern. It controls the flow of information from producer to consumer, creating backpressure in the system.\n\nJava ships with one implementation of the TransferQueue interface, LinkedTransferQueue.\n\nDeque is short for Double-Ended Queue and is analogous to a deck of cards – elements may be taken from both the start and end of the Deque. Much like the traditional Queue, the Deque provides methods to add, retrieve and peek at elements held at both the top and bottom.\n\nFor a detailed guide on how the Deque works, check out our ArrayDeque article.\n\nWe saw earlier that most of the Queues that we come across in Java follow the FIFO principle.\n\nOne such exception to this rule is the PriorityQueue. When new elements are inserted into the PriorityQueue, they are ordered based on their natural ordering, or by a defined Comparator provided when we construct the PriorityQueue.\n\nLet’s take a look at how this works with a simple unit test:\n\nDespite the order in which our integers were added to the PriorityQueue, we can see that the retrieval order is changed according to the natural order of the numbers.\n\nWe can see that the same is also true when applied to Strings:\n\nAdding items to Queues is particularly useful in multi-threaded environments. A Queue can be shared amongst threads, and be used to block progress until space is available – helping us overcome some common multi-threaded problems.\n\nFor example, writing to a single disk from multiple threads creates resource contention and can lead to slow writing times. Creating a single writer thread with a BlockingQueue can alleviate this issue and lead to vastly improved write speeds.\n\nLuckily, Java offers ConcurrentLinkedQueue, ArrayBlockingQueue, and ConcurrentLinkedDeque which are thread-safe and perfect for multi-threaded programs.\n\nIn this tutorial, we’ve taken a deep dive into the Java Queue interface.\n\nFirstly, we explored what a Queue does, as well as the implementations that Java provides.\n\nNext, we looked at a Queue’s usual FIFO principle, as well as the PriorityQueue which differs in its ordering.\n\nFinally, we explored thread safety and how Queues can be used in a multi-threaded environment."
    },
    {
        "link": "https://codegym.cc/groups/posts/java-queue-interface-and-implementations",
        "document": "\n• – inserts a new element into the queue if it is possible\n• – inserts a new element into the queue if it is possible. Returns true in case of success and throws an IllegalStateException if there is no space.\n• – retrieves and removes an element from the head of the. Returns null if the queue is empty.\n• – retrieves and removes an element from the head of the queue.\n• – retrieves, but doesn’t remove an element from the head of the queue. Returns null if the queue is empty.\n• – retrieves, but doesn’t remove an element from the head of the queue.\n• thread is trying to get elements from an empty queue\n• thread is trying to put elements in the full queue\n• according to Queue Java 8 docs, this abstract class provides basic implementations of some Queue operations. It doesn’t allow null elements. There are 3 more methods add, remove, and element based on Queue classical , , and , respectively. However they throw exceptions instead of indicating failure via false or null returns.\n• — the concurrent implementation of the Deque interface.\n• — doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null)\n• — a blocking queue where each insert operation must wait for a corresponding remove operation by another thread, and vice versa.\n• add(E element) Appends the specified element to the end of this list;\n• add(int index, E element) Inserts the element at the specified position index;\n• get(int index) Returns the element at the specified position in this list;\n• remove(int index) Removes the element that is at position index;\n• remove(Object o) Removes the first occurrence of ?o element from this list if it is there.\n• remove() Retrieves and removes the first element of the list.\n• addFirst(), addLast() add an element to the beginning/end of a list\n• clear() removes all elements from the list\n• contains(Object o) returns true if the list contains the o element.\n• indexOf(Object o) returns the index of the first occurrence of the o element, or -1 if it isn’t in the list.\n• set(int index, E element) replaces the element at index position with the element\n• size()Returns the quantity of elements in the list.\n• toArray() returns an array containing all list’s elements from first to the last element.\n• pop() that pops an element from the stack (represented by the list)\n• push(E e) that pushes an element onto the stack (represented by this list)\n• inserts the specified element into the priority queue. Returns true in case of success. If the queue is full, the method throws an exception.\n• inserts the specified element into this priority queue. If the queue is full, the method returns false.\n• removes a single instance of the specified element from this queue, if it is present.\n• retrieves and removes the head of this queue. Returns null if the queue is empty.\n• removes all elements from the priority queue.\n• retrieves the head of this queue without removing it. Throws NoSuchElementException if the queue is empty.\n• retrieves the head of the queue without removing it. Returns null if the queue is empty.\n• returns true if the queue contains the o element.\n• returns the number of elements in this queue.\n• creates a queue of fixed capacity and with a default access policy.\n• creates a queue with a fixed capacity and a specified access policy.\n• creates a queue with a fixed capacity specified by the access policy and includes elements in the queue.\n\nTo reinforce what you learned, we suggest you watch a video lesson from our Java Course\n\nAdvantages of Using the Queue Interface\n\nHere we are going to discuss the Java Queue interface. You’ll find out what Queue data structure is, how it is represented in Java, what methods are the most important for all queues. Also, what implementations of Queue are in Java language. After that, we take a closer look at the most important implementations and learn them with examples.A Queue is a linear abstract data structure with the particular order of performing operations — First In First Out (FIFO). That means you can add an element (or enqueue, put in the queue) only at the end of the structure, and take an element (dequeue or remove from the queue) only from its beginning. You may imagine Queue data structure very easily. It seems like a queue or a line of customers in real life. The customer that came first, is going to be served first as well. If you have four people in line in McDonalds or elsewhere, the first to line up will be the first to get the store. If the new customer comes, he/she will be the 5th in line to get hamburgers. So, while working with a queue, new elements are added to the end, and if you want to get an element, it will be taken from the beginning. This is the main principle of classical queue data structure work.Queue in Java is an interface. According to Oracle documentation, Queue interface has 2 superinterfaces, 4 different interfaces that inherit from the queue, and an extremely impressive list of classes.What does it mean? First of all, Java Queue is a part of the Collection Framework and implements Collection interface. So it supports all methods of Collection interface such as insertion, deletion and so on. Queue implements Iterable interface, that allows an object to be the target of the \"for-each loop\" statement.The Queue declares a number of methods. As interface’s methods they should be represented in all classes that implement Queue. The most important Queue Methods, Java:Queue interface is inherited by 4 subinterfaces –. You may divide them into 3 groups: Deques, Blocking Queues and Transfer Queues with BlockingDeque belonging to the two first. Let's take a glimpse at these groups.Deque meansouble-ndedueue and supports addition or removal from either tail of the data as a queue (first-in-first-out/FIFO) or from the head as another popular data structure called(last-in-first-out/LIFO).ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque, LinkedList.A blocking queue is a queue that blocks a thread in two cases:When a thread tries to get items from an empty queue, it waits until some other thread puts the items into the queue. Similarly, when a thread tries to put elements into a full queue, it waits until some other thread takes the elements out of the queue to get free space for the elements. Sure, the concept of \"full queue\" implies that the queue has a limited size, which is usually specified in the constructor. Standard Blocking Queues include LinkedBlockingQueue, SynchronousQueue, and ArrayBlockingQueue. Implementing classes ofinterface: ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue.is a subinterface for BlockingQueue. BlockingDeque such as BlockingQueue is a blocking queue, but bidirectional. So it inherits the properties of the Deque interface. It is oriented to multi-threaded execution, doesn’t allow zero elements and capacity could be limited. Implementations of the BlockingDeque interface block the operation of getting elements if the queue is empty, and adding an element into the queue if it is full.TransferQueue interface extends BlockingQueue interface. However unlike the implementation of BlockingQueue interface queues, where threads can be blocked if the queue is empty (reading), or if the queue is full (writing), TransferQueue interface queues block the write stream until another stream retrieves the element. Use a transfer method for this. In other words, the implementation of BlockingQueue guarantees that the element created by the Producer must be in the queue, while the implementation of TransferQueue guarantees that the Producer element is \"received\" by the Consumer. There is only one official Java implementation of TransferQueue interface — LinkedTransferQueue.There are many classes that implement Queue interface:The most popular implementations are LinkedList, ArrayBlockingQueue and PriorityQueue. Let’s look at them and do some examples for better understanding.Class LinkedList in Java implements List and Deque interfaces. So, it is a combination of List and Deque, a two-way queue, that supports adding and removing elements from both sides. In Java LinkedList is doubly-linked List: every element of List calls Node and contains an object and references to two neighboring objects — the previous and the next.You may say that LinkedList isn’t very effective in terms of using memory. That’s true, but this data structure can be useful in case of the insert and delete operations performance. However it happens only if you use iterators for them (in this case it occurs in constant time). Access operations by index are performed by searching from the beginning of the end (whichever is closer) to the desired element. However, don’t forget about additional costs for storing references between elements. So, LinkedList is the most popular queue implementation in Java. It is an implementation of List and Deque as well and it allows us to create a bidirectional queue consisting of any objects including null. LinkedList is a collection of elements.without parameters is used to construct an empty list.is for creating a list containing the elements of the specified collection, in order, they are returned by the collection's iterator.Java Queue Example — LinkedList (putting and removing elements in different ways)PriorityQueue is not exactly the queue in FIFO general meaning. The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. However it is not an order like it could be in linear structure such as list (from the biggest to the smallest or vice versa). A priority queue based on a priority min heap. Heap is a data structure based on binary tree . The priority of each parent is greater than the priorities of its children. A tree is called complete binary if each parent has no more than two children, and the filling of the levels goes from top to bottom (from the same level — from left to right). Binary heap reorganises itself every time a new element is added or removed from it. In case of min-heap, the smallest element goes to the root regardless of the order of its insertion. Priority queue based on this min-heap, so if we have a PriorityQueue of integers, its first element will be the smallest of these numbers. If you delete the root, the next smallest becomes a root.It is important to understand that priority queues are based on binary heaps, so they do not keep elements in linear sorted order. Every way from the root to the leaf is ordered, but different ways from the root are not. That means you can get the minimal element of the queue very quickly. If you delete the head every time, you’ll print a sorted structure.Internal data structure ofis based on a circular array to store elements. It is a typical queue (FIFO) in case new elements are inserted at the tail of the queue, and extraction operations return an element from the head of the queue.Once created queue capacity cannot be changed. Attempts to insert (put) an element into a full queue lead to blocking the flow; trying to take an element from an empty queue also blocks the thread. As we said before, this array is circular. That means that the first and the last elements of the array are treated logically adjacent. The queue advances the indices of the head and tail elements every time you put the elemento into the queue or remove it from the queue. If some index advances the last element of the array, it restarts from 0. Hence, the queue doesn’t have to shift all the elements in case of the head removing (as in usual array). However, in case of removing an element from the middle (using Iterator.remove), the elements are shifted.supports an additional fairness policy withparameter in the constructor to order the work of waiting flows of producers (inserting elements) and consumers (extracting elements). By default, the order is not guaranteed. However if the queue is created with \"fair == true\", the implementation of the ArrayBlockingQueue class provides thread access in FIFO order. Equity typically reduces bandwidth, but also reduces volatility and prevents running out of resources.Here we’ve got the BlockingQueueExample example. We create a queue of the ArrayBlockingQueue with a capacity of one element and a fair flag. Two threads are started. The first of them, Producer thread, queues messages from the messages array using the put method. The second one, Consumer, thread reads elements from the queue usingmethod and displays them in the console. The order of elements is the natural one for the queue.The output is the queue in natural order; the first two elements appear with a delay.\n\nQueues are more than just a line of people at a coffee shop. In Java, they serve a powerful role in managing data. Let’s check out why queues can be a fantastic choice in your programs!\n\nThe most defining feature of a queue is its FIFO structure. This means the first element added is the first one to be removed. It’s perfect for tasks that need to process data in the exact order it arrives. Think of task scheduling or printer jobs—whoever gets in line first gets served first!\n\nQueues offer constant-time performance for adding and removing elements. Unlike arrays or lists, you don’t need to shift elements around. This makes queues highly efficient for managing large streams of data.\n\nIn multithreaded applications, queues shine! They help manage data between threads, ensuring safe and organized processing. For example, one thread can produce data while another consumes it—queues handle this beautifully.\n\nJava offers several queue implementations tailored for different needs:\n\nDisadvantages of Using the Queue Interface\n\nBut hey, no data structure is perfect, right? Let’s talk about some of the limitations you might face when using queues.\n\nNeed to access a specific element in the middle of the queue? Tough luck! Queues don’t support random access like arrays or lists. You can only access the front and back elements. So, if you need quick access to arbitrary elements, a queue might not be the best fit.\n\nSome queue implementations (like ) can use more memory than arrays due to node pointers. If memory efficiency is a top priority, you might want to consider alternatives like .\n\nBy default, many queue implementations (like or ) are not thread-safe. If you need concurrency support, you'll need to use thread-safe versions like or wrap your queue using .\n\nWhy Choose a Queue Over Other Data Structures?\n\nOkay, so why use a queue instead of an array or a list? Great question!\n\nQueues are the perfect fit for tasks that need to be processed in order. If your program involves scheduling, buffering, or task execution, a queue should be your go-to structure.\n\nQueues offer O(1) performance for adding and removing elements, making them more efficient than lists for sequential processing. No shifting or reordering needed!\n\nFlexible Variants for Different Needs\n\nJava's queue implementations cater to various needs:\n• The Queue is used to insert elements at the end of the queue and removes from the beginning of the queue. It follows the FIFO concept.\n• Java Queue is a part of the Collection Framework and implements Collection interface. So it supports all methods of Collection interface such as insertion, deletion and so on.\n• The most frequently used implementations of Queue are LinkedList, ArrayBlockingQueue and PriorityQueue.\n• The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.\n• If any null operation is performed on BlockingQueues, NullPointerException is thrown."
    },
    {
        "link": "https://mygreatlearning.com/blog/java-queue-interface",
        "document": "Efficient data management is a crucial aspect of programming, particularly when dealing with large amounts of data or implementing algorithms that require organized data processing. The Java Queue Interface provides a powerful tool for managing data in a first-in, first-out (FIFO) manner, enabling efficient data manipulation and synchronization. Understanding the Java Queue Interface and its purpose is essential for developers looking to optimize their data handling processes and improve overall program efficiency.\n\nThe Java Queue Interface serves as a blueprint for implementing queues, which are data structures that follow the FIFO principle. In a queue, elements are added at the end and removed from the front, simulating a real-life queue of people waiting in line. This ordering mechanism ensures that the first element enqueued is the first to be dequeued, making it ideal for scenarios where strict ordering and sequence maintenance are necessary.\n\nBy utilizing the Java Queue Interface, developers can benefit from several advantages. The interface provides a standardized set of methods for manipulating and accessing elements in a queue, simplifying the implementation process. The Queue interface allows for the use of different queue implementations, such as LinkedList or ArrayDeque, depending on specific requirements and performance considerations. This flexibility enables developers to choose the most suitable implementation for their use case, balancing factors such as memory usage and speed of operations. The Java Queue Interface provides a convenient and efficient solution for managing data in a FIFO manner, ensuring smooth and organized data processing in various applications.\n\nBy understanding the intricacies of the Queue interface and harnessing its capabilities, developers can streamline their data management processes and enhance the efficiency of their Java programs.\n\nA queue is a fundamental data structure that follows the First-In, First-Out (FIFO) principle. It behaves like a real-life queue or line, where the first person who joins the line is the first one to be served. In Java, the Queue interface defines the methods and behaviors required for implementing a queue data structure efficiently.\n\nThe Queue interface provides several methods for data manipulation and retrieval. One of the key methods is the add() method, which adds an element to the back of the queue. The queue throws an exception, if it is full. Another method is offer(), which adds an element to the back of the queue and returns true if successful. If the queue is full, it returns false instead of throwing an exception. The remove() method removes and returns the element at the front of the queue, throwing an exception if the queue is empty. Similarly, the poll() method removes and returns the element at the front of the queue, but returns null if the queue is empty. These methods allow for efficient insertion and removal of elements in the queue, ensuring proper ordering based on the FIFO principle.\n\nThe FIFO principle is a key characteristic of the queue data structure. It ensures that the first element added to the queue is the first one to be removed. This ordering is crucial in scenarios where strict sequence maintenance is required, such as task scheduling, event handling, or message processing systems. The Queue interface enforces this principle, providing a reliable mechanism for managing data in the desired order.\n\nBy utilizing the Queue interface in Java, developers can efficiently manage data and ensure synchronized processing. The interface allows for easy implementation of queues, and it provides a consistent set of methods across different queue implementations. This standardization simplifies code development and maintenance, as developers can rely on the defined methods and behaviors of the Queue interface. Whether using LinkedList, ArrayDeque, or other implementations, developers can seamlessly switch between them without impacting the overall functionality of their programs.\n\nThe Java Queue interface is implemented by several classes that provide different underlying data structures for efficient data management. Two commonly used implementations are LinkedList and ArrayDeque.\n\nLinkedList is a doubly-linked list implementation that offers flexibility in adding and removing elements at both ends of the list. It implements the Queue interface and provides all the required methods for efficient queue operations. To create a LinkedList-based queue object, you can instantiate it as follows:\n\nOn the other hand, ArrayDeque is a resizable-array implementation that provides efficient operations at both ends of the queue. It is a high-performance alternative to the LinkedList implementation, particularly when the queue size is known in advance or requires efficient random access. To create an ArrayDeque-based queue object, you can instantiate it as follows:\n\nOnce the queue object is created, you can perform various queue operations using the implemented classes. The common operations include adding elements to the queue using the add() or offer() method, retrieving and removing elements from the front of the queue using the remove() or poll() method, and accessing the front element of the queue without removing it using the element() or peek() method.\n\nHere’s an example that demonstrates basic queue operations using a LinkedList-based queue:\n\nThe above example creates a LinkedList-based queue, adds three elements to it, retrieves the front element using peek(), removes an element using poll(), and prints the updated queue.\n\nBy utilizing the implemented classes and their respective methods, developers can easily create and manipulate queues in Java. The choice between LinkedList and ArrayDeque depends on the specific requirements of the application, such as the need for random access, size constraints, or performance considerations. It is important to select the appropriate implementation based on the characteristics of the data and the desired performance trade-offs.\n\nThe Java Queue interface provides a set of common methods that facilitate efficient data management and synchronization. These methods enable developers to perform various operations on the queue, such as adding, removing, retrieving, and checking the state of elements. Let’s explore these methods in detail:\n• Enqueuing elements using the add() and offer() methods:\n• The add(element) method adds the specified element to the end of the queue. If the queue has a maximum capacity and is full, it throws an IllegalStateException.\n• The offer(element) method adds the specified element to the end of the queue and returns true if the operation is successful. If the queue is full, it returns false.\n• Dequeuing elements using the remove() and poll() methods:\n• The remove() method removes and returns the head element of the queue. If the queue is empty, it throws a NoSuchElementException.\n• The poll() method removes and returns the head element of the queue. The queue returns null if it is empty.\n• Retrieving the head element using the element() and peek() methods:\n• The element() method retrieves and returns the head element of the queue without removing it. If the queue is empty, it throws a NoSuchElementException.\n• The peek() method retrieves and returns the head element of the queue without removing it. The queue returns null if it is empty.\n• Exploring additional methods for checking the size, emptiness, and containment of elements in the queue:\n• The size() method returns the number of elements in the queue.\n• The isEmpty() method checks if the queue is empty and returns true if it is, or false otherwise.\n• The contains(element) method checks if the queue contains the specified element and returns true if it does, or false otherwise.\n\nThese methods provide essential functionality for managing elements in the queue efficiently. It’s important to choose the appropriate method based on the specific requirements of your application. The add() and remove() methods are preferred when dealing with a bounded queue, while the offer() and poll() methods are more suitable for an unbounded queue, as they return false or null instead of throwing exceptions when the queue is full or empty.\n\nBy leveraging these methods, developers can perform enqueue and dequeue operations, retrieve the head element, check the size and emptiness of the queue, and determine if a specific element is present. These capabilities are crucial for building robust and efficient applications that involve data management and synchronization.\n\nIn a multi-threaded environment, it is essential to ensure that queue operations are synchronized to avoid data inconsistencies and race conditions. When multiple threads concurrently access and modify the same queue, synchronization mechanisms are required to maintain data integrity. Let’s delve into this topic in more detail:\n• Explanation of the need for synchronization when working with queues in a multi-threaded environment:\n• In a multi-threaded environment, threads can concurrently perform enqueue and dequeue operations on a shared queue.\n• Without proper synchronization, race conditions can occur, leading to data corruption and unexpected behavior.\n• Synchronization ensures that only one thread can access and modify the queue at a time, preventing data inconsistencies.\n• Overview of the synchronized and concurrent implementations of the Queue interface:\n• The Java Queue interface does not provide inherent thread safety.\n• To achieve synchronization, developers can use the synchronized keyword to protect critical sections of code that access the queue.\n• Alternatively, Java provides concurrent implementations of the Queue interface, such as ConcurrentLinkedQueue and LinkedBlockingQueue, which offer built-in thread safety.\n• Discussion of thread-safe queue operations and the use of locks and concurrent data structures:\n• Thread-safe implementations of the Queue interface, like ConcurrentLinkedQueue and LinkedBlockingQueue, use advanced synchronization techniques, such as locks and concurrent data structures.\n• These implementations ensure that enqueue and dequeue operations are atomic and maintain consistency in a multi-threaded environment.\n• By utilizing locks or concurrent data structures, concurrent queues allow multiple threads to access and modify the queue concurrently without compromising data integrity.\n\nWhen working with queues in a multi-threaded environment, it is crucial to consider the synchronization requirements and choose an appropriate implementation. If the application demands high concurrency and scalability, concurrent implementations like ConcurrentLinkedQueue and LinkedBlockingQueue are preferred. On the other hand, if you need to synchronize queue operations explicitly, you can use the synchronized keyword to protect critical sections of code.\n\nSelecting the appropriate queue implementation for your specific use case is crucial to ensure optimal performance and meet the requirements of your application. Let’s explore the factors to consider and compare different queue implementations:\n• Comparison of different queue implementations based on performance, memory usage, and specific use cases:\n• LinkedList: LinkedList is a basic implementation of the Queue interface that offers flexibility in adding and removing elements. It performs well for small-sized queues but may exhibit slower performance for larger queues due to its linear time complexity for certain operations.\n• ArrayDeque: ArrayDeque is a highly efficient implementation that offers constant time complexity for most operations. It is suitable for both small and large-sized queues and provides a good balance between performance and memory usage.\n• ConcurrentLinkedQueue: ConcurrentLinkedQueue is a concurrent implementation that provides high scalability and thread-safety for concurrent access. It is ideal for scenarios with high concurrency and where thread safety is a critical requirement.\n• LinkedBlockingQueue: LinkedBlockingQueue is a blocking implementation that offers both thread-safety and blocking capabilities. It is suitable for scenarios where blocking operations are needed, such as producer-consumer patterns.\n• Factors to consider when selecting a queue implementation:\n• Performance: Consider the expected workload and the performance characteristics of the queue implementation. Choose an implementation that offers efficient enqueue and dequeue operations based on your specific requirements.\n• Memory usage: Evaluate the memory overhead of different implementations. Some implementations may have higher memory usage due to additional data structures used for synchronization or blocking operations.\n• Thread-safety requirements: Determine whether your application requires thread-safe queue operations. If so, choose a concurrent or blocking implementation that provides built-in thread safety.\n• Specific use cases: Consider the specific requirements of your application. For example, if you need a queue that supports both FIFO and LIFO (Last-In-First-Out) operations, you may opt for a double-ended queue implementation like ArrayDeque.\n\nBy carefully analyzing and considering these factors, you can choose the right queue implementation that aligns with the performance, memory usage, thread-safety, and specific use cases of your application.\n\nBest Practices for Using the Queue Interface\n\nTo maximize the efficiency and effectiveness of your queue operations in Java programming, it’s essential to follow certain best practices. Let’s explore some guidelines, tips, and considerations for using the Queue interface:\n• Guidelines for efficient and effective use of queues in Java programming:\n• Use the appropriate queue implementation based on your specific requirements. Consider factors such as performance, thread-safety, and blocking capabilities.\n• Choose the correct data types for the elements in the queue to ensure type safety and maintain data integrity.\n• Initialize the queue with an initial capacity if you have an estimate of the expected number of elements. This can help prevent unnecessary resizing operations.\n• Avoid unnecessary operations like unnecessary enqueue or dequeue operations, which can impact performance. Only perform operations when needed.\n• Use proper synchronization techniques when working with shared queues in a multi-threaded environment to ensure thread-safety.\n• Minimize the use of expensive operations like resizing the underlying data structure by allocating sufficient initial capacity.\n• Use the appropriate methods for your specific use case. For example, if you need to retrieve the head element without removing it, use the peek() method instead of poll() or remove().\n• Batch process queue operations whenever possible to reduce the overhead of individual enqueue or dequeue operations.\n• Be mindful of the ordering of elements in the queue. Ensure that the desired ordering is maintained and adjust your operations accordingly.\n• Avoid unnecessary conversions or transformations of queue elements unless required. Unnecessary operations can introduce additional overhead.\n• Considerations for choosing appropriate data types and handling exceptions:\n• Select data types that accurately represent the elements you intend to store in the queue. Use generics to ensure type safety and avoid type-casting issues.\n• Handle exceptions appropriately when working with blocking or concurrent queue implementations. Understand the exceptions thrown by different methods and handle them gracefully.\n• Consider the size and memory usage of the elements in the queue. Avoid storing excessively large objects or unnecessary data to optimize memory utilization.\n\nBy following these best practices, you can streamline your queue operations, optimize performance, and avoid common pitfalls. Remember to choose the appropriate queue implementation, utilize the right methods, and handle exceptions effectively to ensure efficient and effective data management and synchronization.\n\nCheck out this Advanced Certificate Program in Full Stack Software Development – your ticket to an exciting career. Whether you’re a beginner or want to level up your skills, this program equips you with what you need for success.\n\nThe Java Queue interface is a fundamental component of efficient data management and synchronization in Java programming. Its intuitive methods and various implementations make it a versatile tool for handling data in a first-in, first-out manner. By embracing the Queue interface and incorporating it into your programming practices, you can enhance your code’s performance, maintainability, and overall quality.\n\nExplore a selection of courses in software development that can pave the way for a dynamic career in this captivating domain. These courses are meticulously crafted to impart the fundamental skills required in the industry. Embark on your path to a thriving software development career today!"
    },
    {
        "link": "https://codejava.net/java-core/collections/java-queue-collection-tutorial-and-examples",
        "document": "This Java Queue tutorial helps you understand the concepts and be able to use Queue implementations (LinkedList, PriorityQueue, Deque...) in the Java Collections Framework. Here’s the table content of this tutorial:\n\n2. Adding New Elements to the Queue\n\n3. Removing the Head of the Queue\n\n4. Examining the Head of the Queue\n\n5. Iterating over Elements in the Queue\n\nQueue means ‘waiting line’, which is very similar to queues in real life: a queue of people standing in an airport’s check-in gate; a queue of cars waiting for green light in a road in the city; a queue of customers waiting to be served in a bank’s counter, etc.\n\nIn programming, queue is a data structure that holds elements prior to processing, similar to queues in real-life scenarios. Let’s consider a queue holds a list of waiting customers in a bank’s counter. Each customer is served one after another, follow the order they appear or registered. The first customer comes is served first, and after him is the 2nd, the 3rd, and so on. When serving a customer is done, he or she lefts the counter (removed from the queue), and the next customer is picked to be served next. Other customers come later are added to the end of the queue. This processing is called First In First Out or FIFO.\n\nDuring the processing, the queue can be dynamically changed, i.e. processed elements are removed from the queue, and new elements are added to the queue.\n\nIn the Java Collections Framework, Queueis the main interface, and there are four sub interfaces: Deque, BlockingDeque, BlockingQueue, and TransferQueue.\n\nExcept the Deque interface which is in the java.util package, all others are organized in the java.util.concurrent package, which is designed for multi-threading or concurrent programming.\n\nBasically, a queue has a head and a tail. New elements are added to the tail, and to-be-processed elements are picked from the head. The following picture illustrates a typical queue:\n\nElements in the queue are maintained by their insertion order. The Queue interface abstracts this kind of queue.\n\nAnother kind of queue is double ended queue, or deque. A deque has two heads, allowing elements to be added or removed from both ends. The following picture illustrates this kind of queue:\n\nThe Deque interface abstracts this kind of queue, and it is a sub interface of the Queue interface. And the LinkedList class is a well-known implementation.\n\nSome implementations accept null elements, some do not.\n\nQueue does allow duplicate elements, because the primary characteristic of queue is maintaining elements by their insertion order. Duplicate elements in terms of equals contract are considered distinct in terms of queue, as there is no two elements having same ordering.\n\nAdditionally, the Java Collection Framework provides the BlockingQueue interface that abstracts queues which can be used in concurrent (multi-threading) context.\n\nA blocking queue waits for the queue to become non-empty when retrieving an element, and waits for space become available in the queue when storing an element.\n\nSimilarly, the BlockingDeque interface is blocking queue for double ended queues.\n\nDue to Queue’s nature, the key operations that differentiate Queue from other collections are extraction and inspection at the head of the queue.\n\nFor deques, the extraction and inspection can be processed on both ends.\n\nAnd because the Queue interface extends the Collection interface, all Queue implementations provide core operations of a collection like add(), contains(), remove(), clear(), isEmpty(), etc.\n\nAnd keep in mind that, with queues, operations on the head are fastest (e.g. offer() and remove()), whereas operations on middle elements are slow (e.g. contains(e) and remove(e)).\n\nQueue is the super interface of the queue branch in the Java Collection Framework. Under it, there are the following sub interfaces:\n• : abstracts a queue that has two heads. A deque allows adding or removing elements at both ends.\n• : abstracts a type of queues that waits for the queue to be non-empty when retrieving an element, and waits for space to become available in the queue when storing an element.\n• : is similar to , but for double ended queues. It is sub interface of the .\n\nAnd since Java 7, the BlockingQueue interface has a new sub interface called TransferQueue, which is a specialized BlockingQueue, which waits for another thread to retrieve an element in the queue.\n\nThe Java Collection framework provides many implementations, mostly for the BlockingQueue interface. Below I name few which are used commonly.\n\nQueue implementations are grouped into two groups: general-purpose and concurrent implementations.\n\n+ LinkedList: this class implements both List and Deque interface, thus having hybrid characteristics and behaviors of list and queue. Consider using a LinkedList when you want fast adding and fast removing elements at both ends, plus accessing elements by index.\n\n+ PriorityQueue: this queue orders elements according to their natural ordering, or by a Comparator provided at construction time. Consider using a PriorityQueue when you want to take advantages of natural ordering and fast adding elements to the tail and fast removing elements at the head of the queue.\n\n+ ArrayDeque: a simple implementation of the Deque interface. Consider using an ArrayDeque when you want to utilize features of a double ended queue without list-based ones (simpler than a LinkedList).\n\n+ ArrayBlockingQueue: this is a blocking queue backed by an array. Consider using an ArrayBlockingQueue when you want to use a simple blocking queue that has limited capacity (bounded).\n\n+ PriorityBlockingQueue: Use this class when you want to take advantages of both PriorityQueue and BlockingQueue.\n\n+ DelayQueue: a time-based scheduling blocking queue. Elements added to this queue must implement the Delayed interface. That means an element can only be taken from the head of the queue when its delay has expired.\n\nBecause the Queue interface extends the Collection interface, all Queue implementations have basic operations of a collection:\n\nBasically, Queue provides three primary types of operations which differentiate a queue from others:\n• Insert: adds an element to the tail of the queue.\n• Remove: removes the element at the head of the queue.\n• Examine: returns, but does not remove, the element at the head of the queue.\n\nAnd for each type of operation, there are two versions:\n• The first version throws an exception if the operation fails, e.g. could not add element when the queue is full.\n• The second version returns a special value (either null or false, depending on the operation).\n\nThe following table summarizes the main operations of the Queue interface:\n\nAs you know, the Deque interface abstracts a double ended queue with two ends (first and last), so its API is structured around this characteristic.\n\nA Deque implementation provides the xxxFirst() methods that operate on the first element, and the xxxLast() methods that operate on the last element.\n\nThe following table summarizes the API structure of Deque:\n\nA blocking queue is designed to wait for the queue to become non-empty when retrieving an element (the put(e) method), and wait for space to become available in the queue when storing an element (the take() method).\n\nIn addition, a blocking queue provides specialized operations that can wait up to a specified duration when inserting and removing an element.\n\nThe following table summarizes the API structure of BlockingQueue interface:\n\nSimilarly, a BlockingDeque is a specialized BlockingQueue for double ended queue with two ends (head and tail). Its API is in scheme of xxxFirst() methods operating on the first element and xxxLast() methods operating on the last element.\n\nThe following table summarizes the API structure of BlockingDeque:\n\nLet’s go through various code examples to understand how to use Queue collections in daily coding. In the upcoming examples, I use different implementations like LinkedList, ArrayDeque, PriorityQueue, ArrayBlockingQueue, ec.\n\nTo learn in-depth about Java collections framework, I recommend you to read the well-known book Java Generics and Collections.\n\nAs a best practice, it’s recommended to use generic type and interface as reference type when creating a new collection. For queues, depending on the need of a particular type (queue, deque and blocking queue), use the corresponding interface as the reference type.\n\nFor example, the following statements create 3 different types of queues:\n\nMost Queue implementations do not have restriction on capacity (unbounded queues), except the ArrayBlockingQueue, LinkedBlockingQueue and LinkedBlockingDeque classes. The following statement creates an ArrayBlockingQueue with fixed capacity of 200 elements:\n\nAlso remember that we can use the copy constructor to create a new Queue instance from another collection. For example:\n\n2. Adding New Elements to the Queue\n\nTo insert an element to the tail of the queue, we can use either the add() or offer() method. The following code adds two elements to a linked list:\n\nWhen using an unbounded queue (no capacity restriction), the add() and offer() methods do not show the difference. However, when using a bounded queue, the add() method will throw an exception if the queue is full, while the offer() method returns false. The following example illustrates this difference:\n\nThe last line throws java.lang.IllegalStateException: Queue full because we declare the queue with capacity of 3 elements. Hence adding the 4th element results in an exception.\n\nHowever, we are safe when using the offer() method, as shown in the following code snippet:\n\nThe following code snippet adds an element to the head and an element to the tail of a double ended queue (notice the type of the interface is used):\n\nFor blocking queue, use the put(e)or offer(e, time, unit) in case you want the current thread to wait until space becomes available in the queue. For example:\n\n3. Removing the Head of the Queue\n\nA Queue provides the remove() and poll() methods that allow us to pick the element at the head and remove it from the queue. And you should understand the difference between these two methods.\n\nThe remove() method returns the head element or throws an exception if the queue is empty. For example:\n\nHere, the queue has only one element, so the first call to remove() working fine. However the subsequent invocation results in java.util.NoSuchElementException because the queue becomes empty.\n\nIn contrast, the poll() method returns null if the queue is empty, as shown in the following example:\n\nThe following example removes the head element and tail element from a deque:\n\nFor a blocking queue, use the take()or poll(time, unit)methods in case you want the current thread to wait until an element becomes available. For example:\n\n4. Examining the Head of the Queue\n\nIn contrast to the remove() method, the examine methods element() and peek() return (but do not remove) the head of the queue. So consider using these methods in case you just want to check what is currently in the head element without modifying the queue.\n\nAlso, you need to know the difference between the element() and peek() methods:\n\nThe element() method throws an exception in case the queue is empty, whereas the peek() method returns null. For example:\n\nFor a deque, use the getFirst() or peekFirst() methods to examine the first element, and getLast() or peekLast() to examine the last element. Here’s an example:\n\n5. Iterating over Elements in the Queue\n\nWe can use the enhanced for loop, iterator and forEach() method to iterate over elements in the queue. The following code snippet illustrates how to iterate a linked list using the enhanced for loop:\n\nMore simply, using Lambda expression with forEach() method in Java 8:\n\nThe following example iterates over elements of a PriorityQueue which sorts elements by natural ordering:\n\nAs you can see in the output, the elements are sorted in the alphabetic order (natural ordering of Strings).\n\nNOTE: Pay attention when using an iterator of a PriorityQueue, because it is not guaranteed to traverse the elements of the priority queue in any particular order.\n\nAll implementations of BlockingQueue are thread-safe. The following implementations are not:\n\nWhen you want to use a synchronized linked list, use the following code:\n\nAnd consider using the PriorityBlockingQueue instead of the PriorityQueue when you want to use a synchronized priority queue.\n\nSo far you have learned almost everything you need to know about Queue in Java. I hope you benefit from this tutorial. If you want to go further in Java programming, consider to learn this Java Masterclass course.\n• Understanding Object Ordering in Java with Comparable and Comparator"
    }
]