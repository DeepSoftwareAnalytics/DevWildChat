[
    {
        "link": "https://realpython.com/python-pyqt-layout",
        "document": "PyQt’s layout managers provide a user-friendly and productive way of arranging graphical components, or widgets, on a GUI. Laying out widgets properly will make your GUI applications look polished and professional. Learning to do so efficiently and effectively is a fundamental skill for you to get up and running with GUI application development using Python and PyQt.\n• What the benefits are of using PyQt’s layout managers\n• How to programmatically lay out widgets on a GUI using PyQt’s layout managers\n• How to select the right layout manager for your GUI application\n• How to lay out widgets in main window–based and dialog-based applications\n\nWith this knowledge and skillset, you’ll be able to use Python and PyQt to create professional-looking GUI applications.\n\nFor a better understanding of how to use layout managers, some previous knowledge of how to create PyQt GUI applications and how to work with PyQt widgets would be helpful.\n\nWhen you’re creating graphical user interface (GUI) applications, a common issue is how to get your graphical components—buttons, menus, toolbars, labels, and so on—laid out coherently on your forms and windows. This process is known as GUI layout, and it’s an important step in creating GUI applications. In the past, if you wanted to lay out graphical components, or widgets, on a window, then you would follow one of the following approaches:\n• Decide on and manually set a static size and position for each widget on the window.\n• Calculate and set the size and position of each widget dynamically. The first approach is fairly direct, but it has at least the following drawbacks:\n• Your windows will be non-resizable, which might cause problems when displaying them on different screen resolutions.\n• Your labels might not support localization properly because the length of a given text changes between languages.\n• Your widgets will display differently on different platforms, which makes it difficult to write multiplatform applications that look good. The second approach is more flexible. However, it also has drawbacks:\n• You have to do a lot of manual calculations to determine the right size and position of each widget.\n• You have to do some extra calculations to respond correctly to window resizing.\n• You have to redo all the calculations any time you modify the layout of your window. Even though you can still use either of these two approaches to lay out your GUIs, most of the time you’ll want to use a third and more convenient approach implemented by most modern GUI frameworks or toolkits: layout managers. Note: In some GUI frameworks, such as Tkinter, layout managers are also referred to as geometry managers. Layout managers automatically arrange widgets on a GUI according to your specific needs. They avoid the compatibility drawbacks of the first approach as well as the annoying and complicated calculations of the second approach. In the following sections, you’ll learn about PyQt’s built-in layout managers and how to use them to effectively lay out the graphical components of your GUI applications.\n\nGetting Stocked With a Gallery of PyQt Layouts In PyQt, widgets are graphical components that you use as building blocks for your GUI applications. When you place a bunch of widgets on a window to create a GUI, you need to give them some order. You need to set the widgets’ size and position on the window, and you also need to define their behavior for when the user resizes the underlying window. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out the PyQt4 documentation, the Qt for Python documentation, or the original Qt documentation. In this tutorial, you’ll find that most links will take you to the original Qt documentation, which is a better source of information in most cases. To arrange the widgets on windows or forms in PyQt, you can use the following techniques:\n• Use and on your widgets to provide an absolute size and position.\n• Reimplement and calculate your widgets’ size and position dynamically.\n• Use layout managers and let them do all the calculations and hard work for you. These techniques generally correspond to the three different approaches for laying out a GUI that you saw in the previous section. Again, calculating the size and position dynamically might be a good approach, but most of the time you’ll be better off using layout managers. In PyQt, layout managers are classes that provide the required functionality to automatically manage the size, position, and resizing behavior of the widgets in the layout. With layout managers, you can automatically arrange child widgets within any parent, or container, widget. Using layout managers will ensure that you make good use of the available space on your GUI and also that your application remains usable when the user resizes the window. Layout managers work as containers for both widgets and other layouts. To add widgets to a layout manager, you call on the layout at hand. To add a layout to another layout, you call on the layout at hand. You’ll dive deeper into nesting layouts in the section Nesting Layouts to Build Complex GUIs. Once you’ve added all the required widgets to a layout manager, you set the layout manager on a given widget using . You can set a layout manager on any subclasses of , including windows or forms. Note: is a PyQt class that you can use to create main window–style applications. This class has its own built-in layout manager. So, if you’re using , then you commonly won’t need to set a layout manager on your main window objects. All the widgets in a layout are automatically set as children of the widget on which you install the layout, not of the layout itself. That’s because widgets can have only other widgets, not layouts, as their parent. PyQt’s layout managers provide some cool features that make your life a lot easier when it comes to creating good-looking GUI applications:\n• Handling the size and position of widgets without the need for any calculation\n• Handling the resizing and repositioning of widget when the user resizes the underlying window Using layout managers will also dramatically increase your productivity and improve your code’s maintainability in the long term. In the next few sections, you’ll learn the basics of how to use these general-purpose layout managers.\n\nWhen creating GUI applications with PyQt, you’ll often use one or more of the four general-purpose layouts that you saw at the end of the previous section to get your widget laid out on your windows and forms. In the next few sections, you’ll learn how to create and use the four general-purpose layout managers with the help of some examples. Box layout managers take the space they get from their parent layout or widget, divide it up into a number of boxes, or cells, and make each widget in the layout fill one box. is one of the two available box layouts in PyQt. This layout manager allows you to arrange widgets horizontally, one next to the other. The widgets are added to the layout from left to right. This means that the widget that you add first in your code will be the left-most widget in the layout. To add widgets to a object, you call on the layout object. This method takes one required argument and two optional arguments:\n• is a required argument that holds the specific widget that you want to add to the layout.\n• is an optional argument that holds an integer number representing the stretch factor to apply to . Widgets with higher stretch factors grow more on window resizing. It defaults to , which means that the widget has no stretch factor assigned.\n• is an optional argument that holds horizontal and vertical flags. You can combine these flags to produce the desired alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s a small application that shows how to create a horizontal layout using . In this example, you’ll use objects to better visualize where each widget will be placed in the layout according to the order in which you add the widgets to your code: # Set the layout on the application's window On line 15, you create a object called . On lines 17 to 19, you add three buttons to using . Note that you pass and to the parameter in the Center and Right-Most buttons, respectively. On line 21, you set as your window’s top-level layout using . Note: If you’re new to GUI programming with PyQt, then you can take a look at Python and PyQt: Building a GUI Desktop Calculator to get a better idea of how to create a GUI application with PyQt. If you run this application, then you’ll get the following window on your screen: This window contains three buttons arranged in a horizontal fashion. Note that the Left-Most button corresponds to the first button that you add in your code. So, buttons are shown in the same order (from left to right) that you add them in your code (from top to bottom). The Center and Right-Most buttons have different stretch factors, so they expand in proportion to those factors when you resize the window. Additionally, all the buttons in and the layout itself are set as children of . This is automatically done by the layout object, which internally calls on each widget. The call to on line 22 prints a list of the children of on your terminal as evidence of this behavior. arranges widgets vertically, one below the other. You can use this class to create vertical layouts and arrange your widgets from top to bottom. Since is another box layout, its method works the same as in . Here’s a PyQt application that shows how to create and use a object for creating vertical arrangements of widgets in your GUIs: # Set the layout on the application's window On line 16, you create an instance of . On lines 18 to 20, you add three buttons to . Finally, you set as your window’s top-level layout. If you run this application, then you’ll get the following window: Your window shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order (from top to bottom) as you add them in your code (from top to bottom). You can use to arrange widgets in a grid of rows and columns. Each widget will have a relative position in the grid. To define a widget’s position, or cell in the grid, you use a pair of coordinates of the form . These coordinates should be zero-based integer numbers. takes the available space on its parent, divides it into rows and columns, and places each widget into its own cell or box. automatically figures out how many rows and columns the final layout will have depending on the number of widgets and their coordinates. If you don’t add a widget to a given cell, then will leave that cell empty. To add widgets to a grid layout, you call on the layout. This method has two different overloaded implementations:\n• adds to the cell at ( , ).\n• adds to the cell, spanning multiple rows, columns, or both. The first implementation takes the following arguments:\n• is a required argument that holds the specific widget that you need to add to the layout.\n• is a required argument that holds an integer representing the coordinate of a row in the grid.\n• is a required argument that holds an integer representing the coordinate of a column in the grid.\n• is an optional argument that holds the alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s an example of how to use to create a grid of widgets: # Set the layout on the application's window On line 15, you create the object. Then, on lines 17 to 25, you add widgets to the layout using . To see how grid layouts manage cells without an assigned widget, comment out one or more of these lines and run the application again. If you run this code from your command line, then you’ll get a window like this: Each widget in the object occupies the cell defined by the pair of coordinates that you provide in . The text on each button reflects those coordinates. The coordinates are zero-based, so the first cell is at . In the second implementation of , the arguments and stay the same, and you have four additional arguments that allow you to place the widget across several rows or columns:\n• takes an integer number that represents the row in which the widget will start.\n• takes an integer number that represents the column in which the widget will start.\n• takes an integer number that represents the number of rows that the widget will occupy in the grid.\n• takes an integer number that represents the number of columns that the widget will occupy in the grid. Here’s an application that shows how this variation of works: # Set the layout on the application's window On line 19, you use the second implementation of to add a button that occupies two columns in the grid. The button starts at the second row ( ) and at the first column ( ). Finally, the button occupies one row ( ) and two columns ( ). Note: Since PyQt is a Python binding for Qt, which is a set of C++ libraries, sometimes you can’t use keyword arguments when calling PyQt methods. The keyword arguments used in the above paragraph have the sole purpose of showing what value is assigned to each argument. Here’s the window that you’ll see on your screen if you run this application: In this kind of layout, you can make a widget occupy more than one cell, just as you did with the Button Spans two Cols button. If you’re constantly creating forms to perform actions like inputting data into a database, then is for you. This class arranges widgets in a two-column layout. The first column usually displays a label describing the intended input, and the second column generally contains input widgets such as , , or that allow the user to enter or edit data. To add widgets to a form layout, you use . This method has several variations but, most of the time, you’ll choose from the following two:\n• adds a new row to the bottom of a form layout. The row should contain a object ( ) and an input widget ( ).\n• automatically creates and adds a new object with as its text. holds an input widget. Here’s a sample application that uses a object to arrange widgets: # Set the layout on the application's window On line 17, you create a object. Then, on lines 19 to 22, you add some rows to the layout. Note that on lines 19 and 20, you use the second variation of the method, and on line 22, you use the first variation, passing a object as the first argument to . If you run this code, then you’ll get the following window on your screen: With a , you can organize your widgets in a two-column arrangement. The first column contains labels that ask the user for some information. The second column shows widgets that allow the user to input or edit that information.\n\nYou can use nested layouts to create complex GUIs that would be difficult to create using one of the general-purpose PyQt’s layout managers. To do that, you need to call on an outer layout. This way, the inner layout becomes a child of the outer layout. Suppose you need to create a dialog that shows a label and a line edit in a form layout, and below those widgets you want to place several checkboxes in a vertical layout. Here’s a mock-up of what your dialog should look like: The blue rectangle represents your outer layout. The green rectangle is the form layout that will hold the label and line edit. The red rectangle is the vertical layout to hold the option checkboxes. Both the green layout and the red layout are nested into the blue one, which is a vertical layout. Here’s an example of how to build this layout using PyQt: # Create a form layout for the label and line edit # Add a label and a line edit to the form layout # Add some checkboxes to the layout # Nest the inner layouts into the outer layout Here’s what you’re doing in this code:\n• On line 17, you create the outer, or top-level, layout, which you’ll use as a parent layout and as the main layout of your window. In this case, you use because you want your widgets to be arranged vertically on your form. In your mock-up, this is the blue layout.\n• On line 19, you create a form layout to hold a label and a line edit.\n• On line 21, you add the required widgets to the layout. This is equivalent to your green layout.\n• On line 23, you create a vertical layout to hold the checkboxes.\n• On lines 25 to 27, you add the required checkboxes. This is your red layout.\n• On lines 29 and 30, you nest and under the . That’s it! If you run the application, then you’ll see a window like the following: In this application, you nest two different layouts under an outer layout to create a general layout for your window. At the top of the window, you use a horizontal layout to place a label and a line edit. Then you place some checkboxes below that using a vertical layout.\n\nSo far, you’ve seen how to use traditional or general-purpose layout managers to arrange the widgets in your application’s windows. These layout managers will arrange widgets on a single-page layout. In other words, your GUI will always show the same set of widgets to the user. Sometimes you need to create a layout that shows a different set of widgets in response to certain user actions on the GUI. For example, if you’re creating a preferences dialog for a given application, then you might want to present the user with a tab-based, or multipage, layout in which each tab or page contains a different set of closely related options. Every time the user clicks on a tab or page, the application shows a different set of widgets. PyQt provides a built-in layout called and some convenient widgets like that will allow you to create this kind of multipage layout. The next few sections will walk you through some of these tools. provides a layout manager that will allow you to arrange your widgets on a stack, one on top of the other. In this kind of layout, only one widget is visible at a given time. To populate a stacked layout with widgets, you need to call on the layout object. This will add each widget to the end of the layout’s internal list of widgets. You can also insert or remove a widget at a given position in the list of widgets using or , respectively. Each widget in the list of widgets is displayed as an independent page. If you want to show several widgets on a page, then use a object for each page and set an appropriate layout of widgets to the page widget. If you need to get the total number of widgets (pages) in the layout, then you can call . An important point to keep in mind when working with objects is that you need to explicitly provide a mechanism to switch between pages. Otherwise, your layout will always show the same page to the user. To switch between pages, you need to call on the layout object. Here’s an example that shows how to use a stacked layout with a combo box for switching between pages: # Create and connect the combo box to switch between pages # Add the combo box and the stacked layout to the top-level layout On lines 21 to 23, you create a object that will allow you to switch between the pages in the layout. Then you add two options to the combo box in a list and connect it to , which is intended to handle page switching. Inside , you call on the layout object, passing the current index of the combo box as an argument. This way, when the user changes the option in the combo box, the page on the stacked layout will change accordingly. On line 25, you create the object. On lines 27 to 32, you add the first page to the layout, and on lines 34 to 39, you add the second page. Each page is represented by a object that contains several widgets in a convenient layout. The final step to get everything working is to add the combo box and the layout to the application’s main layout. Here’s how your application behaves now: In this case, you have two pages in your application’s layout. Each page is represented by a object. When you select a new page in the combo box on the top of the window, the layout changes to show the selected page. Note: PyQt provides a convenient class called , which is built on top of . You can also use this class to create multipage layouts. This class provides a stack of widgets in which only one widget is visible at a time. Just like stacked layouts, doesn’t provide an intrinsic mechanism for switching between pages. Besides stacked layout and stacked widget, you can use to create a multipage user interface. You’ll learn how in the next section. Another popular way of creating multipage arrangements in PyQt is by using a class called . This class provides a tab bar and a page area. You use the tab bar to switch between pages and the page area to display the page associated with the selected tab. The tab bar is located at the top of the page area by default. However, you can change this behavior using and one of four possible tab positions: Right of the pages To add tabs to a tab widget, you use . This method has two variations, or overloaded implementations: In both cases, the method adds a new tab, with as the tab’s title. needs to be a widget representing the page associated with the tab at hand. In the second variation of the method, needs to be a object. If you pass an icon to , then that icon will be shown to the left of the tab’s title. A common practice when creating tab widgets is to use a object for each page. This way, you’ll be able to add extra widgets to the page using a layout containing the required widgets. Most of the time, you’ll use tab widgets to create dialogs for your GUI applications. This kind of layout allows you to present the user with several options in a relatively small space. You can also take advantage of the tab system to organize your options according to some classification criteria. Here’s a sample application that shows the basics of how to create and use a object: # Create the tab widget with two tabs In this example, you use a tab widget to present the user with a concise dialog that shows options related to the General and Network sections of a hypothetical preferences menu. On line 20, you create the object. Then you add two tabs to the tab widget using . In and , you create the specific GUI for each tab. To do this, you use a object, a object, and some checkboxes to hold the options. If you run the application now, then you’ll get the following dialog on your screen: That’s it! You have a fully functional tab-based GUI. Note that to switch between pages, you just need to click the corresponding tab.\n\nGUI applications are commonly built using a main window and one or more dialogs. Dialogs are small windows that allow you to communicate with your users. PyQt provides to handle the creation of dialogs. Unlike , doesn’t have a predefined or default top-level layout. That’s because dialogs can be quite varied and include a wide range of widget arrangements and combinations. Once you place all the widgets on a dialog’s GUI, you need to set a top-level layout on that dialog. To do this, you have to call on the dialog object just like you’d do with any other widget. Here’s a dialog-style application that shows how to set a top-level layout to a object: # Set the layout on the dialog In this case, the application’s window inherits from , so you have a dialog-style application. On line 16, you create the layout that you’ll use as the dialog’s top-level layout. On lines 18 to 21, you create a form layout to arrange some widgets in a form. On line 24, you add a object. You’ll often use to handle the buttons on a dialog. In this example, you use two buttons, an Ok button and a Cancel button. These buttons won’t have any functionality—they’re just intended to make the dialog more realistic. Once you have all the widgets and layouts in place, you can add them to the top-level layout. That’s what you do on lines 28 and 29. The final step, on line 30, is to set the top-level layout as your dialog’s layout using . If you run this application, then you’ll see the following window on your screen: It’s a best practice to set a top-level layout for all your dialogs. This ensures that the dialog’s GUI will behave coherently when the user resizes the underlying window. Otherwise, your dialogs could appear disorganized and unpolished in the user’s eyes.\n\nWhen it comes to using PyQt’s layout managers to arrange the widgets on a window or form, managing space—empty space, space between widgets, and so on—is a common issue. Being able to manage this space is an important skill to have. Internally, layouts manage the available space on a window using some of the following widget properties:\n• contains the smallest size the widget can have while remaining usable\n• holds the default behavior of a widget in a layout Layouts use these properties to automatically position and resize widgets, assigning a given amount of space to each widget according to the available space. This ensures that widgets are consistently arranged and remain usable. In the next three sections, you’ll learn how the different types of layouts manage space in PyQt. Box layouts do a great job when it comes to distributing available space between widgets. However, sometime their default behavior isn’t enough, and you need to manually handle the available space. To help you out in this situation, PyQt provides . This class allows you to add blank space (or empty boxes) to a box layout. Normally, you don’t need to use directly. Instead, you call some of the following methods on your box layout objects:\n• adds a non-stretchable space (or empty box) of fixed size to the layout. must be an integer representing the size of the space in pixels.\n• adds a stretchable space with a minimum size of and a stretch factor to a box layout. must be an integer.\n• inserts a non-stretchable space at position , with size . If is negative, then the space is added at the end of the box layout.\n• inserts a stretchable space at position , with a minimum size of and a stretch factor of . If is negative, then the space is added at the end of the box layout. Stretchable spacers will expand or shrink to fill empty space when the user resizes the underlying window. Non-stretchable spacers will remain the same size regardless of the changes in the size of the underlying window. Go back to the example of how to use vertical layouts and run that application again. If you pull down the border of the window, then you’ll notice that more space appears between the buttons the further down you pull: This happens because the layout handles the newly available space by automatically expanding its boxes. You can change this behavior by adding a stretchable object to the end of the layout. In your example’s code, update the initializer of as follows: # Set the layout on the application's window In the highlighted line, you add a stretchable object to the end of the layout by calling on the layout. If you run the application again, then you’ll get the following behavior: Now all the extra space is automatically assigned to the stretchable object at the bottom of the layout without affecting the position or size of the rest of the widgets. You can use this and other space management techniques to make your GUI applications look good and polished. Grid and form layouts handle available space in a different way. In these types of layouts, you can handle only the vertical and horizontal space between widgets. These layouts provide three methods to manage these spaces:\n• sets both the vertical and the horizontal spacing between widgets to .\n• sets only the vertical spacing between widgets in the layout to .\n• sets only the horizontal spacing between widgets in the layout to . In all cases, is an integer representing pixels. Now go back to the example on how to create a form layout and update the initializer of like this: # Set the layout on the application's window In the highlighted line, you set the vertical space between widgets to pixels. If you run the application again, then you’ll see the following window: Now there’s more space between the rows of widgets. You can also try modifying the example of how to use a grid layout by adding some vertical or horizontal space just to see how all these spacing mechanisms work."
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-basic-widgets",
        "document": "In Qt, like in most GUI frameworks, widget is the name given to a component of the UI that the user can interact with. User interfaces are made up of multiple widgets, arranged within the window.\n\nQt comes with a large selection of widgets available and even allows you to create your own custom and customized widgets. In this tutorial, you'll learn the basics of some of the most commonly used widgets in Qt GUI applications.\n\nFirst, let's have a look at some of the most common PyQt widgets. The following code creates a range of PyQt widgets and adds them to a window layout so you can see them together:\n\nRun it! You'll see a window appear containing all the widgets we've created:\n\nWe'll cover how layouts work in Qt in the next tutorial.\n\nLet's have a look at all the example widgets, from top to bottom:\n\nThere are far more widgets than this, but they don’t fit so well! You can see them all by checking the Qt documentation.\n\nNext, we'll step through some of the most commonly used widgets and look at them in more detail. To experiment with the widgets, we'll need a simple application to put them in. Save the following code to a file named and run it to make sure it's working:\n\nIn the code above, we've imported a number of Qt widgets. Now we'll step through each of those widgets in turn, adding them to our application and seeing how they behave.\n\nWe'll start the tour with , arguably one of the simplest widgets available in the Qt toolbox. This is a simple one-line piece of text that you can position in your application. You can set the text by passing in a string as you create it:\n\nYou can also set the text of a label dynamically, by using the method:\n\nYou can also adjust font parameters, such as the size of the font or the alignment of text in the widget:\n\nFont tip Note that if you want to change the properties of a widget font it is usually better to get the current font, update it, and then apply it back. This ensures the font face remains in keeping with the desktop conventions.\n\nThe alignment is specified by using a flag from the namespace. The flags available for horizontal alignment are listed in the following table:\n\nSimilarly, the flags available for vertical alignment are:\n\nYou can combine flags together using pipes ( ). However, note that you can only use vertical or horizontal alignment flags at a time:\n\nNote that you use an OR pipe ( ) to combine the two flags (not ). This is because the flags are non-overlapping bitmasks. For example, has the hexadecimal value , while is . By ORing them together, we get the value , representing 'bottom left'. This principle applies to all other combinatorial Qt flags. If this is gibberish to you, then feel free to ignore it and move on. Just remember to use the pipe ( ) symbol.\n\nFinally, there is also a shorthand flag that centers in both directions simultaneously:\n\nWeirdly, you can also use to display an image using . This accepts a pixmap, which you can create by passing an image filename to the class.\n\nBelow is an image which you can download for this example.\n\nPlace the file in the same folder as your code, and then display it in your window as follows:\n\nWhat a lovely face. By default, the image scales while maintaining its aspect ratio. If you want it to stretch and scale to fit the window completely, then you can call on the object:\n\nThis way, your image will stretch and scale to fit the window completely.\n\nThe next widget to look at is , which, as the name suggests, presents a checkable box to the user. However, as with all Qt widgets, there are a number of configurable options to change the widget's default behaviors:\n\nYou can set a checkbox state programmatically using the or methods. The former accepts either or , which correspond to the checked or unchecked states, respectively. However, with , you also specify a particular checked state using a namespace flag:\n\nA checkbox that supports a partially-checked ( ) state is commonly referred to as 'tri-state', which is being neither on nor off. A checkbox in this state is commonly shown as a greyed-out checkbox, and is commonly used in hierarchical checkbox arrangements where sub-items are linked to parent checkboxes.\n\nIf you set the value to the checkbox will become tristate. You can also set a checkbox to be tri-state without setting the current state to partially checked by using\n\nYou may notice that when the script is running, the current state number is displayed as an with checked = , unchecked = , and partially checked = . You don’t need to remember these values, the namespace variable , for example. This is the value of these state's respective flags. This means you can test state using .\n\nThe is a drop-down list, closed by default with an arrow to open it. You can select a single item from the list, with the currently selected item being shown as a label on the widget. The combo box is suited for the selection of a choice from a long list of options.\n\nYou have probably seen the combo box used for the selection of font face, or size, in word processing applications. Although Qt actually provides a specific font-selection combo box as .\n\nYou can add items to a by passing a list of strings to . Items will be added in the order they are provided:\n\nThe signal is triggered when the currently selected item is updated, by default passing the index of the selected item in the list. There is also a signal, which instead provides the label of the currently selected item, which is often more useful.\n\ncan also be editable, allowing users to enter values not currently in the list and either have them inserted or simply used as a value. To make the box editable, use the method:\n\nYou can also set a flag to determine how the insertion is handled. These flags are stored on the class itself and are listed below:\n\nTo use these, apply the flag as follows:\n\nYou can also limit the number of items allowed in the box by using the method:\n\nFor a more in-depth look at the , check out our QComboBox documentation.\n\nThis widget is similar to , except options are presented as a scrollable list of items. It also supports the selection of multiple items at once. A offers a signal, which sends the (the element of the list widget), and a signal, which sends the text of the current item:\n\nThe widget is a single-line text editing box, into which users can type input. These are used for form fields, or settings where there is no restricted list of valid inputs. For example, when entering an email address, or computer name:\n\nAs demonstrated in the above code, you can set a maximum length for the text in a line edit using the method.\n\nThe has a number of signals available for different editing events, including when the Enter key is pressed (by the user), and when the user selection is changed. There are also two edit signals, one for when the text in the box has been edited and one for when it has been changed. The distinction here is between user edits and programmatic changes. The signal is only sent when the user edits text.\n\nAdditionally, it is possible to perform input validation using an input mask to define which characters are supported and where. This can be applied to the field as follows:\n\nThe above would allow a series of 3-digit numbers separated with periods, and could therefore be used to validate IPv4 addresses.\n\nprovides a small numerical input box with arrows to increase and decrease the value. supports integers, while the related widget, , supports floats:\n\nRun it, and you'll see a numeric entry box. The value shows pre and post-fix units and is limited to the range 3 to -10.\n\nThe demonstration code above shows the various features that are available for the widget.\n\nTo set the range of acceptable values, you can use the and methods. Alternatively, use to set both simultaneously. Annotation of value types is supported with both prefixes and suffixes that can be added to the number (e.g. for currency markers or units) using the and methods, respectively.\n\nClicking the up and down arrows on the widget will increase or decrease the value in the widget by an amount, which can be set using the method. Note that this has no effect on the values that are acceptable to the widget.\n\nBoth and have a signal, which fires whenever their value is altered. The raw signal sends the numeric value (either an or a ), while sends the value as a string, including both the prefix and suffix characters.\n\nYou can optionally disable text input on the spin box's line edit, by setting it to read-only. With this setting, the value can only be changed using the controls:\n\nThis setting also has the side effect of disabling the flashing cursor.\n\nprovides a slide-bar widget, which internally works like a . Rather than display the current value numerically, that value is represented by the position of the slider's handle along the length of the widget. This is often useful when providing adjustment between two extremes, but when absolute accuracy is not required. The most common use case of this type of widget is for volume controls in audio playback.\n\nThere is an additional signal that is triggered whenever the slider moves position and a signal that is emitted whenever the slider is clicked:\n\nRun this, and you'll see a slider widget. Drag the slider to change the value:\n\nYou can also construct a slider with a vertical or horizontal orientation by providing the orientation as you create it. The orientation flags are defined in the namespace:\n\nFinally, the widget is a rotatable widget that works just like the slider but appears as an analog dial. This widget looks nice, but from a UI perspective, it is not particularly user-friendly. However, dials are often used in audio applications as a representation of real-world analog dials:\n\nRun this, and you'll see a circular dial. Rotate it to select a number from the range:\n\nThe signals are the same as for the widget and retain the same names (e.g. ).\n\nThis concludes our brief tour of the common widgets used in PyQt applications. To see the full list of available widgets, including all their signals and attributes, check out the Qt documentation."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtdesigner-manual.html",
        "document": "Qt Widgets Designer is the Qt tool for designing and building graphical user interfaces (GUIs) with Qt Widgets. For user interface design with Qt Quick, see Qt Design Studio.\n\nYou can compose and customize your windows or dialogs in a what-you-see-is-what-you-get (WYSIWYG) manner, and test them using different styles and resolutions. Widgets and forms created with Qt Widgets Designer integrate seamlessly with programmed code, using Qt's signals and slots mechanism, so that you can easily assign behavior to graphical elements. All properties set in Qt Widgets Designer can be changed dynamically within the code. Furthermore, features like widget promotion and custom plugins allow you to use your own components with Qt Widgets Designer.\n\nNote: You have the option of using Qt Quick and Qt Design Studio for user interface design rather than widgets. It is a much easier way to write many kinds of applications. It enables a completely customizable appearance, touch-reactive elements, and smooth animated transitions, taking advantage of hardware acceleration.\n\nIf you are new to Qt Widgets Designer, you can take a look at the Getting To Know Qt Widgets Designer document. For a quick tutorial on how to use Qt Widgets Designer, refer to A Quick Start to Qt Widgets Designer.\n• Using a Designer UI File in Your C++ Application\n• Using a Designer UI File in Your Qt for Python Application"
    },
    {
        "link": "https://pythonguis.com/pyqt5-tutorial",
        "document": "PyQt is a Python library for creating GUI applications using the Qt toolkit. Created by Riverbank Computing, PyQt is free software (GPL licensed) and has been in development since 1999. PyQt5 was released in 2016 and last updated in October 2021.\n\nThis complete PyQt5 tutorial takes you from first concepts to building fully-functional GUI applications in Python. It requires some basic Python knowledge, but no previous familiarity with GUI concepts. Everything will be introduced step by by step, using hands-on examples.\n\nPyQt5 is the Qt5-based edition of the Python GUI library PyQt from Riverbank Computing.\n\nThere are two major versions currently in use: PyQt5 based on Qt5 and PyQt6 based on Qt6. Both versions are almost completely compatible aside from imports. PyQt6 also makes some changes to how namespaces and flags work, but these are easily manageable.\n\nLooking for something else? I also have a PyQt6 tutorial, PySide2 tutorial and PySide6 tutorial.\n\nThis track consists of 36 tutorials. Keep checking back as I'm adding new tutorials regularly — last updated ."
    },
    {
        "link": "https://build-system.fman.io/pyqt5-tutorial",
        "document": "This PyQt5 tutorial shows how to use Python 3 and Qt to create a GUI on Windows, Mac or Linux. It even covers creating an installer for your app.\n\nPyQt is a library that lets you use the Qt GUI framework from Python. Qt itself is written in C++. By using it from Python, you can build applications much more quickly while not sacrificing much of the speed of C++.\n\nPyQt5 refers to the most recent version 5 of Qt. You may still find the occasional mention of (Py)Qt4 on the web, but it is old and no longer supported.\n\nAn interesting new competitor to PyQt is Qt for Python. Its API is virtually identical. Unlike PyQt, it is licensed under the LGPL and can thus be used for free in commercial projects. It's backed by the Qt company, and thus likely the future. We use PyQt here because it is more mature. Since the APIs are so similar, you can easily switch your apps to Qt for Python later.\n\nThe best way to manage dependencies in Python is via a virtual environment. A virtual environment is simply a local directory that contains the libraries for a specific project. This is unlike a system-wide installation of those libraries, which would affect all of your other projects as well.\n\nTo create a virtual environment in the current directory, execute the following command:\n\nThis creates the folder. To activate the virtual environment on Windows, run:\n\nOn Mac and Linux, use:\n\nYou can see that the virtual environment is active by the prefix in your shell:\n\nTo now install PyQt, issue the following command:\n\nTime to write our very first GUI app! With the virtual environment still active, start Python. We will execute the following commands:\n\nFirst, we tell Python to load PyQt via the import statement:\n\nNext, we create a with the command:\n\nThis is a requirement of Qt: Every GUI app must have exactly one instance of . Many parts of Qt don't work until you have executed the above line. You will therefore need it in virtually every (Py)Qt app you write.\n\nThe brackets in the above line represent the command line arguments passed to the application. Because our app doesn't use any parameters, we leave the brackets empty.\n\nNow, to actually see something, we create a simple label:\n\nThen, we tell Qt to show the label on the screen:\n\nDepending on your operating system, this already opens a tiny little window:\n\nThe last step is to hand control over to Qt and ask it to \"run the application until the user closes it\". This is done via the command:\n\nIf all this worked as expected then well done! You've just built your first GUI app with Python and Qt.\n\nEverything you see in a (Py)Qt app is a widget: Buttons, labels, windows, dialogs, progress bars etc. Like HTML elements, widgets are often nested. For example, a window can contain a button, which in turn contains a label.\n\nThe following screenshot shows the most common Qt widgets:\n\nYou can download the code for the app shown in the screenshot here, if you are interested.\n\nLike the example above, your GUI will most likely consist of multiple widgets. In this case, you need to tell Qt how to position them. For instance, you can use QVBoxLayout to stack widgets vertically:\n\nThe code for this screenshot is:\n\nAs before, we instantiate a . Then, we create a . We use the most basic type for it because it merely acts as a container and we don't want it to have any special behavior. Next, we create the and add two s to it. Finally, we tell the window to use this layout (and thus its contents). As in our first application, we end with calls to and .\n\nThere are of course many other kinds of layouts (eg. QHBoxLayout to lay out items in a row). See Qt's documentation for an overview.\n\nOne of Qt's strengths is its support for custom styles. There are many mechanisms that let you customize the look and feel of your application. This section outlines a few.\n\nThe coarsest way to change the appearance of your application is to set the global Style. Recall the widgets screenshot above:\n\nThis uses a style called . If you use the style instead, then it looks as follows:\n\nThe available styles depend on your platform but are usually , , (Windows only) and (Mac only).\n\nIf you like a style, but want to change its colors (eg. to a dark theme), then you can use QPalette and . For example:\n\nThis changes the text color in buttons to red:\n\nFor a dark theme of the Fusion style, see here.\n\nIn addition to the above, you can change the appearance of your application via style sheets. This is Qt's analogue of CSS. We can use this for example to add some spacing:\n\nFor more information about style sheets, please see Qt's documentation.\n\nQt uses a mechanism called signals to let you react to events such as the user clicking a button. The following example illustrates this. It contains a button that, when clicked, shows a message box:\n\nThe interesting line is highlighted above: is a signal, lets us install a so-called slot on it. This is simply a function that gets called when the signal occurs. In the above example, our slot shows a message box.\n\nThe term slot is important when using Qt from C++, because slots must be declared in a special way in C++. In Python however, any function can be a slot – we saw this above. For this reason, the distinction between slots and \"normal\" functions has little relevance for us.\n\nSignals are ubiquitous in Qt. And of course, you can also define your own. This however is beyond the scope of this tutorial.\n\nYou now have the basic knowledge for creating a GUI that responds to user input. Say you've written an app. It runs on your computer. How do you give it to other people, so they can run it as well?\n\nYou could ask the users of your app to install Python and PyQt like we did above, then give them your source code. But that is very tedious (and usually impractical). What we want instead is a standalone version of your app. That is, a binary executable that other people can run on their systems without having to install anything.\n\nIn the Python world, the process of turning source code into a self-contained executable is called freezing. Although there are many libraries that address this issue – such as PyInstaller, py2exe, cx_Freeze, bbfreze, py2app, ... – freezing PyQt apps has traditionally been a surprisingly hard problem.\n\nWe will use a new library called fbs that lets you create standalone executables for PyQt apps. To install it, enter the command:\n\nThen, execute the following:\n\nThis prompts you for a few values:\n\nWhen you type in the suggested command, an empty window should open:\n\nThis is a PyQt5 app just like the ones we have seen before. Its source code is in in your current directory. But here's the cool part: We can use fbs to turn it into a standalone executable!\n\nThis places a self-contained binary in the folder of your current directory. You can send it to your friends (with the same OS as yours) and they will be able to run your app!\n\n(Please note that the free version of fbs only supports Python 3.5 or 3.6. If you have a different version, please install one of these supported Python versions or buy fbs Pro).\n\nfbs also lets you create an installer for your app via the command :\n\nFor more information on how you can use fbs for your existing application, please see this article. Or fbs's tutorial.\n\nIf you have made it this far, then big congratulations. Hopefully, you now have a good idea of how PyQt (and its various parts) can be used to write a desktop application with Python. We also saw how fbs lets you create standalone executables and installers.\n\nDue to the popularity of this article, I wrote a PyQt6 book.\n\nThe book explains in more detail how you can create your own apps. Even Phil Thompson, the creator of PyQt, read the book and said it's \"very good\". So check it out!"
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-signals-slots-events",
        "document": "So far we've created a window and added a simple push button widget to it, but the button doesn't do anything. That's not very useful at all -- when you create GUI applications you typically want them to do something! What we need is a way to connect the action of pressing the button to making something happen. In Qt, this is provided by signals and slots or events.\n\nSignals are notifications emitted by widgets when something happens. That something can be any number of things, from pressing a button, to the text of an input box changing, to the text of the window changing. Many signals are initiated by user action, but this is not a rule.\n\nIn addition to notifying about something happening, signals can also send data to provide additional context about what happened.\n\nYou can also create your own custom signals, which we'll explore later.\n\nSlots is the name Qt uses for the receivers of signals. In Python any function (or method) in your application can be used as a slot -- simply by connecting the signal to it. If the signal sends data, then the receiving function will receive that data too. Many Qt widgets also have their own built-in slots, meaning you can hook Qt widgets together directly.\n\nLet's take a look at the basics of Qt signals and how you can use them to hook widgets up to make things happen in your apps.\n\nSave the following app outline to a file named .\n\nOur simple application currently has a with a set as the central widget. Let's start by hooking up this button to a custom Python method. Here we create a simple custom slot named which accepts the signal from the .\n\nRun it! If you click the button you'll see the text \"Clicked!\" on the console.\n\nThat's a good start! We've heard already that signals can also send data to provide more information about what has just happened. The signal is no exception, also providing a checked (or toggled) state for the button. For normal buttons this is always , so our first slot ignored this data. However, we can make our button checkable and see the effect.\n\nIn the following example, we add a second slot which outputs the checkstate.\n\nRun it! If you press the button you'll see it highlighted as checked. Press it again to release it. Look for the check state in the console.\n\nYou can connect as many slots to a signal as you like and can respond to different versions of signals at the same time on your slots.\n\nOften it is useful to store the current state of a widget in a Python variable. This allows you to work with the values like any other Python variable and without accessing the original widget. You can either store these values as individual variables or use a dictionary if you prefer. In the next example we store the checked value of our button in a variable called on .\n\nFirst we set the default value for our variable (to ), then use the default value to set the initial state of the widget. When the widget state changes, we receive the signal and update the variable to match.\n\nYou can use this same pattern with any PyQt widgets. If a widget does not provide a signal that sends the current state, you will need to retrieve the value from the widget directly in your handler. For example, here we're checking the checked state in a pressed handler.\n\nWe need to keep a reference to the button on so we can access it in our slot.\n\nThe released signal fires when the button is released, but does not send the check state, so instead we use to get the check state from the button in our handler.\n\nSo far we've seen how to accept signals and print output to the console. But how about making something happen in the interface when we click the button? Let's update our slot method to modify the button, changing the text and disabling the button so it is no longer clickable. We'll also turn off the checkable state for now.\n\nAgain, because we need to be able to access the in our method, we keep a reference to it on . The text of the button is changed by passing a to . To disable a button call with .\n\nRun it! If you click the button the text will change and the button will become unclickable.\n\nYou're not restricted to changing the button that triggers the signal, you can do anything you want in your slot methods. For example, try adding the following line to method to also change the window title.\n\nMost widgets have their own signals -- and the we're using for our window is no exception. In the following more complex example, we connect the signal on the to a custom slot method.\n\nIn the following example we connect the signal on the to a method slot . This slot also receives the new window title.\n\nFirst we set up a list of window titles -- we'll select one at random from this list using Python's built-in . We hook our custom slot method to the window's signal.\n\nWhen we click the button the window title will change at random. If the new window title equals \"Something went wrong\" the button will be disabled.\n\nRun it! Click the button repeatedly until the title changes to \"Something went wrong\" and the button will become disabled.\n\nThere are a few things to notice in this example.\n\nFirstly, the signal is not always emitted when setting the window title. The signal only fires if the new title is changed from the previous one. If you set the same title multiple times, the signal will only be fired the first time. It is important to double-check the conditions under which signals fire, to avoid being surprised when using them in your app.\n\nSecondly, notice how we are able to chain things together using signals. One thing happening -- a button press -- can trigger multiple other things to happen in turn. These subsequent effects do not need to know what caused them, but simply follow as a consequence of simple rules. This decoupling of effects from their triggers is one of the key concepts to understand when building GUI applications. We'll keep coming back to this throughout the book!\n\nIn this section we've covered signals and slots. We've demonstrated some simple signals and how to use them to pass data and state around your application. Next we'll look at the widgets which Qt provides for use in your applications -- together with the signals they provide.\n\nSo far we've seen examples of connecting widget signals to Python methods. When a signal is fired from the widget, our Python method is called and receives the data from the signal. But you don't always need to use a Python function to handle signals -- you can also connect Qt widgets directly to one another.\n\nIn the following example, we add a widget and a to the window. In the for the window we connect our line edit signal to the method on the . Now any time the text changes in the the will receive that text to it's method.\n\nNotice that in order to connect the input to the label, the input and label must both be defined. This code adds the two widgets to a layout, and sets that on the window. We'll cover layouts in detail later, you can ignore it for now.\n\nRun it! Type some text in the upper box, and you'll see it appear immediately on the label.\n\nAny text typed in the input immediately appears on the label.\n\nMost Qt widgets have slots available, to which you can connect any signal that emits the same type that it accepts. The widget documentation has the slots for each widget listed under \"Public Slots\". For example, see https://doc.qt.io/qt-5/qlabel.html#public-slots[QLabel].\n\nEvery interaction the user has with a Qt application is an event. There are many types of event, each representing a different type of interaction. Qt represents these events using event objects which package up information about what happened. These events are passed to specific event handlers on the widget where the interaction occurred.\n\nBy defining custom, or extended event handlers you can alter the way your widgets respond to these events. Event handlers are defined just like any other method, but the name is specific for the type of event they handle.\n\nOne of the main events which widgets receive is the . QMouseEvent events are created for each and every mouse movement and button click on a widget. The following event handlers are available for handling mouse events --\n\nFor example, clicking on a widget will cause a to be sent to the event handler on that widget. This handler can use the event object to find out information about what happened, such as what triggered the event and where specifically it occurred.\n\nYou can intercept events by sub-classing and overriding the handler method on the class. You can choose to filter, modify, or ignore events, passing them up to the normal handler for the event by calling the parent class function with . These could be added to your main window class as follows. In each case will receive the incoming event.\n\nRun it! Try moving and clicking (and double-clicking) in the window and watch the events appear.\n\nYou'll notice that mouse move events are only registered when you have the button pressed down. You can change this by calling on the window. You may also notice that the press (click) and double-click events both fire when the button is pressed down. Only the release event fires when the button is released. Typically to register a click from a user you should watch for both the mouse down and the release.\n\nInside the event handlers you have access to an event object. This object contains information about the event and can be used to respond differently depending on what exactly has occurred. We'll look at the mouse event objects next.\n\nAll mouse events in Qt are tracked with the object, with information about the event being readable from the following event methods.\n\nYou can use these methods within an event handler to respond to different events differently, or ignore them completely. The positional methods provide both global and local (widget-relative) position information as objects, while buttons are reported using the mouse button types from the namespace.\n\nFor example, the following allows us to respond differently to a left, right or middle click on the window.\n\nThe button identifiers are defined in the Qt namespace, as follows --\n\nOn left-handed mice the left and right button positions are reversed, i.e. pressing the right-most button will return . This means you don't need to account for the mouse orientation in your code.\n\nContext menus are small context-sensitive menus which typically appear when right clicking on a window. Qt has support for generating these menus, and widgets have a specific event used to trigger them. In the following example we're going to intercept the a . This event is fired whenever a context menu is about to be shown, and is passed a single value of type .\n\nTo intercept the event, we simply override the object method with our new method of the same name. So in this case we can create a method on our subclass with the name and it will receive all events of this type.\n\nIf you run the above code and right-click within the window, you'll see a context menu appear. You can set up slots on your menu actions as normal (and re-use actions defined for menus and toolbars).\n\nWhen passing the initial position to the function, this must be relative to the parent passed in while defining. In this case we pass as the parent, so we can use the global position.\n\nJust for completeness, there is actually a signal-based approach to creating context menus.\n\nIt's entirely up to you which you choose.\n\nIn PyQt every widget is part of two distinct hierarchies: the Python object hierarchy, and the Qt layout hierarchy. How you respond or ignore events can affect how your UI behaves.\n\nOften you may want to intercept an event, do something with it, yet still trigger the default event handling behavior. If your object is inherited from a standard widget, it will likely have sensible behavior implemented by default. You can trigger this by calling up to the parent implementation using .\n\nThis is the Python parent class, not the PyQt .\n\nThe event will continue to behave as normal, yet you've added some non-interfering behavior.\n\nWhen you add a widget to your application, it also gets another parent from the layout. The parent of a widget can be found by calling . Sometimes you specify these parents manually, such as for or , often it is automatic. When you add a widget to your main window for example, the main window will become the widget's parent.\n\nWhen events are created for user interaction with the UI, these events are passed to the uppermost widget in the UI. So, if you have a button on a window, and click the button, the button will receive the event first.\n\nIf the first widget cannot handle the event, or chooses not to, the event will bubble up to the parent widget, which will be given a turn. This bubbling continues all the way up nested widgets, until the event is handled or it reaches the main window.\n\nIn your own event handlers you can choose to mark an event as handled calling --\n\nAlternatively, you can mark it as unhandled by calling on the event object. In this case the event will continue to bubble up the hierarchy.\n\nIf you want your widget to appear transparent to events, you can safely ignore events which you've actually responded to in some way. Similarly, you can choose to accept events you are not responding to in order to silence them."
    },
    {
        "link": "https://doc.qt.io/qtforpython-6/tutorials/basictutorial/signals_and_slots.html",
        "document": "Due to the nature of Qt, s require a way to communicate, and that’s the reason for this mechanism to be a central feature of Qt.\n\nIn simple terms, you can understand Signal and Slots in the same way you interact with the lights in your house. When you move the light switch (signal) you get a result which may be that your light bulbs are switched on/off (slot).\n\nWhile developing interfaces, you can get a real example by the effect of clicking a button: the ‘click’ will be the signal, and the slot will be what happens when that button is clicked, like closing a window, saving a document, etc.\n\nAll classes that inherit from or one of its subclasses, like , can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nQt’s widgets have many predefined signals and slots. For example, (base class of buttons in Qt) has a signal and (single line input field) has a slot named . So, a text input field with a button to clear the text could be implemented by placing a to the right of the and connecting its signal to the slot . This is done using the method of the signal:\n\nreturns a object, which can be used with the method to sever the connection.\n\nSignals can also be connected to free functions:\n\nConnections can be spelled out in code or, for widget forms, designed in the Signal-Slot Editor of Qt Widgets Designer.\n\nThe function takes an optional parameter of that specifies the behavior with regards to threads and event loops.\n\nWhen writing classes in Python, signals are declared as class level variables of the class . A -based button that emits a signal could look as follows: The constructor of takes a tuple or a list of Python types and C types: In addition to that, it can receive also a named argument that defines the signal name. If nothing is passed, the new signal will have the same name as the variable that it is being assigned to. Another useful option of is the arguments name, useful for QML applications to refer to the emitted values by name: // do something with 'sum'\n\nSlots in QObject-derived classes should be indicated by the decorator . Again, to define a signature just pass the types similar to the class. also accepts a and a keyword. The keyword defines the type that will be returned and can be a C or Python type. The keyword behaves the same way as in . If nothing is passed as name then the new slot will have the same name as the function that is being decorated. We recommend marking all methods used by signal connections with a decorator. Not doing causes run-time overhead due to the method being added to the when creating the connection. This is particularly important for classes registered with QML, where missing decorators can introduce bugs. Missing decorators can be diagnosed by setting activating warnings of the logging category ; for example by setting the environment variable:\n\nOverloading Signals and Slots with Different Types¶ It is actually possible to use signals and slots of the same name with different parameter type lists. This is legacy from Qt 5 and not recommended for new code. In Qt 6, signals have distinct names for different types. The following example uses two handlers for a Signal and a Slot to showcase the different functionality. # create two new signals on the fly: one will handle # int type, the other will handle strings # define a new slot that receives a C 'int' or a 'str' # and has 'say_something' as its name # we have to specify the str as int is the default"
    },
    {
        "link": "https://stackoverflow.com/questions/35443399/pyqt-what-signal-does-my-standard-apply-button-emit-and-how-do-i-write-the-s",
        "document": "You don't need to write slots for and , because the class already has them.\n\nWhen you create a new form and choose \"Dialog with Buttons\", it will add a button-box with Ok and Cancel buttons, and the signals will be automatically connected to the dialog's existing and slots.\n\nBut note that there is no one-to-one relationship between the buttons and signals. Instead, there is a set of button roles, and each standard button is assigned one of those roles. All buttons with the will emit the signal, those with the will emit the signal, whilst those with the will emit the signal. But the other roles (such as the ), do not emit any specific signals other than .\n\nTo handle these other buttons you can either connect to each one directly:\n\nor handle them all in a single slot like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/61201337/pyqt5-the-connected-slot-to-a-clicked-signal-not-working",
        "document": "The problem is that you didn't create a persistent object for the controller instance, so the instance is immediately garbage collected afterwards because it isn't referenced anywhere else.\n\nAs long as a reference to the instance exists, it will work as expected.\n\n In this case a local variable will suffice, since will block further processing within , ensuring that the instance will exist until it exists.\n\nNonetheless, let me tell you that while conceptually using an MVC is usually a good idea, you should use it carefully, without \"exaggerating\" the pattern and only if it really helps the development.\n\nI'd like to point up one of the disadvantages of MVC:\n\nI understand that yours is a simple and conceptual example, but it certainly is an overly complicated one for what it does. For instance:\n• you don't seem to be using a model, or at least it doesn't seem that you need a full MVC pattern to do that (one should choose an MVC whenever there's actual advantage in doing so, not \"because you should use it\");\n• using an MVC pattern doesn't necessarily mean that you have to use 3 classes (and 3 separate files) which might also decrease the code navigability; MVC is mostly about the way the three elements are divided in the program logic: Qt (as most frameworks that provide UI elements) already helps with that, since it provides ui elements that do almost nothing besides showing themselves, and other elements that allow interacting with them (file access, network interfaces and actual models);\n• overusing functions to create the UI is usually a bad idea, as it makes things much more complicated than they are, most importantly from the point of view of readability: while using separate functions might help in keeping your code \"tidier\", functions are also created for their reusability, and in your class there are 4 functions that will most certainly be used only once."
    },
    {
        "link": "https://w3resource.com/python-exercises/pyqt/python-pyqt-connecting-signals-to-slots-exercise-7.php",
        "document": "Write a Python program that creates a button and when clicked sends a message with a specific value. Use the PyQt module.\n\nQApplication Class: The QApplication class manages the GUI application's control flow and main settings.\n\nQWidget Class: The QWidget class is the base class of all user interface objects.\n\nIn the exercise above -\n• Import the necessary modules from PyQt5.\n• Create a custom signal emitter class \"MySignalEmitter\", which defines a custom signal named 'custom_signal'. This signal can send a string value when emitted.\n• Create a custom widget class \"MyCustomWidget\", which contains a button. When the button is clicked, it emits the custom_signal with the message \"Exercises from w3resource!\"\n• Define a custom slot function \"custom_slot()\" that receives and prints the value sent by the signal.\n• In the main() function, we create the PyQt application, instantiate the \"MyCustomWidget\" class, set the window properties, and connect the custom signal to the custom slot."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/uf6fn6/best_practices_pyqt5_file",
        "document": "I'm trying to design a GUI for my Python program and I used Qt Designer to design it. Qt Designer outputs a *.ui file that I convert to *.py file running in the terminal the command:\n\nThe first lines of the file are:\n\nThe file structure of my project is:\n\nNow what I want to do is using the and its methods and attrs (e.g: pushbutton, lineedit etc. etc.) present in in in order not to modify the former file.\n\nHow do I do that?"
    },
    {
        "link": "https://realpython.com/python-pyqt-gui-calculator",
        "document": "Even though web and mobile applications appear to have taken over the software development market, there’s still demand for traditional graphical user interface (GUI) desktop applications. If you’re interested in building these kinds of applications in Python, then you’ll find a wide variety of libraries to choose from. They include Tkinter, wxPython, PyQt, PySide, and a few others.\n\nIn this tutorial, you’ll learn the basics of building GUI desktop applications with Python and PyQt.\n\nIn this tutorial, you’ll learn how to:\n• Connect the user’s events on the app’s GUI with the app’s logic\n\nFor this tutorial, you’ll create a calculator app with Python and PyQt. This short project will help you grasp the fundamentals and get you up and running with this GUI library.\n\nYou can download the source code for the project and all examples in this tutorial by clicking on the link below:\n\nYou have several options for installing PyQt on your system or development environment. The recommended option is to use to use binary wheels. Wheels are the standard way to install Python packages from the Python package index, PyPI. In any case, you need to consider that wheels for PyQt6 are only available for Python 3.6.1 and later. There are wheels for Linux, macOS, and Windows (64-bit). All of these wheels include copies of the corresponding Qt libraries, so you won’t need to install them separately. Another installation option is to build PyQt from source. This can be a bit complicated, so you might want to avoid it if possible. If you really need to build from source, then check out what the library’s documentation recommends in those cases. Alternatively, you have the option of using package managers, such as APT on Linux or Homebrew on macOS, to install PyQt6. In the next few sections, you’ll go through some of the options for installing PyQt6 from different sources and on different platforms. Most of the time, you should create a Python virtual environment to install PyQt6 in an isolated way. To create a virtual environment and install PyQt6 in it, run the following on your command line: Here, you first create a virtual environment using the module from the standard library. Then you activate it, and finally you install PyQt6 in it using . Note that you must have Python 3.6.1 or later for the install command to work correctly. You’ll rarely need to install PyQt directly on your system Python environment. If you ever need to do this kind of installation, then run the following command on your command line or in your terminal window without activating any virtual environment: With this command, you’ll install PyQt6 in your system Python environment directly. You can start using the library immediately after the installation finishes. Depending on your operating system, you may need root or administrator privileges for this installation to work. Even though this is a fast way to install PyQt6 and start using it right away, it’s not the recommended approach. The recommended approach is to use a Python virtual environment, as you learned in the previous section. Several Linux distributions include binary packages for PyQt6 in their repositories. If this your case, then you can install the library using the distribution’s package manager. On Ubuntu, for example, you can use the following command: With this command, you’ll install PyQt6 and all of its dependencies in your base system, so you can use the library in any of your GUI projects. Note that root privileges are needed, which you invoke here with the command. If you’re a macOS user, then you can install PyQt6 using the Homebrew package manager. To do this, open a terminal and run the following command: After running this command, you’ll have PyQt6 installed on your Homebrew Python environment, and it’ll be ready for you to use. If you use a package manager on Linux or macOS, then there’s a chance you won’t get the latest version of PyQt6. A installation will be better if you want to ensure that you have the latest release.\n\nNow that you have a working PyQt installation, you’re ready to create your first GUI app. You’ll create a application with Python and PyQt. Here are the steps that you’ll follow:\n• Import and all the required widgets from . You can download the source code for the examples that you’ll code in this section by clicking the link below: Download Code: Click here to download the code that you’ll use to build a calculator in Python with PyQt in this tutorial. To kick things off, start by creating a new file called in your current working directory: \"\"\"Simple Hello, World example with PyQt6.\"\"\" # 1. Import QApplication and all the required widgets First, you import , which will allow you to handle the application’s termination and exit status through the function. Then you import , , and from , which is part of the package. With these imports, you’re done with step one. To complete step two, you just need to create an instance of . Do this as you would create an instance of any Python class: In this line of code, you create the instance of . You should create your instance before you create any GUI object in PyQt. Internally, the class deals with command-line arguments. That’s why you need to pass in a list of command-line arguments to the class constructor. In this example, you use an empty list because your app won’t be handling any command-line arguments. Note: You’ll often find that developers pass to the constructor of . This object contains the list of command-line arguments passed into a Python script. If your application needs to accept command-line arguments, then you should use to handle them. Otherwise, you can just use an empty list, like you did in the above example. Step three involves creating the application’s GUI. In this example, your GUI will be based on the class, which is the base class of all user interface objects in PyQt. Here’s how you can create the app’s GUI: In this code, is an instance of , which provides all the features that you’ll need to create the application’s window, or form. As its names suggests, sets the window’s title in your application. In this example, the app’s window will show as its title. Note: More precisely, this step requires you to create the app’s top-level or main window. The term application’s GUI is a bit generic. Typically, an application’s GUI consists of more than one window. You can use to define the window’s size and screen position. The first two arguments are the and screen coordinates where the window will be placed. The third and fourth arguments are the window’s and . Every GUI application needs widgets, or graphical components that make the app’s GUI. In this example, you use a widget, , to show the message on your application’s window. objects can display HTML-formatted text, so you can use the HTML element to provide the desired text as an header. Finally, you use to place at the coordinates on the application’s window. Note: In PyQt, you can use any widget—a subclass of —as a top-level window. The only condition is that the target widget must not have a widget. When you use a widget as your top-level window, PyQt automatically provides it with a title bar and turns it into a normal window. The parent-child relationship between widgets has two complementary purposes. A widget with no is considered a main or top-level window. In contrast, a widget with an explicit is a child widget, and it’s shown within its parent. This relationship is also known as ownership, with parents owning their children. The PyQt ownership model ensures that if you delete a parent widget, such as your top-level window, then all of its child widgets will automatically be deleted as well. To avoid memory leaks, you should always make sure that any object has a parent, with the sole exception of your top-level windows. You’re done with step three, so you can continue with the final two steps and get your PyQt GUI application ready to run: In this code snippet, you call on . The call to schedules a paint event, which is a request to paint the widgets that compose a GUI. This event is then added to the application’s event queue. You’ll learn more about PyQt’s event loop in a later section. Finally, you start the application’s event loop by calling . The call to is wrapped in a call to , which allows you to cleanly exit Python and release memory resources when the application terminates. You can run your first PyQt app with the following command: When you run this script, you’ll see a window that’ll look something like this: Your application shows a window based on . The window displays the message. To show the message, it uses a widget. And with that, you’ve written your first GUI desktop application using PyQt and Python! Isn’t that cool?\n\nYou’ll need to master the basic components of PyQt if you want to proficiently use this library to develop your GUI applications. Some of these components include: These elements are the building blocks of any PyQt GUI application. Most of them are represented as Python classes that live in the module. These elements are extremely important. You’ll learn more about them in the following few sections. Widgets are rectangular graphical components that you can place on your application’s windows to build the GUI. Widgets have several attributes and methods that allow you to tweak their appearance and behavior. They can also paint a representation of themselves on the screen. Widgets also detect mouse clicks, keypresses, and other events from the user, the window system, and other sources. Each time a widget catches an event, it emits a signal to announce its state change. PyQt has a rich and modern collection of widgets. Each of those widgets serves a different purpose. Some of the most common and useful PyQt widgets are: First up is the button. You can create a button by instantiating , a class that provides a classic command button. Typical buttons are , , , , , and . Here’s how they look on a Linux system: Buttons like these are perhaps the most commonly used widgets in any GUI. When someone clicks them, your app commands the computer to perform actions. This is how you can execute computations when a user clicks a button. Up next are labels, which you can create with . Labels let you display useful information as text or images: You’ll use labels like these to explain how to use your app’s GUI. You can tweak a label’s appearance in several ways. A label can even accept HTML-formatted text, as you saw earlier. You can also use labels to specify a keyboard shortcut to move the cursor focus to a given widget on your GUI. Another common widget is the line edit, also known as the input box. This widget allows you to enter a single line of text. You can create line edits with the class. Line edits are useful when you need to get the user’s input as plain text. Here’s how line edits look on a Linux system: Line edits like these automatically provide basic editing operations like copy, paste, undo, redo, drag, drop, and so on. In the above figure, you can also see that the objects on the first row show placeholder text to inform the user what kind of input is required. Combo boxes are another fundamental type of widget in GUI applications. You can create them by instantiating . A combo box will present your user with a dropdown list of options in a way that takes up minimal screen space. Here’s an example of a combo box that provides a dropdown list of popular programming languages: This combo box is read-only, which means that users can select one of several options but can’t add their own options. Combo boxes can also be editable, allowing users to add new options on the fly. Combo boxes can also contain pixmaps, strings, or both. The last widget that you’ll learn about is the radio button, which you can create with . A object is an option button that you can click to switch on. Radio buttons are useful when you need the user to select one of many options. All options in a radio button are visible on the screen at the same time: In this radio buttons group, only one button can be checked at a given time. If the user selects another radio button, then the previously selected button will switch off automatically. PyQt has a large collection of widgets. At the time of this writing, there are over forty available for you to use to create your application’s GUI. Here, you’ve studied only a small sample. However, that’s enough to show you the power and flexibility of PyQt. In the next section, you’ll learn how to lay out different widgets to build modern and fully functional GUIs for your applications. Now that you know about widgets and how they’re used to build GUIs, you need to know how to arrange a set of widgets so that your GUI is both coherent and functional. In PyQt, you’ll find a few techniques for laying out the widgets on a form or window. For instance, you can use the and methods to give widgets absolute sizes and positions. However, this technique can have some drawbacks. You’ll have to:\n• Do many manual calculations to determine the correct size and position of every widget\n• Do extra calculations to respond to window resize events\n• Redo most of your calculations when the window’s layout changes in any way Another technique involves using to calculate the widget’s size and position dynamically. In this case, you’ll have similar headaches as with the previous technique. The most effective and recommended technique is to use PyQt’s layout managers. They’ll increase your productivity, mitigate the risk of errors, and improve your code’s maintainability. Layout managers are classes that allow you to size and position your widgets on the application’s window or form. They automatically adapt to resize events and GUI changes, controlling the size and position of all their child widgets. Note: If you develop internationalized applications, then you’ve probably seen translated text get cut off mid-sentence. This is likely to happen when the target natural language is more verbose than the original one. Layout managers can help you prevent this common issue by automatically adjusting the widget size to the available space. However, this feature can sometimes fail with particularly wordy natural languages. The first layout manager class, , arranges widgets horizontally from left to right, like with the hypothetical widgets in the following figure: In the horizontal layout, the widgets will appear one next to the other, starting from the left. The code example below shows how to use to arrange three buttons horizontally: Here’s how this example creates a horizontal layout of buttons:\n• Lines 19 to 21 add three buttons to by calling the method.\n• Line 22 sets as your window’s layout with . When you run from your command line, you’ll get the following output: The above figure shows three buttons in a horizontal arrangement. The buttons are shown from left to right in the same order as you added them in your code. The next layout manager class is , which arranges widgets vertically from top to bottom, like in the following figure: Each new widget will appear beneath the previous one. This layout allows you to to construct vertical layouts and organize your widgets from top to bottom on your GUI. Here’s how you can create a object containing three buttons: On line 18, you create an instance of called . In the next three lines, you add three buttons to . Finally, you use the object to arrange the widget in a vertical layout through the method on line 22. When you run this sample application, you’ll get a window that looks something like this: This figure shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order as you added them to your code, from top to bottom. The third layout manager in your list is . This class arranges widgets in a grid of rows and columns. Every widget will have a relative position on the grid. You can define a widget’s position with a pair of coordinates like . Each coordinate must be an integer number. These pairs of coordinates define which cell on the grid a given widget will occupy. The grid layout will look something like this: takes the available space, divides it up into and , and puts each child widget into its own cell. Here’s how to create a grid layout arrangement in your GUI: In this example, you create an application that uses a object to organize its widgets on the screen. Note that, in this case, the second and third arguments that you pass to are integer numbers defining each widget’s position on the grid. On lines 26 to 28, you pass two more arguments to . These arguments are and , and they’re the fourth and fifth arguments passed to the function. You can use them to make a widget occupy more than one row or column, like you did in the example. If you run this code from your command line, then you’ll get a window that looks something like this: In this figure, you can see your widgets arranged in a grid of rows and columns. The last widget occupies two columns, as you specified on lines 26 to 28. The last layout manager that you’ll learn about is . This class arranges widgets in a two-column layout. The first column usually displays messages in labels. The second column generally contains widgets like , , , and so on. These allow the user to enter or edit data regarding the information in the first column. The following diagram shows how form layouts work in practice: The left column consists of labels, while the right column consists of input widgets. If you’re developing a database application, then this kind of layout can be a useful tool that’ll increase your productivity when creating input forms. The following example shows how to create an application that uses a object to arrange its widgets: Lines 18 to 23 do the hard work in this example. has a convenient method called . You can use this method to add a two-widget row to the layout. The first argument to should be a label or a string. Then, the second argument can be any widget that allows the user to enter or edit data. In this specific example, you’ve used line edits. If you run this code, then you’ll get a window that looks something like this: The above figure shows a window that uses a form layout. The first column contains labels to ask the user for some information. The second column shows widgets that allow the user to enter or edit the required information. With PyQt, you can develop two types of GUI desktop applications. Depending on the class that you use to create the main form or window, you’ll have one of the following: You’ll start with dialog-style applications first. In the next section, you’ll learn about main window–style applications. To develop a dialog-style application, you need to create a GUI class that inherits from , which is the base class of all dialog windows. A dialog window is a stand-alone window that you can use as the main window for your application. Note: Dialog windows are commonly used in main window–style applications for brief communication and interaction with the user. When you use dialog windows to communicate with the user, those dialogs can be:\n• Modal: Blocks input to any other visible windows in the same application. You can display a modal dialog by calling its method.\n• Modeless: Operates independently from other windows in the same application. You can display a modeless dialog by using its method. Dialog windows can also provide a return value and have default buttons, such as and . A dialog is always an independent window. If a dialog has a , then it’ll display centered on top of the parent widget. Dialogs with a parent will share the parent’s task bar entry. If you don’t set for a given dialog, then the dialog will get its own entry in the system’s task bar. Here’s an example of how you’d use to develop a dialog-style application: This application is a bit more elaborate. Here’s what this code does:\n• Line 16 defines a class for the app’s GUI by inheriting from .\n• Line 18 calls the parent class’s method using . This call allows you to properly initialize instances of this class. In this example, the argument is set to because this dialog will be your main window.\n• Line 26 calls on . This call embeds the form layout into the global dialog layout.\n• Line 27 defines a button box, which provides a convenient space to display the dialog’s buttons.\n• Lines 28 to 31 add two standard buttons, and , to the dialog.\n• Line 32 adds the button box to the dialog by calling . The construct wraps up the app’s main code. This kind of conditional statement is common in Python apps. It ensures that the indented code will only run if the containing file is executed as a program rather than imported as a module. For more about this construct, check out What Does if name == “main” Do in Python?. Note: On line 26 in the above example, you’ll note that layout managers can be nested inside one another. You can nest layouts by calling on the container layout with the nested layout as an argument. The above code example will show a window that looks something like this: This figure shows the GUI that you’ve created using a object to arrange the widgets and a layout for the application’s global layout. Most of the time, your GUI applications will be main window–style apps. This means that they’ll have a menu bar, some toolbars, a status bar, and a central widget that’ll be the GUI’s main element. It’s also common for your apps to have several dialogs to accomplish secondary actions that depend on a user’s input. You’ll inherit from to develop main window–style applications. An instance of a class that derives from is considered the app’s main window and should be unique. provides a framework for building your application’s GUI quickly. This class has its own built-in layout, which accepts the following graphical components: One or more toolbars Hold tool buttons and other widgets, such as , , and more Holds the window’s central widget, which can be of any type, including a composite widget One or more dock widgets You can’t create a main window without a central widget. You need a central widget even if it’s just a placeholder. When this is the case, you can use a object as your central widget. You can set the window’s central widget with the method. The main window’s layout will allow you to have only one central widget, but it can be a single or a composite widget. The following code example shows you how to use to create a main window–style application:\n• Line 17 calls the base class’s initializer. Again, the argument is set to because this is your app’s main window, so it must not have a parent.\n• Lines 20 to 22 call non-public methods to create different GUI elements:\n• Lines 24 to 26 create the main menubar with a drop-down menu called Menu. This menu will have a menu option to exit the app.\n• Lines 28 to 31 create the toolbar, which will have a toolbar button to exit the app. When you implement GUI components using their own methods, like you did with the menu bar, toolbar, and status bar in this example, you’re making your code more readable and more maintainable. Note: If you’re running this example on macOS, then you may have issues with the app’s main menu. macOS hides certain menu options, like Exit. Remember that macOS shows the Exit or Quit option under the app’s entry on the top of the screen. When you run the above sample application, you’ll get a window like the following: As you can confirm, your main window–style application has the following components:\n• One toolbar with an Exit tool button\n• One central widget consisting of a object with a text message\n• One status bar at the window’s bottom That’s it! You’ve learned how to build a main window–style application with Python and PyQt. Up to this point, you’ve learned about some of the more important graphical components in PyQt’s set of widgets. In the next few sections, you’ll study other important concepts related to building GUI applications with PyQt. is the most foundational class that you’ll use when developing PyQt GUI applications. This class is the core component of any PyQt application. It manages the application’s control flow as well as its main settings. In PyQt, any instance of is an application. Every PyQt GUI application must have one instance. Some of the responsibilities of this class include:\n• Providing access to global information, such as the application’s directory, screen size, and so on\n• Defining the application’s look and feel These are just some of the core responsibilities of . So, this is a fundamental class when it comes to developing PyQt GUI applications. One of the most important responsibilities of is to provide the event loop and the entire event handling mechanism. In the following section, you’ll take a closer look at what the event loop is and how it works. GUI applications are event-driven. This means that functions and methods are called in response to user actions, like clicking on a button, selecting an item from a combo box, entering or updating the text in a text edit, pressing a key on the keyboard, and so on. These user actions are commonly known as events. Events are handled by an event loop, also known as a main loop. An event loop is an infinite loop in which all events from the user, the window system, and any other sources are processed and dispatched. The event loop waits for an event to occur and then dispatches it to perform some task. The event loop continues to work until the application is terminated. All GUI applications have an event loop. When an event happens, then the loop checks if it’s a terminate event. In that case, the loop finishes, and the application exits. Otherwise, the event is sent to the application’s event queue for further processing, and the loop iterates again. In PyQt6, you can run the app’s event loop by calling on the object. For an event to trigger an action, you need to connect the event with the action that you want to execute. In PyQt, you can establish that connection with the signals and slots mechanism, which you’ll explore in the next section. PyQt widgets act as event-catchers. This means that every widget can catch specific events, like mouse clicks, keypresses, and so on. In response to these events, a widget emits a signal, which is a kind of message that announces a change in its state. The signal on its own doesn’t perform any action. If you want a signal to trigger an action, then you need to connect it to a slot. This is the function or method that’ll perform an action whenever its associated signal is emitted. You can use any Python callable as a slot. If a signal is connected to a slot, then the slot is called whenever the signal is emitted. If a signal isn’t connected to any slot, then nothing happens and the signal is ignored. Some of the most relevant features of signals and slots include the following:\n• A signal can be connected to one or many slots.\n• A signal may also be connected to another signal.\n• A slot may be connected to one or many signals. You can use the following syntax to connect a signal and a slot: This will connect to . From now on, whenever is emitted, will be called. The code below shows how to use the signals and slots mechanism in a PyQt application: On line 15, you create , which you’ll use as a slot. Then in line 27, you connect the button’s signal to . This way, whenever the user clicks the Greet button, the slot is called and the label object’s text alternates between and an empty string: When you click the Greet button, the message appears and disappears on your application’s main window. Note: Every widget has its own set of predefined signals. You can check them out on the widget’s documentation. If your slot function needs to receive extra arguments, then you can pass them using . For example, you can modify to take an argument, like in the following code: Now needs to receive an argument called . If you want to connect this new version of to the signal, then you can do something like this: For this code to work, you need to import from first. The call to returns a function object that behaves similarly to when called with . Now, when the user clicks on the button, the message will appear in the label just like before. Note: You can also use a function to connect a signal to a slot that requires extra arguments. As an exercise, try to code the above example using instead of . The signals and slots mechanism is what you’ll use to give life to your PyQt GUI applications. This mechanism will allow you to turn user events into concrete actions. You can dive deeper into signals and slots by checking out the PyQt6 documentation on the topic. Now you know the basics of several important concepts of PyQt. With this knowledge and the library’s documentation at hand, you’re ready to start developing your own GUI applications. In the next section, you’ll build your first fully functional GUI application.\n\nIn this section, you’ll develop a calculator GUI app using the Model-View-Controller (MVC) design pattern. This pattern has three layers of code, with each one having different roles:\n• The model takes care of your app’s business logic. It contains the core functionality and data. In your calculator app, the model will handle the input values and the calculations.\n• The view implements your app’s GUI. It hosts all the widgets that the end user would need to interact with the application. The view also receives a user’s actions and events. For your example, the view will be the calculator window on your screen.\n• The controller connects the model and the view to make the application work. Users’ events, or requests, are sent to the controller, which puts the model to work. When the model delivers the requested result, or data, in the right format, the controller forwards it to the view. In your calculator app, the controller will receive the target math expressions from the GUI, ask the model to perform calculations, and update the GUI with the result. Here’s a step-by-step description of how your GUI calculator app will work:\n• The user performs an action or request (event) on the view (GUI).\n• The view notifies the controller about the user’s action.\n• The controller gets the user’s request and queries the model for a response.\n• The model processes the controller’s query, performs the required computations, and returns the result.\n• The controller receives the model’s response and updates the view accordingly.\n• The user finally sees the requested result on the view. You’ll use this MVC design to build your calculator app with Python and PyQt. Creating the Skeleton for Your PyQt Calculator App To kick things off, you’ll start by implementing a minimal skeleton for your application in a file called . You can get this file and the rest of the source code for your calculator app by clicking the link below: Download Code: Click here to download the code that you’ll use to build a calculator in Python with PyQt in this tutorial. If you’d prefer to code the project on your own, then go ahead and create in your current working directory. Open the file in your favorite code editor or IDE and type the following code: \"\"\"PyCalc is a simple calculator built with Python and PyQt.\"\"\" This script implements all the boilerplate code that you’ll need to run a basic GUI application. You’ll use this skeleton to build your calculator app.\n• Line 5 imports . This module provides the function, which you’ll use to cleanly terminate the app.\n• Line 9 creates a Python constant to hold a fixed window size in pixels for your calculator app.\n• Line 11 creates the class to provide the app’s GUI. Note that this class inherits from .\n• Line 15 calls on the super class for initialization purposes.\n• Line 17 uses to give the window a fixed size. This ensures that the user won’t be able to resize the window during the app’s execution.\n• Lines 18 and 19 create a object and set it as the window’s central widget. This object will be the parent of all the required GUI components in your calculator app.\n• Line 21 defines your calculator’s main function. Having a function like this is a best practice in Python. This function provides the application’s entry point. Inside , your program does the following:\n• Line 24 creates an instance of the app’s window, .\n• Line 25 shows the GUI by calling on the window object. Finally, line 29 calls to execute your calculator app. When you run the above script, the following window appears on your screen: That’s it! You’ve successfully built a fully functional app skeleton for your GUI calculator app. Now you’re ready to continue building the project. The GUI that you have at this point doesn’t really look like a calculator. You need to finish this GUI by adding a display to show the target math operation and a keyboard of buttons representing numbers and basic math operators. You’ll also add buttons representing other required symbols and actions, like clearing the display. First, you need to update your imports like in the code below: You’ll use a layout manager for the calculator’s global layout. To arrange the buttons, you’ll use a object. The class will work as the calculator’s display and will provide the required buttons. Now you can update the initializer for : You’ve added the highlighted lines of code. You’ll use as the app’s general layout. In this layout, you’ll place the display at the top and the keyboard buttons in a grid layout at the bottom. The calls to and won’t work at this point, because you haven’t implemented those methods yet. To fix this issue, you’ll start by coding . Get back to your code editor and update like in the following code: In this code snippet, you first define a new constant to hold the display height in pixels. Then you define inside . To create the calculator’s display, you use a widget. Then you set a fixed height of thirty-five pixels for your display using the constant. The display will have its text right-aligned. Finally, the display will be read-only to prevent direct editing by the user. The last line of code adds the display to the calculator’s general layout. Next up, you’ll implement the method to create the required buttons for your calculator’s keyboard. These buttons will live in a grid layout, so you need a way to represent their coordinates on the grid. Each coordinate pair will consist of a row and a column. To represent a coordinate pair, you’ll use a list of lists. Each nested list will represent a row. Now go ahead and update the file with the following code: In this piece of code, you define a new constant called . You’ll use this constant to provide the size of your calculator’s buttons. In this specific example, all the buttons will have a square shape with forty pixels per side. With this initial setup, you can code the method. You’ll use a list of lists to hold the keys or buttons and their position on the calculator keyboard. A will allow you to arrange the buttons on the calculator’s window: You first create the empty dictionary to hold the calculator buttons. Then, you create a list of lists to store the key labels. Each row or nested list will represent a row in the grid layout, while the index of each key label will represent the corresponding column on the layout. Then you define two loops. The outer loop iterates over the rows and the inner loop iterates over the columns. Inside the inner loop, you create the buttons and add them to both and . Every button will have a fixed size of pixels, which you set with and the constant. Finally, you embed the grid layout into the calculator’s general layout by calling on the object. Note: When it comes to widget size, you’ll rarely find measurement units in the PyQt documentation. The measurement unit is assumed to be pixels, except when you’re working with class, which uses points. Now your calculator’s GUI will show the display and the buttons gracefully. However, you have no way to update the information shown on the display. You’ll fix this by adding a few extra methods to : These methods will provides the GUI’s public interface and complete the view class for your Python calculator app. Here’s a breakdown of what each method does:\n• uses to set and update the display’s text. It also uses to set the cursor’s focus on the display.\n• is a getter method that returns the display’s current text. When the user clicks the equal sign ( ) on the calculator’s keyboard, the app will use the return value of as the math expression to be evaluated.\n• sets the display’s text to an empty string ( ) so that the user can introduce a new math expression. This method will be triggered every time the user presses the C button on the calculator’s board. Now your calculator’s GUI is ready for use! When you run the application, you’ll get a window like the following: You’ve completed the calculator’s GUI, which looks pretty sleek! However, if you try to do some calculations, then the calculator won’t respond as expected. That’s because you haven’t implemented the model and the controller components. In the next section, you’ll write the calculator’s model. In the MVC pattern, the model is the layer of code that takes care of the business logic. In your calculator app, the business logic is all about basic math calculations. So, your model will evaluate the math expressions that your users introduced in the calculator’s GUI. The calculator’s model also needs to handle errors. To this end, you’ll define the following global constant: This constant is the message that the user will see on the calculator’s display if they introduce an invalid math expression. With the above change, you’re ready to code your app’s model, which will be a single function in this example: In , you use to evaluate a math expression that comes as a string. If the evaluation is successful, then you return . Otherwise, you return the predefined error message. Note that this function isn’t perfect. It has a couple of important issues:\n• The … block doesn’t catch a specific exception, so it’s using a practice that’s discouraged in Python.\n• The function uses , which can lead to some serious security issues. You’re free to rework the function to make it more reliable and secure. In this tutorial, you’ll use the function as is to keep the focus on implementing the GUI. Creating the Controller Class for Your Calculator In this section, you’re going to code the calculator’s controller class. This class will connect the view to the model that you just coded. You’ll use the controller class to make the calculator perform actions in response to user events. Your controller class needs to perform three main tasks:\n• Connect all the buttons’ signals with the appropriate slots. To perform all these actions, you’ll code a new class in a moment. Go ahead and update with the following code: At the top of , you import from . You’ll use this function to connect signals with methods that need to take extra arguments. Inside , you define the class initializer, which takes two arguments: the app’s model and its view. Then you store these arguments in appropriate instance attributes. Finally, you call to make all the required connections of signals and slots. In , you use to evaluate the math expression that the user has just typed into the calculator’s display. Then you call on the calculator’s view to update the display text with the computation result. As its name suggests, the method takes care of building the target math expression. To do this, the method concatenates the initial display value with every new value that the user enters on the calculator’s keyboard. Finally, the method connects all the buttons’ signals with the appropriate slots method in the controller class. That’s it! Your controller class is ready. However, for all this code to work as a real calculator, you need to update the app’s function like in the code below: This piece of code creates a new instance of . The argument to the class constructor holds a reference to the function, while the argument holds a reference to the object, which provides the app’s GUI. Now your PyQt calculator application is ready to run. Now that you’ve finished writing your calculator app with Python and PyQt, it’s time for a live test! If you run the application from your command line, then you’ll get something like this: To use PyCalc, enter a valid math expression with your mouse. Then, press or click the equal sign ( ) button to compute and show the expression result on the calculator’s display. That’s it! You’ve developed your first fully functional GUI desktop application with Python and PyQt!"
    },
    {
        "link": "https://stackoverflow.com/questions/44802242/properly-use-ui-with-pyqt5",
        "document": "my goal is to bring a .ui interface in a python program. It barely works but I would like to improve it since I can't obtain exactly what I want.\n\nFor now I have to create a layout to paste my sss.ui to. The QVboxLayout dosen't respect the stylesheet I setup in Qt Designer. How can I use my sss.ui directly ? Do I need to convert it ? I unable to find the pyuic5 in my Qt install ..."
    },
    {
        "link": "https://stackoverflow.com/questions/64352306/how-can-i-implement-an-ui-file-to-package-a-pyqt5-application-with-fbs",
        "document": "EDIT: My question might duplicate with this one: link. I was used to search through Google, haven't realized I should look through Stack search bar.\n\nI have been trying to package a PyQt5 application with Pyinstaller (without success) and decided to give it a try using fbs. But I am struggling to rewrite my main python file to make it work with the compiler. After two weeks trying to figure out how to finally solve these issue, I would like to request help from more advanced developers.\n\nMy project is a virtual board with draggable elements organized this way:\n• a folder with images (used while creating the UI with Qt Designer)\n\nFirst version of code (before trying to convert it to fbs):\n\nThis code would work fine when compiled, but I could not have it packaged for distribution no matter what I tried - the console would open but the UI would never appear. So I have decided to give it a try with fbs (which, as a bonus, would force me to start thinking more about the project organization next time):\n\nNew version of code (attempting to organize the project according to the fbs guideline):\n\nThis code would not even compile, I receive this traceback:\n\nI have tried to use the solution proposed there (for UI implementation): https://forum.learnpyqt.com/t/ui-files-with-fbs/61/2\n\nBut I suppose I could not figure out how to implement it properly. About the \"Wrong base class of toplevel widget\" I have no idea what to do. I really would like to find out what my next steps must be and get an understanding of it.\n\nI shall precise I am using Python 3.6 and working on PyCharm.\n\nI am pretty new to programming and this is my very first question on Stack Overflow (which has been so useful during the past months), so please let me know if something is unclear, I will do my best to explain it more correctly.\n\nThank you for your insight!\n\nThe selected answer helped. FOr other reasons I had to change the structure a bit, though, here is the current code:\n\nI followed the structure shown by eyllanesc and included the folder with the pictures used in Qt Designer to build the UI directly in the UI folder. Now the project runs well with the fbs run command. The executable obtained after freezing returns a \"no module named main\" error, but it seems to be linked to other reasons."
    },
    {
        "link": "https://h2kinfosys.com/blog/setup-pyqt5-and-design-gui-applications",
        "document": "Python is a versatile programming language widely used in various domains, from web development to artificial intelligence. One of its powerful libraries, PyQt5, allows developers to create stunning graphical user interfaces (GUI). Whether you are an aspiring software developer, a data analyst, or an automation engineer, learning GUI design can significantly enhance your skill set.\n\nGraphical interfaces are essential for software usability, as they enable users to interact with applications visually rather than through the command line. simplifies GUI creation by providing a robust set of tools and widgets, making it easier to develop professional applications quickly.\n\nWith the growing demand for Python developers in fields like finance, healthcare, and cybersecurity, mastering that can help you stand out in the job market. Whether you want to build desktop applications, automation tools, or data visualization dashboards, It provides the flexibility needed to create customized solutions.\n\nIn this guide, we will walk you through setting up to designing GUI applications from scratch. By the end, you will be equipped to build interactive desktop applications using. If you are looking for structured guidance, enroll in an Online Class For Python at H2K Infosys, where you can learn Python online with expert-led training.\n\nIt is a set of Python bindings for the Qt application framework, widely used to develop cross-platform desktop applications. Here’s why it is an excellent choice for GUI development:\n• Rich Widgets and Components: Provides a vast collection of ready-to-use widgets.\n• Highly Customizable: Allows full control over UI design and styling.\n• Industry Adoption: Used in applications like Autodesk Maya and VLC Media Player.\n\nIf you’re considering an online training Python course, learning it can Open Doors to career opportunities in desktop application development.\n\nBefore designing GUI applications, you need to install the on your system. Follow these steps:\n\nEnsure you have Python installed on your system. If not, download and install the latest version from Python.org.\n\nTo verify Python installation, open the terminal (or Command Prompt) and type:\n\nIf Python is installed correctly, you will see the installed version number displayed.\n\nIt can be installed using pip:\n\nThis command installs the required to modules along with Qt Designer, a graphical tool for designing UI layouts.\n\nOnce installed, check if it is available by running:\n\nIf no errors occur, It is ready to use!\n\nTo enhance your development experience, consider installing additional tools:\n• PyCharm or VS Code: Advanced IDEs that support development.\n• pyuic5: A command-line tool to convert UI files created in Qt Designer to Python code.\n\nDesigning Your First GUI Application with PyQt5\n\nCreate a new Python script ( ) and add the following code:\n• : Sets the title of the application window.\n• : Defines the initial size of the window.\n\nRun the script, and you will see a basic window appear.\n\nInstead of coding the UI manually, you can use Qt Designer to create the interface visually.\n• Drag and drop widgets (buttons, labels, input fields) onto the canvas.\n• Adjust the widget properties using the property editor.\n\nUse the tool to convert the UI file:\n\nNow, contains the Python equivalent of your UI design.\n• : Changes label text when the button is clicked.\n\nRun the script, and clicking the button updates the label text.\n\nWith these enhancements, you will have a well-structured introduction and detailed setup guide for PyQt5, making it easier for learners to follow.\n\nIt is widely used across industries for developing applications such as:\n• Banking Software: Many financial applications use PyQt5 for data visualization.\n• Medical Applications: Used for medical imaging software and data management.\n\nA recent survey by Stack Overflow found that Python is the most sought-after language for enterprise applications, reinforcing the demand for PyQt5 skills.\n• Installing PyQt5 and Qt Designer is straightforward with pip.\n• It is widely used in banking, medical, and enterprise applications.\n• Learning if can enhance your Python Programming language certification.\n\nMastering PyQt5 opens up career opportunities in GUI application development. Enroll in our online class for Python at H2K Infosys to gain hands-on experience and elevate your programming skills!"
    }
]