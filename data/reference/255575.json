[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Random.html",
        "document": "\n• seed. The general contract of is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument as a seed. The method is implemented by class by atomically updating the seed to and clearing the flag used by Sets the seed of this random number generator using a singleseed. The general contract ofis that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argumentas a seed. The methodis implemented by classby atomically updating the seed toand clearing theflag used by The implementation of by class happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the argument as a seed value.\n• Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of is that it returns an value and if the argument is between and (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be or . The method is implemented by class by atomically updating the seed to and returning This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1. and returningThis is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth inVolume 3:, section 3.2.1. the next pseudorandom value from this random number generator's sequence\n• Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method is implemented by class as if by: - the byte array to fill with random bytes - if the byte array is null\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. All 232 possible values are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. All 2possiblevalues are produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of is that one value in the specified range is pseudorandomly generated and returned. All possible values are produced with (approximately) equal probability. The method is implemented by class as if by: public int nextInt(int bound) { if (bound <= 0) throw new IllegalArgumentException(\"bound must be positive\"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; } Returns a pseudorandom, uniformly distributedvalue between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract ofis that onevalue in the specified range is pseudorandomly generated and returned. Allpossiblevalues are produced with (approximately) equal probability. The methodis implemented by classas if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2. The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two. - the upper bound (exclusive). Must be positive. the next pseudorandom, uniformly distributed value between zero (inclusive) and (exclusive) from this random number generator's sequence - if bound is not positive\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The method is implemented by class as if by: Because class uses a seed with only 48 bits, this algorithm will not return all possible values. Because classuses a seed with only 48 bits, this algorithm will not return all possiblevalues. the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. The values and are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The valuesandare produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. All 224 possible values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value with mean and standard deviation from this random number generator's sequence. Returns the next pseudorandom, Gaussian (\"normally\") distributedvalue with meanand standard deviationfrom this random number generator's sequence. The general contract of is that one value, chosen from (approximately) the usual normal distribution with mean and standard deviation , is pseudorandomly generated and returned. The method is implemented by class as if by a threadsafe version of the following: private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() { if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } } This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to and one call to . This uses theof G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in, Volume 3:, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call toand one call to the next pseudorandom, Gaussian (\"normally\") distributed value with mean and standard deviation from this random number generator's sequence\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom , each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandom, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values, each between zero (inclusive) and one (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values, each between zero (inclusive) and one (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero - if is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Random.html",
        "document": "\n• seed. The general contract of is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument as a seed. The method is implemented by class by atomically updating the seed to and clearing the flag used by Sets the seed of this random number generator using a singleseed. The general contract ofis that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argumentas a seed. The methodis implemented by classby atomically updating the seed toand clearing theflag used by The implementation of by class happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the argument as a seed value.\n• Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of is that it returns an value and if the argument is between and (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be or . The method is implemented by class by atomically updating the seed to and returning This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 2: Seminumerical Algorithms, section 3.2.1. and returningThis is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth inVolume 2:, section 3.2.1. the next pseudorandom value from this random number generator's sequence\n• Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method is implemented by class as if by: - the byte array to fill with random bytes - if the byte array is null\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. All 232 possible values are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. All 2possiblevalues are produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of is that one value in the specified range is pseudorandomly generated and returned. All possible values are produced with (approximately) equal probability. The method is implemented by class as if by: public int nextInt(int bound) { if (bound <= 0) throw new IllegalArgumentException(\"bound must be positive\"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; } Returns a pseudorandom, uniformly distributedvalue between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract ofis that onevalue in the specified range is pseudorandomly generated and returned. Allpossiblevalues are produced with (approximately) equal probability. The methodis implemented by classas if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2. The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two. - the upper bound (exclusive). Must be positive. the next pseudorandom, uniformly distributed value between zero (inclusive) and (exclusive) from this random number generator's sequence - if bound is not positive\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The method is implemented by class as if by: Because class uses a seed with only 48 bits, this algorithm will not return all possible values. Because classuses a seed with only 48 bits, this algorithm will not return all possiblevalues. the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. The values and are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The valuesandare produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. All 224 possible values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value with mean and standard deviation from this random number generator's sequence. Returns the next pseudorandom, Gaussian (\"normally\") distributedvalue with meanand standard deviationfrom this random number generator's sequence. The general contract of is that one value, chosen from (approximately) the usual normal distribution with mean and standard deviation , is pseudorandomly generated and returned. The method is implemented by class as if by a threadsafe version of the following: private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() { if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } } This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 2: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to and one call to . This uses theof G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in, Volume 2:, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call toand one call to the next pseudorandom, Gaussian (\"normally\") distributed value with mean and standard deviation from this random number generator's sequence\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom , each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandom, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values, each between zero (inclusive) and one (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values, each between zero (inclusive) and one (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero - if is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to"
    },
    {
        "link": "https://geeksforgeeks.org/java-util-random-class-java",
        "document": "Random class is used to generate pseudo-random numbers in java. An instance of this class is thread-safe. The instance of this class is however cryptographically insecure. This class provides various method calls to generate different random data types such as float, double, int.\n• java.util.Random.doubles(): Returns an effectively unlimited stream of pseudo random double values, each between zero (inclusive) and one (exclusive)\n\n Syntax:\n• next(int bits): java.util.Random.next(int bits) Generates the next pseudo random number\n\n Syntax: protected int next(int bits) Parameters: bits - random bits Returns: the next pseudo random value from this random number generator's sequence\n• java.util.Random.nextBoolean(): Returns the next pseudo random, uniformly distributed boolean value from this random number generator’s sequence\n\n Syntax: public boolean nextBoolean() Returns: the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence\n• java.util.Random.nextBytes(byte[] bytes) :Generates random bytes and places them into a user-supplied byte array\n\n Syntax: public void nextBytes(byte[] bytes) Parameters: bytes - the byte array to fill with random bytes Throws: NullPointerException - if the byte array is null\n• java.util.Random.nextDouble(): Returns the next pseudo random, uniformly distributed double value between 0.0 and 1.0 from this random number generator’s sequence\n\n Syntax: public double nextDouble() Returns: the next pseudo random, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence\n• java.util.Random.nextFloat(): Returns the next pseudo random, uniformly distributed float value between 0.0 and 1.0 from this random number generator’s sequence\n\n Syntax: public float nextFloat() Returns: the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence\n• java.util.Random.nextGaussian(): Returns the next pseudo random, Gaussian (“normally”) distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator’s sequence\n\n Syntax: public double nextGaussian() Returns: the next pseudorandom, Gaussian (\"normally\") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence\n• java.util.Random.nextInt(): Returns the next pseudorandom, uniformly distributed int value from this random number generator’s sequence\n\n Syntax: public int nextInt() Returns: the next pseudorandom, uniformly distributed int value from this random number generator's sequence\n• java.util.Random.nextInt(int bound): Returns a pseudo random, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator’s sequence\n\n Syntax: public int nextInt(int bound) Parameters: bound - the upper bound (exclusive). Must be positive. Returns: the next pseudorandom, uniformly distributed int value between zero (inclusive) and bound (exclusive) from this random number generator's sequence Throws: IllegalArgumentException - if bound is not positive\n• java.util.Random.nextLong(): Returns the next pseudorandom, uniformly distributed long value from this random number generator’s sequence\n\n Syntax: public long nextLong() Returns: the next pseudorandom, uniformly distributed long value from this random number generator's sequence\n• java.util.Random.setSeed(long seed): Sets the seed of this random number generator using a single long seed\n\n Syntax:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-random",
        "document": "Java Random class is used to generate a series of random numbers.\n• An instance of java Random class is used to generate random numbers.\n• This class provides several methods to generate random numbers of type integer, double, long, float etc.\n• Random number generation algorithm works on the seed value. If not provided, seed value is created from system nano time.\n• If two Random instances have same seed value, then they will generate same sequence of random numbers.\n• Java Random class is thread-safe, however in multithreaded environment it’s advised to use class.\n• Random class instances are not suitable for security sensitive applications, better to use in those cases.\n\nJava Random class has two constructors which are given below:\n• : creates new random generator using specified seed\n\nLet’s have a look at some of the methods of java Random class.\n• : This method returns next pseudorandom which is a boolean value from random number generator sequence.\n• : This method returns next pseudorandom which is double value between 0.0 and 1.0.\n• : This method returns next pseudorandom which is float value between 0.0 and 1.0.\n• : This method returns next int value from random number generator sequence.\n• nextInt(int n): This method return a pseudorandom which is int value between 0 and specified value from random number generator sequence.\n\nLet’s have a look at the below java Random example program.\n\nOutput of the above program is:\n\nCheck this post for more about Java Radom Number Generation.\n\nThere are two ways we can generate random number using seed.\n\nThe seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next(int).\n\nOutput of the above program is:\n\nWhat if we pass same seed to two different random number generators? Let’s have a look at the below program and see what happen if we pass same seed to two different random number generators.\n\nOutput of the above program is:\n\nWe can see that it will generate same random number if we pass same seed to two different random number generators.\n\nAs you can see from above image, there are many new methods added in Java 8 to Random class. These methods can produce a stream of random numbers. Below is a simple program to generate a stream of 5 integers between 1 and 100.\n\nThat’s all for a quick roundup on Java Random Class. Reference: API Doc"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/java.util.random?view=net-android-34.0",
        "document": "An instance of this class is used to generate a stream of pseudorandom numbers; its period is only 2<sup>48</sup>. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald E. Knuth, <cite>The Art of Computer Programming, Volume 2, Third edition: Seminumerical Algorithms</cite>, Section 3.2.1.)\n\nIf two instances of are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class . Java implementations must use all the algorithms shown here for the class , for the sake of absolute portability of Java code. However, subclasses of class are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.\n\nThe algorithms implemented by class use a utility method that on each invocation can supply up to 32 pseudorandomly generated bits.\n\nMany applications will find the method simpler to use.\n\nInstances of are threadsafe. However, the concurrent use of the same instance across threads may encounter contention and consequent poor performance. Consider instead using in multithreaded designs.\n\nInstances of are not cryptographically secure. Consider instead using to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License.\n\nCreates and returns a copy of this object. (Inherited from Object) Indicates whether some other object is \"equal to\" this one. (Inherited from Object) Returns a hash code value for the object. (Inherited from Object) Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. (Inherited from Object) Returns the next pseudorandom, uniformly distributed value from this random number generator's sequence. Generates random bytes and places them into a user-supplied byte array. Returns the next pseudorandom, uniformly distributed value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributed value between and from this random number generator's sequence. Returns the next pseudorandom, Gaussian (\"normally\") distributed value with mean and standard deviation from this random number generator's sequence. Returns the next pseudorandom, uniformly distributed value from this random number generator's sequence. Returns a pseudorandom, uniformly distributed value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. Returns the next pseudorandom, uniformly distributed value from this random number generator's sequence. Wakes up a single thread that is waiting on this object's monitor. (Inherited from Object) Wakes up all threads that are waiting on this object's monitor. (Inherited from Object) Sets the seed of this random number generator using a single seed. Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>. (Inherited from Object) Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed. (Inherited from Object) Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed. (Inherited from Object)"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/working-with-java-collections-tips-and-techniques-e1ee28e179ab",
        "document": "Java Collections Framework (JCF) is a set of classes and interfaces that implement commonly reusable collection data structures. It is one of the fundamental aspects of Java programming, enabling developers to store, retrieve, manipulate, and communicate aggregate data. Effective use of collections can lead to more efficient, cleaner, and more intuitive coding practices. The goal of this article is to provide practical tips and techniques for working with Java Collections, focusing on simplicity and best practices.\n\nThe Java Collections Framework (JCF) is a critical part of Java programming, designed to manage groups of objects. Unlike traditional arrays, collections in Java are more flexible and offer powerful utilities to handle data dynamically. This comprehensive framework includes various interfaces, implementations, and algorithms that can drastically improve coding efficiency and program performance.\n\nThe foundation of the JCF is built on a set of core interfaces, each serving a distinct purpose in the organization, storage, and manipulation of data:\n• Collection: The root of the collection hierarchy, this interface represents a group of objects known as its elements. It provides basic operations such as adding and removing elements, checking the size, and checking if an element is included.\n• List: An ordered collection that can contain duplicate elements. Lists are ideal for scenarios where data ordering matters, such as maintaining an insertion order or accessing elements by their index positions. and are two widely used implementations, with the former being the preferred choice for random access operations and the latter for frequent insertions and deletions.\n• Set: A collection that cannot contain duplicate elements. It models the mathematical set abstraction and is primarily used when the uniqueness of the elements is a key requirement. , for example, stores its elements in a hash table, offering constant time performance for basic operations like add, remove, and contains.\n• Queue: Designed to hold elements prior to processing, queues typically order elements in a FIFO (first-in-first-out) manner. However, variations like priority queues order elements according to a specified comparator. and are common implementations, with each serving different use cases depending on the required ordering and concurrency characteristics.\n• Map: Unlike the other interfaces, does not extend but is still part of the framework. A map stores key-value pairs, with each key mapping to exactly one value. Keys are unique, and the map provides fast retrieval based on key. and are commonly used implementations, offering different sorting and performance characteristics.\n\nFor each core interface, the Java Collections Framework provides several implementation classes. These classes can be broadly categorized into two groups:\n• General-purpose Implementations: These are the most commonly used implementations, such as , , and . They offer good all-around performance for most use cases.\n• Special-purpose Implementations: These are designed for special cases and offer specific behaviors, such as , which is an efficient and compact implementation of a for enum types, or , which maintains insertion order of keys.\n\nUnderstanding the performance implications of different collections is crucial for efficient Java programming. For instance, provides constant-time positional access but has a linear time complexity for inserting and removing elements at the beginning or in the middle of the list. In contrast, offers better performance for such operations but does not support efficient random access.\n\nBest Practices for Using Java Collections\n• Prefer Interfaces to Implementations: When declaring collection variables, prefer using interface types over concrete implementation types. This promotes flexibility by decoupling the code from a specific implementation, making it easier to switch implementations if necessary.\n• Consider Initial Capacity: For classes like and , consider the initial capacity to avoid rehashing or resizing, which can be costly for performance.\n• Use Collections Utilities: Java provides utility classes like and , which offer various methods to manipulate collections, such as sorting, searching, and converting arrays to lists. These utilities can simplify common tasks and improve code readability.\n\nThe Java Collections Framework is a powerful toolset that, when used effectively, can solve a wide array of programming problems. By understanding the core interfaces, choosing the right implementations, and following best practices, developers can write more efficient, cleaner, and more maintainable Java code.\n\nWorking with Java Collections effectively means more than just knowing which collection to use. It involves understanding the nuances of each collection type, leveraging generics for type safety, iterating over collections efficiently, and avoiding common pitfalls that can lead to bugs or performance issues. This section goes into these aspects to help developers make the most out of the Java Collections Framework.\n\nGenerics were introduced in Java 5 to provide compile-time type checking and eliminate the need for casting, which can lead to at runtime. When using collections, always specify the type of elements they will hold using generics. This not only makes your code safer and cleaner but also easier to read and maintain.\n\nFor instance, instead of using a raw type like , specify the type of elements the list will contain, like or . This way, the compiler will ensure that only elements of the specified type are added to the collection, preventing runtime errors.\n\nJava provides several ways to iterate over collections, each with its advantages and use cases. Choosing the right iteration strategy can improve code clarity and performance.\n• Using Iterators: The interface provides methods to iterate over collections. It is particularly useful when you need to remove elements during iteration, as it supports a method that safely deletes elements without causing .\n• Enhanced for-loop: Also known as the “for-each” loop, this is a simpler syntax introduced in Java 5. It’s best used when you don’t need to remove elements during iteration.\n• Java 8 forEach method: With the introduction of Lambda expressions in Java 8, the method provides a more concise and expressive way to iterate over collections.\n\nWhile collections are powerful, there are common pitfalls that can lead to bugs or inefficient code:\n• Modifying a collection while iterating: This can lead to . Use an 's method or iterate over a copy of the collection if you need to modify it during iteration.\n• Using mutable objects as keys in Maps or elements in Sets: If a mutable object’s state changes in a way that affects its or method, it can \"get lost\" in the collection, leading to unpredictable behavior. Prefer immutable objects for map keys and set elements.\n• Neglecting collection capacities: For collections like , which dynamically resize, initializing them with a capacity estimate can improve performance by reducing the number of resizes.\n• Ignoring thread-safety: Collections from the standard package are not thread-safe. For concurrent access, consider using collections from the package or wrapping your collection using methods like .\n\nBy understanding and applying these practices, developers can use Java Collections more effectively, leading to cleaner, safer, and more efficient code.\n\nMastering Java Collections involves more than understanding the basic collections and their uses. Advanced techniques and tips can help you optimize performance, write cleaner code, and solve complex problems more efficiently. Here we explore custom collection implementations, concurrent collections for safe multi-threaded access, and utility methods that enhance collection manipulation.\n\nWhile the Java Collections Framework provides a wide range of collection types, sometimes specific scenarios require custom implementations. For example, you might need a collection with a unique sorting order, or one that automatically evicts the least recently used items. Implementing a new collection involves extending an existing abstract implementation or implementing a collection interface directly.\n• Ensure consistency with and methods to prevent unexpected behavior, especially if your collection is used in or as a key in .\n• Implement the interface to enable the use of enhanced for-loops and other iteration mechanisms.\n• Consider thread safety. If your collection is accessed by multiple threads, ensure it is properly synchronized or use utilities.\n\nConcurrency is a critical aspect of modern software development. The package provides thread-safe versions of collections that support concurrent access and modifications without the need for external synchronization.\n• : A thread-safe variant of where all mutative operations ( , , etc.) are implemented by making a fresh copy of the underlying array.\n• implementations like or are designed for concurrent producer-consumer scenarios.\n\nUsing concurrent collections can significantly improve performance in multi-threaded environments by reducing the need for locking and by providing non-blocking algorithms.\n\nJava provides utility classes such as and that offer a range of static methods to manipulate collections. These utilities can perform operations such as sorting, searching, reversing, and creating thread-safe wrappers around collections.\n• Sorting and Searching: sorts any based on the natural ordering of its elements or a provided . allows for fast searching in sorted lists.\n• Reversing, Shuffling, and Swapping: Methods like , , and offer convenient ways to manipulate list elements.\n• Creating Unmodifiable Collections: To make a collection read-only, use , , , , etc. This is particularly useful for returning collections from methods without exposing them to modification.\n\nBy integrating these more advanced techniques and tips into your Java development practices, you can enhance the efficiency, safety, and strength of your applications. Custom collections can provide tailored solutions, concurrent collections enable safe multi-threaded operations, and collection utilities simplify common tasks, elevating your use of the Java Collections Framework.\n\nThe Java Collections Framework is a fundamental toolset for Java developers, facilitating efficient data management and manipulation. Through this article, we’ve covered essential aspects from selecting the right collections, employing generics for type safety, to advanced techniques and common pitfalls. Understanding these concepts enables developers to write more effective, maintainable Java code. Embracing these practices and continuously exploring the depth of Java Collections will significantly enhance your coding proficiency and application performance."
    },
    {
        "link": "https://dev.to/be11amer/understanding-arrays-and-collections-in-java-managing-groups-of-data-2hf1",
        "document": "Let’s learn how to work with arrays and collections in Java, essential tools for managing groups of data effectively. This guide covers array basics, ArrayList, HashMap, and more.\n\nIn Java, managing groups of data efficiently is crucial for building robust applications. Arrays and collections are two fundamental concepts that help you store, access, and manipulate multiple elements in your programs. This post will guide you through the basics of arrays and collections, including how to use them effectively in your Java projects.\n\nAn array is a data structure that holds a fixed number of elements of the same type. It’s like a container that can store multiple values, allowing you to access each value using an index.\n\nYou can declare an array in Java by specifying the data type of its elements and using square brackets .\n\nTo initialize an array, you must specify its size or provide values directly.\n\nAlternatively, you can declare and initialize an array in a single line:\n\nYou can access and modify array elements using their index. In Java, array indices start from .\n\nCreate an array of 7 days of the week and print each day using a loop.\n\nWhile arrays are powerful, they have limitations, such as a fixed size. Java's collections framework offers more flexible ways to manage groups of objects. Collections can grow or shrink in size and provide various utilities for working with data.\n\nis one of the most commonly used collections in Java. It’s like an array, but it can dynamically resize itself.\n\nHere are some common operations you can perform with an :\n\nCreate an of your favorite books. Add at least 5 books to the list, then print each book using a loop.\n\nis another powerful collection that stores key-value pairs. It’s ideal for scenarios where you want to associate unique keys with specific values.\n\nCreate a to store the names and ages of your friends. Add at least 3 friends to the map, then print each name and age.\n\n3. Arrays vs. Collections: When to Use What\n• \n• You know the exact number of elements.\n• You need fast access to elements by index.\n• \n• The number of elements can change dynamically.\n• You require data structures like lists, sets, or maps.\n\nArrays and collections are fundamental tools in Java for managing groups of data. Arrays offer simplicity and efficiency when working with fixed-size data, while collections provide flexibility and powerful utilities for more complex scenarios.\n\nBy mastering these concepts, you can handle data in your Java programs more effectively. Practice with the challenges provided to reinforce your understanding!"
    },
    {
        "link": "https://geeksforgeeks.org/collections-in-java-2",
        "document": "Any group of individual objects that are represented as a single unit is known as a Java Collection of Objects. In Java, a separate framework named the “Collection Framework” has been defined in JDK 1.2 which holds all the Java Collection Classes and Interface in it.\n\nIn Java, the Collection interface (java.util.Collection) and Map interface (java.util.Map) are the two main “root” interfaces of Java collection classes.\n\nWhat You Should Learn in Java Collections?\n\nWhat is a Framework in Java?\n\nA framework is a set of classes and interfaces which provide a ready-made architecture. In order to implement a new feature or a class, there is no need to define a framework. However, an optimal object-oriented design always includes a framework with a collection of classes such that all the classes perform the same kind of task.\n\nNeed for a Separate Collection Framework in Java\n\nBefore the Collection Framework(or before JDK 1.2) was introduced, the standard methods for grouping Java objects (or collections) were Arrays or Vectors, or Hashtables. All of these collections had no common interface. Therefore, though the main aim of all the collections is the same, the implementation of all these collections was defined independently and had no correlation among them. And also, it is very difficult for the users to remember all the different methods, syntax, and constructors present in every collection class. \n\nLet’s understand this with an example of adding an element in a hashtable and a vector.\n\nAs we can observe, none of these collections(Array, Vector, or Hashtable) implements a standard member access interface, it was very difficult for programmers to write algorithms that can work for all kinds of Collections. Another drawback is that most of the ‘Vector’ methods are final, meaning we cannot extend the ’Vector’ class to implement a similar kind of Collection. Therefore, Java developers decided to come up with a common interface to deal with the above-mentioned problems and introduced the Collection Framework in JDK 1.2 post which both, legacy Vectors and Hashtables were modified to conform to the Collection Framework.\n\nSince the lack of a collection framework gave rise to the above set of disadvantages, the following are the advantages of the collection framework.\n• Consistent API: The API has a basic set of interfaces like Collection Set List Map , all the classes (ArrayList, LinkedList, Vector, etc) that implement these interfaces have some\n• Reduces programming effort: A programmer doesn’t have to worry about the design of the Collection but rather he can focus on its best use in his program. Therefore, the basic concept of Object-oriented programming (i.e.) abstraction has been successfully implemented.\n• Increases program speed and quality: Increases performance by providing high-performance implementations of useful data structures and algorithms because in this case, the programmer need not think of the best implementation of a specific data structure. He can simply use the best implementation to drastically boost the performance of his algorithm/program.\n\nHierarchy of the Collection Framework in Java\n\nThe utility package, (java.util) contains all the classes and interfaces that are required by the collection framework. The collection framework contains an interface named an iterable interface which provides the iterator to iterate through all the collections. This interface is extended by the main collection interface which acts as a root for the collection framework. All the collections extend this collection interface thereby extending the properties of the iterator and the methods of this interface. The following figure illustrates the hierarchy of the collection framework.\n\nBefore understanding the different components in the above framework, let’s first understand a class and an interface.\n• Class: A class is a user-defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type.\n• Interface: Like a class, an interface can have methods and variables, but the methods declared in an interface are by default abstract (only method signature, nobody). Interfaces specify what a class must do and not how. It is the blueprint of the class.\n\nThis interface contains various methods which can be directly used by all the collections which implement this interface. They are:\n\nThis method is used to add an object to the collection. This method adds all the elements in the given collection to this collection. This method removes all of the elements from this collection. This method returns true if the collection contains the specified element. This method returns true if the collection contains all of the elements in the given collection. This method compares the specified object with this collection for equality. This method is used to return the hash code value for this collection. This method returns true if this collection contains no elements. This method returns an iterator over the elements in this collection. This method is used to return the maximum value present in the collection. This method returns a parallel Stream with this collection as its source. This method is used to remove the given object from the collection. If there are duplicate values, then this method removes the first occurrence of the object. This method is used to remove all the objects mentioned in the given collection from the collection. This method is used to remove all the elements of this collection that satisfy the given This method is used to retain only the elements in this collection that are contained in the specified collection. This method is used to return the number of elements in the collection. This method is used to create a over the elements in this collection. This method is used to return a sequential Stream with this collection as its source. This method is used to return an array containing all of the elements in this collection.\n\nThe collection framework contains multiple interfaces where every interface is used to store a specific type of data. The following are the interfaces present in the framework.\n\nThis is the root interface for the entire collection framework. The collection interface extends the iterable interface. Therefore, inherently, all the interfaces and classes implement this interface. The main functionality of this interface is to provide an iterator for the collections. Therefore, this interface contains only one abstract method which is the iterator. It returns the\n\nThis interface extends the iterable interface and is implemented by all the classes in the collection framework. This interface contains all the basic methods which every collection has like adding the data into the collection, removing the data, clearing the data, etc. All these methods are implemented in this interface because these methods are implemented by all the classes irrespective of their style of implementation. And also, having these methods in this interface ensures that the names of the methods are universal for all the collections. Therefore, in short, we can say that this interface builds a foundation on which the collection classes are implemented.\n\nThis is a child interface of the collection interface. This interface is dedicated to the data of the list type in which we can store all the ordered collections of the objects. This also allows duplicate data to be present in it. This list interface is implemented by various classes like ArrayList, Vector, Stack, etc. Since all the subclasses implement the list, we can instantiate a list object with any of these classes.\n\nThe classes which implement the List interface are as follows:\n\nArrayList provides us with dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed. The size of an ArrayList is increased automatically if the collection grows or shrinks if the objects are removed from the collection. Java ArrayList allows us to randomly access the list. ArrayList can not be used for primitive types, like int, char, etc. We will need a wrapper class for such cases.\n\nLet’s understand the ArrayList with the following example:\n\nThe LinkedList class is an implementation of the LinkedList data structure which is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses. Each element is known as a node.\n\nLet’s understand the LinkedList with the following example:\n\nA vector provides us with dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed. This is identical to ArrayList in terms of implementation. However, the primary difference between a vector and an ArrayList is that a Vector is synchronized and an ArrayList is non-synchronized.\n\nLet’s understand the Vector with an example:\n\nStack class models and implements the Stack data structure. The class is based on the basic principle of last-in-first-out. In addition to the basic push and pop operations, the class provides three more functions empty, search, and peek. The class can also be referred to as the subclass of Vector.\n\nLet’s understand the stack with an example:\n\nAs the name suggests, a queue interface maintains the FIFO(First In First Out) order similar to a real-world queue line. This interface is dedicated to storing all the elements where the order of the elements matter. For example, whenever we try to book a ticket, the tickets are sold on a first come first serve basis. Therefore, the person whose request arrives first into the queue gets the ticket. There are various classes like PriorityQueue, ArrayDeque, etc. Since all these subclasses implement the queue, we can instantiate a queue object with any of these classes.\n\nThe most frequently used implementation of the queue interface is the PriorityQueue.\n\nA PriorityQueue is used when the objects are supposed to be processed based on priority. It is known that a queue follows the First-In-First-Out algorithm, but sometimes the elements of the queue are needed to be processed according to the priority and this class is used in these cases. The PriorityQueue is based on the priority heap. The elements of the priority queue are ordered according to the natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.\n\nLet’s understand the priority queue with an example:\n\nThis is a very slight variation of the queue data structure. Deque, also known as a double-ended queue, is a data structure where we can add and remove elements from both ends of the queue. This interface extends the queue interface. The class which implements this interface is ArrayDeque. Since ArrayDeque class implements the Deque interface, we can instantiate a deque object with this class.\n\nThe class which implements the deque interface is ArrayDeque.\n\nArrayDeque class which is implemented in the collection framework provides us with a way to apply resizable array. This is a special kind of array that grows and allows users to add or remove an element from both sides of the queue. Array deques have no capacity restrictions and they grow as necessary to support usage.\n\nA set is an unordered collection of objects in which duplicate values cannot be stored. This collection is used when we wish to avoid the duplication of the objects and wish to store only the unique objects. This set interface is implemented by various classes like HashSet, TreeSet, LinkedHashSet, etc. Since all the subclasses implement the set, we can instantiate a set object with any of these classes.\n\nThe following are the classes that implement the Set interface:\n\nThe HashSet class is an inherent implementation of the hash table data structure. The objects that we insert into the HashSet do not guarantee to be inserted in the same order. The objects are inserted based on their hashcode. This class also allows the insertion of NULL elements. Let’s understand HashSet with an example:\n\nA LinkedHashSet is very similar to a HashSet. The difference is that this uses a doubly linked list to store the data and retains the ordering of the elements.\n\nLet’s understand the LinkedHashSet with an example:\n\nThis interface is very similar to the set interface. The only difference is that this interface has extra methods that maintain the ordering of the elements. The sorted set interface extends the set interface and is used to handle the data which needs to be sorted. The class which implements this interface is TreeSet. Since this class implements the SortedSet, we can instantiate a SortedSet object with this class.\n\nThe class which implements the sorted set interface is TreeSet. \n\n \n\nTreeSet\n\nThe TreeSet class uses a Tree for storage. The ordering of the elements is maintained by a set using their natural ordering whether or not an explicit comparator is provided. This must be consistent with equals if it is to correctly implement the Set interface. It can also be ordered by a Comparator provided at a set creation time, depending on which constructor is used.\n\nLet’s understand TreeSet with an example:\n\nA map is a data structure that supports the key-value pair for mapping the data. This interface doesn’t support duplicate keys because the same key cannot have multiple mappings, however, it allows duplicate values in different keys. A map is useful if there is data and we wish to perform operations on the basis of the key. This map interface is implemented by various classes like HashMap, TreeMap, etc. Since all the subclasses implement the map, we can instantiate a map object with any of these classes.\n\nThe frequently used implementation of a Map interface is a HashMap.\n\nHashMap provides the basic implementation of the Map interface of Java. It stores the data in (Key, Value) pairs. To access a value in a HashMap, we must know its key. HashMap uses a technique called Hashing. Hashing is a technique of converting a large String to a small String that represents the same String so that the indexing and search operations are faster. HashSet also uses HashMap internally.\n\nLet’s understand the HashMap with an example:"
    },
    {
        "link": "https://stackoverflow.com/questions/27458331/can-array-of-objects-be-considered-as-a-collection-of-objects-in-java",
        "document": "I don't see why this is a problem. In the literal sense an array is a 'collection' (Read).\n\nBut when you dive into Java the meaning of a collection changes from a mere group of objects to a set of mechanisms to manage(store,retrieve,operate etc) the objects and is specified by the prototype interface.\n\nSo unless you are overriding the interface in Java your array isn't exactly a collection."
    },
    {
        "link": "https://stackoverflow.com/questions/6100148/collection-interface-vs-arrays",
        "document": "The easy way to think of it is: Collections beat object arrays in basically every single way. Consider:\n• A collection can be mutable or immutable. A nonempty array must always be mutable.\n• A collection can allow or disallow null elements. An array must always permit null elements.\n• A collection can be thread-safe; even concurrent. An array is never safe to publish to multiple threads.\n• A list or set's , and methods do what users expect; on an array they are a common source of bugs.\n• A collection is type-safe; an array is not. Because arrays \"fake\" covariance, can result at runtime.\n• A collection can hold a non-reifiable type (e.g. or ). An array will generate a warning for this.\n• A collection can have views (unmodifiable, subList...). No such luck for an array.\n• A collection has a full-fledged API; an array has only set-at-index, get-at-index, length and clone.\n• Type-use annotations like are very confusing with arrays. I promise you can't guess what means.\n• Because of all the reasons above, third-party utility libraries should not bother adding much additional support for arrays, focusing only on collections, so you also have a network effect.\n\nObject arrays will never be first-class citizens in Java APIs.\n\nA couple of the reasons above are covered -- but in much greater detail -- in Effective Java, Third Edition, Item 28, from page 126.\n\nSo, why would you ever use object arrays?\n• You have to interact with an API that uses them and you can't fix it\n• so convert to/from a as close to that API as you can\n• Because varargs (but varargs is overused)\n• so ... same as previous\n• Obviously some collection implementations must be using them\n• I can't think of any other reasons, they suck bad"
    },
    {
        "link": "https://geeksforgeeks.org/access-modifiers-java",
        "document": "Access Modifiers in Java control the visibility and accessibility of classes, methods, and variables, ensuring better security and encapsulation. Understanding default, private, protected, and public access modifiers is essential for writing efficient and structured Java programs. In this article, we will explore each modifier with examples to demonstrate their impact on Java development.\n\nThere are 4 types of access modifiers available in Java:\n\nWhen no access modifier is specified for a class, method, or data member, it is said to be having the default access modifier by default. The default access modifiers are accessible only within the same package.\n\nExample 1: Demonstrating Default Access Modifier Within the Same Package. In this example, we will create two packages and the classes in the packages will be having the default access modifiers and we will try to access a class from one package from a class of the second package.\n\nExample 2: Error when Accessing Default Modifier Class across Packages. In this example, the program will show the compile-time error when we try to access a default modifier class from a different package.\n\nThe private access modifier is specified using the keyword private. The methods or data members declared as private are accessible only within the class in which they are declared.\n• None Any other class of the same package will not be able to access these members.\n• None Top-level classes or interfaces can not be declared as private because,\n• None protected means “only visible within the enclosing class and any subclasses”.\n\nHence these modifiers in terms of application to classes, apply only to nested classes and not on top-level classes.\n\nExample: In this example, we will create two classes A and B within the same package p1. We will declare a method in class A as private and try to access this method from class B and see the result.\n\nExplanation: The above code will show a compile-time error when trying to access a private method from class B, even within the same package.\n\nThe protected access modifier is specified using the keyword protected. The methods or data members declared as protected are accessible within the same package or subclasses in different packages.\n\nExample 1: In this example, we will create two packages p1 and p2. Class A in p1 is made public, to access it in p2. The method display in class A is protected and class B is inherited from class A and this protected method is then accessed by creating an object of class B.\n\nSo, it demonstrates that a protected method is accessible within the same package.\n\n\n\nExample 2: In this example, we will create two packages, p1 and p2. Class A in p1 has a protected method display. Class B in p2 extends A and accesses the protected method through inheritance by creating an object of class B.\n\nExplanation: The above example demonstrates that a protected method is accessible in a subclass from a different package using inheritance.\n\nThe public access modifier is specified using the keyword public.\n• None The public access modifier has the widest scope among all other access modifiers.\n• None Classes, methods, or data members that are declared as public are accessible from everywhere in the program. There is no restriction on the scope of public data members.\n\nExample 1: Here, the code shows that a public method is accessible within the same package.\n\nExample 2: Here, the example shows that a public method is accessible across packages.\n• None If other programmers use your class, try to use the most restrictive access level that makes sense for a particular member. Use private unless you have a good reason not to.\n\nWhen to Use Each Access Modifier in Real-World Projects\n• Private : This is used for encapsulating sensitive data and internal helper methods that should not be accessed outside the class.\n• Example : Private fields in a model class with getter and setter methods.\n• Default (Package-Private) : This is suitable for classes and methods that should only be accessible within the same package, often used in package-scoped utilities or helper classes.\n• Protected: This is ideal for methods and fields that should be accessible within the same package and subclasses, commonly used in inheritance-based designs like framework extensions.\n• Public : This is used for classes, methods, or fields meant to be accessible from anywhere, such as API endpoints, service classes, or utility methods shared across different parts of an application.\n\nAlgorithm to Use Access Modifier in Java\n\nHere’s a basic algorithm for using access modifiers in Java:\n• Define a class : Create a class to represent the object you want to manage.\n• Define instance variables : Inside the class, define variables for the data you want to manage.\n• Set an access modifier\n• None Use private for variables only accessible within the class.\n• None Use protected for variables accessible within the class and its subclasses.\n• None Use public for variables accessible from anywhere.\n• Use getter and setter methods: To access or modify variables, use getter (accessor) and setter (mutator) methods, even for public variables, to maintain encapsulation.\n\nWhat are access modifiers in Java?\n\nWhat is the default access modifier in Java?\n\nWhat are the 12 modifiers in Java?\n\nCan a private method be accessed outside its class?\n\nWhat does the protected access modifier do?\n\nCan public variables be accessed from any class?"
    },
    {
        "link": "https://simplilearn.com/tutorials/java-tutorial/access-modifiers",
        "document": ""
    },
    {
        "link": "https://piyu108.medium.com/mastering-access-modifiers-best-practices-for-java-programming-e27eaa615aa3",
        "document": "Access modifiers in Java are keywords that define the accessibility of classes, methods, and variables in a Java program. Access modifiers are used to control the visibility of classes, methods, and variables, which means they control which parts of the program can access these elements. There are four access modifiers in Java:\n\nEach access modifier has its own set of rules for determining which parts of the program can access the elements they modify.\n\nPublic Access Modifier The public access modifier is the most permissive access modifier in Java. When a class, method, or variable is declared public, it can be accessed from any part of the program. This means that a public class can be accessed from any other class, a public method can be called from any other method, and a public variable can be read or modified from any part of the program.\n\nPrivate Access Modifier The private access modifier is the most restrictive access modifier in Java. When a class, method, or variable is declared as private, it can only be accessed from within the same class. This means that a private class cannot be accessed from any other class, a private method cannot be called from any other method, and a private variable cannot be read or modified from any other part of the program.\n\nProtected Access Modifier The protected access modifier is similar to the private access modifier, but it provides a limited amount of access to other classes. When a class, method, or variable is declared as protected, it can be accessed from within the same package or by a subclass of the class in a different package. This means that a protected class can only be accessed from other classes within the same package, a protected method can be called from other methods within the same package or from a subclass of the class in a different package, and a protected variable can be read or modified from other classes within the same package or from a subclass of the class in a different package.\n\nDefault Access Modifier The default access modifier is also known as the package-private access modifier. When a class, method, or variable is declared with no access modifier, it is considered to have a default access. This means that the element can only be accessed from within the same package. This is a more permissive access modifier than private but more restrictive than protected or public.\n\nImportance of Access Modifiers in Java Access modifiers are an important part of object-oriented programming because they help maintain the integrity and security of a program. By restricting access to certain elements of a program, access modifiers prevent unauthorized modification or access to sensitive data. For example, if a variable contains sensitive information, such as a user’s password, it should be declared as private so that it can only be accessed from within the class that owns it. Similarly, if a method is intended to be used only within the same package, it should be declared as package-private to prevent other classes from accessing it.\n\nIn addition to security, access modifiers also help maintain code quality by encapsulating data and functionality. Encapsulation is the practice of hiding the implementation details of an object and only exposing a public interface. Access modifiers allow developers to control which parts of the program can access the internal details of an object, promoting encapsulation and reducing the likelihood of bugs and errors.\n\nAccess modifiers are an important aspect of Java programming as they control the visibility of classes, methods, and variables.\n• Keep variables private: It is considered best practice to keep variables private to prevent direct access to them from outside the class. Instead, public methods should be created to provide controlled access to these variables.\n• Use the least restrictive access modifier possible: Access modifiers should be chosen based on the access needed for a particular class, method, or variable. Always use the least restrictive access modifier possible that still provides the required functionality.\n• Don’t expose implementation details: It is important to keep the implementation details of a class hidden and only expose the public interface. This allows for easier maintenance and upgrades in the future.\n• Limit the use of protected access: Protected access should be used sparingly as it allows access to a class or variable from subclasses or classes in the same package. This can lead to tight coupling between classes and make it harder to modify or maintain them in the future.\n• Use interfaces to expose functionality: Interfaces can be used to expose functionality to other classes without exposing the implementation details. This allows for greater flexibility in the future and promotes better code reusability.\n• Use package-private access for closely related classes: Package-private access allows classes in the same package to access each other’s members. This can be useful for closely related classes that need to collaborate with each other.\n• Avoid using public fields: Public fields should be avoided as they can be accessed directly from outside the class, leading to a lack of encapsulation. Instead, use private fields with public getter and setter methods to provide controlled access.\n• Document access modifiers: Access modifiers should be documented in the code to provide clarity on why a particular modifier was chosen and what access it provides.\n\nBy following these best practices, Java programmers can create well-structured and maintainable code that is easier to modify and upgrade in the future.\n\nIt’s important to note that access modifiers are not only limited to classes, methods, and fields, but also to constructors, inner classes, and interfaces.\n\nConstructors: Access modifiers can be applied to constructors, and their purpose is to control the visibility of a constructor. A constructor with public access modifier can be accessed from any class, while a constructor with private access modifier can only be accessed within the same class. Protected constructors are accessible only within the same package or within a subclass of the class that contains the protected constructor. Finally, a constructor with a default access modifier is accessible within the same package.\n\nInner classes: Access modifiers can also be applied to inner classes. An inner class is a class that is declared inside another class. An inner class can be declared as public, private, protected, or with a default access modifier. A public inner class can be accessed from any class, while a private inner class can only be accessed within the same outer class. Protected inner classes are accessible within the same package or within a subclass of the outer class, and inner classes with a default access modifier are accessible within the same package.\n\nInterfaces: Access modifiers can also be used to control the visibility of an interface. An interface with a public access modifier can be accessed from any class, while an interface with a default access modifier is only accessible within the same package. There are no private or protected access modifiers for interfaces.\n\nIn conclusion, access modifiers are important in Java as they allow developers to control the visibility of their classes, methods, fields, constructors, inner classes, and interfaces. This helps in maintaining the security, encapsulation, and abstraction of code, and also aids in creating reusable code that can be used in different parts of an application."
    },
    {
        "link": "https://geeksforgeeks.org/encapsulation-in-java",
        "document": "Encapsulation in Java is a fundamental OOP (object-oriented programming) principle that combines data and methods in a class. It allows implementation details to be hidden while exposing a public interface for interaction.\n\nExample: Below is a simple example of Encapsulation in Java.\n\nExplanation: In this example, the class restricts direct access to it from outside. The and methods, known as getters and setters, provide controlled access to the attribute. This encapsulation mechanism protects the internal state of the object and allows for better control and flexibility in how the attribute is accessed and modified.\n\nIn Java, encapsulation is implemented by declaring instance variables as private, restricting direct access. Public getter methods retrieve variable values, while setter methods modify them, enabling controlled access. This approach allows the class to enforce data validation and maintain a consistent internal state, enhancing security and flexibility.\n\nEncapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. Another way to think about encapsulation is, that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n• None In encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of its own class.\n• None A private class can hide its members or methods from the end user, using abstraction to hide implementation details, by combining data hiding abstraction.\n• None Encapsulation can be achieved by Declaring all the variables in the class as private and writing public methods in the class to set and get the values of variables.\n• None It is more defined with the setter and getter method.\n\nExample 1: Here is another example of encapsulation in Java\n\nExplanation: Here the encapsulation is achieved by restricting direct access to the name and age fields of the Person class. These fields are marked as private and can only be accessed or modified through public getter and setter methods (getName(), setName(), getAge(), setAge()). This approach ensures data hiding and maintains control over the values of these fields.\n\nExample 2: In this example, we use abstraction to hide the implementation and show the functionality.\n\nExample 2: The program to access variables of the class EncapsulateDemo is shown below:\n\nExplanation: In the above program, the class Encapsulate is encapsulated as the variables are declared private. The get methods like getAge(), getName(), and getRoll() are set as public, these methods are used to access these variables. The setter methods like setName(), setAge(), and setRoll() are also declared as public and are used to set the values of the variables.\n\nExample 4: Below is the implementation of the Java Encapsulation:\n\nExplanation: in the above code we can easily get the values and set the values easily by using the methods. Here the implementation is hidden and we can perform the tasks which makes it easy to use for end users.\n• Data Hiding: Encapsulation provides data hiding. Users don’t see the implementation of the class. The user only knows that we are passing the values to a setter method and variables are getting initialized with that value.\n• Data Integrity : By using getter and setter methods, we can ensure that only valid data is assigned to variables. If we omit the setter methods, we make the variables read-only, and if we omit the getter methods, we make them write-only. This ensures the internal state of the object is protected and maintains data integrity.\n• Reusability: Encapsulation also improves the re-usability and is easy to change with new requirements.\n• Testing code is easy: Encapsulated code is easy to test for unit testing.\n• Freedom of the details: one of the major advantages of encapsulation is that it gives the programmer freedom to implement the details of a system. The only constraint on the programmer is to maintain the abstract interface that outsiders see.\n• None It can lead to increased complexity, especially if not used properly.\n• None It can make it more difficult to understand how the system works.\n• None This may limit the flexibility of the implementation."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html",
        "document": "Trail: Learning the Java Language \n\nLesson: Classes and Objects \n\nSection: More on Classes\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAccess level modifiers determine whether other classes can use a particular field or invoke a particular method. There are two levels of access control:\n• At the top level , or package-private (no explicit modifier).\n• At the member level , , , or package-private (no explicit modifier).\n\nA class may be declared with the modifier , in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes  you will learn about them in a later lesson.)\n\nAt the member level, you can also use the modifier or no modifier (package-private) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: and . The modifier specifies that the member can only be accessed in its own class. The modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.\n\nThe following table shows the access to members permitted by each modifier.\n\nThe first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members. The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member. The third column indicates whether subclasses of the class declared outside this package have access to the member. The fourth column indicates whether all classes have access to the member.\n\nAccess levels affect you in two ways. First, when you use classes that come from another source, such as the classes in the Java platform, access levels determine which members of those classes your own classes can use. Second, when you write a class, you need to decide what access level every member variable and every method in your class should have.\n\nLet's look at a collection of classes and see how access levels affect visibility. The following figure shows the four classes in this example and how they are related.\n\nThe following table shows where the members of the Alpha class are visible for each of the access modifiers that can be applied to them."
    }
]