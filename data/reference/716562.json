[
    {
        "link": "https://api.flutter.dev/flutter/widgets/ListView-class.html",
        "document": "ListView is the most commonly used scrolling widget. It displays its children one after another in the scroll direction. In the cross axis, the children are required to fill the ListView.\n\nIf non-null, the itemExtent forces the children to have the given extent in the scroll direction.\n\nIf non-null, the prototypeItem forces the children to have the same extent as the given widget in the scroll direction.\n\nSpecifying an itemExtent or an prototypeItem is more efficient than letting the children determine their own extent because the scrolling machinery can make use of the foreknowledge of the children's extent to save work, for example when the scroll position changes drastically.\n\nYou can't specify both itemExtent and prototypeItem, only one or none of them.\n\nThere are four options for constructing a ListView:\n• The default constructor takes an explicit List<Widget> of children. This constructor is appropriate for list views with a small number of children because constructing the List requires doing work for every child that could possibly be displayed in the list view instead of just those children that are actually visible.\n• The ListView.builder constructor takes an IndexedWidgetBuilder, which builds the children on demand. This constructor is appropriate for list views with a large (or infinite) number of children because the builder is called only for those children that are actually visible.\n• The ListView.separated constructor takes two IndexedWidgetBuilders: builds child items on demand, and similarly builds separator children which appear in between the child items. This constructor is appropriate for list views with a fixed number of children.\n• The ListView.custom constructor takes a SliverChildDelegate, which provides the ability to customize additional aspects of the child model. For example, a SliverChildDelegate can control the algorithm used to estimate the size of children that are not actually visible.\n\nTo control the initial scroll offset of the scroll view, provide a controller with its ScrollController.initialScrollOffset property set.\n\nBy default, ListView will automatically pad the list's scrollable extremities to avoid partial obstructions indicated by MediaQuery's padding. To avoid this behavior, override with a zero padding property.\n\nWhile laying out the list, visible children's elements, states and render objects will be created lazily based on existing widgets (such as when using the default constructor) or lazily provided ones (such as when using the ListView.builder constructor).\n\nWhen a child is scrolled out of view, the associated element subtree, states and render objects are destroyed. A new child at the same position in the list will be lazily recreated along with new elements, states and render objects when it is scrolled back.\n\nIn order to preserve state as child elements are scrolled in and out of view, the following options are possible:\n• Moving the ownership of non-trivial UI-state-driving business logic out of the list child subtree. For instance, if a list contains posts with their number of upvotes coming from a cached network response, store the list of posts and upvote number in a data model outside the list. Let the list child UI subtree be easily recreate-able from the source-of-truth model object. Use StatefulWidgets in the child widget subtree to store instantaneous UI state only.\n• Letting KeepAlive be the root widget of the list child widget subtree that needs to be preserved. The KeepAlive widget marks the child subtree's top render object child for keepalive. When the associated top render object is scrolled out of view, the list keeps the child's render object (and by extension, its associated elements and states) in a cache list instead of destroying them. When scrolled back into view, the render object is repainted as-is (if it wasn't marked dirty in the interim). This only works if and are false since those parameters cause the ListView to wrap each child widget subtree with other widgets.\n• Using AutomaticKeepAlive widgets (inserted by default when is true). AutomaticKeepAlive allows descendant widgets to control whether the subtree is actually kept alive or not. This behavior is in contrast with KeepAlive, which will unconditionally keep the subtree alive. As an example, the EditableText widget signals its list child element subtree to stay alive while its text field has input focus. If it doesn't have focus and no other descendants signaled for keepalive via a KeepAliveNotification, the list child element subtree will be destroyed when scrolled away. AutomaticKeepAlive descendants typically signal it to be kept alive by using the AutomaticKeepAliveClientMixin, then implementing the AutomaticKeepAliveClientMixin.wantKeepAlive getter and calling AutomaticKeepAliveClientMixin.updateKeepAlive.\n\nA ListView is basically a CustomScrollView with a single SliverList in its CustomScrollView.slivers property.\n\nIf ListView is no longer sufficient, for example because the scroll view is to have both a list and a grid, or because the list is to be combined with a SliverAppBar, etc, it is straight-forward to port code from using ListView to using CustomScrollView directly.\n\nThe key, scrollDirection, reverse, controller, primary, physics, and shrinkWrap properties on ListView map directly to the identically named properties on CustomScrollView.\n\nThe CustomScrollView.slivers property should be a list containing either:\n• a SliverList if both itemExtent and prototypeItem were null;\n• a SliverFixedExtentList if itemExtent was not null; or\n• a SliverPrototypeExtentList if prototypeItem was not null.\n\nThe childrenDelegate property on ListView corresponds to the SliverList.delegate (or SliverFixedExtentList.delegate) property. The ListView constructor's argument corresponds to the childrenDelegate being a SliverChildListDelegate with that same argument. The ListView.builder constructor's and arguments correspond to the childrenDelegate being a SliverChildBuilderDelegate with the equivalent arguments.\n\nThe padding property corresponds to having a SliverPadding in the CustomScrollView.slivers property instead of the list itself, and having the SliverList instead be a child of the SliverPadding.\n\nCustomScrollViews don't automatically avoid obstructions from MediaQuery like ListViews do. To reproduce the behavior, wrap the slivers in SliverSafeAreas.\n\nOnce code has been ported to use CustomScrollView, other slivers, such as SliverGrid or SliverAppBar, can be put in the CustomScrollView.slivers list.\n\nA common design pattern is to have a custom UI for an empty list. The best way to achieve this in Flutter is just conditionally replacing the ListView at build time with whatever widgets you need to show for the empty list state:\n\nListView has no built-in notion of a selected item or items. For a small example of how a caller might wire up basic item selection, see ListTile.selected.\n\nScrollViews are often decorated with Scrollbars and overscroll indicators, which are managed by the inherited ScrollBehavior. Placing a ScrollConfiguration above a ScrollView can modify these behaviors for that ScrollView, or can be managed app-wide by providing a ScrollBehavior to MaterialApp.scrollBehavior or CupertinoApp.scrollBehavior.\n\nScroll views attempt to persist their scroll position using PageStorage. This can be disabled by setting ScrollController.keepScrollOffset to false on the controller. If it is enabled, using a PageStorageKey for the key of this widget is recommended to help disambiguate different scroll views from each other.\n• SingleChildScrollView, which is a scrollable widget that has a single child.\n• PageView, which is a scrolling list of child widgets that are each the size of the viewport.\n• GridView, which is a scrollable, 2D array of widgets.\n• CustomScrollView, which is a scrollable widget that creates custom scroll effects using slivers.\n• ListBody, which arranges its children in a similar manner, but without scrolling.\n• ScrollNotification and NotificationListener, which can be used to watch the scroll position without using a ScrollController.\n• Cookbook: Create lists with different types of items"
    },
    {
        "link": "https://docs.flutter.dev/cookbook/lists/long-lists",
        "document": "The standard constructor works well for small lists. To work with lists that contain a large number of items, it's best to use the constructor.\n\nIn contrast to the default constructor, which requires creating all items at once, the constructor creates items as they're scrolled onto the screen.\n\nFirst, you need a data source. For example, your data source might be a list of messages, search results, or products in a store. Most of the time, this data comes from the internet or a database.\n\nFor this example, generate a list of 10,000 Strings using the constructor.\n\nTo display the list of strings, render each String as a widget using . In this example, display each String on its own line.\n\nTo specify each item's extent, you can use either , , or .\n\nSpecifying either is more efficient than letting the children determine their own extent because the scrolling machinery can make use of the foreknowledge of the children's extent to save work, for example when the scroll position changes drastically.\n\nUse or if your list has items of fixed size.\n\nUse if your list has items of different sizes."
    },
    {
        "link": "https://techdynasty.medium.com/listview-builder-in-flutter-e54a8fa2c7a0",
        "document": "is a powerful Flutter widget used for efficiently creating scrollable lists or grids of items. It's particularly useful when dealing with a large number of items because it creates items on-demand as the user scrolls, reducing memory usage and improving performance. Here's an explanation of its main components:\n• itemCount: This property defines the number of items in the list. It specifies how many times the function will be called.\n• itemBuilder: This callback function is called for each item in the list. It takes two arguments: and . You're responsible for returning the widget for the item at the given index.\n• shrinkWrap: If set to , the will take up only as much vertical space as needed to display its children. It can be useful when the is placed inside another scrollable widget.\n• physics: Defines the scrolling behavior. You can choose from various options like , , and more, depending on how you want the scrolling to behave.\n• scrollDirection: Specifies the direction in which the list should scroll. It can be either (default) for a vertical list or for a horizontal list.\n\nis commonly used in the following scenarios:\n• Displaying Dynamic Data: When you have a list of items that can change in size, such as a list of messages, contacts, or products fetched from an API. It allows you to create UI elements for each item dynamically.\n• Optimizing Performance: When dealing with a large number of items, is more memory-efficient than creating a static list of widgets because it only creates widgets for the visible items.\n• Infinite Scrolling: It’s often used for implementing infinite scrolling in applications where new items are loaded as the user scrolls down, like in social media feeds.\n\nHere’s a simple example of using :\n• is a widget that creates a with multiple lists of data. You can customize the list to contain your data.\n• is a widget responsible for displaying a single list with cards. It takes a parameter, which is the data for that specific list.\n• Inside , we create a widget for each list. It includes a as the list title and a nested to display the items within the list.\n• The nested is set to have and to ensure that it doesn't scroll independently within each card but still scrolls as a whole list.\n\nYou can further customize the UI to match your specific design preferences."
    },
    {
        "link": "https://stackoverflow.com/questions/50794021/flutter-listview-builder-in-scrollable-column-with-other-widgets",
        "document": "I have a TabBarView() with an amount of different views. I want of them to be a Column with a TextField at top and a ListView.Builder() below, but both widgets should be in the same scrollable area (scrollview). The way I implemented it threw some errors:\n\nI read about stacking the ListView.builder() in an Expanded-Area but it made the textfield kind of \"sticky\" which is not what I want. :-)\n\nI also came across CustomScrollView but didn't fully understand how to implement it."
    },
    {
        "link": "https://github.com/flutter/flutter/issues/99778",
        "document": "The issue has been confirmed reproducible and is ready to work on\n\nThe issue has been confirmed reproducible and is ready to work on\n\nIssue is closed as not valid"
    },
    {
        "link": "https://api.flutter.dev/flutter/widgets/Table-class.html",
        "document": "A widget that uses the table layout algorithm for its children.\n\nIf you only have one row, the Row widget is more appropriate. If you only have one column, the SliverList or Column widgets will be more appropriate.\n\nRows size vertically based on their contents. To control the individual column widths, use the columnWidths property to specify a TableColumnWidth for each column. If columnWidths is null, or there is a null entry for a given column in columnWidths, the table uses the defaultColumnWidth instead.\n\nBy default, defaultColumnWidth is a FlexColumnWidth. This TableColumnWidth divides up the remaining space in the horizontal axis to determine the column width. If wrapping a Table in a horizontal ScrollView, choose a different TableColumnWidth, such as FixedColumnWidth.\n\nFor more details about the table layout algorithm, see RenderTable. To control the alignment of children, see TableCell."
    },
    {
        "link": "https://stackoverflow.com/questions/54155991/flutter-creating-tables-dynamically",
        "document": "I'm trying to dynamically create tables using Dart and Flutter. Something like this The number of table rows will change depending on the the JSON file passed in.\n\nI've read through and done all of the Flutter tutorials I can get my hands on and read through the Documentation on the Table and ListBuilder classes, but none of them quite accomplish what I'm trying to do, because the examples either only dynamically create single ListItems or all the data and/or Widgets are hard-coded.\n\nI've also tried doing this by doing: then dynamically adding children Widgets with\n\nBut I get an error saying \"Cannot add to an unmodifiable list\".\n\nAny tips on how to accomplish this would be greatly appreciated."
    },
    {
        "link": "https://api.flutter.dev/flutter/material/DataTable-class.html",
        "document": "A data table that follows the Material 2 design specification.\n\nColumns are sized automatically based on the table's contents. It's expensive to display large amounts of data with this widget, since it must be measured twice: once to negotiate each column's dimensions, and again when the table is laid out.\n\nA SingleChildScrollView mounts and paints the entire child, even when only some of it is visible. For a table that effectively handles large amounts of data, here are some other options to consider:\n• PaginatedDataTable, which automatically splits the data into multiple pages.\n\nThis sample shows how to display a DataTable with three columns: name, age, and role. The columns are defined by three DataColumn objects. The table contains three rows of data for three example users, the data for which is defined by three DataRow objects. link To create a local project with this code sample, run:\n\n flutter create --sample=material.DataTable.1 mysample\n\nDataTable can be sorted on the basis of any column in columns in ascending or descending order. If sortColumnIndex is non-null, then the table will be sorted by the values in the specified column. The boolean sortAscending flag controls the sort order.\n• DataColumn, which describes a column in the data table.\n• DataRow, which contains the data for a row in the data table.\n• DataCell, which contains the data for a single cell in the data table.\n• PaginatedDataTable, which shows part of the data in a data table and provides controls for paging through the remainder of the data.\n• from the two_dimensional_scrollables package, for displaying large amounts of data without pagination."
    },
    {
        "link": "https://dhiwise.com/post/the-art-of-organizing-data-with-the-flutter-table-class",
        "document": "Flutter, as we all know, is a comprehensive open-source framework that lets developers create aesthetically pleasing, high-performance applications for Android, iOS, Web, and Desktop from a single codebase.\n\nIn any Flutter app, managing and displaying data in a structured format is of utmost importance. This is where the Flutter Table Widget exhibits its significance.\n\nThe Flutter Table class, a core part of Flutter's data table widget, is a powerful tool that allows developers to make the most out of displaying tabular data. It uses the table layout algorithm for its children, making it an appropriate choice when you have multiple rows and columns to display.\n\nHowever, if you’re dealing with only one row, the Row widget becomes more appropriate, and for one column, SliverList or column widget will be more suitable.\n\nThis blog post aims to guide you in understanding the ins and outs of the Flutter table, along with a Flutter Table example for practical illustration.\n\nSo, let's dive into it!\n\nSimilar to tables used in web development, Flutter tables augment data representation, making it more readable and structured. Tables make complex data understandable – even non-technical people can easily make sense of the data. The Flutter Table Widget is a vital part of this data organization. In essence, a table widget in Flutter is a widget that employs a table layout algorithm to shape its children.\n\nWith Flutter's data table, you can exemplify column-oriented data. The table widget allows for the easy addition of rows and columns, facilitating a user-friendly way to organize UI elements on the screen. It provides a few extra features that set it apart. The key benefit is the control it offers over the alignment of widgets for each cell, the widget build buildcontext context and the ability to define column width, and the way the table's child widgets are partitioned among themselves.\n\nLet's now move ahead and unravel the core elements of a table in Flutter.\n\nWhen constructing a table in Flutter, there are several key elements that you should familiarize yourself with.\n• Children: These are the rows in the table, each defined by the TableRow class.\n• TableRow: The individual row in a Flutter Table. TableRow children property allows for specifying the items in the row.\n• Column Widths: Flutter Table allows controlling the columns' widths using the columnWidths property, which specifies a TableColumnWidth for each column. If columnWidths is null, or if there is a null entry for a given column in columnWidths, the table defaults to using defaultColumnWidth.\n• defaultColumnWidth: A TableColumnWidth that is used when the table's columnWidths map does not have an entry for a given column.\n\nWith a firm grasp of these elements, let’s proceed to observe how to display data using a Flutter data table.\n\nDisplaying data using a Flutter table revolves around the creation of rows and columns.\n\nThe actual table creation takes place with the Table class. The Table class has several properties, such as columns, border, defaultColumnWidth (with FlexColumnWidth as default), columnWidths, textDirection, and children. The rows of the table can be managed with the children's property of the Table class.\n\nHere’s an example of how to make a simple table using a Flutter table widget:\n\nThis code will create the table in your Flutter app with two rows and three columns, displaying six cells in total. In the next section, we'll explore the working of a Flutter data table, drawing from the Flutter table example provided.\n\nFollowing each of the subsequent sections, we will explore these concepts in more detail, including a walkthrough of a Flutter Table example, advanced techniques for displaying data, and useful tips for getting the most out of the Flutter Table widget.\n\nThe Flutter data table serves as an efficient way to exhibit tabular data. This table view is built with various elements like cells, columns, rows, and clickable actions.\n\nA DataTable widget takes two properties: columns and rows, which are both required. The columns are defined by the DataColumn widget, which takes a label as a required property. This label is a widget that appears as the column header.\n\nData rows are created with the help of DataRow. Each DataRow contains multiple DataCells. A DataCell can contain any widget, but generally, it holds Text or DropdownButton or Checkbox or ElevatedButton.\n\nHere is an example of how a Flutter data table in which we display three data columns of a user- id, name, and profession.\n\nIn the above code, DataTable has two properties, columns, and rows. The DataColumn represents the column of the data table, and DataRow is for creating rows dynamically. And for each DataRow, we are defining DataCell which is the cell data.\n\nSo, this way we can easily create our data table. Let's look at how we can deal with it in the forthcoming sections of our blog, along with the practical example and other features.\n\nAs a developer, you learn better by doing. Let's look at a hands-on example where we will create a Flutter table consisting of two rows and three columns.\n\nThis would look something like this in the code:\n\nWith this example, a simple table with borders, row headers of 'Name', 'Age', and 'ID', and one row of data is created. The entire table is wrapped in a container, but it could be any other widget like a Column or Row based on your layout. Padding is used in cells to provide white space around the cell data for a cleaner look.\n\nWhen dealing with large datasets, a Flutter data table might not be efficient due to the available real estate, particularly on a smaller screens of mobile devices. Though Flutter data tables support horizontal scrolling, it is not always a good user experience.\n\nIn such situations, the Flutter table widget comes to the rescue. A Table widget allows you to create a table layout in Flutter. It works with rows and columns, allowing for flexibility with the layout size and structure. The Table widget uses a TableLayout algorithm for its working, whereby the Table widget takes an array of rows and each row consists of an array of widgets.\n\nThis way makes it a lot easier to manipulate the table layout while maintaining the essence of a data table, making it a valuable asset in the toolkit of a Flutter developer. In the next section, we look at how to combine the power of Flutter tables with Material Design for a well-rounded user interface.\n\nFor a Flutter table view to be more attractive, Flutter comes with a Material Design version of DataTable. This DataTable widget adheres to the Material Design specifications. It offers features like sorting data in ascending or descending order, adjusting the cell width to fit the screen size, and even embedding other Material widgets such as DropDownButton, PopupButton, and IconMenuButton within the cell to enhance its capabilities.\n\nThis Flutter data table essentially has rows and columns, where rows represent the data and columns are the data types.\n\nIn the example above, we use the Material Design Flutter data table and create a data table comprising three columns and rows.\n\nAs discussed in the official material design data table guide , a material data table can be manipulated to change the look and functionality at the end-user level. This is extremely useful when you want to create a custom Flutter table layout that follows material design standards.\n\nIn the further sections, we're going to deep-dive into advanced concepts of Flutter table data.\n\nIn addition to the basics of creating rows and columns, Flutter Table also introduces advanced concepts for optimizing your table and working with different types of data. A few of these concepts include:\n• Cell Alignment: You can control the alignment of children within the cells of your table, with advanced adjustment of vertical alignment and baseline for text cells.\n• Column Width Sorting: The Flutter Table class also provides the option to control column widths. You can even specify a different TableColumnWidth to optimize your Table widget for any layout needs.\n• Table Borders: You can customize table borders according to your preferences with border property included in Flutter Table Class.\n\nThese additions to your table can improve readability, provide a better user experience, and add visual intrigue to your Flutter apps.\n\nHere’s how to modify the cell's content alignment and add column widths:\n\nIn this Flutter Table example, we've added 3 columns with different widths. The first column has an intrinsic width, and its width depends on the content of the cell. The second column has a flexible width, and it occupies the remaining space. The third column has a fixed width of 64 logical pixels. Moreover, children in each cell are aligned in the middle vertically.\n\nTables are an important part of the UI where data presentation is a prerequisite. As we’ve gone through, the Flutter Table widget is a great option among others for handling and managing this data.\n\nRemember to consider the following points when working with Flutter Tables:\n• Make the most use of the columnWidths property for a custom layout.\n• When large amounts of data are involved, always opt for a scrollable parent for your table.\n• Use DataRow and DataCell for better control over the widgets in the table.\n• Incorporate other Flutter widgets like Checkbox, DropdownButton, PopupMenuButton, etc. in DataCell to create an interactive datatable.\n• Leverage the power of defaultVerticalAlignment and textBaseline for custom alignment of cell data.\n• Use the TableBorder class to create custom borders around your table.\n\nHere is a simple yet impactful example to illustrate all these best practices together:\n\nThis is an advanced example where you can see how to create a Flutter data table with scrolling, sorting, and selecting capabilities.\n\nRemember, the capabilities of Flutter Table are not just restricted to these features. With its compatibility with Material Design and other widgets, a Flutter data table application is endless.\n\nAnd with this, we conclude our comprehensive guide and walkthrough on understanding the Flutter Table class, as well as how it can be employed in your Flutter projects. Keep exploring to make the most of your Flutter journey!\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/71910741/how-to-create-flutter-table",
        "document": "I'm trying to create a table the same as in this one :\n\nIs there an easy way to show the author's books the way they appear in the table above?.\n\nI tried to use a List of ExpansionTile, but the code become more complicated since i want to fetch the data from an API."
    }
]