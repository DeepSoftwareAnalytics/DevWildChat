[
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://ni4yja.medium.com/parent-child-communication-in-vue-from-child-to-parent-9d9d9d353a09",
        "document": "I chose the Star Wars theme just before the war started, kind of prophetic, don’t you think? Relation between Luke and his father is dramatic and recognizable, and I wanted to use it in my small project about components’ communication in Vue. There are two components — and . The child has a text field for a message, which should be sent to its parent and displayed in it. How to achieve this?\n\nWe need to use , which allows us to send custom events from a child component to its parent. Each Vue call can pass two arguments: the event name and a payload object (optional). Let’s check how it works on the real-world example. In my codesandbox (visit this link to play around with code), the parent component listens for a custom event and confers the received value to its data:\n\nNow we need our child component to listen for the native input event and then emit its event. To pass the value of our original change event, we need to send our custom event with the event payload — in this case, the — as a second parameter. It looks like this:\n\nThat’s all the magic. The message from the child component is displayed in its parent. Note, that this is an example of emitting inline events in Vue. If you are curious about other ways of using in your code, watch this video. Thanks for reading. Stay tuned."
    },
    {
        "link": "https://medium.com/js-dojo/component-communication-in-vue-js-ca8b591d7efa",
        "document": "In modern front-end frameworks, the entire page is divided into small pieces of components. Each component has its own functionality & UI. Component-based architecture makes it easy to develop & maintain an application. During development, you may come across a situation where you need to share data between with other components. In this post, we are going to learn about many possible ways of achieving communication between components.\n\nIn this type of communication, a parent passes the data to child by adding an argument in the component declaration.\n\nConsider the above code. Here we have added an argument “message” in the child component declaration. For dynamically setting the value we have to add “ : ” before the argument.\n\nIn our child component, we have added an input argument “message” along with the data type “String”.\n\nProps provide only one-way communication from a parent to child but vice-versa is not possible. Any changes in the values of an attribute/argument in the prop is directly reflected in the child.\n\nBut what if you want to call a method inside child component when the value is changed.\n\nIn the above example, we have added a property “watch” inside which a function to invoke the callMe() method is declared. This will ensure that when the value is changed callMe() function will be invoked.\n\nIn this type of communication, Events ensures communication from child to parent.\n\nHere in the “ChildComponent” we are firing an event that emits a message and its parent can get this message using the “v-on:” directive.\n\nIn events, arguments are optional. You can pass ’n’ number of arguments. When child component will fire the event “messageFromChild()”, “childMessageReceived()” function will be called.\n\n3. Communication between any components using Event Bus\n\nEvent Bus is not limited to a parent-child relation. You can share information between any components.\n\nIn the above AbcComponent, we are firing an event “message_from_abc” and passing arguments. Arguments are optional here. Any other component can listen to this event.\n\nIn XyzComponent to listen an event, we have to register it first. We can do so by putting an event listener inside mounted() callback. This callback will be triggered when an event is fired from any component.\n\nAlternatively, we can use Vuex a redux based state management tool for Vue.\n\nWe’ll discuss Vuex on my next article. Stay tuned…."
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/techniques-for-sharing-data-between-vue-js-components",
        "document": "In this example, we are passing the prop with a value of to our child component. We will then be able to access this value from inside of the by initializing our props object in the script tag of our child component file\n\nAs our application grows in size and complexity, passing data through components can become messy. We will have to pass data from a parent component to a child component which may be deeply nested in the component tree. Stores introduce an advanced method of passing data across components by eliminating the problem of prop drilling. Prop drilling refers to transporting data or states as props to the intended destination through intermediate components.\n\nWith stores, our states or data are stored in a centralized point to be accessed by any components irrespective of their hierarchy in the component tree. This is a common way of handling states for big Vue.js applications. Popular state management tools for Vue.js include Pinia and Vuex. For our basic example, we will use Pinia which is the official state management tool for Vue js 3.\n\nProvide and Inject technique is also another useful technique of preventing prop drilling when building complex Vue.js applications. With this technique the parent component can provide dependencies for all its child components. This means that any component in the component tree, regardless of how deep it is, can inject dependencies that are provided by components higher up in the component chain."
    },
    {
        "link": "https://stackoverflow.com/questions/61998500/call-parent-methods-from-child-components-vue-js",
        "document": "You should use inside of your child component, when you want to trigger the method in the parent.\n\nThen find your child component in the template of the parent and add an event catcher on it like this:\n\nIf you want to add parameters to your method, you can add a second parameter to your emit like this:\n\nFor this to work you don't have to change anything in the event \"catcher\", as long as the method you call has a parameter."
    },
    {
        "link": "https://stackoverflow.com/questions/64605807/vuejs-3-emit-event-from-child-to-parent-component",
        "document": "I've recently started working with VueJS, I'm using v3 and seem to be having an issue calling a method on a parent. The emit function in the child doesn't seem to be emitting the event and nothing is getting picked up in the parent.\n\nI've included the parent and child to show how I have it set up\n\nHow should this be done? Is there something I've missed?\n\nI was wondering can I still use here?"
    },
    {
        "link": "https://learnvue.co/articles/vue-emit-guide",
        "document": "Many Vue patterns involve passing data from a parent component to its children using . But what if we need a child to affect its parent?\n\nUsing , we can trigger events and pass data up the component heirarchy. This is useful for things like:\n• closing modals from inside the modal itself\n• making our parent component respond to one of its children\n\nWhen we emit an event, we invoke a method with one or more arguments:\n• – the name of our event. Our parent component will listen for this.\n• – any value(s) that we want to pass with our event\n\nHere’s an example of an inline emit, . We are emitting an event called and passing it a value of\n\nThen, using the or directive, a parent component can listen to our custom event and receive the value.\n\nEvery time we click our button, emits an event called with a random value between 0 and 1. Then, captures this event and adds that value to\n\nWe can pass as many arguments as we want and our listener will receive all of them.\n\nSo now, we know how to emit inline events in our template, but in more complicated examples, it's better if we emit an event from the section of our SFC instead. This is useful when we want to perform some logic before emitting an event.\n\nIn Vue 3, we have 2 different ways to do this:\n\nLet’s check out an example for each.\n\nWhen we are using , we don't have access to the component instance or the setup function's argument.\n\nSoooo. How do we get ?\n\nIn this case, we have a compiler macro called that let us:\n• specify events that our component emits\n• have access to the same value as so we can emit events\n\nIn the simplest case, array of strings, with each one being the name of an event.\n\nHowever, if we pass an object, we can add a validator function for each event that lets us check we're emitting events with proper values.\n\nLike event listeners, the validator accepts however many values as we pass in.\n\nThis works similar to prop validation, where if our validator returns , we'll get a warning in our console. While the event with the unvalidated value will still be emitted, the console warning provides valuable feedback during development.\n\nUsing is called the runtime declaration since it creates a runtime check for your component events.\n\nHowever, if we want to unleash the full power of Typescript, we can also used type-based . This is typically the method that I choose to use.\n\nHere's the initial component that we wrote with this syntax.\n\nSo when we used the type-based method, we can specify our eventName as and then add any payload options after that.\n\nHowever, in the upcoming Vue 3.3 release, we're going to get an even cleaner way to write this. See this tweet by Evan You to learn more.\n\nIn the Composition API, if we use the function, we don't have access to our component with - meaning we can't call to send our event.\n\nInstead, we can access our method by using the second argument of our function – .\n\nhas access to your components slots, attributes, and most importantly for us, its emit method.\n\nWe can call with the same event name and values that we used before.\n\nLike most things in Vue 3, we have the choice of using the Options API or the Composition API.\n\nIn the Options API, we can call to emit a custom event.\n\nLet's take a look at an example where we have that contains a label and a text input. Whenever the text changes, we want to emit an event with the uppercased value of our input.\n\nInstead of calling from our template, we can call a component method instead. Inside, we can call and pass it our value.\n\nWhile this is a simple example, extracting this logic outside of our component gives us easier access to other properties in our data and helps keep our logic organized in larger files.\n\nIf we're not using , we can still keep track custom events for a component by defining the option in our .\n\nThis is important for keeping good component documentation and for getting errors from Vue if we try to use an event not declared in .\n\nAlso, defining events makes component events take priority over the native events.\n\nFor example, if we define an event called (an existing HTML event), we can override the default action.\n\nIn Vue 3, event names can automatically be converted between the different cases. Similar to props, it's best to stick to each programming language’s conventions and use in your script and in your template.\n\nHowever, if you're using Vue 2, event names don't have automatic case conversion and since directive automatically converts your event names to lower case so camelCase named events impossible to listen to.\n\nFor example, if we emitted an event called , listening for would not work.\n\nThe ability to emit custom events in Vue is one of the most important techniques to understand before working on larger Vue projects.\n\nI hope this overview of Vue helped explain the different ways to use this powerful feature in all sorts of Vue apps."
    },
    {
        "link": "https://stackoverflow.com/questions/67371579/vue-3-emit-event-from-parent-to-child-component",
        "document": "If you were like me calling some event on and in Vue2 from any parent/child to any child/parent for somehow keep your code cleaner rather then using bunch of emits and props respectively and have your code blows up..\n\nfrom Vue3 doc, event bus pattern can be replaced by using an external library implementing the event emitter interface. use a library that implement a pub-sub pattern or write it. vue3 event description\n\nNow if you're using the Option-API (like vue 2) y need to import that event file then using it right a way in any component.\n\nif you are using the you need add extra step in order to you that event library heres the code.\n\nhere's a basic example of pub-sub javascript pattern, don't forget to add the off method and call it on (v3), (v2) to not have multiple function execution for each mounted call )\n\nif you're doing vue2 like syntax Option-API: //in vue component\n\n//obviously you have to emit that from another component //...\n\nif you're using the which means all variables and methods are exposed by default to the template.\n\n//using it in a"
    },
    {
        "link": "https://vuejs.org/guide/components/events.html",
        "document": "A component can emit custom events directly in template expressions (e.g. in a handler) using the built-in method:\n\nThe parent can then listen to it using :\n\nThe modifier is also supported on component event listeners:\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to to provide this value:\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\nOr, if the event handler is a method:\n\nThen the value will be passed as the first parameter of that method:\n\nA component can explicitly declare the events it will emit using the macro option:\n\nThe method that we used in the isn't accessible within the section of a component, but returns an equivalent function that we can use instead: The macro cannot be used inside a function, it must be placed directly within , as in the example above. If you're using an explicit function instead of , events should be declared using the option, and the function is exposed on the context: As with other properties of the context, can safely be destructured:\n\nThe option and macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the call and returns a boolean to indicate whether the event is valid or not."
    },
    {
        "link": "https://yaasir007.medium.com/how-to-use-props-and-emits-in-vue-3-59228403bd30",
        "document": "Vue 3 is a progressive JavaScript framework that is widely used for building user interfaces. Its component-based architecture allows developers to create reusable code, making applications more efficient and easier to manage. Two fundamental concepts in Vue 3 are “props” and “emits.” These features facilitate communication between components and play a critical role in the framework’s reactivity system. This article will guide you through how to effectively use props and emits in Vue 3, enhancing your component building skills.\n\nProps, short for properties, allow you to pass data from a parent component to a child component. This method of one-way data binding enables child components to receive and utilize data without altering it directly. Here’s how to define and use props effectively:\n\nProps can be defined in the script section of a Vue component. Here’s an example:\n\nIn the above example, a `title` prop is defined, which expects a string and is required.\n\nTo use the defined prop in a child component, you need to pass it down from the parent:\n\nHere, the `title` prop is passed from the parent component to the `ChildComponent`.\n\nBest Practices for Using Props\n\n1. Use Prop Types: Always define the expected type of your props. This helps in validating the data and ensures that your components behave as expected.\n\n2. Provide Default Values: In scenarios where props may not always be provided, consider adding default values to avoid undefined behavior:\n\n3. Be Cautious with Object Types: When using objects or arrays as props, remember they are passed by reference. Mutating a prop in the child component can lead to unexpected behavior in the parent component.\n\nEmits are how child components communicate with their parent components, allowing you to send events up the component hierarchy. This two-way communication enhances interactivity and responsiveness in your application.\n\nTo emit an event from a child component, use the `$emit` method:\n\nIn this code, when the button is clicked, the `dataSent` event is emitted along with a payload.\n\nIn the parent component, you can catch the emitted event by using the `v-on` directive or the `@` shorthand:\n\nHere, when the `dataSent` event occurs, the `handleData` method is triggered, logging the message to the console.\n\nBest Practices for Using Emits\n\n1. Naming Conventions: Use clear and descriptive event names, ideally in camelCase format, to make the purposes of events obvious to other developers.\n\n2. Event Arguments: When emitting events, always consider the payload you want to send. Limit it to only what is necessary to reduce complexity.\n\n3. Use `defineEmits`: In the Composition API, you can define emitted events using `defineEmits`, which offers better type inference and validation.\n\nProps and emits are critical components of Vue 3’s reactivity system that facilitate communication between parent and child components. By effectively using these features, you can create more dynamic and modular applications. Always remember to validate prop types, provide defaults, and emit events with clear naming conventions. Mastering these concepts will enhance your development workflow and empower you to build more robust Vue 3 applications.\n\nAs you continue to explore Vue 3, you’ll find that effectively managing component interactions through props and emits is key to building scalable and maintainable software solutions."
    }
]