[
    {
        "link": "https://github.com/http-party/node-http-proxy",
        "document": "is an HTTP programmable proxying library that supports websockets. It is suitable for implementing components such as reverse proxies and load balancers.\n\nA new proxy is created by calling and passing an object as argument (valid properties are available here)\n\n†Unless listen(..) is invoked on the object, this does not create a webserver. See below.\n\nAn object will be returned with four methods:\n• listen (a function that wraps the object in a webserver, for your convenience)\n• close (a function that closes the inner webserver and stops listening on given port)\n\nIt is then possible to proxy requests by calling these functions\n\nErrors can be listened on either using the Event Emitter API\n\nor using the callback API\n\nWhen a request is proxied it follows two different pipelines (available here) which apply transformations to both the and object. The first pipeline (incoming) is responsible for the creation and manipulation of the stream that connects your client to the target. The second pipeline (outgoing) is responsible for the creation and manipulation of the stream that, from your target, returns data to the client.\n\n†Invoking listen(..) triggers the creation of a web server. Otherwise, just the proxy instance is created.\n\nThis example shows how you can proxy a request using your own HTTP server and also you can put your own logic to handle the request.\n\nThis example shows how you can proxy a request using your own HTTP server that modifies the outgoing proxy request by adding a special header.\n\n// To modify the proxy connection before data is sent, you can listen // for the 'proxyReq' event. When the event is fired, you will receive // http.ServerResponse res, Object options). This mechanism is useful when // you need to modify the proxy request before the proxy connection // is made to the target. // You can define here your custom logic to handle the request // and then proxy the request. :\n\nSometimes when you have received a HTML/XML document from the server of origin you would like to modify it before forwarding it on.\n\nHarmon allows you to do this in a streaming style so as to keep the pressure on the proxy to a minimum.\n\nYou can activate the validation of a secure SSL certificate to the target connection (avoid self-signed certs), just set in the options.\n\nYou can activate the websocket support for the proxy using in the options.\n\nAlso you can proxy the websocket requests just calling the method.\n• target: url string to be parsed with the url module\n• forward: url string to be parsed with the url module\n• agent: object to be passed to http(s).request (see Node's https agent and http agent objects)\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• secure: true/false, if you want to verify the SSL Certs\n• toProxy: true/false, passes the absolute URL as the (useful for proxying to proxies)\n• prependPath: true/false, Default: true - specify whether you want to prepend the target's path to the proxy path\n• ignorePath: true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).\n• changeOrigin: true/false, Default: false - changes the origin of the host header to the target URL\n• preserveHeaderKeyCase: true/false, Default: false - specify whether you want to keep letter case of response header key\n• autoRewrite: rewrites the location host/port on (201/301/302/307/308) redirects based on requested host/port. Default: false.\n• protocolRewrite: rewrites the location protocol on (201/301/302/307/308) redirects to 'http' or 'https'. Default: null.\n• \n• String: new domain, for example . To remove the domain, use .\n• Object: mapping of domains to new domains, use to match all domains. For example keep one domain unchanged, rewrite one domain and remove other domains:\n• \n• String: new path, for example . To remove the path, use . To set path to root use .\n• Object: mapping of paths to new paths, use to match all paths. For example, to keep one path unchanged, rewrite one path and remove other paths:\n• headers: object with extra headers to be added to target requests.\n• followRedirects: true/false, Default: false - specify whether you want to follow redirects\n• selfHandleResponse true/false, if set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the event\n• buffer: stream of data to send as the request body. Maybe you have some middleware that consumes the request stream before proxying it on e.g. If you read the body of a request into a field called 'req.rawbody' you could restream this field in the buffer option: 'use strict'; const streamify = require('stream-array'); const HttpProxy = require('http-proxy'); const proxy = new HttpProxy(); module.exports = (req, res, next) => { proxy.web(req, res, { target: 'http://localhost:4003/', buffer: streamify(req.rawBody) }, next); };\n\nNOTE: and are optional. and cannot both be missing\n\nIf you are using the method, the following options are also applicable:\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• : The error event is emitted if the request to the target fail. We do not do any error handling of messages passed between client and proxy, and messages passed between proxy and target, so it is recommended that you listen on errors and handle them.\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"web\" connections\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"websocket\" connections\n• : This event is emitted if the request to the target got a response.\n• : This event is emitted once the proxy websocket was created and piped into the target websocket.\n• : This event is emitted once the proxy websocket was closed.\n• When testing or running server within another program it may be necessary to close the proxy.\n• This will stop the proxy from accepting new connections.\n\nIf you want to handle your own response after receiving the , you can do so with . As you can see below, if you use this option, you are able to intercept and read the but you must also make sure to reply to the itself otherwise the original client will never receive any data.\n\nA proxy table API is available through this add-on module, which lets you define a set of rules to translate matching routes to target routes that the reverse proxy will talk to.\n• If you can't find anything, open an issue\n• If you feel comfortable about fixing the issue, fork the repo\n• Commit to your local branch (which must be different from )\n• Submit your Pull Request (be sure to include tests and update documentation)"
    },
    {
        "link": "https://nodejs.org/api/http.html",
        "document": "This module, containing both a client and server, can be imported via (CommonJS) or (ES module).\n\nThe HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data.\n\nHTTP message headers are represented by an object like this:\n\nKeys are lowercased. Values are not modified.\n\nIn order to support the full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.\n\nSee for details on how duplicate headers are handled.\n\nThe raw headers as they were received are retained in the property, which is an array of . For example, the previous message header object might have a list like the following:\n\nAn is responsible for managing connection persistence and reuse for HTTP clients. It maintains a queue of pending requests for a given host and port, reusing a single socket connection for each until the queue is empty, at which time the socket is either destroyed or put into a pool where it is kept to be used again for requests to the same host and port. Whether it is destroyed or pooled depends on the option. Pooled connections have TCP Keep-Alive enabled for them, but servers may still close idle connections, in which case they will be removed from the pool and a new connection will be made when a new HTTP request is made for that host and port. Servers may also refuse to allow multiple requests over the same connection, in which case the connection will have to be remade for every request and cannot be pooled. The will still make the requests to that server, but each one will occur over a new connection. When a connection is closed by the client or the server, it is removed from the pool. Any unused sockets in the pool will be unrefed so as not to keep the Node.js process running when there are no outstanding requests. (see ). It is good practice, to an instance when it is no longer in use, because unused sockets consume OS resources. Sockets are removed from an agent when the socket emits either a event or an event. When intending to keep one HTTP request open for a long time without keeping it in the agent, something like the following may be done: An agent may also be used for an individual request. By providing as an option to the or functions, a one-time use with default options will be used for the client connection. Change the default scheduling from 'fifo' to 'lifo'. Add option to specify the free socket scheduling strategy.\n• <Object> Set of configurable options to set on the agent. Can have the following fields:\n• <boolean> Keep sockets around even when there are no outstanding requests, so they can be used for future requests without having to reestablish a TCP connection. Not to be confused with the value of the header. The header is always sent when using an agent except when the header is explicitly specified or when the and options are respectively set to and , in which case will be used. Default: .\n• <number> When using the option, specifies the initial delay for TCP Keep-Alive packets. Ignored when the option is or . Default: .\n• <number> Maximum number of sockets to allow per host. If the same host opens multiple concurrent connections, each request will use new socket until the value is reached. If the host attempts to open more connections than , the additional requests will enter into a pending request queue, and will enter active connection state when an existing connection terminates. This makes sure there are at most active connections at any point in time, from a given host. Default: .\n• <number> Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: .\n• <number> Maximum number of sockets per host to leave open in a free state. Only relevant if is set to . Default: .\n• <string> Scheduling strategy to apply when picking the next free socket to use. It can be or . The main difference between the two scheduling strategies is that selects the most recently used socket, while selects the least recently used socket. In case of a low rate of request per second, the scheduling will lower the risk of picking a socket that might have been closed by the server due to inactivity. In case of a high rate of request per second, the scheduling will maximize the number of open sockets, while the scheduling will keep it as low as possible. Default: .\n• <number> Socket timeout in milliseconds. This will set the timeout when the socket is created. in are also supported. To configure any of them, a custom instance must be created.\n• <Object> Options containing connection details. Check for the format of the options Produces a socket/stream to be used for HTTP requests. By default, this function is the same as . However, custom agents may override this method in case greater flexibility is desired. A socket/stream can be supplied in one of two ways: by returning the socket/stream from this function, or by passing the socket/stream to . This method is guaranteed to return an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Called when is detached from a request and could be persisted by the . Default behavior is to: This method can be overridden by a particular subclass. If this method returns a falsy value, the socket will be destroyed instead of persisting it for use with the next request. The argument can be an instance of <net.Socket>, a subclass of <stream.Duplex>. Called when is attached to after being persisted because of the keep-alive options. Default behavior is to: This method can be overridden by a particular subclass. The argument can be an instance of <net.Socket>, a subclass of <stream.Duplex>. Destroy any sockets that are currently in use by the agent. It is usually not necessary to do this. However, if using an agent with enabled, then it is best to explicitly shut down the agent when it is no longer needed. Otherwise, sockets might stay open for quite a long time before the server terminates them. The property now has a prototype. An object which contains arrays of sockets currently awaiting use by the agent when is enabled. Do not modify. Sockets in the list will be automatically destroyed and removed from the array on . The parameter is now optional.\n• <Object> A set of options providing information for name generation\n• <string> A domain name or IP address of the server to issue the request to\n• <string> Local interface to bind for network connections when issuing the request\n• <integer> Must be 4 or 6 if this doesn't equal . Get a unique name for a set of request options, to determine whether a connection can be reused. For an HTTP agent, this returns or . For an HTTPS agent, the name includes the CA, cert, ciphers, and other HTTPS/TLS-specific options that determine socket reusability. By default set to 256. For agents with enabled, this sets the maximum number of sockets that will be left open in the free state. By default set to . Determines how many concurrent sockets the agent can have open per origin. Origin is the returned value of . By default set to . Determines how many concurrent sockets the agent can have open. Unlike , this parameter applies across all origins. The property now has a prototype. An object which contains queues of requests that have not yet been assigned to sockets. Do not modify. The property now has a prototype. An object which contains arrays of sockets currently in use by the agent. Do not modify.\n\nThis object is created internally and returned from . It represents an in-progress request whose header has already been queued. The header is still mutable using the , , API. The actual header will be sent along with the first data chunk or when calling . To get the response, add a listener for to the request object. will be emitted from the request object when the response headers have been received. The event is executed with one argument which is an instance of . During the event, one can add listeners to the response object; particularly to listen for the event. If no handler is added, then the response will be entirely discarded. However, if a event handler is added, then the data from the response object must be consumed, either by calling whenever there is a event, or by adding a handler, or by calling the method. Until the data is consumed, the event will not fire. Also, until the data is read it will consume memory that can eventually lead to a 'process out of memory' error. For backward compatibility, will only emit if there is an listener registered. Set header to limit the response body size. If is set to , mismatching the header value will result in an being thrown, identified by . value should be in bytes, not characters. Use to determine the length of the body in bytes. - Deprecated. Listen for the event instead. Emitted when the request has been aborted by the client. This event is only emitted on the first call to . Indicates that the request is completed, or its underlying connection was terminated prematurely (before the response completion). Emitted each time a server responds to a request with a method. If this event is not being listened for, clients receiving a method will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. A client and server pair demonstrating how to listen for the event: Emitted when the server sends a '100 Continue' HTTP response, usually because the request contained 'Expect: 100-continue'. This is an instruction that the client should send the request body. Emitted when the request has been sent. More specifically, this event is emitted when the last segment of the response headers and body have been handed off to the operating system for transmission over the network. It does not imply that the server has received anything yet. Emitted when the server sends a 1xx intermediate response (excluding 101 Upgrade). The listeners of this event will receive an object containing the HTTP version, status code, status message, key-value headers object, and array with the raw header names followed by their respective values. 101 Upgrade statuses do not fire this event due to their break from the traditional HTTP request/response chain, such as web sockets, in-place TLS upgrades, or HTTP 2.0. To be notified of 101 Upgrade notices, listen for the event instead. Emitted when a response is received to this request. This event is emitted only once. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Emitted when the underlying socket times out from inactivity. This only notifies that the socket has been idle. The request must be destroyed manually. Emitted each time a server responds to a request with an upgrade. If this event is not being listened for and the response status code is 101 Switching Protocols, clients receiving an upgrade header will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. A client server pair demonstrating how to listen for the event. Marks the request as aborting. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed. The property is no longer a timestamp number. The property will be if the request has been aborted. The parameter can now be a . This method now returns a reference to . Finishes sending the request. If any parts of the body are unsent, it will flush them to the stream. If the request is chunked, this will send the terminating . If is specified, it is equivalent to calling followed by . If is specified, it will be called when the request stream is finished. The function returns for consistency with other Readable streams.\n• <Error> Optional, an error to emit with event. Destroy the request. Optionally emit an event, and emit a event. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed. See for further details. Is after has been called. See for further details. The property will be if has been called. will automatically be called if the request was initiated via . For efficiency reasons, Node.js normally buffers the request headers until is called or the first chunk of request data is written. It then tries to pack the request headers and data into a single TCP packet. That's usually desired (it saves a TCP round-trip), but not when the first data is not sent until possibly much later. bypasses the optimization and kickstarts the request. Reads out a header on the request. The name is case-insensitive. The type of the return value depends on the arguments provided to . Returns an array containing the unique names of the current outgoing headers. All header names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related http module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns an array containing the unique names of the current outgoing raw headers. Header names are returned with their exact casing being set. Returns if the header identified by is currently set in the outgoing headers. The header name matching is case-insensitive. Limits maximum response headers count. If set to 0, no limit will be applied. Removes a header that's already defined into headers object.\n• <boolean> Whether the request is send through a reused socket. When sending request through a keep-alive enabled agent, the underlying socket might be reused. But if server closes connection at unfortunate time, client may run into a 'ECONNRESET' error. By marking a request whether it reused socket or not, we can do automatic error retry base on it. Sets a single header value for headers object. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. Therefore, may return non-string values. However, the non-string values will be converted to strings for network transmission. When the value is a string an exception will be thrown if it contains characters outside the encoding. If you need to pass UTF-8 characters in the value please encode the value using the RFC 8187 standard. Once a socket is assigned to this request and is connected will be called. Once a socket is assigned to this request and is connected will be called. Consistently set socket timeout only when the socket connects.\n• <Function> Optional function to be called when a timeout occurs. Same as binding to the event. Once a socket is assigned to this request and is connected will be called. Reference to the underlying socket. Usually users will not want to access this property. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. http ; options = { : , }; req = http. (options); req. (); req. ( , { ip = req. . ; port = req. . ; . ( `Your IP address is and your source port is .` ); }); http = ( ); options = { : , }; req = http. (options); req. (); req. ( , { ip = req. . ; port = req. . ; . ( `Your IP address is and your source port is .` ); }); This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket>. Is after has been called. This property does not indicate whether the data has been flushed, for this use instead. Is if all data has been flushed to the underlying system, immediately before the event is emitted. The parameter can now be a . Sends a chunk of the body. This method can be called multiple times. If no is set, data will automatically be encoded in HTTP Chunked transfer encoding, so that server knows when the data ends. The header is added. Calling is necessary to finish sending the request. The argument is optional and only applies when is a string. Defaults to . The argument is optional and will be called when this chunk of data is flushed, but only if the chunk is non-empty. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in user memory. will be emitted when the buffer is free again. When function is called with empty string or buffer, it does nothing and waits for more input.\n\nEmitted each time a request with an HTTP is received. If this event is not listened for, the server will automatically respond with a as appropriate. Handling this event involves calling if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body. When this event is emitted and handled, the event will not be emitted. Emitted each time a request with an HTTP header is received, where the value is not . If this event is not listened for, the server will automatically respond with a as appropriate. When this event is emitted and handled, the event will not be emitted. The default behavior will return a 431 Request Header Fields Too Large if a HPE_HEADER_OVERFLOW error occurs. The is the current buffer that just parsed. Adding this buffer to the error object of event is to make it possible that developers can log the broken packet. The default action of calling on the will no longer take place if there are listeners attached for . If a client connection emits an event, it will be forwarded here. Listener of this event is responsible for closing/destroying the underlying socket. For example, one may wish to more gracefully close the socket with a custom HTTP response instead of abruptly severing the connection. The socket must be closed or destroyed before the listener ends. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Default behavior is to try close the socket with a HTTP '400 Bad Request', or a HTTP '431 Request Header Fields Too Large' in the case of a error. If the socket is not writable or headers of the current attached has been sent, it is immediately destroyed. is the object that the error originated from. When the event occurs, there is no or object, so any HTTP response sent, including response headers and payload, must be written directly to the object. Care must be taken to ensure the response is a properly formatted HTTP response message. is an instance of with two extra columns:\n• : the bytes count of request packet that Node.js may have parsed correctly; In some cases, the client has already received the response and/or the socket has already been destroyed, like in case of errors. Before trying to send data to the socket, it is better to check that it is still writable.\n• <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n• <stream.Duplex> Network socket between the server and client\n• <Buffer> The first packet of the tunneling stream (may be empty) Emitted each time a client requests an HTTP method. If this event is not listened for, then clients requesting a method will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. After this event is emitted, the request's socket will not have a event listener, meaning it will need to be bound in order to handle data sent to the server on that socket. This event is emitted when a new TCP stream is established. is typically an object of type . Usually users will not want to access this event. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. The can also be accessed at . This event can also be explicitly emitted by users to inject connections into the HTTP server. In that case, any stream can be passed. If is called here, the timeout will be replaced with when the socket has served a request (if is non-zero). This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>.\n• <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n• <stream.Duplex> Network socket between the server and client When the number of requests on a socket reaches the threshold of , the server will drop new requests and emit event instead, then send to client. Emitted each time there is a request. There may be multiple requests per connection (in the case of HTTP Keep-Alive connections). Not listening to this event no longer causes the socket to be destroyed if a client sends an Upgrade header.\n• <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n• <stream.Duplex> Network socket between the server and client\n• <Buffer> The first packet of the upgraded stream (may be empty) Emitted each time a client requests an HTTP upgrade. Listening to this event is optional and clients cannot insist on a protocol change. After this event is emitted, the request's socket will not have a event listener, meaning it will need to be bound in order to handle data sent to the server on that socket. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Stops the server from accepting new connections and closes all connections connected to this server which are not sending a request or waiting for a response. See . Closes all established HTTP(S) connections connected to this server, including active connections connected to this server which are sending a request or waiting for a response. This does not destroy sockets upgraded to a different protocol, such as WebSocket or HTTP/2. This is a forceful way of closing all connections and should be used with caution. Whenever using this in conjunction with , calling this after is recommended as to avoid race conditions where new connections are created between a call to this and a call to . Closes all connections connected to this server which are not sending a request or waiting for a response. Starting with Node.js 19.0.0, there's no need for calling this method in conjunction with to reap connections. Using it won't cause any harm though, and it can be useful to ensure backwards compatibility for libraries and applications that need to support versions older than 19.0.0. Whenever using this in conjunction with , calling this after is recommended as to avoid race conditions where new connections are created between a call to this and a call to . The default is now set to the minimum between 60000 (60 seconds) or .\n• <number> Default: The minimum between or . Limit the amount of time the parser will wait to receive the complete HTTP headers. If the timeout expires, the server responds with status 408 without forwarding the request to the request listener and then closes the connection. It must be set to a non-zero value (e.g. 120 seconds) to protect against potential Denial-of-Service attacks in case the server is deployed without a reverse proxy in front. Starts the HTTP server listening for connections. This method is identical to from .\n• <boolean> Indicates whether or not the server is listening for connections. Limits maximum incoming headers count. If set to 0, no limit will be applied. The default request timeout changed from no timeout to 300s (5 minutes). Sets the timeout value in milliseconds for receiving the entire request from the client. If the timeout expires, the server responds with status 408 without forwarding the request to the request listener and then closes the connection. It must be set to a non-zero value (e.g. 120 seconds) to protect against potential Denial-of-Service attacks in case the server is deployed without a reverse proxy in front. The default timeout changed from 120s to 0 (no timeout). Sets the timeout value for sockets, and emits a event on the Server object, passing the socket as an argument, if a timeout occurs. If there is a event listener on the Server object, then it will be called with the timed-out socket as an argument. By default, the Server does not timeout sockets. However, if a callback is assigned to the Server's event, timeouts must be handled explicitly. The maximum number of requests socket can handle before closing keep alive connection. A value of will disable the limit. When the limit is reached it will set the header value to , but will not actually close the connection, subsequent requests sent after the limit is reached will get as a response. The default timeout changed from 120s to 0 (no timeout). The number of milliseconds of inactivity before a socket is presumed to have timed out. A value of will disable the timeout behavior on incoming connections. The socket timeout logic is set up on connection, so changing this value only affects new connections to the server, not any existing connections. The number of milliseconds of inactivity a server needs to wait for additional incoming data, after it has finished writing the last response, before a socket will be destroyed. If the server receives new data before the keep-alive timeout has fired, it will reset the regular inactivity timeout, i.e., . A value of will disable the keep-alive timeout behavior on incoming connections. A value of makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout. The socket timeout logic is set up on connection, so changing this value only affects new connections to the server, not any existing connections. Calls and returns a promise that fulfills when the server has closed.\n\nThis object is created internally by an HTTP server, not by the user. It is passed as the second parameter to the event. Indicates that the response is completed, or its underlying connection was terminated prematurely (before the response completion). Emitted when the response has been sent. More specifically, this event is emitted when the last segment of the response headers and body have been handed off to the operating system for transmission over the network. It does not imply that the client has received anything yet. This method adds HTTP trailing headers (a header but at the end of the message) to the response. Trailers will only be emitted if chunked encoding is used for the response; if it is not (e.g. if the request was HTTP/1.0), they will be silently discarded. HTTP requires the header to be sent in order to emit trailers, with a list of the header fields in its value. E.g., Attempting to set a header field name or value that contains invalid characters will result in a being thrown. The parameter can now be a . This method now returns a reference to . This method signals to the server that all of the response headers and body have been sent; that server should consider this message complete. The method, , MUST be called on each response. If is specified, it is similar in effect to calling followed by . If is specified, it will be called when the response stream is finished. The property will be if has been called. Flushes the response headers. See also: . Reads out a header that's already been queued but not sent to the client. The name is case-insensitive. The type of the return value depends on the arguments provided to . Returns an array containing the unique names of the current outgoing headers. All header names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related http module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns if the header identified by is currently set in the outgoing headers. The header name matching is case-insensitive. Boolean (read-only). True if headers were sent, false otherwise. When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true. This should only be disabled for testing; HTTP requires the Date header in responses. Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. Therefore, may return non-string values. However, the non-string values will be converted to strings for network transmission. The same response object is returned to the caller, to enable call chaining. Attempting to set a header field name or value that contains invalid characters will result in a being thrown. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence. If method is called and this method has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use instead of . Sets the Socket's timeout value to . If a callback is provided, then it is added as a listener on the event on the response object. If no listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If a handler is assigned to the request, the response, or the server's events, timed out sockets must be handled explicitly. Reference to the underlying socket. Usually users will not want to access this property. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. After , the property is nulled. http ; server = http. ( { ip = res. . ; port = res. . ; res. ( `Your IP address is and your source port is .` ); }). ( ); http = ( ); server = http. ( { ip = res. . ; port = res. . ; res. ( `Your IP address is and your source port is .` ); }). ( ); This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket>. When using implicit headers (not calling explicitly), this property controls the status code that will be sent to the client when the headers get flushed. After response header was sent to the client, this property indicates the status code which was sent out. When using implicit headers (not calling explicitly), this property controls the status message that will be sent to the client when the headers get flushed. If this is left as then the standard message for the status code will be used. After response header was sent to the client, this property indicates the status message which was sent out. If set to , Node.js will check whether the header value and the size of the body, in bytes, are equal. Mismatching the header value will result in an being thrown, identified by . Is after has been called. This property does not indicate whether the data has been flushed, for this use instead. Is if all data has been flushed to the underlying system, immediately before the event is emitted. The parameter can now be a . If this method is called and has not been called, it will switch to implicit header mode and flush the implicit headers. This sends a chunk of the response body. This method may be called multiple times to provide successive parts of the body. If is set to true in then writing to the body is not allowed when the request method or response status do not support content. If an attempt is made to write to the body for a HEAD request or as part of a or response, a synchronous with the code is thrown. can be a string or a buffer. If is a string, the second parameter specifies how to encode it into a byte stream. will be called when this chunk of data is flushed. This is the raw HTTP body and has nothing to do with higher-level multi-part body encodings that may be used. The first time is called, it will send the buffered header information and the first chunk of the body to the client. The second time is called, Node.js assumes data will be streamed, and sends the new data separately. That is, the response is buffered up to the first chunk of the body. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in user memory. will be emitted when the buffer is free again. Sends an HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent. See the event on . Allow passing hints as an object. Sends an HTTP/1.1 103 Early Hints message to the client with a Link header, indicating that the user agent can preload/preconnect the linked resources. The is an object containing the values of headers to be sent with early hints message. The optional argument will be called when the response message has been written. Allow passing headers as an array. Return from to allow chaining with . A is thrown if is not a number in the range . Sends a response header to the request. The status code is a 3-digit HTTP status code, like . The last argument, , are the response headers. Optionally one can give a human-readable as the second argument. may be an where the keys and values are in the same list. It is not a list of tuples. So, the even-numbered offsets are key values, and the odd-numbered offsets are the associated values. The array is in the same format as . Returns a reference to the , so that calls can be chained. This method must only be called once on a message and it must be called before is called. If or are called before calling this, the implicit/mutable headers will be calculated and call this function. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence. If this method is called and has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use instead. is read in bytes, not characters. Use to determine the length of the body in bytes. Node.js will check whether and the length of the body which has been transmitted are equal or not. Attempting to set a header field name or value that contains invalid characters will result in a [ ][] being thrown. Sends a HTTP/1.1 102 Processing message to the client, indicating that the request body should be sent.\n\nThe value returns after the incoming data is consumed. The value mirrors that of the socket. An object is created by or and passed as the first argument to the and event respectively. It may be used to access response status, headers, and data. Different from its value which is a subclass of <stream.Duplex>, the itself extends <stream.Readable> and is created separately to parse and emit the incoming HTTP headers and payload, as the underlying socket may be reused multiple times in case of keep-alive. Emitted when the request has been aborted. The close event is now emitted when the request has been completed and not when the underlying socket is closed. Emitted when the request has been completed. The property will be if the request has been aborted. The property will be if a complete HTTP message has been received and successfully parsed. This property is particularly useful as a means of determining if a client or server fully transmitted a message before a connection was terminated: req = http. ({ : , : , : , }, { res. (); res. ( , { (!res. ) . ( 'The connection was terminated while the message was still being sent' ); }); }); The function returns for consistency with other Readable streams. Calls on the socket that received the . If is provided, an event is emitted on the socket and is passed as an argument to any listeners on the event. The option in the and functions ensures that duplicate headers are not discarded, but rather combined using a comma separator, in accordance with RFC 9110 Section 5.3. is now lazily computed using an accessor property on the prototype and is no longer enumerable. Key-value pairs of header names and values. Header names are lower-cased. Duplicates in raw headers are handled in the following ways, depending on the header name:\n• Duplicates of , , , , , , , , , , , , , , , , , or are discarded. To allow duplicate values of the headers listed above to be joined, use the option in and . See RFC 9110 Section 5.3 for more information.\n• is always an array. Duplicates are added to the array.\n• For duplicate headers, the values are joined together with .\n• For all other headers, the values are joined together with . Similar to , but there is no join logic and the values are always arrays of strings, even for headers received just once. In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either or . Also is the first integer and is the second. Only valid for request obtained from . The request method as a string. Read only. Examples: , . The raw request/response headers list exactly as they were received. The keys and values are in the same list. It is not a list of tuples. So, the even-numbered offsets are key values, and the odd-numbered offsets are the associated values. Header names are not lowercased, and duplicates are not merged. The raw request/response trailer keys and values exactly as they were received. Only populated at the event. The object associated with the connection. With HTTPS support, use to obtain the client's authentication details. This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket> or internally nulled. Only valid for response obtained from . Only valid for response obtained from . The request/response trailers object. Only populated at the event. Similar to , but there is no join logic and the values are always arrays of strings, even for headers received just once. Only populated at the event. Only valid for request obtained from . Request URL string. This contains only the URL that is present in the actual HTTP request. Take the following request: To parse the URL into its parts: When is and is undefined: Ensure that you set to the server's host name, or consider replacing this part entirely. If using , ensure proper validation is used, as clients may specify a custom header.\n\nThis class serves as the parent class of and . It is an abstract outgoing message from the perspective of the participants of an HTTP transaction. Emitted when the buffer of the message is free again. Emitted when the transmission is finished successfully. Emitted after is called. When the event is emitted, all data has been processed but not necessarily completely flushed. Adds HTTP trailers (headers but at the end of the message) to the message. Trailers will only be emitted if the message is chunked encoded. If not, the trailers will be silently discarded. HTTP requires the header to be sent to emit trailers, with a list of header field names in its value, e.g. Attempting to set a header field name or value that contains invalid characters will result in a being thrown. Append a single header value to the header object. If the value is an array, this is equivalent to calling this method multiple times. If there were no previous values for the header, this is equivalent to calling . Depending of the value of when the client request or the server were created, this will end up in the header being sent multiple times or a single time with values joined using .\n• <Error> Optional, an error to emit with event Destroys the message. Once a socket is associated with the message and is connected, that socket will be destroyed as well. The parameter can now be a . Finishes the outgoing message. If any parts of the body are unsent, it will flush them to the underlying system. If the message is chunked, it will send the terminating chunk , and send the trailers (if any). If is specified, it is equivalent to calling , followed by . If is provided, it will be called when the message is finished (equivalent to a listener of the event). For efficiency reason, Node.js normally buffers the message headers until is called or the first chunk of message data is written. It then tries to pack the headers and data into a single TCP packet. It is usually desired (it saves a TCP round-trip), but not when the first data is not sent until possibly much later. bypasses the optimization and kickstarts the message. Gets the value of the HTTP header with the given name. If that header is not set, the returned value will be . Returns an array containing the unique names of the current outgoing headers. All names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related HTTP module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns if the header identified by is currently set in the outgoing headers. The header name is case-insensitive. Read-only. if the headers were sent, otherwise . Overrides the method inherited from the legacy class which is the parent class of . Calling this method will throw an because is a write-only stream. Removes a header that is queued for implicit sending. Sets a single header value. If the header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings to send multiple headers with the same name. Sets multiple header values for implicit headers. must be an instance of or , if a header already exists in the to-be-sent headers, its value will be replaced. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence.\n• <Function> Optional function to be called when a timeout occurs. Same as binding to the event. Once a socket is associated with the message and is connected, will be called with as the first parameter. Reference to the underlying socket. Usually, users will not want to access this property. After calling , this property will be nulled. The number of times has been called. Is if has been called. This property does not indicate whether the data has been flushed. For that purpose, use instead. Is if all data has been flushed to the underlying system. The of the underlying socket if assigned. Otherwise, the default buffer level when starts returning false ( ). The parameter can now be a . Sends a chunk of the body. This method can be called multiple times. The argument is only relevant when is a string. Defaults to . The argument is optional and will be called when this chunk of data is flushed. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in the user memory. The event will be emitted when the buffer is free again.\n\nWhen using a object parsed username and password will now be properly URI decoded. It is possible to abort a request with an AbortSignal. The option is supported now. The option is supported now. The parameter can now be passed along with a separate object. The parameter can be a WHATWG object.\n• <Object>\n• <http.Agent> | <boolean> Controls behavior. Possible values:\n• (default): use for this host and port.\n• object: explicitly use the passed in .\n• : causes a new with default values to be used.\n• <Function> A function that produces a socket/stream to use for the request when the option is not used. This can be used to avoid creating a custom class just to override the default function. See for more details. Any stream is a valid return value.\n• <number> Default port for the protocol. Default: if an is used, else .\n• <number> IP address family to use when resolving or . Valid values are or . When unspecified, both IP v4 and v6 will be used.\n• <string> A domain name or IP address of the server to issue the request to. Default: .\n• <string> Alias for . To support , will be used if both and are specified.\n• <boolean> If set to , it will use a HTTP parser with leniency flags enabled. Using the insecure parser should be avoided. See for more information. Default:\n• <boolean> It joins the field line values of multiple headers in a request with instead of discarding the duplicates. See for more information. Default: .\n• <number> Optionally overrides the value of (the maximum length of response headers in bytes) for responses received from the server. Default: 16384 (16 KiB).\n• <string> Request path. Should include query string if any. E.G. . An exception is thrown when the request path contains illegal characters. Currently, only spaces are rejected but that may change in the future. Default: .\n• <number> Port of remote server. Default: if set, else .\n• <boolean>: Specifies whether or not to automatically add default headers such as , , , and . If set to then all necessary headers must be added manually. Defaults to .\n• <boolean>: Specifies whether or not to automatically add the header. If provided, this overrides . Defaults to .\n• <AbortSignal>: An AbortSignal that may be used to abort an ongoing request.\n• <string> Unix domain socket. Cannot be used if one of or is specified, as those specify a TCP Socket.\n• <number>: A number specifying the socket timeout in milliseconds. This will set the timeout before the socket is connected.\n• <Array> A list of request headers that should be sent only once. If the header's value is an array, the items will be joined using . in are also supported. Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests. can be a string or a object. If is a string, it is automatically parsed with . If it is a object, it will be automatically converted to an ordinary object. If both and are specified, the objects are merged, with the properties taking precedence. The optional parameter will be added as a one-time listener for the event. returns an instance of the class. The instance is a writable stream. If one needs to upload a file with a POST request, then write to the object. http ; { } ; postData = . ({ : , }); options = { : , : , : , : , : { : , : . (postData), }, }; req = http. (options, { . ( ); . ( ); res. ( ); res. ( , { . ( ); }); res. ( , { . ( 'No more data in response.' ); }); }); req. ( , { . ( ); }); req. (postData); req. (); http = ( ); postData = . ({ : , }); options = { : , : , : , : , : { : , : . (postData), }, }; req = http. (options, { . ( ); . ( ); res. ( ); res. ( , { . ( ); }); res. ( , { . ( 'No more data in response.' ); }); }); req. ( , { . ( ); }); req. (postData); req. (); In the example was called. With one must always call to signify the end of the request - even if there is no data being written to the request body. If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an event is emitted on the returned request object. As with all events, if no listeners are registered the error will be thrown. There are a few special headers that should be noted.\n• Sending a 'Connection: keep-alive' will notify Node.js that the connection to the server should be persisted until the next request.\n• Sending an 'Expect' header will immediately send the request headers. Usually, when sending 'Expect: 100-continue', both a timeout and a listener for the event should be set. See RFC 2616 Section 8.2.3 for more information.\n• Sending an Authorization header will override using the option to compute basic authentication. Example using a as : In a successful request, the following events will be emitted in the following order:\n• \n• any number of times, on the object ( will not be emitted at all if the response body is empty, for instance, in most redirects) In the case of a connection error, the following events will be emitted: In the case of a premature connection close before the response is received, the following events will be emitted in the following order:\n• with an error with message and code In the case of a premature connection close after the response is received, the following events will be emitted in the following order:\n• \n• any number of times, on the object\n• on the object with an error with message and code If is called before a socket is assigned, the following events will be emitted in the following order:\n• with an error with message and code , or the error with which was called If is called before the connection succeeds, the following events will be emitted in the following order:\n• with an error with message and code , or the error with which was called If is called after the response is received, the following events will be emitted in the following order:\n• \n• any number of times, on the object\n• on the object with an error with message and code , or the error with which was called If is called before a socket is assigned, the following events will be emitted in the following order: If is called before the connection succeeds, the following events will be emitted in the following order:\n• with an error with message and code If is called after the response is received, the following events will be emitted in the following order:\n• \n• any number of times, on the object\n• on the object with an error with message and code . Setting the option or using the function will not abort the request or do anything besides add a event. Passing an and then calling on the corresponding will behave the same way as calling on the request. Specifically, the event will be emitted with an error with the message , the code and the , if one was provided."
    },
    {
        "link": "https://medium.com/@datajournal/proxies-with-node-js-76a186140af5",
        "document": "In this guide, I’ll walk you through the basics of using proxies with Node.js. We’ll go over the different types of proxies, how they work, and practical ways to use them with popular Node.js libraries. By the end, you’ll have a clear understanding of how to set up proxies in your Node.js projects and why they can be useful. Whether you’re just starting out or looking to optimize your setup, this guide will make proxies easy to grasp.\n\nA proxy server is an intermediary server that receives requests from a client and forwards them to the target server. In return, it forwards the response back to the client. This setup allows the proxy server to hide the client’s IP address and provide anonymity, security, or content filtering.\n\nThere are multiple types of proxies, but in this article, we will focus on the popular forward proxies, which are mostly used for web scraping:\n• Datacenter Proxies: These are hosted in data centers and offer fast, cost-effective solutions for scraping large amounts of data but are easier to detect.\n• ISP Proxies: These use IPs provided by ISPs and offer a blend of speed and legitimacy, making them harder to block than datacenter proxies.\n• Mobile Proxies: These use IPs assigned to mobile devices, providing high anonymity and rotation, making them excellent for bypassing strict anti-bot measures.\n• Residential Proxies: These are tied to real user devices and provide high anonymity, making them ideal for scraping data from websites with strict geo-blocking and security filters.\n\nWe’ll focus on these forward proxies because they are essential for web scraping and bypassing restrictions.\n\nWhy Use Proxies with Node.js?\n\nProxies can offer several advantages for Node.js applications, such as:\n• Bypassing Geo-Restrictions: You can access content or APIs that are restricted by geography.\n• Load Balancing and Traffic Distribution: Reverse proxies help distribute traffic to different server instances, improving the reliability and performance of your app.\n• Caching: Proxies can cache data to reduce the number of times the same content is fetched from the origin server.\n• Enhanced Security: Proxies can act as a security layer by blocking malicious requests or attacks before they reach your server.\n\nTo implement proxies in Node.js, you can use libraries like http-proxy and node-fetch. Let’s start by using http-proxy, a popular proxy library in the Node.js ecosystem.\n\nStart by installing the http-proxy package in your project directory.\n\nAfter installing the package, you can create a simple proxy server. Here’s an example of a forward proxy:\n\nIn this example, the proxy forwards all incoming requests to http://example.com. If you access http://localhost:3000, the request will be forwarded to the target site.\n\nProxies often encounter errors, like connection issues or invalid requests. You can handle these by listening to the error event.\n\nThis ensures that when something goes wrong with the proxy, the client receives a meaningful response.\n\nTo set up a reverse proxy (one that directs traffic to multiple servers), you can modify the code as follows:\n\nThe node-fetch library is commonly used for making HTTP requests in Node.js applications. You can easily add proxy support using http-proxy-agent for HTTP proxies or https-proxy-agent for HTTPS proxies.\n\nHere’s how to configure node-fetch with a proxy:\n\nIn this example, all requests made using node-fetch are routed through the specified proxy server (http://your-proxy-server:8080).\n\nProxies are not just useful for small projects. Large-scale Node.js applications, especially microservices-based architectures, frequently use reverse proxies for routing and load balancing. Nginx and HAProxy are common tools used as reverse proxies for Node.js apps.\n• Manage Traffic: Forward incoming requests to different microservices based on routes.\n• Improve Security: Hide the actual server IP addresses and implement security measures before traffic reaches the internal network.\n• Enable Scalability: Distribute requests across multiple instances to ensure your services are highly available.\n\nIn some cases, proxy servers require authentication. You can add authentication headers to your proxy requests using Node.js.\n\nThis sends an authorization header containing the base64-encoded credentials (username:password), enabling you to access proxies requiring authentication.\n• Bright Data\n\nBright Data offers top-tier proxy services, including datacenter, residential, and mobile proxies, ideal for Node.js applications needing high scalability, IP rotation, and advanced CAPTCHA solving. Its vast network ensures reliability and compliance.\n• ScraperAPI\n\nKnown for its ease of integration with Node.js, ScraperAPI provides automatic IP rotation, CAPTCHA solving, and anti-bot protection, making it perfect for large-scale web scraping.\n• Oxylabs\n\nOxylabs offers robust proxy services, including datacenter and residential proxies. It’s highly secure and works well with Node.js for scraping and API-driven projects.\n• NetNut\n\nNetNut offers residential proxies that are reliable and fast, making them an excellent choice for Node.js users who need consistent performance and minimal downtime for scraping or API tasks.\n• Smartproxy\n\nSmartproxy provides affordable residential and datacenter proxies, offering a wide range of IPs for web scraping, with a straightforward setup process for Node.js users.\n\nProxies are essential tools when building with Node.js. Whether you need to bypass geo-restrictions, balance traffic, or add security layers to your app, proxies can make a big difference. With libraries like http-proxy and node-fetch, setting up proxies is straightforward. They give you the flexibility to add forward or reverse proxies depending on what your project needs.\n\nNo matter if you’re building a small Node.js API or working on a large microservice system, proxies will help you improve performance, strengthen security, and manage traffic more efficiently. When you understand how to use them effectively, your applications become more reliable and scalable.\n\nGot questions? Let me know in the comments!"
    },
    {
        "link": "https://npmjs.com/package/http-proxy-middleware",
        "document": "Node.js proxying made simple. Configure proxy middleware with ease for connect, express, next.js and many more.\n\nThis page is showing documentation for version v3.x.x (release notes)\n\nSee MIGRATION.md for details on how to migrate from v2.x.x to v3.x.x\n\nIf you're looking for older documentation. Go to:\n\n💡 Tip: Set the option to for name-based virtual hosted sites.\n\nAll options can be used, along with some extra options.\n\nAn example with server.\n\nIf you want to use the server's parameter to match requests. Use option to further include/exclude requests which you want to proxy.\n\nNarrow down which requests should be proxied. The used for filtering is the pathname. In Express, this is the relative to the mount-point of the proxy.\n• \n• - matches any path, all requests will be proxied when is not configured.\n• For fine-grained control you can use wildcard matching. Glob pattern matching is done by micromatch. Visit micromatch or glob for more globbing examples.\n• matches any path, all requests will be proxied.\n• matches any path which ends with\n• matches requests ending with in the path of Note: In multiple path matching, you cannot use string paths and wildcard paths together.\n• For full control you can provide a custom function to determine which requests should be proxied or not.\n\nRewrite target's url path. Object-keys will be used as RegExp to match paths.\n\nIf you're not satisfied with the pre-configured plugins, you can eject them by configuring .\n\nNOTE: register your own error handlers to prevent server from crashing.\n\nConfigure a logger to output information from http-proxy-middleware: ie. , , , , , etc...\n\nOnly , , are used internally for compatibility across different loggers.\n\nIf you use , make sure to enable interpolation: https://github.com/winstonjs/winston#string-interpolation\n\nSee also logger recipes (recipes/logger.md) for more details.\n\nSubscribe to http-proxy events with the option:\n• : 'Something went wrong. And we are reporting a custom error message.'\n• // listen for messages coming FROM the target here\n\nThe following options are provided by the underlying http-proxy library.\n• option.target: url string to be parsed with the url module\n• option.forward: url string to be parsed with the url module\n• option.agent: object to be passed to http(s).request (see Node's https agent and http agent objects)\n• option.ssl: object to be passed to https.createServer()\n• option.ws: true/false: if you want to proxy websockets\n• option.secure: true/false, if you want to verify the SSL Certs\n• option.toProxy: true/false, passes the absolute URL as the (useful for proxying to proxies)\n• option.prependPath: true/false, Default: true - specify whether you want to prepend the target's path to the proxy path\n• option.ignorePath: true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).\n• option.changeOrigin: true/false, Default: false - changes the origin of the host header to the target URL\n• option.preserveHeaderKeyCase: true/false, Default: false - specify whether you want to keep letter case of response header key\n• option.autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false.\n• option.protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.\n• \n• String: new domain, for example . To remove the domain, use .\n• Object: mapping of domains to new domains, use to match all domains.\n\n For example keep one domain unchanged, rewrite one domain and remove other domains:\n• \n• String: new path, for example . To remove the path, use . To set path to root use .\n• Object: mapping of paths to new paths, use to match all paths. For example, to keep one path unchanged, rewrite one path and remove other paths:\n• option.proxyTimeout: timeout (in millis) when proxy receives no response from target\n• option.followRedirects: true/false, Default: false - specify whether you want to follow redirects\n• option.selfHandleResponse true/false, if set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the event\n• option.buffer: stream of data to send as the request body. Maybe you have some middleware that consumes the request stream before proxying it on e.g. If you read the body of a request into a field called 'req.rawbody' you could restream this field in the buffer option:\n\nIn the previous WebSocket examples, http-proxy-middleware relies on a initial http request in order to listen to the http event. If you need to proxy WebSockets without the initial http request, you can subscribe to the server's http event manually.\n\nIntercept requests from downstream by defining in .\n\nCurrently the only pre-provided request interceptor is , which is used to fix proxied POST requests when is applied before this middleware.\n\nIntercept responses from upstream with . (Make sure to set )\n\nResponses which are compressed with , and will be decompressed automatically. The response will be returned as (docs) which you can manipulate.\n\nWith , response manipulation is not limited to text responses (html/css/js, etc...); image manipulation will be possible too. (example)\n\nCheck out interception recipes for more examples.\n\nNode.js 17+ no longer prefers IPv4 over IPv6 for DNS lookups. E.g. It's not guaranteed that will be resolved to – it might just as well be (or some other IP address).\n\nIf your target server only accepts IPv4 connections, trying to proxy to will fail if resolved to (IPv6).\n• Change the target server to (also) accept IPv6 connections.\n• Add this flag when running : . (Not recommended.)\n\nSee project for more options.\n\nView and play around with working examples.\n\nView the recipes for common use cases.\n\nis compatible with the following servers:\n\nSample implementations can be found in the server recipes."
    },
    {
        "link": "https://github.com/http-party/node-http-proxy/blob/master/README.md",
        "document": "is an HTTP programmable proxying library that supports websockets. It is suitable for implementing components such as reverse proxies and load balancers.\n\nA new proxy is created by calling and passing an object as argument (valid properties are available here)\n\n†Unless listen(..) is invoked on the object, this does not create a webserver. See below.\n\nAn object will be returned with four methods:\n• listen (a function that wraps the object in a webserver, for your convenience)\n• close (a function that closes the inner webserver and stops listening on given port)\n\nIt is then possible to proxy requests by calling these functions\n\nErrors can be listened on either using the Event Emitter API\n\nor using the callback API\n\nWhen a request is proxied it follows two different pipelines (available here) which apply transformations to both the and object. The first pipeline (incoming) is responsible for the creation and manipulation of the stream that connects your client to the target. The second pipeline (outgoing) is responsible for the creation and manipulation of the stream that, from your target, returns data to the client.\n\n†Invoking listen(..) triggers the creation of a web server. Otherwise, just the proxy instance is created.\n\nThis example shows how you can proxy a request using your own HTTP server and also you can put your own logic to handle the request.\n\nThis example shows how you can proxy a request using your own HTTP server that modifies the outgoing proxy request by adding a special header.\n\n// To modify the proxy connection before data is sent, you can listen // for the 'proxyReq' event. When the event is fired, you will receive // http.ServerResponse res, Object options). This mechanism is useful when // you need to modify the proxy request before the proxy connection // is made to the target. // You can define here your custom logic to handle the request // and then proxy the request. :\n\nSometimes when you have received a HTML/XML document from the server of origin you would like to modify it before forwarding it on.\n\nHarmon allows you to do this in a streaming style so as to keep the pressure on the proxy to a minimum.\n\nYou can activate the validation of a secure SSL certificate to the target connection (avoid self-signed certs), just set in the options.\n\nYou can activate the websocket support for the proxy using in the options.\n\nAlso you can proxy the websocket requests just calling the method.\n• target: url string to be parsed with the url module\n• forward: url string to be parsed with the url module\n• agent: object to be passed to http(s).request (see Node's https agent and http agent objects)\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• secure: true/false, if you want to verify the SSL Certs\n• toProxy: true/false, passes the absolute URL as the (useful for proxying to proxies)\n• prependPath: true/false, Default: true - specify whether you want to prepend the target's path to the proxy path\n• ignorePath: true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).\n• changeOrigin: true/false, Default: false - changes the origin of the host header to the target URL\n• preserveHeaderKeyCase: true/false, Default: false - specify whether you want to keep letter case of response header key\n• autoRewrite: rewrites the location host/port on (201/301/302/307/308) redirects based on requested host/port. Default: false.\n• protocolRewrite: rewrites the location protocol on (201/301/302/307/308) redirects to 'http' or 'https'. Default: null.\n• \n• String: new domain, for example . To remove the domain, use .\n• Object: mapping of domains to new domains, use to match all domains. For example keep one domain unchanged, rewrite one domain and remove other domains:\n• \n• String: new path, for example . To remove the path, use . To set path to root use .\n• Object: mapping of paths to new paths, use to match all paths. For example, to keep one path unchanged, rewrite one path and remove other paths:\n• headers: object with extra headers to be added to target requests.\n• followRedirects: true/false, Default: false - specify whether you want to follow redirects\n• selfHandleResponse true/false, if set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the event\n• buffer: stream of data to send as the request body. Maybe you have some middleware that consumes the request stream before proxying it on e.g. If you read the body of a request into a field called 'req.rawbody' you could restream this field in the buffer option: 'use strict'; const streamify = require('stream-array'); const HttpProxy = require('http-proxy'); const proxy = new HttpProxy(); module.exports = (req, res, next) => { proxy.web(req, res, { target: 'http://localhost:4003/', buffer: streamify(req.rawBody) }, next); };\n\nNOTE: and are optional. and cannot both be missing\n\nIf you are using the method, the following options are also applicable:\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• : The error event is emitted if the request to the target fail. We do not do any error handling of messages passed between client and proxy, and messages passed between proxy and target, so it is recommended that you listen on errors and handle them.\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"web\" connections\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"websocket\" connections\n• : This event is emitted if the request to the target got a response.\n• : This event is emitted once the proxy websocket was created and piped into the target websocket.\n• : This event is emitted once the proxy websocket was closed.\n• When testing or running server within another program it may be necessary to close the proxy.\n• This will stop the proxy from accepting new connections.\n\nIf you want to handle your own response after receiving the , you can do so with . As you can see below, if you use this option, you are able to intercept and read the but you must also make sure to reply to the itself otherwise the original client will never receive any data.\n\nA proxy table API is available through this add-on module, which lets you define a set of rules to translate matching routes to target routes that the reverse proxy will talk to.\n• If you can't find anything, open an issue\n• If you feel comfortable about fixing the issue, fork the repo\n• Commit to your local branch (which must be different from )\n• Submit your Pull Request (be sure to include tests and update documentation)"
    },
    {
        "link": "https://medium.com/@datajournal/proxies-with-node-js-76a186140af5",
        "document": "In this guide, I’ll walk you through the basics of using proxies with Node.js. We’ll go over the different types of proxies, how they work, and practical ways to use them with popular Node.js libraries. By the end, you’ll have a clear understanding of how to set up proxies in your Node.js projects and why they can be useful. Whether you’re just starting out or looking to optimize your setup, this guide will make proxies easy to grasp.\n\nA proxy server is an intermediary server that receives requests from a client and forwards them to the target server. In return, it forwards the response back to the client. This setup allows the proxy server to hide the client’s IP address and provide anonymity, security, or content filtering.\n\nThere are multiple types of proxies, but in this article, we will focus on the popular forward proxies, which are mostly used for web scraping:\n• Datacenter Proxies: These are hosted in data centers and offer fast, cost-effective solutions for scraping large amounts of data but are easier to detect.\n• ISP Proxies: These use IPs provided by ISPs and offer a blend of speed and legitimacy, making them harder to block than datacenter proxies.\n• Mobile Proxies: These use IPs assigned to mobile devices, providing high anonymity and rotation, making them excellent for bypassing strict anti-bot measures.\n• Residential Proxies: These are tied to real user devices and provide high anonymity, making them ideal for scraping data from websites with strict geo-blocking and security filters.\n\nWe’ll focus on these forward proxies because they are essential for web scraping and bypassing restrictions.\n\nWhy Use Proxies with Node.js?\n\nProxies can offer several advantages for Node.js applications, such as:\n• Bypassing Geo-Restrictions: You can access content or APIs that are restricted by geography.\n• Load Balancing and Traffic Distribution: Reverse proxies help distribute traffic to different server instances, improving the reliability and performance of your app.\n• Caching: Proxies can cache data to reduce the number of times the same content is fetched from the origin server.\n• Enhanced Security: Proxies can act as a security layer by blocking malicious requests or attacks before they reach your server.\n\nTo implement proxies in Node.js, you can use libraries like http-proxy and node-fetch. Let’s start by using http-proxy, a popular proxy library in the Node.js ecosystem.\n\nStart by installing the http-proxy package in your project directory.\n\nAfter installing the package, you can create a simple proxy server. Here’s an example of a forward proxy:\n\nIn this example, the proxy forwards all incoming requests to http://example.com. If you access http://localhost:3000, the request will be forwarded to the target site.\n\nProxies often encounter errors, like connection issues or invalid requests. You can handle these by listening to the error event.\n\nThis ensures that when something goes wrong with the proxy, the client receives a meaningful response.\n\nTo set up a reverse proxy (one that directs traffic to multiple servers), you can modify the code as follows:\n\nThe node-fetch library is commonly used for making HTTP requests in Node.js applications. You can easily add proxy support using http-proxy-agent for HTTP proxies or https-proxy-agent for HTTPS proxies.\n\nHere’s how to configure node-fetch with a proxy:\n\nIn this example, all requests made using node-fetch are routed through the specified proxy server (http://your-proxy-server:8080).\n\nProxies are not just useful for small projects. Large-scale Node.js applications, especially microservices-based architectures, frequently use reverse proxies for routing and load balancing. Nginx and HAProxy are common tools used as reverse proxies for Node.js apps.\n• Manage Traffic: Forward incoming requests to different microservices based on routes.\n• Improve Security: Hide the actual server IP addresses and implement security measures before traffic reaches the internal network.\n• Enable Scalability: Distribute requests across multiple instances to ensure your services are highly available.\n\nIn some cases, proxy servers require authentication. You can add authentication headers to your proxy requests using Node.js.\n\nThis sends an authorization header containing the base64-encoded credentials (username:password), enabling you to access proxies requiring authentication.\n• Bright Data\n\nBright Data offers top-tier proxy services, including datacenter, residential, and mobile proxies, ideal for Node.js applications needing high scalability, IP rotation, and advanced CAPTCHA solving. Its vast network ensures reliability and compliance.\n• ScraperAPI\n\nKnown for its ease of integration with Node.js, ScraperAPI provides automatic IP rotation, CAPTCHA solving, and anti-bot protection, making it perfect for large-scale web scraping.\n• Oxylabs\n\nOxylabs offers robust proxy services, including datacenter and residential proxies. It’s highly secure and works well with Node.js for scraping and API-driven projects.\n• NetNut\n\nNetNut offers residential proxies that are reliable and fast, making them an excellent choice for Node.js users who need consistent performance and minimal downtime for scraping or API tasks.\n• Smartproxy\n\nSmartproxy provides affordable residential and datacenter proxies, offering a wide range of IPs for web scraping, with a straightforward setup process for Node.js users.\n\nProxies are essential tools when building with Node.js. Whether you need to bypass geo-restrictions, balance traffic, or add security layers to your app, proxies can make a big difference. With libraries like http-proxy and node-fetch, setting up proxies is straightforward. They give you the flexibility to add forward or reverse proxies depending on what your project needs.\n\nNo matter if you’re building a small Node.js API or working on a large microservice system, proxies will help you improve performance, strengthen security, and manage traffic more efficiently. When you understand how to use them effectively, your applications become more reliable and scalable.\n\nGot questions? Let me know in the comments!"
    },
    {
        "link": "https://stackoverflow.com/questions/20351637/how-to-create-a-simple-http-proxy-in-node-js",
        "document": "I'm trying to create a proxy server to pass requests from a client to a third party website (say google). My proxy just needs to mirror incoming requests to their corresponding path on the target site, so if my client's requested url is:\n\nThe following resource should be served:\n\nHere is what I came up with:\n\nIt works well with html pages, but for other types of files, it just returns a blank page or some error message from target site (which varies in different sites)."
    },
    {
        "link": "https://stackoverflow.com/questions/3862813/how-can-i-use-an-http-proxy-with-node-js-http-client",
        "document": "I want to make an outgoing HTTP call from node.js, using the standard . But I cannot reach the remote server directly from my network and need to go through a proxy. How do I tell node.js to use the proxy?"
    },
    {
        "link": "https://github.com/http-party/node-http-proxy",
        "document": "is an HTTP programmable proxying library that supports websockets. It is suitable for implementing components such as reverse proxies and load balancers.\n\nA new proxy is created by calling and passing an object as argument (valid properties are available here)\n\n†Unless listen(..) is invoked on the object, this does not create a webserver. See below.\n\nAn object will be returned with four methods:\n• listen (a function that wraps the object in a webserver, for your convenience)\n• close (a function that closes the inner webserver and stops listening on given port)\n\nIt is then possible to proxy requests by calling these functions\n\nErrors can be listened on either using the Event Emitter API\n\nor using the callback API\n\nWhen a request is proxied it follows two different pipelines (available here) which apply transformations to both the and object. The first pipeline (incoming) is responsible for the creation and manipulation of the stream that connects your client to the target. The second pipeline (outgoing) is responsible for the creation and manipulation of the stream that, from your target, returns data to the client.\n\n†Invoking listen(..) triggers the creation of a web server. Otherwise, just the proxy instance is created.\n\nThis example shows how you can proxy a request using your own HTTP server and also you can put your own logic to handle the request.\n\nThis example shows how you can proxy a request using your own HTTP server that modifies the outgoing proxy request by adding a special header.\n\n// To modify the proxy connection before data is sent, you can listen // for the 'proxyReq' event. When the event is fired, you will receive // http.ServerResponse res, Object options). This mechanism is useful when // you need to modify the proxy request before the proxy connection // is made to the target. // You can define here your custom logic to handle the request // and then proxy the request. :\n\nSometimes when you have received a HTML/XML document from the server of origin you would like to modify it before forwarding it on.\n\nHarmon allows you to do this in a streaming style so as to keep the pressure on the proxy to a minimum.\n\nYou can activate the validation of a secure SSL certificate to the target connection (avoid self-signed certs), just set in the options.\n\nYou can activate the websocket support for the proxy using in the options.\n\nAlso you can proxy the websocket requests just calling the method.\n• target: url string to be parsed with the url module\n• forward: url string to be parsed with the url module\n• agent: object to be passed to http(s).request (see Node's https agent and http agent objects)\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• secure: true/false, if you want to verify the SSL Certs\n• toProxy: true/false, passes the absolute URL as the (useful for proxying to proxies)\n• prependPath: true/false, Default: true - specify whether you want to prepend the target's path to the proxy path\n• ignorePath: true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).\n• changeOrigin: true/false, Default: false - changes the origin of the host header to the target URL\n• preserveHeaderKeyCase: true/false, Default: false - specify whether you want to keep letter case of response header key\n• autoRewrite: rewrites the location host/port on (201/301/302/307/308) redirects based on requested host/port. Default: false.\n• protocolRewrite: rewrites the location protocol on (201/301/302/307/308) redirects to 'http' or 'https'. Default: null.\n• \n• String: new domain, for example . To remove the domain, use .\n• Object: mapping of domains to new domains, use to match all domains. For example keep one domain unchanged, rewrite one domain and remove other domains:\n• \n• String: new path, for example . To remove the path, use . To set path to root use .\n• Object: mapping of paths to new paths, use to match all paths. For example, to keep one path unchanged, rewrite one path and remove other paths:\n• headers: object with extra headers to be added to target requests.\n• followRedirects: true/false, Default: false - specify whether you want to follow redirects\n• selfHandleResponse true/false, if set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the event\n• buffer: stream of data to send as the request body. Maybe you have some middleware that consumes the request stream before proxying it on e.g. If you read the body of a request into a field called 'req.rawbody' you could restream this field in the buffer option: 'use strict'; const streamify = require('stream-array'); const HttpProxy = require('http-proxy'); const proxy = new HttpProxy(); module.exports = (req, res, next) => { proxy.web(req, res, { target: 'http://localhost:4003/', buffer: streamify(req.rawBody) }, next); };\n\nNOTE: and are optional. and cannot both be missing\n\nIf you are using the method, the following options are also applicable:\n• ssl: object to be passed to https.createServer()\n• ws: true/false, if you want to proxy websockets\n• : The error event is emitted if the request to the target fail. We do not do any error handling of messages passed between client and proxy, and messages passed between proxy and target, so it is recommended that you listen on errors and handle them.\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"web\" connections\n• : This event is emitted before the data is sent. It gives you a chance to alter the proxyReq request object. Applies to \"websocket\" connections\n• : This event is emitted if the request to the target got a response.\n• : This event is emitted once the proxy websocket was created and piped into the target websocket.\n• : This event is emitted once the proxy websocket was closed.\n• When testing or running server within another program it may be necessary to close the proxy.\n• This will stop the proxy from accepting new connections.\n\nIf you want to handle your own response after receiving the , you can do so with . As you can see below, if you use this option, you are able to intercept and read the but you must also make sure to reply to the itself otherwise the original client will never receive any data.\n\nA proxy table API is available through this add-on module, which lets you define a set of rules to translate matching routes to target routes that the reverse proxy will talk to.\n• If you can't find anything, open an issue\n• If you feel comfortable about fixing the issue, fork the repo\n• Commit to your local branch (which must be different from )\n• Submit your Pull Request (be sure to include tests and update documentation)"
    },
    {
        "link": "https://webshare.io/academy-article/node-js-proxy",
        "document": "A proxy server’s job is to be an intermediary between a client and a destination server. It basically handles requests on behalf of the client, keeping the operator's network private. In proxy-dependent Node.js applications, proxies are essential for managing network traffic, improving security, and bypassing network restrictions. Jump straight to your preferred method of choice:\n\nIf you do not have proxies, feel free to use Webshare’s 10 free proxies - sign up here.\n\nThis article will explore five most common methods for setting up proxies in Node.js, along with advanced configurations, to help developers optimize their applications for performance and scalability.\n\n5 common methods to set up a Proxy in Node.js\n\nBelow, we have listed five common methods for setting up proxies in Node.js, each suited for different use cases.\n\nThe http-proxy library is a Node.js module designed to create proxy servers for handling HTTP and HTTPS requests. Its lightweight design and reliable feature set make it a popular choice for implementing custom proxy solutions. By using http-proxy, developers can intercept and manipulate requests and responses to enable scenarios like load balancing, caching, or secure API access.\n\nFollow these steps to create an HTTP proxy server using http-proxy.\n\n2) Set up the server: Import the library and configure your proxy to route traffic through Webshare proxies.\n\n3) Run the server: Use a code snippet like the one below to start the proxy.\n\nHTTP proxies are most effective for the following.\n\nBy using http-proxy and Webshare proxies, you can implement a reliable, high-performance HTTP proxy server customized to your needs.\n\nThe SOCKS proxy is an intermediary at the transport layer level, which supports practically every form of network traffic, ranging from HTTP and HTTPS to FTP and more. While HTTP proxies only work with web traffic, SOCKS provides far greater flexibility and added anonymity that makes it highly suitable in implementations where safe data transfer, bypassing restrictions in firewalls, P2P handling and streaming are involved. Furthermore, they provide faster data transmission and fewer restrictions compared to HTTP proxies.\n\nTo begin setting up a SOCKS proxy, first install the socks library.\n\nNext, configure the proxy with SOCKS proxy details.\n\nNode-fetch is a library for Node.js applied in executing HTTP requests, with its interface rather similar to the Fetch browser API. It is often utilized for tasks such as API calls and web scraping. Using proxies with it increases its ability to bypass geo-restrictions, evade rate limits, and ensure anonymity.\n\nNow, to use proxies with node-fetch, you must integrate it with proxies like http-proxy-agent and socks-proxy-agent, depending on whether it's an HTTP or a socks proxy.\n\nNext, configure the proxy agent for HTTP or SOCKS proxies. Here’s an example using Webshare’s HTTP proxy.\n\nExpress.js is a popular Node.js framework for building web applications and APIs because it's flexible and easy to use. With the addition of the http-proxy-middleware library, Express.js can integrate proxy features like routing, logging, and load balancing. This setup allows you to forward requests through a proxy server while improving security, performance, and scalability.\n\nTo set up proxy middleware in an Express.js app, first install the necessary dependencies.\n\nNext, integrate the proxy middleware to route requests through a Webshare proxy.\n\nThis setup proxies requests to /api through Webshare to the target server. Common use cases include web scraping. Using this method, developers can build efficient and secure backend solutions.\n\nKoa.js is a minimalist Node.js framework designed for building web applications and APIs with increased flexibility. Unlike Express.js, it has a lightweight core that focuses on middleware, which improves performance and error handling with async/await. When paired with the koa-proxies library, Koa.js becomes a very useful tool for integrating proxy capabilities, ideal for scenarios such as API forwarding, web scraping, and load balancing.\n\nTo set up proxies in Koa.js, begin by installing the necessary dependencies.\n\nThis setup proxies any requests to /api through Webshare to the target server. Koa's lightweight design ensures low overhead and is therefore perfect for microservices, custom proxy features like logging and rate limiting, and high-performance web scraping.\n\nAdvanced proxy configurations can easily improve your Node.js application's performance, security, and efficiency. This section explores three essential techniques, proxy rotation, configuring request headers, and integrating caching.\n\nProxy rotation is a good technique for staying anonymous and keeping away from detection, especially when dealing with web scraping or frequent requests to other services. By rotating the proxies for each request, you avoid IP bans and anti-bot measures. Webshare.io offers proxy pools that make rotating proxies simple and efficient.\n\nProperly configured headers are important in order for your requests to seem more human-like and not to get your requests flagged as bots. Custom headers like User-Agent, Accept-Language, and Connection help simulate browser-like requests to make your proxy requests less detectable.\n\nCaching is a powerful method to improve performance and reduce the number of API calls. By storing previously fetched responses, you can significantly reduce the load on external servers and minimize API costs. Caching is particularly useful for data that doesn’t change often.\n\nYou can use these proxy server setups to optimize your Node.js apps for scalability, security, and performance.\n\nIn this article, we’ve explored various methods to set up proxies in Node.js, with libraries like http-proxy, socks, node-fetch, and frameworks such as Express.js and Koa.js. These methods offer flexibility for different use cases, from web scraping to handling API requests. Advanced configurations like proxy rotation, custom headers, and caching can further improve performance and security. Webshare.io stands out as a reliable and affordable proxy provider, which offers scalable solutions for developers. By using Webshare’s proxies, you can efficiently manage large-scale proxy needs while optimizing your Node.js applications."
    }
]