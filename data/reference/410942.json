[
    {
        "link": "https://stackoverflow.com/questions/18606162/debugging-into-external-libraries-in-qtcreator",
        "document": "I have been using Qt Creator to develop some Qt apps recently with no problems. This week I started to use Qt Creator to work on an Open Scene Graph application. I have all of the source (.cpp and .h) files for Open Scene Graph and used those to build the libraries.\n\nI then created a new project and linked those libraries into my project through the .pro file. My application works and runs, I can debug but not step into the code from the Open Scene Graph libraries.\n\nHow can I set up Qt Creator to step through these source files or even break at breakpoints within the source code of these libraries?\n\nIn Tools -> Options -> Debugger, there is Source Paths Mapping which may be what I'm after but I'm not sure."
    },
    {
        "link": "https://qtcentre.org/threads/51114-How-to-step-into-Thirdparty-library-source-code-while-debugging",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/1130106/linking-with-a-debug-release-lib-with-qmake-qt-creator",
        "document": "I am using Qt Creator and have a Qt GUI project that depends on a C++ static library project. I want to link the release version of the GUI app with the release build of the .lib and the debug release of the GUI app with the debug .lib. I have found out how to add additional libraries to the project by including a line like the following in my .pro file:\n\nBut I cannot see how I can use a different command for release and debug builds.\n\nIs there support in qmake to do this?"
    },
    {
        "link": "https://forum.qt.io/topic/59822/inspect-third-party-library-from-qt-debugger",
        "document": "I am using the OpenGL mathematics library within the application I am developing now from Qt creator.\n\nI am trying to see the value of one of elements of the library , for example\n\nwhile debugging. All I see is value \"not accessible\". Is there any way to make them visible so that I can realize what is indeed happening within the code structure. I am developing from Ubuntu system and Qt creator uses the GDB debugger as an underlay , I think.\n\nSome insights into this issue would be very helpful."
    },
    {
        "link": "https://forum.qt.io/topic/101097/unable-to-debug-code-from-one-specific-library",
        "document": "\n• Have been using Qt for quite some time, but have been stumped by this occurrence. I have developed a number of libraries, both Qt and non-Qt that I re-use in most of the applications I develop. I have always been able to set breakpoints in all of the libraries, whether the source code is part of the present project or not. I just open the appropriate source code, set the breakpoint, and wait for the present project to reach that place in the libraries code. For one specific project, however, that fails. When the app is not executing, I am able to open the source code and set some appropriate breakpoints. As would normally be the case, I can double click on the various breakpoints and the editor jumps to the associated location in the source code. However, once execution starts, I can no longer access these breakpoints. Further, rather than stop at the desired breakpoint, execution stops at the place in my current project code that calls that library routine. The result is that I cannot debug the code for this library. While the code is executing, When I click on a breakpoint in this library, I get an error that Qt \"could not open [the source code] for reading. Either the file does not exist or you do not have the permissions to open it. I suspect this result is from some compiler or linker option that somehow disables access to the debug info. There are quite a few such options, and I am not familiar with a bunch of them. I am not aware of what details in the source code itself that could disable my ability to debug, but I suppose such could exist. I hope to get a few suggestions for the sorts of things that can lead to this behavior, because the code in question really deserves a bit of debugging.\n• It's quite difficult to understand what's going on without more details. When I got a similar issue in the past, was due the fact that at runtime the application was finding a release library that got installed in the system (by a previous make install I did on release mode), but when the application was stopped, the Qt Creator was let me navigate the code of the library in debug mode. So, my first suggestion is to try to find in your whole computer the library in question and see if there are some of them got installed in some system directory or in a path that at runtime the application can load libraries from.\n• It would be helpful if you mentioned which platform, compiler and debugger you're using, as the debugging setup differs from toolchain to toolchain.\n\n In any case the first step is to verify if you're loading the debug version of that library. Might sound silly but it's a common mistake and it would be a shame not to check.\n\n Next would be to confirm if you have debug symbols loaded for that lib.\n\n Both these things you can check in the modules window of Qt Creator when you're running the app under debugger. (Window->Views->Modules if you don't have it shown).\n\n If both of these check out the next step is to verify if the debug info has the right paths to the sources. This step varies depending on the toolchain and debug info format so can't help you without that information. If the paths don't match Qt Creator lets you setup path mapping in the debugger options (Options->Debugger->General tab-> Source Paths Mapping).\n• \n• Running Windows 10, and using g++ from MinGW-w64-x86 (recent version) as the compiler and the corresponding gdb for the debugger.\n• I am loading the debug version of the library - at least the one with the \"d\" suffix. I am \"pretty\" confident I created it with the appropriate debug switches set properly. However, I did build this library by a somewhat different means than I normally use, so that leaves some room for doubt.\n• not confident I'm looking at the debug symbols question correctly. The \"modules\" window shows that for my main executable, the \"Symbols Read\" and \"Symbols Type\" are \"Unknown\" - but the debugger reads and displays them correctly. When I tried this the first time, both for the executable and for the library in question, these were both \"yes\". Not at all sure what has changed.\n• Pretty sure the debugger has the correct paths, but not sure how to verify. Execution breaks at all the right times, but at a location in my executable's code that corresponds to where a breakpoint would be encounted in the library - just not in the library code. There are no explicit source path mappings configured - but I have never set any and never needed to set any with any other library.\n• @aha_1980 Well, again I find myself stumped by some pretty deep intricacies in how Windows uses libraries - in particular DLLs.\n• My immediate debugging problem seems to be that the debugger can't find the source code for the library giving me trouble. I found this note in the Global Debugger Log: \"No source file named xxxxxx.cpp\", where xxxxxx.cpp is the file I'm trying to debug. Presumably, that is why the debugger doesn't know what to do with my breakpoints. I have been unsuccessful telling Creator how to provide the source code location to the debugger.\n• I have not been successful making this library the same way I make all of my others. In the past, I have always used \"ar\" to create a library, say mylib, as libmylib.a and to link with the executable with -lmylib where the loader has libmylib.a in its search path. There has never been specific need to tell the debugger anything special - it always just found the source code, presumably from association of the breakpoint with where it was set in the source code via the Creator editor. This library is created using g++ with options I don't fully understand. It creates mylib.dll, which is what the loader uses to create the executable for my app, and which must be in my PATH when I execute the app. The reason I do it this way is because it works. if I use my usual approach, the loader fails with a bunch of unresolved references having mangled names like \"__imp__ZN5Qxxxx6FormatD1Ev\". I fought a similar problem a few years back, but never fully understood how I made it go away. But it was also related to how libraries were linked and loaded. Bottom line, I am considerably confused by all things related to .a and .dll libraries, and would very much like to know how to know for certain that the dll in question has the relevant debugging info and how to tell the debugger how to find it. Thanks for listening to my tirade.\n• So you're on Windows, right? You still didn't tell us, which compiler you use. From I assume it would be MinGW, but could also by cygwin. You probably know, that on Windows you cannot mix libraries from different compilers; and I assume the library in question is build with debug symbols. This library is created using g++ with options I don't fully understand. Well, that may be true, but how can I help you there? You didn't gave us the options to tell you if there is anything fishy. and which must be in my PATH when I execute the app. Which brings us to another point: Are you sure the correct library is loaded, and not an older version that is somewhere on your hard disk? Qt has to stay free or it will die.\n• @aha_1980 OP already said he's using MinGW-w64-x86 on Windows 10. which is what the loader uses to create the executable for my app, and which must be in my PATH when I execute the app. The reason I do it this way is because it works. That's horrible. Both the fact you're using PATH for that and the reason for it.\n\n You should have a build step that copies dependencies to your output directory. There are 2 ways to link a library - static and dynamic. Static library is just a .a file containing the actual code that is linked into the executable at link time. Dynamic libraries consist of a .a file and a .dll file. The dll contains the actual code while the .a file is linked into the executable and contains just the \"glue\" code that loads the dll at runtime and resolves function pointers from it.\n\n In case of static libraries the debug information is placed inside the executable (at least MinGW does that, MSVC uses separate .pdb files). In case of dynamic libraries the debug info is split into the executable and the dll, each containing the info for the code it holds.\n\n Debug info consists, among other things, of source file name and path the library or executable was build from. When you start a debug session and hit a breakpoint the debugger looks for the source file specified in the debug info in the following locations: next to the library dll file, in the path contained in the debug info which is the original location at compile time, in some debugger specific locations (I don't know what they are for GDB specifically, I suspect some env variable) and in the mapped directories. So, if the sources are at the location specified in the debug info then it will \"just work\". If you moved the sources, renamed a directory they are in or have the .a and .dll from some other machine which had a different path then the debugger won't find it. So the steps are: Make sure you're linking to the debug version. Make sure the debugger loads the debug info. Check where it looks for the sources. Check if the sources exist at exactly that location. If not either move them to that exact location or use the path mapping feature of Qt Creator.\n• @Chris-Kawa Thanks for the input. \"That's horrible. Both the fact you're using PATH for that and the reason for it.\" - I'd be happy to learn a better way. \"a build step that copies dependencies to your output directory\" - I don't know what this means or how to accomplish it. In general, I have control over where the output directory is and what goes into it but I don't understand putting \"dependencies\" in it. I broadly understand static vs dynamic linking, but certainly do not many fine details. For the bulk of libraries I create, I just make the .a with no affiliated .dll. One of my big confusions is why the relevant info is not available through whatever mechanism it always has been. For the immediate situation, the .a and .dll are in the same location, and I think the compile process specifies that location. Not sure what you mean by \"mapped directories\". Mapped where and by whom? The sources are where they were at compile time. I have, and have always, copied the created libraries to a general library location. that is somehow magically found when some app is ultimately executed. All of the libraries under question were built by me from source with the same set of tools. I don't know how to make the debugger load debug info and I apparently don't know where it looks for sources. I have monkeyed around with the path mapping feature, but apparently not yet in a useful way for reference, below is an extract from the transcript for the build process for this library showing the exact compiler and linker options. Below that is a comparable transcript from building another of my libraries. The second library is rather heavily used and regularly part of a debugging session."
    },
    {
        "link": "https://doc.qt.io/qt-6/qmake-project-files.html",
        "document": "Project files contain all the information required by qmake to build your application, library, or plugin. Generally, you use a series of declarations to specify the resources in the project, but support for simple programming constructs enables you to describe different build processes for different platforms and environments.\n\nThe project file format used by qmake can be used to support both simple and fairly complex build systems. Simple project files use a straightforward declarative style, defining standard variables to indicate the source and header files that are used in the project. Complex projects may use control flow structures to fine-tune the build process.\n\nThe following sections describe the different types of elements used in project files.\n\nIn a project file, variables are used to hold lists of strings. In the simplest projects, these variables inform qmake about the configuration options to use, or supply filenames and paths to use in the build process.\n\nqmake looks for certain variables in each project file, and it uses the contents of these to determine what it should write to a Makefile. For example, the lists of values in the HEADERS and SOURCES variables are used to tell qmake about header and source files in the same directory as the project file.\n\nVariables can also be used internally to store temporary lists of values, and existing lists of values can be overwritten or extended with new values.\n\nThe following snippet illustrates how lists of values are assigned to variables:\n\nThe list of values in a variable is extended in the following way:\n\nThe CONFIG variable is another special variable that qmake uses when generating a Makefile. It is discussed in General Configuration. In the snippet above, is added to the list of existing values contained in .\n\nThe following table lists some frequently used variables and describes their contents. For a full list of variables and their descriptions, see Variables.\n\nThe contents of a variable can be read by prepending the variable name with . This can be used to assign the contents of one variable to another:\n\nThe operator is used extensively with built-in functions that operate on strings and lists of values. For more information, see qmake Language.\n\nUsually, whitespace separates values in variable assignments. To specify values that contain spaces, you must enclose the values in double quotes:\n\nThe quoted text is treated as a single item in the list of values held by the variable. A similar approach is used to deal with paths that contain spaces, particularly when defining the INCLUDEPATH and LIBS variables for the Windows platform:\n\nYou can add comments to project files. Comments begin with the character and continue to the end of the same line. For example:\n\nTo include the character in variable assignments, it is necessary to use the contents of the built-in LITERAL_HASH variable.\n\nqmake provides a number of built-in functions to enable the contents of variables to be processed. The most commonly used function in simple project files is the include() function which takes a filename as an argument. The contents of the given file are included in the project file at the place where the function is used. The function is most commonly used to include other project files:\n\nSupport for conditional structures is made available via scopes that behave like statements in programming languages:\n\nThe assignments inside the braces are only made if the condition is true. In this case, the CONFIG option must be set. This happens automatically on Windows. The opening brace must stand on the same line as the condition.\n\nMore complex operations on variables that would usually require loops are provided by built-in functions such as find(), unique(), and count(). These functions, and many others are provided to manipulate strings and paths, support user input, and call external tools. For more information about using the functions, see qmake Language. For lists of all functions and their descriptions, see Replace Functions and Test Functions.\n\nThe TEMPLATE variable is used to define the type of project that will be built. If this is not declared in the project file, qmake assumes that an application should be built, and will generate an appropriate Makefile (or equivalent file) for the purpose.\n\nThe following table summarizes the types of projects available and describes the files that qmake will generate for each of them:\n\nSee Building Common Project Types for advice on writing project files for projects that use the and templates.\n\nWhen the template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's tool on the newly-created Makefile. The variable is used to contain a list of all the subdirectories to be processed.\n\nThe CONFIG variable specifies the options and features that the project should be configured with.\n\nThe project can be built in release mode or debug mode, or both. If debug and release are both specified, the last one takes effect. If you specify the option to build both the debug and release versions of a project, the Makefile that qmake generates includes a rule that builds both versions. This can be invoked in the following way:\n\nAdding the option to the variable makes this rule the default when building the project.\n\nThis enables different configurations to be defined for and builds. For more information, see Using Scopes.\n\nThe following options define the type of project to be built.\n\nThe application and library project templates provide you with more specialized configuration options to fine tune the build process. The options are explained in detail in Building Common Project Types.\n\nFor example, if your application uses the Qt library and you want to build it in mode, your project file will contain the following line:\n\nIf the CONFIG variable contains the value, qmake's support for Qt applications is enabled. This makes it possible to fine-tune which of the Qt modules are used by your application. This is achieved with the QT variable which can be used to declare the required extension modules. For example, we can enable the XML and network modules in the following way:\n\nIf you want to build a project without the module, you need to exclude it with the \"-=\" operator. By default, contains both and , so the following line will result in a minimal Qt project being built:\n\nFor a list of Qt modules that you can add to the variable, see QT.\n\nqmake can be set up with extra configuration features that are specified in feature (.prf) files. These extra features often provide support for custom tools that are used during the build process. To add a feature to the build process, append the feature name (the stem of the feature filename) to the variable.\n\nFor example, qmake can configure the build process to take advantage of external libraries that are supported by pkg-config, such as the D-Bus and ogg libraries, with the following lines:\n\nFor more information about adding features, see Adding New Configuration Features.\n\nIf you are using other libraries in your project in addition to those supplied with Qt, you need to specify them in your project file.\n\nThe paths that qmake searches for libraries and the specific libraries to link against can be added to the list of values in the LIBS variable. You can specify the paths to the libraries or use the Unix-style notation for specifying libraries and paths.\n\nFor example, the following lines show how a library can be specified:\n\nThe paths containing header files can also be specified in a similar way using the INCLUDEPATH variable.\n\nFor example, to add several paths to be searched for header files:"
    },
    {
        "link": "https://doc.qt.io/qt-6/qmake-advanced-usage.html",
        "document": "qmake lets you create your own that can be included in project files by adding their names to the list of values specified by the CONFIG variable. Features are collections of custom functions and definitions in files that can reside in one of many standard directories. The locations of these directories are defined in a number of places, and qmake checks each of them in the following order when it looks for files:\n• In a directory listed in the environment variable that contains a list of directories delimited by the platform's path list separator (colon for Unix, semicolon for Windows).\n• In a directory listed in the property variable that contains a list of directories delimited by the platform's path list separator.\n• In a features directory residing within a directory. directories can be located beneath any of the directories listed in the environment variable that contains a list of directories delimited by the platform's path list separator. For example: .\n• In a features directory residing beneath the directory provided by the QMAKESPEC environment variable. For example: .\n• In a features directory residing in the directory. For example: .\n• In a features directory that exists as a sibling of the directory specified by the environment variable. For example: .\n\nThe following features directories are searched for features files:\n• , , or , depending on the platform in use\n\nFor example, consider the following assignment in a project file:\n\nWith this addition to the variable, qmake will search the locations listed above for the file after it has finished parsing your project file. On Unix systems, it will look for the following file:\n\nIt is common on Unix to also use the build tool to install applications and libraries; for example, by invoking . For this reason, qmake has the concept of an , an object which contains instructions about the way a part of a project is to be installed. For example, a collection of documentation files can be described in the following way:\n\nThe member informs qmake that the files should be installed in (the path member), and the member specifies the files that should be copied to the installation directory. In this case, everything in the directory will be copied to .\n\nOnce an install set has been fully described, you can append it to the install list with a line like this:\n\nqmake will ensure that the specified files are copied to the installation directory. If you require more control over this process, you can also provide a definition for the member of the object. For example, the following line tells qmake to execute a series of commands for this install set:\n\nThe scope ensures that these particular commands are only executed on Unix platforms. Appropriate commands for other platforms can be defined using other scope rules.\n\nCommands specified in the member are executed before the instructions in the other members of the object are performed.\n\nIf you append a built-in install set to the variable and do not specify or members, qmake will decide what needs to be copied for you. Currently, the and install sets are supported. For example:\n\nIn the above lines, qmake knows what needs to be copied, and will handle the installation process automatically.\n\nqmake tries to do everything expected of a cross-platform build tool. This is often less than ideal when you really need to run special platform-dependent commands. This can be achieved with specific instructions to the different qmake backends.\n\nCustomization of the Makefile output is performed through an object-style API as found in other places in qmake. Objects are defined automatically by specifying their members. For example:\n\nThe definitions above define a qmake target called , containing a Makefile target called which in turn is generated with the command. Finally, the member specifies that depends on , another target that is defined afterwards. is a dummy target. It is only defined to echo some text to the console.\n\nThe final step is to use the variable to instruct qmake that this object is a target to be built:\n\nThis is all you need to do to actually build custom targets. Of course, you may want to tie one of these targets to the qmake build target. To do this, you simply need to include your Makefile target in the list of PRE_TARGETDEPS.\n\nIt is possible to customize qmake to support new compilers and preprocessors:\n\nWith the above definitions, you can use a drop-in replacement for moc if one is available. The command is executed on all arguments given to the variable (from the member), and the result is written to the file defined by the member. This file is added to the other source files in the project. Additionally, qmake will execute to generate dependency information, and place this information in the project as well.\n\nThe CONFIG member supports the following options:\n\nOften when linking against a library, qmake relies on the underlying platform to know what other libraries this library links against, and lets the platform pull them in. In many cases, however, this is not sufficient. For example, when statically linking a library, no other libraries are linked to, and therefore no dependencies to those libraries are created. However, an application that later links against this library will need to know where to find the symbols that the static library will require. qmake attempts to keep track of the dependencies of a library, where appropriate, if you explicitly enable tracking.\n\nThe first step is to enable dependency tracking in the library itself. To do this you must tell qmake to save information about the library:\n\nThis is only relevant to the template, and will be ignored for all others. When this option is enabled, qmake will create a file ending in .prl which will save some meta-information about the library. This metafile is just like an ordinary project file, but only contains internal variable declarations. When installing this library, by specifying it as a target in an INSTALLS declaration, qmake will automatically copy the .prl file to the installation path.\n\nThe second step in this process is to enable reading of this meta information in the applications that use the static library:\n\nWhen this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of DEFINES as well as LIBS. Once qmake has processed this file, it will then look through the newly introduced libraries in the variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.\n\nThe .prl files should be created by qmake only, and should not be transferred between operating systems, as they may contain platform-dependent information."
    },
    {
        "link": "https://stackoverflow.com/questions/26211872/calling-custom-qmake-function-defined-in-parent-pro-file",
        "document": "I have defined a simple qmake function as the one below:\n\nMy project is arranged in the following hierachial manner:\n\nI have defined the aforementioned custom function in ProjectName.pro\n\nI am able to successfully call this function within ProjectName.pro using:\n\nHowever, I want to be able to call the custom function 'generateBoilerPlate' from within the .pro files inside the module subdirectories (i.e. in the example above, I want to call the function in ModuleName1.pro AND ModuleName2.pro).\n\nWhen I try and invoke the function in the submodules' .pro files, I get the following error:\n\nCan someone please tell me how to achieve what I want?"
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_versions/freesurfer/lib/qt/qt_doc/html/qmake-project-files.html",
        "document": "Project files contain all the information required by to build your application, library, or plugin. The resources used by your project are generally specified using a series of declarations, but support for simple programming constructs allow you to describe different build processes for different platforms and environments.\n\nThe project file format used by can be used to support both simple and fairly complex build systems. Simple project files will use a straightforward declarative style, defining standard variables to indicate the source and header files that are used in the project. Complex projects may use the control flow structures to fine-tune the build process.\n\nThe following sections describe the different types of elements used in project files.\n\nIn a project file, variables are used to hold lists of strings. In the simplest projects, these variables inform about the configuration options to use, or supply filenames and paths to use in the build process.\n\nlooks for certain variables in each project file, and it uses the contents of these to determine what it should write to a Makefile. For example, the list of values in the and variables are used to tell about header and source files in the same directory as the project file.\n\nVariables can also be used internally to store temporary lists of values, and existing lists of values can be overwritten or extended with new values.\n\nThe following lines show how lists of values are assigned to variables:\n\nNote that the first assignment only includes values that are specified on the same line as the variable. The second assignment splits the items across lines by using the character.\n\nThe list of values in a variable is extended in the following way:\n\nThe variable is another special variable that uses when generating a Makefile. It is discussed in the section on general configuration later in this chapter. In the above line, is added to the list of existing values contained in .\n\nThe following table lists the variables that recognizes, and describes what they should contain.\n\nThe contents of a variable can be read by prepending the variable name with . This can be used to assign the contents of one variable to another:\n\nThe operator is used extensively with built-in functions that operate on strings and lists of values. These are described in the chapter on qmake Advanced Usage.\n\nNormally, variables are used to contain whitespace-separated lists of values. However, it is sometimes necessary to specify values containing spaces. These must be quoted by using the quote() function in the following way:\n\nThe quoted text is treated as a single item in the list of values held by the variable. A similar approach is used to deal with paths that contain spaces, particularly when defining the INCLUDEPATH and LIBS variables for the Windows platform. In cases like these, the quote() function can be used in the following way:\n\nYou can add comments to project files. Comments begin with the character and continue to the end of the same line. For example:\n\nTo include the character in variable assignments, it is necessary to use the contents of the built-in variable. See the variable reference for more information.\n\nprovides a number of built-in functions to allow the contents of variables to be processed. The most commonly used function in simple project files is the function which takes a filename as an argument. The contents of the given file are included in the project file at the place where the function is used. The function is most commonly used to include other project files:\n\nSupport for conditional structures is made available via scopes that behave like statements in programming languages:\n\nThe assignments inside the braces are only made if the condition is true. In this case, the special variable must be set; this happens automatically on Windows, but this can also be specified on other platforms by running with the command line option (see Running qmake for more information). The opening brace must stand on the same line as the condition.\n\nSimple loops are constructed by iterating over lists of values using the built-in function. The following code adds directories to the SUBDIRS variable, but only if they exist:\n\nMore complex operations on variables that would usually require loops are provided by built-in functions such as , , and . These functions, and many others are provided to manipulate strings and paths, support user input, and call external tools. A list of the functions available can be found in the qmake Advanced Usage chapter of this manual.\n\nThe variable is used to define the type of project that will be built. If this is not declared in the project file, assumes that an application should be built, and will generate an appropriate Makefile (or equivalent file) for the purpose.\n\nThe types of project available are listed in the following table with information about the files that will generate for each of them:\n\nSee the qmake Tutorial for advice on writing project files for projects that use the and templates.\n\nWhen the template is used, generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's tool on the newly-created Makefile. The SUBDIRS variable is used to contain a list of all the subdirectories to be processed.\n\nThe CONFIG variable specifies the options and features that the compiler should use and the libraries that should be linked against. Anything can be added to the variable, but the options covered below are recognized by internally.\n\nThe following options control the compiler flags that are used to build the project:\n\nThe project is to be built in release mode. This is ignored if is also specified. The project is to be built in debug mode. The project is built in both debug and release modes. The project is built in both debug and release modes. TARGET is built into both the debug and release directories. If is specified, the project is built in both debug and release modes by default. Automatically generates a file that includes the precompiled header file specified in the .pro file. When using the template, this option specifies that the directories listed should be processed in the order in which they are given. The compiler should output as many warnings as possible. This is ignored if is specified. The compiler should output as few warnings as possible. Enables the install rule to also copy directories, not just files.\n\nThe option is special in that it enables both debug and release versions of a project to be built. In such a case, the Makefile that generates includes a rule that builds both versions, and this can be invoked in the following way:\n\nAdding the option to the variable makes this rule the default when building the project, and installation targets will be created for both debug and release builds.\n\nNote that each of the options specified in the variable can also be used as a scope condition. You can test for the presence of certain configuration options by using the built-in CONFIG() function. For example, the following lines show the function as the condition in a scope to test whether only the option is in use:\n\nThis enables different configurations to be defined for and builds, and is described in more detail in the Scopes section of the Advanced Usage chapter of this manual.\n\nThe following options define the type of project to be built. Note that some of these options only take effect when used on the relevant platform. On other platforms, they have no effect.\n\nWhen using application or library project templates, more specialized configuration options can be used to fine tune the build process. These are explained in details in the Common Projects chapter of this manual.\n\nFor example, if your application uses the Qt library and you want to build it as a multi-threaded application in mode, your project file will contain the following line:\n\nNote, that you must use \"+=\", not \"=\", or will not be able to use Qt's configuration to determine the settings needed for your project.\n\nIf the variable contains the value, qmake's support for Qt applications is enabled. This makes it possible to fine-tune which of the Qt modules are used by your application. This is achieved with the variable which can be used to declare the required extension modules. For example, we can enable the XML and network modules in the following way:\n\nNote that includes the and modules by default, so the above declaration adds the network and XML modules to this default list. The following assignment omits the default modules, and will lead to errors when the application's source code is being compiled:\n\nIf you want to build a project without the module, you need to exclude it with the \"-=\" operator. By default, contains both and , so the following line will result in a minimal Qt project being built:\n\nThe table below shows the options that can be used with the variable and the features that are associated with each of them:\n\nNote that adding the option to the variable automatically causes the equivalent option to be added to the variable. Therefore, for Qt applications, it is not necessary to add the option to both and .\n\ncan be set up with extra configuration features that are specified in feature (.prf) files. These extra features often provide support for custom tools that are used during the build process. To add a feature to the build process, append the feature name (the stem of the feature filename) to the variable.\n\nFor example, can configure the build process to take advantage of external libraries that are supported by pkg-config, such as the D-Bus and ogg libraries, with the following lines:\n\nMore information about features can be found in the Adding New Configuration Features section of the qmake Advanced Usage chapter.\n\nIf you are using other libraries in your project in addition to those supplied with Qt, you need to specify them in your project file.\n\nThe paths that searches for libraries and the specific libraries to link against can be added to the list of values in the LIBS variable. The paths to the libraries themselves can be given, or the familiar Unix-style notation for specifying libraries and paths can be used if preferred.\n\nFor example, the following lines show how a library can be specified:\n\nThe paths containing header files can also be specified in a similar way using the INCLUDEPATH variable.\n\nFor example, it is possible to add several paths to be searched for header files:"
    },
    {
        "link": "https://stackoverflow.com/questions/18663331/how-to-check-the-selected-version-of-qt-in-a-pro-file",
        "document": "I have multiple versions of Qt installed, and I need to compile my project with all of them.\n\n Using a pro file, I could not find in the documentation how to do a conditional compilation.\n\nIdeally, this is what I would like to do:\n\nNaturally, the if() command does not exist in pro files.\n\n Is there a better way to do the same thing?"
    }
]