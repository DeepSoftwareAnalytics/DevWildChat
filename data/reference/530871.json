[
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://geeksforgeeks.org/encapsulation-in-python",
        "document": "In Python, encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. It also restricts direct access to some components, which helps protect the integrity of the data and ensures proper usage.\n\nEncapsulation is the process of hiding the internal state of an object and requiring all interactions to be performed through an object’s methods. This approach:\n• None Provides better control over data.\n• Data Hiding : The variables (attributes) are kept private or protected, meaning they are not accessible directly from outside the class. Instead, they can only be accessed or modified through the methods.\n• Access through Methods : Methods act as the interface through which external code interacts with the data stored in the variables. For instance, getters and setters are common methods used to retrieve and update the value of a private variable.\n• Control and Security : By encapsulating the variables and only allowing their manipulation via methods, the class can enforce rules on how the variables are accessed or modified, thus maintaining control and security over the data.\n\nEncapsulation in Python is like having a bank account system where your account balance (data) is kept private. You can’t directly change your balance by accessing the account database. Instead, the bank provides you with methods (functions) like deposit and withdraw to modify your balance safely.\n• Private Data (Balance) : Your balance is stored securely. Direct access from outside is not allowed, ensuring the data is protected from unauthorized changes.\n• Public Methods (Deposit and Withdraw) : These are the only ways to modify your balance. They check if your requests (like withdrawing money) follow the rules (e.g., you have enough balance) before allowing changes.\n\nPublic members are accessible from anywhere, both inside and outside the class. These are the default members in Python.\n• Public Attribute (name): This attribute is declared without any underscore prefixes. It is accessible from anywhere, both inside and outside of the class.\n• Public Method (display_name): This method is also accessible from any part of the code. It directly accesses the public attribute and prints its value.\n• Object (obj): An instance of Public is created, and the display_name method is called, demonstrating how public attributes and methods can be accessed directly.\n\nNote: The __init__ method is a constructor and runs as soon as an object of a class is instantiated.\n\nProtected members are identified with a single underscore (_). They are meant to be accessed only within the class or its subclasses.\n• Protected Attribute (_age): This attribute is prefixed with a single underscore, which by convention, suggests that it should be treated as a protected member. It’s not enforced by Python but indicates that it should not be accessed outside of this class and its subclasses.\n• Subclass: Here, a subclass inherits from Protected. Within this subclass, we can still access the protected attribute _age\n• Method (display_age): This method within the subclass accesses the protected attribute and prints its value. This shows that protected members can be accessed within the class and its subclasses.\n\nPrivate members are identified with a double underscore (__) and cannot be accessed directly from outside the class. Python uses name mangling to make private members inaccessible by renaming them internally.\n\nNote: Python’s private and protected members can be accessed outside the class through python name mangling.\n• Private Attribute (__salary): This attribute is prefixed with two underscores, which makes it a private member. Python enforces privacy by name mangling, which means it renames the attribute in a way that makes it hard to access from outside the class.\n• Method (salary): This public method provides the only way to access the private attribute from outside the class. It safely returns the value of __salary.\n• Direct Access Attempt: Trying to access the private attribute directly (obj.__salary) will result in an AttributeError, showing that direct access is blocked. This is Python’s way of enforcing encapsulation at a language level.\n\nWhat is Encapsulation in Python Programming?\n\nHow to Implement Encapsulation in Python Classes?\n\nWhat are Private and Protected Members in Python Classes?\n\nWhat are Key Differences Between Encapsulation and Abstraction?"
    },
    {
        "link": "https://docs.python.org/3/reference/datamodel.html",
        "document": "Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.) Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The operator compares the identity of two objects; the function returns an integer representing its identity. CPython implementation detail: For CPython, is the memory address where is stored. An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. The function returns an object’s type (which is an object itself). Like its identity, an object’s type is also unchangeable. The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object’s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable. Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether — it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable. CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. See the documentation of the module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change. Do not depend on immediate finalization of objects when they become unreachable (so you should always close files explicitly). Note that the use of the implementation’s tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a … statement may keep objects alive. Some objects contain references to “external” resources such as open files or windows. It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a method. Programs are strongly recommended to explicitly close such objects. The … statement and the statement provide convenient ways to do this. Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a container’s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed. Types affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after , a and b may or may not refer to the same object with the value one, depending on the implementation. This is because is an immutable type, so the reference to can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after , c and d are guaranteed to refer to two different, unique, newly created empty lists. (Note that assigns the same object to both e and f.)"
    },
    {
        "link": "https://realpython.com/python-classes",
        "document": "Python classes form the backbone of object-oriented programming, enabling you to encapsulate data and behavior into a single entity. When you work with a Python class, you define attributes to store data and methods to perform actions. This structure allows you to model real-world objects and create organized, reusable code.\n\nA class in Python serves as a blueprint for creating objects, which are instances of the class. You use classes when you need to encapsulate related data and functions, making your code modular and easier to manage. By defining classes, you can create multiple objects that share the same attributes and methods, while maintaining their own unique state.\n\nIn this tutorial, you’ll learn how to define and use Python classes, understand the distinction between classes and objects, and explore methods and attributes. You’ll also learn about instance and class attributes, methods, inheritance, and common pitfalls to avoid when working with classes.\n\nBy the end of this tutorial, you’ll understand that:\n• A class in Python is like a recipe for creating objects that encapsulate both data and behavior.\n• You use classes to model complex data structures and behaviors in a modular way.\n• You define classes in Python using the keyword, and instantiate them to create objects.\n• A class is a blueprint, while an object is an instance of a class.\n• Instance attributes are unique to each object, while class attributes are shared across all instances of the class.\n\nTo get the most out of this tutorial, you should know about Python variables, data types, and functions. Some experience with object-oriented programming (OOP) is also a plus. Don’t worry if you’re not an OOP expert yet. In this tutorial, you’ll learn the key concepts that you need to get started and more. You’ll also write several practical examples to help reinforce your knowledge of Python classes.\n\nPython is a multiparadigm programming language that supports object-oriented programming (OOP) through classes that you can define with the keyword. You can think of a class as a piece of code that specifies the data and behavior that represent and model a particular type of object. What is a class in Python? A common analogy is that a class is like the blueprint for a house. You can use the blueprint to create several houses and even a complete neighborhood. Each concrete house is an object or instance that’s derived from the blueprint. Each instance can have its own properties, such as color, owner, and interior design. These properties carry what’s commonly known as the object’s state. Instances can also have different behaviors, such as locking the doors and windows, opening the garage door, turning the lights on and off, watering the garden, and more. In OOP, you commonly use the term attributes to refer to the properties or data associated with a specific object of a given class. In Python, attributes are variables defined inside a class with the purpose of storing all the required data for the class to work. Similarly, you’ll use the term methods to refer to the different behaviors that objects will show. Methods are functions that you define within a class. These functions typically operate on or with the attributes of the underlying instance or class. Attributes and methods are collectively referred to as members of a class or object. You can write classes to model the real world. These classes will help you better organize your code and solve complex programming problems. For example, you can use classes to create objects that emulate people, animals, vehicles, books, buildings, cars, or other objects. You can also model virtual objects, such as a web server, directory tree, chatbot, file manager, and more. Finally, you can use classes to build class hierarchies. This way, you’ll promote code reuse and remove repetition throughout your codebase. In this tutorial, you’ll learn a lot about classes and all the cool things that you can do with them. To kick things off, you’ll start by defining your first class in Python. Then you’ll dive into other topics related to instances, attributes, and methods. To define a class, you need to use the keyword followed by the class name and a colon, just like you’d do for other compound statements in Python. Then you must define the class body, which will start at the next indentation level: In a class’s body, you can define attributes and methods as needed. As you already learned, attributes are variables that hold the class data, while methods are functions that provide behavior and typically act on the class data. Note: In Python, the body of a given class works as a namespace where attributes and methods live. You can only access those attributes and methods through the class or its objects. As an example of how to define attributes and methods, say that you need a class to model different circles in a drawing application. Initially, your class will have a single attribute to hold the radius. It’ll also have a method to calculate the circle’s area: In this code snippet, you define using the keyword. Inside the class, you write two methods. The method has a special meaning in Python classes. This method is known as the object initializer because it defines and sets the initial values for the object’s attributes. You’ll learn more about this method in the Instance Attributes section. The second method of is conveniently named and will compute the area of a specific circle by using its radius. In this example, you’ve used the module to access the constant as it’s defined in that module. It’s common for method names to contain a verb, such as calculate, to describe an action the method performs. To learn more about naming functions and methods in Python, check out the How Do You Choose Python Function Names? tutorial. Note: In Python, the first argument of most methods is . This argument holds a reference to the current object so that you can use it inside the class. You’ll learn more about this argument in the section on instance methods with . Cool! You’ve written your first class. Now, how can you use this class in your code to represent several concrete circles? Well, you need to instantiate your class to create specific circle objects from it. The action of creating concrete objects from an existing class is known as instantiation. With every instantiation, you create a new object of the target class. To get your hands dirty, go ahead and make a couple of instances of by running the following code in a Python REPL session: To create an object of a Python class like , you must call the class constructor with a pair of parentheses and a set of appropriate arguments. What arguments? In Python, the class constructor accepts the same arguments as the method. In this example, the class expects the argument. Calling the class constructor with different argument values will allow you to create different objects or instances of the target class. In the above example, and are separate instances of . In other words, they’re two different and concrete circles, as you can conclude from the code’s output. Great! You already know how to create objects of an existing class by calling the class constructor with the required arguments. Now, how can you access the attributes and methods of a given class? That’s what you’ll learn in the next section. In Python, you can access the attributes and methods of an object by using dot notation with the dot operator. The following snippet of code shows the required syntax: Note that the dot ( ) in this syntax basically means give me the following attribute or method from this object. The first line returns the value stored in the target attribute, while the second line accesses the target method and calls it. Note: Remember that to call a function or method, you need to use a pair of parentheses and a series of arguments, if applicable. Now get back to your circle objects and run the following code: In the first couple of lines after the instantiation, you access the attribute on your object. Then you call the method to calculate the circle’s area. In the second pair of statements, you do the same but on the object. You can also use dot notation and the assignment operator to change the current value of an attribute: Now the radius of is entirely different. When you call , the result immediately reflects this change. You’ve changed the object’s internal state or data, which typically impacts its behaviors or methods.\n\nAs you’ve learned, classes are great when you must bundle data and behavior together in a single entity. The data will come in the form of attributes, while the behavior will come as methods. You already have an idea of what an attribute is. Now it’s time to dive deeper into how you can add, access, and modify attributes in your custom classes. First, you need to know that your classes can have two types of attributes in Python:\n• Class attributes: A variable that you define in the class body directly. Class attributes belong to their containing class. Their data is common to the class and all its instances.\n• Instance attributes: A variable that you define inside an instance method using the argument and dot notation, like in . Instance attributes belong to a concrete instance of a given class. Their data is only available to that instance and defines its state. Both types of attributes have their specific use cases. Instance attributes are, by far, the most common type of attribute that you’ll use in your day-to-day coding, but class attributes also come in handy. Class attributes are variables that you define directly in the class body but outside of any method. These attributes are tied to the class itself rather than to particular objects of that class. All the objects that you create from a particular class share the same class attributes with the same original values. Because of this, if you change a class attribute, then that change affects all the derived objects. As an example, say that you want to create a class that keeps an internal count of the instances you’ve created. In that case, you can use a class attribute: keeps a class attribute that works as a counter of instances. When Python parses this class, it initializes the counter to zero and leaves it alone. Creating instances of this class means automatically calling the method and incremementing by one. Note: In the above example, you’ve used the class name to access inside . However, using the built-in function is best because it’ll make your class more flexible: The built-in function returns the class or type of , which is in this example. This subtle change makes your class more robust and reliable by avoiding hard-coding the name of the class that provides the attribute. It’s important to note that you can access class attributes using either the class or one of its instances. That’s why you can use the object to retrieve the value of . However, if you need to modify a class attribute, then you must use the class itself rather than one of its instances. For example, if you use to modify , then you’ll be overriding the original class attribute by creating a new instance attribute: You can’t modify class attributes through instances of the containing class. Doing that will create new instance attributes with the same name as the original class attributes. That’s why returns in this example. You’ve overridden the class attribute in the highlighted line. Note: It’s curious what Python does in the example above. It uses the initial value of as a class attribute to create a new instance attribute with the same name and increments it by one. How come? Well, the line is equivalent to the following assignment: In this statement, the attribute on the left of the equal sign is an instance attribute, while the attribute on the right side of the sign is a class attribute. Otherwise, the operator would’ve raised a . In general, you should use class attributes for sharing data between instances of a class. Any changes on a class attribute will be visible to all the instances of that class. Instance attributes are variables tied to a particular object of a given class. The value of an instance attribute is attached to the object itself. So, the attribute’s value is specific to its containing instance. Python lets you dynamically attach attributes to existing objects that you’ve already created. However, you most often define instance attributes inside instance methods, which are those methods that receive as their first argument. Note: Even though you can define instance attributes inside any instance method, it’s best to define all of them in the method, which is the instance initializer. This ensures that all of the attributes have consistent values when you create a new instance. Additionally, it makes the code more organized and easier to debug. Consider the following class, which defines a bunch of instance attributes: In this class, you define a total of seven instance attributes inside . The attributes , , , and take values from the arguments to , which are the arguments that you must pass to the class constructor, , to create concrete objects. Then, you explicitly initialize the attributes , , and with sensible values that don’t come from the user. Note: Inside a class, you must access all instance attributes through the argument. This argument holds a reference to the current instance, which is where the attributes belong and live. The argument plays a fundamental role in Python classes. You’ll learn more about in the section Instance Methods With . Here’s how your class works in practice: In these examples, you create two different instances of . Each instance takes specific input arguments at instantiation time to initialize part of its attributes. Note how the values of the associated attributes are different and specific to the concrete instance. Unlike class attributes, you can’t access instance attributes through the class. You need to access them through their containing instance: Instance attributes are specific to a concrete instance of a given class. So, you can’t access them through the class object. If you try to do that, then you get an exception. In Python, both classes and instances have a special attribute called . This attribute holds a dictionary containing the writable members of the underlying class or instance. Remember, these members can be attributes or methods. Each key in represents an attribute name. The value associated with a given key represents the value of the corresponding attribute. In a class, will contain class attributes and methods. In an instance, will hold instance attributes. When you access a class member through the class object, Python automatically searches for the member’s name in the class . If the name isn’t there, then you get an . Similarly, when you access an instance member through a concrete instance of a class, Python looks for the member’s name in the instance . If the name doesn’t appear there, then Python looks in the class . If the name isn’t found, then you get a . Here’s a toy class that illustrates how this mechanism works: In this class, you define a class attribute with a value of . In the method, you define an instance attribute that takes its value from the user’s input. Finally, you define a method to print both attributes. Now it’s time to check the content of in the class object. Go ahead and run the following code: The highlighted lines show that both the class attribute and the method are in the class dictionary. Note how you can use to access the value of class attributes by specifying the attribute’s name in square brackets, as you usually access keys in a dictionary. Note: You can access the same dictionary by calling the built-in function on your class or instance, as you did before. In instances, the dictionary will contain instance attributes only: The instance dictionary in this example holds and its specific value for the object at hand. Again, you can access any existing instance attribute using and the attribute name in square brackets. You can modify the instance dynamically. This means that you can change the value of existing instance attributes through , as you did in the final example above. You can even add new attributes to an instance using its dictionary. Using to change the value of instance attributes will allow you to avoid exceptions when you’re wiring descriptors in Python. You’ll learn more about descriptors in the Property and Descriptor-Based Attributes section. In Python, you can add new attributes to your classes and instances dynamically. This possibility allows you to attach new data and behavior to your classes and objects in response to changing requirements or contexts. It also allows you to adapt existing classes to specific and dynamic needs. For example, you can take advantage of this Python feature when you don’t know the required attributes of a given class at the time when you’re defining that class itself. Consider the following class, which aims to store a row of data from a database table or a CSV file: In this class, you haven’t defined any attributes or methods because you don’t know what data the class will store. Fortunately, you can add attributes and even methods to this class dynamically. For example, say that you’ve read a row of data from an file using . This class reads the data and returns it in a dictionary-like object. Now suppose that you have the following dictionary of data: Next, you want to add this data to an instance of your class, and you need to represent each data field as an instance attribute. Here’s how you can do it: In this code snippet, you first create an instance of called . Then you run a loop to iterate over the items of your dictionary of data, . Inside the loop, you use the built-in function to sequentially add each field as an attribute to your object. If you inspect , then you’ll note that it stores all the original data as attributes. You can also use dot notation and an assignment to add new attributes and methods to a class dynamically: Here, you first create a minimal class with no custom attributes or methods. To define the class’s body, you’ve just used a statement as a placeholder, which is Python’s way of doing nothing. Then you create an object called . Note how you can use dot notation and an assignment to add new attributes to the instance. In this example, you add and attributes with appropriate values. Then you provide the class with an initializer or method. In this method, you take the and arguments, which you turn into instance attributes in the method’s body. Then you add the method to dynamically. After this addition, you can create objects by passing the name and job to the class constructor. As you can conclude from the above example, you can construct an entire Python class dynamically. Even though this capability of Python may seem neat, you must use it carefully because it can make your code difficult to understand and reason about. Python allows you to add function-like behavior on top of existing instance attributes and turn them into managed attributes. This type of attribute prevents you from introducing breaking changes into your APIs. In other words, with managed attributes, you can have function-like behavior and attribute-like access at the same time. You don’t need to change your APIs by replacing attributes with method calls, which can potentially break your users’ code. To create a managed attribute with function-like behavior in Python, you can use either a property or a descriptor, depending on your specific needs. Note: To dive deeper into Python properties, check out Python’s : Add Managed Attributes to Your Classes. As an example, get back to your class and say that you need to validate the radius to ensure that it only stores positive numbers. How would you do that without changing your class interface? The quickest approach to this problem is to use a property and implement the validation logic in the setter method. Here’s what your new version of can look like: To turn an existing attribute like into a property, you typically use the decorator to write the getter method. The getter method must return the value of the attribute. In this example, the getter returns the circle’s radius, which is stored in the non-public attribute. Note: The pipe sign ( ) in the call to expresses union types. You can use this syntax in Python 3.10 or greater. If you’re using a lower version of Python, then you can use a tuple of types . To define the setter method of a property-based attribute, you need to use the decorator . In the example, you use . Then you need to define the method itself. Note that property setters need to take an argument providing the value that you want to store in the underlying attribute. Inside the setter method, you use a conditional to check whether the input value is an integer or a floating-point number. You also check if the value is less than or equal to . If either is true, then you raise a with a descriptive message about the actual issue. Finally, you assign to and that’s it. Now, is a property-based attribute. Here’s an example of this new version of in action: The first instance of in this example takes a valid value for its radius. Note how you can continue working with as a regular attribute rather than as a method. If you try to assign an invalid value to , then you get a exception. Note: Remember to reload the module if you’re working on the same REPL session as before. This recommendation will also be valid for all the examples in this tutorial where you change modules that you defined in previous examples. It’s important to note that the validation also runs at instantiation time when you call the class constructor to create new instances of . This behavior is consistent with your validation strategy. Using a descriptor to create managed attributes is another powerful way to add function-like behavior to your instance attributes without changing your APIs. Like properties, descriptors can also have getter, setter, and other types of methods. Note: To learn more about descriptors and how to use them, check out Python Descriptors: An Introduction. To explore how descriptors work, say that you’ve decided to continue creating classes for your drawing application, and now you have the following class: This class uses the same pattern as your class. Instead of using , the class takes a argument and computes the area using the appropriate expression for a square. This class is pretty similar to , and the repetition starts looking odd. Then you think of using a descriptor to abstract away the validation process. Here’s what you come up with: The first thing to notice in this example is that you moved all the classes to a file. In that file, you define a descriptor class called by implementing the and special methods, which are part of the descriptor protocol. Next, you remove the property from and the property from . In , you add a class attribute, which holds an instance of . You do something similar in , but the class attribute is appropriately named . Here are a few examples of how your classes work now: Python descriptors provide a powerful tool for adding function-like behavior on top of your instance attributes. They can help you remove repetition from your code, making it cleaner and more maintainable. They also promote code reuse. In a Python class, using the attribute can help you reduce the memory footprint of the corresponding instances. This attribute prevents the automatic creation of an instance . Using is particularly handy when you have a class with a fixed set of attributes, and you’ll use that class to create a large number of objects. In the example below, you have a class with a attribute that consists of a tuple of allowed attributes. Each attribute will represent a Cartesian coordinate: This class defines as a tuple with two items. Each item represents the name of an instance attribute. So, they must be strings holding valid Python identifiers. Note: Although can hold a object, you should use a object instead. Even if changing the list in after processing the class body had no effect, it’d be misleading to use a mutable sequence there. Instances of your class don’t have a , as the code shows. This feature makes them memory-efficient. To illustrate this efficiency, you can measure the memory consumption of an instance of . To do this, you can use the Pympler library, which you can install from PyPI using the command. Once you’ve installed Pympler with , then you can run the following code in your REPL: The function from Pympler says that the object occupies 112 bytes in your computer’s memory. Now get back to your REPL session and redefine without providing a attribute. With this update in place, go ahead and run the memory check again: The same object, , now consumes 528 bytes of memory. This number is over four times greater than what you got with the original implementation of . Imagine how much memory would save if you had to create a million points in your code. The attribute adds a second interesting behavior to your custom classes. It prevents you from adding new instance attributes dynamically: Adding a to your classes allows you to provide a series of allowed attributes. This means that you won’t be able to add new attributes to your instances dynamically. If you try to do it, then you’ll get an exception. A word of caution is in order, as many of Python’s built-in mechanisms implicitly assume that objects have the attribute. When you use , then you waive that assumption, which means that some of those mechanisms might not work as expected anymore.\n\nPython classes allow you to bundle data and behavior together in a single entity through attributes and methods, respectively. You’ll use the data to define the object’s current state and the methods to operate on that data or state. A method is just a function that you define inside a class. By defining it there, you make the relationship between the class and the method explicit and clear. Because they’re just functions, methods can take arguments and return values as functions do. However, the syntax for calling a method is a bit different from the syntax for calling a function. To call a method, you need to specify the class or instances in which that method is defined. To do this, you need to use dot notation. Remember that classes are namespaces, and their members aren’t directly accessible from the outside. In a Python class, you can define three different types of methods:\n• Instance methods, which take the current instance, , as their first argument\n• Class methods, which take the current class, , as their first argument\n• Static methods, which take neither the instance nor the class as an argument Every type of method has its own characteristics and specific use cases. Instance methods are, by far, the most common methods that you’ll use in your custom Python classes. Note: To learn more about instance, class, and static methods, check out Python’s Instance, Class, and Static Methods Demystified. In the following sections, you’ll dive into how each of these methods works and how to create them in your classes. To get started, you’ll begin with instance methods, which are the most common methods that you’ll define in your classes. In a class, an instance method is a function that takes the current instance as its first argument. In Python, this first argument is called by convention. Note: Naming the current instance is a strong convention in Python. It’s so strong that it may look like is one of the Python keywords. However, you could use any other name instead of . Even though it’s possible to use any name for the first argument of an instance method, using is definitely the right choice because it’ll make your code look like Python code in the eyes of other developers. The argument holds a reference to the current instance, allowing you to access that instance from within methods. More importantly, through , you can access and modify the instance attributes and call other methods within the class. To define an instance method, you just need to write a regular function that accepts as its first argument. Up to this point, you’ve already written some instance methods. To continue learning about them, turn back to your class. Now say that you want to add methods to start, stop, accelerate, and brake the car. To kick things off, you’ll begin by writing the and methods: The and methods are pretty straightforward. They take the current instance, , as their first argument. Inside the methods, you use to access the attribute on the current instance using dot notation. Then you change the current value of this attribute to in and to in . Both methods print informative messages to illustrate what your car is doing. Note: Instance methods should act on instance attributes by either accessing them or changing their values. If you find yourself writing an instance method that doesn’t use in its body, then that may not be an instance method. In this case, you should probably use a class method or a static method, depending on your specific needs. Now you can add the and methods, which will be a bit more complex: The method takes an argument that represents the increment of speed that occurs when you call the method. For simplicity, you haven’t set any validation for the input increment of speed, so using negative values can cause issues. Inside the method, you first check whether the car’s engine is started, returning immediately if it’s not. Then you check if the incremented speed is less than or equal to the allowed maximum speed for your car. If this condition is true, then you increment the speed. Otherwise, you set the speed to the allowed limit. The method works similarly. This time, you compare the decremented speed to because cars can’t have a negative speed. If the condition is true, then you decrement the speed according to the input argument. Otherwise, you set the speed to its lower limit, . Again, you have no validation on the input decrement of speed, so be careful with negative values. Your class now has four methods that operate on and with its attributes. It’s time for a drive: Great! Your class works nicely! You can start your car’s engine, increment the speed, brake, and stop the car’s engine. You’re also confident that no one can increment the car’s speed if the car’s engine is stopped. How does that sound for minimal modeling of a car? It’s important to note that when you call an instance method on a concrete instance like using dot notation, you don’t have to provide a value for the argument. Python takes care of that step for you. It automatically passes the target instance to . So, you only have to provide the rest of the arguments. However, you can manually provide the desired instance if you want. To do this, you need to call the method on the class: In this example, you call instance methods directly on the class. For this type of call to work, you need to explicitly provide an appropriate value to the argument. In this example, that value is the instance. Note that if you don’t provide a suitable instance, then the call fails with a . The error message is pretty clear. There’s a missing positional argument, . Python supports what it calls special methods, which are also known as dunder or magic methods. These methods are typically instance methods, and they’re a fundamental part of Python’s internal class mechanism. They have an important feature in common: Python calls them automatically in response to specific operations. Python uses these methods for many different tasks. They provide a great set of tools that will allow you to unlock the power of classes in Python. You’ll recognize special methods because their names start and end with a double underscore, which is the origin of their other name, dunder methods (double underscore). Arguably, is the most common special method in Python classes. As you already know, this method works as the instance initializer. Python automatically calls it when you call a class constructor. Note: To dive deeper into special methods, check out the Python’s Magic Methods: Leverage Their Power in Your Classes tutorial. You’ve already written a couple of methods. So, you’re ready to learn about other common and useful special methods. For example, the and methods provide string representations for your objects. Go ahead and update your class to add these two methods: The method provides what’s known as the informal string representation of an object. This method must return a string that represents the object in a user-friendly manner. You can access an object’s informal string representation using either or . The method is similar, but it must return a string that allows you to re-create the object if possible. So, this method returns what’s known as the formal string representation of an object. This string representation is mostly targeted at Python programmers, and it’s pretty useful when you’re working in an interactive REPL session. In interactive mode, Python falls back to calling when you access an object or evaluate an expression, issuing the formal string representation of the resulting object. In script mode, you can access an object’s formal string representation using the built-in function. Run the following code to give your new methods a try. Remember that you need to restart your REPL or reload : When you use an instance of as an argument to or , you get a user-friendly string representation of the car at hand. This informal representation comes in handy when you need your programs to present your users with information about specific objects. If you access an instance of directly in a REPL session, then you get a formal string representation of the object. You can copy and paste this representation to re-create the object in an appropriate environment. That’s why this string representation is intended to be useful for developers, who can take advantage of it while debugging and testing their code. Python protocols are another fundamental topic that’s closely related to special methods. Protocols consist of one or more special methods that support a given feature or functionality. Common examples of protocols include: Allows you to create iterator objects Enables an object to work on statements Of course, Python has many other protocols that support cool features of the language. You already coded an example of using the descriptor protocol in the Property and Descriptor-Based Attributes section. Here’s an example of a minimal class that implements the iterable protocol: This class takes three arguments representing the space coordinates of a given point. The method is a generator function that returns an iterator. The resulting iterator yields the coordinates of on demand. The call to iterates over the attributes , , and , returning a object. You don’t need to call directly. Python calls it automatically when you use an instance of in an iteration. You can also add class methods to your custom Python classes. A class method is a method that takes the class object as its first argument instead of taking . In this case, the argument should be called , which is also a strong convention in Python. So, you should stick to it. You can create class methods using the decorator. Providing your classes with multiple constructors is one of the most common use cases of class methods in Python. For example, say you want to add an alternative constructor to your so that you can quickly create points from tuples or lists of coordinates: In the class method, you take a sequence of coordinates as an argument, create a object from it, and return the object to the caller. To create the new object, you use the argument, which holds an implicit reference to the current class, which Python injects into your method automatically. In this example, you use the class directly to access the class method . Note that you can also access the method using a concrete instance, like in the example. In each of the calls to , you’ll get a completely new instance of . However, class methods should be accessed through the corresponding class name for better clarity and to avoid confusion. Your Python classes can also have static methods. These methods don’t take the instance or the class as an argument. So, they’re regular functions defined within a class. You could’ve also defined them outside the class as stand-alone function. You’ll typically define a static method instead of a regular function outside the class when that function is closely related to your class, and you want to bundle it together for convenience or for consistency with your code’s API. Remember that calling a function is a bit different from calling a method. To call a method, you need to specify a class or object that provides that method. If you want to write a static method in one of your custom classes, then you need to use the decorator. Check out the method below: ! This is your 3D Point!\" The static method takes a as an argument and prints a message on the screen. Note that this is only a toy example of how to write static methods in your classes. Static methods like don’t operate on the current instance, , or the current class, . They work as independent functions enclosed in a class. You’ll typically put them inside a class when they’re closely related to that class but don’t necessarily affect the class or its instances. Hey Pythonista! This is your 3D Point! Hey Python developer! This is your 3D Point! As you already know, the method takes a name as an argument and prints a message to your screen. Note that you can call the method using the class or any of its instances. As with class methods, you should generally call static methods through the corresponding class instead of one of its instances. Programming languages like Java and C++ don’t expose attributes as part of their classes’ public APIs. Instead, these programming languages make extensive use of getter and setter methods to give you access to attributes. Note: To dive deeper into the getter and setter pattern and how Python approaches it, check out Getters and Setters: Manage Attributes in Python. Using methods to access and update attributes promotes encapsulation. Encapsulation is a fundamental OOP principle that recommends protecting an object’s state or data from the outside world, preventing direct access. The object’s state should only be accessible through a public interface consisting of getter and setter methods. For example, say that you have a class with a instance attribute. You can make a non-public attribute and provide getter and setter methods to access and change that attribute: In this example, is the getter method and allows you to access the underlying attribute. Similarly, is the setter method and allows you to change the current value of . The attribute is non-public and is where the actual data is stored. Here’s how you can use your class: Here, you create an instance of using the class constructor and as the required name. That means you can use the method to access Jane’s name and the method to update it. The getter and setter pattern is common in languages like Java and C++. Besides promoting encapsulation and APIs centered on method calls, this pattern also allows you to quickly add function-like behavior to your attributes without introducing breaking changes in your APIs. However, this pattern is less popular in the Python community. In Python, it’s completely normal to expose attributes as part of an object’s public API. If you ever need to add function-like behavior on top of a public attribute, then you can turn it into a property instead of breaking the API by replacing the attribute with a method. Here’s how most Python developers would write the class: This class doesn’t have getter and setter methods for the attribute. Instead, it exposes the attribute as part of its API. So, you can use it directly: In this example, instead of using a setter method to change the value of , you use the attribute directly in an assignment statement. This is common practice in Python code. If your class evolves to a point where you need to add function-like behavior on top of , then you can turn the attribute into a property. For example, say that you need to store the attribute in uppercase letters. Then you can do something like the following: This class defines as a property with appropriate getter and setter methods. Python will automatically call these methods, respectively, when you access or update the attribute’s value. The setter method takes care of uppercasing the input value before assigning it back to : Python properties allow you to add function-like behavior to your attributes while you continue to use them as normal attributes instead of as methods. Note how you can still assign new values to using an assignment instead of a method call. Running the assignment triggers the setter method, which uppercases the input value.\n\nIn the Python standard library, you’ll find many tools that solve different problems and deal with different challenges. Among all these tools, you’ll find a few that will make you more productive when writing custom classes. For example, if you want a tool that saves you from writing a lot of class-related boilerplate code, then you can take advantage of data classes and the module. Similarly, if you’re looking for a tool that allows you to quickly create class-based enumerations of constants, then you can turn your eye to the module and its different types of enumeration classes. In the following sections, you’ll learn the basics of using data classes and enumerations to efficiently write robust, reliable, and specialized classes in Python. Python’s data classes specialize in storing data. However, they’re also code generators that produce a lot of class-related boilerplate code for you behind the scenes. For example, if you use the data class infrastructure to write a custom class, then you won’t have to implement special methods like , , , and . The data class will write them for you. More importantly, the data class will write these methods applying best practices and avoiding potential errors. Note: To learn more about data classes in Python, check out the Data Classes in Python 3.7+ (Guide) tutorial. As you already know, special methods support important functionalities in Python classes. In the case of data classes, you’ll have accurate string representation, comparison capabilities, hashability, and more. Even though the name data class may suggest that this type of class is limited to containing data, it can also contain methods. So, data classes are like regular classes but with superpowers. To create a data class, go ahead and import the decorator from the module. You’ll use this decorator in the definition of your class. This time, you won’t write an method. You’ll just define data fields as class attributes with type hints. For example, here’s how you can write the class as a data class: ! This is your 3D Point!\" This new implementation of uses Python’s decorator to turn the regular class into a data class. Instead of defining an method, you list the attributes with their corresponding types. The data class will take care of writing a proper initializer for you. Note that you don’t define or either. Note: Data classes are pretty flexible when it comes to defining their fields or attributes. You can declare them with the type annotation syntax. You can initialize them with a sensible default value. You can also combine both approaches depending on your needs: In this code snippet, you declare the first attribute using the type annotation syntax. The second attribute has a default value with no type annotation. Finally, the third attribute has both type annotation and a default value. However, when you don’t specify a type hint for an attribute, then Python won’t automatically generate the corresponding code for that attribute. Once you’ve defined the data fields or attributes, you can start adding methods. In this example, you keep the class method and the static method. Go ahead and run the following code to check the additional functionality that has added to this version of : Your class works pretty well! It provides a suitable string representation with an automatically generated method. You can iterate over the fields using the function from the module. Finally, you can compare two instances of the class for equality ( ). As you can conclude, this new version of has saved you from writing several lines of tricky boilerplate code. An enumeration, or just enum, is a data type that you’ll find in several programming languages. Enums allow you to create sets of named constants, which are known as members and can be accessed through the enumeration itself. Python doesn’t have a built-in enum data type. However, Python 3.4 introduced the module to provide the class for supporting general-purpose enumerations. Days of the week, months and seasons of the year, HTTP status codes, colors in a traffic light, and pricing plans of a web service are all great examples of constants that you can group in an enum. In short, you can use enums to represent variables that can take one of a limited set of possible values. The class, among other similar classes in the module, allows you to quickly and efficiently create custom enumerations or groups of similar constants with neat features that you don’t have to code yourself. Apart from member constants, enums can also have methods to operate with those constants. Note: To learn more about how to create and use enumerations in your Python code, check out the Build Enumerations of Constants With Python’s Enum tutorial. To define a custom enumeration, you can subclass the class. Here’s an example of an enumeration that groups the days of the week: In this code example, you define by subclassing from the module. This specific enum groups seven constants representing the days of the week. These constants are the enum members. Because they’re constants, you should follow the convention for naming any constant in Python: uppercase letters and underscores between words, if applicable. Enumerations have a few cool features that you can take advantage of. For example, their members are strict constants, so you can’t change their values. They’re also iterable by default: If you try to change the value of an enum member, then you get an . So, enum members are strictly constants. You can iterate over the members directly because enumerations support iteration by default. You can directly access their members using different syntax: In the first example, you access an enum member using dot notation, which is pretty intuitive and readable. In the second example, you access a member by calling the enumeration with that member’s value as an argument. Finally, you use a dictionary-like syntax to access another member by name. If you want fine-grain access to a member’s components, then you can use the and attributes: In these examples, you access the and attributes of specific members of . These attributes provide access to each member’s component. Finally, you can also add custom behavior to your enumerations. To do that, you can use methods as you’d do with regular classes: After saving your code to , you add a class method called to your enumeration. This method will just return your favorite day of the week, which is Friday, of course! Then you add a method to provide a user-friendly string representation for the current day. Here’s how you can use these methods in your code: You’ve added new functionality to your enumeration through class and instance methods. Isn’t that cool?\n\nInheritance is a powerful feature of object-oriented programming. It consists of creating hierarchical relationships between classes, where child classes inherit attributes and methods from their parent class. In Python, one class can have multiple parents or, more broadly, ancestors. This is known as implementation inheritance, which allows you to reduce duplication and repetition by code reuse. It can also make your code more modular, better organized, and more scalable. However, classes also inherit the interface by becoming more specialized kinds of their ancestors. In some cases, you’ll be able to use a child instance where an ancestor is expected. In the following sections, you’ll learn how to use inheritance in Python. You’ll start with simple inheritance and continue with more complex concepts. So, get ready! This is going to be fun! When you have a class that inherits from a single parent class, then you’re using single-base inheritance or just simple inheritance. To make a Python class inherit from another, you need to list the parent class’s name in parentheses after the child class’s name in the definition. Here’s the syntax that you must use: In this code snippet, is the class you want to inherit from. Parent classes typically provide generic and common functionality that you can reuse throughout multiple child classes. is the class that inherits attributes and methods from . The highlighted line shows the required syntax. Note: In this tutorial, you’ll use the terms parent class, superclass, and base class interchangeably to refer to the class that you inherit from. Similarly, you’ll use the terms child class, derived class, and subclass to refer to classes that inherit from other classes. Here’s a practical example to get started with simple inheritance and how it works. Suppose you’re building an app to track vehicles and routes. At first, the app will track cars and motorcycles. You think of creating a class and deriving two subclasses from it. One subclass will represent a car, and the other will represent a motorcycle. The class will provide common attributes, such as , , and . It’ll also provide the and methods to start and stop the vehicle engine, respectively: In this code, you define the class with attributes and methods that will be common to all your vehicle types. You can say that provides the common interface of all your vehicles. You’ll inherit from this class to reuse this interface and its functionality in your subclasses. Now you can define the and classes. Both of them will have some unique attributes and methods specific to the vehicle type. For example, the will have a attribute and a method: Your class uses as its parent class. This means that will automatically inherit the , , and attributes, as well as the non-public attribute. It’ll also inherit the and methods. Note: Like inheritance in biology, inheritance in OOP goes in a single direction, from the parents to the children. In other words, children inherit from their parents and not the other way around. The class defines a attribute. As you already know, you should define and initialize instance attributes in . This requires you to provide a custom method in , which will shadow the superclass initializer. How can you write an method in and still guarantee that you initialize the , , and attributes? That’s where the built-in function comes on the scene. This function allows you to access members in the superclass, as its name suggests. Note: To learn more about using in your classes, check out Supercharge Your Classes With Python . In , you use to call the method on . Note that you pass the input values for , , and so that can initialize these attributes correctly. After this call to , you add and initialize the attribute, which is specific to the class. Finally, you write the method, which is also specific to . This method is just a demonstrative example, so it only prints a message to your screen. Now it’s time to define the class, which will inherit from too. This class will have a attribute and a method: Again, you call to initialize , , and . After that, you define and initialize the attribute. Finally, you write the method. Again, this method is just a demonstrative example. With this code in place, you can start using and right away: Driving my \"Tesla - Model S\" on the road Riding my \"Harley-Davidson - Iron 883\" on the road. Cool! Your Tesla and your Harley-Davidson work nicely. You can start their engines, drive or ride them, and so on. Note how you can use both the inherited and specific attributes and methods in both classes. You’ll typically use single inheritance or inheritance in general when you have classes that share common attributes and behaviors and want to reuse them in derived classes. So, inheritance is a great tool for code reuse. Subclasses will inherit and reuse functionality from their parent. Subclasses will frequently extend their parent’s interface with new attributes and methods. You can use them as a new starting point to create another level of inheritance. This practice will lead to the creation of class hierarchies. Using inheritance, you can design and build class hierarchies, also known as inheritance trees. A class hierarchy is a set of closely related classes that are connected through inheritance and arranged in a tree-like structure. The class or classes at the top of the hierarchy are the base classes, while the classes below are derived classes or subclasses. Inheritance-based hierarchies express an is-a-type-of relationship between subclasses and their base classes. For example, a bird is a type of animal. Each level in the hierarchy will inherit attributes and behaviors from the above levels. Therefore, classes at the top of the hierarchy are generic classes with common functionality, while classes down the hierarchy are more specialized. They’ll inherit attributes and behaviors from their superclasses and will also add their own. Taxonomic classification of animals is a commonly used example to explain class hierarchies. In this hierarchy, you’ll have a generic class at the top. Below this class, you can have subclasses like , , , and so on. These subclasses are more specific classes than and inherit the attributes and methods from it. They can also have their own attributes and methods. To continue with the hierarchy, you can subclass , , and and create derived classes with even more specific characteristics. Here’s a short toy implementation of this example: At the top of the hierarchy, you have the class. This is the base class of your hierarchy. It has the , , and attributes, which will be string objects. These attributes are common to all animals. Then you define the , , and classes by inheriting from . These classes have a class attribute that holds the distinguishing characteristic of each group of animals. Then you create concrete mammals like and . These classes have specific methods that are common to all dogs and cats, respectively. Similarly, you define two classes that inherit from and two more that inherit from . Here’s a tree-like class diagram that will help you see the hierarchical relationship between classes: Each level in the hierarchy can—and typically will—add new attributes and functionality on top of those that its parents already provide. If you walk through the diagram from top to button, then you’ll move from generic to specialized classes. These latter classes implement new methods that are specific to the class at hand. In this example, the methods just print some information to the screen and automatically return , which is the null value in Python. Note: You can create class diagrams to represent class hierarchies that are based on inheritance. However, that’s not the only relationship that can appear between your classes. With class diagrams, you can also represent other types of relationships, including the following:\n• Composition expresses a strong has-a relationship. For example, a robot has an arm. If the robot stops existing, then the arm stops existing too.\n• Aggregation expresses a softer has-a relationship. For example, a university has an instructor. If the university stops existing, the instructor doesn’t stop existing.\n• Association expresses a uses-a relationship. For example, a student may be associated with a course. They will use the course. This relationship is common in database systems where you have one-to-one, one-to-many, and many-to-many associations. You’ll learn more about some of these types of relationships in the section called Using Alternatives to Inheritance. That’s how you design and create class hierarchies to reuse code and functionality. Such hierarchies also allow you to give your code a modular organization, making it more maintainable and scalable. When you’re using inheritance, you can face an interesting and challenging issue. In some situations, a parent class may provide a given functionality only at a basic level, and you may want to extend that functionality in your subclasses. In other situations, the feature in the parent class isn’t appropriate for the subclass. In these situations, you can use one of the following strategies, depending on your specific case:\n• Extending an inherited method in a subclass, which means that you’ll reuse the functionality provided by the superclass and add new functionality on top\n• Overriding an inherited method in a subclass, which means that you’ll completely discard the functionality from the superclass and provide new functionality in the subclass Here’s an example of a small class hierarchy that applies the first strategy to provide extended functionality based on the inherited one: In this example, you define as the base class. In , you create a few instance attributes. Then you define the method, which prints information about the aircraft’s technical specifications. Next, you define , inheriting from . The method of extends the corresponding method of by calling to initialize the , , and attributes. You already saw something like this in the previous section. also extends the functionality of . In this case, you first call from using . Then you add a new call to that adds new information to the technical description of the helicopter at hand. When you call on a instance, you get the information provided by the base class, , and also the specific information added by itself. You’ve extended the functionality of in its subclass . Now it’s time to take a look at how you can override a method in a subclass. As an example, say that you have a base class called that defines several attributes and methods like in the following example: In this class, you define a few instance attributes to store important data about the current worker. You also provide the method to display relevant information about the worker. Finally, you write a generic method to compute the salary of workers from their hourly salary and the number of hours worked. Later in the development cycle, some requirements change. Now you realize that managers compute their salaries in a different way. They’ll have an hourly bonus that you must add to the normal hourly salary before computing the final amount. After thinking a bit about the problem, you decide that has to override completely. Here’s the implementation that you come up with: In the initializer, you take the hourly bonus as an argument. Then you call the parent’s method as usual and define the instance attribute. Finally, you override with a completely different implementation that doesn’t reuse the inherited functionality. In Python, you can use multiple inheritance. This type of inheritance allows you to create a class that inherits from several parent classes. The subclass will have access to attributes and methods from all its parents. Multiple inheritance allows you to reuse code from several existing classes. However, you must manage the complexity of multiple inheritance with care. Otherwise, you can face issues like the diamond problem. You’ll learn more about this topic in the Method Resolution Order (MRO) section. Here’s a small example of multiple inheritance in Python: In this example, you write a class with , , and attributes. The class also has the , , and methods. Then you create a class that inherits from and extends it with a new method called . You also create an class that inherits from and adds a method. Finally, you define a class to represent a car that you can drive on the road or fly in the sky. Isn’t that cool? Note that this class includes both and in its list of parent classes. So, it’ll inherit functionality from both superclasses. Here’s how you can use the class: In this code snippet, you first create an instance of . Then you call all its methods, including the inherited ones. As you can see, multiple inheritance promotes code reuse, allowing you to use functionality from several base classes at the same time. By the way, if you get this to really fly, then make sure you don’t stop the engine while you’re flying! When you’re using multiple inheritance, you can face situations where one class inherits from two or more classes that have the same base class. This is known as the diamond problem. The real issue appears when multiple parents provide specific versions of the same method. In this case, it’d be difficult to determine which version of that method the subclass will end up using. Python deals with this issue using a specific method resolution order (MRO). So, what is the method resolution order in Python? It’s an algorithm that tells Python how to search for inherited methods in a multiple inheritance context. Python’s MRO determines which implementation of a method or attribute to use when there are multiple versions of it in a class hierarchy. Python’s MRO is based on the order of parent classes in the subclass definition. For example, comes before in the class from the previous section. MRO also considers the inheritance relationships between classes. In general, Python searches for methods and attributes in the following order:\n• The superclass listed next, from left to right, up to the last superclass It’s important to note that the current class comes first in the search. Additionally, if you have multiple parents that implement a given method or attributes, then Python will search them in the same order that they’re listed in the class definition. To illustrate the MRO, consider the following sample class hierarchy: In this example, inherits from and , which inherit from . All the superclasses in the hierarchy define a different version of . Which of these versions will end up calling? To answer this question, go ahead and call on a instance: When you call on an instance of , you get on your screen. This means that Python found on the class first. That’s the version of that you end up calling. You ignore the versions from and . Note: Sometimes, you may run into complex inheritance relationships where Python won’t be able to create a consistent method resolution order. In those cases, you’ll get a pointing out the issue. You can check the current MRO of a given class by using the special attribute: In this output, you can see that Python searches for methods and attributes in by going through itself, then , then , then , and finally, , which is the base class of all Python classes. The attribute can help you tweak your classes and define the specific MRO that you want your class to use. The way to tweak this is by moving and reordering the parent classes in the subclass definition until you get the desired MRO. A mixin class provides methods that you can reuse in many other classes. Mixin classes don’t define new types, so they’re not intended to be instantiated but only inherited. You use their functionality to attach extra features to other classes quickly. You can access the functionality of a mixin class in different ways. One of these ways is inheritance. However, inheriting from mixin classes doesn’t imply an is-a relationship because these classes don’t define concrete types. They just bundle specific functionality that’s intended to be reused in other classes. To illustrate how to use mixin classes, say that you’re building a class hierarchy with a class at the top. From this class, you’ll derive classes like , , , and several others. Then you realize that all the subclasses of need methods that serialize their data into different formats, including JSON and pickle. With this in mind, you think of writing a class that takes care of this task. Here’s what you come up with: In this example, is the parent class, and is a mixin class that provides serialization functionality. The class inherits from both and . Therefore, it’ll inherit the and methods, which you can use to serialize instances of in your code. In this example, is a . However, it’s not a because this class doesn’t define a type of object. It’s just a mixin class that packs serialization capabilities. Note: Because of the method resolution order (MRO), which you learned about earlier, placing your mixin classes before the base classes on the list of parents is often necessary. It’s especially true for class-based views in the Django web framework, which uses mixins to modify the behavior of a base view class. Now your class is able to serialize its data using JSON and pickle formats. That’s great! Can you think of any other useful mixin classes? Up to this point, you’ve learned a lot about simple and multiple inheritance in Python. In the following section, you’ll go through some of the advantages of using inheritance when writing and organizing your code. Inheritance is a powerful tool that you can use to model and solve many real-world problems in your code. Some benefits of using inheritance include the following:\n• Reusability: You can quickly inherit and reuse working code from one or more parent classes in as many subclasses as you need.\n• Modularity: You can use inheritance to organize your code in hierarchies of related classes.\n• Maintainability: You can quickly fix issues or add features to a parent class. These changes will be automatically available in all its subclasses. Inheritance also reduces code duplication.\n• Polymorphism: You can create subclasses that can replace their parent class, providing the same or equivalent functionality.\n• Extensibility: You can quickly extend an exiting class by adding new data and behavior to its subclasses. You can also use inheritance to define a uniform API for all the classes that belong to a given hierarchy. This promotes consistency and leverages polymorphism. Using classes and inheritance, you can make your code more modular, reusable, and extensible. Inheritance enables you to apply good design principles, such as separation of concerns. This principle states that you should organize code in small classes that each take care of a single task. Even though inheritance comes with several benefits, it can also end up causing issues. If you overuse it or use it incorrectly, then you can:\n• Artificially increase your code’s complexity with multiple inheritance or multiple levels of inheritance\n• Face issues like the diamond problem where you’ll have to deal with the method resolution order\n• End up with fragile base classes where changes to a parent class produce unexpected behaviors in subclasses Of course, these aren’t the only potential pitfalls. For example, having multiple levels of inheritance can make your code harder to reason about, which may impact your code’s maintainability in the long term. Another drawback of inheritance is that inheritance is defined at compile time. So, there’s no way to change the inherited functionality at runtime. Other techniques, like composition, allow you to dynamically change the functionality of a given class by replacing its components.\n\nInheritance, and especially multiple inheritance, can be a complex and hard-to-grasp topic. Fortunately, inheritance isn’t the only technique that allows you to reuse functionality in object-oriented programming. You also have composition, which represents a has-a relationship between classes. Composition allows you to build an object from its components. The composite object doesn’t have direct access to each component’s interface. However, it can leverage each component’s implementation. Delegation is another technique that you can use to promote code reuse in your OOP code. With delegation, you can represent can-do relationships, where an object relies on another object to perform a given task. In the following sections, you’ll learn more about these techniques and how they can make your object-oriented code more robust and flexible. As you’ve already learned, you can use composition to model a has-a relationship between objects. In other words, through composition, you can create complex objects by combining objects that will work as components. Note that these components may not make sense as stand-alone classes. Favoring composition over inheritance leads to more flexible class designs. Unlike inheritance, composition is defined at runtime, which means that you can dynamically replace a current component with another component of the same type. This characteristic makes it possible to change the composite’s behavior at runtime. In the example below, you use composition to create an class from the and components: In this example, you build an class out of its components, and . The class provides horizontal movements, while the class represents the robot’s arm and provides vertical movement and welding functionality. Here’s how you can use in your code: Rotating body 20 degrees to the right... Great! Your robot works as expected. It allows you to move its body and arm according to your movement needs. It also allows you to weld different mechanical pieces together. An idea to make this robot even cooler is to implement several types of arms with different welding technologies. Then you can change the arm by doing something like . You can even add a method to your robot class. How does that sound as a learning exercise? Unlike inheritance, composition doesn’t expose the entire interface of components, so it preserves encapsulation. Instead, the composite objects access and use only the required functionality from their components. This characteristic makes your class design more robust and reliable because it won’t expose unneeded members. Following the robot example, say you have several different robots in a factory. Each robot can have different capabilities like welding, cutting, shaping, polishing, and so on. You also have several independent arms. Some of them can perform all those actions. Some of them can perform just a subset of the actions. Now say that a given robot can only weld. However, this robot can use different arms with different welding technologies. If you use inheritance, then the robot will have access to other operations like cutting and shaping, which can cause an accident or breakdown. If you use composition, then the welder robot will only have access to the arm’s welding feature. That said, composition can help you protect your classes from unintended use. Delegation is another technique that you can use as an alternative to inheritance. With delegation, you can model can-do relationships, where an object hands a task over to another object, which takes care of executing the task. Note that the delegated object can exist independently from the delegator. You can use delegation to achieve code reuse, separation of concerns, and modularity. For example, say that you want to create a stack data structure. You think of taking advantage of Python’s as a quick way to store and manipulate the underlying data. Here’s how you end up writing your class: In , you define a object called that can take its initial data from the argument. You’ll use this list to store the data in the containing , so you delegate all the operations related to storing, adding, and deleting data to this list object. Then you implement the typical operations, and . Note how these operations conveniently delegate their responsibilities on and , respectively. Your class has handed its operations over to the object, which already knows how to perform them. It’s important to notice that this class is pretty flexible. You can replace the list object in with any other object as long as it implements the and methods. For example, you can use a object from the module. Because you’ve used delegation to write your class, the internal implementation of isn’t visible or directly accessible in , which preserves encapsulation: The public interface of your class only contains the stack-related methods and , as you can see in the function’s output. This prevents the users of your class from using list-specific methods that aren’t compatible with the classic stack data structure. If you use inheritance, then your child class, , will inherit all the functionality from its parent class, : In this example, your class has inherited all the methods from . These methods are exposed as part of your class’s public API, which may lead to incorrect uses of the class and its instances. With inheritance, the internals of parent classes are visible to subclasses, which breaks encapsulation. If some of the parent’s functionality isn’t appropriate for the child, then you run the risk of incorrect use. In this situation, composition and delegation are safer options. Note: To learn more about creating custom list-like classes, check out the Custom Python Lists: Inheriting From vs tutorial. Finally, in Python, you can quickly implement delegation through the special method. Python calls this method automatically whenever you access an instance attribute or method. You can use this method to redirect the request to another object that can provide the appropriate method or attribute. To illustrate this technique, get back to the mixin example where you used a mixin class to provide serialization capabilities to your class. Here’s how to rewrite the example using delegation: In this new implementation, the serializer class takes the instance that provides the data as an argument. defines a method that uses the built-in function to access the methods in the class. For example, if you call on an instance of , then that call will be automatically redirected to calling on the instance of . Go ahead and try it out! This is a pretty cool Python feature. You’ve tried your hand at a quick example of delegation in Python to learn how a class can delegate some of its responsibilities to another class, achieving code reuse and separation of concerns. Again, you should note that this technique indirectly exposes all the delegated attributes and methods. So, use it with care. Dependency injection is a design pattern that you can use to achieve loose coupling between a class and its components. With this technique, you can provide an object’s dependencies from the outside, rather than inheriting or implementing them in the object itself. This practice allows you to create flexible classes that are able to change their behavior dynamically, depending on the injected functionality. In your robot example, you can use dependency injection to decouple the and classes from , which will make your code more flexible and versatile. In this new version of , you only made two small changes to . Now this method takes and as arguments and assigns their values to the corresponding instance attributes, and . This allows you to inject appropriate body and arm objects into the class so that it can do its work. Here’s how you can use with this new implementation: Rotating body 20 degrees to the right... Overall, the class’s functionality remains the same as in your first version. The only difference is that now you have to pass the body and arm objects to the class constructor. This step is a common way of implementing dependency injection. Now that you know about a few techniques that you can use as alternatives to inheritance, it’s time for you to learn about abstract base classes (ABCs) in Python. These classes allow you to define consistent APIs for your classes."
    },
    {
        "link": "https://pythonspot.com/encapsulation",
        "document": "Encapsulation is a fundamental concept in object-oriented programming (OOP). In a nutshell, encapsulation in Python allows us to restrict the access to certain methods and variables within the class, ensuring that the data is hidden and safe from any unintentional modifications. Dive into this guide to understand encapsulation in Python with examples.\n\nBoost Your Python Skills: Python Programming Bootcamp: Go from zero to hero.\n\nConsider the following scenario: We have a class, which consists of two main methods: and the private method . When we instantiate the class, the method gets executed.\n\nHowever, here’s the catch. You cannot invoke the private method ( ) directly using the object outside the class. Here’s how it’s done:\n\nExecuting the above program would give you:\n\n\n\nThe crux here is that encapsulation ensures accidental data access restrictions. Still, determined users can intentionally access it. Though the private methods appear hidden, they are simply renamed with the class name prefixed, like . Therefore, you can still access the method using .\n\nJust like methods, variables can be set as private. The beauty of private variables lies in their restricted access, ensuring they are modified only within the class methods, not outside. This is crucial for protecting vital application data.\n\nNow, what if you wish to modify a private variable? Use a setter method—a dedicated method designed to set or alter the value of private variables:\n\nSetter methods are handy. While some private variables might need occasional updates, others might not necessitate any changes.\n\nIn Python, encapsulation can be primarily categorized as:\n• Private Methods: Exclusive to their class, these begin with two underscores.\n• Private Variables: Restricted to their class or through specific methods (if provided), these also commence with two underscores.\n\nUnlike some other programming languages, Python doesn’t support protected class methods. By encapsulating data, you get superior control over how much coupling exists in your code. Essentially, it permits a class to evolve its implementation without impacting other code segments."
    },
    {
        "link": "https://stackoverflow.com/questions/4151320/efficient-circular-buffer",
        "document": "What would be more efficient (and why)?\n\nIs this an efficient way to use a list to collect values?\n\nI want to create an efficient circular buffer in python (with the goal of taking averages of the integer values in the buffer).\n\nAlthough there are already a great number of great answers here, I could not find any direct comparison of timings for the options mentioned. Therefore, please find my humble attempt at a comparison below. For testing purposes only, the class can switch between a -based buffer, a -based buffer, and a -based buffer. Note that the method adds only one value at a time, to keep it simple. import numpy import timeit import collections class CircularBuffer(object): buffer_methods = ('list', 'deque', 'roll') def __init__(self, buffer_size, buffer_method): self.content = None self.size = buffer_size self.method = buffer_method self.update = getattr(self, '_update_' + buffer_method) def _update_list(self, scalar): try: # shift self.content.append(scalar) self.content.pop(0) except AttributeError: # init self.content = [0.] * self.size def _update_deque(self, scalar): try: # shift self.content.append(scalar) except AttributeError: # init self.content = collections.deque([0.] * self.size, maxlen=self.size) def _update_roll(self, scalar): try: # shift self.content = numpy.roll(self.content, -1) self.content[-1] = scalar except IndexError: # init self.content = numpy.zeros(self.size, dtype=float) # Testing and Timing circular_buffer_size = 100 circular_buffers = [ CircularBuffer(buffer_size=circular_buffer_size, buffer_method=method) for method in CircularBuffer.buffer_methods ] timeit_iterations = 1e4 timeit_setup = 'from __main__ import circular_buffers' timeit_results = [] for i, cb in enumerate(circular_buffers): # We add a convenient number of convenient values (see equality test below) code = '[circular_buffers[{}].update(float(j)) for j in range({})]'.format( i, circular_buffer_size ) # Testing eval(code) buffer_content = [item for item in cb.content] assert buffer_content == list(range(circular_buffer_size)) # Timing timeit_results.append( timeit.timeit(code, setup=timeit_setup, number=int(timeit_iterations)) ) print( '{}: total {:.2f}s ({:.2f}ms per iteration)'.format( cb.method, timeit_results[-1], timeit_results[-1] / timeit_iterations * 1e3, ) ) On my system this yields: deque: total 0.87s (0.09ms per iteration) list: total 1.06s (0.11ms per iteration) roll: total 6.27s (0.63ms per iteration)\n\nHow about the solution from the Python Cookbook, including a reclassification of the ring buffer instance when it becomes full? class RingBuffer: \"\"\" class that implements a not-yet-full buffer \"\"\" def __init__(self,size_max): self.max = size_max self.data = [] class __Full: \"\"\" class that implements a full buffer \"\"\" def append(self, x): \"\"\" Append an element overwriting the oldest one. \"\"\" self.data[self.cur] = x self.cur = (self.cur+1) % self.max def get(self): \"\"\" return list of elements in correct order \"\"\" return self.data[self.cur:]+self.data[:self.cur] def append(self,x): \"\"\"append an element at the end of the buffer\"\"\" self.data.append(x) if len(self.data) == self.max: self.cur = 0 # Permanently change self's class from non-full to full self.__class__ = self.__Full def get(self): \"\"\" Return a list of elements from the oldest to the newest. \"\"\" return self.data # sample usage if __name__=='__main__': x=RingBuffer(5) x.append(1); x.append(2); x.append(3); x.append(4) print(x.__class__, x.get()) x.append(5) print(x.__class__, x.get()) x.append(6) print(x.data, x.get()) x.append(7); x.append(8); x.append(9); x.append(10) print(x.data, x.get()) The notable design choice in the implementation is that, since these objects undergo a nonreversible state transition at some point in their lifetimes—from non-full buffer to full-buffer (and behavior changes at that point)—I modeled that by changing . This works even in Python 2.2, as long as both classes have the same slots (for example, it works fine for two classic classes, such as RingBuffer and in this recipe). Changing the class of an instance may be strange in many languages, but it is a Pythonic alternative to other ways of representing occasional, massive, irreversible, and discrete changes of state that vastly affect behavior, as in this recipe. Good thing that Python supports it for all kinds of classes.\n\nLots of answers here but none subclass the Numpy ndarray as suggested by D Left Adjoint to U. This avoids using np.roll which does not scale efficiently, and passes on all the advantages of Numpy arrays like array slicing. Using Numpy arrays will allow for most analyses you need to run, including averaging. My solution subclasses np.ndarray using the guidelines written in the Numpy documentation. The RingArray is initialised with a specified shape, and filled with np.nan values. Itertools cycle is used to create a one dimensional cycle that gives the next row position to edit in the array. This is based on the height of the array during initialisation. An append method is added to the ndarray methods to write data over the next position in the cycle. class RingArray(np.ndarray): \"\"\"A modified numpy array type that functions like a stack. RingArray has a set size specified during initialisation. Add new data using the append() method, which will replace the next value in a cyclical fashion. The array itself has all the properties of a numpy array e.g. it can be sliced and accessed as normal. Initially fills the array with np.nan values. Options -------- shape : tuple A tuple of (height, width) for the maximum size of the array. Attributes ---------- Inherited from nd.array. Initially fills array with np.nan values. Methods -------- append(data) Add/replace data in the next element of the cycle. Data should be the length of the RingArray width. \"\"\" def __new__(subtype, shape): obj = super().__new__(subtype, shape) obj = np.vectorize(lambda x: np.nan)(obj) obj._pointer = cycle(np.arange(0, shape[0])) return obj # needed by numpy def __array_finalize__(self, obj): if obj is None: return # add data to the next element (looped) def append(self, data): \"\"\"Adds or replaces data in the RingArray. The function writes to the next row in the Array. Once the last row is reached, the assignment row loops back to the start. Parameters ---------- data : array_like Data should be the length of the RingArray width. \"\"\" self[next(self._pointer)] = data I believe this method scales at O(1), however I am not a computer scientist, so please correct me if I'm wrong! As this is a subclass of ndarray, all the methods from that class can be used on the RingArray. Removing or adding values with array functions like np.delete, will change the shape of the array. This will cause an errors with the cycle as it is set at initialisation. For this reason be cautious when editing the array by any other method than append(). This is my first stack overflow post, if there's anything I can improve upon please let me know :).\n\nI've had this problem before doing serial programming. At the time just over a year ago, I couldn't find any efficient implementations either, so I ended up writing one as a C extension and it's also available on pypi under an MIT license. It's super basic, only handles buffers of 8-bit signed chars, but is of flexible length, so you can use Struct or something on top of it if you need something other than chars. I see now with a google search that there are several options these days though, so you might want to look at those too.\n\nThis one does not require any library. It grows a list and then cycle within by index. The footprint is very small (no library), and it runs twice as fast as dequeue at least. This is good to compute moving averages indeed, but be aware that the items are not kept sorted by age as above. class CircularBuffer(object): def __init__(self, size): \"\"\"initialization\"\"\" self.index= 0 self.size= size self._data = [] def record(self, value): \"\"\"append an element\"\"\" if len(self._data) == self.size: self._data[self.index]= value else: self._data.append(value) self.index= (self.index + 1) % self.size def __getitem__(self, key): \"\"\"get element by index like a regular array\"\"\" return(self._data[key]) def __repr__(self): \"\"\"return string representation\"\"\" return self._data.__repr__() + ' (' + str(len(self._data))+' items)' def get_all(self): \"\"\"return a list of all the elements\"\"\" return(self._data) To get the average value, e.g.: This is about 1/3 the time of the equivalent with dequeue.\n\nThe original question was: \"efficient\" circular buffer. According to this efficiency asked for, the answer from aaronasterling seems to be definitively correct. Using a dedicated class programmed in Python and comparing time processing with collections.deque shows a x5.2 times acceleration with deque! Here is very simple code to test this: class cb: def __init__(self, size): self.b = [0]*size self.i = 0 self.sz = size def append(self, v): self.b[self.i] = v self.i = (self.i + 1) % self.sz b = cb(1000) for i in range(10000): b.append(i) # called 200 times, this lasts 1.097 second on my laptop from collections import deque b = deque( [], 1000 ) for i in range(10000): b.append(i) # called 200 times, this lasts 0.211 second on my laptop To transform a deque into a list, just use: You will then get O(1) random access to the deque items. Of course, this is only valuable if you need to do many random accesses to the deque after having set it once.\n\nI don't get the answers here. Obviously if you're working within NumPy, you'd want to subclass either array or ndarray (usually), that way (at least once your cyclic array is full) you can still use the NumPy array arithmetic operations on the cyclical array. The only thing you have to be careful of is that for operations that span multiple components (such as a moving average), you don't have your window be larger than what has accumulated in the buffer. Also, as all the commenters mentioned, don't use rolling as that defeats the purpose of efficiency. If you need a growing array, you simply double its size each time a resize is required (this is different from a cyclical array implementation)."
    },
    {
        "link": "https://linkedin.com/advice/3/what-best-practices-implementing-python-data-structures",
        "document": ""
    },
    {
        "link": "https://blog.devgenius.io/python-performance-optimization-a-comprehensive-guide-21bc4f40dcfd",
        "document": "Python, known for its simplicity and readability, has become one of the most popular programming languages in the world. However, with its ease of use comes a common misconception: Python is slow. While it’s true that Python may not be as fast as low-level languages like C or Rust out of the box, with the right optimization techniques, you can significantly boost your Python code’s performance.\n\nIn this comprehensive guide, we’ll dive deep into the world of Python performance optimization. Whether you’re a beginner looking to speed up your first Python project or an experienced developer aiming to squeeze every ounce of performance from your code, this article has something for you.\n\nImagine you’re building a web application that needs to handle thousands of requests per second. Or perhaps you’re developing a data analysis tool that processes gigabytes of information. In these scenarios and many others, the speed of your code can make the difference between a smooth, responsive application and a frustratingly slow one.\n\nPerformance optimization isn’t just about speed, though. It’s also about:\n• Resource Efficiency: Optimized code uses less memory and CPU power, allowing your applications to run on less powerful hardware or handle larger workloads with the same resources.\n• Cost Savings: In cloud environments, better performance often translates directly to lower costs, as you can serve the same number of users with fewer compute resources.\n• User Experience: Faster applications lead to happier users, higher engagement, and potentially increased revenue for businesses.\n• Scalability: Well-optimized code scales better, allowing your applications to grow and handle increased loads more gracefully.\n\nIn this guide, we’ll explore a wide range of optimization techniques, from basic principles to advanced strategies. Here’s a sneak peek at what you’ll learn:\n• Profiling Your Python Code: Before you can optimize, you need to know where the bottlenecks are. We’ll show you how to use profiling tools to identify performance issues.\n• Memory Management: Learn how Python manages memory and how you can write memory-efficient code.\n• Concurrency and Parallelism: Discover how to leverage multi-core processors to speed up your code.\n• Leveraging Built-in Functions and Libraries: Python’s standard library is a treasure trove of optimized functions. We’ll show you how to make the most of them.\n• Caching and Memoization: Learn how to avoid redundant computations and speed up your code with smart caching strategies.\n• Just-in-Time Compilation: Explore how tools like PyPy can give your Python code a significant speed boost.\n• C Extensions: For performance-critical parts of your code, we’ll show you how to tap into the speed of C.\n• Best Practices and Common Pitfalls: We’ll wrap up with a summary of best practices and common mistakes to avoid.\n\nBy the end of this guide, you’ll have a robust toolkit for optimizing your Python code, allowing you to write faster, more efficient applications.\n\nBefore diving into optimization techniques, it’s crucial to understand where your code is spending most of its time. This is where profiling comes in. Profiling is the process of measuring the performance of your code, helping you identify bottlenecks and areas that need improvement.\n\nImagine you’re a detective trying to solve a mystery. You wouldn’t jump to conclusions without gathering evidence first, right? Similarly, in the world of performance optimization, profiling is your evidence-gathering tool. It helps you:\n• Measure the impact of your optimization efforts\n\nPython comes with a built-in profiler called cProfile. It’s a powerful tool that provides detailed information about function calls, including how many times each function was called and how long it took to execute.\n\nHere’s how you can use cProfile:\n\nWhen you run this script, cProfile will output something like this:\n\nThis output tells us that is taking the most time (0.083 seconds), which is not surprising given the large loop it contains.\n\nWhile cProfile’s output is informative, it can be hard to digest for larger programs. This is where visualization tools like SnakeViz come in handy.\n• Run your script and save the profile:\n\nThis will open a web browser with an interactive visualization of your profile.\n\nSometimes, you need even more granular information. The package allows you to profile your code line by line. Here's how to use it:\n\n2. Decorate the function you want to profile with\n\nThis will output something like:\n\nThis output shows us that the loop (lines 6–7) is taking up 99.9% of the execution time, which is valuable information for optimization.\n\nIf you’re dealing with memory-intensive applications, the package can be incredibly useful.\n\nThis will output memory usage line by line:\n\nThis shows us exactly how much memory each line of code is using.\n• Profile in a realistic environment: Make sure your profiling setup mimics your production environment as closely as possible.\n• Use representative data: Profile with data that’s similar in size and structure to what you’ll be dealing with in production.\n• Profile regularly: As your codebase evolves, so will its performance characteristics. Regular profiling helps catch performance regressions early.\n• Don’t optimize prematurely: Use profiling to guide your optimization efforts. Focus on the parts of your code that are actually slow, not the parts you think might be slow.\n\nBy mastering these profiling techniques, you’ll be well-equipped to identify performance bottlenecks in your Python code. In the next sections, we’ll explore various optimization techniques to address these bottlenecks.\n\nNow that we’ve learned how to profile our Python code, let’s dive into specific techniques for optimizing it. We’ll cover efficient data structures, algorithmic improvements, and loop optimization strategies.\n\nChoosing the right data structure can significantly impact your code’s performance. Let’s look at some common scenarios:\n\nLists vs. Sets for Membership Testing\n\nWhen you need to frequently check if an item is in a collection, sets are much faster than lists.\n\nDictionaries for Fast Lookups\n\nWhen you need to associate keys with values and perform frequent lookups, dictionaries are your best friend.\n\nDictionary lookups are much faster, especially for large datasets.\n\nOften, the biggest performance gains come from improving the underlying algorithm. Let’s look at an example:\n\nBy optimizing the algorithm to only check up to the square root of the number, we’ve significantly reduced the execution time.\n\nLoops are often a source of performance bottlenecks. Here are some techniques to optimize them:\n\nList Comprehensions\n\nList comprehensions are often faster than traditional for loops:\n\nGenerator Expressions\n\nWhen you don’t need the entire list in memory at once, generator expressions can be more memory-efficient:\n\nAvoiding Unnecessary Work in Loops\n\nAlways try to move operations that don’t need to be repeated outside the loop:\n\nBy binding the math functions outside the loop, we avoid repeated attribute lookups, resulting in a performance improvement.\n\nFor numerical computations, using NumPy’s vectorized operations can dramatically improve performance:\n\nNumPy’s vectorized operations are implemented in C, making them much faster than pure Python loops for large numerical computations.\n\nUnderstanding how Python manages memory is crucial for writing efficient, scalable code. In this section, we’ll explore Python’s memory management system and techniques to optimize memory usage.\n\nPython uses a private heap space to manage memory. All Python objects and data structures are located in this heap. The Python memory manager handles the allocation and deallocation of this heap space.\n• Reference Counting: Python keeps track of how many references point to an object. When the reference count drops to zero, the object is deallocated.\n• Garbage Collection: For handling circular references, Python uses a garbage collector that periodically frees unreachable objects.\n• Memory Pooling: For small objects, Python uses an internal object allocator that pre-allocates memory pools for future use.\n\n1. Use Generators for Large Datasets\n\nWhen dealing with large datasets, generators can help reduce memory usage:\n\nThe generator version doesn’t create the entire list in memory, instead generating values on-the-fly.\n\n2. Utilize for Classes with Many Instances\n\nFor classes with many instances, using can significantly reduce memory usage:\n\neliminates the need for a for each instance, reducing memory usage.\n\n3. Use to Remove Unnecessary References\n\nExplicitly deleting objects when they’re no longer needed can help free up memory:\n\n4. Avoid Creating Unnecessary Objects\n\nReuse objects when possible, especially in loops:\n\n5. Use Memory-Efficient Data Structures\n\nChoose appropriate data structures based on your use case:\n• Use instead of for membership testing\n• Use instead of for immutable sequences\n• Consider using for homogeneous numerical data\n• For large datasets, consider using libraries like NumPy or Pandas\n\nTo optimize memory usage, it’s crucial to monitor it. Here are some tools:\n\n1. memory_profiler: We introduced this in the profiling section. It’s great for line-by-line memory usage analysis.Monitoring Memory Usage\n\n2. psutil: A cross-platform library for retrieving information on running processes and system utilization.\n• Use generators and iterators for large datasets\n• Use weak references when appropriate\n• Regularly test your application’s memory usage under various conditions\n\nBy applying these techniques and best practices, you can significantly reduce your Python application’s memory footprint, leading to more efficient and scalable code.\n\nIn today’s multi-core computing environment, leveraging concurrency and parallelism can significantly boost your Python code’s performance. Let’s explore how to use these techniques effectively.\n• Concurrency: Dealing with multiple tasks at the same time (not necessarily executing simultaneously).\n\nPython offers several ways to implement both concurrency and parallelism.\n\nPython’s threading module is useful for I/O-bound tasks. Due to the Global Interpreter Lock (GIL), threads in Python don’t achieve true parallelism for CPU-bound tasks.\n\nHere’s an example of using threads for concurrent downloads:\n\nFor CPU-bound tasks, the multiprocessing module allows you to leverage multiple cores:\n\nFor I/O-bound tasks, asyncio provides a way to write asynchronous code:\n• Use threading for I/O-bound tasks with blocking operations.\n• Use multiprocessing for CPU-bound tasks to leverage multiple cores.\n• Use asyncio for I/O-bound tasks with support for asynchronous operations.\n• Avoid Race Conditions: Use locks or other synchronization primitives when multiple threads access shared resources.\n• Be Mindful of the GIL: For CPU-bound tasks, use multiprocessing instead of threading.\n• Use Process Pools: For better control over resource usage, use process pools instead of spawning processes manually.\n• Consider the Overhead: Creating processes is more expensive than creating threads. For short-lived tasks, the overhead might outweigh the benefits.\n• Use Async Libraries: When using asyncio, prefer libraries that support asynchronous operations (like aiohttp instead of requests).\n• Profile Your Concurrent Code: Use tools like cProfile or line_profiler to ensure your concurrent code is actually improving performance.\n• Combining Approaches: You can combine multiprocessing with threading or asyncio for complex scenarios.\n• Using Queues: For producer-consumer scenarios, use Queue (for threading) or multiprocessing.Queue.\n• Considering Alternative Implementations: Look into libraries like concurrent.futures for a higher-level interface to asynchronous execution.\n\nBy effectively using concurrency and parallelism, you can significantly improve your Python code’s performance, especially for I/O-bound and CPU-bound tasks.\n\nPython’s standard library is rich with built-in functions and libraries that are optimized for performance. Using these effectively can significantly boost your code’s speed and efficiency.\n\nPython’s built-in functions are implemented in C, making them much faster than equivalent functions written in Python. Here are some examples:\n\n1. vs. List Comprehension\n\nWhile list comprehensions are often preferred for readability, can be slightly faster for simple operations:\n\n2. vs. Manual Loop\n\nThe built-in function is significantly faster than a manual loop:\n\n1. Collections Module\n\nThe module provides specialized container datatypes that can be more efficient than Python's general-purpose built-in containers.\n\n2. Itertools Module\n\nThe module provides a collection of fast, memory-efficient tools for creating iterators for efficient looping.\n\nWhile not built-in, some third-party libraries offer significant performance improvements:\n\n1. NumPy for Numerical Operations\n\nNumPy provides a powerful N-dimensional array object and tools for working with these arrays. It’s much faster than pure Python for numerical operations.\n\n2. Pandas for Data Manipulation\n\nPandas is built on top of NumPy and provides high-performance, easy-to-use data structures and data analysis tools.\n• Know Your Standard Library: Familiarize yourself with Python’s standard library. Often, there’s a built-in function or module that can do what you need more efficiently.\n• Profile First: Always profile your code to identify bottlenecks before optimizing.\n• Readability Counts: Don’t sacrifice code readability for minor performance gains. Clear, maintainable code is often more valuable than slightly faster, but obscure code.\n• Stay Updated: Keep your Python version and libraries up-to-date. Newer versions often include performance improvements.\n• Consider the Trade-offs: Sometimes, using a specialized library like NumPy or Pandas requires restructuring your code. Ensure the performance gain is worth the effort.\n\nBy effectively utilizing Python’s built-in functions and libraries, you can often achieve significant performance improvements with minimal effort.\n\nCaching and memoization are powerful techniques for optimizing Python code, especially when dealing with expensive computations or repetitive function calls. These methods can significantly reduce execution time by storing and reusing previously computed results.\n• Memoization: A specific form of caching that involves storing the return values of a function based on its parameters.\n\n1. Manual Memoization\n\nLet’s start with a simple example of manual memoization:\n\n2. Using Python’s Python’s standard library provides the decorator, which implements memoization with a Least Recently Used (LRU) cache:\n\n1. Simple In-Memory Cache\n\nHere’s an example of a simple in-memory cache for a web scraping function:\n\n2. Using Library\n\nFor more advanced caching needs, the library provides various cache implementations:\n\nBest Practices for Caching and Memoization\n• Identify Suitable Candidates: Use caching for pure functions (same input always produces same output) and expensive computations.\n• Choose Appropriate Cache Size: For , set a that balances memory usage and performance gains.\n• Consider Cache Eviction Policies: LRU (Least Recently Used) is common, but other policies might be more suitable for specific use cases.\n• Be Aware of Memory Usage: Caching trades memory for speed. Monitor memory usage, especially for large caches.\n• Use Time-based Expiration: For data that becomes stale, implement time-based cache expiration.\n• Thread Safety: Ensure your caching mechanism is thread-safe if used in a multi-threaded environment.\n• Monitoring and Logging: Implement logging to monitor cache hit rates and performance improvements.\n\nWhen to Use Caching vs. Memoization\n• Results that are expensive to compute but may change over time\n• Scenarios where you need more control over cache size and eviction policies\n\nBy effectively using caching and memoization, you can significantly improve your Python code’s performance, especially for computationally expensive operations or frequently accessed data.\n\nPyPy is an alternative implementation of Python that includes a Just-in-Time (JIT) compiler. It can significantly improve the performance of many Python programs without requiring changes to the source code.\n• JIT Compilation: A technique that compiles frequently executed parts of the code to machine code at runtime.\n• It identifies “hot spots” — parts of the code that are executed frequently.\n• These hot spots are then compiled to machine code for faster execution.\n• The compiled code is used in subsequent runs, improving overall performance.\n\nLet’s compare the performance of CPython (standard Python) and PyPy with a simple example:\n\nSave this as and run it with both CPython and PyPy:\n\nAs we can see, PyPy provides a significant speedup for this recursive function.\n\nWhen to Use PyPy\n\nPyPy is particularly effective for:\n• Long-running programs: The longer the program runs, the more time PyPy has to optimize it.\n• Pure Python code: PyPy works best with pure Python implementations rather than C extensions.\n• Startup Time: PyPy may have a longer startup time due to its JIT warmup.\n• Memory Usage: PyPy often uses more memory than CPython.\n• C Extension Compatibility: Not all C extensions are compatible with PyPy.\n• Standard Library Differences: Some parts of the standard library might behave slightly differently.\n\nBest Practices for Using PyPy\n• Profile First: Always profile your code to identify if PyPy will provide significant benefits.\n• Test Thoroughly: Ensure your code works correctly under PyPy, as there might be subtle differences.\n• Consider Warmup Time: For short-running scripts, the JIT warmup might negate performance gains.\n• Use PyPy-compatible Libraries: Prefer pure Python libraries or those known to work well with PyPy.\n• Monitor Memory Usage: Keep an eye on memory consumption, especially for long-running processes.\n\nLet’s compare the performance of a simple web server using CPython and PyPy:\n\nSave this as and run it with both CPython and PyPy. Then, use a benchmarking tool like Apache Bench to test its performance:\n\nYou might see results similar to this:\n\nThis demonstrates how PyPy can significantly improve the performance of a web server without any code changes.\n\nPyPy offers a powerful way to boost Python performance, especially for CPU-intensive and long-running applications. While it’s not a universal solution, it can provide substantial speedups in many scenarios with minimal effort. Always profile your specific use case to determine if PyPy is the right choice for your project.\n\nWhile Python is excellent for rapid development and ease of use, there are times when you need the raw speed of lower-level languages like C. Python allows you to create C extensions, which can significantly boost performance for computationally intensive tasks.\n\nWhy Use C Extensions?\n• Speed: C code runs much faster than Python for CPU-bound tasks.\n• Memory Efficiency: C allows fine-grained control over memory usage.\n• Access to C Libraries: You can wrap existing C libraries for use in Python.\n• GIL Bypass: C extensions can release the Global Interpreter Lock (GIL), allowing true multi-threading.\n\nLet’s create a simple C extension that calculates the factorial of a number.\n\n4. Now you can use the C extension in Python:\n\nAs we can see, the C extension is significantly faster than the pure Python implementation.\n\nBest Practices for C Extensions\n• Profile First: Only move code to C if it’s a proven bottleneck.\n• Keep It Simple: Start with simple C extensions and gradually increase complexity.\n• Handle Errors: Properly handle errors and exceptions in your C code.\n• Release the GIL: Use and for long-running computations.\n• Memory Management: Be careful with memory allocation and deallocation.\n• Type Checking: Always check types of input arguments in your C functions.\n• Documentation: Provide clear documentation for your C extension functions.\n\nUsing Cython for Easier C Extensions\n\nCython is a superset of Python that compiles to C, making it easier to create C extensions. Here’s the factorial example using Cython:\n\nWhen to Use C Extensions\n• Low-Level System Access: When you need fine-grained control over system resources.\n• Wrapping Existing C Libraries: To use powerful C libraries in Python.\n• Performance-Critical Sections: When a small part of your code is causing a significant bottleneck.\n• Complexity: C extensions are more complex to write and maintain than Python code.\n• Portability: C extensions may need to be compiled for different platforms.\n• Debugging: Debugging C extensions can be more challenging than Python code.\n• Safety: Improper C code can lead to segmentation faults and memory leaks.\n\nBy judiciously using C extensions for performance-critical parts of your code, you can significantly boost the overall performance of your Python applications while maintaining the ease of use and rapid development that Python provides for the majority of your codebase.\n\nAs we conclude our exploration of Python performance optimization, it’s crucial to summarize the best practices we’ve discussed and highlight common pitfalls to avoid. This section will serve as a comprehensive guide to help you write efficient, optimized Python code.\n• Always measure performance before and after optimization attempts.\n• Use tools like cProfile, line_profiler, and memory_profiler to identify bottlenecks.\n• Choose the right data structure for your use case (e.g., sets for membership testing, dictionaries for fast lookups).\n• Use built-in functions and standard library modules when possible.\n• Consider specialized libraries like NumPy for numerical operations.\n• Use list comprehensions, generator expressions, and other Pythonic constructs.\n• Generators can help manage memory for large datasets.\n• Consider using for simple cases.\n• Move operations that don’t change out of loops.\n• Use instead of manual indexing.\n• Don’t optimize before you have a working solution and performance metrics.\n• Remember Donald Knuth’s advice: “Premature optimization is the root of all evil.”\n• Many developers reinvent the wheel instead of using built-in functions or standard library modules.\n• Global variables can make code harder to understand and maintain.\n• They can also lead to unexpected behavior in multithreaded environments.\n• Using for repeated string concatenation is inefficient.\n• Use or f-strings instead.\n• Failing to close files, database connections, or other resources can lead to resource leaks.\n• Wrapping large blocks of code in try-except can hide bugs and impact performance.\n• Be specific about which exceptions you’re catching.\n• The Global Interpreter Lock (GIL) can limit performance gains in CPU-bound multithreaded code.\n• Consider multiprocessing or asyncio for CPU-bound tasks.\n• Creating large temporary objects or holding onto data longer than necessary can lead to memory issues.\n• Use generators and context managers to manage memory efficiently.\n• Outdated libraries may have performance issues that have been fixed in newer versions.\n• Regularly update your dependencies, but be sure to test thoroughly after updates.\n\nBy following these best practices and avoiding common pitfalls, you can write more efficient, performant Python code. Remember, the key to optimization is always to measure, optimize the bottlenecks, and then measure again to confirm the improvements.\n\nThroughout this comprehensive guide on Python Performance Optimization, we’ve explored a wide range of techniques and strategies to enhance the efficiency and speed of your Python code. Let’s recap the key points and provide some final thoughts on the journey of optimization.\n• Profiling is Essential: Always start your optimization journey with profiling. Tools like cProfile, line_profiler, and memory_profiler are invaluable for identifying bottlenecks in your code.\n• Algorithmic Efficiency Matters: Often, the most significant performance gains come from improving the underlying algorithm. Big O notation is a crucial concept for understanding algorithmic efficiency.\n• Leverage Python’s Strengths: Python offers many built-in functions and data structures that are optimized for performance. Familiarize yourself with the standard library and use it to your advantage.\n• Data Structures are Crucial: Choosing the right data structure for your specific use case can lead to dramatic performance improvements. Remember that sets are faster for membership testing, and dictionaries provide fast lookups.\n• Concurrency and Parallelism: For I/O-bound tasks, consider using asyncio or threading. For CPU-bound tasks, multiprocessing can help utilize multiple cores effectively.\n• Memory Management: Efficient memory usage is key to performance. Use generators for large datasets, and be mindful of memory leaks.\n• Caching and Memoization: These techniques can significantly speed up functions with expensive computations, especially when dealing with recursive algorithms or repeated function calls.\n• Just-in-Time Compilation: Tools like PyPy can offer substantial speed improvements for long-running Python programs without requiring code changes.\n• C Extensions: For performance-critical parts of your application, consider writing C extensions or using Cython to get close-to-C performance.\n• Best Practices and Pitfalls: Always write readable, maintainable code. Avoid premature optimization and be aware of common pitfalls like global variable misuse and inefficient string concatenation.\n\nOptimization is not a one-time task but an ongoing process. As you develop your Python applications, keep these principles in mind:\n• Measure, Don’t Guess: Always base your optimization efforts on concrete profiling data rather than assumptions.\n• Readability First: Maintain code readability and clarity. An overly optimized but unreadable piece of code can become a maintenance nightmare.\n• Incremental Improvements: Focus on making small, measurable improvements rather than trying to optimize everything at once.\n• Know When to Stop: Optimization can be a rabbit hole. Know when your code is “fast enough” for your specific use case.\n• Stay Updated: Python and its ecosystem are constantly evolving. Stay informed about new features and libraries that could help improve performance.\n\nAs we look to the future, several trends are shaping the landscape of Python performance:\n• Improved Concurrency: Projects like asyncio are continually evolving, making concurrent programming in Python more accessible and efficient.\n• JIT Advancements: Ongoing improvements in Just-in-Time compilation, both in PyPy and potentially in CPython, promise to boost performance further.\n• Machine Learning Optimizations: With Python’s prominence in data science and machine learning, expect more optimizations tailored for these domains.\n• Type Hinting and Static Analysis: As type hinting becomes more prevalent, it opens doors for better static analysis and potential performance optimizations.\n• Hardware Acceleration: Increased support for GPU acceleration and other specialized hardware could lead to significant performance gains in specific domains.\n\nPerformance optimization in Python is a blend of art and science. It requires a deep understanding of the language, its ecosystem, and the principles of computer science. However, it’s important to remember that premature optimization can lead to unnecessary complexity and bugs.\n\nThe best approach is to write clear, idiomatic Python code first, then optimize based on profiling results and specific performance requirements. By applying the techniques and principles discussed in this guide, you’ll be well-equipped to create Python applications that are not only functional and maintainable but also performant and efficient.\n\nRemember, the goal of optimization is not just to make your code faster, but to make it fast enough to meet your specific needs while maintaining readability and reliability. Happy optimizing!"
    },
    {
        "link": "https://thingsdaq.org/2023/04/18/circular-buffer-in-python",
        "document": "A circular or ring buffer is a fixed-size data structure that is commonly used in real-time software applications to store a pre-defined number of values. The analogy of a ring with a fixed number of positions is quite useful to capture the FIFO (First-In-First-Out) nature of such data structure. Once the buffer is full, the first element that was written (“In” ) to the buffer is the first one to be overwritten (“Out”) by the next incoming element.\n\nCircular buffers are particularly useful in situations where the data is continuously being sampled and calculations need to be done using a pre-defined sample size or continuous visualization is required.\n\nThe two images below represent a circular buffer with 10 positions. On the left, with four elements written to it being 5 the “first in”. On the right, the buffer is full where the value 3 was written. Note how the current write position pointer moves around as new values are added.\n\nAdditionally, a ring buffer has basically two states: not-yet- full (left image) and full (right image). The not-yet-full state occurs after the buffer is initialized and exists only until it becomes full. We will see later how this affects the Python code used to represent the buffer.\n\nOnce the buffer state changes to full, the FIFO nature of this type of data structure becomes evident. In the next two images, the next element “in” is the value 12, replacing the “first in” value 5, which therefore is the “first out”. The next value “in” is 2, replacing the “second in” value 10, and so on.\n\nIn the example figures above, we could imagine the buffer being used to display the average value of its elements (once the buffer reaches the full state). As time progresses, a new sample is written to the buffer, replacing the oldest sample. Each figure of the full buffer is a snapshot at a given time step of the sampling process. In this case the average values are 6.4, 7.1, and 6.3.\n\nThe most elegant way to implement the circular buffer is by using a class. Also, a true circular buffer does not involve shifting its elements to implement the FIFO structure. The current position pointer is used to keep track of where the newest element is.\n\nThe circular buffer class should have the following attributes:\n• : the number of elements that the circular buffer can hold (integer)\n• : the list of elements, i.e., the buffer itself\n\nThe class should also have two methods:\n• : writes an element to the buffer\n\nLet’s go over some of the features of the Python implementation below:\n• As mentioned earlier, the ring buffer has two states (not-yet-full and full). The first state only exists for a limited time until the buffer is filled up. With that in mind, it makes sense to define the class within the class with the exact same methods. Once the buffer is full, the original class is permanently changed to the full class implementation, with its and methods now superseding the original ones.\n• The not-yet-full method just does a regular list append operation of new elements to the buffer list. It is also in this method that the class is changed to the class once the buffer reaches its capacity.\n• The full method, on the other hand, writes the new element at the current (newest) element position and increments the current position by one unit (wrapping it around, or resetting it, once the buffer size value is reached).\n• More interesting however is the full method. It splits the list at the current position into two lists which are then concatenated. The list going from to the last element goes first, then comes the list from the first element to (excluded). By returning this concatenated list, the method fully implements the circular buffer without shifting any of it elements! Inspect the attribute as you add elements to a full buffer to see what the original list looks like.\n\n\"\"\" Add an element overwriting the oldest one. \"\"\" \"\"\" Add an element at the end of the buffer\"\"\" \"\"\" Return a list of elements from the oldest to the newest. \"\"\"\n\nThe output shown next is produced if the code containing the class is executed. The values and the states of the ring buffer shown in the figures at the beginning of the post are recreated in an iterative process that simulates some data acquisition. Note how the ring buffer class changes once the buffer is full.\n\nAs a final remark, in the Pulse Rate Monitor post, the buffer that was used is not a true circular buffer, since the elements in the arrays are shifted by one position for every new value being sampled. Because the buffer is relatively small (200 elements) and the sampling period of the data is reasonably large (0.1s) this solution does not constitute a problem. You can check out the code that implements a true ring buffer for the monitor on my GitHub page."
    },
    {
        "link": "https://reddit.com/r/pythontips/comments/149qlts/some_quick_and_useful_python_memory_optimization",
        "document": "Here are some quick and unique Python memory optimization tips:\n• Use generator expressions or list comprehensions instead of creating temporary lists.\n• Utilize built-in functions like map(), filter(), and zip() for memory-efficient data processing.\n• Consider using sys.getsizeof() to measure the memory consumption of objects and optimize accordingly.\n• Take advantage of lazy evaluation using iterators or generators to avoid unnecessary memory allocation.\n• Avoid unnecessary copying of objects by using in-place operations or views.\n• Dispose of large objects or data structures when they are no longer needed using del statements.\n• Use efficient data structures like sets or dictionaries for membership or uniqueness checks.\n• Consider using memory-mapped files or streaming techniques for handling large files instead of loading them entirely into memory.\n• Optimize memory usage when working with recursive functions by using tail recursion or converting them into iterative solutions.\n• Profile your code using tools like memory_profiler to identify memory-intensive areas and optimize them.\n\nBy applying these memory optimization tips, you can reduce memory consumption, improve performance, and make your Python code more efficient."
    }
]