[
    {
        "link": "https://st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_UART",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what is UART and how to use it through examples\n\nThe universal synchronous/asynchronous receiver transmitter (USART/UART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. USART can operate with a very wide range of baud rates using a programmable baud rate generator.\n\n It supports synchronous one-way communication and half-duplex single-wire communication, as well as multiprocessor communications. It also supports the LIN (Local Interconnect Network), Smartcard protocol and IrDA (Infrared Data Association) SIR ENDEC specifications and Modem operations (CTS/RTS).\n\n High speed data communication is possible by using the DMA (direct memory access) for multibuffer configuration. Also, the UART can be used with interrupt.\n\n This article goes through the following UART features: \n\n\n\nLearn how to set up UART and generate code with STM32CubeIDE and how to use HAL functions. \n\n\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n• Select NUCLEO-L476RG board using Board Selector as shown in the figure below:\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n• Initialize all peripherals with their default settings.\n\n\n\nAnswer “Yes” to initialize all peripherals with their default mode? Popup as below:\n• Configure Parameter Settings as shown in the figure below: \n\n\n\nTo select the correct GPIOs pins, it is necessary to refer to the datasheet. Look for the alternate function table. \n\n STM32L476 USART1 uses PA9 for transmission (TX) and PA10 for reception (RX) as shown below:\n\n\n\n \n\n\n\n PA9 and PA10 should be configured as follows:\n\n\n\n \n\n\n\n\n\nYou will need a pair of boards, one will act as transmitter and the other as receiver. \n\n The two boards should be connected as follows: \n\n\n\nFirst of all, build your project \n\n Connect the first NUCLEO-L476RG board. It will act as the TX board in this example.\n\n Then, run your program \n\n The debug configurations window will open. Rename your configuration as UART Debug TX.\n\n\n\n \n\n\n\n In the debugger tab, click ST-LINK S/N and scan. A number will appear: this is your TX board ST-LINK serial number used to indicate that this debug configuration is related to this specific board.\n\n\n\n \n\n\n\n Click OK and the program will run autonomously on the TX board.\n\n\n\n Now, connect the second NUCLEO-L476RG board. It will act as the RX board in this example. Let's go through the code for this board. \n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\nFirst, we need to create a new debug configuration for the RX board.\n\n Click the little arrow of the debug button and click Debug Configurations... Then click the New launch configuration button.\n\n\n\n \n\n\n\nRename this configuration as UART Debug RX. Just as we did for the previous configuration, in the debugger tab, click ST-LINK S/N and scan. Make sure to select the new serial number that appears: it belongs to the RX board we just connected.\n\nThen click Debug.\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Now hover over rx_buff[] to monitor its value.\n\n\n\n Alternatively, you can add rx_buff to Expressions, on the right side of STM32CubeIDE. \n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Enable USART1 global interrupt.\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_IT to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value. \n\n\n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Add the DMA request as shown in the figure below:\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_DMA to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value."
    },
    {
        "link": "https://github.com/electricui/stm32-dma-uart-eui",
        "document": "This example firmware demonstrates using DMA for both rx and tx for minimal CPU load during transfers, and is 100% compatible with the Electric UI Quickstart Tutorial.\n\nFor a loopback example without Electric UI integration refer to 796ce88.\n\nDMA (Direct Memory Access) lets the microcontroller's peripherals transfer data to/from memory specified by the firmware developer, rather than making the developer read data out of registers manually.\n\nDMA lets our USART/UART operate much efficiently than the more typical polling or per-byte interrupt based methods, as it seamlessly handles inbound and output transfers in the background with occasional interrupts when:\n• or the serial line has been idle for >1 frame!\n\nThis means the microcontroller isn't doing any work while data transfers, other than occasionally ensuring the buffer's don't overflow!\n\nAs a result, DMA transfers give one of the best UART experiences with Electric UI, with measured roundtrip heartbeat latency/jitter of at 115200 baud. For reference, an Arduino Mega is about 6x slower, , for the same baudrate.\n\nThe actual time between the rx Idle Line interrupt firing at the end of the inbound packet, and the response packet's DMA transfer starting was measured around .\n• Hardware used was the ol' faithful green STM32F4 Discovery Board, .\n• Connect an external USB-UART adaptor to / (and ground).\n• The board is configured to run at baud by default.\n• The orange led, on , is used as a blinker for the standard example.\n\nThis example is setup against the , but because it uses the ST HAL, changing to different F4 parts isn't too hard.\n• If you're using , change the to match your part i.e .\n• Ensure your linker file file matches your micro, as your part might have more/less RAM and flash.\n• Adjust the USART peripheral in use, GPIO pins, and LED pin as required for your development board.\n\nThis project was created with CubeMX (.ioc file included), but the are heavily modified. The project was exported for SW4STM32, but imported and edited with CLion.\n• The library isn't included in this repo.\n• Either download the zip from GitHub and put the contents in .\n• Import the project into your IDE, or build using CMake.\n• Configure the build target as required for your IDE.\n• Build and flash the project to the devboard.\n\nPre-built binaries for the are in .\n\nTilen Majerle's USART DMA examples are the best available resource for DMA USART on the STM32, this project basically combined several examples with some cleanup."
    },
    {
        "link": "https://reddit.com/r/stm32f4/comments/95406y/documentation_on_hal_libraries_functions",
        "document": "Some of the programming software I use (mainly game development) is extremely well documented. To the point where you can type a function in the help search and it will pull up the function, it's definitions, variables to parse along with their descriptions and other useful information about it.\n\nI'm having trouble finding something of the same sort for the HAL libraries. All I have to go on with is the function description that pops up in Keil, when you pause a mouse over it.\n\nGoogling doesn't help either, I get more Stack Overflow questions and forum posts than documentation links.\n\nFor example I thought that this would be the documentation for the uart functions in HAL:\n\nBut it seems to only describe and showcase the code underneath the hood of the library, as opposed to the surface functions you're supposed to use in your projects. Am I missing something here?\n\nThe function I'm interested to look up the description for is:\n\nI see it mentioned nowhere on that page that is supposed to describe the functions of hal uart library... could it be an outdated or newly updates function list and I'm using something old?\n\nYou can right click on the function in Keil and pick \"Go To Dfinition Of \"FUNCTION NAME HERE\" and the description is literally written there in comment ssections."
    },
    {
        "link": "https://controllerstech.com/stm32-uart-4-receive-data-using-dma",
        "document": "This is the 4th tutorial in the series on the UART peripheral of STM32 Microcontrollers. In this series we will cover different ways of transmitting and receiving data over the UART protocol. We will also see different UART modes available in the STM32 microcontrollers and how to use them. In the previous tutorial we saw how to receive the data over the UART in blocking mode and using the interrupt. Today we will continue receiving the data, but we will use the DMA to do so. DMA is generally used when we need to receive a large amount of data. The DMA bus is a separate unit and hence the data transfer does not utilize the CPU. Instead the CPU can be used to handle the other tasks. In today’s tutorial, we will use the DMA in normal mode and also in the circular mode. I will demonstrate some scenarios under which we will use these different modes to receive a large data via the UART. Let’s assume a case where we want to receive a large amount of data, and our MCU has enough RAM to store that data into a buffer. We can use the DMA in NORMAL mode to receive this data over the UART and then store the data into the buffer. A situation like this can work for few kilobytes of data as most of the STM32 MCUs has RAM in few kilobytes. But if you want to store an audio file or a video file, then you can’t afford to use a single buffer. I will use 2 kilobytes of data to demonstrate how to receive the data using the DMA in normal mode and store the data in a buffer. Below is the cubeMX configuration to enable the UART DMA in normal mode. The DMA request is set for USART2_RX as we are receiving the data via the DMA. The data width is Byte as the UART transfers the data in bytes. The DMA mode is set as Normal. The rest of the UART configuration is same as the previous tutorials with Baud Rate of 115200 with 8 data bits, 1 stop bit and no parity. We need to know the size of the incoming data. So the sender should first send 4 bytes of the size data followed by the data itself. If you are receiving larger data, you can change the length of the size data bytes. In the main function, we will set the DMA to receive 4 data bytes for the size. The function HAL_UART_Receive_DMA is used to receive 4 data bytes. Once all the 4 bytes has been received, the interrupt will trigger and the UART Receive Complete Callback will be called. int isSizeRxed = 0; uint16_t size = 0; void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if (isSizeRxed == 0) { size = ((RxData[0]-48)*1000)+((RxData[1]-48)*100)+((RxData[2]-48)*10)+((RxData[3]-48)); isSizeRxed = 1; HAL_UART_Receive_DMA(&huart2, RxData, size); } else if (isSizeRxed == 1) { isSizeRxed = 0; HAL_UART_Receive_DMA(&huart2, RxData, 4); } } The callback will be first called when the 4 size bytes are received. The isSizeRxed variable was 0 in the beginning so we calculate the size using the 4 bytes of the RxData buffer. The size bytes were transferred in the Ascii form and hence we need to subtract 48 to convert them to integer equivalent. After calculating the size, we will set the variable isSizeRxed to 1 so that we don’t enter this loop again. Then we will call the function HAL_UART_Receive_DMA to receive the required number of data bytes as calculated by the size variable. Once all the required number of data bytes has been received, we will enter this function again. This time the variable isSizeRxed is set to 1, so the else condition will execute. Here we will reset the variable isSizeRxed to 0 and receive the 4 size bytes. This will make this entire loop to run forever. Now we can receive the large data of any size, but it should be less than 4KB. This is because we have defined a buffer of 4KB to store the data. Although we need to send the size first, followed by the data itself. Below are the images showing the data sent by the serial console and the data stored in the RxData buffer.\n• We are going to send a file of size 2176 bytes, so we need to send the size first.\n• select the file that contains the data.\n• The MCU has extracted the size data, and it is expecting 2176 bytes to be received. The RxData buffer has the data. To make sure we received the entire data, we will cross check the start and end part with the actual data. The images below shows the comparison between the actual data, and the data stored in the RxData buffer. You can see the actual data in the file and the data stored in the RxData buffer have the same content in the beginning and in the end. This means we have received entire data from the file. Let’s assume another case where we want to receive an audio or a video file from the UART and then store it in the SD card or a flash memory connected to the MCU. These types of files can be of few megabytes in size, so we can’t store them in a buffer. Instead we can receive a portion of the file and write it to SD card, then receive another portion and write it. This way we can transfer the entire file to the SD card without even storing it to the buffer in the MCU Ram. Although I don’t want to involve the SD card related functions in this tutorial, so I will just use a buffer to store the data. If you are using an actual SD card or flash storage, you can use the same code, just instead of writing to buffer, write the data to the SD card. The process remains the same, so there aren’t many changes from the writing prospective. Below is the cubeMX configuration to enable the UART DMA in circular mode. The DMA request is set for USART2_RX as we are receiving the data via the DMA. The data width is Byte as the UART transfers the data in bytes. The DMA mode is set as Circular. The rest of the UART configuration is same as the previous tutorials with Baud Rate of 115200 with 8 data bits, 1 stop bit and no parity. In Circular mode, the DMA never stops automatically, it is always in the receiving mode. Once all the required number of data bytes has been received, it automatically reset the receive counter to 0 and hence starts receiving again. We still need to know the size of the incoming data. So the sender should first send 4 bytes of the size data followed by the data itself. If you are receiving larger data, you can change the length of the size data bytes, the rest of the code will change accordingly. In the main function, we will set the DMA to receive 256 bytes of data. This data will contain the size bytes as well as the actual data itself. The 256 bytes we requested contains the size data as well as the actual data. Once 128 bytes are received, the half received complete callback will be called. We can handle the received data inside this callback, while the DMA continues to receive the second half. Once all the 256 bytes are received, the receive complete callback will be called. Here we will process the data received in the second half of the buffer, while the DMA continues to receive the 3rd half. This process keep going on until the sender stops sending the data. int HTC = 0, FTC = 0; uint32_t indx=0; int isSizeRxed = 0; uint32_t size=0; void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart) { if (isSizeRxed == 0) { size = ((RxData[0]-48)*1000)+((RxData[1]-48)*100)+((RxData[2]-48)*10)+((RxData[3]-48)); // extract the size indx = 0; memcpy(FinalBuf+indx, RxData+4, 124); // copy the data into the main buffer/file memset(RxData, ' int HTC = 0, FTC = 0; uint32_t indx=0; int isSizeRxed = 0; uint32_t size=0; void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart) { if (isSizeRxed == 0) { size = ((RxData[0]-48)*1000)+((RxData[1]-48)*100)+((RxData[2]-48)*10)+((RxData[3]-48)); // extract the size indx = 0; memcpy(FinalBuf+indx, RxData+4, 124); // copy the data into the main buffer/file memset(RxData, '\\0', 128); // clear the RxData buffer indx += 124; // update the indx variable isSizeRxed = 1; // set the variable to 1 so that this loop does not enter again } else { memcpy(FinalBuf+indx, RxData, 128); memset(RxData, '\\0', 128); indx += 128; } HTC=1; // half transfer complete callback was called FTC=0; } ', 128); // clear the RxData buffer indx += 124; // update the indx variable isSizeRxed = 1; // set the variable to 1 so that this loop does not enter again } else { memcpy(FinalBuf+indx, RxData, 128); memset(RxData, ' int HTC = 0, FTC = 0; uint32_t indx=0; int isSizeRxed = 0; uint32_t size=0; void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart) { if (isSizeRxed == 0) { size = ((RxData[0]-48)*1000)+((RxData[1]-48)*100)+((RxData[2]-48)*10)+((RxData[3]-48)); // extract the size indx = 0; memcpy(FinalBuf+indx, RxData+4, 124); // copy the data into the main buffer/file memset(RxData, '\\0', 128); // clear the RxData buffer indx += 124; // update the indx variable isSizeRxed = 1; // set the variable to 1 so that this loop does not enter again } else { memcpy(FinalBuf+indx, RxData, 128); memset(RxData, '\\0', 128); indx += 128; } HTC=1; // half transfer complete callback was called FTC=0; } ', 128); indx += 128; } HTC=1; // half transfer complete callback was called FTC=0; } The size data bytes are sent first so they are received in the first half of the received data. We will extract the size data, and write the rest of the data in the buffer/file inside the half received complete callback. we are using 4 bytes for the size, so the remaining 124 bytes will be written to the buffer/file. We will also update the indx variable, which keep track of how many data bytes has been written to the buffer/file. This callback will be called several times during the transfer, depending on how large data the sender is sending. We only need to extract the size data in the first call, and for the rest, we will simply copy the 128 bytes to the buffer/file. Similarly, the receive complete callback is called whenever all 256 bytes are received. Here we will simply copy the 128 bytes, from the second half of the buffer into the final buffer/file. Then clear the RxData buffer and update the indx variable. Copying data using the half and complete callback is fine as long as the received data is in the multiple of 256. If not, then we have an issue. For example, if we are receiving 260 bytes, the half callback will be called first, then the Rx complete callback will be called, and the remaining 4 bytes will be stored in the beginning if the RxData buffer. Since we did not received the 128 bytes, the half received callback will not be called and hence we might loose these 4 bytes. To avoid this, we will manually check the received size with the size mentioned by the sender. If they are not equal, we will look where the remaining data is stored and then copy the data to our buffer/file. Below is the code showing it in the while loop. while (1) { if (((size-indx)>0) && ((size-indx)<128)) { if (HTC==1) { strcpy((char *)FinalBuf+indx, (char *)RxData+128); // memcpy (FinalBuf+indx, RxData+128, (size-indx)); indx = size; isSizeRxed = 0; HTC = 0; HAL_UART_DMAStop(&huart2); HAL_UART_Receive_DMA(&huart2, RxData, 256); } else if (FTC==1) { strcpy((char *)FinalBuf+indx, (char *)RxData); // memcpy (FinalBuf+indx, RxData, (size-indx)); indx = size; isSizeRxed = 0; FTC = 0; HAL_UART_DMAStop(&huart2); HAL_UART_Receive_DMA(&huart2, RxData, 256); } We basically check if the difference between the size and indx variable is more than 0 and less than 128. This is necessary as the size variable is calculated in the beginning, so it have a large value. Also the indx variable increases as more data bytes are received. The value 128 is chosen because if we have more than 128 bytes remaining, either half or complete callback will trigger eventually. So if we do enter inside this condition, it means that neither of the callbacks are being called. The sender have stopped sending the data, and we have some extra data in either the first half or the second half of the RxData buffer. We will verify which half contains the data by checking the HTC and FTC variables. If the HTC variable is set, it means that half receive callback was called, and hence the data is in the second half of the RxData buffer. Similarly, if the FTC variable is set, it means that receive complete callback was called, and hence the data is in the first half of the RxData buffer. We will simply copy the remaining data (size-indx) from the RxData buffer into the Final buffer/file. Then update the indx variable and reset the HTC/FTC variable. Also reset the isSizeRxed variable, so that the size of the new upcoming data can be processed. Now we need to start storing the received data from the beginning of the RxData buffer. But the DMA in circular mode will just store the data at the very next position. So we need to manually stop the DMA and call the function again to receive 256 bytes of data. We have discussed the case when we have received some extra bytes, which might be stored in either the first half or the second half of the RxData buffer. But we could also receive data in the multiples of 128, so there will be no extra byte at all. We also need to handle this scenario. Here we will check if the size variable is equal to the indx variable. This could also be possible in the beginning when both of them are 0 and also when the previous if loop was executed. So we will add one more check to this condition. We will check if eiher of the HTC or FTC variables are set. This will confirm that the indx variable and the size variable are equal only after receiving all the data. Inside this condition, we don’t need to copy any data since all the data has already been handled. We will simply reset the variables and start the DMA again. Now we can receive the large data of any size and store in the buffer/file. Although we need to send the size first, followed by the data itself. Below are the images showing the data sent by the serial console and the data stored in the FinalBuf buffer. As shown in the image above:\n• We are going to send a file of size 2200 bytes, so we need to send the size first.\n• select the file that contains the data.\n• The MCU has extracted the size data, and it is expecting 2200 bytes to be received.\n• The indx variable is 2200, which means that the MCU has received 2200 bytes. Check out the Video Below You can help with the development by Below.\n\nTo download the project, click the button."
    },
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_GPIO",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what GPIO is and how to use it through examples.\n\nGPIO stands for general purpose input/output. It is a type of pin found on an integrated circuit that does not have a specific function. While most pins have a dedicated purpose, such as sending a signal to a certain component, the function of a GPIO pin is customizable and can be controlled by the software.\n• Pin Mode : Each port bit of the general-purpose I/O (GPIO) ports can be individually configured by software in several modes:\n• Pin characteristics :\n• Input : no pull-up and no pull-down or pull-up or pull-down\n• Output : push-pull or open-drain with pull-up or pull-down capability\n• Alternate function : push-pull or open-drain with pull-up or pull-down capability.\n• Change the rising and falling edge when the pin state changes from high to low or low to high.\n• A higher GPIO speed increases the EMI noise from STM32 and increases the STM32 consumption.\n• It is good to adapt the GPIO speed to the peripheral speed. For example, low speed is optimal for toggling GPIO at 1 Hz, while using SPI at 45 MHz requires very high speed setting.\n\nLearn how to Toggle a pin on STM32L476 Nucleo board using Hardware Abstraction Layer (HAL) library and learn how to setup the pin and GPIO port in STM32CubeIDE.\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n• Select NUCLEO-L476RG using the Board Selector as shown in the figure below:\n\n\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n• You will then get a popup asking if you want to initialize peripherals to their default configuration.\n• No need to configure any peripheral as only the core/Flash/SRAMs are used (default peripherals).\n• If you want to start the project with a board, the LED pin is already selected (PA5 on NucleoL476RG. For other boards refer to the user manual).\n• Output speed set to very high is important for faster peripherals such as SPI or USART.\n\nThe easiest way to generate the code is to save your current project : Ctrl + S \n\n The code is generated so you can see it in the left side of the screen in the project explorer \n\n \n\n Now, open the main.c file which is the main source file for this application\n• The LED toggling is done with a HAL function inside main.c\n• Click on Debug button (to run step by step)\n• Or on Run button (to execute) \n\n\n\nEvery 500 ms the green LED state changes."
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://deepbluembedded.com/stm32-gpio-write-pin-digital-output-lab",
        "document": "In this tutorial, we’ll configure an STM32 GPIO pin to be output. Then, we’ll create our first STM32 GPIO Example project (LED Blinking) with a blue pill board. You’ll learn all the steps to configure the STM32 CubeMX & flash the code from STM32CubeIDE to the blue pill board.\n\nWe’ll also dive deeper into the STM32 HAL GPIO functions used to control the GPIO output pins in STM32 microcontrollers. Such as the HAL_GPIO_Write() function, HAL_GPIO_TogglePin() function, and more. Without further ado, let’s get right into it!\n\nObjectives of This STM32 LED Blinking Example Project:\n• Use function to change an output pin state\n• Use function to toggle the state of a GPIO pin\n• Use The & Know How It Works\n\nOpen STM32CubeMX, create a new project, and select the STM32F103C8T6 target microcontroller. Note that the STM32 BluePill board has two common target microcontrollers (STM32F103C8T6 & STM32F103C6T6). So you need to select the exact target microcontroller on your hardware board.\n\nThis example project should work flawlessly on any STM32 target microcontroller, you just need to select the target MCU that matches your hardware board.\n\nGo to the RCC clock configuration page and enable the HSE external crystal oscillator input.\n\nClick on the PA8 GPIO pin in the “Pinout View” and select it to be in GPIO_Output mode. Note: you can use any other pin you want instead.\n\nGo to the clock configurations page, and select the HSE as a clock source, PLL output, and type in 72MHz for the desired output system frequency. Hit the “ Enter” key, and let the application solve for the required PLL dividers/multipliers to achieve the desired clock rate.\n\nThe reason behind this: using the external onboard oscillator on the BluePill board provides a more accurate and stable clock, and using a 72MHz as a system clock pushes the microcontroller to its limits, so we get the maximum performance out of it. As long as we don’t care about the application’s power consumption.\n\nFinally, go to the Project Manager, give your project a name, select the toolchain/IDE to be STM32CubeIDE, and click on the Generate Code button.\n\nThe STM32CubeMX tool will generate the initialization code & the project main files and it’ll prompt you to open the project in STM32CubeIDE. Select, open project, and let’s move to the next step.\n\nThen, open the project in the IDE you’re using. And head over to the main.c file. So we can start writing the application code and have a look at the initialization code generated by the STM32 CubeMX tool.\n\nCopy the following code into your main.c file replacing the auto-generated code from the beginning of the fill till the main function. You should leave everything else under the main() function in the main.c file as is.\n\nThis code example uses the STM32 HAL_GPIO_TogglePin() function.\n\nThis code example uses the STM32 HAL_GPIO_TogglePin() function.\n\nYou can use any of the previous code examples. Both are doing the exact same functionality (blink an LED every 100ms).\n\nThe auto-generated main.c file in the source code directory within our projects was as shown below.\n\nBoth functions SystemClock_Config() and MX_GPIO_Init() are generated by CubeMX to configure the system clock as we’ve done in the GUI before and the GPIO pin which we’ve selected to be an output pin. The implementation of both functions is found in the file after the main function.\n\nWe call each of them before the main loop while(1) as well as the HAL_Init function. The HAL_Init must be called at the beginning of your application. Its functionality is clarified in the HAL Documentation as shown below.\n\nAnd most importantly it initializes the SysTick timer, whose ticks are used by the HAL_Delay(). The SysTick timer is set to tick @ 1000Hz or every 1mSec. So the HAL_Delay function will give you multiples of milliseconds delay.\n\nBesides the delay function, we also need to know the HAL APIs for controlling the GPIO pins. To do basic stuff like pin read or write or port read/write, and so on.\n\nSo we’ll head over again to the HAL documentation and search for the GPIO chapter, where we’ll find this listing for the available APIs. The APIs are hyperlinked in the documentation file, so you can click the name of the function to go directly to its detailed description.\n\nSo, let’s take a closer look at the GPIO_WritePin() function, for example.\n\nMore details on all functions can be found in the STM32 HAL documentation that you can easily find on the STMicroelectronics website.\n\nConnect The ST-Link To The USB Port & SWD Pins On Board\n\nClick The Debug Button To Compile The Code & Flash It To The Board & Start A Debugging Session\n\nYou Can Stop The Debugging Session Or Keep It Going. But You Need To Restart The MCU Once To Run The New Application At The Booting Process.\n\nAll the example Code/LABs/Projects in this STM32 Series of Tutorials are done using the Dev boards & Electronic Parts Below:\n\n★ Check The Links Below For The Full Course Kit List & LAB Test Equipment Required For Debugging ★\n\nYou can download all attachment files for this Article/Tutorial (project files, schematics, code, etc..) using the link below. Please consider supporting our work through the various support options listed in the link down below. Every small donation helps to keep this website up and running and ultimately supports the whole community.\n\nIn conclusion, it was quite easy to create our first STM32 LED blinking project using the HAL GPIO WritePin or TogglePin functions. You can play with different settings like delay period, multiple IO pins, and so on.\n\nIf you’re just getting started with STM32, you need to check out the STM32 Getting Started Tutorial here.\n\nFollow this STM32 Series of Tutorials to learn more about STM32 Microcontrollers Programming."
    },
    {
        "link": "https://reddit.com/r/embedded/comments/168is11/how_to_lock_a_gpio_pin_configuration_in_stm32f4",
        "document": "I am implementing my own version for stm32f407 drivers. so I came to that section mentioning how to lock a GPIO pin configuration and that's what they said:\n\nThe problem is that I don't understand what means. As is only 1 bit while is 16 bits, how shall I assign a 16-bit value to a 1-bit value? and why is even written like that? isn't same as ?"
    },
    {
        "link": "https://eevblog.com/forum/microcontrollers/macro-for-efficient-stm32-gpio-handling",
        "document": "0 Members and 2 Guests are viewing this topic.\n\nQuote from: DavidAlfa on April 28, 2021, 09:21:28 am But I found a big issue: HAL doesn't declare the pin numbers anywhere. They're hardcoded as Pin2=0x2, Pin8=0x100, Pin15=0x8000...\n\nThus, you're not going to get the pin number for \"LED_Pin\" anywhere for making a bitmask.\n\n \n\nI'm not sure I understand this part. Where is LED_Pin defined? Is that a HAL thing for the dev boards that have LEDs on particular pins, or does HAL generate that from what you tell it your pin allocations are? Or is it defined by you, as your example shows, in which case why wouldn't you just define LED_Pin as \"13\" instead of as \"GPIO_PIN_13\"? I guess other parts of HAL depend on the pin being defined that way maybe, if you're using other library functions against that pin? Switching from defining LED_Pin as a mask to defining it as an offset would allow you to skip the `__get_GPIO_Pos` macro and replace that `__expand_16to32` macro chain with `(0x03<<(2*x))`\n\n\n\nI don't use HAL so don't care about compatibility, but it's possible to make usage even simpler by adding an extra macro layer:\n\n\n\n \n\nThe extra variadic macro allows multiple arguments to be passed in as a single macro and expands them as the macros are resolved, so you can do this:\n\n\n\n \n\nWithout the extra macro layer the preprocessor will complain about the wrong number of arguments. Each time I work on a new part family I make a set of macros in this style for it, so everything's consistent, and usually the first code I write in a new project is a list of defines for all of the IO pins transcribed from the schematic.\n\n\n\n Quote from: JOEBOBSICLE on April 28, 2021, 11:46:14 am It's not that inefficient to use the HAL if you use link time optimization which may inline small functions. Functions are cleaner than macros \n\nThat second bit is a rather broad statement. Macros can certainly get very ugly when used improperly, but then so can functions (just look at HAL ). A situation like this where you have one to two lines that are very simple presents very little risk of macros getting out of hand. Functions may get optimized down to equivalent instructions as the macros, and often they will, but it's not guaranteed. Optimization of functions depends not just on the optimization settings but also on the type and qualification of any arguments. With macros, and defined constants as their arguments, you end up giving the optimizer a set of statements that is unambiguously constant and therefore more likely to get optimized in all cases. Obviously that doesn't mean that EVERYTHING should be macros instead of functions, but for stuff like this where you will use them everywhere across a project and they're so simple to write once, I think macros make a lot of sense. And even if the macros aren't BETTER than function calls, I don't see how they're especially cleaner in situations like this. I'm not sure I understand this part. Where is LED_Pin defined? Is that a HAL thing for the dev boards that have LEDs on particular pins, or does HAL generate that from what you tell it your pin allocations are? Or is it defined by you, as your example shows, in which case why wouldn't you just define LED_Pin as \"13\" instead of as \"GPIO_PIN_13\"? I guess other parts of HAL depend on the pin being defined that way maybe, if you're using other library functions against that pin? Switching from defining LED_Pin as a mask to defining it as an offset would allow you to skip the `__get_GPIO_Pos` macro and replace that `__expand_16to32` macro chain with `(0x03<<(2*x))`I don't use HAL so don't care about compatibility, but it's possible to make usage even simpler by adding an extra macro layer:The extra variadic macro allows multiple arguments to be passed in as a single macro and expands them as the macros are resolved, so you can do this:Without the extra macro layer the preprocessor will complain about the wrong number of arguments. Each time I work on a new part family I make a set of macros in this style for it, so everything's consistent, and usually the first code I write in a new project is a list of defines for all of the IO pins transcribed from the schematic.That second bit is a rather broad statement. Macros can certainly get very ugly when used improperly, but then so can functions (just look at HAL). A situation like this where you have one to two lines that are very simple presents very little risk of macros getting out of hand. Functions may get optimized down to equivalent instructions as the macros, and often they will, but it's not guaranteed. Optimization of functions depends not just on the optimization settings but also on the type and qualification of any arguments. With macros, and defined constants as their arguments, you end up giving the optimizer a set of statements that is unambiguously constant and therefore more likely to get optimized in all cases. Obviously that doesn't mean that EVERYTHING should be macros instead of functions, but for stuff like this where you will use them everywhere across a project and they're so simple to write once, I think macros make a lot of sense. And even if the macros aren't BETTER than function calls, I don't see how they're especially cleaner in situations like this. The following users thanked this post: DavidAlfa\n\nQuote from: newbrain on April 28, 2021, 03:52:30 pm As another alternative, there's the LL library, which mostly consist of static inline functions.\n\nThey are very similar to the macros defined above, and for GPIO an init function is also provided, though the HAL one can be used too.\n\n\n\nI have yet to see a case where they were not inlined, from -Og onwards.\n\n \n\nYep.\n\n\n\nAnd that said, use what's best for your requirements. Who cares if setting an IO takes a couple more cycles that it would with fully optimized assembly code, unless you actually NEED to save those extra cycles for performance reasons. I'm against execssive bloat, but also against excessive optimization when it's not actually needed. Sometimes it is, but most of the time, if you really need ultra-fast GPIO toggling, then you're probably going to have to use a dedicated peripheral anyway (such as output compare, serial or parallel bus, or whatever else...) rather than bit-banging stuff. Those MCUs are complex stuff and are pretty fast. You can't think of them as you would have when dealing with crippled 8-bit MCUs running at a couple MHz.\n\n\n\nSo yeah, GPIO-related functions in the HAL are definitely not what causes issues in most cases. There are HAL functions that are easy to use, but definitely NOT efficient though. Functions handling peripheral block access via DMA in just one function, for instance (ADC, DAC, SPI, ...). As they often include the DMA setup code, they can take hundreds of cycles and are good examples of what can be hand optimized.\n\n\n\nAnd as ataradov said, if you think you can replace one general-purpose, one-size-fits-all library with another, better one, you're probably deluded.\n\nJust use existing libraries when they fit your requirements, and hand-written code when they do not.\n\n Yep.And that said, use what's best for your requirements. Who cares if setting an IO takes a couple more cycles that it would with fully optimized assembly code, unless you actually NEED to save those extra cycles for performance reasons. I'm against execssive bloat, but also against excessive optimization when it's not actually needed. Sometimes it is, but most of the time, if you really need ultra-fast GPIO toggling, then you're probably going to have to use a dedicated peripheral anyway (such as output compare, serial or parallel bus, or whatever else...) rather than bit-banging stuff. Those MCUs are complex stuff and are pretty fast. You can't think of them as you would have when dealing with crippled 8-bit MCUs running at a couple MHz.So yeah, GPIO-related functions in the HAL are definitely not what causes issues in most cases. There are HAL functions that are easy to use, but definitely NOT efficient though. Functions handling peripheral block access via DMA in just one function, for instance (ADC, DAC, SPI, ...). As they often include the DMA setup code, they can take hundreds of cycles and are good examples of what can be hand optimized.And as ataradov said, if you think you can replace one general-purpose, one-size-fits-all library with another, better one, you're probably deluded.Just use existing libraries when they fit your requirements, and hand-written code when they do not. The following users thanked this post: lucazader\n\nQuote from: DavidAlfa on April 28, 2021, 04:52:49 pm Really, why so much mess? Makes me thing what people are behind it. Newbies? \n\n The first code is actually correct if you ever call that from an interrupt. The second code would fail and set the wrong bits if interrupt and main code coincide. Not newbies, quite the opposite.\n\n\n\nI use ^ too, but that't the responsibility I'm taking. And I may forget about it and run into bugs that I have to debug. But at least, if it is my bug, I'm the one to blame for time spent debugging. \n\n\n\nAnd that's another argument against universal libraries. In my code I make allowances for my general coding and architecture style. If you were to make a universal code that should just work for everyone, things will get much more complicated.\n\n\n\nAlso, with a simple code like this that manipulates single pins, you are assuming that you won't need to modify multiple pins. Or you need to make an API for that too. Again, in my case I know that modifications to multiple pins are rarely used by me. Usually it happens in very tightly optimized sections, where completely custom code is justified anyway. So I never bother to implement anything generic for manipulating multiple pins. The first code is actually correct if you ever call that from an interrupt. The second code would fail and set the wrong bits if interrupt and main code coincide. Not newbies, quite the opposite.I use ^ too, but that't the responsibility I'm taking. And I may forget about it and run into bugs that I have to debug. But at least, if it is my bug, I'm the one to blame for time spent debugging.And that's another argument against universal libraries. In my code I make allowances for my general coding and architecture style. If you were to make a universal code that should just work for everyone, things will get much more complicated.Also, with a simple code like this that manipulates single pins, you are assuming that you won't need to modify multiple pins. Or you need to make an API for that too. Again, in my case I know that modifications to multiple pins are rarely used by me. Usually it happens in very tightly optimized sections, where completely custom code is justified anyway. So I never bother to implement anything generic for manipulating multiple pins. The following users thanked this post: newbrain\n\nOne also has to remember that the HAL is an abstraction that needs to work across multiple devices - it has to account for differences in a way that doesn’t break the APIs it presents. This can lead to some “over complicated” architecture/design in some places.\n\n\n\nBut from what I’ve seen of it, it isn’t all that bad. Just complicated at times.\n\n\n\nBack in the days, I used to write super optimized assembly code to convert data into assembly files that could be compiled into the software I was working on. Completely pointless as that was a one-off thing but I wanted everything optimized 100%. These days, I care much more about code readability and simplicity for the *reader* rather than optimizing everything. I trust the C compiler to do that well enough so that I don’t have to care.\n\n\n\nAnd one thing is certain, compared to the steaming pile of crap that is the Arduino framework and related libraries, the STM32 HAL is a beautiful piece of art.\n\nQuote from: ataradov on April 28, 2021, 06:25:06 pm Quote from: DavidAlfa on April 28, 2021, 06:12:23 pm Im all ears! What are other possible options for MCUs like STM32?\n\n An actual debugger.\n\n\n\nAlthough I generally don't use debuggers. Somehow I can figure things out with printfs and GPIO toggling faster than with a debugger. But I also have a ton of helpful debug code snippets that I have accumulated over the years.\n\n \n\nI practically never use debuggers on embedded targets either. My experience is similar; they actually tend to make you waste a lot of time. Well-written debug code is usually much more effective, and the added benefit is that they leave a lasting trace of your debugging. Of course it requires a bit of thought. Using a debugger won't leave any trace. Usually. I reckon people paid by the hour may prefer having to think less, and spend more time frantically hitting on keys.\n\n\n\nAnother point is that \"real-time\" issues can be very hard to track down using a debugger. Toggling IOs can help here. Even sending some info through SWO or even some UART - long gone are the days where you were limited to very low baud rates. You can set up SWO or UART for several Mbits/s, and thus make any logging have mininal overhead.\n\n\n\nNow for any \"complex\" logic that could have a high probably of having bugs, what I sometimes do is just compile it on a PC, writing minimal additional code to test it. It gives you a way of adding automated testing without having to do this on the final target (which can be a pain with MCUs), while being able to occasionally use a debugger if required, with usually many more features than what you get with a MCU. So that's what I usually do for any complex logic, algorithms or even DSP. The benefit of C here (or C++) is that correctly written in a portable way, it can be compiled on a PC unmodified.\n\n\n\n I practically never use debuggers on embedded targets either. My experience is similar; they actually tend to make you waste a lot of time. Well-written debug code is usually much more effective, and the added benefit is that they leave a lasting trace of your debugging. Of course it requires a bit of thought. Using a debugger won't leave any trace. Usually. I reckon people paid by the hour may prefer having to think less, and spend more time frantically hitting on keys.Another point is that \"real-time\" issues can be very hard to track down using a debugger. Toggling IOs can help here. Even sending some info through SWO or even some UART - long gone are the days where you were limited to very low baud rates. You can set up SWO or UART for several Mbits/s, and thus make any logging have mininal overhead.Now for any \"complex\" logic that could have a high probably of having bugs, what I sometimes do is just compile it on a PC, writing minimal additional code to test it. It gives you a way of adding automated testing without having to do this on the final target (which can be a pain with MCUs), while being able to occasionally use a debugger if required, with usually many more features than what you get with a MCU. So that's what I usually do for any complex logic, algorithms or even DSP. The benefit of C here (or C++) is that correctly written in a portable way, it can be compiled on a PC unmodified. The following users thanked this post: Siwastaja"
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1723-stm32cube-polarssl-example-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/embedded/comments/1idjgc6/is_my_approach_to_implementing_serial",
        "document": "Context:\n\nI have two STM32 microcontrollers communicating via RS485 modules.\n• Controller 1 transmits a hex value when a push button is pressed.\n• Controller 2 receives this value and continuously monitors a limit switch.\n• Once the limit switch is triggered, Controller 2 transmits a hex value back to Controller 1.\n• Upon receiving this value, Controller 1 sets an LED high.\n\nApproach:\n\nHere, in Controller 1's program, I've used a while loop that waits for a response from Controller 2 and then sets the LED high. Here, in this handshake process, Controller 1 is stuck in an instruction until a certain event occurs.\n\n(I’ve learned about 'TCP handshake duration' in my Computer Networks class, but unlike a predefined handshake duration, the limit switch in my scenario can trigger at any unpredictable time. Therefore, I cannot use a fixed waiting period.)\n\nTo ensure the controller remains responsive to other critical tasks during this handshake process, I have used external interrupts for higher priority events (eg. emergency shutdown etc.). Once the ISR executes, the PC must return back to the instruction where it was interrupted (here, while instruction).\n\nQuestion:\n\nBy using external interrupts, have I effectively addressed the issue of the program being stuck in an instruction?\n\nIs this a good practice for real-time embedded system programming, or is there a more efficient approach?"
    },
    {
        "link": "https://embedthreads.com/wp-content/uploads/2023/09/Muhammad-Ali-Mazidi.pdf",
        "document": ""
    },
    {
        "link": "https://st.com/resource/en/application_note/an3365-secure-socket-layer-ssl-for-stm32f217xx-microcontroller-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://deepbluembedded.com/stm32-spi-tutorial",
        "document": "In this tutorial, we’ll be discussing the SPI hardware in STM32 microcontrollers. Starting with an introduction to the Serial Peripheral Interface (SPI) communication. And we’ll get a closer look at the STM32 SPI hardware module and its internal functionalities, modes of operation, options, and configurations. In conclusion, we’ll take a look at the possible interrupt signals that can be triggered by the SPI hardware. And the different modes to perform SPI transmit & receive operations like (polling – interrupt – DMA).\n\nFinally, we’ll check the available SPI configuration inside of CubeMX and how to configure & operate the peripheral using the provided HAL APIs. And that’s it for this theoretical tutorial. Next, we’ll do a couple of LABs to practice using SPI in different projects for communication and modules interfacing with STM32 microcontrollers.\n\nSPI is an acronym for (Serial Peripheral Interface) pronounced as “S-P-I” or “Spy”. Which is an interface bus typically used for serial communication between microcomputer systems and other devices, memories, and sensors. Usually used to interface Flash Memories, ADC, DAC, RTC, LCD, SDcards, and much more. The SPI was originally developed by Motorola back in the 80s to provide full-duplex serial communication to be used in embedded systems applications.\n\nIn typical SPI communication, there should be at least 2 devices attached to the SPI bus. One of them should be the master and the other will essentially be a slave. The master initiates communication by generating a serial clock signal to shift a data frame out, at the same time serial data is being shifted-in to the master. This process is the same whether it’s a read or write operation.\n• None SCLK -> Serial Clock, generated by the master and goes to the slave.\n• None SS -> Slave Select. Generated by the master to control which slave to talk to. It’s usually an active-low signal.\n\nDevices on the SPI bus can operate in either mode of the following: Master or Slave. There must be at least one master who initiates the serial communication process (For Reading/Writing). On the other hand, there can be single or multiple devices operating in slave mode.\n\nThe master device can select which slave to talk to by setting the SS (slave select) pin to logic low. If a single slave is being addressed, you can tie the SS pin of this slave device to logic low without the need to control this line by the master.\n\nThe master SPI device is responsible for generating the clock signal to initiate and continue the data transaction process. The master, therefore, determines the data rate by controlling the serial clock line’s (SCK) frequency which is a programmable parameter in hardware by firmware instructions.\n\nThe SPI clock has two more parameters to control which are the Clock Phase (CPHA) and the Clock Polarity (CPOL). The clock phase determines the phase at which the data latching occurs at each bit transfer whether it’s the leading edge or the trailing edge. The clock polarity determines the IDLE state of the clock line whether it’s a HIGH or LOW. Having 2 possible states for each of the CPOL and CPHA gives us a total of 4 possible modes for the SPI clock. Typically referred to as “SPI Mode Number”.\n\nThe linked SPI tutorial above is a full guide (+8k words!) that has all the information you may need to know if you’re just starting to learn about the topic. Take the time to check it out if you need to and come back to resume this tutorial and to see the SPI hardware peripheral implemented in STM32 microcontrollers and the extra features it does have.\n\nthe STM32 SPI interface provides two main functions, supporting either the SPI protocol or the I2S audio protocol. By default, it is the SPI function that is selected. It is possible to switch the interface from SPI to I2S by software.\n\nThe serial peripheral interface (SPI) allows half/ full-duplex, synchronous, serial communication with external devices. The interface can be configured as the master and in this case, it provides the communication clock (SCK) to the external slave device. The interface is also capable of operating in a multi-master configuration.\n• None Simplex synchronous transfers on two lines with or without a bidirectional data line\n• None NSS pin management by hardware or software for both master and slave: dynamic change of master/slave operations\n• None Hardware CRC feature for reliable communication: [ CRC value can be transmitted as the last byte in Tx mode – Automatic CRC error checking for last received byte ]\n• None 1-byte transmission and reception buffer with DMA capability: Tx and Rx requests\n\nIn this section, we’ll get a deep insight into the STM32 SPI module hardware, its block diagram, functionalities, modes of operations, and data reception/transmission.\n\nAs you can see in the SPI block diagram above, there is the main shift register lying between two buffer registers one for transmission (TX) and the other for reception (RX). And a logical control unit on the right side with a bunch of signals coming in and out to the control registers.\n\nThe control registers give you the ability to change any of the SPI hardware configurations by software instructions. And there is also the status register that gives you some signals about the ongoing and last-done transaction and any error if happened.\n\nThe baud rate generator (Clock signal SCK) is also configurable by software as we can tell and there is a control logic dedicated for the NSS pin (if you’re going to use it).\n\nData can be shifted out either MSB-first or LSB-first depending on the value of the LSBFIRST bit in the SPI_CR1 Register.\n\nEach data frame is 8 or 16 bits long depending on the size of the data programmed using the DFF bit in the SPI_CR1 register. The selected data frame format is applicable for transmission and/or reception.\n\nIt has to be the same on both ends of the communication. The slave should know what to expect in order to read the received data correctly. It has to be formatted coordinately.\n\nIn the slave configuration, the serial clock is received on the SCK pin from the master device. The baud rate value set in the BR[2:0] bits in the SPI_CR1 register, does not affect the data transfer rate. In this configuration, the MOSI pin is a data input pin and the MISO pin is a data output.\n\n\n\nNote that you need to have the SPI slave device running and configured before the master starts to send anything just to avoid any possible data corruption at the beginning of the first communication session.\n\nThe configuration procedure is available in the datasheet if you’d like to follow it in order to build an SPI initialization function at the register-level. But we’ll be using the HAL APIs so it’ll handle this procedure for us regardless of the specific STM32 target microcontroller we’re using in the design.\n\nThe data byte is parallel-loaded into the Tx buffer during a write cycle. The transmit sequence begins when the slave device receives the clock signal and the most significant bit of the data on its MOSI pin. The remaining bits (the 7 bits in 8-bit data frame format, and the 15 bits in 16-bit data frame format) are loaded into the shift-register. The TXE flag in the SPI_SR register is set on the transfer of data from the Tx Buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.\n\nFor the receiver, when data transfer is complete: The Data in the shift register is transferred to Rx Buffer and the RXNE flag (SPI_SR register) is set. An Interrupt is generated if the RXNEIE bit is set in the SPI_CR2 register.\n\nAfter the last sampling clock edge, the RXNE bit is set, a copy of the data byte received in the shift register is moved to the Rx buffer. When the SPI_DR register is read, the SPI peripheral returns this buffered value. Clearing of the RXNE bit is performed by reading the SPI_DR register.\n\nIn the master configuration, the serial clock is generated on the SCK pin. In this configuration, the MOSI pin is a data output pin and the MISO pin is data input.\n\nThe transmit sequence begins when a byte is written in the Tx Buffer. The data byte is parallel-loaded into the shift register (from the internal bus) during the first-bit transmission and then shifted out serially to the MOSI pin MSB first or LSB first depending on the LSBFIRST bit in the SPI_CR1 register.\n\nThe TXE flag is set on the transfer of data from the Tx Buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.\n\nFor the receiver, when data transfer is complete: The data in the shift register is transferred to the RX Buffer and the RXNE flag is set. An interrupt is generated if the RXNEIE bit is set in the SPI_CR2 register\n\nAt the last sampling clock edge, the RXNE bit is set, a copy of the data byte received in the shift register is moved to the Rx buffer. When the SPI_DR register is read, the SPI peripheral returns this buffered value.\n\nClearing the RXNE bit is performed by reading the SPI_DR register. A continuous transmit stream can be maintained if the next data to be transmitted is put in the Tx buffer once the transmission is started. Note that the TXE flag should be ‘1 before any attempt to write the Tx buffer is made.\n\nThe STM32 SPI Hardware is capable of operating in half-duplex mode in 2 configurations.\n\nCheck the target MCU’s datasheet for more information about each configuration of them if you’re going to use this Half-Duplex mode. I don’t think we’d need that in any of the future tutorials. But if we did, I’ll give some examples to do this type of communication with SPI.\n\nIn reception, data are received and then stored into an internal Rx buffer while In transmission, data are first stored into an internal Tx buffer before being transmitted.\n\nA read access to the SPI_DR register returns the Rx buffered value, whereas a write access to the SPI_DR stores the written data into the Tx buffer.\n\nA CRC calculator has been implemented in STM32 SPI hardware for communication reliability. Separate CRC calculators are implemented for transmitted data and received data. The CRC is calculated using a programmable polynomial serially on each bit. It is calculated on the sampling clock edge defined by the CPHA and CPOL bits in the SPI_CR1 register.\n\nAt the end of data and CRC transfers, the CRCERR flag in the SPI_SR register is set if corruption occurs during the transfer. This is similar to a checksum if you’re familiar with error detection procedures for communication. Actually, the checksum is a very simple way of doing a mathematical operation (addition) to the data being transferred to check the validity of the whole data packet.\n\nThe CRC (cyclic redundancy check) is a much “mathematically” powerful operation than a normal checksum that’s much harder to fool. There are many different versions and equations for performing CRC in general but it’s really good to have it built within the SPI hardware itself.\n\nThere are some status flags provided for the application to completely monitor the state of the SPI bus.\n• None Tx buffer empty flag (TXE) – When it is set, this flag indicates that the Tx buffer is empty and the next data to be transmitted can be loaded into the buffer. The TXE flag is cleared when writing to the SPI_DR register.\n• None Rx buffer not empty (RXNE) – When set, this flag indicates that there are valid received data in the Rx buffer. It is cleared when SPI_DR is read.\n• None BUSY flag – The BSY flag is useful to detect the end of a transfer if the software wants to disable the SPI and enter Halt mode (or disable the peripheral clock). This avoids corrupting the last transfer. For this, the procedure described below must be strictly respected. The BSY flag is also useful to avoid write collisions in a multi-master system.\n\nThere are also other SPI flags that indicate whether a specific type of error has occurred or not.\n• None SPI Master mode fault (MODF) – Master mode fault occurs when the master device has its NSS pin pulled low (in NSS hardware mode) or SSI bit low (in NSS software mode), this automatically sets the MODF bit.\n• None SPI Overrun condition – An overrun condition occurs when the master device has sent data bytes and the slave device has not cleared the RXNE bit resulting from the previous data byte transmitted.\n• None SPI CRC error – This flag is used to verify the validity of the value received when the CRCEN bit in the SPI_CR1 register is set. The CRCERR flag in the SPI_SR register is set if the value received in the shift register does not match the receiver SPI_RXCRCR value.\n\nThe SPI interrupt events are connected to the same interrupt vector. So the SPI fires a single interrupt signal regardless of the source of it. The software will have to detect it. These events generate an interrupt if the corresponding Enable Control Bit is set.\n\nIn this section, I’ll list the possible ways that you can handle SPI transactions in your firmware applications. For code example LABs and testing, just click on the next tutorial button and keep going through this series of tutorials. There will be lots of examples and libraries that we’ll build based on SPI communication.\n\nThe first and the easiest way to do anything in embedded software is just to poll for the hardware resource until it’s ready to move on to the next step in your program instructions. However, it’s the least efficient way to do things and the CPU will end up wasting so much time in a “busy-waiting” state.\n\nIt’s the same thing for both transmission and reception. You just wait until the current byte of data to be transmitted so you can start the next one and so on.\n\nWe can, however, enable the SPI interrupts and have a signal when it’s done and ready for servicing by CPU. Either for data that has been sent or received. Which saves a lot of time and has been always the best way to handle events like that.\n\nHowever, in some “Time Critical” applications we need everything to be as deterministic, in time, as possible. And a major problem with interrupts is that we can’t expect when it’d arrive or during which task. That can potentially screw up the timing behavior of the system, Especially with an extremely fast communication bus like SPI that can definitely block the CPU if you’re receiving massive data blocks at a very high rate.\n\nTo operate at its maximum speed, the SPI needs to be fed with the data for transmission and the data received on the Rx buffer should be read to avoid overrun. To facilitate the transfers, the SPI features a DMA capability implementing a simple request/acknowledge protocol.\n\nA DMA access is requested when the enable bit in the SPI_CR2 register is enabled. Separate requests must be issued to the Tx and Rx buffers.\n\nUsing the DMA unit not only will make the SPI going at full speed on both sides of communication, but it will also free the CPU from doing the data transfers “from peripheral to memory”. This will end up saving a lot of time and is considered to be the most efficient way to handle this peripheral to memory data transfer and vice versa.\n\nIn the next few tutorials, we’ll be doing some practical LABs to implement SPI receiver/transmitter code examples. In which we’ll be using the CubeMX software tool to configure the SPI hardware. Therefore, in this section, I’ll introduce to you the features and options that can be configured within CubeMX GUI for SPI peripheral.\n\nHere is the configuration tab for the SPI peripheral in CubeMX. And those are the possible modes for SPI.\n\nLet’s pick the “Full-Duplex Master” mode for example. You’ll find that now we’re able to set the baud rate, frame type and size, NSS pin control, CRC, SPI Mode Number (Clock Phase & Polarity), and other parameters.\n\nWe can also enable/disable interrupts for SPI in the NVIC tab if you’re willing to use interrupt mode instead of polling the peripheral. And the same goes for the DMA, you can click the DMA tab to “Add” a DMA channel dedicated to SPI transfer and configure its parameters.\n\nAfter calling the above function, the SPI peripheral will start sending all the data bytes in the buffer one by one until it’s done. When it’s done this function below will be called and executed, if you’d like to do something upon data transmission completion, then add that to your code in the application source file (main.c).\n\nAfter calling the above function, the SPI peripheral will start receiving all the incoming data bytes in the buffer one by one until it’s done. When it’s done this function below will be called and executed, if you’d like to do something upon data reception completion, then add that to your code in the application source file (main.c).\n\nAfter calling the above function, the SPI peripheral will start sending-receiving all the incoming data bytes in the buffers one by one until it’s done. When it’s done this function below will be called and executed, if you’d like to do something upon data transmission-reception completion, then add that to your code in the application source file (main.c).\n\nAfter calling the above function, the SPI peripheral will start sending all the data bytes in the buffer one by one until it’s done (in DMA Mode). When it’s done this function below will be called and executed, if you’d like to do something upon data transmission completion, then add that to your code in the application source file (main.c).\n\nAfter calling the above function, the SPI peripheral will start receiving all the incoming data bytes in the buffer one by one until it’s done (in DMA Mode). When it’s done this function below will be called and executed, if you’d like to do something upon data reception completion, then add that to your code in the application source file (main.c).\n\nAfter calling the above function, the SPI peripheral will start sending-receiving all the incoming data bytes in the buffers one by one until it’s done (in DMA Mode). When it’s done this function below will be called and executed, if you’d like to do something upon data transmission-reception completion, then add that to your code in the application source file (main.c).\n\nThe SPI Communication Bus Demonstrated in This Tutorial Will Be Used In The Following Next Tutorials:\n\nThat’s it for this tutorial. If you’d like to see the practical LAB examples for SPI and other interfacing projects and libraries we’ll build using this peripheral, just keep progressing through this series of tutorials and click to the next tutorial link down below.\n\nDid you find this helpful? If yes, please consider supporting this work and sharing these tutorials!\n\nStay tuned for the upcoming tutorials and don’t forget to SHARE these tutorials. And consider SUPPORTING this work to keep publishing free content just like this!"
    }
]