[
    {
        "link": "https://stackoverflow.com/questions/189892/best-practices-for-handling-variable-size-arrays-in-c-c",
        "document": "For C++, using std::vector\n\nThere's no real point in using a C-array. The std::vector has (almost) the same performance as a C array, and it will:\n• verify you are really accessing the right memory (i.e. it could throw an exception if you go beyond its bounds)\n\nAnd this is not even considering the generic algorithm associated with the std::vector.\n\nNow, using C\n\nYou can write it somewhat better at least in two ways. First, replacing a define with a true constant variable:\n\nUsing a true variable will offer your somewhat more type safety, and won't pollute the global scope. To minimize dependancies, you can even declare the variables in the header, and define them in a source:\n\nThis way, you'll be able to change the size of the array in one source, without needing recompilation of all the sources using it. The downside is that MAXPLAYERS is not anymore known at compile time (but, is this really a downside?)\n\nNote that your second type of array cannot grow dynamically. The sizeof is (at least in C++) evaluated at compile time. For growing arrays, malloc/realloc/free is the way to go in C, and std::vector (or any other generic STL container) is the way to go in C++."
    },
    {
        "link": "https://hackernoon.com/c-performance-optimization-best-practices",
        "document": "Performance optimization is a critical aspect of C++ programming, as it can significantly impact the speed and efficiency of your applications. In this article, we'll explore various techniques and best practices for optimizing C++ code. Whether you're a beginner or an experienced developer, these tips will help you write faster and more efficient C++ programs.\n\n1. Use the Right Data Structures\n\nChoosing the appropriate data structures can have a massive impact on performance. Use for dynamic arrays, or for key-value pairs and or for unique values. Avoid linked lists when you need random access, as they can lead to poor cache performance.\n\nExample: Using for Dynamic Arrays\n\nCopying objects can be expensive. Use references or move semantics ( ) when passing and returning objects to minimize unnecessary copying. If you use then try to change it in some cases, it will have a better performance.\n\nAllocate objects on the stack whenever possible, as stack allocation is faster than heap allocation. Use dynamic allocation (e.g., and ) only when the object's lifetime extends beyond the current scope.\n\nHowever, it's important to note that stack allocation has limitations:\n• Fixed Size: Stack memory is of fixed size and is limited. This means you can't allocate very large objects or a dynamic number of objects on the stack.\n• Risk of Stack Overflow: Excessive stack memory usage can lead to a stack overflow if the available stack space is exhausted. Heap memory doesn't have this limitation.\n\nProfiling tools can help identify performance bottlenecks. Use tools like (GNU Profiler) or platform-specific profilers to analyze your code's execution time and memory usage.\n• Identify what areas of code are taking how much time\n• See if you can use better data structures/ algorithms to make things faster\n\nExcessive memory allocation and deallocation can lead to performance issues. Reuse objects when possible and consider using object pools for frequently created and destroyed objects.\n\nLoops are often the core of algorithms. Optimize loops by minimizing loop overhead, reducing unnecessary calculations, and using the right loop constructs (e.g., range-based loops).\n\nModern C++ compilers provide optimization flags (e.g., , ) that can significantly improve code performance. Use these flags during compilation to enable various optimization techniques.\n• : Enables basic optimization. This includes optimizations such as common subexpression elimination and instruction scheduling. It's a good balance between optimization and compilation time.\n• : Enables more aggressive optimization, including inlining functions, loop optimizations, and better code scheduling. It provides a significant performance boost.\n• : Enables even more aggressive optimizations. It can lead to faster code but may increase compilation time and the size of the executable.\n\nMinimize function calls within tight loops. Inlining functions (e.g., using or compiler optimizations) can eliminate function call overhead.\n\nOptimize for cache efficiency by minimizing cache misses. Access data sequentially, avoid non-contiguous memory accesses, and use data structures that promote cache locality.\n\nBenchmark your code after each optimization step to measure the impact of changes accurately. Iteratively apply optimizations, focusing on the most significant bottlenecks.\n\nOptimizing C++ code is a crucial skill for achieving high-performance applications. You can significantly enhance your code's speed and efficiency by using the right data structures, avoiding unnecessary copying, and following best practices. Profiling, benchmarking, and iterative optimization are essential tools for achieving optimal performance. Remember that premature optimization is not always beneficial; focus on optimizing critical sections of your code when necessary."
    },
    {
        "link": "https://stackoverflow.com/questions/527887/c-c-optimize-data-structures-array-of-arrays-or-just-array",
        "document": "jalf is mostly right. L1 cache is divided up into chunks, the size of the chunks is dependant on the processor but is in the order of 32 bytes. So, if you were stepping through memory a byte at a time, you'd get a cache miss every 32 bytes (or whatever the chunk size is). Now, the Intel chip is quite clever here and can detect sequential reads and prefetch the data reducing the impact of a cache miss.\n\nThe 4x4 matrix is highly likely to reside in a single L1 chunk (or cache line), so accessing it by row or by column makes little difference. Of course, you don't want to split the matrix across two cache lines, so well aligned memory is important.\n\nThe 16x16 matrix, however, won't fit in a cache line. So, if you're skipping through the array processing columns you're going to get lots of cache misses. The computation of the index, as jalf said, makes little difference as the ratio between CPU and memory is high (i.e. you can do a lot of CPU work for each cache miss).\n\nNow, if you are mainly processing the matrix in a column orientated way, then your best option is to transpose all your matrices (swap rows with columns), thus your memory accesses will be more sequential and the number of cache misses will be reduced and the CPU will be able to prefetch data better. So, instead of organising the matrix like this:\n\nwhere the number is the memory offset from the start of the matrix, organise thus:"
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-optimize-character-array-processing-435795",
        "document": "In C++, character arrays are fundamental data structures used to store and manipulate sequences of characters. They provide a low-level method of handling text data efficiently. Understanding their basic properties and usage is crucial for effective string processing.\n\nCharacter arrays are contiguous memory blocks that store individual characters. Each character occupies one byte of memory and is represented by its ASCII or Unicode value.\n\nBy mastering character arrays, developers can write more efficient and low-level string manipulation code in C++."
    },
    {
        "link": "https://quora.com/How-should-I-handle-large-data-inputs-in-C++-for-problems-in-programming-contests",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/introduction-to-iostream-cout-cin-and-endl",
        "document": "In this lesson, we’ll talk more about std::cout, which we used in our Hello world! program to output the text Hello world! to the console. We’ll also explore how to get input from the user, which we will use to make our programs more interactive.\n\nThe input/output library (io library) is part of the C++ standard library that deals with basic input and output. We’ll use the functionality in this library to get input from the keyboard and output data to the console. The io part of iostream stands for input/output.\n\nTo use the functionality defined within the iostream library, we need to include the iostream header at the top of any code file that uses the content defined in iostream, like so:\n\nThe iostream library contains a few predefined variables for us to use. One of the most useful is std::cout, which allows us to send data to the console to be printed as text. cout stands for “character output”.\n\nAs a reminder, here’s our Hello world program:\n\nIn this program, we have included iostream so that we have access to std::cout. Inside our main function, we use std::cout, along with the insertion operator ( ), to send the text Hello world! to the console to be printed.\n\nstd::cout can not only print text, it can also print numbers:\n\nIt can also be used to print the value of variables:\n\nTo print more than one thing on the same line, the insertion operator ( ) can be used multiple times in a single statement to concatenate (link together) multiple pieces of output. For example:\n\nThis uses the operator twice, first to output and then to output .\n\nHere’s another example where we print both text and the value of a variable in the same statement:\n\nWhat would you expect this program to print?\n\nYou might be surprised at the result:\n\nSeparate output statements don’t result in separate lines of output on the console.\n\nIf we want to print separate lines of output to the console, we need to tell the console to move the cursor to the next line. We can do that by outputting a newline. A newline is an OS-specific character or sequence of characters that moves the cursor to the start of the next line.\n\nOne way to output a newline is to output (which stands for “end line”):\n\nConsider a rollercoaster ride at your favorite amusement park. Passengers show up (at some variable rate) and get in line. Periodically, a train arrives and boards passengers (up to the maximum capacity of the train). When the train is full, or when enough time has passed, the train departs with a batch of passengers, and the ride commences. Any passengers unable to board the current train wait for the next one.\n\nThis analogy is similar to how output sent to is typically processed in C++. Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. Instead, the requested output “gets in line”, and is stored in a region of memory set aside to collect such requests (called a buffer). Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console).\n\nThis also means that if your program crashes, aborts, or is paused (e.g. for debugging purposes) before the buffer is flushed, any output still waiting in the buffer will not be displayed.\n\nUsing is often inefficient, as it actually does two jobs: it outputs a newline (moving the cursor to the next line of the console), and it flushes the buffer (which is slow). If we output multiple lines of text ending with , we will get multiple flushes, which is slow and probably unnecessary.\n\nWhen outputting text to the console, we typically don’t need to explicitly flush the buffer ourselves. C++’s output system is designed to self-flush periodically, and it’s both simpler and more efficient to let it flush itself.\n\nTo output a newline without flushing the output buffer, we use (inside either single or double quotes), which is a special symbol that the compiler interprets as a newline character. moves the cursor to the next line of the console without causing a flush, so it will typically perform better. is also more concise to type and can be embedded into existing double-quoted text.\n\nHere’s an example that uses in a few different ways:\n\nWhen is not being embedded into an existing line of double-quoted text (e.g. , it is conventionally single quoted ( ).\n\nWe’ll cover what ‘\n\n’ is in more detail when we get to the lesson on chars (4.11 -- Chars).\n\nis another predefined variable in the library. Whereas prints data to the console (using the insertion operator to provide the data), (which stands for “character input”) reads input from keyboard. We typically use the extraction operator to put the input data in a variable (which can then be used in subsequent statements).\n\nTry compiling this program and running it for yourself. When you run the program, line 5 will print “Enter a number: “. When the code gets to line 8, your program will wait for you to enter input. Once you enter a number (and press enter), the number you enter will be assigned to variable . Finally, on line 10, the program will print “You entered ” followed by the number you just entered.\n\nFor example (entering the value 4 as input):\n\nThis is an easy way to get keyboard input from the user, and we will use it in many of our examples going forward.\n\nJust like it is possible to output more than one bit of text in a single line, it is also possible to input more than one value on a single line:\n\nValues entered should be separated by whitespace (spaces, tabs, or newlines).\n\nIn a prior section, we noted that outputting data is actually a two stage process:\n• The data from each output request is added (to the end) of an output buffer.\n• Later, data from (the front of) the output buffer is flushed to the output device (the console).\n\nSimilarly, inputting data is also a two stage process:\n• The individual characters you enter as input are added to the end of an input buffer (inside ). The enter key (pressed to submit the data) is also stored as a character.\n• The extraction operator ‘>>’ removes characters from the front of the input buffer and converts them into a value that is assigned (via copy-assignment) to the associated variable. This variable can then be used in subsequent statements.\n\nWe’ll demonstrate this using the following program:\n\nThis program inputs to two variables (this time as separate statements). We’ll run this program twice.\n\nRun #1: When is encountered, the program will wait for input. Enter the value . The input goes into the input buffer, and the value is extracted to variable .\n\nWhen is encountered, the program will again wait for input. Enter the value . The input goes into the input buffer, and the value is extracted to variable . Finally, the program will print .\n\nThere should be nothing surprising about this run.\n\nRun #2: When is encountered, the program will wait for input. Enter . The input goes into the input buffer, but only the is extracted to variable (extraction stops at the space).\n\nWhen is encountered, the program will not wait for input. Instead, the that is still in the input buffer is extracted to variable . The program then prints .\n\nNote that in run 2, the program didn’t wait for the user to enter additional input when extracting to variable because there was already prior input in the input buffer that could be used.\n\nHere’s a simplified view of how operator works for input.\n• If is not in a good state (e.g. the prior extraction failed and has not yet been cleared), no extraction is attempted, and the extraction process aborts immediately.\n• Leading whitespace characters (spaces, tabs, and newlines at the front of the buffer) are discarded from the input buffer. This will discard an unextracted newline character remaining from a prior line of input.\n• If the input buffer is now empty, operator will wait for the user to enter more data. Any leading whitespace is discarded from the entered data.\n• operator then extracts as many consecutive characters as it can, until it encounters either a newline character (representing the end of the line of input) or a character that is not valid for the variable being extracted to.\n\nThe result of the extraction process is as follows:\n• If the extraction aborted in step 1, then no extraction attempt occurred. Nothing else happens.\n• If any characters were extracted in step 4 above, extraction is a success. The extracted characters are converted into a value that is then copy-assigned to the variable.\n• If no characters could be extracted in step 4 above, extraction has failed. The object being extracted to is copy-assigned the value (as of C++11), and any future extractions will immediately fail (until is cleared).\n\nAny non-extracted characters (including newlines) remain available for the next extraction attempt.\n\nFor example, given the following snippet:\n\nHere’s what happens in a three different input cases:\n• If the user types and enter, will be added to the buffer. will be extracted, converted to an integer, and assigned to variable . will be left in the input buffer for the next extraction.\n• If the user types ‘b’ and enter, would be added to the buffer. Because is not a valid integer, no characters can be extracted, so this is an extraction failure. Variable would be set to , and future extractions will fail until the input stream is cleared.\n• If is not in a good state due to a prior failed extraction, nothing happens here. The value of variable is not altered.\n\nWe’ll explore more cases in the quiz below.\n\nNew programmers often mix up , , the insertion operator ( ) and the extraction operator ( ). Here’s an easy way to remember:\n• and always go on the left-hand side of the operator.\n• is used to output a value (cout = character output).\n• is used to get an input value (cin = character input).\n• is used with , and shows the direction that data is moving. moves the value to the console.\n• is used with , and shows the direction that data is moving. moves the value the user entered from the keyboard into variable .\n\nWe’ll talk more about operators in lesson 1.9 -- Introduction to literals and operators.\n\nConsider the following program that we used above:\n\nThe program expects you to enter an integer value, as the variable that the user input will be put into is an integer variable.\n\nRun this program multiple times and describe the output that results when you enter the following types of input:\n\nb) A number with a fractional part (e.g. ). Try numbers with fractional parts less than 0.5 and greater than 0.5 (e.g. and ).\n\nc) A small negative integer, such as .\n\ne) A really big number (at least 3 billion).\n\nf) A small number followed by some letters, such as .\n\ng) A few letters followed by a small number, such as .\n\nh) (three spaces, followed by a plus symbol, and a 5).\n\nAsk the user to enter three values. The program should then print these values. Add an appropriate comment above function .\n\nThe program should match the following output (when run with input values , , and ):\n\nHint: Comments above a function should describe what the function does."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io/cout",
        "document": "The global objects and control output to a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C output stream stdout.\n\nThese objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as is included before the object is defined).\n\nUnless std::ios_base::sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.\n\nBy specification of std::cin, std::cin.tie() returns &std::cout. This means that any input operation on executes std::cout.flush() (via std::basic_istream::sentry's constructor). Similarly, std::wcin.tie() returns &std::wcout.\n\nBy specification of std::cerr, std::cerr.tie() returns &std::cout. This means that any output operation on executes std::cout.flush() (via std::basic_ostream::sentry's constructor). Similarly, std::wcerr.tie() returns &std::wcout. (since C++11)\n\nThe 'c' in the name refers to \"character\" (stroustrup.com FAQ); means \"character output\" and means \"wide character output\".\n\nBecause dynamic initialization of templated variables are unordered, it is not guaranteed that has been initialized to a usable state before the initialization of such variables begins, unless an object of type std::ios_base::Init has been constructed."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/basic_io",
        "document": "std; main () { i; cout << \"Please enter an integer value: \" ; cin >> i; cout << \"The value you entered is \" << i; cout << \" and its double is \" << i*2 << ; 0; }\n\nPlease enter an integer value: 702 The value you entered is 702 and its double is 1404."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/aabvc4/how_exactly_do_stdcout_and_stdcin_work_and_why_do",
        "document": "I've been coding in C++ for quite a while now and knowing that prints stuff onto terminal and that takes input from terminal was kinda enough.\n\nBut how exactly do they work? Especially considering the whole part with the and ? What makes it different to, let's say, and ? Or compared to other languages with Python's or Java's ? Why do we use instead of ?"
    },
    {
        "link": "https://stackoverflow.com/questions/39874756/should-using-stdcin-and-using-stdcout-be-avoided-or-encouraged",
        "document": "I searched this site and people says you should avoid using . I totally agree. However, what about and ? Should this be avoided or encouraged?\n\nI know always type is the safest choice, but it is very tedious to type them again and again.\n\nHowever, when you type etc in the begining of the file, it seems very crowd. For example, this simple program read and calculate student grade, in front of it, there are too many , it look very uncomfortable.\n\nIn python's tutorial, it says:\n\nRemember, there is nothing wrong with using ! In fact, this is the recommended notation unless the importing module needs to use submodules with the same name from different packages.\n\nI want to know what I should do in c++ programs."
    }
]