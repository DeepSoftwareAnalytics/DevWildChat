[
    {
        "link": "https://doc.qt.io/qt-6",
        "document": "Qt is a full development framework with tools designed to streamline the creation of applications and user interfaces for desktop, embedded, and mobile platforms. See what's new in Qt 6.8.\n\nQt Essentials define the foundation of Qt on all platforms.\n\nQt add-on and extension modules bring additional value for specific purposes. For more information, see All Modules.\n• Classes for applications which use ActiveX and COM (Windows only).\n• UI Components for displaying visually pleasing charts, driven by static or dynamic data models.\n• Implements the client side of CoAP defined by RFC 7252.\n• Classes for writing multi-threaded programs without using low-level threading primitives.\n• Provides functionality for visualizing data in 3D as bar, scatter, and surface graphs, as well as 2D in area, bar, donut, line, pie, scatter, and spline graphs.\n• Provides an ability to generate Qt-based classes from protobuf specifications used to communicate with gRPC® services.\n• A framework for embedding an HTTP server into a Qt application.\n• A QML API for rendering graphics and animations in JSON format, exported by the Bodymovin plugin for Adobe® After Effects.\n• Provides an implementation of the MQTT protocol specification.\n• A rich set of QML types and C++ classes to handle multimedia content. Also includes APIs to handle camera access.\n• Provides support for OAuth-based authorization to online services.\n• Provides access to Near-Field communication (NFC) hardware. On desktop platforms NDEF access is only supported for Type 4 tags.\n• Protocol for data modeling and exchange of data in industrial applications.\n• C++ classes that make it easy to use OpenGL in Qt applications. A separate library (Qt OpenGL Widgets) provides a widget for rendering OpenGL graphics.\n• Provides access to position, satellite info and area monitoring classes.\n• Classes to make printing easier and more portable.\n• Provides an ability to generate Qt-based classes from protobuf specifications.\n• Provides a high-level API for creating 3D content or UIs based on Qt Quick.\n• Provides a C++ widget class for displaying a Qt Quick user interface.\n• Provides QML types for applying one or more simple graphical effects to Qt Quick items.\n• Provides an easy to use mechanism for sharing a QObject's API (Properties/Signals/Slots) between processes or devices.\n• Provides classes and tools for creating state machines from SCXML files and embedding them in applications.\n• Provides access to sensor hardware on Android, iOS, and Windows platforms.\n• Provides access to serial industrial bus interfaces. Currently, the module supports the CAN bus and Modbus protocols.\n• Provides classes to interact with hardware and virtual serial ports.\n• Provides tools for the cross-platform Qt shader pipeline. These enable processing graphics and compute shaders to make them usable for Qt Quick and other components in the Qt ecosystem.\n• Provides support for spatial audio. Create sound scenes in 3D space containing different sound sources and room related properties such as reverb.\n• Provides classes for creating and executing state graphs.\n• Classes for displaying the contents of SVG files. Supports a subset of the SVG 1.2 Tiny standard. A separate library (Qt SVG Widgets) provides support for rendering SVG files in a widget UI.\n• Provides support for synthesizing speech from text and playing it as audio output.\n• Classes for loading QWidget based forms created in Qt Widgets Designer dynamically, at runtime.\n• A framework for implementing different input methods as well as a QML virtual keyboard. Supports localized keyboard layouts and custom visual themes.\n• Provides a framework to develop a Wayland compositor on Linux and Boot to Qt targets.\n• Provides access to QObject or QML objects from HTML clients for seamless integration of Qt applications with HTML/JavaScript clients.\n• Displays web content in a QML application by using APIs native to the platform, without the need to include a full web browser stack.\n• Qt Core APIs that were in Qt 5 but not Qt 6.\n\nQt Framework and tools are available under both open-source and commercial licenses.\n\nThe commercially licensed Qt contains additional functionality and productivity tools. For details, see https://www.qt.io/download/."
    },
    {
        "link": "https://doc.qt.io/qt-6/best-practices.html",
        "document": "2025 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners."
    },
    {
        "link": "https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp",
        "document": "This is the code repository for Cross-Platform Development with Qt 6 and Modern C++, published by Packt.\n\nDesign and build applications with modern graphical user interfaces without worrying about platform dependency\n\nQt is a cross-platform application development framework widely used for developing applications that can run on a wide range of hardware platforms with little to no change in the underlying codebase. If you have basic knowledge of C++ and want to build desktop or mobile applications with a modern graphical user interface (GUI), Qt is the right choice for you. Cross-Platform Development with Qt 6 and Modern C++ helps you understand why Qt is one of the favorite GUI frameworks adopted by industries worldwide, covering the essentials of programming GUI apps across a multitude of platforms using the standard C++17 and Qt 6 features.\n\nThis book covers the following exciting features: Write cross-platform code using the Qt framework to create interactive applications Build a desktop application using Qt Widgets Create a touch-friendly user interface with Qt Quick Develop a mobile application using Qt and deploy it on different platforms Get to grips with Model/View programming with Qt Widgets and Qt Quick Discover Qt’s graphics framework and add animations to your user interface Write test cases using the Qt Test framework and debug code Build a translation-aware application Follow best practices in Qt to write high-performance code\n\nIf you feel this book is for you, get your copy today!\n\nAll of the code is organized into folders. For example, Chapter02.\n\nThe code will look like the following:\n\nFollowing is what you need for this book: This book is for application developers who want to use C++ and Qt to create modern, responsive applications that can be deployed to multiple operating systems such as Microsoft Windows, Apple macOS, and Linux desktop platforms. Although no prior knowledge of Qt is expected, beginner-level knowledge of the C++ programming language and object-oriented programming system (OOPs) concepts will be helpful.\n\nWith the following software and hardware list you can run all code files present in the book (Chapter 1-12).\n\nWe also provide a PDF file that has color images of the screenshots/diagrams used in this book. Click here to download it.\n\nNibedit Dey is a software engineer turned serial entrepreneur with over a decade of experience in building complex software-based products with amazing user interfaces. Before starting his entrepreneurial journey, he worked for Larsen and Toubro and Tektronix in different R&D roles. He holds a bachelor's degree in biomedical engineering and a master's degree in digital design and embedded systems. Specializing in Qt and embedded technologies, his current role involves end-to-end ownership of products right from architecture to delivery. Currently, he manages two technology-driven product startups named ibrum technologies and AIDIA Health. He is a tech-savvy developer who is passionate about embracing new technologies.\n\nIf you have already purchased a print or Kindle version of this book, you can get a DRM-free PDF version at no cost.\n\nSimply click on the link to claim your free PDF."
    },
    {
        "link": "https://qt.io/resources/qt",
        "document": ""
    },
    {
        "link": "https://packtpub.com/en-us/product/cross-platform-development-with-qt-6-and-modern-c-9781800204584?type=print&srsltid=AfmBOorIvp4Wu4-7k1v0cujQz9yrM4EQ01VLRjf1TZAifCofyRyrP6VA",
        "document": "There are different ways to install the Qt framework and tools on your system. You can download an online or offline installer from the Qt website, or you can build the source packages yourself. Qt recommends using the online installer for first-time installations and the Qt Maintenance Tool for modifying the installation later.\n\nThe installers allow you to download and install the following components:\n\nThe online installer allows you to select open source or commercial versions of Qt, tools, and Add-On modules to install based on the chosen license. The online installer doesn't contain the Qt components, but it is a downloader client to download all the relevant files. You can install once the download is complete. You will require a Qt account to download and install Qt. An evaluation version for the commercial Qt gives you free trial-period access, with all commercial packages and access to official Qt support. The installer requires you to sign in with your Qt account. If you don't have a Qt account, you can sign up during the installation process. The installer fetches the license attached to the account from the Qt server and lists down modules according to your license. If you are new to Qt, then we recommend that you start with the open source version.\n\nThe offline installer is a platform-specific package that includes all Qt modules and add-ons relevant for the platform. Due to the official policy changes, open source offline installers are not available any more since Qt 5.15. If you have a commercial license, then you can provide the credentials during the installation process. You can locate your license key in your Qt account web portal.\n\nYou can download them from the following links:\n• Offline: https://www.qt.io/offline-installers The Qt Company provides users with a dual-licensing option. As a beginner, you can get started with an open source license to explore Qt. If you are working for a company, then discuss with your manager or Information Technology (IT) or legal team to procure a commercial license or to understand legal obligations. You can learn more about Qt licensing at https://www.qt.io/licensing/.\n\nLet's start by downloading Qt onto your machine, as follows:\n• Click on the Download. Try. Buy. button in the top-right corner. You will see different download options here.\n• If you want to try the commercial version, then click on Try Qt section. If you already have a Qt account, then you can log in into the account under the Existing customers section.\n• Considering that you are new to Qt, we will begin with the open source version. Click on the Go open source button, as shown in the following screenshot:\n• On the next screen, you will find Download the Qt Online Installer button. Click on it to proceed to the download link.\n• The web page will automatically detect the underlying platform details from the browser and will show you the Download button. You can also select your intended installer by choosing the other options: you can select 32-bit or 64-bit or download for a different platform. You will see a Thank you page after you click on the download option. At this stage, you can find the installer in your folder.\n\nNext, let's begin with the installation process on the Windows platform.\n\nNow, let's start the installation process on Windows! Proceed as follows:\n• You will find a file with the name inside your download folder. Double-click on the executable, and you will see a Welcome screen.\n• Click the Next button, and a credentials screen will appear, asking you to log in with your Qt account. If you don't have one, then you can sign up on the same page, as shown in the following screenshot:\n• In the next screen, you will be presented with the open source usage obligations agreement. You won't get this screen if you are installing using a commercial license. Click on the first checkbox, saying I have read and approve the obligations of using Open Source Qt, and acknowledge that you are not using Qt for commercial purposes. Make sure you read the terms and conditions mentioned in the agreement! Then, click on the Next button.\n• The next screen will provide you with options related to tracking and sharing pseudonymous data in Qt Creator. You may allow or disable these options based on your preferences. Then, click on the Next button to proceed to the next screen.\n• In the next screen, you can specify the installation path. You may continue with the default path, or you can change it to any other path if you don't have enough space on the default drive. You can also choose whether you want to associate common file types with Qt Creator by selecting the checkbox option at the bottom. Click on the Next button.\n• Next, you will be presented with a list where you can select the version(s) of Qt you need to install on your system. You may simply proceed with the default options. If you don't need some of the components, then you can unselect them to reduce the size of the download. You can update the Qt components using the Maintenance Tool anytime later. To complete the installation process, click on the Next button. The component selection screen can be seen here:\n• In the next screen, you will be presented with the license agreement. Click on the first radio button, which says I have read and agree to the terms contained in the license agreements. Again, make sure you read the terms and conditions mentioned in the license agreement, and then click on the Next button.\n• On the next screen, you can create Start menu shortcuts on Windows. This screen will not be available for other platforms. Once you have finished doing this, click on the Next button.\n• Now, Qt is ready to be installed in your system. Make sure you have a working internet connection and data balance. Click on the Install button to begin the installation. The download process will take time, depending on your internet speed. Once the required files are downloaded, the installer will automatically install them in the previously selected path.\n• Once the installation is finished, the installer will make an entry for the Maintenance Tool, which will help you later to make changes to the libraries. Click on the Next button to move to the last screen of the installer.\n• In order to complete the installation process, click on the Finish button. If you have left the Launch Qt Creator checkbox checked, then Qt Creator will be launched. We will discuss this in more detail in the next chapter. Now, Qt is ready to be used on your Windows machine. Click on the Finish button to exit the wizard.\n\nNow, let's install the Qt framework on the latest LTS version of Linux, such as Ubuntu 20.04, CentOS 8.1, or openSUSE 15.1. We will be focusing on the most popular Linux distribution, Ubuntu. You can follow the same steps as mentioned previously to download the online installer from the Qt website.\n\nOn Ubuntu, you will get an installer file such as , where is the latest version— for example: .\n• You may have to give write permissions to the downloaded file before executing it. To do that, open the terminal and run the following command:\n• You can start the install process by double-clicking the downloaded installer file. The installation requires superuser access. You may have to add a password in the authorization dialog during the installation. You can also run the installer from the terminal, as follows:\n• You will see similar screens to those shown for the Windows platform. Apart from the operating system (OS)-specific title bar changes, all the screens remain the same for installation in Ubuntu or similar Linux flavors.\n\nAt the time of writing the book, there was no Ubuntu or Debian package available for Qt 6 as the respective maintainers have stepped down. Hence, you may not get the Qt 6 package from the terminal.\n\nIf you are a macOS user, then you can also install the same way as discussed for the earlier platforms. You can follow the same steps mentioned previously to download the online installer from the Qt website.\n\nYou will get an installer file such as , where is the latest version (such as ).\n\nQt has a dependency on Xcode. To install Qt on your Mac, you will need Xcode installed on your machine, otherwise, it will refuse to install. If you are an Apple developer, then your Mac may have Xcode installed. If you don't have Xcode installed on your machine, then you may proceed to install Xcode's Command Line Tools instead of Xcode. This will save time and storage space on your machine:\n• To begin, type the following command on the terminal:\n• If the terminal shows the following output, then your system is ready for the next steps: xcode-select: error: command line tools are already installed, use \"Software Update\" to install updates\n• The next step is to install the Qt framework. Double-click on the installer file to launch the installation interface.\n• If the installer still complains that Xcode is not installed, then keep clicking OK until the message goes away permanently. Remember the installation path. Once the installation is finished, you are ready to use Qt on your machine.\n\nFurther instructions on Qt for macOS can be found at the following link:\n\nOnce Qt is installed, you can modify the components—including updating, adding, and removing components—using the Maintenance Tool under the installation directory. The directory structure remains the same for all desktop platforms. The installation directory contains folders and files, as shown in the following screenshot (on Windows):\n\nLet's begin with the maintenance process! You can add, remove, and update modules using the Maintenance Tool. Proceed as follows:\n• Click on the executable to launch the maintenance interface. Click on the Next button, and a credentials screen will appear, asking you to log in with your Qt account. The login details will be prefilled from your last login session. You can click Next to add or update components or select the Uninstall only checkbox to remove Qt from your system. The following screenshot shows what the credentials screen looks like: Figure 1.5 – Welcome screen of the Maintenance Tool\n• Once you are logged in, the tool will present you with options to add or remove or update the components, as shown in the following screenshot. Click on the Next button to proceed further:\n• On the next screen, you can select new components from the latest releases or the archived version. You can click on the Filter button to filter versions as per your requirement. You can also add new platform-specific components such as Android from the component list. If the component is existing and you uncheck it, then it will be removed from your desktop during the update. Once you have selected the components, click on the Next button. The following screenshot shows what the component selection screen looks like:\n• You will then come across the update screen. This screen will tell you how much storage space is required for the installation. If you are running out of storage space, then you may go back and remove some existing components. Click on the Update button to begin the process, as illustrated in the following screenshot: Figure 1.8 – The Ready to Update screen of the Maintenance Tool\n• You can abort the update installation process by clicking on the Cancel button. Qt will warn you and ask you for confirmation before aborting the installation process, as illustrated in the following screenshot. Once the process is aborted, click on the Next button to exit the wizard:\n• Launch the Maintenance Tool again to update existing components from the latest releases. You can click on the Quit button to exit the Maintenance Tool. Please wait while the installer fetches the meta-information from the remote repository. Click on the Next button to see the available components. The update option is illustrated in the following screenshot: Figure 1.10 – The Update option in the Maintenance Tool\n• Next, you can select which components to update from the checkboxes. You can choose to update all or you can update selectively. The installer will show how much storage space will be required for the update, as illustrated in the following screenshot. You can click Next to go to the update screen and begin the update. Then, on the next screen, click on the Update button to download the update packages:\n• Once the installation is finished, the installer makes entries for the Maintenance Tool, which will help you make changes to the libraries later. This is illustrated in the following screenshot. Click on the Next button to move to the last screen of the installer: Figure 1.12 – The Update finished screen in the Maintenance Tool\n• In the last screen, you will see Restart and Finish buttons. Click on the Finish button to exit the Qt wizard.\n• Similarly, you can restart or launch the Maintenance Tool and select the Remove all components radio button. Click on the Next button to begin the uninstallation process, as illustrated in the following screenshot:\n\nFigure 1.13 – The Remove option in the Maintenance Tool\n\nPlease note that on clicking the Uninstall button, all the Qt components will be removed from your system; you will have to reinstall Qt if you want to use them again. Click on Cancel if you don't intend to remove the Qt components from your system, as illustrated in the following screenshot. If you intend to remove the existing version and use a newer version of Qt, then select the Add or remove components option, as discussed earlier. This will remove older Qt modules and free up your disk space:\n\nFigure 1.14 – The Uninstall screen in the Maintenance Tool\n\nIn this section, we learned about modifying an existing Qt installation through the Maintenance Tool. Now, let's learn how to build and install Qt from the source code."
    },
    {
        "link": "https://developer.android.com/ndk/guides",
        "document": "The Native Development Kit (NDK) is a set of tools that allows you to use C and C++ code with Android, and provides platform libraries you can use to manage native activities and access physical device components, such as sensors and touch input. The NDK may not be appropriate for most novice Android programmers who need to use only Java code and framework APIs to develop their apps. However, the NDK can be useful for cases in which you need to do one or more of the following:\n• Squeeze extra performance out of a device to achieve low latency or run computationally intensive applications, such as games or physics simulations.\n• Reuse your own or other developers' C or C++ libraries.\n\nUsing Android Studio 2.2 and higher, you can use the NDK to compile C and C++ code into a native library and package it into your APK using Gradle, the IDE's integrated build system. Your Java code can then call functions in your native library through the Java Native Interface (JNI) framework. To learn more about Gradle and the Android build system, read Configure Your Build.\n\nAndroid Studio's default build tool to compile native libraries is CMake. Android Studio also supports ndk-build due to the large number of existing projects that use the build toolkit. However, if you are creating a new native library, you should use CMake.\n\nThis guide gives you the information you need to get up and running with the NDK on Android Studio. If you don't have the latest version of Android Studio, download and install it now.\n\nAttention experimental Gradle users: Consider migrating to plugin version 2.2.0 or higher, and using CMake or ndk-build to build your native libraries if any of the following apply to you: Your native project already uses CMake or ndk-build; you would rather use a stable version of the Gradle build system; or you want support for add-on tools, such as CCache. Otherwise, you can continue to use the experimental version of Gradle and the Android plugin.\n\nTo compile and debug native code for your app, you need the following components:\n• The Android Native Development Kit (NDK): a set of tools that allows you to use C and C++ code with Android.\n• CMake: an external build tool that works alongside Gradle to build your native library. You do not need this component if you only plan to use ndk-build.\n• LLDB: the debugger Android Studio uses to debug native code.\n\nFor information on installing these components, see Install and configure the NDK and CMake.\n\nOnce you set up Android Studio, you can simply Create a New Project with C/C++ Support. However, if you want to add or import native code to an existing Android Studio project, you need to follow this basic process:\n• Create new native source files and add them to your Android Studio project.\n• You can skip this step if you already have native code or want to import a prebuilt native library.\n• Create a CMake build script to tell CMake how to build your native sources into a library. You also require this build script if you are importing and linking against prebuilt or platform libraries.\n• You can skip this step if your existing native library already has a build script, or uses ndk-build and includes an build script.\n• Link Gradle to your native library by providing a path to your CMake or ndk-build script file. Gradle uses the build script to import source code into your Android Studio project and package your native library (the SO file) into the APK. Note: If your existing project uses the deprecated tool, you should open your file and remove the following line of code before configuring Gradle to use CMake or ndk-build:\n• Build and run your app by clicking Run . Gradle adds your CMake or ndk-build process as a dependency to compile, build, and package your native library with your APK.\n\nOnce your app is running on a physical device or the emulator, you can use Android Studio to Debug your app. Otherwise, to learn more about the NDK and its components, read the Concepts page."
    },
    {
        "link": "https://developer.android.com/studio/projects/add-native-code",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAdd C and C++ code to your Android project by placing the code into a directory in your project module. When you build your project, this code is compiled into a native library that Gradle can package with your app. Your Java or Kotlin code can then call functions in your native library through the Java Native Interface (JNI). To learn more about using the JNI framework, read JNI tips for Android.\n\nAndroid Studio supports CMake, which is useful for cross-platform projects. Android Studio also supports , which can be faster than CMake but only supports Android. Using both CMake and in the same module is not currently supported.\n\nTo import an existing library into your Android Studio project, learn how to link Gradle to your native library project.\n\nThis page shows you how to set up Android Studio with the necessary build tools, create a new project with C/C++ support, and add new C/C++ files to your project.\n\nIf instead you want to add native code to an existing project, follow these steps:\n• Create new native source files and add the files to your Android Studio project.\n• Skip this step if you already have native code or want to import a prebuilt native library.\n• Configure CMake to build your native source code into a library. This build script is required if you are importing and linking against prebuilt or platform libraries.\n• If you have an existing native library that already has a build script or uses and includes an build script, skip this step.\n• Configure Gradle by providing a path to your CMake or script file. Gradle uses the build script to import source code into your Android Studio project and package your native library into the app.\n\nOnce you configure your project, access your native functions from Java or Kotlin code using the JNI framework. To build and run your app, click Run .\n\nNote: If your existing project uses the deprecated tool, migrate to using either CMake or .\n\nTo compile and debug native code for your app, you need the following components:\n• The Android Native Development Kit (NDK): a toolset that lets you use C and C++ code with Android. NDK provides platform libraries that let you manage native activities and access physical device components, such as sensors and touch input.\n• CMake: an external build tool that works alongside Gradle to build your native library. You don't need this component if you only plan to use .\n• LLDB: the debugger in Android Studio that debugs native code.\n\nFor information on installing these components, see Install and configure the NDK and CMake.\n\nTo create a new project with support for native code, the process is similar to creating any other Android Studio project, but with an additional step:\n• In the Choose your project section of the wizard, select the Native C++ project type.\n• Complete all other fields in the next section of the wizard.\n• In the Customize C++ Support section of the wizard, you can customize your project with the C++ Standard field.\n• Use the drop-down list to select which standardization of C++ you want to use. Selecting Toolchain Default uses the default CMake setting.\n\nAfter Android Studio finishes creating your new project, open the Project pane from the left side of the IDE and select the Android view from the menu. As shown in figure 1, Android Studio adds the cpp group:\n\nFigure 1. Android view groups for your native sources and external build scripts.\n\nNote: This view does not reflect the actual file hierarchy on disk, but groups similar files to simplify navigating your project.\n\nThe cpp group is where you can find all the native source files, headers, build scripts for CMake or , and prebuilt libraries that are a part of your project. For new projects, Android Studio creates a sample C++ source file, , and places it in the directory of your app module. This sample code provides a simple C++ function, , that returns the string \"Hello from C++\" . Learn how to add additional source files to your project in the section about how to create new native source files.\n\nSimilar to how files instruct Gradle how to build your app, CMake and require a build script to know how to build your native library. For new projects, Android Studio creates a CMake build script, , and places it in your module’s root directory. To learn more about the contents of this build script, read Configure CMake.\n\nWhen you click Run , Android Studio builds and launches an app that displays the text \"Hello from C++\" on your Android device or emulator. The following overview describes the events that occur to build and run the sample app:\n• CMake follows commands in the build script to compile a C++ source file, , into a shared object library and names it . Gradle then packages it into the app.\n• During runtime, the app's loads the native library using . The library’s native function, , is now available to the app.\n• calls , which returns \"Hello from C++\" and uses it to update the .\n\nTo verify that Gradle packages the native library in the app, use the APK Analyzer:\n• Select the APK or AAB from the directory and click OK.\n• As shown in figure 2, you can see in the APK Analyzer window under .\n\nTip: If you want to experiment with other Android apps that use native code, click File > New > Import Sample and select a sample project from the Ndk list.\n\nTo add new C/C++ source files to an existing project, proceed as follows:\n• If you don't already have a directory in the main source set of your app, create one as follows:\n• Open the Project pane in the left side of the IDE and select the Project view from the menu.\n• Right-click on the main directory and select New > Directory.\n• Enter as the directory name and click OK.\n• Right-click the directory and select New > C/C++ Source File.\n• Enter a name for your source file, such as .\n• From the Type menu, select the file extension for your source file, such as .\n• Click Edit File Types to add other file types to the menu, such as or . In the New File Extensions dialog box that pops up, select another file extension from the Source Extension and Header Extension menus and click OK.\n• To create a header file, select the Create an associated header checkbox.\n\nAfter you add new C/C++ files to you project, you still need to configure CMake to include the files in your native library.\n\nTo learn more about supporting C/C++ code in your app, try the following resource.\n• Create Hello-CMake with Android Studio This codelab shows you how to use the Android Studio CMake template to start Android NDK project development."
    },
    {
        "link": "https://medium.com/androiddevelopers/getting-started-with-c-and-android-native-activities-2213b402ffff",
        "document": "I would like to walk you through setting up a simple Android Native Activity. I will walk through the basic setup, and try to give you the tools you need to move forward.\n\nAlthough my focus is on games, I will not be telling you how to write an OpenGL application or how to architect your own game engine. That is a discussion that literally fills up books.\n\nOn Android, the OS and its supporting infrastructure are designed to support applications written in the Java or Kotlin programming languages. Applications written in these languages benefit from tooling embedded deep into the system’s underlying architecture. Many core Android system features, such as the Android UI and Intent handling, are only exposed through Java interfaces.\n\nBy choosing to use C++, you are not being “more native” to Android than using a managed language such as Kotlin or Java. Counter intuitively, you are in some ways writing a foreign application with only a subset of Android features available. For most applications, you’re better off with languages like Kotlin.\n\nThere are a few exceptions to this rule. Near and dear to my own heart is game development. Since games typically use custom rendering logic, often written in OpenGL or Vulkan, it’s expected that a game looks different from a standard Android application. When you also consider that C and C++ are near universal to every computing platform, and the relative wealth of C libraries to support games development, it may become reasonable to set off down the path of native development.\n\nIf you want to make a game from scratch or port over an existing game, Android’s Native Development Kit (or NDK) and its supporting tooling are ready and waiting. In fact, the native activity I’ll be showing you provides an easy one-stop shop in which you can set up an OpenGL canvas and start gathering user input. You may find that despite C’s cognitive overhead, some common code challenges like building vertex attribute arrays from game data become easier in C++ than higher level languages.\n\nI will stop short of showing you how to initialize a Vulkan or OpenGL context. I recommend reading through the samples Google provides, although I will provide some tips to make your life easier. You may opt instead to use a library like SDL or even Google’s FPLBase instead.\n\nFirst we need to make sure that you have everything installed for native development. For this, we need the Android NDK. Launch Android Studio:\n\nFrom here install LLDB (the native debugger), CMake (the build system we’ll use), and the NDK itself:\n\nNow that you have everything setup, we’ll create a project. We’ll want to create an empty project with no Activity:\n\nNativeActivity has been in Android since Gingerbread, but I’d recommend choosing the highest target available to you at the time if you’re just learning.\n\nNow we need to make a CMakeLists.txt to tell Android how to build our C++ project. Right click on your app in the project view, and create a new file:\n\nWe’re stating that we’re using the latest CMake in Android Studio (3.6.0), and that we’re building a shared library called helloworld-c. I also added a source file that we have to create.\n\nWhy a shared library and not an executable? Android uses a process called Zygote, to accelerate the process of launching an application or service inside the Android Runtime. This applies to every user-facing process in Android, so the first chance your app will get to run code will actually be inside a managed VM. The managed code then must load a shared library file with your logic in it, which is handled for you if you use a native activity. Conversely, when building an executable the expectation is that the operating system will directly load your program and execute a C function called “main.” This is possible in Android, but I haven’t found any practical uses for it.\n\nNow to create the C++ file:\n\nAnd relocate it to the directory we specified in the make file:\n\nAnd let’s put in something small that will tell us if it’s building correctly:\n\nAnd finally, let’s link the C++ project into our application:\n\nIf all goes well, the project will update successfully:\n\nAnd you can run a build without any issues:\n\nAs for what changed in your build script. If you open your app’s build.gradle, you should see this entry:\n\nAn Activity is basically the window Android uses show an interface to your app. Normally you would write a class in Java or Kotlin that extends Activity, but Google created a special C equivalent called a native activity.\n\nThe best way to create a native activity is to include . Many samples copy it out of the SDK and into their project. There’s nothing wrong with this, but it’s my personal preference to leave it in place and make this a library that my game depends on. I’ll make this a STATIC library so I don’t pay the extra cost of dynamic library calls:\n\nThere’s a lot to break down here, so lets start. First I to create a library called and denote it as a library. Then I look for the automatically generated environment variable to look for some files in the NDK installation. Using this, I pull out the implementation for native_app_glue: .\n\nAfter I have my code associated with a target, I want to say where the target finds its header files. I use to pull in the folder with all of its headers and denote these as headers. Other options are or those scopes are irrelevant for now. Some tutorials might use instead of . This is an older practice. The more recent lets you associate the directories with a target, which helps reduce complexity on larger projects.\n\nNow, I’m going to want to be able to log stuff to Android’s LogCat. Just writing to standard output (ex: or ) doesn’t work as well as it does in normal C and C++ applications. Using to locate , we cache Android’s logging library to reference later.\n\nFinally we tell CMake to make depend on , , and the library we called using . This will let us reference the native app logic in our C++ project. The call before also makes sure that helloworld-c doesn’t implement a function called which is provided by .\n\nFirst, with , we’re just telling the linker that we need to treat everything between those curly braces as C. You can still write C++ code inside of there, but the functions will look like C functions to the rest of our program.\n\nI’m creating a small placeholder function . This will serve as our message loop in the future. Any touch events, window events, &c will come through here.\n\nThe meat of the program is . This is called by when your application starts up. We start by pointing to our message loop so that system messages have somewhere to go.\n\nNext we use to handle all the system events that have queued up, and the first argument is a timeout. If we get a value greater than or equal to 0, we need to help process the event. Otherwise we continue until the app closes.\n\nWe still can’t run this activity, but feel free to build to make sure everything’s still OK.\n\nAdd the required information to your ApplicationManifest\n\nNow we need to fill out your AndroidManifest.xml to tell your system how to run your app. You can find it under app>manifests>AndroidManfiest.xml:\n\nFirst we’ll tell Android android about the native activity (called “android.app.NativeActivity”) and tell it not to destroy the activity for orientation changes or keyboard state changes:\n\nThen we tell the native activity where to find the code we want to run. If you’ve forgotten the name, check your CMakeLists.txt!\n\nAnd we tell the Android operating system that this is a launcher activity and the main activity:\n\nIf everything goes well, you can hit debug and see a blank window!\n\nThere are already excellent OpenGL samples in the google samples repository:\n\nI will give you a few helpful hints to get started. First, to use OpenGL, add the following lines to your CMakeLists.txt:\n\nThere’s a lot more intelligence that you can do here for various Android platforms, but adding EGL and GLESv3 to your target will be fine for recent versions of Android.\n\nNext, I like to create a class called for handling my rendering. If you create one with a constructor to initialize your renderer, destructor to destroy it, and a function to render, I’d suggest making your app look like this:\n\nSo, the first thing I’ve done is start to use this little field in called . You can store any one thing you want here, and every instance of this will get it. I chose to add my renderer.\n\nNext, I can only have a renderer after the window is initialized and must get rid of it when it’s destroyed. I use that function that I told you about earlier to do this.\n\nFinally, if there is a renderer (ie: the window has been created), I retrieve it from and ask it to render. Otherwise I just continue processing this loop.\n\nAt this point, you’re ready to use OpenGL ES 3 as if you were on any other platform! Here are some helpful links if you need more resources or tutorials:\n• Google’s Android NDK samples were invaluable for me to piece together this tutorial: https://github.com/googlesamples/android-ndk/\n• CMake is my preferred build system on Android for C++, you can find the reference pages here: https://cmake.org/\n• If you’re new to CMake, or if instead of is new to you, I recommend reading up on “modern” CMake: https://cliutils.gitlab.io/modern-cmake/\n• Android’s Java OpenGL tutorial. It is Java centric, but discusses many Android-specific concerns: https://developer.android.com/training/graphics/opengl/\n• NeHe’s OpenGL tutorials are a bit dated and focused on older desktop versions of OpenGL. I still have yet to find a better getting started tutorial on OpenGL: http://nehe.gamedev.net/"
    },
    {
        "link": "https://dev.to/wetest/a-comprehensive-guide-to-android-ndk-development-with-android-studio-1d5c",
        "document": "The Native Development Kit (NDK) is a collection of tools designed to help developers efficiently create C or C++ dynamic libraries and automatically package the .so files and Java applications into an APK. There are several reasons why developers might choose to use the NDK:\n• None Code protection: Java code in APKs can be easily decompiled, making it vulnerable to reverse engineering. In contrast, C/C++ libraries are more difficult to reverse compile, offering better protection.\n• None Utilization of existing open-source libraries: A vast majority of open-source libraries are written in C/C++ code, making it convenient for developers to incorporate them into their projects.\n• None Enhanced execution efficiency: Developing high-performance application logic using C can significantly improve the execution efficiency of an application, resulting in a better user experience.\n• None Portability: Libraries written in C/C++ can be easily reused on other embedded platforms, making it simpler for developers to port their applications to different devices.\n\nAfter downloading the NDK zip package, extract it to the D:\\Android directory:\n\nWith this package, there is no need to install Cygwin, as the NDK package already includes integrated Linux compilation functionality. This makes the process more convenient and straightforward for developers.\n\nCreate a new project in Android Studio or add a new module.\n\n This article will not go into detail on how to do this. In my example, I added a new Android library-type module to an existing project, named cloudNDKTest.\n\nClick on the menu bar File --> Project Structure, or use the shortcut key Ctrl+Alt+Shift+S. Then, follow the steps shown in the image:\n\nAfter completing this, a configuration will be generated in the local.properties file:\n\nWrite native method\n\n Create a new Java file and declare a static native method. Don't worry if the method name appears in red:\n\nCompile the project\n\n Execute \"Make Project\" to compile the corresponding class files, which will be needed later when generating the .h files.\n\nCreate a JNI directory\n\n Switch the view from Android to Project, and create a JNI directory under the src/main directory, at the same level as the Java directory.\n\nGenerate the C++ .h file\n\n Click on the menu bar View --> Tool Windows --> Terminal, or use the shortcut key Alt+F12 to bring up the terminal window:\n\nThen, execute the following command in the Terminal window:\n\nHere, javah is the tool needed to generate header files, -d specifies the directory location for file creation, and -classpath specifies the file location of android.jar in the SDK folder. After the semicolon, it specifies the class file generated in step 4.\n\nWrite the CPP file\n\n Create a CPP file in the JNI directory, and do not check the part marked in red below, as the .h file already exists.\n\nWrite the CPP file, include the previously created .h file, and implement the specific function.\n\nCompile\n\n a. First, add the following content to the module's build.gradle:\n\nThe above configuration code specifies the .so library name as CloudNdkTest; the library used during linking, corresponding to the LOCAL_LDLIBS in the Android.mk file; and the final output specifies the .so library under three ABI architectures.\n\nc. Add a reference to the static library in the Java class written in step\n\nd. If you encounter the following error, please create an empty util.c file in the JNI directory. This is said to be a bug in the NDK.\n\nIf the CPP implementation uses the STL library, you need to add the following in step 8.a:\n\nCurrently, several compilation and linking methods are supported:\n\nstlport_static --> Use the stlport version of STL with static linking\n\n stlport_shared --> Use the stlport version of STL with dynamic linking\n\ngnustl_static --> Use the GNU version of STL with static linking\n\nIt is important to note that it is better to compile through static libraries, as this will not cause conflicts between .so files in multiple modules and will also reduce the final package file size.\n\nFor more information, check out WeTest services."
    },
    {
        "link": "https://foreignerds.com/blog-can-c-be-used-for-android-app-development",
        "document": "Android app development primarily revolves around the use of Java or Kotlin, the officially supported programming languages by Google. However, developers often ponder the feasibility of applying their C++ expertise to create Android apps. C++ is renowned for its power, versatility, low-level control, high performance, and cross-platform compatibility. This article delves into the possibilities of employing C++ for Android app development.\n\nCan I Develop an Android App Using C++?\n\nIndeed, it is feasible to craft Android applications utilizing C++. While Java and Kotlin stand as the preferred choices for Android development, Google offers the Android Native Development Kit (NDK). This kit empowers developers to compose portions of their apps in C++ and establish connections with the Java-based Android framework. This approach permits developers to harness the performance advantages of C++ while tapping into Android’s rich array of APIs and libraries.\n\nExploring C++ for Android App Development: Step by Step\n\nBegin by installing the Android NDK and configuring your development environment. The NDK equips you with essential tools and libraries tailored for crafting native Android applications with C++.\n\nInitiate the development of your Android app’s logic in C++. You can employ well-established C++ frameworks like Qt or SDL, or you can directly engage with the Android NDK APIs to interact with the system. Keep in mind that while C++ offers performance advantages, it may necessitate more expertise and effort compared to using Java or Kotlin.\n\nTo seamlessly integrate your C++ code with the Java-based Android framework, establish a Java Native Interface (JNI) acting as a bridge between the two languages. The JNI facilitates the calling of C++ functions from Java and vice versa. Defining the JNI interface grants you access to the C++ code within your Java-based Android app.\n\nAfter crafting your C++ code and establishing the JNI interface, proceed to build and compile your app. Employ the Android NDK build system to generate the essential binaries and libraries, which will be bundled with your Android application.\n\nThoroughly test your app to ensure it functions as intended. You can employ Android emulators or physical devices for testing purposes. Once satisfied with the results, package your app, including the C++ binaries and libraries, and deploy it to platforms like the Google Play Store.\n• Is C++ faster than\n\nWhile C++ is generally renowned for its speed due to low-level control and efficient memory management, the performance disparities in typical Android app scenarios might not be discernible. Java and Kotlin are optimized for Android development, delivering outstanding performance. Nonetheless, if specific performance-critical sections exist in your app, leveraging C++ could offer certain advantages.\n• Can I mix C++ with Java or Kotlin in my Android app?\n\nAbsolutely. The Android NDK accommodates the incorporation of C++ code alongside Java or Kotlin in your Android app. This approach proves advantageous when integrating existing C++ libraries or optimizing specific app sections with C++, while still leveraging the Android framework through Java or Kotlin.\n• Are there any limitations associated with using C++ for Android app development?\n\nEmploying C++ for Android app development presents certain considerations and limitations. C++ necessitates more hands-on memory management, demanding vigilance against memory leaks and other low-level issues. Additionally, not all Android APIs have direct bindings in C++, potentially requiring the creation of Java or Kotlin components.\n• Can I develop cross-platform apps using C++ for Android and iOS?\n\nYes, one of C++’s merits in Android app development is its cross-platform potential. Crafting platform-agnostic code in C++ enables reuse for iOS app development via tools such as Apple’s Xcode and Swift. This fosters efficient code sharing between Android and iOS platforms.\n• Which IDEs support C++ for Android app development?\n\nSeveral prominent integrated development environments (IDEs) support C++ for Android app development, including Android Studio, Visual Studio, and Eclipse. These IDEs furnish dedicated tools and features for collaborating with the Android NDK, streamlining development and supplying essential debugging and profiling capabilities.\n\nIn summary, while Java and Kotlin remain the recommended choices for Android app development, the prospect of utilizing C++ is indeed viable. Developers can harness the benefits of C++ in terms of performance and cross-platform compatibility by leveraging the Android NDK and establishing a JNI interface. However, it’s crucial to weigh the additional complexity and manual memory management associated with C++.\n\nWhen determining whether to adopt C++ for your Android app, carefully consider your project’s specific requirements, the necessity for low-level control and performance optimization, and the availability of relevant C++ libraries or pre-existing codebases. It is essential to subject your app to comprehensive testing to ensure compatibility across various Android devices.\n\nIf you are an experienced C++ developer aiming to venture into Android app development or possess distinct performance prerequisites, exploring the possibilities of C++ for Android app development holds substantial promise."
    },
    {
        "link": "https://baeldung.com/jni",
        "document": "As we know, one of the main strengths of Java is its portability – meaning that once we write and compile code, the result of this process is platform-independent bytecode.\n\nSimply put, this can run on any machine or device capable of running a Java Virtual Machine, and it will work as seamlessly as we could expect.\n\nHowever, sometimes we do actually need to use code that’s natively-compiled for a specific architecture.\n\nThere could be some reasons for needing to use native code:\n• The need to handle some hardware\n• An existing library that we want to reuse instead of rewriting it in Java.\n\nTo achieve this, the JDK introduces a bridge between the bytecode running in our JVM and the native code (usually written in C or C++).\n\nThe tool is called Java Native Interface. In this article, we’ll see how it is to write some code with it.\n\nJava provides the native keyword that’s used to indicate that the method implementation will be provided by a native code.\n\nNormally, when making a native executable program, we can choose to use static or shared libs:\n• Static libs – all library binaries will be included as part of our executable during the linking process. Thus, we won’t need the libs anymore, but it’ll increase the size of our executable file.\n• Shared libs – the final executable only has references to the libs, not the code itself. It requires that the environment in which we run our executable has access to all the files of the libs used by our program.\n\nThe latter is what makes sense for JNI as we can’t mix bytecode and natively compiled code into the same binary file.\n\nTherefore, our shared lib will keep the native code separately within its .so/.dll/.dylib file (depending on which Operating System we’re using) instead of being part of our classes.\n\nThe native keyword transforms our method into a sort of abstract method:\n\nWith the main difference that instead of being implemented by another Java class, it will be implemented in a separated native shared library.\n\nA table with pointers in memory to the implementation of all of our native methods will be constructed so they can be called from our Java code.\n\nHere’s a brief description of the key components that we need to take into account. We’ll explain them further later in this article\n• Java Code – our classes. They will include at least one native method.\n• Native Code – the actual logic of our native methods, usually coded in C or C++.\n• JNI header file – this header file for C/C++ (include/jni.h into the JDK directory) includes all definitions of JNI elements that we may use into our native programs.\n• C/C++ Compiler – we can choose between GCC, Clang, Visual Studio, or any other we like as far as it’s able to generate a native shared library for our platform.\n• “native” keyword – as we’ve already covered, any method marked as native must be implemented in a native, shared lib.\n• System.loadLibrary(String libname) – a static method that loads a shared library from the file system into memory and makes its exported functions available for our Java code.\n\nC/C++ elements (many of them defined within jni.h)\n• JNIEXPORT- marks the function into the shared lib as exportable so it will be included in the function table, and thus JNI can find it\n• JNICALL – combined with JNIEXPORT, it ensures that our methods are available for the JNI framework\n• JNIEnv – a structure containing methods that we can use our native code to access Java elements\n• JavaVM – a structure that lets us manipulate a running JVM (or even start a new one) adding threads to it, destroying it, etc…\n\nNext, let’s look at how JNI works in practice.\n\nIn this tutorial, we’ll use C++ as the native language and G++ as compiler and linker.\n\nWe can use any other compiler of our preference, but here’s how to install G++ on Ubuntu, Windows, and MacOS:\n• MacOS – run command “g++” in a terminal and if it’s not yet present, it will install it.\n\nLet’s start creating our first JNI program by implementing a classic “Hello World”.\n\nTo begin, we create the following Java class that includes the native method that will perform the work:\n\nAs we can see, we load the shared library in a static block. This ensures that it will be ready when we need it and from wherever we need it.\n\nAlternatively, in this trivial program, we could instead load the library just before calling our native method because we’re not using the native library anywhere else.\n\nNow, we need to create the implementation of our native method in C++.\n\nWithin C++ the definition and the implementation are usually stored in .h and .cpp files respectively.\n\nFirst, to create the definition of the method, we have to use the -h flag of the Java compiler. It should be noted that for versions earlier than java 9, we should use the javah tool instead of javac -h command:\n\nThis will generate a com_baeldung_jni_HelloWorldJNI.h file with all the native methods included in the class passed as a parameter, in this case, only one:\n\nAs we can see, the function name is automatically generated using the fully qualified package, class and method name.\n\nAlso, something interesting that we can notice is that we’re getting two parameters passed to our function; a pointer to the current JNIEnv; and also the Java object that the method is attached to, the instance of our HelloWorldJNI class.\n\nNow, we have to create a new .cpp file for the implementation of the sayHello function. This is where we’ll perform actions that print “Hello World” to console.\n\nWe’ll name our .cpp file with the same name as the .h one containing the header and add this code to implement the native function:\n\nAt this point, we have all parts we need in place and have a connection between them.\n\nWe need to build our shared library from the C++ code and run it!\n\nTo do so, we have to use G++ compiler, not forgetting to include the JNI headers from our Java JDK installation.\n\nOnce we have the code compiled for our platform into the file com_baeldung_jni_HelloWorldJNI.o, we have to include it in a new shared library. Whatever we decide to name it is the argument passed into the method System.loadLibrary.\n\nWe named ours “native”, and we’ll load it when running our Java code.\n\nThe G++ linker then links the C++ object files into our bridged library.\n\nWe can now run our program from the command line.\n\nHowever, we need to add the full path to the directory containing the library we’ve just generated. This way Java will know where to look for our native libs:\n\nSaying hello is nice but not very useful. Usually, we would like to exchange data between Java and C++ code and manage this data in our program.\n\nWe’ll add some parameters to our native methods. Let’s create a new class called ExampleParametersJNI with two native methods using parameters and returns of different types:\n\nAnd then, repeat the procedure to create a new .h file with “javac -h” as we did before.\n\nNow create the corresponding .cpp file with the implementation of the new C++ method:\n\nWe’ve used the pointer *env of type JNIEnv to access the methods provided by the JNI environment instance.\n\nJNIEnv allows us, in this case, to pass Java Strings into our C++ code and back out without worrying about the implementation.\n\nWe can check the equivalence of Java types and C JNI types into Oracle official documentation.\n\nTo test our code, we’ve to repeat all the compilation steps of the previous HelloWorld example.\n\n4.2. Using Objects and Calling Java Methods From Native Code\n\nIn this last example, we’re going to see how we can manipulate Java objects into our native C++ code.\n\nWe’ll start creating a new class UserData that we’ll use to store some user info:\n\nThen, we’ll create another Java class called ExampleObjectsJNI with some native methods with which we’ll manage objects of type UserData:\n\nOne more time, let’s create the .h header and then the C++ implementation of our native methods on a new .cpp file:\n\nAgain, we’re using the JNIEnv *env pointer to access the needed classes, objects, fields and methods from the running JVM.\n\nNormally, we just need to provide the full class name to access a Java class, or the correct method name and signature to access an object method.\n\nWe’re even creating an instance of the class com.baeldung.jni.UserData in our native code. Once we have the instance, we can manipulate all its properties and methods in a way similar to Java reflection.\n\nWe can check all other methods of JNIEnv into the Oracle official documentation.\n\nJNI bridging does have its pitfalls.\n\nThe main downside being the dependency on the underlying platform; we essentially lose the “write once, run anywhere” feature of Java. This means that we’ll have to build a new lib for each new combination of platform and architecture we want to support. Imagine the impact that this could have on the build process if we supported Windows, Linux, Android, MacOS…\n\nJNI not only adds a layer of complexity to our program. It also adds a costly layer of communication between the code running into the JVM and our native code: we need to convert the data exchanged in both ways between Java and C++ in a marshaling/unmarshaling process.\n\nSometimes there isn’t even a direct conversion between types so we’ll have to write our equivalent.\n\nCompiling the code for a specific platform (usually) makes it faster than running bytecode.\n\nThis makes it useful when we need to speed up a demanding process. Also, when we don’t have other alternatives such as when we need to use a library that manages a device.\n\nHowever, this comes at a price as we’ll have to maintain additional code for each different platform we support.\n\nThat’s why it’s usually a good idea to only use JNI in the cases where there’s no Java alternative."
    },
    {
        "link": "https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html",
        "document": "At times, it is necessary to use native (non-Java) codes (e.g., C/C++) to overcome the memory management and performance constraints in Java. Java supports native codes via the Java Native Interface (JNI).\n\nJNI is difficult, as it involves two languages and runtimes.\n\nI shall assume that you are familiar with:\n• C/C++ and the GCC Compiler (Read \"GCC and Make\").\n• (For Windows) Cygwin or MinGW (Read \"How to Setup Cygwin and MinGW\").\n\nStep 1: Write a Java Class that uses C Codes\n\nThe static initializer invokes to load the native library \" \" (which contains a native method called ) during the class loading. It will be mapped to \" \" in Windows; or \" in Unixes/Mac OS X. This library shall be included in Java's library path (kept in Java system variable ). You could include the library into Java's library path via VM argument . The program will throw a if the library cannot be found in runtime.\n\nNext, we declare the method as a native instance method, via keyword which denotes that this method is implemented in another language. A native method does not contain a body. The shall be found in the native library loaded.\n\nThe method allocates an instance of and invoke the native method .\n\nStarting from JDK 8, you should use \" \" to compile the Java program AND generate C/C++ header file called as follows:\n\nThe \" \" option generates C/C++ header and places it in the directory specified (in the above example, for the current directory).\n\nBefore JDK 8, you need to compile the Java program using and generate C/C++ header using a dedicated utility, as follows. The utility is no longer available in JDK 10.\n\nThe header declares a C function as follows:\n\nThe naming convention for the C function is . The dot in package name is replaced by underscore.\n• : reference to JNI environment, which lets you access all the JNI functions.\n\nWe are not using these arguments in this hello-world example, but will be using them later. Ignore the macros and for the time being.\n\nThe is recognized by C++ compiler only. It notifies the C++ compiler that these functions are to be compiled using C's function naming protocol instead of C++ naming protocol. C and C++ have different function naming protocols as C++ support function overloading and uses a name mangling scheme to differentiate the overloaded functions. Read \"Name Mangling\".\n\nSave the C program as \" \".\n\nThe JNI header \" \" provided by JDK is available under the \" \" and \" \" (for Windows) or \" \" (for Ubuntu) [Check Mac OS X] directories, where is your JDK installed directory (e.g., \" \" for Windows).\n\nThe C function simply prints the message \"Hello world!\" to the console.\n\nFinding the right compiler for your operating platform (Windows, Mac OS X, Ubuntu), for your JDK (32-bit, 64-bit), and figuring out the correct compiler options is the hardest part to get the JNI working!!!\n\nWe are going to use Cygwin. You need to take note of the followings for Windows:\n• Windows/Intel uses these instruction sets: x86 is a 32-bit instruction set; i868 is an enhanced version of x86 (also 32-bit); x86_64 (or amd64) is a 64-bit instruction set.\n• A 32-bit compiler can run on 32-bit or 64-bit (backward compatible) Windows, but 64-bit compiler can only run on 64-bit Windows.\n• A 64-bit compiler could produce target of 32-bit or 64-bit.\n• If you use Cygwin's GCC, the target could be native Windows or Cygwin. If the target is native Windows, the code can be distributed and run under Windows. However, if the target is Cygwin, to distribute, you need to distribute Cygwin runtime environment ( ). This is because Cygwin is a Unix emulator under Windows.\n• The above explains for the many versions of GCC under Cygwin.\n\nFor 64-bit JDK, you need to find a compiler that produces target of 64-bit native Windows. This is provided by MinGW-W64. You can install MinGW-W64 under Cygwin, by selecting packages \" \" (C compiler) and \" \" (C++ compiler). The executables are \" (C Compiler) and \" (C++ Compiler), respectively.\n\nFirst, set the environment variable to point the JDK installed directory (e.g., \" \"). Follow the steps HERE.\n\nNext, use the following commands to compile into . In Windows, we reference the environment variable as in the command.\n\nThe compiler options used are:\n• : for specifying the header directory. In this case \" \" (in \" \") and \" \" (in \" ), where is an environment variable set to the JDK installed directory.\n\nYou can also compile and link in two steps:\n\nYou need check the resultant file type via the \" \" utility, which indicates \" \" is a 64-bit (x86_64) native Windows DLL.\n\nTry , which lists all the symbols in the shared library and look for the function. Check for the function name with type (defined).\n\nFor 32-bit JDK, you need to find a 32/64-bit compiler that produces target of 32-bit native Windows. This is provided by MinGW-W64 (and the older MinGW). You can install MinGW-W64 under Cygwin, by selecting packages \" \" (C compiler) and \" \" (C++ compiler). The executables are \" (C Compiler) and \" (C++ Compiler), respectively.\n\nFirst, set the environment variable to point the JDK installed directory (e.g., \" \"). Follow the steps HERE.\n\nNext, use the following command to compile into :\n\nThe compiler options used are:\n• : The to pass linker option to prevent (symbols with a stdcall suffix ( ) will be exported as-is and also with the suffix stripped). (Some people suggested to use .)\n• : for specifying the header files directories. In this case \" \" (in \" \") and \" \" (in \" ), where is an environment variable set to the JDK installed directory.\n• = : define the type (add this option in front if error \"unknown type name '__int64'\")\n• Set environment variable to point to the JDK installed directory (which shall contains the subdirectory to be used in the next step):\n• Compile the C program into share module using , which is included in all Unixes:\n• Set environment variable to point to the JDK installed directory (which shall contains the subdirectory to be used in the next step):\n• Compile the C program into dynamic share module using , which is included in all Unixes/Mac OS:\n\nYou may need to explicitly specify the Java library path of the \" \" (Windows), \" \" (Unixes), \" \" (Mac OS X) via VM option , as below. In this example, the native library is kept in the current directory .\n\nInstead of a C program, we can use a C++ program (called ) for the above example.\n\nCompile the C++ programs into shared library as follows. See \"JNI with C\" section for explanation.\n\nOn Cygwin, you need to install package.\n\nNotes: If you encounter \" \", you need to find a \"DLL dependency walker\" to track down the dependent libraries. Search for the libraries (under Cygwin) and include the libraries in the environment variable . In my case, the dependent library is \" \" located at \" \".\n\nThe resultant header file \" \" declares the native function as:\n\nWe shall implement the program in C++ (in \" \" and \" \"), but use a C program (\" \") to interface with Java.\n\nCompile the C/C++ programs into shared library (\" \" for Windows).\n\nOn Cygwin, you need to install package.\n\nNotes: If you encounter \" \", you need to find a DLL dependency walker to track down the dependent libraries. Search for the libraries (under Cygwin) and include the libraries in the . In my case, the dependent library is \" \" located at \" \".\n\nFor production, all Java classes shall be kept in proper packages, instead of the default no-name package.\n\nThis JNI class is kept in package \" \" - to be saved as \" \".\n\nThe output of compilation is \" \".\n\nIn this example, we decided to place the header file under a \" \" sub-directory. The generated output is \" \".\n\nTake note of the native function naming convention: , with dots replaced by underscores.\n\nYou can now run the JNI program:\n\nWriting JNI under Eclipse is handy for development Android apps with NDK.\n\nYou need to install Eclipse and Eclipse CDT (C/C++ Development Tool) Plugin. Read \"Eclipse for C/C++\" on how to install CDT.\n\nCreate a new Java project (says ), and the following Java class \" \":\n\nRight-click on the \" \" Java project ⇒ New ⇒ Other... ⇒ Convert to a C/C++ Project (Adds C/C++ Nature) ⇒ Next.\n\nThe \"Convert to a C/C++ Project\" dialog appears. In \"Project type\", select \"Makefile Project\" ⇒ In \"Toolchains\", select \"MinGW GCC\" ⇒ Finish.\n\nNow, you can run this project as a Java as well as C/C++ project.\n\nCreate a directory called \" \" under the project to keep all the C/C++ codes, by right-click on the project ⇒ New ⇒ Folder ⇒ In \"Folder name\", enter \" \".\n\nCreate a \" \" under the \" \" directory, by right-click on the \" \" folder ⇒ new ⇒ File ⇒ In \"File name\", enter \" \" ⇒ Enter the following codes. Take note that you need to use tab (instead of spaces) for the indent.\n\nThis makefile create a target \" \", which has a dependency \" \", and invokes the utility on (under ) to build the target header file.\n\nRight-click on the makefile ⇒ Make Targets ⇒ Create ⇒ In \"Target Name\", enter \" \".\n\nRun the makefile for the target \" \", by right-click on the makefile ⇒ Make Targets ⇒ Build ⇒ Select the target \" \" ⇒ Build. The header file \" \" shall be generated in the \" \" directory. Refresh (F5) if necessary. The outputs are:\n\nRead \"GCC and Make\" for details about makefile.\n\nAlternatively, you could also use the CMD shell to run the make file:\n\nYou can even use the CMD shell to run the (Pre JDK-10):\n\nCreate a C program called \" \", by right-click on the \" \" folder ⇒ New ⇒ Source file ⇒ In \"Source file\", enter \" \". Enter the following codes:\n\nModify the \" \" as follows to generate the shared library \" \". (Again, use tab to indent the lines.)\n\nRight-click on the \" \" ⇒ Make Targets ⇒ Create ⇒ In \"Target Name\", enter \" \". Repeat to create a target \" \".\n\nRun the makefile for the target \" \", by right-click on the makefile ⇒ Make Targets ⇒ Build ⇒ Select the target \" \" ⇒ Build. The outputs are:\n\nThe shared library \" \" shall have been created in \" \" directory.\n\nYou can run the Java JNI program . However, you need to provide the library path to the \" \". This can be done via VM argument . Right-click on the project ⇒ Run As ⇒ Run Configurations ⇒ Select \"Java Application\" ⇒ In \"Main\" tab, enter the main class \" \" ⇒ In \"Arguments\", \"VM Arguments\", enter \" \" ⇒ Run.\n\nYou shall see the output \"Hello World!\" displayed on the console.\n\nJNI defines the following JNI types in the native system that correspond to Java types:\n• Java Primitives: , , , , , , , for Java Primitive of , , , , , , and , respectively.\n• Java Reference Types: for . It also defines the following sub-types:\n• for Java array. Java array is a reference type with eight primitive array and one array. Hence, there are eight array of primitives , , , , , , and ; and one object array .\n\nThe native functions receives argument in the above JNI types and returns a value in the JNI type (such as , ). However, native functions operate on their own native types (such as C-string, C's ). Hence, there is a need to convert (or transform) between JNI types and the native types.\n• Receive the arguments in JNI type (passed over by the Java program).\n• For reference JNI type, convert or copy the arguments to local native types, e.g., to a C-string, to C's , and so on. Primitive JNI types such as and do not need conversion and can be operated directly.\n• Create the returned object in JNI type, and copy the result into the returned object.\n\nThe most confusing and challenging task in JNI programming is the conversion (or transformation) between JNI reference types (such as , , , ) and native types ( , ). The JNI Environment interface provides many functions to do the conversion.\n\nJNI is a C interface, which is not object-oriented. It does not really pass the objects.\n\nPassing Java primitives is straight forward. A type is defined in the native system, i.e,. , , , , , , and for each of the Java's primitives , , , , , , and , respectively.\n\nThis JNI program loads a shared library (Windows) or (Unixes). It declares a method that receives two 's and returns a containing the average value of the two 's. The method invoke the .\n\nCompile the Java program into \" \" and generate the C/C++ header file \" \":\n\nThe header file contains a function declaration which takes a (for accessing JNI environment interface), a (for referencing this ), two 's (Java native method's two arguments) and returns a (Java native method's return-type).\n\nThe JNI types and correspond to Java's type and , respectively.\n\nThe \" \" and \" \" (which is platform dependent) contains these statements for the eight JNI primitives and an additional .\n\nIt is interesting to note that is mapped to C's (which is at least 32 bits), instead of of C's (which could be 16 bits). Hence, it is important to use in the C program, instead of simply using . Cygwin does not support .\n\nThe implementation is as follows:\n\nCompile the C program into shared library ( ).\n\nThis JNI program declares a method that receives a Java and returns a Java . The method invokes the .\n\nCompile the Java program and generate the C/C++ header file \" \":\n\nThe header file contains this function declaration:\n\nJNI defined a type to represent the Java . The last argument (of JNI type ) is the Java passed into the C program. The return-type is also .\n\nPassing strings is more complicated than passing primitives, as Java's is an object (reference type), while C-string is a NULL-terminated array. You need to convert between Java (represented as JNI ) and C-string ( ).\n\nThe JNI Environment (accessed via the argument ) provides functions for the conversion:\n• To get a C-string ( ) from JNI string ( ), invoke method .\n• To get a JNI string ( ) from a C-string ( ), invoke method .\n\nThe C implementation is as follows.\n• It receives the JNI string ( ), convert into a C-string ( ), via .\n• It then performs its intended operations - displays the string received and prompts user for another string to be returned.\n• It converts the returned C-string ( ) to JNI string ( ), via , and return the .\n\nCompile the C program into shared library.\n\nJNI supports conversion for Unicode (16-bit characters) and UTF-8 (encoded in 1-3 bytes) strings. UTF-8 strings act like null-terminated C-strings ( array), which should be used in C/C++ programs.\n\nThe function can be used to create a new C-string ( ) from the given Java's . The function returns if the memory cannot be allocated. It is always a good practice to check against .\n\nThe 3rd parameter (of ), which is an \"in-out\" parameter, will be set to if the returned string is a copy of the original instance. It will be set to if the returned string is a direct pointer to the original instance - in this case, the native code shall not modify the contents of the returned string. The JNI runtime will try to return a direct pointer, if possible; otherwise, it returns a copy. Nonetheless, we seldom interested in modifying the underlying string, and often pass a pointer.\n\nAlways invoke whenever you do not need the returned string of to release the memory and the reference so that it can be garbage-collected.\n\nThe function create a new JNI string ( ), with the given C-string.\n\nJDK 1.2 introduces the , which copies the (or a portion from of ) into the \"pre-allocated\" C's array. They can be used in place of . The is not needed as the C's array is pre-allocated.\n\nJDK 1.2 also introduces the functions. Similar to , it returns a direct pointer if possible; otherwise, it returns a copy. The native method shall not block (for IO or others) between a pair a and call.\n\nFor detailed description, always refer to \"Java Native Interface Specification\" @ http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html.\n\nInstead of , it uses a to store the Unicode characters.\n\nUse to compile the C++ program:\n\nTake note that C++ native string functions have different syntax from C. In C++, we could us \" \", instead of \" \". Furthermore, there is no need for the argument in the C++ functions.\n\nAlso take note that C++ support a class (under the header which is more user-friendly, as well as the legacy C-string (char array).\n\nThe header \" \" contains the following function declaration:\n\nIn Java, array is a reference type, similar to a class. There are 9 types of Java arrays, one each of the eight primitives and an array of . JNI defines a type for each of the eight Java primitive arrays, i.e, , , , , , , , for Java's primitive array of , , , , , , and , respectively. It also define a for Java's array of (to be discussed later).\n\nAgain, you need to convert between JNI array and native array, e.g., between and C's , or and C's . The JNI Environment interface provides a set of functions for the conversion:\n• To get a C native from a JNI , invoke .\n• To get a JNI from C native , first, invoke to allocate, then use to copy from the to .\n\nThere are 8 sets of the above functions, one for each of the eight Java primitives.\n\nThe native program is required to:\n• Convert the return C's native array (e.g., ) to JNI array (e.g., ), and return the JNI array.\n\nThe C implementation \" \" is:\n\nThe JNI primitive array ( , , , , , , and ) functions are:\n\nThe can be used to create a new C's native array from the given Java . can be used to copy a (or a portion from of ) to and from a pre-allocated C native array .\n\nThe can be used to allocate a new of a given size. You can then use the function to fill its contents from a native array .\n\nThe functions does not allow blocking calls in between the get and release.\n\nThe class contains two instance variables: a primitive called and a called . It also declares a native method, which could modify the contents of the instance variables.\n\nTo access the instance variable of an object:\n• Get a reference to this object's class via .\n• Get the Field ID of the instance variable to be accessed via from the class reference. You need to provide the variable name and its field descriptor (or signature). For a Java class, the field descriptor is in the form of \" \", with dot replaced by forward slash ( ), e.g.,, the class descriptor for is \" \". For primitives, use for , for , for , for , for , for , for , and for . For arrays, include a prefix , e.g., \" \" for an array of ; for an array of .\n• Based on the Field ID, retrieve the instance variable via or function.\n• To update the instance variable, use the or function, providing the Field ID.\n\nThe JNI functions for accessing instance variable are:\n\nAccessing static variables is similar to accessing instance variable, except that you use functions such as , , .\n\nThe JNI functions for accessing static variable are:\n\nYou can callback an instance and static methods from the native code.\n\nThis class declares a method called , and invoke this . The , in turn, calls back the various instance and static methods defined in this class.\n\nTo call back an instance method from the native code:\n• Get a reference to this object's class via .\n• From the class reference, get the Method ID via . You need to provide the method name and the signature. The signature is in the form \" \". You can list the method signature for a Java program via utility (Class File Disassembler) with (print signature) and (show private members):\n• Based on the Method ID, you could invoke or or , where the return-type is , void and , respectively. Append the argument, if any, before the argument list. For non- return-type, the method returns a value.\n\nTo callback a method, use , or .\n\nThe JNI functions for calling back instance method and static method are:\n\nJNI provides a set of functions to invoke superclass' instance methods which has been overridden in this class (similar to a call inside a Java subclass):\n• Get the Method ID, via .\n• Based on the Method ID, invoke one of the , with the object, superclass, and arguments.\n\nThe JNI function for calling the overridden superclass' instance method are:\n\nYou can construct and inside the native code, via and functions, and pass them back to the Java program.\n\nCallback the Constructor to Create a New Java Object in the Native Code\n\nCallback the constructor is similar to calling back method. First, get the Method ID of the constructor by passing \" \" as the method name and \" \" as the return-type. You can then use methods like to call the constructor to create a new java object.\n\nThis class declares a method . The native code shall create and return an Integer object, based on the argument given.\n\nThe JNI functions for creating object ( ) are:\n\nFor illustration, this class declares a method that takes an array of , compute their sum and average, and returns as an array of . Take note the arrays of objects are pass into and out of the native method.\n\nUnlike primitive array which can be processed in bulk, for object array, you need to use the to process each of the elements.\n\nThe JNI functions for creating and manipulating object array ( ) are:\n\nManaging references is critical in writing efficient programs. For example, we often use , , to retrieve a , and inside native functions. Instead of performing repeated calls, the values should be obtained once and cached for subsequent usage, to eliminate the overheads.\n\nThe JNI divides object references (for ) used by the native code into two categories: local and global references:\n• A local reference is created within the native method, and freed once the method exits. It is valid for the duration of a native method. You can also use JNI function to invalidate a local reference explicitly, so that it is available for garbage collection intermediately. Objects are passed to native methods as local references. All Java objects ( ) returned by JNI functions are local references.\n• A global reference remains until it is explicitly freed by the programmer, via the JNI function. You can create a new global reference from a local reference via JNI function .\n\nThe above JNI program declares two native methods. Both of them create and return a object.\n\nIn the C implementation, we need to get a class reference for , via . We then find the method ID for the constructor of , and invoke the constructor. However, we wish to cache both the class reference and method ID, to be used for repeated invocation.\n\nThe following C implementation does not work!\n\nIn the above program, we invoke to find the class reference for , and saved it in a global static variable. Nonetheless, in the next invocation, this reference is no longer valid (and not NULL). This is because returns a local reference, which is invalidated once the method exits.\n\nTo overcome the problem, we need to create a global reference from the local reference returned by . We can then free the local reference. The revised code is as follows:\n\nTake note that and are not , and cannot create global reference.\n• Liang, \"The Java Native Interface - Programmer's Guide and Specification\", Addison Wesley, 1999, available online @ http://java.sun.com/docs/books/jni/html/jniTOC.html."
    },
    {
        "link": "https://medium.com/@oleksandra_shershen/harnessing-the-power-of-jni-seamless-integration-of-java-and-c-for-enhanced-performance-d1a6ac4f4a77",
        "document": "JNI stands for Java Native Interface. It is a framework that allows Java code to interact with and invoke native code written in other programming languages, such as C or C++.\n\nJava and C++ are two versatile programming languages, each with its own strengths and areas of specialization. While Java offers platform independence and strong object-oriented capabilities, C++ provides low-level control and high performance. In certain scenarios, developers may find themselves needing to combine the best of both worlds by integrating Java and C++ code within a single application. Enter the Java Native Interface (JNI), a powerful framework that acts as a bridge between Java and C++, enabling seamless communication and collaboration. In this article, we will explore JNI in-depth, providing explanations and concrete code examples to demonstrate its usage and benefits.\n\nThe Java Native Interface (JNI) is a programming framework that facilitates interoperability between Java and code written in other languages, specifically C and C++. It allows Java applications to invoke and be invoked by native code, unlocking the potential for incorporating existing native libraries, leveraging performance-critical algorithms, or interacting with hardware devices.\n\nTo comprehend how JNI operates, let’s walk through its typical workflow:\n• Writing the Native Code: Begin by crafting the native code in C or C++. This code may encompass custom functionality, performance-critical computations, or interactions with platform-specific features.\n• Compiling the Native Code: Compile the native code using a C/C++ compiler to generate a shared library (DLL/SO) that corresponds to the target platform.\n• Creating the Java Native Interface: Define a Java class that serves as the bridge between the Java code and the native code. This class contains native method declarations that correspond to the functions implemented in the native code.\n• Generating the Java Header File: Employ the Java Native Development Kit (JDK) to generate a C/C++ header file ( ). This header file includes the function prototypes for the native methods declared in the Java class.\n• Implementing the Native Methods: In the generated C/C++ header file, implement the native methods declared in the Java class. These implementations provide the actual functionality that will be invoked from Java.\n• Loading the Native Library: In the Java code, load the native library using the method. This ensures that the native methods can be accessed and executed.\n• Invoking Native Methods: Finally, invoke the native methods from the Java code, and they will execute the corresponding native code, enabling seamless communication and data exchange between Java and C++.\n\nHow does it work?\n\nHow is the name of a C function that implements a Java method formed?\n\nThe name of a C function that implements a Java method in JNI is formed by concatenating the Java class name, the Java method name, and optionally the Java method signature. This process follows a specific naming convention.\n\nThe general format for forming the C function name is as follows:\n• represents the package name of the Java class, with periods replaced by underscores.\n• represents the simple name of the Java class.\n• represents the name of the Java method.\n\nIf there are multiple methods with the same name but different parameter signatures within a class, the Java method signature is appended to the C function name. The signature is formed by concatenating the letter representing the return type, followed by the letters representing the parameter types.\n\nFor example, consider a Java class named with a method named that takes two parameters and returns an . The corresponding C function name would be:\n\nIf the method signature needs to be included, it would be added to the C function name as follows:\n\nNote that the signatures for primitive types follow specific conventions, where represents , represents , represents , represents , represents , represents , represents , and represents .\n\nTo illustrate the power and practicality of JNI, let’s delve into a more intricate example. We will develop a Java application that performs matrix multiplication by leveraging a native C++ implementation for enhanced performance.\n\nThe given command is a compilation command using the compiler to compile a C++ source file named into an object file named . Here's a short explanation of each component:\n\n: Compile the source file without linking, generating an object file.\n\n: Generate position-independent code, allowing the compiled code to be loaded and executed at any memory address. This is necessary for creating shared libraries or using JNI.\n\n: Include the directory containing JNI header files for Java.\n\n: The source file to be compiled, containing C++ code for matrix operations.\n\n: Specify the output file name as , where the compiled code will be stored.\n\n: Create a shared library instead of an executable. Shared libraries allow code and data to be dynamically linked by multiple programs.\n\n: Specify the output file name as , where is a common convention for shared library names, and is the file extension for shared libraries on Unix-like systems.\n\n: The object file containing the compiled code for matrix operations.\n\nThe command uses the compiler as the linker to take the object file and generate a shared library named . This shared library can be dynamically linked with other programs, enabling them to access the functions and symbols defined in . The resulting shared library file can be loaded and used by programs, including Java applications through JNI, to leverage the matrix operations implemented in the C++ code.\n\nThe command instructs the compiler to read the file and generate the corresponding bytecode file . The file contains the compiled Java code and can be executed by the JVM.\n\nIn this example, we have a Java class that contains a native method . This method takes two 2-dimensional arrays ( and ) as input and performs matrix multiplication using native code written in C++. The native code uses JNI to access and manipulate the arrays. It calculates the dimensions of the input matrices, creates a new matrix to store the result, and performs the matrix multiplication operation.\n\nIn the Java code, we create an instance of and define two matrices and . We then invoke the native method to perform matrix multiplication using the native code. The resulting matrix is stored in , and we display the result by iterating over the rows and columns.\n\nJNI provides a powerful mechanism for integrating Java and C++ code, enabling developers to leverage the strengths of both languages in a seamless manner. This article explored JNI, its workflow, and provided an example showcasing matrix multiplication using JNI. By using JNI, developers can enhance performance, access native libraries, and utilize low-level capabilities while maintaining the portability and flexibility of Java. With JNI, the boundaries between Java and C++ can be blurred, empowering developers to build high-performance applications that harness the best of both worlds."
    },
    {
        "link": "https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=e666d31f8fc8890ec49b208a600e68884be838da",
        "document": ""
    },
    {
        "link": "https://github.com/hunyadi/javabind",
        "document": "javabind is a lightweight C++17 header-only library that exposes C++ types to Java and vice versa, primarily in order to create Java bindings for existing C++ code. The objective of this library is to provide an easy-to-use interoperability interface that feels natural from both C++ and Java. javabind uses C++ compile-time introspection to generate Java Native Interface (JNI) stubs that can be accessed from Java with regular function invocation. The stubs incur minimal or no overhead compared to hand-written JNI code.\n\nThis project has been inspired by a similar binding interface between JavaScript and C++ in emscripten, between Python and C++ in PyBind11 and Boost.Python, and between Kotlin and C++ in ktbind. Unlike JNA, which one can utilize by means of an intermediary C interface, javabind offers a direct interface between C++ and Java.\n\nThe following C++ features can be mapped to Java:\n• Fundamental types and custom data structures as function arguments or return values\n\nFurthermore, the following Java features are seamlessly exposed to C++:\n\njavabind is a header-only library, including the interoperability header in your C++ project allows you to create bindings to Java:\n\nConsider the following C++ class as an example:\n\nLet's suppose we want to expose this classes to Java. All Java bindings should be registered in the extension module block. We use and its builder functions and to expose the member functions of the class :\n\nassigns a fully-qualified Java class name to the C++ class, which is required to look up objects at run time.\n\nThe type parameter of the template function is a function signature to help choose between multiple available constructors. Use the same style you would with .\n\nThe non-type template parameter of is a function pointer, either a member function pointer (as shown above) or a free function pointer. If multiple functions have the same name (making the pointer reference ambiguous), a static cast to the right signature might be necessary.\n\nis a utility function that lets you print the Java class definition that corresponds to the registered C++ class definitions. prints to Java when you load the compiled shared library ( on macOS and Linux, or on Windows) with Java's . You would normally use it in the development phase.\n\nNext, we need corresponding native bindings in Java:\n\nThe example above highlights many interesting characteristics.\n\nFirst, derives from . Internally, stores a raw pointer as a Java . This raw pointer is completely opaque to Java, and refers to an object in the C++ memory space. When methods of are called, the raw pointer is de-referenced, and the call is routed to the C++ mapping of , as registered by in the extension module block.\n\nSecond, there are two factory methods to create instances of . Factory methods are necessary because the raw pointer has to be populated in C++, and cannot be set in Java. The call in routes the Java factory method to template-generated C++ code, which creates the object, calls the appropriate C++ constructor, sets the raw pointer, and returns a reference to the object. Meanwhile, has a protected constructor to prevent instantiating objects directly in Java.\n\nThird, implements the method inherited from the interface (via ). C++ objects have constructors and destructors but Java (JVM) has garbage collection. In order to ensure that objects are properly reclaimed when they are no longer needed, in C++ binds a template-generated de-allocator to , and calling the method triggers the C++ destructor. You may have called automatically at the end of a block in Java.\n\nFinally, getter and setter methods involve a Java record class called . is defined in Java as follows:\n\nIn order to make fields of the record class accessible from C++, we need to define a corresponding C++ class and declare bindings:\n\nThe above declaration makes a type that we can pass and return in function calls. When objects are received, data in Java is copied into the defined in C++. When objects are returned, data in C++ is copied into the Java record class.\n\nC++ function signatures that are invoked from Java can take arguments by value or by const reference. C++ functions return simple or composite types by value.\n\njavabind recognizes several widely-used types and marshals them automatically between C++ and Java without explicit user-defined type specification:\n\nis a lightweight C++ wrapper defined by the library to match Java boxed types such as . has no C++ run-time overhead, it is only used for disambiguation.\n\nCollection types are copied between C++ and Java.\n\nOptionals are converted to a null-value in Java when they don't have a value in C++. Null-values are converted to an empty optional in C++.\n\nC++ types translate to JNI calls and to get a direct pointer to the memory managed by the Java Virtual Machine (JVM). This imposes significant restrictions:\n\nThe C++ type translates to JNI calls and , which entail similar restrictions as and .\n\nUnsigned integers are not supported in Java. However, it is possible to marshal a C++ unsigned integer type to a compatible Java signed integer type. Two modes are supported. Conversions for C++ unsigned types are disabled by default, and require explicit opt-in.\n\nSigned cast assigns the value of a C++ unsigned integer type to a Java signed integer type of the same width, copying all bits. You can opt in to signed cast by defining the preprocessor symbol (or enabling the CMake option ).\n\nWidening converts the value of a C++ unsigned integer type to a wider Java signed integer type such that the target type can accommodate all values the source type can assume. You can opt in to convert unsigned integers to a wider Java type by defining the preprocessor symbol (or enabling the CMake option ).\n\nIf enabled, the following integer type conversions take place:\n\nNo run-time range checks are performed when passing a value from Java to C++. If the Java value is outside the range of the C++ type (e.g. negative value), the result is undefined.\n\njavabind can expose C++ (and ) to Java.\n\nFirst, define a C++ that needs to be exported to Java:\n\nSecond, define a corresponding enumeration class in Java:\n\nExceptions thrown in C++ automatically trigger a Java exception when crossing the language boundary. The interoperability layer catches all exceptions that inherit from , and throws a before passing control back to the JVM.\n\nExceptions originating from Java are automatically wrapped in a C++ type called , which derives from . The function in retrieves the Java exception message. C++ code can catch and take appropriate action, which causes the exception to be cleared in Java.\n\njavabind can expose C++ function objects ( ) to Java with wrappers that implement functional interfaces such as or . Each wrapper such as or extends the abstract base class , which is responsible for encapsulating a raw pointer. This raw pointer points at a memory location in the C++ domain, allocated with the operator , and de-allocated with once the Java wrapper is garbage collected. Invocation is done in a way similar to regular native class methods but the call is bound not to an object instance (as with ) but to a function object.\n\nBecause function objects as C++ return values are depending on class definitions in Java, auxiliary classes such as or must be available on the class path at binding registration time to be accessible for . All of these are defined in the namespace .\n\nAuxiliary classes use to ensure associated native resources are reclaimed when the Java object becomes phantom reachable.\n\nThe macro expands into a pair of function definitions:\n\nThese definitions, in turn, iterate over the function and field bindings registered with , and .\n\nEach function binding generates a function pointer at compile time, which are passed to the JNI function . Each of these function pointers points at a static member function of a template class, where the template parameters capture the type information extracted from the function signature. When the function is invoked through the pointer, the function makes the appropriate type conversions to cast Java types into C++ types and back. For example, the C++ function signature\n\ncauses the function adapter template to be instantiated with parameter types , and and return type . When Java calls the pointer through JNI, the adapter transforms the types and . ( and need no transformation.) For each transformed type, a temporary object is created, all of which are then used in invoking the original function .\n\nInternally, field bindings utilize JNI accessor functions like and to extract and populate Java objects. Like with function bindings, javabind uses C++ type information to make the appropriate JNI function call. For instance, setting a field with type entails a call to (from Java to C++) or (from C++ to Java). If the type is a composite type, such as a , then a Java object is constructed recursively, and then set with . For example,\n• Setting a field of type first creates a with JNI's , then sets elements with the method (invoked using JNI's ), performing boxing for the primitive type with , and finally uses with the newly created instance.\n• Setting an field involves creating a with JNI's , and a call to JNI's for each string element. The strings are then added to the instance with , and finally to the field with ."
    }
]