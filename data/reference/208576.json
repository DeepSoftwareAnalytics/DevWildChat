[
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_UART",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what is UART and how to use it through examples\n\nThe universal synchronous/asynchronous receiver transmitter (USART/UART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. USART can operate with a very wide range of baud rates using a programmable baud rate generator.\n\n It supports synchronous one-way communication and half-duplex single-wire communication, as well as multiprocessor communications. It also supports the LIN (Local Interconnect Network), Smartcard protocol and IrDA (Infrared Data Association) SIR ENDEC specifications and Modem operations (CTS/RTS).\n\n High speed data communication is possible by using the DMA (direct memory access) for multibuffer configuration. Also, the UART can be used with interrupt.\n\n This article goes through the following UART features: \n\n\n\nLearn how to set up UART and generate code with STM32CubeIDE and how to use HAL functions. \n\n\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n• Select NUCLEO-L476RG board using Board Selector as shown in the figure below:\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n• Initialize all peripherals with their default settings.\n\n\n\nAnswer “Yes” to initialize all peripherals with their default mode? Popup as below:\n• Configure Parameter Settings as shown in the figure below: \n\n\n\nTo select the correct GPIOs pins, it is necessary to refer to the datasheet. Look for the alternate function table. \n\n STM32L476 USART1 uses PA9 for transmission (TX) and PA10 for reception (RX) as shown below:\n\n\n\n \n\n\n\n PA9 and PA10 should be configured as follows:\n\n\n\n \n\n\n\n\n\nYou will need a pair of boards, one will act as transmitter and the other as receiver. \n\n The two boards should be connected as follows: \n\n\n\nFirst of all, build your project \n\n Connect the first NUCLEO-L476RG board. It will act as the TX board in this example.\n\n Then, run your program \n\n The debug configurations window will open. Rename your configuration as UART Debug TX.\n\n\n\n \n\n\n\n In the debugger tab, click ST-LINK S/N and scan. A number will appear: this is your TX board ST-LINK serial number used to indicate that this debug configuration is related to this specific board.\n\n\n\n \n\n\n\n Click OK and the program will run autonomously on the TX board.\n\n\n\n Now, connect the second NUCLEO-L476RG board. It will act as the RX board in this example. Let's go through the code for this board. \n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\nFirst, we need to create a new debug configuration for the RX board.\n\n Click the little arrow of the debug button and click Debug Configurations... Then click the New launch configuration button.\n\n\n\n \n\n\n\nRename this configuration as UART Debug RX. Just as we did for the previous configuration, in the debugger tab, click ST-LINK S/N and scan. Make sure to select the new serial number that appears: it belongs to the RX board we just connected.\n\nThen click Debug.\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Now hover over rx_buff[] to monitor its value.\n\n\n\n Alternatively, you can add rx_buff to Expressions, on the right side of STM32CubeIDE. \n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Enable USART1 global interrupt.\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_IT to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value. \n\n\n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Add the DMA request as shown in the figure below:\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_DMA to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value."
    },
    {
        "link": "https://visualgdb.com/tutorials/arm/stm32/uart/hal",
        "document": "This tutorial shows how to use the STM32 UART interface in different modes using the HAL libraries. We will show how to use direct mode, interrupt-based mode and DMA-controlled mode and will use a logic analyzer to compare the precise timings of various events.\n\nBefore you begin, install VisualGDB 5.2 or later.\n• On the next page select your STM32 device. We will use the Nucleo-F410RB board that has the STM32F410RB chip:\n• Connect your board to USB and let VisualGDB automatically recognize it and configure debug settings:\n• Press “Finish” to create the project. We will begin with a simple program that will read bytes via UART and echo them back in groups of 4. This requires four steps:\n• Enabling the clocks for the UART and GPIO peripherals.\n• Configuring the GPIO pins corresponding to UART to actually act as UART pins (as opposed to manually controlled GPIO) pins.\n• Initializing the UART module by specifying the operating parameters.\n• Actually reading and writing the data. Replace the code in your main source file with the following: #include <stm32f4xx_hal.h> #include <stm32_hal_legacy.h> #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } static UART_HandleTypeDef s_UARTHandle = UART_HandleTypeDef(); int main(void) { HAL_Init(); __USART2_CLK_ENABLE(); __GPIOA_CLK_ENABLE(); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.Pin = GPIO_PIN_2; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Alternate = GPIO_AF7_USART2; GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_3; GPIO_InitStructure.Mode = GPIO_MODE_AF_OD; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); s_UARTHandle.Instance = USART2; s_UARTHandle.Init.BaudRate = 115200; s_UARTHandle.Init.WordLength = UART_WORDLENGTH_8B; s_UARTHandle.Init.StopBits = UART_STOPBITS_1; s_UARTHandle.Init.Parity = UART_PARITY_NONE; s_UARTHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; s_UARTHandle.Init.Mode = UART_MODE_TX_RX; if (HAL_UART_Init(&s_UARTHandle) != HAL_OK) asm(\"bkpt 255\"); for (;;) { uint8_t buffer[4]; HAL_UART_Receive(&s_UARTHandle, buffer, sizeof(buffer), HAL_MAX_DELAY); HAL_UART_Transmit(&s_UARTHandle, buffer, sizeof(buffer), HAL_MAX_DELAY); } }\n• We are using UART2 and pins PA2 and PA3 as the Nucleo-F410RB board has them connected to the on-board ST-Link UART interface, so we can use a terminal to interact with the board. You can find the GPIO pin numbers and the alternate function numbers corresponding to the UART interface on your device by searching the datasheet for the Alternate Function Mapping section: For STM32F410RB connecting UART2 to pins PA2 and PA3 requires enabling alternate function #7.\n• You can use a terminal program to talk to your STM32 board over the UART interface. If you are using VisualGDB Custom Edition, simply enable the Raw Terminal in VisualGDB Project Properties and it will show a terminal window inside the Visual Studio window:\n• Press F5 to start debugging. Try typing some text in the terminal window and see how after every 4 characters the program echoes them back:\n• Now we will explore the UART timings using a logic analyzer. First of all, modify your code to continuously output “test\\r\n\n” and use GPIOC10 to signal the lifetime of the HAL_UART_Transmit() function:\n• We will use Analyzer2Go to turn another STM32 board into a full-featured logic analyzer. Connect your second board to your computer, start Analyzer2Go and select the board type:\n• Connect the following signals between the boards:\n\n Any of the supported inputs Any of the supported inputs\n• Enable the connected signals in Analyzer2go to begin watching them. See how the HAL_UART_Transmit() function (red) is active during the entire transmission (blue):\n• Press the “Record” button to record several packets in a row. Then stop recording and zoom into one of them:\n• In order to automatically decode the UART bytes, open the Protocol Analyzers tab, drag/drop the UART analyzer and connect it to the corresponding signal:\n• You can analyze the raw encoding of the UART signals by selecting the decoded characters and creating notes for some of them:\n• Then switch to the “Raw” view to see the signal shape. You can click the “set clock period” button to highlight individual zeroes and ones:\n• The ‘t’ character was encoded as 0 0010 1110 1, which corresponds to a start bit (0) followed by a value of 0x74 (ASCII code for ‘t’) followed by a stop bit (1):\n• Try changing the stop bit amount to 2: See how the stop bit is now twice longer:\n• Although calling HAL_UART_Transmit() for every transmission is simple, it has one major disadvanrage. While the transmission is active, the program cannot do anything else and has to wait for it to complete. We will now use the interrupt-based transmission to free up some of the CPU cycles. Replace the code in your main source file with this: SysTick_Handler HAL_IncTick HAL_SYSTICK_IRQHandler UART_HandleTypeDef s_UARTHandle UART_HandleTypeDef USART2_IRQHandler HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_SET HAL_UART_IRQHandler s_UARTHandle HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_RESET HAL_UART_TxCpltCallback UART_HandleTypeDef huart HAL_GPIO_WritePin GPIOC, GPIO_PIN_11, GPIO_PIN_RESET main HAL_Init // <Initialize UART and GPIO as before> __GPIOC_CLK_ENABLE GPIO_InitStructure. GPIO_PIN_10 GPIO_PIN_11 GPIO_PIN_12 GPIO_InitStructure. GPIO_MODE_OUTPUT_PP HAL_GPIO_Init GPIOC, GPIO_InitStructure NVIC_EnableIRQ USART2_IRQn buffer HAL_GPIO_WritePin GPIOC, GPIO_PIN_10 GPIO_PIN_11, GPIO_PIN_SET HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_RESET HAL_UART_Transmit_IT s_UARTHandle, buffer, buffer HAL_GPIO_WritePin GPIOC, GPIO_PIN_10, GPIO_PIN_RESET HAL_Delay #include <stm32f4xx_hal.h> #include <stm32_hal_legacy.h> #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } static UART_HandleTypeDef s_UARTHandle = UART_HandleTypeDef(); extern \"C\" void USART2_IRQHandler() { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET); HAL_UART_IRQHandler(&s_UARTHandle); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET); } void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_RESET); } int main(void) { HAL_Init(); // <Initialize UART and GPIO as before> __GPIOC_CLK_ENABLE(); GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure); NVIC_EnableIRQ(USART2_IRQn); for (;;) { char buffer[] = \"test\\r\n\n\"; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10 | GPIO_PIN_11, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET); HAL_UART_Transmit_IT(&s_UARTHandle, (uint8_t *)buffer, sizeof(buffer)); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_RESET); HAL_Delay(2); } } Don’t forget to copy the previous initialization code for UART and GPIO.\n• Set a breakpoint in HAL_UART_TxCpltCallback(), start debugging and wait for it to trigger. Then check the call stack: You can see how the UART interrupt got invoked when the main() function was already running HAL_Delay(). The USART2_IRQHandler() handler called the HAL_UART_IRQHandler() and the HAL_UART_IRQHandler() in turn called the HAL_UART_TxCpltCallback() once it determined that the last byte got transmitted.\n• Remove the breakpoint and restart the program. Then add the C11 and C12 signals to Analyzer2Go and make another recording. Note how the HAL_UART_Transmit_IT() function returns immediately (red) and the interrupt handler (green) is called after each byte is queued for transmission. Finally, the HAL_UART_TxCpltCallback() (orange signal switching to 0) is called once the last byte was physically sent:\n• Most of the time during the transmission the CPU will be able to run code unrelated to the transmission. It will only be interrupted by occasional UART interrupts. You can measure the overhead of the UART interrupts by comparing the byte transmission period to the width of the ‘ISR’ pulse. For STM32F410RB the overhead is 12 out of 96 microseconds (12.5%) regardless of the buffer size:\n• In order to reduce the interrupt-related overhead, we will show switch UART to use DMA (direct memory access). In this mode the DMA controller will automatically feed the entire buffer to the UART byte-by-byte and only raise an interrupt once the entire buffer is sent. Add the following static variable: Then replace the code below the code initializing GPIOC with the following: Remove the UART interrupt handler and add the DMA interrupt handler and 2 UART callbacks: Note that different devices have different DMA channel and stream numbers assigned to UART. Use the DMA Request Mapping table in your device’s reference manual (not datasheet) to get the correct numbers:\n• Start the program and ensure you still can see the stream of ‘test’ messages:\n• Go back to Analyzer2Go and and check the timing. See how now the DMA interrupt is only called twice per the entire transmission (once for each half of the buffer): If you measure the interrupt overhead now you should get 41 microseconds out of 670 (for the entire packet) or ~6%. The DMA interrupt overhead also doesn’t scale up when you increase buffer size, so sending 70 bytes in a packet instead of 7 would reduce the overhead to 0.6%.\n• Having a separate callback for each half of the buffer allows implementing double-buffering. While the DMA is transferring the first half of the buffer, you program could fill the second part with the next frame and vice versa. The same technique would also work for other DMA-capable peripherals, such as SPI (see the SPI tutorial for more details)."
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://controllerstech.com/stm32-uart-1-configure-uart-transmit-data",
        "document": "This tutorial is the start of a new series on the UART peripheral of STM32 Microcontrollers. In this series we will cover different ways of transmitting and receiving data over the UART protocol. We will also see different UART modes available in the STM32 microcontrollers and how to use them.\n\nIn this tutorial, we will understand the connection and configuration of different parameters of UART available in the cubeMX. We will also transmit the data over UART and receive it on a serial console in the computer.\n\nUART stands for Universal Asynchronous Receiver Transmitter whereas the USART stands for Universal Synchronous Asynchronous Receiver Transmitter. The term Synchronous enables the USART to send an additional clock signal to the receiving device. The data is then sampled at a predefined edge (Rising or Falling) of the clock. The USART mode uses 3 pins (clock, Tx and Rx) compared to the 2 pins (Tx and Rx) used in the UART.\n\nThe most widely used synchronous communications are I2C, SPI, etc. The USART, in a way, can act as the SPI master to send the data to the slave. The synchronous communication is also used when communicating with a smartcard.\n\nWe will use the UART for the major part of this series as it has wider applications compared to the USART.\n\nWe will use the STM32 MCU to send the data to the computer. Some of the Nucleo and Discovery dev boards from ST supports the virtual com port. This feature enables the USB connected for the ST link to be also used for the data transmission between the MCU and the computer.\n\nThe Virtual Com Port is supported by many Nucleo and Discovery boards but not all. You need to check the schematic of the board to confirm whether the respective board supports it.\n\nBelow are the images from the schematic of the Nucleo F446RE and Discovery F412.\n\nAs you can see in the images above, both Nucleo F446RE and Discovery F412 supports the USB Virtual Com Port. So if you are using either of these boards, you do not need to use an additional module to communicate to the computer. The USB used for the ST link can also be used for the communication.\n\nNot all the boards support this Virtual Com port feature. Below is the image from the schematic of the very famous STM32F4 Discovery board.\n\nAs you can see in the image above, there is no virtual com port in the F4 Discovery board. In such cases we can use some module to convert the UART signals to the USB, which is connected to the computer.\n\nBelow is the image showing the connection between the MCU and the FT232 USB to UART converter.\n\nThe UART is always connected in the cross connection, connecting the TX pin of the MCU to the RX of the device and the RX to the TX of the device. The module then connects to the computer using the USB.\n\nBelow is the image showing the UART configuration in cubeMX.\n\nWe will use the Asynchronous Mode for the communication. Only 2 pins are used in the Asynchronous mode, TX and RX.\n\nThe baud rate is set to 115200. We need to use the same baud rate for the receiver device also.\n\nWord length consists of the data bits and the parity bit. STM32 supports different word lengths of 7 bits, 8 bits and 9 bits. A typical UART frame is shown in the image below.\n\nThe frame consists of a start bit, data bits and stop bits. we are using 8 data bits with no parity bit and 1 stop bit. We need to use the same configuration in the receiver device also. The data direction is set to Receive and Transmit.\n\nThe oversampling is used to increase the tolerance of the receiver to the clock deviation. But it also reduces the maximum baud rate the device can achieve. The image below explains the oversampling and max baud rate.\n\nThis is all the configuration we need to do in the cubeMX. Let’s see the code now.\n\nWe can only send the ascii characters via the UART. Below we will see how to send a simple string and a number, by converting it to the character format.\n\nWe can directly send a string via the UART. The code below sends the string every 1 second.\n\nHere we define an array (data) which contains the string to be sent to the UART. Then call the function HAL_UART_Transmit in the while loop every 1 second.\n\nThe parameters of the function are as follows:\n• @size of the data in bytes, 12\n\nAs I mentioned we can not send the number directly to the UART. It only transmits the data in the ascii format. To send the number, we first need to convert each digit of the number to the character format and then send the data to the UART.\n\nHere we will send the number 123 to the UART. We first need to define an array of size at least the number of digits of the number.\n\nThe sprintf function is used to convert the number to the character format. The format specifier, %d, is used to convert the integral value (123).\n\nAfter conversion the characters are stored in the array, numarray. We send this array to the UART every 1 second.\n\nThe Serial console on the computer should have the same configuration as we did for the STM32 in the cubeMX. The image below shows the configuration with the baud rate of 115200, 8 data bits with 1 stop bit and no parity.\n\nThe data sent by the STM32 is received in the serial console. The image below shows the data, “Hello world”, printed several times. It was sent every 1 second by the MCU.\n\nWe also sent the number to the UART. The image below shows the number output on the console."
    },
    {
        "link": "https://deepbluembedded.com/stm32-usart-uart-tutorial",
        "document": "In this tutorial, we’ll discuss the STM32 UART Communication. You’ll learn how to use and configure the STM32 UART To Send/Receive Serial Data in polling, interrupt, and DMA modes. We’ll also implement a couple of STM32 UART Example Projects to practice what we’ll learn in this tutorial. Without further ado, let’s get right into it!\n\nUniversal Asynchronous Receiver/Transmitter or UART for short represents the hardware circuitry (module) being used for serial communication. UART is sold/shipped as a standalone integrated circuit (IC) or as an internal module within microcontrollers. In this tutorial, we’re concerned with the internal UART module within STM32 Microcontrollers.\n\nThere are actually two forms of UART hardware as follows:\n\nThe Synchronous type of transmitter generates the data clock and sends it to the receiver which works accordingly in a synchronized manner. On the other hand, the Asynchronous type of transmitter generates the data clock internally. There is no incoming serial clock signal, so to achieve proper communication between the two ends, both of them must be using the same baud rate.\n\nIn the next few tutorials, we’ll be doing some practical LABs to implement UART receiver/transmitter code examples. In which we’ll be using the CubeMX software tool to configure the USART hardware. Therefore, in this section, I’ll introduce to you the features and options that can be configured within CubeMX GUI for USART modules.\n\nHere is the configuration tab for the USART module in CubeMX\n\nAnd here are the possible modes for USART that can be configured.\n\nLet’s pick the asynchronous mode for example. You’ll find that now we’re able to set the baud rate, stop bits, parity control option, and other parameters. You can also enable/disable the USART data flow control. And USART interrupts from the NVIC interrupt controller parameters tab.\n\nThe STM32 HAL library provides us with a handful of functions to handle various UART operations (sending/receiving data, handling interrupts, DMA, etc). Below are the functions that you’ll most probably need in your projects. However, you can check the HAL firmware user manual for an exhaustive list of all UART HAL APIs.\n\nThe STM32 UART example below is a very basic test project that you can implement to get yourself started with the STM32 UART. It reads the incoming data (12 bytes) over the UART serial port and echo (transmit) it back to the terminal using the “polling” method.\n\nTo learn more about how this example code works, you can proceed to the next tutorials in this STM32 UART tutorial series (linked below)!\n\nThe next sections will help you learn theoretical information about the STM32 UART hardware and how it works internally. This will help you better understand how it works and how to configure the STM32 UART and optimize the performance of your target application. However, it’s not mandatory for everyone to study it in the meantime and you can now move on to the next part of this STM32 UART tutorial series.\n\nYou’ve almost completed the first part of This Multi-Part Tutorial Series:\n\nThe universal synchronous asynchronous receiver transmitter (USART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry-standard NRZ (Non-Return-To-Zero) asynchronous serial data format. The USART offers a very wide range of baud rates using a fractional baud rate generator.\n\nIt supports synchronous one-way communication and half-duplex single-wire communication. It also supports the LIN (local interconnection network), Smartcard Protocol, IrDA (infrared data association) SIR ENDEC specifications, and modem operations (CTS/RTS). It allows multiprocessor communication. High-speed data communication is possible by using the DMA for multi-buffer configuration.\n• None Fractional baud rate generator systems – A common programmable transmit and receive baud rates up to 4.5 MBits/s\n• None Configurable multi-buffer communication using DMA (direct memory access) – Buffering of received/transmitted bytes in reserved SRAM using centralized DMA\n\nIn this section, we’ll get a deep insight into the STM32 USART module hardware, its block diagram, functionalities, BRG, modes of operations, and data reception/transmission.\n\nAny USART bidirectional communication requires a minimum of two pins: Receive Data In (RX) and Transmit Data Out (TX). Through these pins, serial data is transmitted and received in normal USART mode. The CK pin is required to interface in synchronous mode. The CTS & RTS pins are required in Hardware flow control mode.\n\nAs you can easily spot in the digital block diagram for this UART hardware module, there are two separate shift registers and double-buffered in/out data for a full-duplex data transmission and reception operation. Both shift registers which shift-in or out the data during reception/transmission are being clocked at the rate of the BRG (baud rate generator) circuitry at the bottom of the diagram.\n\nThere is an address register for multi-processor communication mode. There exist a hardware data flow control unit to support this feature. And also an IrDA decoder circuitry, and interrupt control unit to generate various interrupt signals on different USART hardware events.\n\nWord length may be selected as being either 8 or 9 bits by programming the M bit in the USART_CR1 register. Transmission and reception are driven by a common baud rate generator, the clock for each is generated when the enable bit is set respectively for the transmitter and receiver. The TX pin is in a low state during the start bit. It is in a high state during the stop bit.\n\nAn Idle character is interpreted as an entire frame of “1”s followed by the start bit of the next frame which contains data (The number of “1” ‘s will include the number of stop bits).\n\nA Break character is interpreted on receiving “0”s for a frame period. At the end of the Break frame, the transmitter inserts either 1 or 2 stop bits (logic “1” bit) to acknowledge the start bit.\n\nThe USART transmitter can send data words of either 8 or 9 bits depending on the M bit status. When the transmit enable bit (TE) is set, the data in the transmit shift register is shifted out to the TX pin, and the corresponding clock pulses are output on the CK pin (for synchronous mode).\n\nDuring a USART transmission, data shifts out the least significant bit first on the TX pin. Every character is preceded by a start bit, which is a logic level low for a one-bit period. The character is terminated by a configurable number of stop bits. The following stop bits are supported by USART: 0.5, 1, 1.5, and 2 stop bits.\n• None Enable the USART by writing the UE bit in USART_CR1 register to 1.\n• None Program the M bit in USART_CR1 to define the word length.\n• None Program the number of stop bits in USART_CR2.\n• None Select DMA to enable (DMAT) in USART_CR3 if Multi buffer Communication is to take place. Configure the DMA register as explained in multi-buffer communication.\n• None Select the desired baud rate using the USART_BRR register.\n• None Set the TE bit in USART_CR1 to send an idle frame as the first transmission.\n• None Write the data to send in the USART_DR register (this clears the TXE bit). Repeat this for each data to be transmitted in case of a single buffer.\n• None After writing the last data into the USART_DR register, wait until TC=1. This indicates that the transmission of the last frame is complete. This is required for instance when the USART is disabled or enters the Halt mode to avoid corrupting the last transmission.\n\nWhen a transmission is taking place, a write instruction to the USART_DR register stores the data in the TDR register and which is copied in the shift register at the end of the current transmission.\n\nWhen no transmission is taking place, a write instruction to the USART_DR register places the data directly in the shift register, the data transmission starts, and the TXE bit is immediately set.\n\nIf a frame is transmitted (after the stop bit) and the TXE bit is set, the TC bit goes high. An interrupt is generated if the TCIE bit is set in the USART_CR1 register. After writing the last data into the USART_DR register, it is mandatory to wait for TC=1 before disabling the USART or causing the microcontroller to enter the low-power mode.\n\nThe TC bit is cleared by the following software sequence:\n\nThe TC bit can also be cleared by writing a ‘0’ to it.\n\nThe timing sequence diagram down below will show you the exact behavior of the USART transmitter hardware, the TC bit, and the TXE flag bit.\n\nThe USART can receive data words of either 8 or 9 bits depending on the M bit in the USART_CR1 register. In the USART, the start bit is detected when a specific sequence of samples is recognized.\n\nThis sequence is: 1 1 1 0 X 0 X 0 X 0 0 0 0. If the sequence is not complete, the start bit detection aborts and the receiver returns to the idle state (no flag is set) where it waits for a falling edge.\n\nThe receiver clock is x16 times faster than the transmitter clock which is generated by the same baud rate generator. Which guarantees more samples (typically 16) per bit-time duration. The diagram below shows you the start bit detection and the exact conditions that must be met to validate a true start bit.\n\nDuring a USART reception, data shifts in the least significant bit first through the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) between the internal bus and the received shift register.\n• None Enable the USART by writing the UE bit in the USART_CR1 register to 1.\n• None Program the M bit in USART_CR1 to define the word length.\n• None Program the number of stop bits in USART_CR2.\n• None Select DMA enable (DMAR) in USART_CR3 if multi-buffer communication is to take place. Configure the DMA register as explained in multi-buffer communication. STEP 3\n• None Select the desired baud rate using the baud rate register USART_BRR\n• None Set the RE bit USART_CR1. This enables the receiver which begins searching for a start bit.\n\nWhen a character is received, The RXNE bit is set. It indicates that the content of the shift register is transferred to the RDR. In other words, data has been received and can be read (as well as its associated error flags). An interrupt is generated if the RXNEIE bit is set.\n\nIn multibuffer, RXNE is set after every byte received and is cleared by the DMA read to the Data Register. In single buffer mode, clearing the RXNE bit is performed by software read to the USART_DR register. The RXNE flag can also be cleared by writing a zero to it. The RXNE bit must be cleared before the end of the reception of the next character to avoid an overrun error.\n\nThe baud rate for the receiver and transmitter (RX and TX) are both set to the same value as programmed in the Mantissa and Fraction values of USARTDIV.\n\nUSARTDIV is an unsigned fixed-point number that is coded on the USART_BRR register. F is the input clock to the USART peripheral.\n\nThe baud rate counters are updated with the new value of the Baud registers after a write to USART_BRR. Hence the Baud rate register value should not be changed during communication.\n\nDown below is an example table from the datasheet for the error (percentage) in the baud rate at different rates with different clock frequencies for comparison.\n\nThe (Error%) is defined as (Calculated Baud Rate – Desired Baud Rate) / Desired Baud Rate.\n\nParity control (generation of parity bit in transmission and parity checking in reception) can be enabled by setting the PCE bit in the USART_CR1 register. Depending on the frame length defined by the M bit, the possible USART frame formats are as listed in the table down below.\n\nEven parity: the parity bit is calculated to obtain an even number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.\n\nOdd parity: the parity bit is calculated to obtain an odd number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.\n\nThere is a possibility of performing multiprocessor communication with the USART (several USARTs connected in a network). For instance, one of the USARTs can be the master, its TX output is connected to the RX input of the other USART. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master.\n\nIn multiprocessor configurations it is often desirable that only the intended message recipient should actively receive the full message contents, thus reducing redundant USART service overhead for all non-addressed receivers.\n\nThe non-addressed devices may be placed in mute mode by means of the muting function.\n• None None of the reception status bits can be set.\n• None All the receive interrupts are inhibited.\n• None The RWU bit in the USART_CR1 register is set to 1. RWU can be controlled automatically by hardware or written by the software under certain conditions.\n\nThe USART can enter or exit from mute mode using one of two methods, depending on the WAKE bit in the USART_CR1 register:\n• None Idle Line detection if the WAKE bit is reset,\n• None Address Mark detection if the WAKE bit is set.\n\nThe USART enters mute mode when the RWU bit is written to 1. It wakes up when an Idle frame is detected. Then the RWU bit is cleared by hardware but the IDLE bit is not set in the USART_SR register. RWU can also be written to 0 by software.\n\nIn this mode, bytes are recognized as addresses if their MSB is a ‘1’ else they are considered as data. In an address byte, the address of the targeted receiver is put on the 4 LSB. This 4-bit word is compared by the receiver with its own address which is programmed in the ADD bits in the USART_CR2 register.\n\nThe USART enters mute mode when an address character is received which does not match its programmed address. In this case, the RWU bit is set by hardware. The RXNE flag is not set for this address byte and no interrupt nor DMA request is issued as the USART would have entered the mute mode.\n\nIt exits from mute mode when an address character is received which matches the programmed address. Then the RWU bit is cleared and subsequent bytes are received normally. The RXNE bit is set for the address character since the RWU bit has been cleared.\n\nThe RWU bit can be written to 0 or 1 when the receiver buffer contains no data (RXNE=0 in the USART_SR register). Otherwise, the write attempt is ignored.\n\nThe synchronous mode is selected by writing the CLKEN bit in the USART_CR2 register to 1. In synchronous mode, the following bits must be kept clear (0):\n• None SCEN, HDSEL, and IREN bits in the USART_CR3 register.\n\nThe USART allows the user to control bidirectional synchronous serial communication in master mode. The CK pin is the output of the USART transmitter clock. No clock pulses are sent to the CK pin during the start bit and stop bit. Depending on the state of the LBCL bit in the USART_CR2 register clock pulses will or will not be generated during the last valid data bit (address mark). The CPOL bit in the USART_CR2 register allows the user to select the clock polarity, and the CPHA bit in the USART_CR2 register allows the user to select the phase of the external clock.\n\nDuring IDLE, preamble, and send break, the external CK clock is not activated. In synchronous mode, the USART transmitter works exactly like in asynchronous mode. But as CK is synchronized with TX (according to CPOL and CPHA), the data on TX is synchronous.\n\nIn this mode, the USART receiver works in a different manner compared to the asynchronous mode. If RE=1, the data is sampled on CK (rising or falling edge, depending on CPOL and CPHA), without any oversampling. A setup and a hold time must be respected (which depends on the baud rate: 1/16 bit time).\n\nThe CK pin works in conjunction with the TX pin. Thus, the clock is provided only if the transmitter is enabled (TE=1) and data is being transmitted (the data register USART_DR has been written). This means that it is not possible to receive synchronous data without transmitting data.\n\nThe single-wire half-duplex mode is selected by setting the HDSEL bit in the USART_CR3 register. In this mode, the following bits must be kept clear (0):\n\nLINEN and CLKEN bits in the USART_CR2 register,\n\nSCEN and IREN bits in the USART_CR3 register.\n\nThe USART can be configured to follow a single-wire half-duplex protocol. In single-wire half-duplex mode, the TX and RX pins are connected internally. The selection between half and full-duplex communication is made with a control bit ‘HALF DUPLEX SEL’ (HDSEL in USART_CR3).\n\nAs soon as HDSEL is written to 1:\n• None RX is no longer used.\n• None TX is always released when no data is transmitted. Thus, it acts as a standard IO in idle or in reception. It means that the IO must be configured so that TX is configured as floating input (or output high open-drain) when not driven by the USART.\n\nApart from this, the communications are similar to what is done in normal USART mode.\n\nThe USART hardware in STM32 microcontrollers is capable of detecting 4 errors in operations. These error signals are as follows.\n\nAn overrun error occurs when a character is received when RXNE has not been reset. Data can not be transferred from the shift register to the RDR register until the RXNE bit is cleared.\n\nThe RXNE flag is set after every byte received. An overrun error occurs if the RXNE flag is set when the next data is received or the previous DMA request has not been serviced. When an overrun error occurs:\n• None The RDR content will not be lost. The previous data is available when a read to USART_DR is performed.\n• None The shift register will be overwritten. After that point, any data received during the overrun is lost.\n• None An interrupt is generated if either the RXNEIE bit is set or both the EIE and DMAR bits are set.\n• None The ORE bit is reset by a read to the USART_SR register followed by a USART_DR register read operation.\n• None The ORE bit, when set, indicates that at least 1 data has been lost. There are two possibilities:\n• None – if RXNE=1, then the last valid data is stored in the receive register RDR and can be read.\n• None – if RXNE=0, then it means that the last valid data has already been read and thus there is nothing to be read in the RDR. This case can occur when the last valid data is read in the RDR at the same time as the new (and lost) data is received. It may also occur when the new data is received during the reading sequence (between the USART_SR register read access and the USART_DR read access).\n\n\n\nOver-sampling techniques are used (except in synchronous mode) for data recovery by discriminating between valid incoming data and noise.\n\nWhen noise is detected in a frame:\n• None The is set at the rising edge of the RXNE bit.\n• None The invalid data is transferred from the Shift register to the USART_DR register.\n• None No interrupt is generated in the case of single-byte communication. However, this bit rises at the same time as the RXNE bit which itself generates an interrupt. In the case of multi-buffer communication, an interrupt will be issued if the EIE bit is set in the USART_CR3 register.\n\nThe NE bit is reset by a USART_SR register read operation followed by a USART_DR register read operation.\n\nA framing error is detected when: The stop bit is not recognized on reception at the expected time, following either a desynchronization or excessive noise.\n\nWhen the framing error is detected:\n• None The bit is set by hardware\n• None The invalid data is transferred from the Shift register to the USART_DR register.\n• None No interrupt is generated in the case of single-byte communication. However, this bit rises at the same time as the RXNE bit which itself generates an interrupt. In the case of multi-buffer communication, an interrupt will be issued if the EIE bit is set in the USART_CR3 register.\n\nThe FE bit is reset by a USART_SR register read operation followed by a USART_DR register read operation.\n\nWhen a parity error is detected in the received data frame, the PE bit is set and it’ll fire an interrupt if it’s enabled. It can be set to even or odd parity depending on the application and whether it’s implemented in the communication or not. We won’t be using the parity check in all the tutorials and LABs dealing with USART.\n\nIt is possible to control the serial data flow between two devices by using the CTS input and the RTS output. RTS and CTS flow control can be enabled independently by writing respectively RTSE and CTSE bits to 1 (in the USART_CR3 register). The diagram below shows how to connect two devices in this mode.\n\nIf the RTS flow control is enabled (RTSE=1), then RTS is asserted (tied low) as long as the USART receiver is ready to receive new data. When the receive register is full, RTS is de-asserted, indicating that the transmission is expected to stop at the end of the current frame.\n\nIf the CTS flow control is enabled (CTSE=1), then the transmitter checks the CTS input before transmitting the next frame. If CTS is asserted (tied low), then the next data is transmitted (assuming that data is to be transmitted, in other words, if TXE=0), else the transmission does not occur. When CTS is de-asserted during a transmission, the current transmission is completed before the transmitter stops.\n\nThe LIN (Local Interconnection Network) Mode is selected by setting the LINEN bit in the USART_CR2 register.\n\nIn LIN mode, the following bits must be kept clear (0):\n• None SCEN, HDSEL and IREN in the USART_CR3 register.\n\nThe same procedure for USART transmission discussed earlier applies to LIN Master transmission with the following differences:\n• None Set the LINEN bit to enter LIN mode. In this case, setting the SBK bit sends 13 ‘0’ bits as a break character. Then a bit of value ‘1’ is sent to allow the next start detection.\n\nA break detection circuit is implemented in the USART. The detection is totally independent of the normal USART receiver. A break can be detected whenever it occurs, during idle state or during a frame.\n\nWhen the receiver is enabled (RE=1 in USART_CR1), the circuit looks at the RX input for a start signal. The method for detecting start bits is the same when searching break characters or data. After a start bit has been detected, the circuit samples the next bits exactly like for the data (on the 8th, 9th and 10th samples). If 10 (when the LBDL = 0 in USART_CR2) or 11 (when LBDL=1 in USART_CR2) consecutive bits are detected as ‘0’, and are followed by a delimiter character, the LBD flag is set in USART_SR. If the LBDIE bit=1, an interrupt is generated.\n\nBefore validating the break, the delimiter is checked for as it signifies that the RX line has returned to a high level. If a ‘1’ is sampled before the 10 or 11 have occurred, the break detection circuit cancels the current detection and searches for a start bit again.\n\nThe IrDA mode is selected by setting the IREN bit in the USART_CR3 register. In IrDA mode, the following bits must be kept clear (0):\n• None LINEN, STOP, and CLKEN bits in the USART_CR2 register,\n• None SCEN and HDSEL bits in the USART_CR3 register.\n\nThe IrDA SIR physical layer specifies the use of a Return to Zero, an Inverted (RZI) modulation scheme that represents logic 0 as an infrared light pulse.\n\nThe SIR Transmit encoder modulates the Non-Return to Zero (NRZ) transmit bitstream output from USART. The output pulse stream is transmitted to an external output driver and infrared LED. USART supports only bit rates up to 115.2Kbps for the SIR ENDEC. In normal mode, the transmitted pulse width is specified as 3/16 of a bit period.\n\nThe SIR receive decoder demodulates the return-to-zero bitstream from the infrared detector and outputs the received NRZ serial bit stream to USART. The decoder input is normally HIGH (marking state) in the idle state. The transmit encoder output has the opposite polarity to the decoder input. A start bit is detected when the decoder input is low.\n\nTo get an idea of what configuration modes are supported in which USART module in the target MCU you’re using, you’ll have to check out the datasheet for it. You’ll find a table like the one shown below, highlighting which modes are supported in each USART module.\n\nFor the STM32F103C8 microcontroller in the blue pill board we’re using, there are only 3 USARTs.\n\nFor the STM32L432KC microcontroller in the Nucleo32-L432KC board we’re using, there are only 3 USARTs.\n\nThe USART interrupt events are connected to the same interrupt vector. So the USART fires a single interrupt signal regardless of the source of it. The software will have to detect it.\n• None During transmission: Transmission Complete, Clear to Send or Transmit Data Register empty interrupt.\n• None While receiving: Idle Line detection, Overrun error, Receive Data register not empty, Parity error, LIN break detection, Noise Flag (only in multi buffer communication), and Framing Error (only in multi buffer communication).\n\nThese events generate an interrupt if the corresponding Enable Control Bit is set. The diagram down below shows this interrupt signals mapping to only one request line.\n\nTo conclude this STM32 UART ultimate guide tutorial, we can say that we’ve explored the hardware features of the STM32 UART peripheral and its different operating modes. In the next tutorials of this series, we’ll explore the STM32 UART features & modes one by one to implement some example projects for each to get the hang of it and make sure you completely understand how and when to use each feature/configuration/mode of the STM32 UART.\n\nYou can now proceed to the other parts of this STM32 UART Tutorial Series."
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/stm32/stm32f407-gpio-tutorial-using-stm32cubeide",
        "document": "This is the Series of tutorials on the STM32 Microcontroller. The aim of this series is to provide easy and practical examples that anyone can understand. In this tutorial, we are going to see the STM32F407 GPIO Tutorial using STM32CubeIDE.\n\nThis tutorial aims to help beginners to understand the basics of STM32 GPIO programming using the higher-level abstractions, making it suitable for those who want to learn the fundamentals of microcontroller interaction. If you want to learn GPIO programming without HAL, you can read this Baremetal STM32 GPIO Tutorial.\n\nYou can also read, Getting Started with STM32 RTOS, STM32 GPIO RTOS tutorial, and STM32 Bootloader Tutorial.\n\nBefore starting this STM32F407 GPIO Tutorial, Please go through the below tutorials.\n\nWriting data to a designated port refers to transmitting data from the controller to any connected peripheral device. Here, an LED visualizes the data leaving the parallel port.\n\nThe reading operation involves retrieving data from any peripheral device. In this case, we are using a simple push-button (switch) to provide input to the port pins.\n\nThis STM32F407VGT6 Discovery Bboard comes with a 32-bit STM32F407VGT6 microcontroller which belongs to the F4 family of ST microcontrollers and is based on ARM Cortex-M4 architecture. Microcontrollers that belong to STM32F407xx support up to 140 GPIO pins with interrupt capability out of which up to 136 fast GPIOs up to 84 MHz and up to 138 5 V-tolerant GPIOs. STM32F407VGT6 microcontroller which comes with a microcontroller has 82 GPIO pins. In the STM32F4 discovery board, only 5 GPIO ports are available to use on the two connector headers from PORT A, PORT B, PORT C, PORT D, and PORT E and a total of 80 GPIO pins are available to use from two headers.\n\nThe Discovery board features four user LEDs connected to the PD12, PD13, PD14, and PD15 pins of PORTD, with each LED linked via a current-limiting resistor.\n• LD3: Orange LED is a user LED connected to the GPIO pin PD13 of the STM32F407VGT6\n• LD4: Green LED is a user LED connected to the I/O PD12 of the STM32F407VGT6\n• LD5: Red LED is a user LED connected to the I/O PD14 of the STM32F407VGT6\n• LD6: Blue LED is a user LED connected to the I/O PD15 of the STM32F407VGT6\n\nHere we are using onboard LED from Port D and pin 12, Further, we will see how to create a project using STM32cube IDE. To configure pin PD12 as an LED in STM32CubeIDE, follow these steps:,\n• Open STM32CubeIDE and create a new STM32 project for your target microcontroller.\n• Once the project is created, open the file to access the configuration settings.\n• In the Pinout & Configuration tab, find the pin labelled PD12\n• Click on PD12 to configure it. In the dropdown menu, select “GPIO_Output“. This sets the pin as a digital output.\n• In the Configuration tab (on the left side), click on “GPIO” to adjust settings.\n• You can configure the output level (default is usually low), speed, pull-up/pull-down resistors, etc., as per your requirements.\n• In this tutorial I configured as no pull-up and no pull-down. Once all the configurations are done save with CTRL+S\n• Open the file in the directory. In the function, you can toggle the LED with something like:\n\nYou can download the complete project from GitHub\n\nTo use a push button with the STM32F407 Discovery Board, we will configure the GPIO pins of the STM32F407VG microcontroller as a digital input pin. With the help of LED Interfacing, we learned to use GPIO pins as digital output pins by blinking the onboard LEDs of the Discovery board. In this Push button Interfacing, we will control onboard LEDs of the STM32F407 Discovery board with an onboard push button.\n\nThe discovery board has a user button connected to Pin 0 of the PORTA. We will use this push button as a digital input to manage the onboard LEDs on the board.\n\nWhen interfacing a push button with a microcontroller, our goal is to detect whether the button is pressed or not. Depending on the circuit configuration, pressing or releasing the button produces either a logic high or logic low output.\n\nIn the below schematic diagram, you will see that the onboard user push button is connected to the PA0 digital pin through a pull-down resistor. This setup means that when the button isn’t pressed, the PA0 pin will read an active low signal. When the button is pressed, the PA0 pin will read an active high signal.\n\nTo demonstrate, we will use a push button to control the onboard LED of the STM32 board.\n• The pin A0 will read the input from the push button. If the state is active high, it will turn on the onboard LED of the STM32407 Discovery board. Since the LED is connected to the PD12 pin in a No pull-up and No pull-down configuration, it will typically show an active high output.\n• When the push button is pressed, the LED will turn on; otherwise, it will stay off.\n• Now, we will see how to configure the pushbutton as input. We already know the LED configuration from the previous example.\n\nFurther, we will see how to create a project using STM32cube IDE. To configure pin PA0 as an push button in STM32CubeIDE, follow these steps:\n• Open STM32CubeIDE and create a new STM32 project for your target microcontroller.\n• Once the project is created, open the .ioc file to access the configuration settings.\n• In the Pinout & Configuration tab, find the pin labelled PA0\n• Click on PA0 to configure it. In the dropdown menu, select “GPIO_Input“. This sets the pin as a digital output.\n• Click on PD12 to configure it. In the dropdown menu, select “GPIO_Output“.\n• Open the file in the / directory. In the function, you can toggle the LED with something like:\n\nYou can download the complete project from GitHub\n\nIf you want to learn about other STM32 Microcontrollers GPIO Tutorials, You can read the below tutorials:\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/how-to-configure-a-parallel-synchronous-communication-through/td-p/327272",
        "document": "I'm not sure this is a suitable topic for them at all.\n\nAnd I don't use CubeMX so can't help with that one.\n\nBut basically the steps are simple, for the Rx:\n• set up the data GPIO as inputs\n• set up the clock pin as TIMx_CHy (in 'F4, only TIM1 and TIM8 can be used for this purpose, as only these timers can trigger DMA2 transfers, and only DMA2 can access GPIO)\n• in the timer TIMx_CMMRz, set TIMx_CHy to input capture (you don't need to set the timer/counter at all), enable it in TIMx_CCER (and maybe change polarity if needed)\n• in TIMx_DIER set the appropriate CCyDE to allow triggering the DMA\n• in the DMA Stream respective to TIMx_CHy, set up the control register as appropriate for channel number respective to given timer, transfer size and direction, required mode; set up number of transfers in NDTR and the address of respective GPIOx_IDR and memory buffer address in the respective address registers.\n\nTx differs in that the timer must run and the TIMx_CHy must be set as output compare (PWM). And of course the data GPIO pins have to be set as output and the DMA transfer direction has to be the opposite, using address of respective GPIOx_ODR.\n\nI believe, much of this can be clicked in CubeMX and the rest be written afterwards; but as I've said, I don't use Cube nor CubeMX.\n\nWell, that might be tricky.\n\nThe maximum AHB clock around 180MHz converts to a cycle time of cca 6ns, so 300ns is some 50 AHB cycles. That sounds like quite a lot.\n\nThe minimum GPIO-to-memory (or the other way around) transfer cycle time itself is determined by the DMA, see AN4031 - maybe a little less than a dozen of cycles end-to-end. But then there will be some latency from the input signal to the moment where the DMA is triggered (given by delays in the timer, resampling, maybe resynchronization between timer and DMA?), and there will be also some jitter (maybe 2-3 AHB cycles, a few cycles more if there's activity on the buses from the processor or other bus-matrix masters). So you need to experiment with inversion and delaying (using the filter) of the trigger signal so that DMA reads GPIO in around the middle of the data cycle, or in similar appropriate moment. All this assuming no other DMA2 load - there's still some cycles left, so other DMA2 processes are not excluded, but certainly require care. So, all in all, IMO that might be manageable but it requires some insight and certainly some experimentation and benchmarking; and also some insight so that adding some more program won't spoil it."
    },
    {
        "link": "https://vivonomicon.com/2018/04/22/bare-metal-stm32-programming-part-3-leds-and-buttons",
        "document": "In a previous post, I walked through creating a basic project for an ‘STM32F031K6’ microcontroller to boot the chip into a ‘main’ C method. But the actual program didn’t do much, so in this post we will learn how to use the STM32’s ‘GPIO’ peripheral to listen for a button press and blink an LED.\n\nThe ‘Nucleo’ boards provided by ST have an LED already built into the board, but they don’t have a button (besides the reset one,) so we’ll need to connect one externally:\n\nThe green ‘LD3’ LED is attached to pin B3 on the board. The 100nF capacitor across the button should help reduce noise, one side of the button connects to ground through a jumper wire, and I put a 470Ω resistor between the other side of the button and pin B1.\n\nStrangely, the B1 pin is labeled ‘D6’ on the Nucleo boards; I think that ST wanted to use the same footprint and labeling as the popular Arduino Nano. You can find the actual pin mappings in section 6.11 of this reference document, or they’re also printed on the informational card that comes with the board. The resistor and capacitor are both optional – they’re just a very simple form of debouncing. Next up, the code!\n\nThe STM32 chips have a lot of functionality which is not easy to represent in the standard C language. It has a number of hardware “Peripherals” to make it easier for you write programs which interact with the real world. They can do things like speak common communication protocols with other chips, run actions on timers, and send general-purpose signals to the pins connected to the chip.\n\nThe way that we read and program these peripherals is to check and set certain values at specific memory addresses. For example, in this tutorial we will set a bit to 1 in an “Output Data Register” to pull a pin’s voltage high enough to turn on an LED, and reset the same bit to 0 to pull the pin to ground and turn the LED off.\n\nThe companies which make these chips – ST Microelectronics in this case – usually also provide free header files which have definitions for which memory addresses go to which peripherals, and which bits do what. The bad news is, the definitions are all written as confusing acronyms, so it’s helpful to have your chip’s reference manual handy to check what the jumbles of letters mean. These supporting files are all located in the directory in the repository that I’ll link to at the end of this post.\n\nSome of the device header files – like and the ones starting with – are “CMSIS” files which provide some common ARM Cortex-M definitions and things like software helpers for things like setting up hardware interrupts.\n\nThe file provides general definitions shared across the entire STM32F0 line of chips, and the file has the definitions specific to our STM32F031K6 chip. The file is included by ST’s files because it is used in most of their auto-generated code, but its typical contents are not relevant to our low-level project. I included it as an empty file because the standard file depends on it.\n\nNow that we have external files to include, it makes sense to define a header file for those sorts of definitions:\n\nThe statements are a common pattern in C programming; they prevent the file from being included more than once. If it hasn’t been processed yet, the (‘if not defined’) will evaluate true and the file will be defined and included. If it has already been defined and included, then the will return false and the file will be ignored.\n\nThe header defines standard integer types like , and the file is the device header file discussed above. After the includes, we can define which GPIOB pins will be used for the button and LED. Pin is connected to the on-board LED on ST’s “Nucleo” boards.\n\nWith ST’s device files included, we can reference peripheral registers by name instead of address in our ‘main.c’ file. Before we use the GPIOB peripheral, we need to tell the chip to turn it on. By default, power is not applied to most of the chip’s peripherals for energy efficiency, so we need to turn them on by setting the appropriate bit in the RCC “clock enable” registers. For GPIOB, that looks like this:\n\nThose peripheral names are defined in the file that we included earlier, and this line must be included early in the main method. If try to use a peripheral without first enabling its ‘clock’ in the RCC registers, it will not work, and the GPIO pins are no exception. If we wanted to use a pin in the GPIOA bank, we would also need to set the bit.\n\nWith the peripheral initialized, we need to set up each individual pin – they default to ‘input mode’ with no pull-up/down resistors. There are four different registers which work together to set pin functions – they are described in section 8 of the reference manual, but here are the basics for each one:\n\nThe and settings are only used when the pin is set to ‘Output’ mode in . The ‘O’ in those register names stands for ‘Output’. The reset values are usually all zeros for those registers, with the exception of some debugging pins like A13 and A14.\n\nFor our ‘button’ pin, we want input mode with the pull-up resistor enabled – ‘Pull-Up’ means that the pin is “pulled” towards a ‘1’ / ‘High’ value. It will only read ‘0’ if the pin is connected to ground externally. STM32 chips have internal pull-up and pull-down resistors, but only one can be activated per pin. I think that they are close to 47KΩ each.\n\nFor the LED pin, we want a ‘push-pull’ output without any ‘pull-up/down’ resistors. ‘Push-pull’ outputs can pull a pin to either ‘1’ or ‘0’ while ‘open-drain’ outputs can only pull the pin to ‘0’. Open-drain outputs are useful if you have multiple devices set to ‘output’ on the same wire, because it prevents different devices from trying to pull the signal in two different directions at once and damaging each other. But we want push-pull, for simply turning an LED on or off:\n\nStrictly speaking, the statements are not necessary here; the chip will automatically set each register to 0 after a system reset. But when an option has more than one bit, it is good practice to reset the whole option before setting the bits you want. For example, if you had previously set a value to and you tried to set its first two bits to with the single command, , then the value would actually get set to , which is not what you wanted. Clearing those two bits first with a command like prevents that problem without overwriting any other settings in the register.\n\nAnyways, the button and LED pins are now initialized; we can check the current status of each GPIOB pin by reading the GPIOB peripheral’s ‘IDR’ (‘Input Data Register’) value:\n\nBits 0-15 in that variable will be set to ‘1’ if the corresponding pin is currently at ‘logic high’ voltage and ‘0’ if it is at ‘logic low’ (ground). The first bit (0x1) is pin 0, the next bit (0x2) is pin 1, and so on; pin 15’s status is at position . The ‘ODR’ (‘Output Data Register’) works the same way, but we can also write to it to set pins’ states if they have been set to an output mode. For example, this will pull the LED pin high, turning the board’s LED on:\n\nThe rest of this test ‘main’ program is just some simple logic to listen for a button press. We can’t just toggle the LED whenever the button is down, because even a very quick button press will span a lot of loop cycles. So we keep track of a ‘button_down’ variable to only toggle the LED when the button is pressed down from a previous ‘up’ state:\n\nAnd that’s all there is to it; you should be able to compile and upload that main method using our ‘minimal C’ project from the last post as an outline, and see that the green LED on the board changes state when pin is pulled to ground through the button.\n\nAlso, now that we don’t need to inspect memory values in a debugger to see that the program is working, you can upload the code more quickly using the utility:\n\nI hope that was fairly quick and digestible – especially compared to the last post! Using both our existing ‘minimal C program’ and ST’s handy pre-written register macros, we’re able to work with these chips and their peripherals in a way that is much less intimidating and time-consuming than raw assembly code. And of course, we can finally that our code is working by looking at the LED.\n\nSo while the first two posts in this series covered a lot of ground very quickly while also assuming that you have some prior knowledge about programming and debugging, you really don’t need to understand all of that low-level supporting code to create a robust embedded application these days, and I hope that the concepts presented in this project are starting to feel a bit more familiar and accessible. As usual, corrections or suggestions for presenting things more clearly are very welcome.\n\nHere is a repository with the code presented in this post.\n\nThe next post will probably cover how to use hardware interrupts – we’ll build on this understanding of GPIO pins to learn how to trigger an interrupt when a button is pressed. We’ll also cover the use of the ‘volatile’ keyword in embedded C, and learn a bit about ‘rotary encoder’ dials to demonstrate how it can be useful to respond to input signals the instant they happen, instead of checking the input state once every “loop” like we did in this example."
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/stm32/stm32f411-gpio-tutorial-using-stm32cubeide",
        "document": "This is the Series of tutorials on the STM32 Microcontroller. The aim of this series is to provide easy and practical examples that anyone can understand. In this tutorial, we are going to see the STM32F411 GPIO Tutorial using STM32CubeIDE.\n\nThis tutorial aims to help beginners to understand the basics of STM32 GPIO programming using the higher-level abstractions, making it suitable for those who want to learn the fundamentals of microcontroller interaction. If you want to learn GPIO programming without HAL, you can read this Baremetal STM32 GPIO Tutorial.\n\nYou can also read, Getting Started with STM32 RTOS, STM32 GPIO RTOS tutorial, and STM32 Bootloader Tutorial.\n\nBefore starting this STM32F411 GPIO Tutorial, Please go through the below tutorials.\n\nWriting data to a designated port refers to transmitting data from the controller to any connected peripheral device. Here, an LED visualizes the data leaving the parallel port.\n\nThe reading operation involves retrieving data from any peripheral device. In this case, we are using a simple push-button (switch) to provide input to the port pins.\n\nThe STM32F411CEU6 microcontroller on the Black Pill development board has a total of 5 GPIO ports: Port A, B, C, D, and E. These ports correspond to different pin groups on the microcontroller, with Port A (GPIOA) offering the most pins, from (PA0 to PA15). Port B (GPIOB) includes 8 pins (PB0 to PB7), while Port C (GPIOC) has 10 pins (PC0 to PC15), although some may not be available on the Black Pill). Port D (GPIOD) is composed of 6 pins (PD0 to PD5), and Port E (GPIOE) has only 3 pins (PE0 to PE2). While the Black Pill board exposes only a subset of these pins through its headers, these GPIOs can be configured for a wide range of functions such as UART, SPI, I2C, ADC, PWM, and more, depending on the specific needs of your project. Some pins on these ports are also used for special functions like SWD (Serial Wire Debug) or JTAG for debugging, and NRST for reset.\n\nThe STM32F411CEU6 Black Pill development board typically has one onboard LED. We will be using the onboard LED of the latest version of the STM32F411CEU6. So, this board comes with a user LED connected with a PC13 pin of PORTC through a current limiting resistor. Here we are using onboard LED from Port C and pin 13 Further, we will see how to create a project using STM32cube IDE and to configure pin PC13 as an LED in STM32CubeIDE, follow these steps:\n• Open STM32CubeIDE and create a new STM32 project for your target microcontroller.\n• Once the project is created, open the file to access the configuration settings.\n• In the Pinout & Configuration tab, find the pin labelled PC13\n• Click on PC13 to configure it. In the dropdown menu, select “GPIO_Output“. This sets the pin as a digital output.\n• In the Configuration tab (on the left side), click on “GPIO” to adjust settings.\n• You can configure the output level (default is usually low), speed, pull-up/pull-down resistors, etc., as per your requirements.\n• In this tutorial I configured as no pull-up and no pull-down. Once all the configurations are done save with CTRL+S\n• Open the file in the directory. In the function, you can toggle the LED with something like:\n\nYou can download the complete project from GitHub\n\nTo use a push button with STM32F11, we will configure GPIO pins of STM32F411CEU6 microcontroller as a digital input pin. In this Push button Interfacing, we will control onboard LED‘s of STM32F11 with an onboard push button.\n\nThe user Push button connected to pin 1 of PORTA GPIO. We will use this push button PA1 as a digital input to manage the onboard LED on the board.\n\nWhen interfacing a push button with a microcontroller, our goal is to detect whether the button is pressed or not. Depending on the circuit configuration, pressing or releasing the button produces either a logic high or logic low output.\n\nTo demonstrate, we will use a push button to control the onboard LED of the STM32 board.\n• The pin A1 will read the input from the push button. If the state is active high, it will turn on the onboard LED of the STM32407 Discovery board. Since the LED is connected to the PC13 pin in a No pull-up and No pull-down configuration, it will typically show an active high output.\n• When the push button is pressed, the LED will turn on; otherwise, it will stay off.\n• Now, we will see how to configure the pushbutton as input. We already know the LED configuration from the previous example.\n\nFurther, we will see how to create a project using STM32cube IDE. To configure pin PA0 as an push button in STM32CubeIDE, follow these steps:\n• Open STM32CubeIDE and create a new STM32 project for your target microcontroller.\n• Once the project is created, open the .ioc file to access the configuration settings.\n• In the Pinout & Configuration tab, find the pin labelled PA1\n• Click on PA1 to configure it. In the dropdown menu, select “GPIO_Input“. This sets the pin as a digital input and PA1 pin is configured with Pull-Up configuration.\n• Click on PC13 to configure it. In the dropdown menu, select “GPIO_Output“. Once all the configurations are done save with ctrl+S\n• One terminal of the push button is connected to PA1 (the GPIO pin on the STM32F411CEU6).\n• GND: The other terminal of the push button is connected to GND.\n• Open the file in the / directory. In the function, you can toggle the LED with something like:\n\nYou can download the complete project from GitHub\n\nIf you want to learn about other STM32 Microcontrollers GPIO Tutorials, You can read the below tutorials:\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/stm32u5a5-pc13-with-two-leds-four-states-instead-of-three/td-p/636146",
        "document": "Three states on a single GPIO pin with two LEDs is possible.\n\nFor users who want to drive 2 LEDs with three states with signal GPIO - please, see the details below.\n\nBut I want to ask one question:\n\nOn a STM32U5A5 - how does the PC13 behave? - I see \"FOUR states\" possible (even I can force later just to use three states).\n• None MCU was never flashed with a FW: both LEDs are on (dimmed, like getting pulses)\n• both LEDs off: configure PC13 as input (or GPIO_DeInit() to set as analog pin)\n• LED1 on / LED2 off: configured as output and drive low\n• LED1 off / LED2 on: configure as output and drive high\n\nI cannot force again to see both LEDs on.\n\nBut I am sure: after I have soldered my boards, power it up the first time in order to flush the 1st time my FW - both LEDs are on (but dimmed). I assume: there is a frequency (a toggling signal). But why and which one?\n\nBTW: how to configure PC13 for RTC_OUT1? I have not found an ALT setting to do so?\n\nOne GPIO pin for three states\n• Use a Dual-LED with two LEDs, \"anti-parallel\"\n• One LED is on, if GPIO is set low (acting as a sink)\n• The other LED is on, if GPIO is set high (providing a source)\n• Both LEDs are off, if GPIO is configured as an input (no current)\n\nRemark:\n\nif you run VDD as 1V8 (as I do) - you can only use red LEDs! The forward voltage of a green LED (or a blue one) is above 1V8 - it would never go on. With 3V3 you can use any combination of colors (maybe not white).\n\nThe fourth state is just there if MCU was flashed with a FW. Why do I see both LEDs?\n\nI tried to force the \"fourth state\" but with simple means not possible, like erasing entire MCU flash, not progressing in Reset_Handler.\n\nI can still make use the \"fourth state\" in order to realize if the MCU has a flashed FW running.\n\nIf you want to create a fourth state with one GPIO and two LEDs :\n• generate a frequency (toggling the GPIO fast enough, e.g. with 20 Hz or faster) - both LEDs are on\n\nBut this PC13 does not have an option for a PWM output. And not clear how to enable RTC_OUT1/RTC_TS, TAMP_OUT2. Is it maybe a TAMP_OUT2 signal when MCU FW was never flashed?\n\n: datasheet says: PC13,,,PC15 can just source 3mA in total (as sum). And it should not be used to drive LEDs (directly), even I do.\n\nBut I made sure the current is below 1mA (1V8 with 300R).\n\nI decided to use PC13 as LED because it does not have any other useful ALT function (e.g. SPI, I2C, ...)."
    }
]