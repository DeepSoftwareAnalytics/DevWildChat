[
    {
        "link": "https://help.autodesk.com/cloudhelp/2023/ENU/Maya-Tech-Docs/PyMel/ui.html",
        "document": "As with Maya nodes, pymel adds the ability to use object-oriented code for building MEL GUIs. Like nodes and PyNodes, every UI command in maya.cmds has a class counterpart in pymel derived from the base class . There is one class for every UI element type, each with necessary methods to get and set properties. And as with nodes, the procedural commands you already know and love are retrofitted to return classes, so you don’t have to completely change the way you code\n\nOne common point of confusion when building UIs with python is command callbacks. There are several different ways to handle command callbacks on user interface widgets.\n\nThe simplest method of setting up a callback is to pass the name of the callback function as a string. Maya will try to execute this as python code. Here’s a simple example: This example works fine if you run it from the script editor, but if you save it into a module, say , and then import that module as normal ( e.g. ), it will cease to work (assuming you haven’t already run it from the script edtior). This is because the namespace of the function has changed. It can no longer be found as , because from Maya’s perspective, its new location is . There are several solutions to this.\n• None you can import the contents of directly into the main namespace ( e.g. ). This will allow to be accessed without the namespace. This is not generally recommended as its clutters up your main namespace which could ultimately lead to name clashes.\n• None you can change your script and prefix the function with the module it will be imported from: The problem with both of these solutions is that you must ensure that the module is always imported the same way, and, if you plan to share your module with someone, it’s pretty impossible to do this. A more robust solution is to include an import command in the string to execute: That gives us a fairly reliable solution, but it still has one major drawback: any parameters that we wish to pass to our function must also be converted to strings. This becomes impractical when the parameters are complex objects, such as dictionaries, lists, or other custom objects. So, while string callbacks may seem simple at first, they have limitations, and are generally not recommended.\n\nWhen using this technique, you pass an actual function object instead of a string. The callback function has to be defined before it is passed to the command flag. The difference from the previous example is subtle: is now . The most important thing to realize here is that is not a string, it is a python function object. As such, if we had included ( e.g. ) we would have executed the function immediately, but we don’t want that to happen yet. By leaving the parentheses off, we hand the function over to the UI element to execute later. For most commands that support callbacks, Maya recognizes when you are passing a string and when you are passing a function, and it treats each differently when the callback is triggered. This method is very robust, but there are a few caveats to be aware of. To see what I mean, try executing the code above and pressing the button... ...when we press it, we get this error: Why?! The UI widget, like many others, automatically passes arguments to your function, whether you want them or not. Sometimes these arguments contain the state of the UI element, such as whether a checkbox is on or off, but in our case they are pretty useless. The automatic passing of arguments to python callbacks is an attempt to recreate a feature of MEL. When creating callbacks in MEL you can request that your callback procedure be passed an argument when the callback is triggered. Take the example below: When the callback is executed, the gets replaced with the current state of the radioButton: or . Unfortunately, when using python callbacks, you can’t request which arguments you want, you get them all. So, to make our callback work, we need to modify the function to accept the argument that the button callback is passing us: The tricky part is that different UI elements pass differing numbers of arguments to their callbacks, and some pass none at all. This is why it is best for your command to use the syntax, like so: \"pressed! here are my arguments The asterisk in front of allows the function to accept any quantity of passed arguments. All of the positional arguments to the function are stored in the variable (without the ) as a read-only list, known as a tuple. Making it a habit to use this syntax for your callbacks can save you a lot of headache.\n\nThe next technique builds on the last by simplifying the following situations:\n• You want to pass arguments to your callback function other than those automatically sent by the UI element\n• You’re using a function that someone else wrote and can’t add the to it For example, I want to pass our function a name argument. Here’s how we do this using a lambda function: So, what exactly is a lambda? It’s a shorthand way of creating a simple function on one line. It’s usually used when you need a function but you don’t need to refer to it later by name, which makes it well suited for callbacks. Combining lambda functions with the lessons we learned above adds more versatility to command callbacks. You can choose exactly which args you want to pass along. Let’s clarify what a lambda is. In the above example, this portion of the code... ...could have been written as: We would have then passed as the callback: Instead, we use the lambda to create the function on one line and pass it directly to the flag. The lambda function serves as a mediator between the UI element and our real callback, , giving us control over what arguments will be passed to . In our example, we ignore all the arguments passed by the button and instead opt to pass the string , however, if the circumstances require it, you could use the arguments in as well: In the example above we’re using the first of the arguments passed by the button (remember, is a tuple, which is like a list) and passing it on to our callback in addition to the name string. Keep in mind that for this to work our callback would need to be modified to accept two arguments. Whew! That was a lot to learn, but unfortunately, this method has a drawback, too. It does not work properly when used in a ‘for’ loop. In the following example, we’re going to make several buttons. Our intention is that each one will print a different name, but as you will soon see, we won’t succeed. When pressed, all the buttons will print ‘james’. Why is this? Think of a lambda as a “live” object. It lives there waiting to execute the code it has been given, but the variables in that code are live too, so the value of the variable named changes with each iteration through the loop, thereby changing the code that lambda is waiting to execute. What is its value at the end of the loop? It’s ‘james’. So all the lambda’s execute the equivalent of: To solve this we need to “pin” down the value of our variable to keep it from changing. To do this, pymel provides a object...\n\nIn my experience this method handles all cases reliably and predictably, and solves the ‘lambda’ issue described above. A object is an object that behaves like a function, meaning it can be ‘called’ like a regular function. The Callback object ‘wraps’ another function, and also stores the parameters to pass to that function. And, lucky for you, the Callback class is included with pymel. Our example now works as intended. The class provides the magic that makes it work. Pay close attention to how the Callback is created: the first argument, , is the function to wrap, and the rest are arguments to that function. The Callback stores the function and its arguments separately and then combines them when it is called by the UI element. So, on assignment, something that looks like this... In this case, the variable is the only additional argument, but the Callback class can accept any number of arguments or even keyword arguments, which it will dutifully pass along to your function when the callback is triggered. The class ignores any arguments passed in from the UI element, so you don’t have to design your function to take these into account. However, if you do want these, use the alternate callback object which will pass the UI arguments after yours."
    },
    {
        "link": "https://help.autodesk.com/cloudhelp/2022/ENU/Maya-Tech-Docs/PyMel/ui.html",
        "document": "As with Maya nodes, pymel adds the ability to use object-oriented code for building MEL GUIs. Like nodes and PyNodes, every UI command in maya.cmds has a class counterpart in pymel derived from the base class . There is one class for every UI element type, each with necessary methods to get and set properties. And as with nodes, the procedural commands you already know and love are retrofitted to return classes, so you don’t have to completely change the way you code\n\nOne common point of confusion when building UIs with python is command callbacks. There are several different ways to handle command callbacks on user interface widgets.\n\nThe simplest method of setting up a callback is to pass the name of the callback function as a string. Maya will try to execute this as python code. Here’s a simple example: This example works fine if you run it from the script editor, but if you save it into a module, say , and then import that module as normal ( e.g. ), it will cease to work (assuming you haven’t already run it from the script edtior). This is because the namespace of the function has changed. It can no longer be found as , because from Maya’s perspective, its new location is . There are several solutions to this.\n• None you can import the contents of directly into the main namespace ( e.g. ). This will allow to be accessed without the namespace. This is not generally recommended as its clutters up your main namespace which could ultimately lead to name clashes.\n• None you can change your script and prefix the function with the module it will be imported from: The problem with both of these solutions is that you must ensure that the module is always imported the same way, and, if you plan to share your module with someone, it’s pretty impossible to do this. A more robust solution is to include an import command in the string to execute: That gives us a fairly reliable solution, but it still has one major drawback: any parameters that we wish to pass to our function must also be converted to strings. This becomes impractical when the parameters are complex objects, such as dictionaries, lists, or other custom objects. So, while string callbacks may seem simple at first, they have limitations, and are generally not recommended.\n\nWhen using this technique, you pass an actual function object instead of a string. The callback function has to be defined before it is passed to the command flag. The difference from the previous example is subtle: is now . The most important thing to realize here is that is not a string, it is a python function object. As such, if we had included ( e.g. ) we would have executed the function immediately, but we don’t want that to happen yet. By leaving the parentheses off, we hand the function over to the UI element to execute later. For most commands that support callbacks, Maya recognizes when you are passing a string and when you are passing a function, and it treats each differently when the callback is triggered. This method is very robust, but there are a few caveats to be aware of. To see what I mean, try executing the code above and pressing the button... ...when we press it, we get this error: Why?! The UI widget, like many others, automatically passes arguments to your function, whether you want them or not. Sometimes these arguments contain the state of the UI element, such as whether a checkbox is on or off, but in our case they are pretty useless. The automatic passing of arguments to python callbacks is an attempt to recreate a feature of MEL. When creating callbacks in MEL you can request that your callback procedure be passed an argument when the callback is triggered. Take the example below: When the callback is executed, the gets replaced with the current state of the radioButton: or . Unfortunately, when using python callbacks, you can’t request which arguments you want, you get them all. So, to make our callback work, we need to modify the function to accept the argument that the button callback is passing us: The tricky part is that different UI elements pass differing numbers of arguments to their callbacks, and some pass none at all. This is why it is best for your command to use the syntax, like so: \"pressed! here are my arguments The asterisk in front of allows the function to accept any quantity of passed arguments. All of the positional arguments to the function are stored in the variable (without the ) as a read-only list, known as a tuple. Making it a habit to use this syntax for your callbacks can save you a lot of headache.\n\nThe next technique builds on the last by simplifying the following situations:\n• You want to pass arguments to your callback function other than those automatically sent by the UI element\n• You’re using a function that someone else wrote and can’t add the to it For example, I want to pass our function a name argument. Here’s how we do this using a lambda function: So, what exactly is a lambda? It’s a shorthand way of creating a simple function on one line. It’s usually used when you need a function but you don’t need to refer to it later by name, which makes it well suited for callbacks. Combining lambda functions with the lessons we learned above adds more versatility to command callbacks. You can choose exactly which args you want to pass along. Let’s clarify what a lambda is. In the above example, this portion of the code... ...could have been written as: We would have then passed as the callback: Instead, we use the lambda to create the function on one line and pass it directly to the flag. The lambda function serves as a mediator between the UI element and our real callback, , giving us control over what arguments will be passed to . In our example, we ignore all the arguments passed by the button and instead opt to pass the string , however, if the circumstances require it, you could use the arguments in as well: In the example above we’re using the first of the arguments passed by the button (remember, is a tuple, which is like a list) and passing it on to our callback in addition to the name string. Keep in mind that for this to work our callback would need to be modified to accept two arguments. Whew! That was a lot to learn, but unfortunately, this method has a drawback, too. It does not work properly when used in a ‘for’ loop. In the following example, we’re going to make several buttons. Our intention is that each one will print a different name, but as you will soon see, we won’t succeed. When pressed, all the buttons will print ‘james’. Why is this? Think of a lambda as a “live” object. It lives there waiting to execute the code it has been given, but the variables in that code are live too, so the value of the variable named changes with each iteration through the loop, thereby changing the code that lambda is waiting to execute. What is its value at the end of the loop? It’s ‘james’. So all the lambda’s execute the equivalent of: To solve this we need to “pin” down the value of our variable to keep it from changing. To do this, pymel provides a object...\n\nIn my experience this method handles all cases reliably and predictably, and solves the ‘lambda’ issue described above. A object is an object that behaves like a function, meaning it can be ‘called’ like a regular function. The Callback object ‘wraps’ another function, and also stores the parameters to pass to that function. And, lucky for you, the Callback class is included with pymel. Our example now works as intended. The class provides the magic that makes it work. Pay close attention to how the Callback is created: the first argument, , is the function to wrap, and the rest are arguments to that function. The Callback stores the function and its arguments separately and then combines them when it is called by the UI element. So, on assignment, something that looks like this... In this case, the variable is the only additional argument, but the Callback class can accept any number of arguments or even keyword arguments, which it will dutifully pass along to your function when the callback is triggered. The class ignores any arguments passed in from the UI element, so you don’t have to design your function to take these into account. However, if you do want these, use the alternate callback object which will pass the UI arguments after yours."
    },
    {
        "link": "https://github.com/LumaPictures/pymel/blob/master/docs/source/tutorial.rst",
        "document": "This tutorial assumes that you have some familiarity with python, but even if you only have MEL experience, you'll probably be able to follow along. If you are a MEL scripter but have not used python in maya yet, you should start with the Maya docs on the subject, particularly the section Using Python. This will help you to understand the differences in syntax between the two languages and how to translate between them.\n\nThe code in these tutorials is formatted as you would see it in Maya's Script Editor; however, the majority of the documentation outside of these tutorials is formatted as you would see it in a :doc:`python interpreter <standalone>`, which is standard for python documentation.\n\nYou might notice that the differences go beyond formatting. Although it is not the case, it appears as though the same commands return two different results: and . Prior to version 2011, Autodesk chose to deviate from the standard python practice of using an object's reproduction strings -- as returned by -- to display results, instead they use the object's string representation -- as returned by . This inevitably leads to confusion.\n\nHere's how you can get more informative results in the Script Editor:\n\nhere's a shorthand for the same thing:\n\nTo get started we need to import the pymel module:\n\nThis brings everything in pymel into the main namespace, meaning that you won't have to prefix the maya commands with the module name.\n\nBefore we proceed let's make sure we have a clean scene so that you'll get the same results as me:\n\nLet's start by listing the cameras in the scene. We do this in the same way that we would with :\n\nJust for comparison, let's do the same thing using :\n\nNotice the difference in the returned results. In the second example using , the ls <general.ls> function returns a list of strings. For those of us coming from a MEL background, a list of names as strings is what we would expect out of . PyMEL returns something much better -- instances of PyNode <general.PyNode> classes -- which are like strings on steroids. In addition to :term:`methods` for operating on node names as strings, these classes have methods for operating on the type of node or UI element that the string represents.\n\nLet's use one of these camera objects to get some information. To do this using we might write something like this:\n\nRewriting this in an object-oriented way is fairly straight-forward:\n\nSo, in our case becomes . And becomes .\n\nIf you are ever unsure of what method to use, just use the builtin python command on the node class (the capitalized node type). First find out what type of node you're working with. we'll continue from the example above, with our variable:\n\nThis prints . The part tells you what type of object it is. Now we can get help on that object type:\n\nThis prints all the documentation on the Camera <nodetypes.Camera> node type. If you want help on a particular method, you can do this:\n\nYou can do the same thing for any function as well:\n\nLet's look at another simple procedural example in which we find a camera, get it's transform node, then get the z component of its translation:\n\nNow let's convert this to an object-oriented style.\n\nInstead of listRelatives, we can use use methods available on , which is a nodetypes.Camera class ( which can also be referred to by the shorthand ). inherits from nodetypes.DagNode, so it has methods such as :meth:`getParent <nodetypes.DagNode.getParent>`, and :meth:`getChildren <nodetypes.DagNode.getChildren>`. In this case, we'll use :\n\nNext, instead of xform <general.xform>, we can use the :meth:`getTranslation <nodetypes.Transform.getTranslation>` method of the nodetypes.Transform node:\n\nNow, let's chain these commands together to compare procedural versus object-oriented.\n\nIn procedural programming, you take the result of one function and feed it into the arguments of another function, but in object oriented programming, functions are associated with -- you might even say \"attached to\" -- the returned objects themselves, so the chaining of functions is much easier to read. The object-oriented approach is shorter even though the procedural approach uses short flag names that obscure their purpose.\n\nOne thing that should be clear by now is that you can continue to code in a procedural way using PyMEL, because the pymel.core module provides the same set of :ref:`MEL-derived <why_wrappers>` commands as , but PyMEL wraps all of these commands to return powerful PyMEL node classes, so you can begin mixing in object-oriented code as you become more comfortable with it.\n\nYou can see that, like the ls <general.ls> command, the polyPlane <modeling.polyPlane> command also returns PyNode <general.PyNode> classes. As in MEL, it returns a list: the first object is the tranform of the plane, and the second is the construction history. Now let's get the shape of the transform:\n\nSo, we can clearly see that the shape is a Mesh. Let's explore the nodetypes.Mesh object a little. We can get the name as a string, formatted in different ways (the in front of the string denotes that it is a unicode string, meaning it can represent international characters).:\n\nWe can also get information specific to this mesh:\n\nOn the last line you see that vertices have their own class as well, MeshVertex <general.MeshVertex>. More on that later.\n\nI think it's time we learned how to set some attributes. Let's go back and take a look at our plane's transform and access an Attribute <general.Attribute> object. Just like nodes, attributes have their own class with methods that encompass the dozens of MEL commands for operating on them.:\n\nTo get and set attributes:\n\nHere's a few examples of how to query and edit properties of attributes:\n\nNow let's look into getting other objects connected to our plane shape. The :meth:`Attribute.connections <general.Attribute.connections>` method accepts the same flags as the procedural command listConnections.\n\nBelow we get incoming and outgoing connections:\n\nNotice that when we enable the flag that the result becomes an Attribute <general.Attribute> instead of a node type.:\n\nHere's another handy feature of python: it supports 2D arrays, meaning you can put lists inside lists. PyMEL takes advantage of that in many situations, including when we enable the flag, which causes listConnections to list source-destination pairs.:\n\nThis is particularly useful for looping\n\nIn many cases, you won't be creating objects directly in your code, but will want to gain access to an existing object by name. PyMEL provides two ways of doing this. Both of them will automatically choose the correct PyMEL class for your object.\n\nThe SCENE object ( an instance of the Scene class )\n\nCalling MEL scripts through is a nuisance because it requires so much string formatting on the programmer's part. handles all of that for you so you can use your MEL scripts as if they were python functions. This includes automatically formatting all iterable types into maya arrays.\n\nSee out pymel.core.language.Mel for more information.\n\nAll of the MEL functions in exist in , with a few exceptions ( see :doc:`modules` ). MEL functions that operate on nodes and/or attributes almost always fall into one or more of these categories: creating, listing, querying/editing. As you begin shifting toward a more object-oriented approach, you will still retain the need for procedural programming. Use these guidelines for what aspects of PyMEL are best suited to object-oriented programming:\n\nMixing module with will result in problems, because doesn't know what to do with anything other than very basic data types. Passing a PyNode <general.PyNode>, Matrix <datatypes.Matrix>, Vector <datatypes.Vector>, or other custom type to a function will result in errors. Your best bet is to completely replace with throughout your code in one go. This might sound frightening, but it will ultimately lead to fewer errors than partial PyMEL integration. The purely procedural part of will behave exactly the same as as long as it is replaced wholesale, but if it is not, results returned from PyMEL functions will cause errors when passed to functions, and results from will need to be cast to PyNodes.\n\nThere are only a handful of wraps in PyMEL that are not backward compatible. They all fall into the category of functions which now return a list of tuple pairs instead of a flat list:\n\nThese changes are all noted in the docstrings of each function."
    },
    {
        "link": "https://gucheng0712.github.io/python/2019/06/01/Creating-UI-in-Maya.html",
        "document": "\n• Using Nested Layout to Add Text Before the Input Field\n\n# make sure the window is overlay the maya # make sure the code will only run when this is the main file\n\nSometimes we also need to grab input from field controls, in both integet and float varieties.\n\nThe below script is to create spheres by grabing the input field.\n\nUsing Nested Layout to Add text Before the Input Field\n\nMany times, we will want to create organized UI Layout, we need to nest layouts inside each other.\n\nThe following example shows using rowLayouts within a single columnLayout to add label before the input field.\n\n# in order to continue to add out UI, we have you use `cmds.setParent(\"..\")` # to back to the previous layout, which is the column layout\n\ncan help you get the info of the currently selected tab Use selectTabIndex to set which tab is currently actice"
    },
    {
        "link": "https://medium.com/mighty-bear-games/maya-python-for-newbies-basics-c0fd548024a9",
        "document": "In this guide, I will be giving a very brief introduction to Python in Maya. This guide is suitable even for those without any knowledge in programming.\n• Maya (Any version that has support for Python should work)\n\nIn this part we will:\n• Go through how we are going to code in Maya’s built-in Script Editor\n• Understand the difference between MEL and Python\n• Get a brief introduction on modules and functions\n• Find functions from the Maya technical documentation to perform standard Maya procedures\n\nPython files are just text files and can be edited in any text editing programs. For the purpose of this guide, I’ll be using Maya’s script editor.\n\nThe script editor icon can be found at the bottom right corner of the UI.\n\nThis will bring up the script editor.\n\nThe only two things you really need to care about are the two boxes highlighted in red. The top box is your history. It will display scripts you ran or actions you made. The bottom box is where you will be spending most of your time in this guide as that is where you input your commands.\n\nYou may notice the tab that says MEL:\n\nMEL is the default scripting language that Maya uses. Unlike Python, MEL works in both Maya LT as well as Maya. However, we are not going to be coding in MEL, we will be coding in Python.\n\nTo create a Python script, simply click on the ‘+’ sign next to it and select “Python”.\n\nNow you are ready to start coding in Python!\n\nIn Python, before we write our main code, we need to import modules. Modules can be compared to a toolbox. You can have a toolbox specifically for hammers or a toolbox that is specifically for wrenches.\n\nTo import a module, simply use the command:\n\nThere are potentially thousands of modules that you could use. However, for starters, the module is usually enough for use in Maya. So let’s import that:\n\nYou may have noticed I added at the end. This is my way of shortening . This is not compulsory but it does help speed things up later on. Essentially, if we want to call a function from this module, we will just have to type in instead of .\n\nUsing the toolbox analogy again, if modules are the toolboxes itself, a function is a tool in it. A function is basically a task that the code will execute. Just like how a hammer is meant to hammer nails.\n\nSome examples of functions in Maya:\n\nIf you want to create a cube through Python, the function is called . To call this, simply type in . If you did not shorten then you will need to type instead.\n\nYou can try running this code by pressing Ctrl + Enter. If everything works you should have a cube in your viewport!\n\nLet’s say you want your code to do a certain action that you know how to do manually. How do you find the name of the function for that?\n\nAll you have to do is actually just to look at the Script Editor history log.\n\nThis log keeps track of pretty much every action you make in Maya.\n\nNote: It’s also written in MEL. Which means that if you wanted to you could just copy-paste this into a MEL script and it’ll just repeat whatever you did.\n\nI highlight this because we can find the function we want in Python using this method.\n\nLet’s say we do not know what’s the function to create a sphere. How do we find out?\n\nSimply create a sphere and look at the history log.\n\nWe can see . I’ll explain everything that comes after it in the future.\n\nYou can head on to the Maya Python documentation and lookup that function using their search bar.\n\nAfter searching “polySphere”, you can then access information about this particular function, including examples on how to use it.\n\nWe can create this sphere the same way we created the cube with\n\nI gave a simple example for creating a sphere but this applies to anything else you do in Maya.\n\nYou can save this code into a Python file. Just click on to File>Save Script in your Script Editor. End off the file name with “.py”.\n• A module is a toolbox that carries a variety of tools.\n• Functions are the tools that are included in that toolbox.\n• We can call a module by using followed by the module we want to import. Usually, we would import the module in Maya\n• There are available functions to do Maya operations that can be found in their technical documentation\n\nIf you find this article useful, please leave some claps! Do look out for upcoming articles where I go into more detail about Python in Maya."
    },
    {
        "link": "https://help.autodesk.com/view/MAYACRE/ENU?guid=GUID-8A96A8DB-FD6F-434F-A878-288DD84E99C7",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/64304915/how-to-make-selected-object-renamed-in-maya-using-python",
        "document": "I've corrected your code, it shuold work when ran but there is lots of mistakes in your code, Haggi Krey has pointed lots of them. If you want to dive in UI design, you should look at partial module from functools. There is lots of examples here in Stack"
    },
    {
        "link": "https://reddit.com/r/Maya/comments/1ffa8kn/python_script_vs_python_for_maya",
        "document": "Hey guys! Front up: I have no clue about scripting in general. I am thinking about getting a foot into it since it could help with Rigging.\n\nQuestion: Is python in maya different from python in generell? Should I get a course for maya specific python or would u recommend to learn python over all?\n\nAlso if anybody has recommendations for a course or anything let me know:)"
    },
    {
        "link": "https://around-the-corner.typepad.com/adn/2022/03/maya-2023-api-update-guide.html",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Maya/comments/18cz6we/what_would_be_the_most_ideal_way_to_go_about",
        "document": "I could change the names manually but when there's hundreds of bolts it becomes very time consuming.\n\nOr is it ok for meshes to share the same name and I can therefore remove the numerical suffix?"
    }
]