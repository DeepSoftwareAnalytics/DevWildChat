[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html",
        "document": "Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don’t throw an error.\n\nSee the user guide for more.\n\nDict-like or function transformations to apply to that axis’ values. Use either and to specify the axis to target with , or and . Alternative to specifying axis ( is equivalent to ). Alternative to specifying axis ( is equivalent to ). Axis to target with . Can be either the axis name (‘index’, ‘columns’) or number (0, 1). The default is ‘index’. The keyword will change behavior in pandas 3.0. Copy-on-Write will be enabled by default, which means that all methods with a keyword will use a lazy copy mechanism to defer the copy and ignore the keyword. The keyword will be removed in a future version of pandas. You can already get the future behavior and improvements through enabling copy on write Whether to modify the DataFrame rather than creating a new one. If True then value of copy is ignored. level int or level name, default None In case of a MultiIndex, only rename labels in the specified level. If ‘raise’, raise a when a dict-like , , or contains labels that are not present in the Index being transformed. If ‘ignore’, existing keys will be renamed and extra keys will be ignored. DataFrame with the renamed axis labels or None if . If any of the labels is not found in the selected axis and “errors=’raise’”.\n\nWe highly recommend using keyword arguments to clarify your intent."
    },
    {
        "link": "https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas",
        "document": "I want to change the column labels of a Pandas DataFrame from\n\nUse the function and refer the columns to be renamed. Not all the columns have to be renamed: df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}) # Or rename the existing DataFrame (rather than creating a copy) df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True) The following methods all work and produce the same output: Remember to assign the result back, as the modification is not-inplace. Alternatively, specify : You can specify to raise errors if an invalid column-to-rename is specified.\n\nThere have been some significant updates to column renaming in version 0.21.\n• The method has added the parameter which may be set to or . This update makes this method match the rest of the pandas API. It still has the and parameters but you are no longer forced to use them.\n• The method with the set to enables you to rename all the index or column labels with a list. Using with or Both result in the following: It is still possible to use the old method signature: The function also accepts functions that will be applied to each column name. Using with a list and You can supply a list to the method that is equal in length to the number of columns (or index). Currently, defaults to , but will be defaulted to in future releases. Why not use ? There is nothing wrong with assigning columns directly like this. It is a perfectly good solution. The advantage of using is that it can be used as part of a method chain and that it returns a new copy of the DataFrame. Without it, you would have to store your intermediate steps of the chain to another variable before reassigning the columns. # new for pandas 0.21+ df.some_method1() .some_method2() .set_axis() .some_method3() # old way df1 = df.some_method1() .some_method2() df1.columns = columns df1.some_method3()\n• I have the edited column names stored it in a list, but I don't know how to replace the column names. I do not want to solve the problem of how to replace or strip the first character off of each column header. OP has already done this step. Instead I want to focus on replacing the existing object with a new one given a list of replacement column names.\n• None where is the list of new columns names is as simple as it gets. The drawback of this approach is that it requires editing the existing dataframe's attribute and it isn't done inline. I'll show a few ways to perform this via pipelining without editing the existing dataframe. Setup 1\n\n To focus on the need to rename of replace column names with a pre-existing list, I'll create a new sample dataframe with initial column names and unrelated new column names. It has been said already that if you had a dictionary mapping the old column names to new column names, you could use . However, you can easily create that dictionary and include it in the call to . The following takes advantage of the fact that when iterating over , we iterate over each column name. # Given just a list of new column names df.rename(columns=dict(zip(df, new))) x098 y765 z432 0 1 3 5 1 2 4 6 This works great if your original column names are unique. But if they are not, then this breaks down. First, notice what happens when we attempt to use solution 1: We didn't map the list as the column names. We ended up repeating . Instead, we can use the argument of the function while iterating through the columns of . pd.concat([c for _, c in df.items()], axis=1, keys=new) x098 y765 z432 0 1 3 5 1 2 4 6 Solution 3\n\n Reconstruct. This should only be used if you have a single for all columns. Otherwise, you'll end up with for all columns and converting them back requires more dictionary work. Solution 4\n\n This is a gimmicky trick with and . allows us to set an index inline, but there is no corresponding . So we can transpose, then , and transpose back. However, the same single versus mixed caveat from solution 3 applies here. Solution 5\n\n Use a in that cycles through each element of .\n\n In this solution, we pass a lambda that takes but then ignores it. It also takes a but doesn't expect it. Instead, an iterator is given as a default value and I can then use that to cycle through one at a time without regard to what the value of is. And as pointed out to me by the folks in sopython chat, if I add a in between and , I can protect my variable. Though, in this context I don't believe it needs protecting. It is still worth mentioning.\n\nI would like to explain a bit what happens behind the scenes. Series in turn are an extension of a . This is the name of the series. It is seldom that Pandas respects this attribute, but it lingers in places and can be used to hack some Pandas behaviors. A lot of answers here talks about the attribute being a when in fact it is a . This means it has a attribute. This is what happens if you decide to fill in the name of the columns : df.columns = ['column_one', 'column_two'] df.columns.names = ['name of the list of columns'] df.index.names = ['name of the index'] name of the list of columns column_one column_two name of the index 0 4 1 1 5 2 2 6 3 Note that the name of the index always comes one column lower. The attribute lingers on sometimes. If you set then the will be . If you set then will still give you , and will give you . Because Pandas reuses the of the already defined . Pandas has ways of doing multi-layered column names. There is not so much magic involved, but I wanted to cover this in my answer too since I don't see anyone picking up on this here. |one | |one |two | 0 | 4 | 1 | 1 | 5 | 2 | 2 | 6 | 3 | This is easily achievable by setting columns to lists, like this: df.columns = [['one', 'one'], ['one', 'two']]\n\nOne use-case not mentioned on this page is how to rename a column by index, i.e. rename a column name at a specific position. If the column names are unique, then would work. For example, if we want to rename the second column, the following would work. df = pd.DataFrame({'$A': [1, 2], '$B': ['a', 'b']}) df.rename(columns={df.columns[1]: 'new'}, inplace=True) # ^^^^^^^^^^^^^ <--- second column is renamed However, if the column labels are non-unique (which is a common reason to rename it by index in the first place), the above would change all duplicate column names. However, is an immutable pandas Index object that is built on a (mutable) numpy ndarray which can be accessed as a view using / . Modifying the underlying array by index does the job. # modify the second column name df = pd.DataFrame([[1, 'a', 1.2], [2, 'b', 3.4]], columns=['$A', '$B', '$B']) df.columns[1] = 'new' # <---- TypeError df.columns.values[1] = 'new' # <---- OK df.columns.to_numpy()[1] = 'new' # <---- OK To perform the same in a chained method or create a new copy of a dataframe would require changing the entire columns object and assign using : # change the second column name df = df.set_axis([*df.columns[:1], 'new', *df.columns[2:]], axis=1) also defines a accessor, which enables one to call specific string methods. For the use case in the question, one could use to remove leading s."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-rename-columns-in-pandas-dataframe",
        "document": "In this article, we will see how to rename column in Pandas DataFrame. The simplest way to rename columns in a Pandas DataFrame is to use the rename() function. This method allows renaming specific columns by passing a dictionary, where keys are the old column names and values are the new column names.\n\nThis code changes column names from ‘A’ to ‘X’ , ‘B’ to ‘Y’ and ‘C’ to ‘Z’.\n\nThe rename method is straightforward and flexible, but there are other useful methods, which we’ll explore below.\n\nRename Columns by Assigning a List of New Column Names\n\nIf you need to rename all columns at once, you can directly assign a list of new column names to the columns attribute of the DataFrame. This approach is concise and convenient for changing multiple column names simultaneously.\n\nThis replaces the original column names with the new list [‘X’, ‘Y’, ‘Z’]. Make sure the length of the list matches the number of columns in the DataFrame.\n\nThe method can be used to rename all columns in a DataFrame. This function takes a list of new column names and an axis (0 for rows, 1 for columns) and returns a DataFrame with renamed columns.\n\nHere, set_axis renames the columns to [‘Alpha’, ‘Beta’]. Setting inplace=False ensures the operation returns a new DataFrame, leaving the original unchanged.\n\nTo systematically rename columns by adding a prefix or suffix, you can use the add_prefix or add_suffix methods. This is helpful for categorizing columns or distinguishing them from other sets of data.\n\nThe add_prefix method renames columns by adding ‘col_’ as a prefix, while add_suffix appends ‘_data’ as a suffix.\n\nIf you need to modify column names by replacing specific characters, you can use the str.replace function on the columns attribute. This method is handy for removing or altering unwanted characters or spaces.\n\nThis replaces spaces in column names with underscores, which is helpful for maintaining consistent naming conventions.\n\nHow do I rename multiple columns in pandas?\n\nHow do I rename only certain columns in pandas?\n\nHow to rename column names Pandas with list?\n\nHow do you set column names in DataFrame?"
    },
    {
        "link": "https://freecodecamp.org/news/how-to-rename-a-column-in-pandas",
        "document": "A Pandas Dataframe is a 2-dimensional data structure that displays data in tables with rows and columns.\n\nIn this article, you'll learn how to rename columns in a Pandas Dataframe by using:\n\nHow to Rename a Column in Pandas Using the Function\n\nIn this section, you'll see a practical example of renaming a Pandas Dataframe using the function.\n\nIn the example above, we created a Python dictionary which we used to store the and of students.\n\nWe then converted the dictionary to a Dataframe by passing it as a parameter to the Pandas Dataframe object: .\n\nWhen printed to the console, we had this table printed out:\n\nThe goal here is to rename the columns. We can do that using the function.\n\nHere's what the syntax looks like:\n\nLet's go ahead and change the column names ( and ) in the table from lowercase to uppercase ( and ).\n\nIn the code above, we specified that the columns and should be renamed to and , respectively:\n\nYou'll notice that we added the parameter. This helps in persisting the new changes in the Dataframe. Delete the parameter and see what happens ;)\n\nYou can rename the columns to whatever you want. For instance, we can use instead of by doing this:\n\nYou can change just one column name, too. You are not required to change all the column names at the same time.\n\nHow to Rename a Column in Pandas Using a List\n\nYou can access the column names of a Dataframe using . Consider the table below:\n\nWe can print out the column names with the code below:\n\nUsing that, we can rename the column of a Dataframe. Here's an example:\n\nIn the example above, we put the new column names in a List and assigned it to the Dataframe columns: .\n\nThis will override the previous column names.\n\nHow to Rename a Column in Pandas Using the Function\n\nThe syntax for renaming a column with the function looks like this:\n\nNote that the parameter might raise a warning because it's deprecated for the function and will be replaced in the future.\n\nIn this article, we talked about renaming a column in Pandas.\n\nWe saw different methods that can be used to rename a Pandas Dataframe column with code examples."
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.DataFrame.rename.html",
        "document": "Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don’t throw an error.\n\nSee the user guide for more.\n\nDict-like or function transformations to apply to that axis’ values. Use either and to specify the axis to target with , or and . Alternative to specifying axis ( is equivalent to ). Alternative to specifying axis ( is equivalent to ). Axis to target with . Can be either the axis name (‘index’, ‘columns’) or number (0, 1). The default is ‘index’. The keyword will change behavior in pandas 3.0. Copy-on-Write will be enabled by default, which means that all methods with a keyword will use a lazy copy mechanism to defer the copy and ignore the keyword. The keyword will be removed in a future version of pandas. You can already get the future behavior and improvements through enabling copy on write Whether to modify the DataFrame rather than creating a new one. If True then value of copy is ignored. level int or level name, default None In case of a MultiIndex, only rename labels in the specified level. If ‘raise’, raise a when a dict-like , , or contains labels that are not present in the Index being transformed. If ‘ignore’, existing keys will be renamed and extra keys will be ignored. DataFrame with the renamed axis labels or None if . If any of the labels is not found in the selected axis and “errors=’raise’”.\n\nWe highly recommend using keyword arguments to clarify your intent."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5.0/user_guide/options.html",
        "document": "Use the bottleneck library to accelerate if it is installed, Use the numba engine option for select operations if it is installed, Use the numexpr library to accelerate computation if it is installed, if set to a float value, all float values smaller than the given threshold will be displayed as exactly 0 by repr and friends. [default: None] [currently: None] Controls the justification of column headers. used by DataFrameFormatter. [default: right] [currently: right] When True, prints and parses dates with the day first, eg 20/01/2005 When True, prints and parses dates with the year first, eg 2005/01/20 Defaults to the detected encoding of the console. Specifies the encoding to be used for strings returned by to_string, these are generally strings meant to be displayed on the console. Whether to print out the full DataFrame repr for wide DataFrames across multiple lines, `max_columns` is still respected, but the output will wrap-around across multiple \"pages\" if its width exceeds `display.width`. The callable should accept a floating point number and return a string with the desired format of the number. This is used in some places like SeriesFormatter. See formats.format.EngFormatter for an example. [default: None] [currently: None] A ``border=value`` attribute is inserted in the ``<table>`` tag Whether to publish a Table Schema representation for frontends When True, Jupyter notebook will process table contents using MathJax, For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can show a truncated table (the default from 0.13), or switch to the view from df.info() (the behaviour in earlier versions of pandas). This specifies if the to_latex method of a Dataframe uses escapes special This specifies if the to_latex method of a Dataframe uses the longtable This specifies if the to_latex method of a Dataframe uses multicolumns This specifies if the to_latex method of a Dataframe uses multicolumns This specifies if the to_latex method of a Dataframe uses multirows Whether to produce a latex DataFrame representation for jupyter This sets the maximum number of categories pandas should output when printing out a `Categorical` or a Series of dtype \"category\". If max_cols is exceeded, switch to truncate view. Depending on `large_repr`, objects are either centrally truncated or printed as In case python/IPython is running in a terminal and `large_repr` equals 'truncate' this can be set to 0 and pandas will auto-detect the width of the terminal and print a truncated object which fits the screen width. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do The maximum width in characters of a column in the repr of placeholder is embedded in the output. A 'None' value means unlimited. The number of items that will be added to `dir(...)`. 'None' value means unlimited. Because dir is cached, changing this option will not immediately affect already existing dataframes until a column is deleted or added. This is for instance used to suggest columns from a dataframe to tab max_info_columns is used in DataFrame.info method to decide if per column information will be printed. df.info() will usually show null-counts for each column. For large frames this can be quite slow. max_info_rows and max_info_cols limit this null check only to frames with smaller dimensions than If max_rows is exceeded, switch to truncate view. Depending on `large_repr`, objects are either centrally truncated or printed as In case python/IPython is running in a terminal and `large_repr` equals 'truncate' this can be set to 0 and pandas will auto-detect the height of the terminal and print a truncated object which fits the screen height. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do When pretty-printing a long sequence, no more then `max_seq_items` will be printed. If items are omitted, they will be denoted by the addition of \"...\" to the resulting string. If set to None, the number of items to be printed is unlimited. This specifies if the memory usage of a DataFrame should be displayed when The numbers of rows to show in a truncated view (when `max_rows` is exceeded). Ignored when `max_rows` is set to None or 0. When set to None, follows the value of `max_rows`. When True, IPython notebook will use html representation for pandas objects (if it is available). Controls the number of nested levels to process when pretty-printing Floating point output precision in terms of number of places after the decimal, for regular formatting as well as scientific notation. Similar Whether to print out dimensions at the end of DataFrame repr. If 'truncate' is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) Whether to use the Unicode East Asian Width to calculate the display text Enabling this may affect to the performance (default: False) Whether to use the Unicode East Asian Width to calculate the display text Enabling this may affect to the performance (default: False) Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. The default Excel reader engine for 'ods' files. Available options: The default Excel writer engine for 'ods' files. Available options: The default Excel reader engine for 'xls' files. Available options: The default Excel writer engine for 'xls' files. Available options: The default Excel reader engine for 'xlsb' files. Available options: The default Excel reader engine for 'xlsm' files. Available options: The default Excel writer engine for 'xlsm' files. Available options: The default Excel reader engine for 'xlsx' files. Available options: The default Excel writer engine for 'xlsx' files. Available options: default format writing format, if None, then put will default to 'fixed' and append will default to 'table' [default: None] [currently: None] drop ALL nan rows when appending to a table Raise an exception, warn, or no action if trying to use chained assignment, Use new copy-view behaviour using Copy-on-Write. Defaults to False, unless overridden by the 'PANDAS_COPY_ON_WRITE' environment variable (if set to \"1\" for True, needs to be set before pandas is imported). Internal data manager type; can be \"block\" or \"array\". Defaults to \"block\", unless overridden by the 'PANDAS_DATA_MANAGER' environment variable (needs to be set before pandas is imported). Whether to simulate interactive mode for purposes of testing True means treat None, NaN, INF, -INF as NA (old way), False means None and NaN are null, but INF, -INF are not NA use_inf_as_null had been deprecated and will be removed in a future The plotting backend to use. The default value is \"matplotlib\", the backend provided with pandas. Other backends can be specified by providing the name of the module that implements the backend. Whether to register converters with matplotlib's units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. The character representation for the decimal separator for floats and complex. Whether to escape certain characters according to the given context; html or latex. [default: None] [currently: None] A formatter object to be used as default within ``Styler.format``. [default: None] [currently: None] The string representation for values identified as missing. [default: None] [currently: None] The precision for floats and complex numbers. The character representation for thousands separator for floats, int and complex. [default: None] [currently: None] If False will render special CSS classes to table attributes that indicate Mathjax will not be used in Jupyter Notebook. The environment to replace ``\\begin{table}``. If \"longtable\" is used results [default: None] [currently: None] Whether to add horizontal rules on top and bottom and below the headers. The specifier for horizontal alignment of sparsified LaTeX multicolumns. Pipe decorators can also be added to non-naive values to draw vertical rules, e.g. \"\\|r\" will draw a rule on the left side of right aligned merged cells. The specifier for vertical alignment of sparsified LaTeX multirows. [default: c] [currently: c] The encoding used for output HTML and LaTeX files. The maximum number of columns that will be rendered. May still be reduced to [default: None] [currently: None] The maximum number of data-cell (<td>) elements that will be rendered before trimming will occur over columns, rows or both if needed. The maximum number of rows that will be rendered. May still be reduced to [default: None] [currently: None] Determine which output to use in Jupyter Notebook in {\"html\", \"latex\"}. Whether to sparsify the display of hierarchical columns. Setting to False will display each explicit level element in a hierarchical key for each column. Whether to sparsify the display of a hierarchical index. Setting to False will display each explicit level element in a hierarchical key for each row."
    },
    {
        "link": "https://stackoverflow.com/questions/24685012/pandas-dataframe-renaming-multiple-identically-named-columns",
        "document": "Thank you @Lamakaha for the solution. Your idea gave me a chance to modify it and make it workable in all the cases.\n\nI tried your piece of code on my data set which had only one duplicated column i.e. two columns with same name. Unfortunately, the column names remained As-Is without being renamed. On top of that I got a warning that is deprecated and same will be removed in future version\". I used coupled with in place of which did not yield the expected result.\n\nI have modified your piece of code little bit which is working for me now for my data set as well as in other general cases as well.\n\nHere are the code runs with and without code modification on the example data set mentioned in the question along with results:\n\nTwo of the three \"blah\"(s) are not renamed properly.\n\nHere is a run of modified code on some another example:\n\nHope this helps anybody who is seeking answer to the aforementioned question."
    },
    {
        "link": "https://stackoverflow.com/questions/77536875/issue-setting-entire-column-and-changing-dtype-with-loc-col-in-pandas-1",
        "document": "I often use to reassign columns rather than . This was a recommended practice to avoid the fact that, prior to Copy-on-Write changes in pandas 2.0, we couldn't guarantee whether a view of copy was returned in various cases, and using can sometimes lead to accidental chained assignments and the infamous SettingWithCopyWarning [example].\n\nHowever, since the changes to inplace operation when setting with .loc and .iloc were implemented in pandas 1.5.0, I've had inconsistent behaviors using where the code will execute without any warnings or errors, but the column type is not modified as expected when trying to cast a column to a different datatype.\n\nFor example, I have a dataframe weather_df, which reads in the 'year' column with a dtype of 'float64' (there are missing values that default to NaN).\n\nI want to fill missing values with 0, and cast the column dtype to 'int32' instead.\n\nThe following code executes silently, and replaces the NaN values with 0, but does not modify the type (weather_df['year].dtype remains float64) for pandas 1.5+:\n\nFrustratingly, the following code does modify the datatype of the weather_df 'year' column values in pandas 1.5+, despite previously being not recommended practice:\n\nBefore the recent changes (1.-1.4), both of these lines made equivalent updates to weather_df. My understanding from the documentation was that both of these lines should continue to work since I am setting the entire column. It should try to do the operation in place first, then fall back to casting when the in-place operation fails due to mismatching types (only because I am replacing the entire column), but that is not happening for .\n\nThe following simplified example reproduces the problem for me...\n\nIs this the intended behavior from now on, or is this a bug? Is there a workaround to use and get the old behavior, or should I just forget the old advice about using to avoid chained assignments?\n\nEdit: I am running this on Linux x86_64 using Python version 3.8.3, and the error occurs for any version 1.5.0 to 2.0.3 (latest). I've also clarified that fillna seems to work in both cases, but the typecast does not work using .\n\nSecond edit: I have further clarified that this is not a post about the SettingWithCopyWarning. No warnings are raised by the example code. It's just that pandas 1.5+ causes the behavior of the two lines to diverge (because no longer changes the dtype of 'col2', as was the case before pandas version 1.5. With pandas version 1.something to 1.4, the second print statement of the example code will change to 'int32'. This could cause bugs (as it did for me) for anyone updating pandas from an older version."
    },
    {
        "link": "https://note.nkmk.me/en/python-pandas-dataframe-rename",
        "document": "You can rename (change) column and/or index names in a by using the , , , methods or by directly updating the and/or attributes.\n\nSimilarly, you can rename index names of a .\n\nThe method, which sets an existing column as the index, is also available. For more information, see the following article:\n• pandas: Assign existing column to the DataFrame index with set_index()\n\nThe sample code in this article uses pandas version . The following is used as an example.\n\nYou can use the method of to change the column/index names individually.\n\nSpecify the original and new names in a like for the and/or arguments of the method.\n\nThe argument is used for changing column names, and the argument is used for changing index names. If you want to change either, you should specify only one of or .\n\nA new is returned while the original remains unchanged.\n\nAlternatively, you can use the first argument and the argument to determine whether to target row or column names. If is set to or , it targets the row names; if it is set to or , it targets the column names. With this approach, you cannot change both row and column names simultaneously.\n\nYou can change multiple column/index names at once by adding elements to .\n\nBy default, the original is not changed, and a new is returned.\n\nSetting the argument to changes the original . In this case, no new is returned, and the return value is .\n\nYou can also specify functions (callable objects) in the and arguments of the method.\n\nFor example, you can apply functions to convert strings to either upper or lower case:\n• Uppercase and lowercase strings in Python (conversion and checking)\n\nYou can also apply lambda expressions.\n\nThe and methods add prefixes and suffixes to column names.\n\nThese methods add the specified string in the argument to either the beginning or the end of column names.\n\nIn version , the argument was added. If set to or , it targets the row names. If set to or , it targets the column names. If omitted, it defaults to targeting the column names, as demonstrated in the previous example.\n\nNote that in versions prior to , and could only rename . To add prefixes or suffixes to the , you could use the method with a lambda expression in the argument, as described above.\n\nAdditionally, and do not have the argument. If you want to update the original object, overwrite it like .\n\nTo change all names, use the method or directly update the / attributes.\n\nYou can change all column/index names using the method of .\n\nSpecify new column/index names for the first argument as a list-like object, such as a or .\n\nSet the argument to or to update , and to or to update . If omitted, the is updated by default.\n\nNote that an error is raised if the size (number of elements) of the specified list does not match the number of rows or columns.\n\nBy default, the original remains unchanged, and a new is returned. The argument was deprecated in version . If you want to update the original , the release notes recommend overwriting it by setting the argument to .\n\nYou can also directly update the and attributes of .\n\nYou can assign lists and tuples to the and attributes.\n\nNote that an error is raised if the size (number of elements) of the list does not match the number of rows or columns.\n\nYou can change the index name ( ) of a using methods similar to those used for a , as shown in the previous examples.\n\nFor example, create a as follows:"
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5.0/user_guide/basics.html",
        "document": "Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let’s create some example objects like we did in the 10 minutes to pandas section:\n\npandas objects have a number of attributes enabling you to access the metadata\n• None shape: gives the axis dimensions of the object, consistent with ndarray Note, these attributes can be safely assigned to! pandas objects ( , , ) can be thought of as containers for arrays, which hold the actual data and do the actual computation. For many types, the underlying array is a . However, pandas and 3rd party libraries may extend NumPy’s type system to add support for custom arrays (see dtypes). To get the actual data inside a or , use the property will always be an . The exact details of what an is and why pandas uses them are a bit beyond the scope of this introduction. See dtypes for more. If you know you need a NumPy array, use or . When the Series or Index is backed by an , may involve copying data and coercing values. See dtypes for more. gives some control over the of the resulting . For example, consider datetimes with timezones. NumPy doesn’t have a dtype to represent timezone-aware datetimes, so there are two possibly useful representations:\n• None An object-dtype with objects, each with the correct\n• None A -dtype , where the values have been converted to UTC and the timezone discarded Timezones may be preserved with Or thrown away with Getting the “raw data” inside a is possibly a bit more complex. When your only has a single data type for all the columns, will return the underlying data: If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame’s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to. When working with heterogeneous data, the dtype of the resulting ndarray will be chosen to accommodate all of the data involved. For example, if strings are involved, the result will be of object dtype. If there are only floats and integers, the resulting array will be of float dtype. In the past, pandas recommended or for extracting the data from a Series or DataFrame. You’ll still find references to these in old code bases and online. Going forward, we recommend avoiding and using or . has the following drawbacks:\n• None When your Series contains an extension type, it’s unclear whether returns a NumPy array or the extension array. will always return an , and will never copy data. will always return a NumPy array, potentially at the cost of copying / coercing values.\n• None When your DataFrame contains a mixture of data types, may involve copying data and coercing values to a common dtype, a relatively expensive operation. , being a method, makes it clearer that the returned NumPy array may not be a view on the same data in the DataFrame.\n\nWith binary operations between pandas data structures, there are two key points of interest: We will demonstrate how to manage these issues independently, though they can be handled simultaneously. DataFrame has the methods , , , and related functions , , … for carrying out binary operations. For broadcasting behavior, Series input is of primary interest. Using these functions, you can use to either match on the index or columns via the axis keyword: Furthermore you can align a level of a MultiIndexed DataFrame with a Series. Series and Index also support the builtin. This function takes the floor division and modulo operation at the same time returning a two-tuple of the same type as the left hand side. For example: We can also do elementwise : In Series and DataFrame, the arithmetic functions have the option of inputting a fill_value, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using if you wish). Series and DataFrame have the binary comparison methods , , , , , and whose behavior is analogous to the binary arithmetic operations described above: These operations produce a pandas object of the same type as the left-hand-side input that is of dtype . These objects can be used in indexing operations, see the section on Boolean indexing. You can apply the reductions: , , , and to provide a way to summarize a boolean result. You can reduce to a final boolean value. You can test if a pandas object is empty, via the property. To evaluate single-element pandas objects in a boolean context, use the method : You might be tempted to do the following: These will both raise errors, as you are trying to compare multiple values.: See gotchas for a more detailed discussion. Often you may find that there is more than one way to compute the same result. As a simple example, consider and . To test that these two computations produce the same result, given the tools shown above, you might imagine using . But in fact, this expression is False: Notice that the boolean DataFrame contains some False values! This is because NaNs do not compare as equals: So, NDFrames (such as Series and DataFrames) have an method for testing equality, with NaNs in corresponding locations treated as equal. Note that the Series or DataFrame index needs to be in the same order for equality to be True: You can conveniently perform element-wise comparisons when comparing a pandas data structure with a scalar value: pandas also handles element-wise comparisons between different array-like objects of the same length: Trying to compare or objects of different lengths will raise a ValueError: Note that this is different from the NumPy behavior where a comparison can be broadcast: or it can return False if broadcasting can not be done: A problem occasionally arising is the combination of two similar data sets where values in one are preferred over the other. An example would be two data series representing a particular economic indicator where one is considered to be of “higher quality”. However, the lower quality series might extend further back in history or have more complete data coverage. As such, we would like to combine two DataFrame objects where missing values in one DataFrame are conditionally filled with like-labeled values from the other DataFrame. The function implementing this operation is , which we illustrate: The method above calls the more general . This method takes another DataFrame and a combiner function, aligns the input DataFrame and then passes the combiner function pairs of Series (i.e., columns whose names are the same). So, for instance, to reproduce as above:\n\nThere exists a large number of methods for computing descriptive statistics and other related operations on Series, DataFrame. Most of these are aggregations (hence producing a lower-dimensional result) like , , and , but some of them, like and , produce an object of the same size. Generally speaking, these methods take an axis argument, just like ndarray.{sum, std, …}, but the axis can be specified by name or integer: All such methods have a option signaling whether to exclude missing data ( by default): Combined with the broadcasting / arithmetic behavior, one can describe various statistical procedures, like standardization (rendering data zero mean and standard deviation of 1), very concisely: Note that methods like and preserve the location of values. This is somewhat different from and since behavior is furthermore dictated by a parameter. Here is a quick reference summary table of common functions. Each also takes an optional parameter which applies only if the object has a hierarchical index. Standard error of the mean Note that by chance some NumPy methods, like , , and , will exclude NAs on Series input by default: will return the number of unique non-NA values in a Series: There is a convenient function which computes a variety of summary statistics about a Series or the columns of a DataFrame (excluding NAs of course): You can select specific percentiles to include in the output: By default, the median is always included. For a non-numerical Series object, will give a simple summary of the number of unique values and most frequently occurring values: Note that on a mixed-type DataFrame object, will restrict the summary to include only numerical columns or, if none are, only categorical columns: This behavior can be controlled by providing a list of types as / arguments. The special value can also be used: That feature relies on select_dtypes. Refer to there for details about accepted inputs. The and functions on Series and DataFrame compute the index labels with the minimum and maximum corresponding values: When there are multiple rows (or columns) matching the minimum or maximum value, and return the first matching index: and are called and in NumPy. The Series method and top-level function computes a histogram of a 1D array of values. It can also be used as a function on regular arrays: The method can be used to count combinations across multiple columns. By default all columns are used but a subset can be selected using the argument. Similarly, you can get the most frequently occurring value(s), i.e. the mode, of the values in a Series or DataFrame: Continuous values can be discretized using the (bins based on values) and (bins based on sample quantiles) functions: computes sample quantiles. For example, we could slice up some normally distributed data into equal-size quartiles like so: We can also pass infinite values to define the bins:\n\nTo apply your own or another library’s functions to pandas objects, you should be aware of the three methods below. The appropriate method to use depends on whether your function expects to operate on an entire or , row- or column-wise, or elementwise. and can be passed into functions. However, if the function needs to be called in a chain, consider using the method. and are functions taking and returning . Now compare the following: pandas encourages the second style, which is known as method chaining. makes it easy to use your own or another library’s functions in method chains, alongside pandas’ methods. In the example above, the functions and each expected a as the first positional argument. What if the function you wish to apply takes its data as, say, the second argument? In this case, provide with a tuple of . will route the to the argument specified in the tuple. For example, we can fit a regression using statsmodels. Their API expects a formula first and a as the second argument, . We pass in the function, keyword pair to : The pipe method is inspired by unix pipes and more recently dplyr and magrittr, which have introduced the popular (read pipe) operator for R. The implementation of here is quite clean and feels right at home in Python. We encourage you to view the source code of . Arbitrary functions can be applied along the axes of a DataFrame using the method, which, like the descriptive statistics methods, takes an optional argument: The method will also dispatch on a string method name. The return type of the function passed to affects the type of the final output from for the default behaviour:\n• None If the applied function returns a , the final output is a . The columns match the index of the returned by the applied function.\n• None If the applied function returns any other type, the final output is a . This default behaviour can be overridden using the , which accepts three options: , , and . These will determine how list-likes return values expand (or not) to a . combined with some cleverness can be used to answer many questions about a data set. For example, suppose we wanted to extract the date where the maximum value for each column occurred: You may also pass additional arguments and keyword arguments to the method. For instance, consider the following function you would like to apply: You may then apply this function as follows: Another useful feature is the ability to pass Series methods to carry out some Series operation on each column or row: Finally, takes an argument which is False by default, which converts each row or column into a Series before applying the function. When set to True, the passed function will instead receive an ndarray object, which has positive performance implications if you do not need the indexing functionality. The aggregation API allows one to express possibly multiple aggregation operations in a single concise way. This API is similar across pandas objects, see groupby API, the window API, and the resample API. The entry point for aggregation is , or the alias . We will use a similar starting frame from above: Using a single function is equivalent to . You can also pass named methods as strings. These will return a of the aggregated output: # these are equivalent to a ``.sum()`` because we are aggregating Single aggregations on a this will return a scalar value: You can pass multiple aggregation arguments as a list. The results of each of the passed functions will be a row in the resulting . These are naturally named from the aggregation function. On a , multiple functions return a , indexed by the function names: Passing a named function will yield that name for the row: Passing a dictionary of column names to a scalar or a list of scalars, to allows you to customize which functions are applied to which columns. Note that the results are not in any particular order, you can use an instead to guarantee ordering. Passing a list-like will generate a output. You will get a matrix-like output of all of the aggregators. The output will consist of all unique functions. Those that are not noted for a particular column will be : Deprecated since version 1.4.0: Attempting to determine which columns cannot be aggregated and silently dropping them from the results is deprecated and will be removed in a future version. If any porition of the columns or operations provided fail, the call to will raise. When presented with mixed dtypes that cannot aggregate, will only take the valid aggregations. This is similar to how works. With it is possible to easily create a custom describe function, similar to the built in describe function. The method returns an object that is indexed the same (same size) as the original. This API allows you to provide multiple operations at the same time rather than one-by-one. Its API is quite similar to the API. We create a frame similar to the one used in the above sections. Transform the entire frame. allows input functions as: a NumPy function, a string function name or a user defined function. Here received a single function; this is equivalent to a ufunc application. Passing a single function to with a will yield a single in return. Passing multiple functions will yield a column MultiIndexed DataFrame. The first level will be the original frame column names; the second level will be the names of the transforming functions. Passing multiple functions to a Series will yield a DataFrame. The resulting column names will be the transforming functions. Passing a dict of functions will allow selective transforming per column. Passing a dict of lists will generate a MultiIndexed DataFrame with these selective transforms. Since not all functions can be vectorized (accept NumPy arrays and return another array or value), the methods on DataFrame and analogously on Series accept any Python function taking a single value and returning a single value. For example: has an additional feature; it can be used to easily “link” or “map” values defined by a secondary series. This is closely related to merging/joining functionality:\n\nis the fundamental data alignment method in pandas. It is used to implement nearly all other features relying on label-alignment functionality. To reindex means to conform the data to match a given set of labels along a particular axis. This accomplishes several things:\n• None Reorders the existing data to match a new set of labels\n• None Inserts missing value (NA) markers in label locations where no data for that label existed\n• None If specified, fill data for missing labels using logic (highly relevant to working with time series data) Here is a simple example: Here, the label was not contained in the Series and hence appears as in the result. With a DataFrame, you can simultaneously reindex the index and columns: You may also use with an keyword: Note that the objects containing the actual axis labels can be shared between objects. So if we have a Series and a DataFrame, the following can be done: This means that the reindexed Series’s index is the same Python object as the DataFrame’s index. also supports an “axis-style” calling convention, where you specify a single argument and the it applies to. MultiIndex / Advanced Indexing is an even more concise way of doing reindexing. When writing performance-sensitive code, there is a good reason to spend some time becoming a reindexing ninja: many operations are faster on pre-aligned data. Adding two unaligned DataFrames internally triggers a reindexing step. For exploratory analysis you will hardly notice the difference (because has been heavily optimized), but when CPU cycles matter sprinkling a few explicit calls here and there can have an impact. Reindexing to align with another object# You may wish to take an object and reindex its axes to be labeled the same as another object. While the syntax for this is straightforward albeit verbose, it is a common enough operation that the method is available to make this simpler: Aligning objects with each other with # The method is the fastest way to simultaneously align two objects. It supports a argument (related to joining and merging):\n• None : take the union of the indexes (default) It returns a tuple with both of the reindexed Series: For DataFrames, the join method will be applied to both the index and the columns by default: You can also pass an option to only align on the specified axis: If you pass a Series to , you can choose to align both objects either on the DataFrame’s index or columns using the argument: takes an optional parameter which is a filling method chosen from the following table: Fill from the nearest index value We illustrate these fill methods on a simple Series: These methods require that the indexes are ordered increasing or decreasing. Note that the same result could have been achieved using fillna (except for ) or interpolate: will raise a ValueError if the index is not monotonically increasing or decreasing. and will not perform any checks on the order of the index. The and arguments provide additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches: In contrast, tolerance specifies the maximum distance between the index and indexer values: Notice that when used on a , or , will coerced into a if possible. This allows you to specify tolerance with appropriate strings. A method closely related to is the function. It removes a set of labels from an axis: Note that the following also works, but is a bit less obvious / clean: The method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function. If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used: If the mapping doesn’t include a column/index label, it isn’t renamed. Note that extra labels in the mapping don’t throw an error. also supports an “axis-style” calling convention, where you specify a single and the to apply that mapping to. The method also provides an named parameter that is by default and copies the underlying data. Pass to rename the data in place. Finally, also accepts a scalar or list-like for altering the attribute. The methods and allow specific names of a to be changed (as opposed to the labels).\n\nThe behavior of basic iteration over pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. DataFrames follow the dict-like convention of iterating over the “keys” of the objects. Thus, for example, iterating over a DataFrame gives you the column names: pandas objects also have the dict-like method to iterate over the (key, value) pairs. To iterate over the rows of a DataFrame, you can use the following methods:\n• None : Iterate over the rows of a DataFrame as (index, Series) pairs. This converts the rows to Series objects, which can change the dtypes and has some performance implications.\n• None : Iterate over the rows of a DataFrame as namedtuples of the values. This is a lot faster than , and is in most cases preferable to use to iterate over the values of a DataFrame. Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:\n• None Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …\n• None When you have a function that cannot work on the full DataFrame/Series at once, it is better to use instead of iterating over the values. See the docs on function application.\n• None If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach. You should never modify something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect! For example, in the following case setting the value has no effect: Consistent with the dict-like interface, iterates through key-value pairs: allows you to iterate through the rows of a DataFrame as Series objects. It returns an iterator yielding each index value along with a Series containing the data in each row: Because returns a Series for each row, it does not preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example, All values in , returned as a Series, are now upcasted to floats, also the original integer value in column : To preserve dtypes while iterating over the rows, it is better to use which returns namedtuples of the values and which is generally much faster than . For instance, a contrived way to transpose the DataFrame would be: The method will return an iterator yielding a namedtuple for each row in the DataFrame. The first element of the tuple will be the row’s corresponding index value, while the remaining values are the row values. This method does not convert the row to a Series object; it merely returns the values inside a namedtuple. Therefore, preserves the data type of the values and is generally faster as . The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (>255), regular tuples are returned.\n\npandas supports three kinds of sorting: sorting by index labels, sorting by column values, and sorting by a combination of both. The and methods are used to sort a pandas object by its index levels. Sorting by index also supports a parameter that takes a callable function to apply to the index being sorted. For objects, the key is applied per-level to the levels specified by . For information on key sorting by value, see value sorting. The method is used to sort a by its values. The method is used to sort a by its column or row values. The optional parameter to may used to specify one or more columns to use to determine the sorted order. The parameter can take a list of column names, e.g.: These methods have special treatment of NA values via the argument: Sorting also supports a parameter that takes a callable function to apply to the values being sorted. will be given the of values and should return a or array of the same shape with the transformed values. For objects, the key is applied per column, so the key should still expect a Series and return a Series, e.g. The name or type of each column can be used to apply different functions to different columns. Strings passed as the parameter to may refer to either columns or index level names. If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version. Series has the method, which works similarly to . has the and methods which return the smallest or largest \\(n\\) values. For a large this can be much faster than sorting the entire Series and calling on the result. also has the and methods. You must be explicit about sorting when the column is a MultiIndex, and fully specify all levels to .\n\nFor the most part, pandas uses NumPy arrays and dtypes for Series or individual columns of a DataFrame. NumPy provides support for , , , and (note that NumPy does not support timezone-aware datetimes). pandas and third-party libraries extend NumPy’s type system in a few places. This section describes the extensions pandas has made internally. See Extension types for how to write your own extension that works with pandas. See Extension data types for a list of third-party libraries that have implemented an extension. The following table lists all of pandas extension types. For methods requiring arguments, strings can be specified as indicated. See the respective documentation sections for more on each type. pandas has two ways to store strings.\n• None dtype, which can hold any Python object, including strings.\n• None , which is dedicated to strings. Generally, we recommend using . See Text data types for more. Finally, arbitrary objects may be stored using the dtype, but should be avoided to the extent possible (for performance and interoperability with other libraries and methods. See object conversion). A convenient attribute for DataFrame returns a Series with the data type of each column. On a object, use the attribute. If a pandas object contains data with multiple dtypes in a single column, the dtype of the column will be chosen to accommodate all of the data types ( is the most general). # these ints are coerced to floats The number of columns of each type in a can be found by calling . Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the keyword, a passed , or a passed ), then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will NOT be combined. The following example will give you a taste. By default integer types are and float types are , regardless of platform (32-bit or 64-bit). The following will all result in dtypes. Note that Numpy will choose platform-dependent types when creating arrays. The following WILL result in on 32-bit platform. Types can potentially be upcasted when combined with other types, meaning they are promoted from the current type (e.g. to ). will return the lower-common-denominator of the dtypes, meaning the dtype that can accommodate ALL of the types in the resulting homogeneous dtyped NumPy array. This can force some upcasting. You can use the method to explicitly convert dtypes from one to another. These will by default return a copy, even if the dtype was unchanged (pass to change this behavior). In addition, they will raise an exception if the astype operation is invalid. Upcasting is always according to the NumPy rules. If two different dtypes are involved in an operation, then the more general one will be used as the result of the operation. Convert a subset of columns to a specified type using . Convert certain columns to a specific dtype by passing a dict to . When trying to convert a subset of columns to a specified type using and , upcasting occurs. tries to fit in what we are assigning to the current dtypes, while will overwrite them taking the dtype from the right hand side. Therefore the following piece of code produces the unintended result. pandas offers various functions to try to force conversion of types from the dtype to other types. In cases where the data is already of the correct type, but stored in an array, the and methods can be used to soft convert to the correct type. Because the data was transposed the original inference stored all columns as object, which will correct. The following functions are available for one dimensional object arrays or scalars to perform hard conversion of objects to a specified type: To force a conversion, we can pass in an argument, which specifies how pandas should deal with elements that cannot be converted to desired dtype or object. By default, , meaning that any errors encountered will be raised during the conversion process. However, if , these errors will be ignored and pandas will convert problematic elements to (for datetime and timedelta) or (for numeric). This might be useful if you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime), but occasionally has non-conforming elements intermixed that you want to represent as missing: The parameter has a third option of , which will simply return the passed in data if it encounters any errors with the conversion to a desired data type: In addition to object conversion, provides another argument , which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory: As these methods apply only to one-dimensional arrays, lists or scalars; they cannot be used directly on multi-dimensional objects such as DataFrames. However, with , we can “apply” the function over each column efficiently: Performing selection operations on type data can easily upcast the data to . The dtype of the input data will be preserved in cases where are not introduced. See also Support for integer NA."
    }
]