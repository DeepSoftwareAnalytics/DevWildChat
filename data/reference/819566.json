[
    {
        "link": "https://docs.python.org/3/library/telnetlib.html",
        "document": "This module is no longer part of the Python standard library. It was removed in Python 3.13 after being deprecated in Python 3.11. The removal was decided in PEP 594.\n\nPossible replacements are third-party libraries from PyPI: telnetlib3 or Exscript. These are not supported or maintained by the Python core team.\n\nThe last version of Python that provided the module was Python 3.12."
    },
    {
        "link": "https://docs.python.org/3.12/library/telnetlib.html",
        "document": "The module provides a class that implements the Telnet protocol. See RFC 854 for details about the protocol. In addition, it provides symbolic constants for the protocol characters (see below), and for the telnet options. The symbolic names of the telnet options follow the definitions in , with the leading removed. For symbolic names of options which are traditionally not included in , see the module source itself.\n\nThe symbolic constants for the telnet commands are: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).\n\nrepresents a connection to a Telnet server. The instance is initially not connected by default; the method must be used to establish a connection. Alternatively, the host name and optional port number can be passed to the constructor too, in which case the connection to the server will be established before the constructor returns. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). Do not reopen an already connected instance. This class has many methods. Note that some of them raise when the end of the connection is read, because they can return an empty string for other reasons. See the individual descriptions below. A object is a context manager and can be used in a statement. When the block ends, the method is called:\n\ninstances have the following methods: Read until a given byte string, expected, is encountered or until timeout seconds have passed. When no match is found, return whatever is available instead, possibly empty bytes. Raise if the connection is closed and no cooked data is available. Read all data until EOF as bytes; block until connection closed. Read at least one byte of cooked data unless EOF is hit. Return if EOF is hit. Block if no data is immediately available. Read everything that can be without blocking in I/O (eager). Raise if connection closed and no cooked data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Raise if connection closed and no cooked data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Process and return data already in the queues (lazy). Raise if connection closed and no data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Return any data available in the cooked queue (very lazy). Raise if connection closed and no data available. Return if no cooked data available otherwise. This method never blocks. Return the data collected between a SB/SE pair (suboption begin/end). The callback should access these data when it was invoked with a command. This method never blocks. Connect to a host. The optional second argument is the port number, which defaults to the standard Telnet port (23). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). Do not try to reopen an already connected instance. Print a debug message when the debug level is 0. If extra arguments are present, they are substituted in the message using the standard string formatting operator. Set the debug level. The higher the value of debuglevel, the more debug output you get (on ). Return the file descriptor of the socket object used internally. Write a byte string to the socket, doubling any IAC characters. This can block if the connection is blocked. May raise if the connection is closed. Changed in version 3.3: This method used to raise , which is now an alias of . Read until one from a list of a regular expressions matches. The first argument is a list of regular expressions, either compiled (regex objects) or uncompiled (byte strings). The optional second argument is a timeout, in seconds; the default is to block indefinitely. Return a tuple of three items: the index in the list of the first regular expression that matches; the match object returned; and the bytes read up till and including the match. If end of file is found and no bytes were read, raise . Otherwise, when nothing matches, return where data is the bytes received so far (may be empty bytes if a timeout happened). If a regular expression ends with a greedy match (such as ) or if more than one expression can match the same input, the results are non-deterministic, and may depend on the I/O timing. Each time a telnet option is read on the input flow, this callback (if set) is called with the following parameters: callback(telnet socket, command (DO/DONT/WILL/WONT), option). No other action is done afterwards by telnetlib."
    },
    {
        "link": "https://docs.python.org/3.10/library/telnetlib.html",
        "document": "The module provides a class that implements the Telnet protocol. See RFC 854 for details about the protocol. In addition, it provides symbolic constants for the protocol characters (see below), and for the telnet options. The symbolic names of the telnet options follow the definitions in , with the leading removed. For symbolic names of options which are traditionally not included in , see the module source itself.\n\nThe symbolic constants for the telnet commands are: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).\n\nrepresents a connection to a Telnet server. The instance is initially not connected by default; the method must be used to establish a connection. Alternatively, the host name and optional port number can be passed to the constructor too, in which case the connection to the server will be established before the constructor returns. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). This class has many methods. Note that some of them raise when the end of the connection is read, because they can return an empty string for other reasons. See the individual descriptions below. A object is a context manager and can be used in a statement. When the block ends, the method is called:\n\nRead until a given byte string, expected, is encountered or until timeout seconds have passed. When no match is found, return whatever is available instead, possibly empty bytes. Raise if the connection is closed and no cooked data is available. Read at least one byte of cooked data unless EOF is hit. Return if EOF is hit. Block if no data is immediately available. Read everything that can be without blocking in I/O (eager). Raise if connection closed and no cooked data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Raise if connection closed and no cooked data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Process and return data already in the queues (lazy). Raise if connection closed and no data available. Return if no cooked data available otherwise. Do not block unless in the midst of an IAC sequence. Raise if connection closed and no data available. Return if no cooked data available otherwise. This method never blocks. Return the data collected between a SB/SE pair (suboption begin/end). The callback should access these data when it was invoked with a command. This method never blocks. Connect to a host. The optional second argument is the port number, which defaults to the standard Telnet port (23). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). Do not try to reopen an already connected instance. Print a debug message when the debug level is 0. If extra arguments are present, they are substituted in the message using the standard string formatting operator. Set the debug level. The higher the value of debuglevel, the more debug output you get (on ). Return the file descriptor of the socket object used internally. Write a byte string to the socket, doubling any IAC characters. This can block if the connection is blocked. May raise if the connection is closed. Changed in version 3.3: This method used to raise , which is now an alias of . Read until one from a list of a regular expressions matches. The first argument is a list of regular expressions, either compiled (regex objects) or uncompiled (byte strings). The optional second argument is a timeout, in seconds; the default is to block indefinitely. Return a tuple of three items: the index in the list of the first regular expression that matches; the match object returned; and the bytes read up till and including the match. If end of file is found and no bytes were read, raise . Otherwise, when nothing matches, return where data is the bytes received so far (may be empty bytes if a timeout happened). If a regular expression ends with a greedy match (such as ) or if more than one expression can match the same input, the results are non-deterministic, and may depend on the I/O timing. Each time a telnet option is read on the input flow, this callback (if set) is called with the following parameters: callback(telnet socket, command (DO/DONT/WILL/WONT), option). No other action is done afterwards by telnetlib."
    },
    {
        "link": "https://telnetlib3.readthedocs.io",
        "document": ""
    },
    {
        "link": "https://github.com/certik/python-2.7/blob/master/Lib/telnetlib.py",
        "document": ""
    },
    {
        "link": "https://linode.com/docs/guides/use-paramiko-python-to-ssh-into-a-server",
        "document": "This credit will be applied to any valid services used during your first days.\n\nWhen your Python program needs to run an external password-dependent program, or access a remote server, use Paramiko. Paramiko is a Python module that implements the SSHv2 protocol. Paramiko is not part of Python’s standard library, although it’s widely used. This guide shows you how to use Paramiko in your Python scripts to authenticate to a server using a password and SSH keys.\n• None If you have not already done so, create a Linode account and Compute Instance. See our Getting Started with Linode and Creating a Compute Instance guides.\n• None Follow our Setting Up and Securing a Compute Instance guide to update your system. You may also wish to set the timezone, configure your hostname, create a limited user account, and harden SSH access.\n\nYou must install Paramiko on your system before being able to use it in your Python programs. Use the command below to install Paramiko with Pip:\n\nIf your system is configured to use Anaconda, you can use the following command to install Paramiko:\n\nA Paramiko SSH Example: Connect to Your Server Using a Password\n\nThis section shows you how to authenticate to a remote server with a username and password. To begin, create a new file named and add the contents of the example file. Ensure that you update the file with your own Linode’s details. Replace the values for , , and . Use the Find Your Linode’s IP Address guide, if needed.\n\nThis file connects to remote server over SSH using the IP address and credentials that you provide. It then uses the command to generate a report of your server’s free disk space.\n\nExecute the file with the following command:\n\nThe file above provides a high-level example that you can use to incorporate Paramiko into your Python code. While everything Paramiko does can also be done with shell commands, Paramiko gives you all the power of Python. Python gives you access to structuring data, looping, parsing, and other powerful features that go beyond what is available in shell scripting. For example, if you are writing a program to calculate system usage percentages, Python is better at extracting and calculating values from your system’s output.\n\nSecond Paramiko Example: Connect to your Server Using SSH Keys\n\nOne of Paramiko’s specific strengths is the correct handling of SSH add keys. The introductory example above depended on the use of your limited user account’s password. It is more secure, however, to use SSH keys for server authentication. The example file below, provides a report that alerts you of any logins by users that are not included in your list of users. The Python script relies on Paramiko (notice the function) to use SSHv2 authentication to connect to any of the servers provided in the code’s list.\n\nExecute the file with the following command:\n\nIf a user outside of the Python script’s list accesses one of your servers, the Python script returns the following:\n\nGoing Further with Paramiko\n\nParamiko helps you automate repetitive system administration tasks on remote servers. More advanced Paramiko programs send the lines of a script one at a time. It does this rather than transacting all of a command, such as or , synchronously to completion. Paramiko is a helpful addition to your system administrator toolchain when working to automate common tasks. You can visit Paramiko’s documentation to learn about its special-purpose methods and variables that go beyond the examples covered in this guide.\n\nYou may wish to consult the following resources for additional information on this topic. While these are provided in the hope that they will be useful, please note that we cannot vouch for the accuracy or timeliness of externally hosted materials."
    },
    {
        "link": "https://medium.com/featurepreneur/ssh-in-python-using-paramiko-e08fd8a039f7",
        "document": "Paramiko is a pure-Python implementation of the SSHv2 protocol, providing both client and server functionality. It provides the foundation for the high-level SSH library Fabric, which is recommended to use for common client use-cases such as running remote shell commands or transferring files. Direct use of Paramiko itself is only intended for users who need advanced/low-level primitives or want to run an in-Python sshd.\n\nThe primary client of Paramiko as documented in the API is Paramiko.SSHClient. An instance of the Paramiko.SSHClient can be used to make connections to the remote server and transfer files.\n\nAs a client, you can authenticate yourself using a password or key and as a server, you can decide which users are allowed access and the channels you allow.\n\nRun the following command in the terminal to install the paramiko library:\n\nwe use “set_missing_host_key_policy()” to let know Paramiko that you validate your trust with the machine for the first time you try to connect to the server. Parsing an instance of the AutoAddPolicy to set_missing_host_key_policy() changes it to allow any host.\n\nwe use the auth_interactive method which accepts a handler for passing the values to the prompt. The custom handler that we write has the logic to pass the OTP or Password etc.. based on the output in the prompt. If we want to get the input to the handler from stdin instead then we can use the auth_interactive_dumb method.\n\n**NOTE: Storing your credentials in your scripts is not secure and, you should never do this, we can set them as environment variables or use `.env` file and load it into the Python script but, even storing sensitive information in a plain text file is not very secure. The better and more secure way is to store these data in an encrypted store, like Hashicorp Vault, Keywhiz, etc…"
    },
    {
        "link": "https://stackoverflow.com/questions/10745138/python-paramiko-ssh",
        "document": "i'm new on python. i wrote a script to connect to a host and execute one command\n\nworks fine when then remote command doesn't need a tty. i found an invoke_shell example Nested SSH session with Paramiko. i'm not happy with this solution, because if a server has an prompt that isn't specified in my script -> infinite loop or a specified prompt in the script is a string in the return text -> not all data will be received. is there a better solution maybe where stdout and stderr are send back like in my script?"
    },
    {
        "link": "https://networklessons.com/python/python-ssh",
        "document": "There are multiple options to use SSH in Python but Paramiko is the most popular one. Paramiko is an SSHv2 protocol library for Python. In this lesson, I’ll show you how to use Paramiko to connect to a Cisco IOS router, run a show command, and return the output to us.\n\n\n\nHere is the topology:\n\nI’ll use a Cisco IOS router running IOS Version 15.7(3)M3 and I’ll run the Python code from my computer.\n\nOn the router, we need to enable SSH:\n\nI configured an “admin” user with privilege level 15 so that we have full access to the router once we log in.\n\nWe need to install Paramiko, which is easy with PIP:\n\nWe are now ready to try some code.\n\nIn our first example, here’s what we try to accomplish:\n• Connect to the router with username/password authentication.\n• Look for the default route in the output and show it to us.\n\nHere is my code:\n\nWhen we run this code, here’s what we get:\n\nThis is nice. We managed to connect to the router, run the command, and look for the default route.\n\nHow could we improve this script with some of the things we learned? For example:\n• Our code runs a single command. How about we use a function so we can use our code to connect to different devices and run different commands?\n• What if our SSH connection fails? It would be nice to deal with this with a try/except block. How about we try to attempt to connect multiple times?\n\nLet’s see what we can do. Here is my improved code:\n• I created a function to contain the code used to connect to the router.\n• I added a block for the connection with multiple attempts. When the connection fails, it shows the reason.\n• An extra check to see if the router output contains any information.\n\nLet’s run our code again to see if it works.\n\nWhen you supply a wrong password, you get this output:\n\nThis looks good. Our code attempted to connect three times and showed the reason why it was unable to connect.\n\nWhen your host is unavailable, you get this output:\n\nOnce again, three attempts to connect and it shows the reason why our script failed.\n\nYou have now learned how you can connect to a device using SSH and Python. Although this works, it might not be the best solution. In this example, I ran the command and looked for the default route. This is simple, but what if you want to parse show commands that have a lot of information?\n\nIt’s possible to parse the output of show commands like this using regular expressions but it’s a pain. Instead, if possible, it’s better to use a REST API where the device returns the output in JSON format. Parsing JSON in Python is much easier.\n\nI hope you enjoyed this lesson. If you have any questions feel free to leave a comment!"
    },
    {
        "link": "https://codilime.com/blog/python-paramiko-and-netmiko-for-automation",
        "document": "Python, with its simplicity and versatility, has emerged as a powerful programming language for infrastructure automation. It is the best option for engineers and administrators to start programming and automate their work. With many useful libraries, Python allows you to quickly implement an infrastructure management strategy tailored to your situation.\n\nThis article is an introduction to Paramiko and Netmiko, which are the most popular Python SSH libraries. It should be valuable to both administrators and developers who want to start their automation journey and become aware of the differences between server host automation and network device automation.\n\nIn agentless automation, automation tasks are performed on remote systems without software agents installed on those systems. Unlike agent-based automation implemented with tools such as Puppet or Chef, agentless automation relies on remote management protocols such as SSH or WinRM to execute commands remotely. Agentless automation is easier to implement because it reuses existing management protocols. It also has lower administrative costs since one, or at most several, central automation agents need to be deployed and managed.\n\nThe most popular tool used to establish agentless automation is SSH (Secure Shell). SSH is a protocol for secure system administration, file transfers, and other communication across the Internet or other untrusted networks. It encrypts identities, passwords and transmitted data to prevent eavesdropping and theft. SSH is widely used because it provides security using various authentication and encryption methods and is standardized. Thanks to many existing implementations, including open source, SSH is in widespread use. SSH is used to configure services and retrieve configuration settings and state parameters. It is one of the key components of higher-level automation tools such as Ansible, Napalm, and Nornir.\n\nParamiko is a handy LGPL-licensed library that implements the SSHv2 protocol. It is written in pure Python, so it can be easily installed and used to connect to any system that provides an SSH service. For these reasons, it has become a first choice if someone wants to play with agentless automation. However, simplicity of use is not everything. Its functionality and implementation are modeled on OpenSSH, the most commonly used SSH protocol implementation. This origin makes Paramiko versatile and very useful in more complex scenarios.\n\nThat is possible because it provides full implementation of all internal SSH components, i.e.: transport layer (RFC4252 ), user authentication (RFC4253 ) and connection protocols (RFC4254 ). Additionally, it implements Secure File Transfer Protocol (SFTP) over SSH channels, which can be used to manage remote files and transfer them in both directions.\n\nLet's skip the details of Paramiko’s low-level SSH components and focus on the fact that Paramiko provides a high-level API that simplifies the creation of SSH clients, servers or port forwarders. We can check the use of Paramiko in a simple scenario. We would like to connect to a Linux host and fetch all network interfaces. The use of Paramiko.SSHClient is shown in Listing 1.\n\nListing. 1 Example implementation of SSH client using Paramiko\n\nLooking at the code, we can see that once the SSHClient instance is created, a policy is established to warn about unknown host keys. WarningPolicy allows you to seamlessly connect to any new host, while RejectPolicy should be used in production environments. Later, a private ECDSA key is loaded to connect to the host machine (Paramiko can also use RSA, DSA or Ed25519 keys). Finally, a connection to the server is established and the required Linux command is remotely executed on the host. The command result is read from the standard output and decoded as UTF-8. Unfortunately, this is only a raw string of characters, so additional operations must be performed to parse it; e.g. the IP addresses of the interfaces. Extracting the required information from command results is beyond the scope of the Paramiko library.\n\nThe Paramiko usage example in the previous section uses the SSHClient.exec_command method. This method creates an SSH EXEC channel. An EXEC channel accepts a single command or a set of commands, but does so only at the time the channel is created. The SSH server executes the commands received from the channel and returns all generated output when execution is complete.\n\nLinux SSH servers execute commands from the EXEC channel mainly in non-interactive and non-login shells. It is important to know what environment a command is being executed in as it can have a significant impact on the behavior of commands, especially those that are parameterized by environment variables. This may happen because some startup scripts (e.g. ~/.bash_profile) may not execute and environment variables may be set differently. By default, the EXEC channel doesn’t use terminal emulation to avoid commands to do fancy things like adjusting output to terminal width and height, pagination, and coloring. In summary, the EXEC channel is ideal for automating simple commands for which you can collect output.\n\nWhen an interactive application needs to be automated, a different type of SSH channel is required. The recommended channel type is SSH SHELL. Thanks to the SHELL channel, additional input data can be provided to the application, such as additional \"yes/no\" confirmations, option selections or set values. This channel continuously puts command results into the standard output stream. Linux SSH servers execute commands from the SHELL channel mainly in interactive and login shells. This is the same environment where you log in manually using an SSH terminal client.\n\nIn Paramiko, the output of the SHELL channel is exposed in the form of stdin and stderr streams, which require more complex handling, similar to the use of network sockets. All command output becomes unstructured in the output stream, and the automation code must recognize different parts of the results. The time aspects of communication, such as the waiting time for specific information, should also be properly determined.\n\nWhy isn’t Paramiko enough for network automation?\n\nMost Linux and BSD systems use OpenSSH as their implementation of the SSH protocol. This implementation runs as a daemon called sshd. Compared to servers, network devices have their own SSH server implementation quirks which causes important differences when establishing a connection. An example of such a dissimilarity is how the user is authenticated. In the case of hosts, mechanisms built into the SSH protocol are always used for this purpose. However, in the case of network devices, there are cases where user authentication takes place in a separate application launched immediately after establishing an SSH session.\n\nThe second significant difference between network devices and hosts is the use of specialized CLI shells that allow easy navigation through a large number of available commands. Network equipment manufacturers treat shells as their intellectual property and trademark, and carefully cultivate differences in the behavior of their shells. This causes shells from different manufacturers to behave differently and have different command hierarchies. Therefore, implementing automation for network devices using Paramiko itself is much more complicated than it might initially seem. A few years ago, the user support for Paramiko (aka GitHub issues) was full of problems with people trying to connect to various network devices or execute specific commands. Currently, such unfortunate people are quickly redirected to another library: Netmiko.\n\nCheck out our other related content:\n\nNetmiko is an open-source, Python MIT-licensed library designed to interact with a wide range of network devices (Cisco, Juniper, Arista, Huawei, and many others ). It hides low-level differences between different vendors and provides a high-level API that exposes common behaviors of many web CLI shells (e.g. the existence of operational/configuration modes) in a consistent way.\n\nNetmiko uses several communication technologies that enable the automation of network devices. The most important of these is SSH, which is supported on Netmiko using Paramiko. SCP is available through the scp library (it is also implemented on top of Paramiko). Netmiko also supports telnet (using telnetlib ) and serial (using pyserial ). Additionally, SNMP (pysnmp ) is used, but only for automatic device type detection, which helps select the appropriate device driver.\n\nLet's demonstrate using Netmiko to connect to a Cisco IOS router to obtain the IP addresses of all interfaces. Please refer to Listing. 2 below.\n\nListing. 2 Example implementation of SSH client using Paramiko\n\nThis example uses the netmiko.ConnectHandler factory function. ConnectHandler requires device type information and other access arguments. Using these arguments, ConnectHandler creates a dedicated SSH client for the Cisco IOS router. The appropriate Cisco command is then sent. The use_textfsm argument is set so that send_command returns fully parsed interface information using NTC templates (this is a large collection of TestFSM templates for parsing network device text output). Since the returned output of the command is a list of Python dictionaries describing the attributes of each interface, the user of the Netmiko library can easily filter the required information (i.e. interface IP addresses).\n\nIf the type of network device is not known, the Netmiko library user should first try using the netmiko.ssh_autodetect module. It will most likely provide the correct device type.\n\nA network automation engineer’s work is much easier using Netmiko. The list of the most important Netmiko functionalities is presented in Fig. 5.\n\nThe library includes a long list of dedicated SSH clients for many types of network devices. Each Netmiko client implements the necessary quirks enabling successful login to a specific network platform (i.e. non-standard user authentication methods, additional user confirmations immediately after the login, skipping login banners). After logging in, the library user can easily change CLI mode to privileged and configuration mode. Additionally, each dedicated SSH client includes the expected prompts for a specific mode.\n\nNetmiko also provides a number of features required to successfully execute commands. First, device-specific window size settings are applied to created SSH channels and pagination is disabled, so that structured and multiline commands produce clear results. Secondly, Netmiko supports parsing command output using TestFSM , Genie and TTP libraries. Some network devices copy commands to output, but Netmiko can automatically remove them from the generated output. The library also provides useful commands and their options to handle commands that generate additional questions instead of the expected prompts.\n\nMany network devices experience problems with slowdown periods when responding to commands. For this reason, Netmiko implements a hierarchy of delay factors as well as different command timing strategies. Finally, it provides a convenient method for saving/committing a new configuration.\n\nWhat if performance really matters?\n\nBoth Paramiko and Netmiko are implemented in pure Python, so there are situations where their low performance is problematic. This may be important when building automation systems for hundreds or thousands of nodes. In this case, there are alternative open-source Python SSH libraries that could be a better fit:\n• parallel-ssh - an asynchronous SSH client library under the LGPL license. It is based on ssh2-python (Cython wrapper around C libssh2 ) and gevent .\n• asyncssh - another asynchronous SSH client that is published under the EPL license. It is mostly written in Python using asyncio .\n\nBoth libraries excel when used directly to process hundreds of calls in parallel, as documented here . However, you should be prepared for installation issues and problems in successful connections to many network devices.\n\nHere, you can watch a video that provides practical insights and innovative approaches to tackling complex network firewall upgrades by presenting a real-world case study involving the automation of firewall upgrades:\n\nThis article introduced you to the two most popular Python libraries for the SSH protocol. The first is Paramiko, a solid solution that will help you automate your work on servers. With Paramiko, you can automate both simple applications or scripts as well as programs with more interactive behavior. The second library is Netmiko, which is indispensable when you want to remotely manage network devices. It supports many important behaviors of various network equipment manufacturers and provides parsed command results.\n\nHowever, when performance is a deciding factor, it's worth trying one of the asynchronous SSH implementations such as parallel-ssh or asyncssh."
    }
]