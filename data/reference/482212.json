[
    {
        "link": "https://controllerstech.com/stm32-uart-1-configure-uart-transmit-data",
        "document": "This tutorial is the start of a new series on the UART peripheral of STM32 Microcontrollers. In this series we will cover different ways of transmitting and receiving data over the UART protocol. We will also see different UART modes available in the STM32 microcontrollers and how to use them.\n\nIn this tutorial, we will understand the connection and configuration of different parameters of UART available in the cubeMX. We will also transmit the data over UART and receive it on a serial console in the computer.\n\nUART stands for Universal Asynchronous Receiver Transmitter whereas the USART stands for Universal Synchronous Asynchronous Receiver Transmitter. The term Synchronous enables the USART to send an additional clock signal to the receiving device. The data is then sampled at a predefined edge (Rising or Falling) of the clock. The USART mode uses 3 pins (clock, Tx and Rx) compared to the 2 pins (Tx and Rx) used in the UART.\n\nThe most widely used synchronous communications are I2C, SPI, etc. The USART, in a way, can act as the SPI master to send the data to the slave. The synchronous communication is also used when communicating with a smartcard.\n\nWe will use the UART for the major part of this series as it has wider applications compared to the USART.\n\nWe will use the STM32 MCU to send the data to the computer. Some of the Nucleo and Discovery dev boards from ST supports the virtual com port. This feature enables the USB connected for the ST link to be also used for the data transmission between the MCU and the computer.\n\nThe Virtual Com Port is supported by many Nucleo and Discovery boards but not all. You need to check the schematic of the board to confirm whether the respective board supports it.\n\nBelow are the images from the schematic of the Nucleo F446RE and Discovery F412.\n\nAs you can see in the images above, both Nucleo F446RE and Discovery F412 supports the USB Virtual Com Port. So if you are using either of these boards, you do not need to use an additional module to communicate to the computer. The USB used for the ST link can also be used for the communication.\n\nNot all the boards support this Virtual Com port feature. Below is the image from the schematic of the very famous STM32F4 Discovery board.\n\nAs you can see in the image above, there is no virtual com port in the F4 Discovery board. In such cases we can use some module to convert the UART signals to the USB, which is connected to the computer.\n\nBelow is the image showing the connection between the MCU and the FT232 USB to UART converter.\n\nThe UART is always connected in the cross connection, connecting the TX pin of the MCU to the RX of the device and the RX to the TX of the device. The module then connects to the computer using the USB.\n\nBelow is the image showing the UART configuration in cubeMX.\n\nWe will use the Asynchronous Mode for the communication. Only 2 pins are used in the Asynchronous mode, TX and RX.\n\nThe baud rate is set to 115200. We need to use the same baud rate for the receiver device also.\n\nWord length consists of the data bits and the parity bit. STM32 supports different word lengths of 7 bits, 8 bits and 9 bits. A typical UART frame is shown in the image below.\n\nThe frame consists of a start bit, data bits and stop bits. we are using 8 data bits with no parity bit and 1 stop bit. We need to use the same configuration in the receiver device also. The data direction is set to Receive and Transmit.\n\nThe oversampling is used to increase the tolerance of the receiver to the clock deviation. But it also reduces the maximum baud rate the device can achieve. The image below explains the oversampling and max baud rate.\n\nThis is all the configuration we need to do in the cubeMX. Let’s see the code now.\n\nWe can only send the ascii characters via the UART. Below we will see how to send a simple string and a number, by converting it to the character format.\n\nWe can directly send a string via the UART. The code below sends the string every 1 second.\n\nHere we define an array (data) which contains the string to be sent to the UART. Then call the function HAL_UART_Transmit in the while loop every 1 second.\n\nThe parameters of the function are as follows:\n• @size of the data in bytes, 12\n\nAs I mentioned we can not send the number directly to the UART. It only transmits the data in the ascii format. To send the number, we first need to convert each digit of the number to the character format and then send the data to the UART.\n\nHere we will send the number 123 to the UART. We first need to define an array of size at least the number of digits of the number.\n\nThe sprintf function is used to convert the number to the character format. The format specifier, %d, is used to convert the integral value (123).\n\nAfter conversion the characters are stored in the array, numarray. We send this array to the UART every 1 second.\n\nThe Serial console on the computer should have the same configuration as we did for the STM32 in the cubeMX. The image below shows the configuration with the baud rate of 115200, 8 data bits with 1 stop bit and no parity.\n\nThe data sent by the STM32 is received in the serial console. The image below shows the data, “Hello world”, printed several times. It was sent every 1 second by the MCU.\n\nWe also sent the number to the UART. The image below shows the number output on the console."
    },
    {
        "link": "https://reddit.com/r/embedded/comments/uffhy3/questions_about_freertos_and_uart_on_stm32",
        "document": "Hi, I want to use UART with FreeRTOS to run a Sim800. I wonder if I can use HAL_UART with time out. I think it would change the time management of scheduler so if I am right how I should do it. My other question is How I should read the received data. I used a uint8_t ReadBuffer[100] with a printf(ReadBuffer) but it shows nothing. Also, I tried to read it in memory section in debugging mode but it didn't work! Thank you\n\nEdited: I want to use TCP/IP and connect sim800 to a server. I was wondering if you know a better OS for this job."
    },
    {
        "link": "https://forums.freertos.org/t/example-using-stm32f103-hal-uart-receive-and-transmit/17004",
        "document": "Hi. I’m new to FreeRTOS. Since timing conditions and real time responsitivity were becoming crucial I turned to be using FreeRTOS.\n\n I managed to setup a very rudimentary program for an STM32F103 (blue pill) under STM32CubeIDE. Now I’m seeking for a code example that allows for reading one character from a UART Rx register and write it out to the same UART Tx register. Is there a collection a sample code available somewhere? Thanks in advance.\n\nThe simplest way to do that wouldn’t use FreeRTOS at all, but just an ISR. The demo program provided with FreeRTOS do have code that has the ISR put the receive character into a Queue, and then a task read from the Queue, put it into another Queue and activate a transmit function. Note, all the ISR part of that code will be VERY processor specific.\n\nQueue is exactly what I’m aiming at. Other tasks like reading out ADC data continuously will have to be implemented also. I was fed up with all these delays() and timing constraints. Two UARTs will be acting later in the solution. In a first consideration I thought not to use IRs at all. A task could polll the receive status bit and when there is no character available it just idles. When a character is available, it reads it and puts it in a ringbuffer. Another task looks whether tail != head (overflow conditions have to be processed) and gets the character, processes it and puts it into the Tx register. Tx empty bit must be polled and task could be released, when Tx busy.\n\nNO. Do not have tasks poll and idle loop, that is the way to RTOS madness. The whole concept of an RTOS is that tasks only run when they have work to do, at which point they automatically start (in priority order) and this requires ISR to be doing the work and triggering notifications. The polling method basically just makes your whole program just one big loop task. Checking operations in order.\n\nBy default, the stm32 hal does not use the FreeRTOS vTaskDelay() function and instead busy-waits in it’s API. For better performance, make sure to define the HAL_Delay function in a way which yields time back to the rtos. You can also reference the uart implementation in the STM32U5 reference integration for an example of an interrupt driven UART approach with the STM32 HAL.\n\nThanks. I will give that above posted example code a try. @richard-damon: years ago I read a book titled “Minicomputer Systems” by Richard D. Eckhouse, containing a small Real Time Operating System written in PDP-11 assembler. It was called a “cooperative” OS, which means it gave control to the scheduler when a task had nothing to do. So when the UART read flag was tested “not set” it passed along to “PAUSE”. (this all provided my memory stilll serves) That’s why I had this idea of not using IRs. Maybe it’s different in RTOS. Tasks in RTOS are bound in a tight loop that is only interrupted by the scheduler and the next task can only get started after a time interval that corresponds to the interrupt tick time, right? What is this “granularity” in RTOS?\n\nI tried to incorporate that cli_uart_drv.c example into my project. But it doesn’t compile.\n\n I’m getting: 10:08:39 **** Build of configuration Debug for project NewFreeRTOS **** make -j7 all ... 10:20:51 **** Incremental Build of configuration Debug for project NewFreeRTOS **** make -j7 all arm-none-eabi-gcc \"../Core/Src/cli_uart_drv.c\" -mcpu=cortex-m3 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32F103xB -c -I../Core/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -O0 -ffunction-sections -fdata-sections -Wall -fstack-usage -fcyclomatic-complexity -MMD -MP -MF\"Core/Src/cli_uart_drv.d\" -MT\"Core/Src/cli_uart_drv.o\" --specs=nano.specs -mfloat-abi=soft -mthumb -o \"Core/Src/cli_uart_drv.o\" ../Core/Src/cli_uart_drv.c:63:11: error: 'UART_InitTypeDef' has no member named 'OneBitSampling'; did you mean 'OverSampling'? 63 | .Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE, | ^~~~~~~~~~~~~~ | OverSampling ../Core/Src/cli_uart_drv.c:63:36: error: 'UART_ONE_BIT_SAMPLE_DISABLE' undeclared here (not in a function); did you mean 'UART_ONE_BIT_SAMPLE_DISABLED'? 63 | .Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE, | ^~~~~~~~~~~~~~~~~~~~~~~~~~~ | UART_ONE_BIT_SAMPLE_DISABLED ../Core/Src/cli_uart_drv.c:64:11: error: 'UART_InitTypeDef' has no member named 'ClockPrescaler' 64 | .Init.ClockPrescaler = UART_PRESCALER_DIV1, | ^~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:64:36: error: 'UART_PRESCALER_DIV1' undeclared here (not in a function); did you mean 'TIM_ETRPRESCALER_DIV1'? 64 | .Init.ClockPrescaler = UART_PRESCALER_DIV1, | ^~~~~~~~~~~~~~~~~~~ | TIM_ETRPRESCALER_DIV1 ../Core/Src/cli_uart_drv.c:65:6: error: 'UART_HandleTypeDef' {aka 'struct __UART_HandleTypeDef'} has no member named 'AdvancedInit' 65 | .AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT, | ^~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:65:36: error: 'UART_ADVFEATURE_NO_INIT' undeclared here (not in a function) 65 | .AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT, | ^~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'vUart1MspInitCallback': ../Core/Src/cli_uart_drv.c:83:43: error: 'RCC_PERIPHCLK_USART1' undeclared (first use in this function); did you mean 'RCC_PERIPHCLK_USB'? 83 | xClockInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; | ^~~~~~~~~~~~~~~~~~~~ | RCC_PERIPHCLK_USB ../Core/Src/cli_uart_drv.c:83:43: note: each undeclared identifier is reported only once for each function it appears in ../Core/Src/cli_uart_drv.c:84:20: error: 'RCC_PeriphCLKInitTypeDef' has no member named 'Usart1ClockSelection'; did you mean 'UsbClockSelection'? 84 | xClockInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; | ^~~~~~~~~~~~~~~~~~~~ | UsbClockSelection ../Core/Src/cli_uart_drv.c:84:43: error: 'RCC_USART1CLKSOURCE_PCLK2' undeclared (first use in this function); did you mean 'RCC_LPTIM1CLKSOURCE_PCLK'? 84 | xClockInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; | ^~~~~~~~~~~~~~~~~~~~~~~~~ | RCC_LPTIM1CLKSOURCE_PCLK ../Core/Src/cli_uart_drv.c:106:24: error: 'GPIO_InitTypeDef' has no member named 'Alternate' 106 | GPIO_InitStruct.Alternate = GPIO_AF7_USART1; | ^ ../Core/Src/cli_uart_drv.c:106:37: error: 'GPIO_AF7_USART1' undeclared (first use in this function) 106 | GPIO_InitStruct.Alternate = GPIO_AF7_USART1; | ^~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'vInitUartEarly': ../Core/Src/cli_uart_drv.c:143:14: warning: implicit declaration of function 'HAL_UART_RegisterCallback'; did you mean 'HAL_DMA_RegisterCallback'? [-Wimplicit-function-declaration] 143 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ | HAL_DMA_RegisterCallback ../Core/Src/cli_uart_drv.c:143:58: error: 'HAL_UART_MSPINIT_CB_ID' undeclared (first use in this function) 143 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:144:58: error: 'HAL_UART_MSPDEINIT_CB_ID' undeclared (first use in this function) 144 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPDEINIT_CB_ID, vUart1MspDeInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'xInitConsoleUart': ../Core/Src/cli_uart_drv.c:162:61: error: 'HAL_UART_MSPINIT_CB_ID' undeclared (first use in this function) 162 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:163:61: error: 'HAL_UART_MSPDEINIT_CB_ID' undeclared (first use in this function) 163 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPDEINIT_CB_ID, vUart1MspDeInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:174:65: error: 'HAL_UART_TX_COMPLETE_CB_ID' undeclared (first use in this function) 174 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_TX_COMPLETE_CB_ID, txCompleteCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:176:65: error: 'HAL_UART_ERROR_CB_ID' undeclared (first use in this function); did you mean 'HAL_UART_ERROR_FE'? 176 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_ERROR_CB_ID, rxErrorCallback ); | ^~~~~~~~~~~~~~~~~~~~ | HAL_UART_ERROR_FE ../Core/Src/cli_uart_drv.c:177:21: warning: implicit declaration of function 'HAL_UART_RegisterRxEventCallback'; did you mean 'HAL_UARTEx_RxEventCallback'? [-Wimplicit-function-declaration] 177 | xHalRslt |= HAL_UART_RegisterRxEventCallback( &xConsoleHandle, rxEventCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | HAL_UARTEx_RxEventCallback ../Core/Src/cli_uart_drv.c:183:21: warning: implicit declaration of function 'HAL_UARTEx_SetTxFifoThreshold' [-Wimplicit-function-declaration] 183 | xHalRslt |= HAL_UARTEx_SetTxFifoThreshold( &xConsoleHandle, UART_TXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:183:69: error: 'UART_TXFIFO_THRESHOLD_8_8' undeclared (first use in this function) 183 | xHalRslt |= HAL_UARTEx_SetTxFifoThreshold( &xConsoleHandle, UART_TXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:188:21: warning: implicit declaration of function 'HAL_UARTEx_SetRxFifoThreshold' [-Wimplicit-function-declaration] 188 | xHalRslt |= HAL_UARTEx_SetRxFifoThreshold( &xConsoleHandle, UART_RXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:188:69: error: 'UART_RXFIFO_THRESHOLD_8_8' undeclared (first use in this function) 188 | xHalRslt |= HAL_UARTEx_SetRxFifoThreshold( &xConsoleHandle, UART_RXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:194:21: warning: implicit declaration of function 'HAL_UARTEx_EnableFifoMode' [-Wimplicit-function-declaration] 194 | xHalRslt |= HAL_UARTEx_EnableFifoMode( &xConsoleHandle ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'rxErrorCallback': ../Core/Src/cli_uart_drv.c:224:14: warning: implicit declaration of function 'xTaskNotifyIndexedFromISR'; did you mean 'xTaskNotifyAndQueryFromISR'? [-Wimplicit-function-declaration] 224 | ( void ) xTaskNotifyIndexedFromISR( xRxThreadHandle, | ^~~~~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyAndQueryFromISR ../Core/Src/cli_uart_drv.c: In function 'vRxThread': ../Core/Src/cli_uart_drv.c:295:13: warning: implicit declaration of function 'xTaskNotifyWaitIndexed'; did you mean 'xTaskNotifyWait'? [-Wimplicit-function-declaration] 295 | if( xTaskNotifyWaitIndexed( 1, 0, 0xFFFFFFFF, &ulNotifyValue, pdMS_TO_TICKS( 30 ) ) == pdTRUE ) | ^~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyWait ../Core/Src/cli_uart_drv.c: In function 'txCompleteCallback': ../Core/Src/cli_uart_drv.c:329:14: warning: implicit declaration of function 'vTaskNotifyGiveIndexedFromISR'; did you mean 'vTaskNotifyGiveFromISR'? [-Wimplicit-function-declaration] 329 | ( void ) vTaskNotifyGiveIndexedFromISR( xTxThreadHandle, 1, &xHigherPriorityTaskWoken ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | vTaskNotifyGiveFromISR ../Core/Src/cli_uart_drv.c: In function 'vTxThread': ../Core/Src/cli_uart_drv.c:405:22: warning: implicit declaration of function 'xTaskNotifyStateClearIndexed'; did you mean 'xTaskNotifyStateClear'? [-Wimplicit-function-declaration] 405 | ( void ) xTaskNotifyStateClearIndexed( NULL, 1 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyStateClear ../Core/Src/cli_uart_drv.c:412:26: warning: implicit declaration of function 'ulTaskNotifyTakeIndexed'; did you mean 'ulTaskNotifyTake'? [-Wimplicit-function-declaration] 412 | ( void ) ulTaskNotifyTakeIndexed( 1, pdTRUE, portMAX_DELAY ); | ^~~~~~~~~~~~~~~~~~~~~~~ | ulTaskNotifyTake make: *** [Core/Src/subdir.mk:43: Core/Src/cli_uart_drv.o] Error 1 \"make -j7 all\" terminated with exit code 2. Build might be incomplete. 10:20:52 Build Failed. 20 errors, 10 warnings. (took 1s.174ms) Sorry for posting this long error list. But examples that don’t compile are not so pleasant\n\nA “Cooperative OS” is different than a “Real-Time OS”, A Cooperative OS just needs to give tasks the ability to show they are idle and try to keep the processor busy so everything gets done. The “Real-TIme” part means that it wants to help get vital tasks done quickly on schedule, and giveng only the left over time to less important tasks. This is what needs the data from the ISRs, so it can know what tasks are actually able to run and schedule them appropiately."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/how-to-setup-printf-to-print-message-to-console/td-p/174337",
        "document": "Hello. I have STM32F767ZI nucleo board. I have created a new project and used default setup for the nucleo board. It have automatically set up some peripherals for me\n\nIn my code, I want to print the debug messages to the console:\n\nBut the printf is not working. I remember doing simmilar excersise in the class and it did not require any additional setup.\n\nCan someone help me understand how printf works and how to set it up? Do I need to dedicate USART port for it?"
    },
    {
        "link": "https://stackoverflow.com/questions/55945565/uart-interrupts-in-freertos-with-stm32-hal-driver",
        "document": "I am working on STM32L152VB-A controller. I am using FreeRTOS.\n\n I used CubeMX to generate the code and I configured USART1 with global interrupts.\n\n The non interrupt RX and TX (HAL_UART_Receive and HAL_UART_Transmit) is working.\n\n But I am trying to make it work with interrupts.\n\nOnly after I called HAL_UART_Receive_IT, I am getting interrupt.\n\n Since I couldn't know the receive data size, I am planning to receive characters one by one.\n\nSince I use RTOS, I am confused about where to write HAL_UART_Receive_IT, as the message can come at any time. can anybody guide me??\n\nPS: I tried calling the HAL_UART_Receive_IT inside ISR, but it is also not working."
    },
    {
        "link": "https://forums.freertos.org/t/example-using-stm32f103-hal-uart-receive-and-transmit/17004",
        "document": "Hi. I’m new to FreeRTOS. Since timing conditions and real time responsitivity were becoming crucial I turned to be using FreeRTOS.\n\n I managed to setup a very rudimentary program for an STM32F103 (blue pill) under STM32CubeIDE. Now I’m seeking for a code example that allows for reading one character from a UART Rx register and write it out to the same UART Tx register. Is there a collection a sample code available somewhere? Thanks in advance.\n\nThe simplest way to do that wouldn’t use FreeRTOS at all, but just an ISR. The demo program provided with FreeRTOS do have code that has the ISR put the receive character into a Queue, and then a task read from the Queue, put it into another Queue and activate a transmit function. Note, all the ISR part of that code will be VERY processor specific.\n\nQueue is exactly what I’m aiming at. Other tasks like reading out ADC data continuously will have to be implemented also. I was fed up with all these delays() and timing constraints. Two UARTs will be acting later in the solution. In a first consideration I thought not to use IRs at all. A task could polll the receive status bit and when there is no character available it just idles. When a character is available, it reads it and puts it in a ringbuffer. Another task looks whether tail != head (overflow conditions have to be processed) and gets the character, processes it and puts it into the Tx register. Tx empty bit must be polled and task could be released, when Tx busy.\n\nNO. Do not have tasks poll and idle loop, that is the way to RTOS madness. The whole concept of an RTOS is that tasks only run when they have work to do, at which point they automatically start (in priority order) and this requires ISR to be doing the work and triggering notifications. The polling method basically just makes your whole program just one big loop task. Checking operations in order.\n\nBy default, the stm32 hal does not use the FreeRTOS vTaskDelay() function and instead busy-waits in it’s API. For better performance, make sure to define the HAL_Delay function in a way which yields time back to the rtos. You can also reference the uart implementation in the STM32U5 reference integration for an example of an interrupt driven UART approach with the STM32 HAL.\n\nThanks. I will give that above posted example code a try. @richard-damon: years ago I read a book titled “Minicomputer Systems” by Richard D. Eckhouse, containing a small Real Time Operating System written in PDP-11 assembler. It was called a “cooperative” OS, which means it gave control to the scheduler when a task had nothing to do. So when the UART read flag was tested “not set” it passed along to “PAUSE”. (this all provided my memory stilll serves) That’s why I had this idea of not using IRs. Maybe it’s different in RTOS. Tasks in RTOS are bound in a tight loop that is only interrupted by the scheduler and the next task can only get started after a time interval that corresponds to the interrupt tick time, right? What is this “granularity” in RTOS?\n\nI tried to incorporate that cli_uart_drv.c example into my project. But it doesn’t compile.\n\n I’m getting: 10:08:39 **** Build of configuration Debug for project NewFreeRTOS **** make -j7 all ... 10:20:51 **** Incremental Build of configuration Debug for project NewFreeRTOS **** make -j7 all arm-none-eabi-gcc \"../Core/Src/cli_uart_drv.c\" -mcpu=cortex-m3 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32F103xB -c -I../Core/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3 -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -O0 -ffunction-sections -fdata-sections -Wall -fstack-usage -fcyclomatic-complexity -MMD -MP -MF\"Core/Src/cli_uart_drv.d\" -MT\"Core/Src/cli_uart_drv.o\" --specs=nano.specs -mfloat-abi=soft -mthumb -o \"Core/Src/cli_uart_drv.o\" ../Core/Src/cli_uart_drv.c:63:11: error: 'UART_InitTypeDef' has no member named 'OneBitSampling'; did you mean 'OverSampling'? 63 | .Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE, | ^~~~~~~~~~~~~~ | OverSampling ../Core/Src/cli_uart_drv.c:63:36: error: 'UART_ONE_BIT_SAMPLE_DISABLE' undeclared here (not in a function); did you mean 'UART_ONE_BIT_SAMPLE_DISABLED'? 63 | .Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE, | ^~~~~~~~~~~~~~~~~~~~~~~~~~~ | UART_ONE_BIT_SAMPLE_DISABLED ../Core/Src/cli_uart_drv.c:64:11: error: 'UART_InitTypeDef' has no member named 'ClockPrescaler' 64 | .Init.ClockPrescaler = UART_PRESCALER_DIV1, | ^~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:64:36: error: 'UART_PRESCALER_DIV1' undeclared here (not in a function); did you mean 'TIM_ETRPRESCALER_DIV1'? 64 | .Init.ClockPrescaler = UART_PRESCALER_DIV1, | ^~~~~~~~~~~~~~~~~~~ | TIM_ETRPRESCALER_DIV1 ../Core/Src/cli_uart_drv.c:65:6: error: 'UART_HandleTypeDef' {aka 'struct __UART_HandleTypeDef'} has no member named 'AdvancedInit' 65 | .AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT, | ^~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:65:36: error: 'UART_ADVFEATURE_NO_INIT' undeclared here (not in a function) 65 | .AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT, | ^~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'vUart1MspInitCallback': ../Core/Src/cli_uart_drv.c:83:43: error: 'RCC_PERIPHCLK_USART1' undeclared (first use in this function); did you mean 'RCC_PERIPHCLK_USB'? 83 | xClockInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; | ^~~~~~~~~~~~~~~~~~~~ | RCC_PERIPHCLK_USB ../Core/Src/cli_uart_drv.c:83:43: note: each undeclared identifier is reported only once for each function it appears in ../Core/Src/cli_uart_drv.c:84:20: error: 'RCC_PeriphCLKInitTypeDef' has no member named 'Usart1ClockSelection'; did you mean 'UsbClockSelection'? 84 | xClockInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; | ^~~~~~~~~~~~~~~~~~~~ | UsbClockSelection ../Core/Src/cli_uart_drv.c:84:43: error: 'RCC_USART1CLKSOURCE_PCLK2' undeclared (first use in this function); did you mean 'RCC_LPTIM1CLKSOURCE_PCLK'? 84 | xClockInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; | ^~~~~~~~~~~~~~~~~~~~~~~~~ | RCC_LPTIM1CLKSOURCE_PCLK ../Core/Src/cli_uart_drv.c:106:24: error: 'GPIO_InitTypeDef' has no member named 'Alternate' 106 | GPIO_InitStruct.Alternate = GPIO_AF7_USART1; | ^ ../Core/Src/cli_uart_drv.c:106:37: error: 'GPIO_AF7_USART1' undeclared (first use in this function) 106 | GPIO_InitStruct.Alternate = GPIO_AF7_USART1; | ^~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'vInitUartEarly': ../Core/Src/cli_uart_drv.c:143:14: warning: implicit declaration of function 'HAL_UART_RegisterCallback'; did you mean 'HAL_DMA_RegisterCallback'? [-Wimplicit-function-declaration] 143 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ | HAL_DMA_RegisterCallback ../Core/Src/cli_uart_drv.c:143:58: error: 'HAL_UART_MSPINIT_CB_ID' undeclared (first use in this function) 143 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:144:58: error: 'HAL_UART_MSPDEINIT_CB_ID' undeclared (first use in this function) 144 | ( void ) HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPDEINIT_CB_ID, vUart1MspDeInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'xInitConsoleUart': ../Core/Src/cli_uart_drv.c:162:61: error: 'HAL_UART_MSPINIT_CB_ID' undeclared (first use in this function) 162 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPINIT_CB_ID, vUart1MspInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:163:61: error: 'HAL_UART_MSPDEINIT_CB_ID' undeclared (first use in this function) 163 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_MSPDEINIT_CB_ID, vUart1MspDeInitCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:174:65: error: 'HAL_UART_TX_COMPLETE_CB_ID' undeclared (first use in this function) 174 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_TX_COMPLETE_CB_ID, txCompleteCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:176:65: error: 'HAL_UART_ERROR_CB_ID' undeclared (first use in this function); did you mean 'HAL_UART_ERROR_FE'? 176 | xHalRslt |= HAL_UART_RegisterCallback( &xConsoleHandle, HAL_UART_ERROR_CB_ID, rxErrorCallback ); | ^~~~~~~~~~~~~~~~~~~~ | HAL_UART_ERROR_FE ../Core/Src/cli_uart_drv.c:177:21: warning: implicit declaration of function 'HAL_UART_RegisterRxEventCallback'; did you mean 'HAL_UARTEx_RxEventCallback'? [-Wimplicit-function-declaration] 177 | xHalRslt |= HAL_UART_RegisterRxEventCallback( &xConsoleHandle, rxEventCallback ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | HAL_UARTEx_RxEventCallback ../Core/Src/cli_uart_drv.c:183:21: warning: implicit declaration of function 'HAL_UARTEx_SetTxFifoThreshold' [-Wimplicit-function-declaration] 183 | xHalRslt |= HAL_UARTEx_SetTxFifoThreshold( &xConsoleHandle, UART_TXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:183:69: error: 'UART_TXFIFO_THRESHOLD_8_8' undeclared (first use in this function) 183 | xHalRslt |= HAL_UARTEx_SetTxFifoThreshold( &xConsoleHandle, UART_TXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:188:21: warning: implicit declaration of function 'HAL_UARTEx_SetRxFifoThreshold' [-Wimplicit-function-declaration] 188 | xHalRslt |= HAL_UARTEx_SetRxFifoThreshold( &xConsoleHandle, UART_RXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:188:69: error: 'UART_RXFIFO_THRESHOLD_8_8' undeclared (first use in this function) 188 | xHalRslt |= HAL_UARTEx_SetRxFifoThreshold( &xConsoleHandle, UART_RXFIFO_THRESHOLD_8_8 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c:194:21: warning: implicit declaration of function 'HAL_UARTEx_EnableFifoMode' [-Wimplicit-function-declaration] 194 | xHalRslt |= HAL_UARTEx_EnableFifoMode( &xConsoleHandle ); | ^~~~~~~~~~~~~~~~~~~~~~~~~ ../Core/Src/cli_uart_drv.c: In function 'rxErrorCallback': ../Core/Src/cli_uart_drv.c:224:14: warning: implicit declaration of function 'xTaskNotifyIndexedFromISR'; did you mean 'xTaskNotifyAndQueryFromISR'? [-Wimplicit-function-declaration] 224 | ( void ) xTaskNotifyIndexedFromISR( xRxThreadHandle, | ^~~~~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyAndQueryFromISR ../Core/Src/cli_uart_drv.c: In function 'vRxThread': ../Core/Src/cli_uart_drv.c:295:13: warning: implicit declaration of function 'xTaskNotifyWaitIndexed'; did you mean 'xTaskNotifyWait'? [-Wimplicit-function-declaration] 295 | if( xTaskNotifyWaitIndexed( 1, 0, 0xFFFFFFFF, &ulNotifyValue, pdMS_TO_TICKS( 30 ) ) == pdTRUE ) | ^~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyWait ../Core/Src/cli_uart_drv.c: In function 'txCompleteCallback': ../Core/Src/cli_uart_drv.c:329:14: warning: implicit declaration of function 'vTaskNotifyGiveIndexedFromISR'; did you mean 'vTaskNotifyGiveFromISR'? [-Wimplicit-function-declaration] 329 | ( void ) vTaskNotifyGiveIndexedFromISR( xTxThreadHandle, 1, &xHigherPriorityTaskWoken ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | vTaskNotifyGiveFromISR ../Core/Src/cli_uart_drv.c: In function 'vTxThread': ../Core/Src/cli_uart_drv.c:405:22: warning: implicit declaration of function 'xTaskNotifyStateClearIndexed'; did you mean 'xTaskNotifyStateClear'? [-Wimplicit-function-declaration] 405 | ( void ) xTaskNotifyStateClearIndexed( NULL, 1 ); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ | xTaskNotifyStateClear ../Core/Src/cli_uart_drv.c:412:26: warning: implicit declaration of function 'ulTaskNotifyTakeIndexed'; did you mean 'ulTaskNotifyTake'? [-Wimplicit-function-declaration] 412 | ( void ) ulTaskNotifyTakeIndexed( 1, pdTRUE, portMAX_DELAY ); | ^~~~~~~~~~~~~~~~~~~~~~~ | ulTaskNotifyTake make: *** [Core/Src/subdir.mk:43: Core/Src/cli_uart_drv.o] Error 1 \"make -j7 all\" terminated with exit code 2. Build might be incomplete. 10:20:52 Build Failed. 20 errors, 10 warnings. (took 1s.174ms) Sorry for posting this long error list. But examples that don’t compile are not so pleasant\n\nA “Cooperative OS” is different than a “Real-Time OS”, A Cooperative OS just needs to give tasks the ability to show they are idle and try to keep the processor busy so everything gets done. The “Real-TIme” part means that it wants to help get vital tasks done quickly on schedule, and giveng only the left over time to less important tasks. This is what needs the data from the ISRs, so it can know what tasks are actually able to run and schedule them appropiately."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-wireless/examples-about-usart-serial-communication-tx-and-rx/td-p/106811",
        "document": "My purpose is to be able to send and receive serial communications using USART in asynchronous mode.\n\nWhen I try to adapt these kind of examples using UART_DMA in FreeRTOS, are not working. I copied the configuration regarding IRQs, DMA and USART inicializations, but it is not working.\n\nCould you please let me know if anyone else have the same problem, or could you provide me any kind of example using UART_DMA and FreeRTOS?"
    },
    {
        "link": "https://freertos.org/FreeRTOS_Support_Forum_Archive/December_2017/freertos_generic_UART_example_for_STM32_using_CubeMX_HAL_aa4a1b0ej.html",
        "document": ":This is a read only archive of threads posted to the FreeRTOS support forum. Use these archive pages to search previous posts. New forum support threads can be started at the FreeRTOS forums. The FreeRTOS support forum can be used for active support both from Amazon Web Services and the community. In return for using our software for free, we request you play fair and do your bit to help others! Sign up for an account and receive notifications of new support topics then help where you can. This is a read only archive of threads posted to the FreeRTOS support forum. Use these archive pages to search previous posts. New forum support threads can be started at the FreeRTOS forums. \n\n generic UART example for STM32 using CubeMX HAL Hello: I am self-teaching myself STM32 and FreeRTOS, and I am having difficulty finding examples for this stuff compared to the plethora of examples I was able to gather when learning AVR’s and arduino-land. I am trying to make a base for myself to use whenever I start a new project, and I am getting stumped on how to effectively use a UART with the CubeMX HAL and FreeRTOS. In 2009, someone asked this very question, and the founder of FreeRTOS made a suggestion: https://www.freertos.org/FreeRTOS Forum 2009/freertos way implement UART 3321054.html “..an efficient way would be to have a DMA pass data to and from the UART and a circular buffer. Then have the DMA interrupt use a semaphore to unblock tasks when there is enough data to make it worth processing.” So my question: does someone have an example of this working, ideally with the CubeMX HAL? I have been reading about task notifications (which I can use, since CubeMX uses FreeRTOS v9.0), is there an example that does this with those instead of semaphores? My base code that I am trying to port from arduino land, uses a command parser that can accept messages of varying length, and I need to keep that functionality. I apolgize in advance for the n00b question… it is hard for me to take everything I’ve learned thus far and start from a blank page, and example to learn from would help me greatly. Thank you in advance 🙂 generic UART example for STM32 using CubeMX HAL Specifics of FIFOs and DMAs are chip specific as the hardware moves the data, so outside of the scope of FreeRTOS support. The following file provides a heavily commented example of how to use a stream buffer to send data from an ISR to a task using software https://sourceforge.net/p/freertos/code/HEAD/tree/trunk/FreeRTOS/Demo/Common/Minimal/StreamBufferInterrupt.c You can look at the source code on the direct to task notification documentation pages to see how to signal a task from an interrupt using a notification. If you were using a DMA to move data then the ISR would be the DMA end interrupt: https://www.freertos.org/RTOS Notification Counting_Semaphore.html generic UART example for STM32 using CubeMX HAL THANK YOU.. that example is more or less exactly what I was looking for. [Report an error on this page Report an error on this page (with anti-spam) ] Copyright (C) Amazon Web Services, Inc. or its affiliates. All rights reserved."
    },
    {
        "link": "https://stackoverflow.com/questions/55945565/uart-interrupts-in-freertos-with-stm32-hal-driver",
        "document": "I am working on STM32L152VB-A controller. I am using FreeRTOS.\n\n I used CubeMX to generate the code and I configured USART1 with global interrupts.\n\n The non interrupt RX and TX (HAL_UART_Receive and HAL_UART_Transmit) is working.\n\n But I am trying to make it work with interrupts.\n\nOnly after I called HAL_UART_Receive_IT, I am getting interrupt.\n\n Since I couldn't know the receive data size, I am planning to receive characters one by one.\n\nSince I use RTOS, I am confused about where to write HAL_UART_Receive_IT, as the message can come at any time. can anybody guide me??\n\nPS: I tried calling the HAL_UART_Receive_IT inside ISR, but it is also not working."
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1722-developing-applications-on-stm32cube-with-rtos-stmicroelectronics.pdf",
        "document": ""
    }
]