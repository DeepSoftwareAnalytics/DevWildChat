[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html",
        "document": "Resizable-array implementation of theinterface. Implements all optional list operations, and permits all elements, including. In addition to implementing theinterface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to, except that it is unsynchronized.)\n\nThe , , , , , and operations run in constant time. The operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the implementation.\n\nEach instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.\n\nAn application can increase the capacity of an instance before adding a large number of elements using the operation. This may reduce the amount of incremental reallocation.\n\nNote that this implementation is not synchronized. If multiple threads access an instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be \"wrapped\" using the method. This is best done at creation time, to prevent accidental unsynchronized access to the list:\n\nThe iterators returned by this class's and methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own or methods, the iterator will throw a . Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.\n\nNote that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.\n\nThis class is a member of the Java Collections Framework."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/util/ArrayList.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://geeksforgeeks.org/arraylist-in-java",
        "document": "Java ArrayList is a part of the collections framework and it is a class of java.util package. It provides us with dynamic-sized arrays in Java.\n• advantage of ArrayList is that, unlike normal arrays, we don’t need to mention the size when creating ArrayList. It automatically adjusts its capacity as elements are added or removed.\n• None It may be slower than standard arrays, but it is helpful when the size is not known in advance. Note that creating a large fixed-sized array would cause a waste of space.\n• None Since ArrayList is part of the collections framework, it has better interoperability with other collections. For example, conversion to a HashSet is straightforward.\n\nArrayList is a Java class implemented using the List interface. Java ArrayList, as the name suggests, provides the functionality of a dynamic array where the size is not fixed as an array. Also, as a part of Collections framework, it has many features not available with arrays.\n\nNote: You can also create a generic ArrayList\n• None ArrayList is initialized by size. However, the size is increased automatically if the collection grows or shrinks if the are removed from the collection.\n• None Java ArrayList allows us to randomly access the list.\n• None ArrayList can not be used for , like int, char, etc. We need a\n• None ArrayList in Java can be seen as a\n• None ArrayList is not Synchronized. Its equivalent synchronized class in Java is\n\nLet’s understand the Java ArrayList in depth. Look at the below image:\n\nIn the above illustration, AbstractList, CopyOnWriteArrayList, and AbstractSequentialList are the classes that implement the list interface. A separate functionality is implemented in each of the mentioned classes. They are:\n• AbstractList: This class is used to implement an unmodifiable list, for which one needs to only extend this AbstractList Class and implement only the get() size()\n• CopyOnWriteArrayList: This class implements the list interface. It is an enhanced version of in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.\n• AbstractSequentialList: This class extends AbstractList. This class is used to provide the skeletal implementation for lists that are accessed sequiencially (i.e iterators) to create a concrete class. It can implement the get(int index) and size() methods.\n\nIn order to Create an ArrayList, we need to create an object of the ArrayList class. The ArrayList class consists of various constructors which allow the possible creation of the array list. The following are the constructors available in this class:\n\nNow, Using the constructors we have got ArrayList for further operations like Insertion , Deletion and Updation of the elements in ArrayList.\n\nLet us understand how the three operations performed in above Program works.\n\nAdding elements seems bit complex when the size of ArrayList is not defined:\n• None Creates a bigger-sized memory on heap memory (for example memory of double size).\n• None Copies the current memory elements to the new memory.\n• None The new item is added now as there is bigger memory available now.\n\nAfter adding the elements, if we wish to change the element, it can be done using the set() method. Since an ArrayList is indexed, the element which we wish to change is referenced by the index of the element. Therefore, this method takes an index and the updated element which needs to be inserted at that index.\n\nIn order to remove an element from an ArrayList, we can use the remove() method. This method is overloaded to perform multiple operations based on different parameters. \n\n\n\nSome Key Points of ArrayList in Java\n\nBelow are the advantages and disadvantages of using ArrayList in Java:\n• Dynamic size: ArrayList can dynamically grow and shrink in size, making it easy to add or remove elements as needed.\n• Easy to use : ArrayList is simple to use, making it a popular choice for many Java developers.\n• Fast access : ArrayList provides fast access to elements, as it is implemented as an array under the hood.\n• Ordered collection : ArrayList preserves the order of elements, allowing you to access elements in the order they were added.\n• Supports null values : ArrayList can store null values, making it useful in cases where the absence of a value needs to be represented.\n• Slower than arrays : ArrayList is slower than arrays for certain operations, such as inserting elements in the middle of the list.\n• Increased memory usage : ArrayList requires more memory than arrays, as it needs to maintain its dynamic size and handle resizing.\n• Not thread-safe: ArrayList is not thread-safe, meaning that multiple threads may access and modify the list concurrently, leading to potential race conditions and data corruption.\n• Performance degradation : ArrayList’s performance may degrade as the number of elements in the list increases, especially for operations such as searching for elements or inserting elements in the middle of the list.\n\nHow is ArrayList different from an Array in Java?\n\nHow to Access elements in an ArrayList?\n\nHow to Remove an element from an ArrayList?\n\nCan we Store null elements in an ArrayList?\n\nHow is data stored in ArrayList?"
    },
    {
        "link": "https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayList.java",
        "document": ""
    },
    {
        "link": "https://w3schools.com/java/java_ref_arraylist.asp",
        "document": "A list of all ArrayList methods can be found in the table below.\n\nSome methods use the type of the ArrayList's items as a parameter or return value. This type will be referred to as T in the table."
    },
    {
        "link": "https://stackoverflow.com/questions/18701513/best-practice-and-efficient-equals-override-method",
        "document": "The first one is the code that I have generated using intelliJ IDEA, and the other one is the code that I wrote by referring to the Oracle tutorial.\n\nWhich one would be the most practical and more efficient?"
    },
    {
        "link": "https://codegym.cc/groups/posts/264-equals-and-hashcode-methods-best-practices",
        "document": "\n• we are comparing two objects of the same class\n• and the compared objects are not the same object\n• and the passed object is not\n• When the method is used to to compare any object with itself, it must return true.\n\n We've already complied with this requirement. Our method includes:\n• If , then must return .\n\n Our method satisfies this requirement as well.\n• If two objects are equal to some third object, then they must be equal to each other.\n\n If and , then must also return true.\n• The result of must change only when the fields involved are changed. If the data of the two objects does not change, then the result of must always be the same.\n• For any object, must return false\n\n This is not just a set of some \"useful recommendations\", but rather a strict contract, set out in the Oracle documentation\n\nHi! Today we'll talk about two important methods in Java:and. This isn't the first time we've met them: the CodeGym course begins with a short lesson about— read it if you've forgotten it or haven't seen it before...In today's lesson, we'll talk about these concepts in detail. And believe me, we have something to talk about! But before we move on to the new, let's refresh what we've already covered :) As you remember, it is usually a bad idea to compare two objects using theoperator, becausecompares references. Here is our example with cars from a recent lesson:Console output:It seems we've created two identicalobjects: the values of the corresponding fields of the two car objects are the same, but the result of the comparison is still false. We already know the reason: theandreferences point to different memory addresses, so they are not equal. But we still want to compare the two objects, not two references. The best solution for comparing objects is themethod.You may recall that we don't create this method from scratch, rather we override it: themethod is defined in theclass. That said, in its usual form, it is of little use:This is how themethod is defined in theclass. This is a comparison of references once again. Why did they make it like that? Well, how do the language's creators know which objects in your program are considered equal and which are not? :) This is the main point of themethod — the creator of a class is the one who determines which characteristics are used when checking the equality of objects of the class. Then you override themethod in your class. If you don't quite understand the meaning of \"determines which characteristics\", let's consider an example. Here's a simple class representing a man:Suppose we're writing a program that needs to determine whether two people are identical twins or simply lookalikes. We have five characteristics: nose size, eye color, hair style, the presence of scars, and DNA test results (for simplicity, we represent this as an integer code). Which of these characteristics do you think would allow our program to identify identical twins?Of course, only a DNA test can provide a guarantee. Two people can have the same eye color, haircut, nose, and even scars — there are a lot of people in the world, and it's impossible to guarantee that there aren't any doppelgängers out there. But we need a reliable mechanism: only the result of a DNA test will let us make an accurate conclusion. What does this mean for ourmethod? We need to override it in theclass, taking into account the our program's requirements. The method should compare thefield of the two objects. If they are equal, then the objects are equal.Is it really that simple? Not really. We overlooked something. For our objects, we identified only one field that is relevant to establishing object equality:. Now imagine that we have not 1, but 50 relevant fields. And if all 50 fields of two objects are equal, then the objects are equal. Such a scenario is also possible. The main problem is that establishing equality by comparing 50 fields is a time-consuming and resource-intensive process. Now imagine that in addition to ourclass, we have aclass with exactly the same fields that exist in. If another programmer uses our classes, he or she could easily write code like this:In this case, checking the field values is pointless: we can readily see that we have objects of two different classes, so there is no way they can be equal! This means we should add a check to themethod, comparing the classes of the compared objects. It's good that we thought of that!But maybe we've forgotten something else? Hmm... At a minimum, we should check that we are not comparing an object with itself! If references A and B point to the same memory address, then they are the same object, and we don't need to waste time and compare 50 fields.It also doesn't hurt to add a check for: no object can be equal to. So, if the method parameter is null, then there is no point in additional checks. With all of this in mind, then ourmethod for theclass looks like this:We perform all the initial checks mentioned above. At the end of day, if:...then we proceed to a comparison of the relevant characteristics. For us, this means thefields of the two objects. When overriding themethod, be sure to observe these requirements:"
    },
    {
        "link": "https://sitepoint.com/implement-javas-equals-method-correctly",
        "document": "At SitePoint we’re always looking to expand the range of topics we cover. Lately, we’ve set our sights on exploring the world of Java. If you’re a strong Java developer who wants to contribute to our coverage, get in touch with a few ideas for articles you’d like to write.\n\nA fundamental aspect of any Java class is its definition of equality. It is determined by a class’s method and there are a couple of things to be considered for a correct implementation. Let’s check ’em out so we get it right!\n\nNote that implementing always means that has to be implemented as well! We’ll cover that in a separate article so make sure to read it after this one.\n• The equals method in Java defines a class’s equality and its implementation is crucial for correct functioning. It should always be implemented alongside hashCode.\n• In Java, a variable’s Identity (also called Reference Equality) checks if two variables hold the same reference. This is checked with ‘==’. A variable’s Equality checks if two variables reference the same value, checked with ‘equals’.\n• For a correct implementation of equals in Java, it must adhere to a specific contract. This includes properties such as reflexivity, symmetry, transitivity and consistency.\n• When implementing the equals method, it’s important to perform a self-check, null-check, type check and cast, and field comparison. The method Objects.equals is recommended for comparing fields, as it is more readable.\n• It’s good practice to override the hashCode method whenever the equals method is overridden. This ensures that objects considered equal produce the same hash code, which is important when using objects as keys in hash-based collections like HashMap.\n\nHave a look at this piece of code:\n\nWe have two strings and they are obviously different.\n\nWhat about these two?\n\nHere we have only one String instance and and both reference it. In Java we say and are identical and, accordingly, returns a Boolean value that is .\n\nWhat about this one?\n\nNow, and point to different instances and are no longer identical, so is false. (We’ll ignore String interning in this article; if this bugs you, assume every string literal were wrapped in a .)\n\nBut they do have some relationship as they both “have the same value”. In Java terms, they are equal, which is checked with :\n\nA variable’s Identity (also called Reference Equality) is defined by the reference it holds. If two variables hold the same reference they are identical. This is checked with .\n\nA variable’s Equality is defined by the value it references. If two variables reference the same value, they are equal. This is checked with .\n\nBut what does “the same value” mean? It is, in fact, the implementation of the method in Java that determines “sameness”. The method is defined in and since all classes inherit from it, all have that method.\n\nThe default implementation used in checks identity (note that identical variables are equal as well), but many classes override it with something more suitable. For strings, for example, it compares the character sequence and for dates it makes sure that both point to the same day.\n\nMany data structures, most notably Java’s own collection framework, use to check whether they contain an element.\n\nThe variable is because, while the instances of are not identical, they are equal.\n\nAny implementation of must adhere to a specific contract or the class’s equality is ill-defined and all kinds of unexpected things happen. We will look at the formal definition in a moment but let’s first discuss some properties of equality.\n\nIt might help to think about it as we encounter it in our daily lives. Let’s say we compare laptops and consider them equal if they have the same hardware specifications.\n• One property is so trivial that it is hardly worth mentioning: Each thing is equal to itself. Duh.\n• There is another, which is not much more inspiring: If one thing is equal to another, the other is also equal to the first. Clearly if my laptop is equal to yours, yours is equal to mine.\n• This one is more interesting: If we have three things and the first and second are equal and the second and third are equal, then the first and third are also equal. Again, this is obvious in our laptop example.\n\nThat was an exercise in futility, right? Not so! We just worked through some basic algebraic properties of equivalence relations. No wait, don’t leave! That’s already all we need. Because any relation that has the three properties above can be called an equality.\n\nYes, any way we can make up that compares things and has the three properties above, could be how we determine whether those things are equal. Conversely, if we leave anything out, we no longer have a meaningful equality.\n\nThe contract is little more but a formalization of what we saw above.\n\nTo quote the source:\n\nBy now, the first three should be very familiar. The other points are more of a technicality: Without consistency data structures behave erratically and being equal to null not only makes no sense but would complicate many implementations.\n\nFor a class with string fields and , this would be a common variant to implement string :\n\nLet’s go through it one by one.\n\nIt is very important that takes an ! Otherwise, unexpected behavior occurs.\n\nFor example, assume that we would implement like so:\n\nWhat happens in a simple example?\n\nThen is . What about now?\n\nNow it’s . Wat?! Maybe not quite what we expected.\n\nThe reason is that Java called (as inherited from the class, which checks identity). Why?\n\nJava’s strategy for choosing which overloaded method to call is not based on the parameter’s runtime type but on its declared type. (Which is a good thing because otherwise static code analysis, like call hierarchies, would not work.) So if is declared as an , Java calls instead of our .\n\nNote that most code, for example all collections, handle our persons as objects and thus always call . So we better make sure we provide an implementation with that signature! We can of course create a specialized implementation and call it from our more general one if we like that better.\n\nEquality is a fundamental property of any class and it might end up being called very often, for example in tight loops querying a collection. Thus, its performance matters! And the self check at the beginning of our implementation is just that: a performance optimization.\n\njava\n\n if (this == o)\n\n return true;\n\n\n\nIt might look like it should implement reflexivity but the checks further down would be very strange if they would not also do that.\n\nNo instance should be equal to null, so here we go making sure of that. At the same time, it guards the code from s.\n\nIt can actually be included in the following check, like so:\n\nNext thing, we have to make sure that the instance we’re looking at is actually a person. This is another tricky detail.\n\nOur implementation uses , which returns the classes to which and belong. It requires them to be identical! This means that if we had a class , then would never return – not even if both had the same names.\n\nThis might be unexpected.\n\nThat an extending class with new fields does not compare well may be reasonable, but if that extension only adds behavior (maybe logging or other non-functional details), it should be able to equal instances of its supertype. This becomes especially relevant if a framework spins new subtypes at runtime (e.g. Hibernate or Spring), which could then never be equal to instances we created.\n\nAn alternative is the operator:\n\nInstances of subtypes of pass that check. Hence they continue to the field comparison (see below) and may turn out to be equal. This solves the problems we mentioned above but opens a new can of worms.\n\nSay and adds an additional field. If it overrides the implementation it inherits from and includes the extra field, then can be (because of ) but can’t (because misses that field). This clearly violates the symmetry requirement.\n\nThere seems to be a way out of this: could check whether it compares to an instance with that field and use it only then (this is occasionally called slice comparison).\n\nBut this doesn’t work either because it breaks transitivity:\n\nObviously all three instances share the same name, so and are . By transitivity should also be but it isn’t if the third field, apparently the department, is included in the comparison.\n\nThere is really no way to make slice comparison work without violating reflexivity or, and this is trickier to analyze, transitivity. (If you think you found one, check again. Then let your coworkers check. If you are still sure, ping me. ;) )\n\nSo we end with two alternatives:\n• Use and be aware that instances of the type and its subtypes can never equal.\n• Use but make final because there is no way to override it correctly.\n\nWhich one makes more sense really depends on the situation. Personally, I prefer because its problems (can not include new fields in inherited classes) occurs at declaration site not at use site.\n\nWow, that was a lot of work! And all we did was solve some corner cases! So let’s finally get to the test’s core: comparing fields.\n\nThis is pretty simple, though. In the vast majority of cases, all there is to do is to pick the fields that should define a class’s equality and then compare them. Use for primitives and for objects.\n\nIf any of the fields could be null, the extra checks considerably reduce the code’s readability:\n\nAnd this already uses the non-obvious fact that is .\n\nIt is much better to use Java’s utility method (or, if you’re not yet on Java 7, Guava’s ):\n\nIt does exactly the same checks but is much more readable.\n\nWe have discussed the difference between identity (must be the same reference; checked with ) and equality (can be different references to “the same value”; checked with ) and went on to take a close look at how to implement .\n• Make sure to override so our method is always called.\n• Include a self and null check for an early return in simple edge cases.\n• Use to allow subtypes their own implementation (but no comparison across subtypes) or use and make final (and subtypes can equal).\n\nOr let your IDE generate it all for you and edit where needed.\n\nWe have seen how to properly implement (and will soon look at ). But what if we are using classes that we have no control over? What if their implementations of these methods do not suit our needs or are plain wrong?\n\nLibFX to the rescue! (Disclaimer: I’m the author.) The library contains transforming collections and one of their features is to allow the user to specify the and methods she needs.\n\nFAQs about the equals Method in Java"
    },
    {
        "link": "https://stackoverflow.com/questions/17801611/implementing-hashcode-and-equals-for-custom-classes",
        "document": "So I have many custom classes are also have custom clases inside of them using composition.\n\nMy custom classes have variables that change very frequently and I add them to HashSets. So my question is when I implement hashCode - what should I do for a class that only has private fields that constantly change?\n\nHere is an example of one custom class:"
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-implement-the-equals-method-in-java-classes-414077",
        "document": "When implementing the method, it's important to follow a set of best practices to ensure that your implementation is correct and consistent. Here are the steps to correctly implement the method:\n\nThe first step in implementing the method is to check if the object being compared is or if it's the same object in memory. This can be done using the following code:\n\nNext, you should check if the object being compared is of the same class type as the current object. This can be done using the method:\n\n3. Cast the Object and Compare the Attributes\n\nAfter checking the class type, you can cast the object to the appropriate class and compare the relevant attributes. This is where the actual logic of your method implementation will reside:\n\nIn the example above, the method is used to compare the attributes, as it handles values correctly.\n\nBy following these steps, you can ensure that your method implementation is correct and consistent with the general contract defined in the class."
    }
]