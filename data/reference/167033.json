[
    {
        "link": "https://sqlservercentral.com/articles/dos-and-donts-of-dynamic-sql",
        "document": "Dynamic SQL can be an incredibly powerful tool when used properly, however, it can an incredibly large security flaw or a pain to debug if written poorly. The below is a few of Dos (and Don’ts) that I have that may help you in the future when writing Dynamic Statements.\n\nDon’t use Dynamic SQL if your statement isn’t Dynamic\n\nThis might seem like a silly thing to say, but countless times time I have seen examples of dynamic SQL where the query doesn’t need to be dynamic at all. Take the following procedure, for example:\n\nThere’s actually nothing “dynamic” about this statement. doesn’t need to be injected into the statement, and neither does a variable to hold the statement need to be used. You could easily replace the whole thing with a parametrised statement:\n\nDo quote the names of your objects properly\n\nOne thing that is incredibly important when using dynamic SQL is making sure your object names are properly quoted. That means not injecting the value of your dynamic object straight into your dynamic statement, like in the below:\n\nBoth of these statements are just as bad as the other; simply wrapping the dynamic object’s name in a couple of brackets does not make your code “safe” from injection. Just like with a literal string, brackets can be escaped, and someone malicious will be try to escape the value.\n\nFortunately SQL Server has a handy function to help keep you safer, which is . Simply wrap the function round the variable with the dynamic object’s name and the function will automatically wrap the name in brackets and (just as importantly) escape any characters accordingly.\n\nWhen writing dynamic statements, it’s very likely you’re also going to need to pass the value of a parameter for the query as well. These aren’t values for a dynamic object but are likely something that is going to appear in your clause as part of a Boolean expression. The way to pass there parameters is not like the below example:\n\nDynamic SQL can (and should) be parametrised just like any other SQL statement. This can be achieved by using instead of just executing the dynamic statement using . ‘s second parameter is used to declare any variables that will be passed to the dynamic statement, and then the values for those variables can be passed as further parameters:\n\nThis can even be used to output values as well:\n\nParametrising your Dynamic Statement has the advantage that plans can be reused as well (when the value of the dynamic object is the same). If you inject the parameter's value then the plan won't be reused. The Data Engine would create separate query plans for queries where the clause and ; however a query with would use the same plan, regardless of the value of .\n\nDo take the time to format your Dynamic SQL\n\nOne common reason I hear for why people don’t use dynamic SQL is because it’s difficult to troubleshoot. I personally find this a little untrue. Poorly written and/or formatted dynamic SQL is difficult to troubleshoot, but then the same is true for poorly written SQL in general. Let’s take something that looks like a simple enough query:\n\nThis query look well formatted, and it’s quite easy to read. The problem is that the dynamic SQL is returning an error (perhaps something about an invalid object name). Therefore, before executing the dynamic statement you print out its value, which returns something like this:\n\nNow that “well written” dynamic statement turns out to look like a complete eyesore. So, how do you fix this? My personal preference is to add a carriage returns and line breaks, as well an indents into my dynamic statements, just like I would any “normal” query. I tend to and for carriage return and line break respectively, but you can add the values however you wish. So the above you might write something like this:\n\nWhen you then print out the statement from this query you end up with something far more readable.\n\nIf you’re writing a more “normal” query, then the same logic applies. A query like this “looks” well formatted:\n\nBut, once printed out, turns into a single line of SQL, that can be hard to debug. If, however, you add some formatting into the dynamic statement as well, then it becomes much more readable. Applying the same idea, you could write the above query as:\n\nThis formatting may look a little odd to some, but I've personally found it invaluable when dealing with high complexity dynamic statements. The above statements don't really lose any readability either, although may be a bit confusing to those newer to the language. But would you rather something than looks a little more complex at the generation point, or a huge unreadable mess when you print the dynamic statements value? I know I'd prefer the former.\n\nDo perform whitelist checks to avoid errors on invalid objects and make your statements safer\n\nMaking sure you perform a whitelist process can be really important, especially if you want to avoid passing an error back to the presentation layer. With dynamic object names, this can be achieved my checking the values of the dynamic objects against the system tables, such as or , or your own table of “allowed” values. Passing the value to does not generate an error, but also, it won’t actually run anything; making your statement even safer from any injection attempts.\n\nThe above ends up not printing anything, nor running any dynamic SQL, as it’s going to be very unlikely you have a table with the name in this script.\n\nDon’t use nvarchar(MAX) for your object’s name parameter\n\nThe maximum length of an object’s name in SQL Server is 128 characters, so why do you need space for 2GB worth of characters? Quite simply, you don’t. As you may have seen, I’ve been making use of the data type , which is a synonym for . If you know that the names of your objects are going to be shorter than 128 characters, then certainly use a smaller length, but there is never any need to have a length of more than 128 characters when dealing with SQL Server objects. I do recommend using rather than , as a object can contain Unicode characters. Just because you \"know\" your objects don't contain any of those characters now, doesn't mean they won't in the future (and the parameter to be implicitly cast to a if you're white listing against the system objects as well).\n\nDon’t always debug the code that creates the dynamic SQL first, debug the generated SQL statement instead\n\nContinuing on my earlier point of making your SQL easier to debug by using formatting inside the dynamic statement, often it’s easier to debug the generated statement first and then the code that creates it. Using (or a Statement if your dynamic SQL is over 4,000 characters) you can inspect the SQL that is about to be run. You can then run that code on its own and see where the error is being generated and more importantly why. Once you work out why that’s failing you can then propagate the solution to your SQL that creates the dynamic statement.\n\nSometimes the reason for the error can be very simple, like a space is missing between 2 words. These can be very difficult to spot when all your code looks like a literal string. Getting the value of your dynamic statement means you can view the code as it’s going to be run, with all the fancy colours that your preferred UI provides, and will make debugging the code far easier."
    },
    {
        "link": "https://dba.stackexchange.com/questions/43580/are-there-design-patterns-best-practices-in-writing-dynamic-sql-in-stored-proced",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://brentozar.com/sql/dynamic",
        "document": "Dynamic SQL - When, Why, and How to Use It that have a bunch of parameters. For example, you have that \"product search\" stored proc with parameters for product category, name, price range, sort order, etc, and you have to accept any of 'em. So how do we make those go fast? And how can we get 'em to use indexes? In one all-demo hour, you'll learn how to write dynamic SQL that's easy to Open source with the Creative Commons License. For details, see the end of this file. This first RAISERROR is just to make sure you don't accidentally hit F5 and run the entire script. You don't need to run this: 't just hit F5. Run these demos one at a time.' /* Set up indexes for the demo: */ /* Turn on our tuning options and Actual Execution Plans: */ How big is it? Look at how many rows are returned from this query, and on the Messages tab, check the STATISTICS IO results to see how many logical reads we did. That's how many 8KB pages the clustered index has. Folks want a single stored procedure that can search on any of these 3 fields. You should be able to pass in 1, 2, or all 3, and find just the users that match ALL of your parameters. They want a stored proc that works like this: Here's one way to do it. It's a bad way - it doesn't really work - but let's /* Will that work? Is there a bug in that logic? */ /* If we pass in multiple fields, like this, it only searches for one of them: */ /* Do other parameters use indexes? */ When I'm looking at search code performance, I'll often ask: * Is the optimizer willing to use indexes? * Are the row estimates right? In this case, all 3 of the branches were willing to use indexes - too willing - and the estimates weren't right - because SQL Server built the entire execution plan for all 3 branches when we ran the very first query. Notice some of the query plans have yellow bang warnings on their sort operator because SQL Server underestimated how many rows those queries would bring back. It's that pesky ORDER BY CreationDate. Does it get better if you clear the cache, and try a different branch first? Sometimes - for some branches - but not always. That's the devil of parameter sniffing - the whole plan gets optimized for the first set of parameters that get used, even if some branches rely on parameters that didn't get passed in. They can get optimized for NULL, which can give you really low estimates. Sometimes that's good - but not usually. The IF branch design has a few drawbacks: * It's very susceptible to parameter sniffing * Multi-parameter results don't match what the users asked for * Getting multi-parameter results to work right would require a lot of code IF @SearchDisplayName IS NOT NULL AND @SearchLocation IS NOT NULL IF @SearchDisplayName IS NOT NULL AND @SearchLocation IS NOT NULL AND @SearchReputation.... Yeah, that's not gonna scale. So let's try a different design: /* Do other parameters use indexes? */ Look at the plans, and... Then look at logical reads! That, ladies and gentlemen, is a really bad query plan. SQL Server uses the first set of incoming parameters to build the plan - in our case, it builds a plan that uses the DisplayName index. And when DisplayName isn't passed in, SQL SERVER STILL USES THAT INDEX, doing a key lookup of every single row. It does millions of logical reads - even though the whole table only has about 80k pages. /* Do other parameters use indexes? */ /* Do other parameters use indexes? */ Depending on your version & cardinality estimator, you're probably going to get either clustered index scans, or some very unusual index intersection plans Now you see why people have to resort to dynamic SQL. So let's spend some time at the Dynamic SQL Resort: /* Do other parameters use indexes? */ /* Is it bloating the plan cache? */ There's a line in the plan cache for every variation of the dynamic SQL, but whenever we use different parameters, they'll reuse an existing plan. This might look like a lot of plans at first glance - but it's not really that many, especially as opposed to building a line for every single combination of parameter VALUES, like Brent or Alex or Billie. It's a little bit of plan cache bloat - but totally worth it since each combination of parameters can get its own customized plan with good (hopefully) We do still have parameter sniffing: /* Now for the pro tips. Lemme clear the cache and run it a couple of times first: */ /* Pro Tip: in your dynamic SQL, throw in a comment to include the source. */ So that when you're viewing plans, you can see the source. */ /* Pro Tip: add line feeds to make it easier to read. */ Now check out the nicely formatted string - after sp_BlitzCache runs, click on the query plan, right-click on the query, and click Edit Query Text: /* But do NOT put dynamic stuff in the comments, les you end up with different plans for every dynamic thing: /* Because every string will be unique: */ See how sp_BlitzCache shows four different lines of dynamic SQL now? Click on each of their plans, and look at the query text to see how the time text comments meant that each query has different text, so it gets different /* Pro Tip: Every proc with dynamic SQL needs a @Debug_PrintQuery parameter to print strings: */ /* So you can see the T-SQL in the Messages tab, complete with line returns: */ PRINT is limited to 4,000 characters. If you build longer strings, use this Just to keep the projector screen readable, I'm going to ignore the filters for @SearchLocation and @SearchReputation, and only work on the ORDER BY part. Let's see what QUERY (not query plan) that it builds. I'm less worried about performance here, and more just worried about getting the query right first. /* Pretty cool. And how about this: */ /* Oh. Well, that's not good. That's SQL injection. Never, ever use the stored procedure's input parameters as part of the dynamic SQL itself. Never, ever. Obligatory comic strip: https://xkcd.com/327/ Think you can work around it via regex and sanitizing? Think again, as Bert Instead, examine the user's input, and substitute your own: /* Or whatever default ordering you want, ideally to make SQL's life easier */ /* Because technically, we're supposed to */ Note that the more complex our dynamic SQL gets, like with different possible filters, joins, and order by clauses, the more we may need specialized indexes. But don't try to guess which ones need indexes! Use sp_BlitzCache to review your most resource-intensive queries. That'll tell you which ones need the most help because they're getting called more frequently and/or sucking the most. What if you want to order by MULTIPLE columns? If you pass in a list, then whatever method you use to split the string list has to preserve the same order. Unfortunately, SPLIT_STRING doesn't: it doesn't guarantee that the output will be in the same order. For more info: Instead, we'll either have to use our own string splitter, or pass in a table. I'm going to use a splitter function that's widely regarded as one of the fastest ones out there, Jeff Moden's: Create the function. Note that I'm using the name STRING_SPLIT, which is the same as a system function, but there's a reason: the internal function doesn't guarantee order and doesn't include a row number. To learn more: --==== This provides the \"base\" CTE and limits the number of rows right up front -- for both a performance gain and prevention of accidental \"overruns\" --==== This returns N+1 (starting position of each \"element\" just once for each delimiter) --==== Return start and length (for use in substring) --===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found. /* When you call it, here's what you get: */ /* Note that there are spaces we'll need to clean up. */ /* This can now be a comma-delimited list of columns */ /* Or whatever default ordering you want, ideally to make SQL's life easier */ /* Because technically, we're supposed to */ Next up, how about letting users pick what fields they want to see, and from which tables? We already know we NEVER EVER want to let them send their own T-SQL in as a parameter because it's a recipe for SQL injection. Here's one implementation - again, I'm going to remove the search parameters and the order-by stuff just to keep my presentation screen easier to read, and only focus on the dynamic join implementation: /* Let's see how it works: */ Well, that's not gonna work. Our dynamic SQL building is gonna have to get a lot more intelligent, and we'll need to build the string in different parts: And then at the end of our string-building, assemble them all into one like /* Let's see how it works: */ The beauty of dynamic SQL here is that you're only joining out to the Votes table if you really need to show its contents. Otherwise, you keep the query fast by only looking at the Users table. You can also leverage views here to put the optional joins and fields in the view, and SQL Server will (usually) do a good job of eliminating unneccessary joins, but that also means you can't just SELECT *. You have to be really careful about only selecting the fields you need. Debugging this stuff can be AWFUL, especially when you start nesting dynamic SQL inside of dynamic SQL. It can even be tough figuring out which part of your query is throwing the error - normal SQL, or dynamic SQL, since the line numbers are worthless too. Run this, and try to figure out where the error is: And that line number is worthless. Is that \"AND\" inside our regular query, or the dynamic SQL? So when you build dynamic SQL, it can help to use different casing for your keywords and variable names inside dynamic SQL, like this: /* Let's change the casing on our stored procedure: */ /* So now when there's an error, it's easier to know where it's coming from: */ You may also need to log the dynamic SQL, and/or the parameters. Erik Darling Basically you create a table like this: /* And in your stored procedures, include this code: */ To show you just how bad it can get, I'm going to put all the logic in at once: /* Or whatever default ordering you want, ideally to make SQL's life easier */ /* You could also do this with a separate @OrderByDesc bit parameter if you want */ /* Let's see how it works: */ This here is the point where you wish that your conference water bottle was filled with margaritas instead, and you start sobbing into your hands. Dynamic SQL done well is really hard work, but before you complain, think about a sliding control that you can tune left to right: Start with easy-to-code stuff like ORMs. Later, as you need better performance, graduate to stored procedures. Over time, as your data grows and you have to start making tradeoffs between hardware, index size, and budgets, you may have Now you're better equipped to start building it in a way that scales. Wanna learn even more? Check out Erland Sommarskog's epic posts: * Share - copy and redistribute the material in any medium or format * Adapt - remix, transform, and build upon the material for any purpose, even Under the following terms: * Attribution - You must give appropriate credit, provide a link to the license, and indicate if changes were made. * ShareAlike - If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original."
    },
    {
        "link": "https://stackoverflow.com/questions/74466924/best-practice-of-executing-dynamic-sql-strings-via-prepared-statements-and-proce",
        "document": "Background: I am building a Springboot+mySQL app that uses Spring Data JPA native queries (i.e. to retrieve database data.\n\nWe have to use the same SQL in every query we write to enable certain functionality (this can be seen in the example below). And wanted a way to remove this duplicate SQL and instead only declare it once. An option presented was to pass a dynamic SQL string into a stored procedure and then build a prepared statement by concatenating this dynamic SQL string with our static shared SQL string (show in example below).\n\nQuestion: This doesn't seem like a good idea to me, but I am not knowledgeable enough about databases to given the exact technical reasons. Is the below example safe, reasonable, and best-practice? Are there ways to mitigate issues with this approach, or are there other approaches to use instead?"
    },
    {
        "link": "https://sqlshack.com/dynamic-sql-in-sql-server",
        "document": "In this article, we will review how to construct and execute dynamic SQL statements in SQL Server with different examples.\n\nDynamic SQL is the SQL statement that is constructed and executed at runtime based on input parameters passed. Let us go through some examples using the EXEC command and sp_executesql extended stored procedure.\n\nEXEC command executes a stored procedure or string passed to it. Please refer to EXEC SQL overview and examples for more details and examples on the EXEC command.\n\nThe following example demonstrates constructing the SQL statement using the input variable and executing the SQL statement using the EXEC command.\n\nThere is a possibility of SQL injection when you construct the SQL statement by concatenating strings from user input values. I hope to cover the SQL injection and some methods to prevent SQL Injection in my future articles.\n\nWe should take care of null values when concatenating strings from parameters using ‘+’ operator. In the below example, I commented out the statement that sets a value to variable “@pid”.\n\nBy default, the variable “@pid” is NULL as we did not set any value. The final statement constructed after concatenation is blank as ‘+’ operator does not handle null values. Please refer to the below image that shows the final value of “@SQL” variable is blank.\n\nIn this case, use the ISNULL function to construct a proper SQL statement while concatenating strings using ‘+’ operator.\n\nEXEC command does not re-use the compiled plan stored in the plan cache. Execute the following query and check for the cached plans.\n\nPlease refer to the below image that shows two separate plans created when the above query is executed for two different parameters.\n\nsp_executesql is an extended stored procedure that can be used to execute dynamic SQL statements in SQL Server. we need to pass the SQL statement and definition of the parameters used in the SQL statement and finally set the values to the parameters used in the query.\n\nFollowing is the syntax of executing dynamic SQL statements using sp_executesql extended stored procedure.\n\nBelow example demonstrates executing dynamic SQL statement by passing parameters to sp_executesql extended stored procedure.\n\nsp_executesql reuses the compiled plan when the statement is executed for different parameters. Execute the following query and check for the cached plan.\n\nPlease refer to the below image that shows the same plan is being used when the statement is executed with different parameters.\n\nFollowing is the example of using dynamic SQL inside a stored procedure. For demo purpose, I used the Product table from the AdventureWorksLT database. This stored procedure is used to search for products based on different columns like name, color, productid, and the product number. The dynamic SQL statement is constructed based on the input parameters passed to the stored procedure and is executed by the EXEC command.\n\nWhen we execute the stored procedure with input parameter productid only, the SQL statement is constructed as shown in the below image.\n\nPlease refer to the below image that shows a different SQL statement constructed when productid and product number are passed as input parameters to the stored procedure.\n\nLet us re-write the stored procedure to form dynamic SQL and execute it using sp_executesql extended stored procedure. Please refer to the below sample script.\n\nLet us execute below sample thread that will retrieve all the products that are red.\n\nsp_executesql extended stored procedure supports the output parameter to store the value returned by the select query and use the output variable in another statement.\n\nFollowing is the example script which shows the usage of the output variable in sp_executesql.\n\nThe local temp table created by executing dynamic SQL cannot be accessed outside the execution of dynamic SQL. It throws invalid object error as shown in the below image.\n\nA workaround for this is to create the local temp table outside and use it in the dynamic SQL. Following is the example that demonstrates this scenario.\n\nPlease refer to the below image. we can see that the data is inserted in the temp table and can be accessed again.\n\nIn this article, we explored how to construct and execute dynamic SQL in SQL Server using the EXEC command and sp_executesql extended stored procedure with different examples. In case you have any questions, please feel free to ask in the comment section below."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://red-gate.com/simple-talk/databases/sql-server/performance-sql-server/the-except-and-intersect-operators-in-sql-server",
        "document": "Quite often, you’re faced with the task of comparing two or more tables, or query results, to determine which information is the same and which isn’t. One of the most common approaches to doing such a comparison is to use the UNION or UNION ALL operator to combine the relevant columns of the results that you want to compare. As long as you adhere to the restrictions placed on either of those operators, you can combine data sets whether they come from different databases or even different servers. With the UNION operator, you end up with a result containing every distinct row from the two results combined. However, it becomes more difficult to use UNION to return only the common data that is held in both results, or the different data that exists in one table but not the other(s). To get the results you need, you must use UNION ALL with a GROUP BY clause, though the logic isn’t always obvious on how to do this. And it isn’t any easier to use a JOIN operator to get the result you want. .\n\nEnter the INTERSECT and EXCEPT operators. Beginning with SQL Server 2005, you can use these operators to combine queries and get the results you need. For instance, you can use the INTERSECT operator to return only values that match within both data sets, as shown in the following illustration .\n\nThe illustration shows how the INTERSECT operator returns data that is common to both results set; the common data is represented by the area where the two circles intersect. The illustration also shows how the EXCEPT operator works; only data that exists in one of the data sets outside the intersecting area is returned. For instance, if Set A is specified to the left of the EXCEPT operator, only values that are not in Set B are returned. In the illustration above, that would be the data in the left circle, outside the section where the two data sets intersect. The following bullets sum up which operator to use to return different combinations of data:\n• To return the data in Set A that doesn’t overlap with B, use A EXCEPT B.\n• To return only the data that overlaps in the two sets, use A INTERSECT B.\n• To return the data in Set B that doesn’t overlap with A, use B EXCEPT A.\n• To return the data in all three areas without duplicates, use A UNION B.\n• To return the data in all three areas, including duplicates, use A UNION ALL B.\n• To return the data in the non-overlapping areas of both sets, use (A UNION B) except (A INTERSECT B), or perhaps (A EXCEPT B) UNION (B EXCEPT A)\n\nThe differences between the INTERSECT and EXCEPT operators and how to use each of them will become clearer as we work through the examples in the article. Just to give you a basic idea of how they work, we’ll start with a rather unrealistic example. To demonstrate those, however, we must first create two test views (using SQL Server 2005-compatible syntax). The first view contains a single column that describes what you might have had for lunch:\n\nThe second view also contains a single column and describes what you might have had for dinner:\n\nNow we can use these two views to demonstrate how to use the UNION, INTERSECT, and EXCEPT operators. I’ve also included a couple examples that use the JOIN operator to demonstrate the differences.\n\nThe first example uses the UNION operator to join the two views in order to return everything you’ve eaten today:\n\nNow we return the same data by using a full outer join:\n\nNotice that the join requires more complex syntax; however, both statements return the same results, as shown in the following table:\n\nNow let’s look at how you would return only the food you ate (or drank) for lunch, but did not have for dinner:\n\nIn this case, I used the EXCEPT operator to return the lunch-only items. I could have achieved the same results using the following left outer join:\n\nOnce again, you can see that the join is more complex, though the results are the same, as shown in the following table:\n\nIf you wanted to return those items you had for dinner but not lunch, you can again use the EXCEPT operator, but you must reverse the order of the queries, as shown in the following example:\n\nNotice that I first retrieve the data from the Dinner view. To use the left outer join, you would again have to reverse the order of the tables:\n\nAs expected, the results are the same for both SELECT statements:\n\nIn the next example, I use the INTERSECT operator to return only the food that was eaten at both meals:\n\nAs you can see, I simply connect the two queries with the INTERSECT operator, as I did with the EXCEPT operator. You can achieve the same results by using an inner join:\n\nAs the following results show, the only items you had at both meals were olives, bread, and coffee:\n\nNow let’s look at how you would return a list of food that you ate at one of the meals, but not both meals, in other words, the food you ate other than bread, olives, and coffee. In the following statement, I use a UNION operator to join two SELECT statements:\n\nNotice that first statement retrieves only the food you ate for lunch, and the second statement retrieves only the food ate for dinner. I achieve this in the same way I did in previous examples-by using the EXCEPT operator. I then used the UNION operator to join the two result sets. You can achieve the same results by using a full outer join:\n\nIn both examples, the statements return the following results:\n\nFrom this point on, I developed the examples on a local instance of SQL Server 2008 and the AdventureWorks2008 database. Each example uses either the INTERSECT or EXCEPT operator to compare data between the Employee and JobCandidate tables, both part of the HumanResources schema. The comparison is based on the BusinessEntityID column in each table. The BusinessEntityID column in the Employee table is the primary key. In the JobCandidate table, the BusinessEntityID column is a foreign key that references the BusinessEntityID column in the Employee table. The column in the JobCandidate table also permits null values.\n\nAs I mentioned above, when you use the INTERSECT operator to combine queries, the data returned is only that which matches between the two data sets. That means, with regard to the Employee and JobCandidate tables, the result set will include only rows in which the BusinessEntityID value in the Employee table matches the BusinessEntityID value in the JobCandidate table.\n\nIn the following example, I create two queries that retrieve data from the Employee and JobCandidate tables and use the INTERSECT operator to combine those queries:\n\nThe first SELECT statement, as you can see, retrieves the BusinessEntityID column from the Employee table, and the second SELECT statement retrieves the BusinessEntityID column from the JobCandidate table. The INTERSECT operator combines the two queries.\n\nWhen you use the INTERSECT operator to combine queries (or EXCEPT, for that matter), the number of columns must be the same in both queries and the columns must be in the same order. In addition, the corresponding columns between the queries must be configured with compatible data types. The example above meets these conditions because each query returns only one column of the same data type (INT). When the INTERSECT operator is used to combine these the two queries, the statement returns the following results:\n\nAs it turns out, the Employee table and JobCandidate table have only two BusinessEntityID values in common. If you were to examine the data in the JobCandidate table, you would find that the query results here are consistent with the data in that table. The table contains only 13 rows, and the BusinessEntityID column is NULL for all but two of the rows. The BusinessEntityID values in those rows are 212 and 274. And, as you would expect, the Employee table also contains a row with a BusinessEntityID value of 212 and a row with a value of 274.\n\nCertainly, as the above example indicates, using the INTERSECT operator to combine the results of two queries together is a straightforward process. The key, as I’ve stated, is to make sure the SELECT lists in the two queries are in sync with each other.\n\nHowever, that also points out one of the limitations of using the INTERSECT operator to combine queries-and that is, you cannot include columns in one query that are not included of the second query. If you do include multiple matching columns in each query, all the column values must match in order for a row to be returned. For example, suppose you’re retrieving data from two tables that each include columns for employee IDs, first names, and last names. If you want to match the two tables based on those three columns, the three values in the first table must match the three values in the second table for a row to be returned. (At this point, you might be asking yourself what you’re doing with all that redundant data in your database.)\n\nInstead of taking this approach, you may decide to compare the IDs in both tables, but pull the first and last name from only one of the tables. Or you might decide that you want to pull information from one table that is not stored in the other table. However, because columns must correspond between the two queries when using an INTERSECT operator to combine them, you have to find a way to work around this limitation. One of the easiest ways to do that is to put your INTERSECT construction into a common table expression (CTE) and then join the expression to one of the tables to pull the additional data. For instance, the following example includes a CTE that contains the same INTERSECT construction you saw in the example above:\n\nNotice that I’ve created a CTE named cteCandidates. As you would expect, the CTE returns the BusinessEntityID values that are contained in both the Employee and JobCandidate tables. In the primary SELECT statement, I then join the Employee table to the CTE in order to also retrieve the LoginID and JobTitle values from the Employee table. Because I put the INTERSECT join in the CTE, the statement can now return the following results:\n\nAs you can see, I’ve gotten around the limitations of the INTERSECT operator and am now returning additional information from one of the tables. I could have also joined the CTE to a different table in order to include additional information. For example, I might have joined what I have here to the Person table to retrieve the employee’s first and last names. The point is, the CTE let’s you be quite flexible when working with the INTERSECT operator; you can still determine which rows match but also return all the data you need, regardless of the source table.\n\nWorking with the EXCEPT Operator\n\nOnce you’ve mastered the INTERSECT operator, you have, for the most part, mastered the EXCEPT operator. As I stated earlier, the EXCEPT operator returns only those rows that do not have a match in the joined table. The important point to remember when using the EXCEPT operator is that it makes a difference which side of the operator you place the query. Only data from the query to the left of the operator (before the operator) is returned. Let’s look at an example to demonstrate how this works.\n\nIn the following statement, I again combine two queries, one that retrieves data from the Employee table and one that retrieves data from the JobCandidate table:\n\nThis statement is nearly identical to the INTERSECT construction you saw in the first two examples, except, of course, for the use of the EXCEPT operator. However, because the query to the left of the operator is retrieving data from the Employee table, the final result set will include data only from that table, and not the JobCandidate table.\n\nThe Employee table, as it turns out, contains 290 rows. As you’ll recall from the previous examples, the two rows in the table with the BusinessEntityID values of 212 and 274 match the two rows in the JobCandidate table that also have BusinessEntityID values of 212 and 274. That means, these two rows should be excluded from the result set of the query above, which is exactly what happens. The query returns 288 rows that have BusinessEntityID values of 1 through 290. However, IDs 212 and 274 are not included in those results.\n\nNow let’s look at what happens when you reverse the order of the queries, as I’ve done in the following example:\n\nNotice that the query that retrieves data from the JobCandidate table now comes first, that is, sits to the left of the EXCEPT operator. The results from this statement, as you would expect, are quite different from the previous example. All that is returned is a single NULL value. In other words, according to the results, the JobCandidate table contains no BusinessEntityID values that are not contained in the Employee table. This is, of course, exactly the case.\n\nAs with the CTE example above, which uses the INTERSECT operator, you can also use CTEs with EXCEPT operators. But as the last example points out, if your CTE returns no data, your main query will also return no data (at least if you’re using an inner join), but that’s true with either operator. Overall, in fact, you’ll find there’s little difference between the INTERSECT and EXCEPT operators, in terms of how you use them. The difference, of course, is in the results. INTERSECT returns rows common to both queries, and EXCEPT returns only rows in the left query. Both operators, however, are useful additions to the types of joins that the UNION and UNION ALL operators provide. You can find more details about the INTERSECT and EXCEPT operators by referring to the topic “EXCEPT and INTERSECT (Transact-SQL)” in SQL Server Books Online. There you’ll find additional information about each operator and additional examples of how to use them."
    },
    {
        "link": "https://geeksforgeeks.org/sql-intersect-except-clause",
        "document": "1. INTERSECT clause : As the name suggests, the intersect clause is used to provide the result of the intersection of two select statements. This implies the result contains all the rows which are common to both the SELECT statements. Syntax :\n\nExample : Table 1 containing Employee Details Table 2 containing details of employees who are provided bonus Query :\n\nResult : 2. EXCEPT clause : contains all the rows that are returned by the first SELECT operation, and not returned by the second SELECT operation. Syntax :\n\nExample : Table 1 containing Employee Details Table 2 containing details of employees who are provided bonus Query :"
    },
    {
        "link": "https://geeksforgeeks.org/sql-server-intersect-and-except-operator",
        "document": "Multiple SQL Queries may return duplicate values in recordsets from each query result. There could be situations when a single resultset is needed to be returned by combining multiple SQL queries. In SQL Server, there are many SET operators like UNION, EXCEPT, and INTERSECT to merge multiple results of select statements to a single result set. The INTERSECT operator is one of them which is used to filter distinct values.\n\nStructured Query Language (SQL) is a powerful tool for managing and manipulating relational databases. In SQL Server, various operators allow you to perform different types of set operations on your data. Two such operators are and , which are used to compare and combine the results of two queries.\n\nThe INTERSECT operator is one of the Set Operators in SQL Server which is used to filter out duplicates and return only distinct rows of data. The INTERSET operator combines two or more SELECT statements and returns a single dataset with common and distinct data between the SELECT statements on the right and the left of the INTERSECT operator.\n• query_specification query_expression is a SELECT statement with or without a where clause.\n• None INTERSECT is the operator used to filter distinct or unique data common to the queries specified.\n\nEXCEPT keyword is an operator that is used to retrieve distinct rows from the left query result set that are not present in the right query result set in a given query. It can be useful in finding the difference between two sets of data. The syntax for the EXCEPT operator is given as follows\n\nExamples of SQL Server INTERSECT and EXCEPT Operator\n\nThere are 3 tables used in the examples below and the queries to create tables and insert data are given below:\n\nExample 1: Identifying Employees Who Also Serve as Managers\n\nIn the above example, there are two tables namely Employees and Managers. Using the INTERSECT operator the resultant dataset will return data of employees who are managers, meaning the names which exists in both Employees and Managers tables.\n\nExample 2: Identifying Employees with Java Technology Who Also Serve as Managers\n\nThe above example has where clause combining 2 SQL Queries, to all employees with Technology 'Java' and are managers.\n\nExample 3: We use EXCEPT Operator to Find the employees in the Employee Table that do not have any Project Assignments\n\nIn the example below, we use EXCEPT operator to find the employees in the Employee table that do not have any project assignments. In the Projects table, we use JOIN to find the employees that have project assignments.\n\nIn SQL Server, the INTERSECT and EXCEPT operators are used to get the common rows of two SELECT statements. The first SELECT statement retrieves the rows that are common to both SELECT statements. The second SELECT statement retrieves different rows that are not common to the two SELECT statements. These operators help to compare and analyze the data between two pairs of results in an SQL query."
    },
    {
        "link": "https://manifold.net/doc/mfd9/union___except___intersect.htm",
        "document": ""
    }
]