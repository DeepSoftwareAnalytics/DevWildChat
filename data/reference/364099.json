[
    {
        "link": "https://devforum.roblox.com/t/how-to-create-npcs-that-use-your-combat-system/2864076",
        "document": "That makes sense, though it is going to be incredibly difficult to do considering Ill have to rewrite like 3k+ lines of code on my local script to fit the server\n\nGuess ive got my work cut out for me, i just need to figure out how to actually write npc logic"
    },
    {
        "link": "https://devforum.roblox.com/t/general-combat-npc-tutorial/1862031",
        "document": "Hello everyone, today I want to update my npc tutorial. This one is going to be much more general and what you should do and not do.\n\nHave you ever wondered how to make a npc that attacks you? Well here’s a tutorial for that! Part 1 - Making the Dummy\n\n First off, let’s create the npcs. For R15 games go to the plugins tab and press this icon in the screenshot to insert a R15 character make sure to un-anchor the root part! Or if you want a R6 character you could insert this model of a R6 character:\n\n https://www.roblox.com/library/8370047840/R6-Dummy-Rig?Category=Models&SortType=Relevance&SortAggregation=AllTime&CreatorId=0&Page=1&Position=7&SearchId=31af5b5c-1b58-4cbb-97ad-2dbca631e70e Part 2 - Scripting Time \n\n Alright scripting time also known as the best time! \n\n So first, create a script inside the dummy/NPC you can name it whatever. So inside the script insert this code. (I won’t be going step by step so I don’t make this to post to long ) -- Follow Script local PathFinding = game:GetService(\"PathfindingService\") local path = PathFinding:CreatePath() local AttackEvent = script.Parent:WaitForChild(\"AttackEvent\") -- Used to attack local debounce = false -- Debounce so it doesn't spam attack local cooldown = 0.5 local maxDistance = 100 -- Max Distance change to your liking local closestPlayer = nil -- Locks to closest player local closestDistance = maxDistance local attackRange = 5 -- Range npc can attack you local Players = game:GetService(\"Players\") local npc = script.Parent local HRP = npc:WaitForChild(\"HumanoidRootPart\") local humanoid = npc:WaitForChild(\"Humanoid\") -- New Path Function function newPath(character) -- Compute the path path:ComputeAsync(HRP.Position, character.HumanoidRootPart.Position) local waypoints = path:GetWaypoints() for i, waypoint in pairs(waypoints) do npc.Humanoid:MoveTo(waypoint.Position + Vector3.new(1, 0, 1)) -- Move to the waypoint position end end -- When damaged move the NPC humanoid:GetPropertyChangedSignal(\"Health\"):Connect(function() while true do for _, player in pairs(Players:GetPlayers()) do local playerRoot = player.Character and player.Character:FindFirstChild(\"HumanoidRootPart\") local playerHumanoid = player.Character and player.Character:FindFirstChild(\"Humanoid\") if playerRoot then if playerHumanoid.Health <= 0 then closestPlayer = nil closestDistance = maxDistance break end if (playerRoot.Position - HRP.Position).Magnitude <= attackRange then AttackEvent:Fire() -- Fire Attacks Event break end if (playerRoot.Position - HRP.Position).Magnitude <= maxDistance then newPath(player.Character) -- Move characters break end end end task.wait() end end) Alright! We got a basic following script! Good job! Now let’s create the attack event! First create a bindable event and put it inside dummy/npc. Call it “AttackEvent.” Now for hit detection. First get the sword it can be a roblox sword or a custom sword it doesn’t matter. So to make it detect the event, instead of the activated just replace it with the event. For example: Also make sure to add an animate script to give the dummy animations. You could get the animate script by searching inside the toolbox. Here’s a video of it in action:\n\n Well this is it hopefully you learned something new. Well, have a nice day and thank you for reading .\n\nNPCs are good for many types of games such as tower defense games, wave games, and much much more. It doesn’t have to be all about fighting NPC. But, in this tutorial I’m going to be talking more about fighting NPC.\n\nSo how should you organize your NPCs? You should always have it in a folder. The more organized the better.\n\nBUT, less is more when scripting them. The less NPC scripts the better. You should always try having only one controller script instead of multiple scripts under each NPC. You can do something like this:\n\nThis is much more efficient since now you have less scripts meaning less lag.\n\nStill lag is still a big problem.\n• I have too much NPCs it’s still lagging!\n\nWhat do you do??? First, I would first recommend Simple Path! It’s easy to use and makes NPCs path find much more smoother.\n\nIf you want more information how it works I recommend checking the github for simple path!\n\nSo perfect! The npc runs smoothly and we have one script controlling all NPCs, perfect! Or is it? we can take it one step farther.\n\nInstead of having all the NPCs run on the server which can be extremely laggy especially if there’s lots of NPCs, why not run it on the client?\n\nInstructions:\n\n Basically copy the whole script and put it in the client. Make sure to move all your modules into Replicated Storage! Modules like Simple Path, Fastcast, and Raycasthitbox works on the client so no worries!\n\nIf you want more information I recommend this awesome video created by @5uphi.\n\nAlso here’s an example if you want. It doesn’t use all the practices, but it shows the differences between client and server npcs.\n\n Place1.rbxl (83.5 KB)\n\nWell that’s all for now! Have fun coding and good luck developers!\n\n – Rapideed/mang"
    },
    {
        "link": "https://devforum.roblox.com/t/how-do-i-make-an-npc-walk-on-the-set-of-tiles-pathfinding/1584710",
        "document": "Hello, so I need an npc to go through the path and it consists out of small tiles, which npc has to do :MoveTo() to. But I don’t know how to make these paths in order, so the NPC walks exactly to each path in the right order.\n\nIf you are still confused, we are able to see this system implemented in to Theme Patk Tycoon 2. The NPC has to basically walk on the selected path.\n\n Media:\n\n\n\nSo, how am I able to implement this? Thank you"
    },
    {
        "link": "https://devforum.roblox.com/t/how-are-npcs-in-games-with-combat-normally-handled/3059277",
        "document": "Alrighty, so I’ve been looking into making NPCs for my game for a while now, but I’ve been putting it off as it’s pretty well known that this is arguably one of the most complex topics you could probably deal with on this platform. Given that no NPC systems are interchangeable between games since every game has different systems, (Unless there’s some open sourced NPC framework that I’m not aware of) you’ll ultimately have to make your own.\n\nBut, since I’ve never done that before, I’m curious as to how games normally handle NPC’s. I’m pretty sure it’s almost a certainty that each of these systems is a tailor made OOP monster of a task to undertake. Since to my understanding, making optimized NPC’s that can interact with a game’s systems without tanking the games performance, is pretty difficult.\n\nI’m mainly asking as to how these systems work usually. Pathfinding is something I can understand as there are plenty of resources on using pathfinding such as SimplePath, but how exactly is pathfinding dealt with when per say, an NPC is targetting an entity within the workspace. Is the path constantly updated every frame? And while they’re pathfinding, are they constantly checking for other factors through conditional logic? That’s what I would assume but given a complex enough game I would imagine this being an absolute bomb on performance.\n\nActual actions aren’t much of a concern for me though. The framework I’m using, WCS, makes it pretty easy to initiate actions on both clients and NPCs, so the divide between server and player inputs isn’t a concern.\n\nBut overall, I cannot comprehend how bigger games are able to make high quality NPC’s with unfathomably complex logic without it being a hinderance to performance. There are plenty of games without crazy NPC logic, like Blox Fruits for example, but I’m leaning towards the quality of my NPC’s, as well as how you even handle decision making.\n\nThe best example I can think of is Deepwoken’s massively complex NPC’s which are pretty impressive, and the server can handle tons of them. (In general I find deepwoken to be a technical herculean feat for several reasons, but the NPC’s are one of the most impressive things I’ve found within it.)"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628",
        "document": "DISCLAIMER: THIS THREAD IS OLD AND OUTDATED, REFER TO THE NEWEST VERSION OF THIS THREAD: How To Use Roblox Pathfinding Service 2.0\n\nHello everyone! This is my first tutorial. Please correct me anything if I taught something wrong.\n\nIn this post, I will be teaching you guys on how to use the Pathfinding service in Roblox! This tutorial is specially for people who are decent at scripting and new to this service. Anyway without ay further ado...\n\nWhat the heck is Pathfinding service? In Roblox, PathfindingService is a service used to find a clear path between 2 points/destination. Imagine an NPC that can walk with this service. Pretty uninteresting right? Well, with PathfindingService, the NPC will find a clear path to walk to it’s destination without getting stuck at blocking obstacles. This will make the NPC smart enough to get to a specific position.\n\nThis is because, as I’ve stated earlier, PathfindingService allows an NPC to find a clear path between 2 destination points. If you get the idea, a clear path means a path with nothing to block the path. You might be asking, why can’t we just use the MoveTo() function from the humanoid instead? This is because MoveTo() function will ONLY find the fastest path, which is a straight line, from one point to an end point. This makes it hard for the NPC to reach because imagine there’s gaps between the path, blocking obstacles, jumping platforms and even more! With PathfindingService, this issue will be resolved.\n\nHow can we use it? Glad you asked! Follow the steps below.\n• Make sure you use a server script for this, and maybe try to parent it in a NPC model so we can script more easily.\n• Remove the code inside it and get the service of it.\n• Now, let’s create some variables for the NPC’s root part, humanoid and the destination/position we want it to walk to. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead.\n• Cool! Now we can start the real stuffs here. We need to create a path so we can tell the NPC to walk to that destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath()\n• Alright, now we need to give the two points to the path variable so that we will successfully create a path between the starting point and the ending point. Okay, you might be a bit confused. But let me explain. We re calling our path variable and then we use a function called ComputeAsync() which will create a clear path between 2 points. The first parameter of the function is the starting point of our path, in this case we use rootPart.Position as the starting point, then we use destination as our ending point of the path, which is the second argument we need to pass in this function. NOTE: IF YOU'RE NOT USING VECTOR3 AS THE DESTINATION, YOU CAN USE A PART'S POSITION AS THE ENDING POINT. MAKE SURE TO ADD .Position !!! WHICH WILL BE LIKE ComputeAsync(rootPart.Position,part.Position).\n• Now that we have computed the path, it will provide a series of waypoints, which we will tell the NPC to move to each waypoint until it reached it’s destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints()\n• Now, we will use a for loop so that we can tell the NPC to move to each waypoint after they’ve reached the previous ones. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints() for i,v in pairs(waypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end Okay, so what we did is, for every waypoint that’s being iterated in the table of waypoints, we tell the NPC to move to that waypoint using MoveTo(). The gaps between each waypoint is small enough for the NPC to walk to the next waypoint in a straight line. Then, you’ll notice there’s an if statement to it. This checks if whether the NPC reaches a waypoint that needs the humanoid to jump or not. Waypoints have a property called Action and this have 2 values, Jump and Walk. The waypoint will determine whether it’s action is either Jump or Walk. So, we use an if statement to check if the action is jump using an enumeration of PathWaypointAction. If it’s true, we will set the humanoid’s jump to true. And this should work now! Play the game and see the magic happens. Due to my trashy laptop, I’m unable to record it working in Roblox Studio. And there you go! You successfully make a smart NPC!\n\nWait! How can we make it so that when it handles blocked paths? This got me hard when I was trying to find a solution of it. While you can actually use path.Blocked event, I can’t manage to find how to use this event to handle this issue. But, the best thing we can solve this issue is to create a new path and compute it constantly. So for this, we will use RunService.Heartbeat as an alternative way for while true do loop. Then, instead of making a script that’s not good-looking, we will create functions which will do a separate job. So we will create a function that creates a path and returns it, then another function which will tell the NPC to move to each waypoints. The key is to tell the script to constantly create a new path, and compute it, as creating a path and compute it only once only keeps that path forever, so if we do this method, it will create a new clear path constantly. So if you want the full code instead of just trying to create the functions by yourself, here it is. NOTE: I wouldn’t recommend you guys to copy this code. Try to be creative and use your brain instead! local pathfinding = game:GetService(\"PathfindingService\") local run = game:GetService(\"RunService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local hum = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local function GetPath(destination) local path = pathfinding:CreatePath() if typeof(destination) == \"Vector3\" then -- This line is untested yet. Please tell me if it works. path:ComputeAsync(rootPart.Position,destination) else path:ComputeAsync(rootPart.Position,destination.Position) end return path end local function WalkToWaypoints(tableWaypoints) for i,v in pairs(tableWaypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end end local function WalkTo(destination) local path = GetPath(destination) if path.Status == Enum.PathStatus.Success then -- the path will return either success as true value or nopath as false value if it's computed. WalkToWaypoints(path:GetWaypoints()) end end run.Heartbeat:Connect(function() WalkTo(destination) end)\n\nThank you for reading my post! Again, please leave feedbacks and any mistakes and corrections under this post. I will update the post if I did anything wrong.\n\nEDIT 1: I made a spelling mistake while spelling humanoid in the scripts. I accidentally spell it hum as humanoid. If you wanna change it, you can use Ctrl + H or Cmd + H while typing in the script to change these spellings immediately. Sorry for the mistake!"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/Path",
        "document": "Path objects store the result of paths created by PathfindingService:CreatePath().\n\nOnce a path object is created, you can call Path:ComputeAsync() with a starting point and ending point. This will attempt to compute a valid path for a character to move along, based on default or custom parameters passed to CreatePath(). If ComputeAsync() successfully finds a path, the Path object will have a Path.Status value of Enum.PathStatus.Success. Otherwise the status will be Enum.PathStatus.NoPath which can occur if there are obstacles between the two points (and no way around) or if the points are inside of solid objects.\n\nIn addition to ComputeAsync(), Path objects have the GetWaypoints() method which returns a list of waypoints representing the points a character should follow in sequence to get from the beginning to the end of the path.\n\nFinally, Path objects can be connected to the Path.Blocked event. This event will fire if, at any time during the path's existence, the path is blocked. Note that this can occur behind a character moving along the path, not just in front of it."
    },
    {
        "link": "https://devforum.roblox.com/t/whats-the-most-efficient-way-to-code-a-combat-system/234963",
        "document": "Hey guys, I’m Ehcode. I’m an aspiring solo developer and my goal is to become a jack of all trades on this amazing platform.Between late 2017 till now, I’ve been learning how to code but I’ve realized that my code usually lacks efficiency and that there is always a better way to things.I finally decided to work on my own game but I’m having a hard time deciding on what’s the most efficient way to code my combat system. here’s a short summary of how my system works:"
    },
    {
        "link": "https://devforum.roblox.com/t/what-do-i-need-to-learn-to-make-a-combat-system-like-yakuza/1677251",
        "document": "These are really broad and give the user no real help towards what they need to know to achieve a combat system.\n\nTo ACTUALLY make a combat system, you’d probably need a bit of knowledge on the following topics. I’ve provided a link for you to follow through to, in case you want to learn about it.\n• Client → Server Model for exploitation prevention and to help replicate attacks\n• Module Scripts to follow an OOP approach and to have scalability, or you could follow a functional/procedural path (Paradigms)\n\nNow, a simple pipeline of how an attack would go through would be something like so:\n\n 1 - The player presses the E key and is picked up by the ContextActionService\n\n 2 - The ContextActionService fires a Remote\n\n 3 - Something on the server picks this request up and checks if it’s a real request\n\n 4 - The server see’s if the player can attack\n\n 5 - A ray/ multiple rays is/ are fired from the attack\n\n 6 - If the ray(s) hit anything, damage plus any other side affects are applied"
    },
    {
        "link": "https://devforum.roblox.com/t/whats-the-most-efficient-way-to-code-a-combat-system/234963/25",
        "document": "I too started learning Roblox Lua by making a simple combat system. An important part of any combat system is snappiness and responsiveness. I suggest you load animations on the client. When they press the mouse, play the animation (via their local script). In general, I reserve the server scripts for verifying attacks/damages and creating/modifying objects that need to be replicated.\n\nFor hit detection, you could attach a listener (.Touched) on the client and verify it with the server, or do it all on the server. In addition to hit detection of .Touched, you can also use ray tracing for some ranged attacks. The roblox wiki elaborates on all this. Hope this points you in the right direction!"
    },
    {
        "link": "https://stackoverflow.com/questions/77077778/cant-figure-out-how-to-make-a-combat-system-on-lua-in-roblox-studio",
        "document": "I am a new programmer and have been working with some of my friends on Roblox. We have been trying to make a game with a fun combat system, but have failed in every attempt, although we're not ready to give up.\n\nWe've tried googling things, searching tutorials on YouTube and have been trying for about a week to get this to work. We can barely get a punch animation to play when our goal is to make a combat system with a normal attack that combos up to 5, a skill that can be used every 15 seconds, and an ultimate ability that charges whenever you hit an enemy. Thank you to anyone that can help, I feel as if I'm in way over my head and I don't really know where to start."
    },
    {
        "link": "https://devforum.roblox.com/t/how-do-i-go-about-making-a-combat-system-like-the-strongest-battlegrounds/2503882",
        "document": "Hey there! I want to make a combat systems, similar to The Strongest Battlegrounds. I am making a One Piece battlegrounds game, and I want these features:\n\nI have my own custom ragdoll feature, but how would I make ragdoll canceling and perfect dodge (like project slayers)\n\nAlso, how would I make a hit-dash?\n\nAny help is Appreciated!"
    }
]