[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list",
        "document": "The following is a list of the reference content for the Windows application programming interface (API) for desktop and server applications.\n\nUsing the Windows API, you can develop applications that run successfully on all versions of Windows while taking advantage of the features and capabilities unique to each version. (Note that this was formerly called the Win32 API. The name Windows API more accurately reflects its roots in 16-bit Windows and its support on 64-bit Windows.)\n\nThe Windows UI API creates and uses windows to display output, prompt for user input, and carry out the other tasks that support interaction with the user. Most applications create at least one window.\n\nThe Diagnostics API enable you to troubleshoot application or system problems and monitor performance.\n\nThe Graphics, multimedia, audio, and video APIs enable applications to incorporate formatted text, graphics, audio, and video.\n\nThe System Services APIs give applications access to the resources of the computer and the features of the underlying operating system, such as memory, file systems, devices, processes, and threads.\n\nThe Security and Identity APIs enable password authentication at logon, discretionary protection for all sharable system objects, privileged access control, rights management, and security auditing.\n\nThe System administration interfaces enable you to install, configure, and service applications or systems.\n\nThe Networking APIs enable communication between applications over a network. You can also create and manage access to shared resources, such as directories and network printers.\n\nThe following are technologies and APIs that are outdated or have been replaced or deprecated from the Windows client and server operating systems.\n• Microsoft UDDI SDK is now included with Microsoft BizTalk Server."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api",
        "document": "The Win32 API reference documentation is presented in several different views. You can browse a list of popular technologies on this page, or you can browse the full list of technologies in the table of contents. To browse all of the headers, see the list at the bottom of the table of contents."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa",
        "document": "Retrieves file system attributes for a specified file or directory.\n\nTo get more attribute information, use the GetFileAttributesEx function.\n\nTo perform this operation as a transacted operation, use the GetFileAttributesTransacted function.\n\nThe name of the file or directory.\n\nBy default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.\n\nIf the function succeeds, the return value contains the attributes of the specified file or directory. For a list of attribute values and their descriptions, see File Attribute Constants.\n\nIf the function fails, the return value is INVALID_FILE_ATTRIBUTES. To get extended error information, call GetLastError.\n\nWhen GetFileAttributes is called on a directory that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory in the volume that the mounted folder associates with the directory. To obtain the file attributes of the associated volume, call GetVolumeNameForVolumeMountPoint to obtain the name of the associated volume. Then use the resulting name in a call to GetFileAttributes. The results are the attributes of the root directory on the associated volume.\n\nIf you call GetFileAttributes for a network share, the function fails, and GetLastError returns ERROR_BAD_NETPATH. You must specify a path to a subfolder on that share.\n\nIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.\n\nSymbolic link behavior—If the path points to a symbolic link, the function returns attributes for the symbolic link.\n\nIf a file is open for modification in a transaction, no other thread can open the file for modification until the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread modifies the file before the transacted thread does, and the file is still open when the transaction attempts to open it, the transaction receives the error\n\nFor an example, see Retrieving and Changing File Attributes."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/fileapi",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Windows_API",
        "document": "The Windows API, informally WinAPI, is the foundational application programming interface (API) that allows a computer program to access the features of the Microsoft Windows operating system in which the program is running. Programs can access API functionality via shared-library technologies or via system-file access.[disputed – discuss]\n\nEach major version of the Windows API has a distinct name that identifies a compatibility aspect of that version. For example, Win32 is the major version of Windows API that runs on 32-bit systems. The name, Windows API, collectively refers to all versions of this capability of Windows.\n\nMicrosoft provides developer support via a software development kit, Microsoft Windows SDK, which includes documentation and tools for building software based on the Windows API.\n\nThis section lists notable services provided by the Windows API.[1]\n\nBase services include features such as the file system, devices, processes, threads, and error handling. These functions reside in , or files on 16-bit Windows, and on 32 and 64 bit Windows. These files reside in the folder on all versions of Windows.[2]\n\nAdvanced services include features beyond the kernel like the Windows registry, shutdown/restart the system (or abort), start/stop/create a Windows service, manage user accounts. These functions reside in and on 32-bit Windows.\n\nThe Graphics Device Interface (GDI) component provides features to output graphics content to monitors, printers, and other output devices. It resides in on 16-bit Windows, and on 32-bit Windows in user-mode. Kernel-mode GDI support is provided by which communicates directly with the graphics driver.[3][4]\n\nThe User Interface component provides features to create and manage screen windows and most basic controls, such as buttons and scrollbars, receive mouse and keyboard input, and other functions associated with the graphical user interface (GUI) part of Windows. This functional unit resides in on 16-bit Windows, and on 32-bit Windows. Since Windows XP versions, the basic controls reside in , together with the common controls (Common Control Library).[5]\n\nThe Common Dialog Box Library provides standard dialog boxes to open and save files, choose color and font, etc. The library resides in a file called on 16-bit Windows, and on 32-bit Windows. It is grouped under the User Interface category of the API.[6]\n\nThe Common Control Library provides access to advanced user interface controls include things like status bars, progress bars, toolbars and tabs. The library resides in a DLL file called on 16-bit Windows, and on 32-bit Windows. It is grouped under the User Interface category of the API.[7]\n\nThe Windows Shell component provides access to the operating system shell. The component resides in on 16-bit Windows, and on 32-bit Windows. The Shell Lightweight Utility Functions are in . It is grouped under the User Interface category of the API.[8][9]\n\nNetwork Services provide access to the various networking abilities of the operating system. Its subcomponents include NetBIOS, Winsock, NetDDE, remote procedure call (RPC) and many more. This component resides in on 32-bit Windows.[10]\n\nThe Internet Explorer (IE) web browser exposes APIs and as such could be considered part of the Windows API. IE has been included with the operating system since Windows 95 OSR2 and has provided web-related services to applications since Windows 98.[11]\n\nThe Windows API is a C language-based API.[12] Functions and data structures are consumable via C syntax by including windows.h, but the API can be consumed via any programming language that can inter-operate with the API data structures and calling conventions for function calls and callbacks.\n\nOf note, the implementation of API functions has been developed in several languages other than C.[a]\n\nDespite the fact that C is not an object-oriented programming (OOP) language, the Windows API is somewhat object-oriented due to its use of handles. Various other technologies from Microsoft and others make this object-oriented aspect more apparent by using an OOP language such as C++ — see Microsoft Foundation Class Library (MFC), Visual Component Library (VCL), GDI+. Of note, Windows 8 provides the Windows API and the WinRT API, which is implemented in C++[13] and is object-oriented by design.[13]\n\nWindows.pas is a Delphi unit that exposes the features of Windows API – the Pascal equivalent of windows.h.[14]\n\nMany Microsoft technologies use the Windows API -- as most software running on Windows does. As middle-ware between Windows API and an application, the following technologies provide some access to Windows API. Some technologies are described as wrapping Windows API, but this is debatable since they don't provide or expose all of the capabilities of Windows API.\n• Microsoft Foundation Class Library (MFC) exposes some of Windows API functionality in C++ classes, and thus allows a more object-oriented way to interact with the API\n• Active Template Library (ATL) is a C++ template library that provides some Windows API access\n• Windows Template Library (WTL) was developed as an extension to ATL, and intended as a smaller alternative to MFC\n• Most application frameworks for Windows provide some access to Windows API; including .NET runtime and Java virtual machine and any other programming languages targeting Windows\n• Various technologies for communicating between components and applications – starting with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the Component Object Model (COM), Automation Objects, ActiveX controls, and the .NET Framework\n\nAlthough almost all Windows programs use the Windows API, on the Windows NT line of operating systems, programs that start early in the Windows startup process use the Native API instead.[15]\n\nThe Windows API has always exposed a large part of the underlying structure of the Windows systems to programmers. This had the advantage of giving them much flexibility and power over their applications, but also creates great responsibility in how applications handle various low-level, sometimes tedious, operations that are associated with a graphical user interface.\n\nFor example, a beginning C programmer will often write the simple \"hello world\" as their first assignment. The working part of the program is only a single printf line within the main subroutine. The overhead for linking to the standard I/O library is also only one line:\n\nCharles Petzold, who wrote several books about programming for the Windows API, said: \"The original hello world program in the Windows 1.0 SDK was a bit of a scandal. HELLO.C was about 150 lines long, and the HELLO.RC resource script had another 20 or so more lines. (...) Veteran programmers often curled up in horror or laughter when encountering the Windows hello-world program.\"[16] Petzold explains that while it was the first Windows sample programs developers were introduced to, it was quite \"fancy\" and more complex than needed. Tired of people ridiculing the length of the sample, he eventually reduced it to a simple MessageBox call.[17]\n\nOver the years, various changes and additions were made to Windows systems, and the Windows API changed and grew to reflect this.[18] The Windows API for Windows 1.0 supported fewer than 450 function calls, whereas modern versions of the Windows API support thousands. However, in general, the interface remained fairly consistent, and an old Windows 1.0 application will still look familiar to a programmer who is used to the modern Windows API.[19]\n\nMicrosoft has made an effort to maintain backward compatibility. To achieve this, when developing new versions of Windows, Microsoft sometimes implemented workarounds[20] to allow compatibility with third-party software that used the prior version in an undocumented or even inadvisable way. Raymond Chen, a Microsoft developer who works on the Windows API, has said: \"I could probably write for months solely about bad things apps do and what we had to do to get them to work again (often in spite of themselves). Which is why I get particularly furious when people accuse Microsoft of maliciously breaking applications during OS upgrades. If any application failed to run on Windows 95, I took it as a personal failure.\"[21]\n\nOne of the largest changes to the Windows API was the transition from Win16 (shipped in Windows 3.1 and older) to Win32 (Windows NT and Windows 95 and up). While Win32 was originally introduced with Windows NT 3.1 and Win32s allowed use of a Win32 subset before Windows 95, it was not until Windows 95 that widespread porting of applications to Win32 began. To ease the transition, in Windows 95, for developers outside and inside Microsoft, a complex scheme of API thunks was used that could allow 32-bit code to call into 16-bit code (for most of Win16 APIs) and vice versa. Flat thunks allowed 32-bit code to call into 16-bit libraries, and the scheme was used extensively inside Windows 95's libraries to avoid porting the whole OS to Win32 in one batch. In Windows NT, the OS was pure 32-bit, except parts for compatibility with 16-bit applications, and only generic thunks were available to thunk from Win16 to Win32, as for Windows 95. The Platform SDK shipped with a compiler that could produce the code needed for these thunks. Versions of 64-bit Windows are also able to run 32-bit applications via WoW64. The SysWOW64 folder located in the Windows folder on the OS drive contains several tools to support 32-bit applications.[22]\n\nEach version of Microsoft Windows contains a version of Windows API, and almost every new version of Microsoft Windows has introduced additions and changes to the Windows API.[23]\n\nThe name, Windows API, refers to essentially the same capability in each version of Windows, but there is another name for this capability that is based on major architectural aspects of the Windows version that contains it. When there was only one version, it was simply called Windows API. Then, when the first major update was made, Microsoft gave it the name Win32 and gave the first version the name Win16. The term Windows API refers to both versions and all subsequently developed major versions.[24]\n• Win16 is in the 16-bit versions of Windows. The functions reside mainly in core files of the OS: kernel.exe (or krnl286.exe or krnl386.exe), user.exe and gdi.exe. Despite the file extension of , such a file is accessed as a DLL.\n• Win32 is in the 32-bit versions of Windows (NT, 95, and later). The functions are implemented in system DLL files including kernel32.dll, user32.dll, and gdi32.dll. Win32 was introduced with Windows NT. In Windows 95, it was initially referred to as Win32c, with c meaning compatibility. This term was later abandoned by Microsoft in favor of Win32.\n• Win32s is an extension for the Windows 3.1x family of Microsoft Windows that implemented a subset of the Win32 API for these systems. The \"s\" stands for \"subset\".\n• Win64 is the version in the 64-bit platforms of the Windows architecture (as of 2021 , x86-64 and AArch64). b 25 26 Both 32-bit and 64-bit versions of an application can be compiled from one codebase, although some older API functions have been deprecated, and some of the API functions that were deprecated in Win32 were removed. All memory pointers are 64-bit by default (the LLP64 model), so porting Win32-compatible source code includes updating for 64-bit pointer arithmetic. 27\n• WinCE is the version in the Windows CE operating system.\n\nThe Wine project provides a Win32 API compatibility layer for Unix-like platforms, between Linux kernel API and programs written for the Windows API. ReactOS goes a step further and aims to implement the full Windows operating system, working closely with the Wine project to promote code re-use and compatibility. DosWin32 and HX DOS Extender are other projects which emulate the Windows API to allow executing simple Windows programs from a DOS command line. Odin is a project to emulate Win32 on OS/2, superseding the original Win-OS/2 emulation which was based on Microsoft code. Other minor implementations include the MEWEL and Zinc libraries which were intended to implement a subset of the Win16 API on DOS (see List of platform-independent GUI libraries).\n\nWindows Interface Source Environment (WISE) was a licensing program from Microsoft which allowed developers to recompile and run Windows-based applications on Unix and Macintosh platforms. WISE SDKs were based on an emulator of the Windows API that could run on those platforms.[28]\n\nEfforts toward standardization included Sun's Public Windows Interface (PWI) for Win16 (see also: Sun Windows Application Binary Interface (Wabi)), Willows Software's Application Programming Interface for Windows (APIW) for Win16 and Win32 (see also: Willows TWIN), and ECMA-234, which attempted to standardize the Windows API bindingly.\n\nTo develop software that uses the Windows API, a compiler must be able to use the Microsoft-specific DLLs listed above (COM-objects are outside Win32 and assume a certain vtable layout). The compiler must either handle the header files that expose the interior API function names, or supply such files.\n\nFor the language C++, Zortech (later Symantec, then Digital Mars), Watcom and Borland have all produced well known commercial compilers that have been used often with Win16, Win32s, and Win32. Some of them supplied memory extenders, allowing Win32 programs to run on Win16 with Microsoft's redistributable Win32s DLL. The Zortech compiler was probably one of the first stable and usable C++ compilers for Windows programming, before Microsoft had a C++ compiler.\n\nFor certain classes of applications, the compiler system should also be able to handle interface description language (IDL) files. Collectively, these prerequisites (compilers, tools, libraries, and headers) are known as the Microsoft Platform SDK. For a time, the Microsoft Visual Studio and Borland's integrated development system were the only integrated development environments (IDEs) that could provide this (although, the SDK is downloadable for free separately from the entire IDE suite, from Microsoft Windows SDK for Windows 7 and .NET Framework 4).\n\nAs of 2016 , the MinGW and Cygwin projects also provide such an environment based on the GNU Compiler Collection (GCC), using a stand-alone header file set, to make linking against the Win32-specific DLLs simple. LCC-Win32 is a C compiler maintained by Jacob Navia, freeware for non-commercial use. Pelles C is a freeware C compiler maintained by Pelle Orinius. Free Pascal is a free software Object Pascal compiler that supports the Windows API. The MASM32 package is a mature project providing support for the Windows API under Microsoft Macro Assembler (MASM) by using custom made or converted headers and libraries from the Platform SDK. Flat assembler FASM allows building Windows programs without using an external linker, even when running on Linux.\n\nWindows specific compiler support is also needed for Structured Exception Handling (SEH). This system serves two purposes: it provides a substrate on which language-specific exception handling can be implemented, and it is how the kernel notifies applications of exceptional conditions such as dereferencing an invalid pointer or stack overflow. The Microsoft/Borland C++ compilers had the ability to use this system as soon as it was introduced in Windows 95 and NT, however the actual implementation was undocumented and had to be reverse engineered for the Wine project and free compilers. SEH is based on pushing exception handler frames onto the stack, then adding them to a linked list stored in thread-local storage (the first field of the thread environment block). When an exception is thrown, the kernel and base libraries unwind the stack running handlers and filters as they are encountered. Eventually, every exception unhandled by the application will be dealt with by the default backstop handler, which pops up the Windows common crash dialog.\n• Linux kernel API – An overview and comparison of the Linux kernel API and ABI.\n• ECMA-234 – ECMA standard for a subset of the Windows API"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-bitmap-flat",
        "document": "Windows GDI+ exposes a flat API that consists of about 600 functions, which are implemented in Gdiplus.dll and declared in Gdiplusflat.h. The functions in the GDI+ flat API are wrapped by a collection of about 40 C++ classes. It is recommended that you do not directly call the functions in the flat API. Whenever you make calls to GDI+, you should do so by calling the methods and functions provided by the C++ wrappers. Microsoft Product Support Services will not provide support for code that calls the flat API directly. For more information on using these wrapper methods, see GDI+ Flat API.\n\nThe following flat API functions are wrapped by the Bitmap C++ class."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/gdiplusheaders/nl-gdiplusheaders-bitmap",
        "document": "The Bitmap class inherits from the Image class. The Image class provides methods for loading and saving vector images (metafiles) and raster images (bitmaps). The Bitmap class expands on the capabilities of the Image class by providing additional methods for creating and manipulating raster images.\n\nThe Bitmap class has these methods."
    },
    {
        "link": "https://stackoverflow.com/questions/39551863/creating-gdi-bitmaps-in-memory-and-then-saving-as-png",
        "document": "I am new to C++ and been having trouble with writing a function using the GDI+ library to create a new bitmap in memory ( so not opening/reading an existing bitmap); then drawing on the bitmap; before saving it to png. In particular, I am having problems with the bitmap creation and saving code. I am constrained to using codeblocks and I can't use visual studios, even if I wanted to. The code is as follows:\n\nThe issues I am having are as follows:\n• None The 'saving' code does not compile and gives the error message \"'GetEncoderClsid' was not declared in this scope\". However, I got this direct from the Microsoft website here. I don't think this is the proper way of converting to png but I dont know an alternative way?\n• None When the code is compiled and run (by commenting out the saving code), it then crashes on the line \"Bitmap *myBitmap = new Bitmap(width, height, PixelFormatCanonical);\" and gives an error message saying my executable has stopped working.\n\nI have added the 'gdi32' linker library and also '-lgdiplus' as a linker option. Also, I have used this website to help with the gdi stuff although the section on bitmaps only deals with loading existing bitmaps (not creating new ones in memory)\n\nI am totally lost on what to do, so any help or advice on this matter is much appreciated."
    },
    {
        "link": "https://vbforums.com/showthread.php?896937-GDI-bitmap-vs-GDI-image",
        "document": "I think you might be pushing the container analogy. It seems to really be about inheritance.\n\n \n\n More likely what we have behind the handle is some sort of struct with a header indicating \"type\" information and then a set of pointers to other things like some equivalent of BITMAPINFO and the raw bits and such.\n\n \n\n The Flat API is so close to the inner workings that we're probably lucky it was ever documented at all, and thus so poorly. There just isn't much aside from a brief description and a link to the docs on the related C++ API class for us to puzzle over.\n\n \n\n I suspect Microsoft expected C programmers to gut through using the C++ API as well. That drastically slowed adoption, so the Flat API got documented, er, described, er, listed out... mainly for them.\n\n \n\n The C++ API docs do have snippets like this though:"
    },
    {
        "link": "https://ninjaone.com/blog/a-gdi-tutorial-for-beginners",
        "document": "GDI+ is an enhanced version of the Windows Graphics Device Interface (GDI). GDI+ was introduced with Windows XP and later versions and provides more advanced graphics capabilities. It’s built upon the foundation of GDI, offering improved performance and a richer set of graphical functions for developers.\n\nIf you have ever asked, “What is GDI+?” it’s an API designed to simplify the creation and manipulation of graphical content. GDI+ offers improved 2D graphics rendering over GDI, and better support for gradient fills, alpha blending and anti-aliasing. This results in smoother and more visually appealing graphics. Additionally, GDI+ enhances text rendering by supporting advanced typography features like kerning, ligatures, and complex script processing.\n\nGDI+ is particularly useful for applications that perform complex image-processing tasks. It supports image scaling, cropping, rotation, and format conversion, meaning you can easily manipulate images within your application without relying on external libraries. This means you can draw sophisticated paths and shapes and create complex designs and graphics.\n\nAnother advantage of GDI+ is its compatibility with existing GDI-based applications. While GDI+ offers more advanced features, it maintains backward compatibility. This gives it a smoother transition and integration with older systems and makes GDI+ a practical choice for modernizing legacy applications.\n\nYou should understand its key components to use GDI+ for graphics rendering effectively and provide a flexible and powerful graphical subsystem.\n\nGDI+ provides a set of graphics classes that form the core of its functionality. These classes handle various graphical tasks, such as drawing shapes, rendering text, and managing images. The Graphics class, for example, is central to GDI+ and provides methods for drawing lines, curves, shapes, and text. There are other classes such as the Pen class to draw lines a specific width and style and the Font class to define font type, size, and style attributes.\n\nDrawing surfaces in GDI+ refer to the areas where graphics are rendered. These surfaces can be anything from a window or a control to an off-screen bitmap. The Graphics class works with these surfaces to perform drawing operations.\n\nDrawing surfaces lets you render graphics directly to the screen or create complex images in memory before displaying them. This flexibility allows for more efficient and effective graphics rendering in your applications.\n\nGDI+ excels in image handling, providing advanced capabilities for working with images. The Image and Bitmap classes are fundamental as they allow you to load, manipulate, and save images in various formats.\n\nGDI+ supports operations such as scaling, rotating, cropping, and converting image formats which make it easier to manage and display images within your applications. Features like transparency and alpha blending are also supported and enable the creation of more visually appealing graphics.\n\nHow to use GDI+ for graphics rendering\n\nHere are some steps to follow to use GDI+ to render graphics for your applications:\n• Include the necessary headers and libraries.\n• In a C++ project, this typically means including the Gdiplus.h header and linking against the Gdiplus.lib library.\n• To draw on a window or control, create a Graphics object associated with the device context of the drawing surface.\n• This allows rendering operations directly on the specified surface.\n• Create a Pen object to define the color and style of the outline.\n• Use the DrawLine method of the Graphics class to draw a line on the surface.\n• Similarly, use the DrawRectangle and DrawEllipse methods to render rectangles and ellipses.\n• Create a Font object that specifies the font family, size, and style.\n• Use the DrawString method of the Graphics class to draw text on the surface with the specified font and brush.\n\nDespite the emergence of newer graphical frameworks, GDI+ remains a viable option for many developers. Microsoft continues to support it and it’s included in the Windows operating system. If you are wondering, “Is GDI+ still usable?” the answer is yes, particularly for certain types of applications and scenarios.\n\nGDI+ is still in use because of its compatibility with older systems and applications. Many legacy applications were built using GDI+ and maintaining compatibility is important for businesses that rely on these applications. GDI+ allows you to update or enhance existing software without completely rewriting it.\n\nAdditionally, it is well-suited for applications that require detailed 2D graphics rendering, advanced text handling, and image processing.\n\nIt is important to remember that while GDI+ is still usable, it may not be the best choice for all new developments. Newer graphical interfaces like Direct2D and DirectWrite provide more modern features, better performance, and enhanced security, which might be a better choice for many of your projects.\n\nUsing GDI+ offers several benefits that make it a valuable tool for developers working on Windows applications. These benefits include:\n• Versatility in graphics rendering: GDI+ provides a versatile platform for rendering 2D graphics. It allows you to draw lines, shapes, text, and images with ease while advanced features let you create smooth and visually appealing graphics.\n• Simplified image processing: GDI+ supports various image formats and provides tools to scale, crop, and convert images, which simplifies the process of manipulating images within your application.\n• Integration with Windows applications: GDI+ integrates seamlessly with Windows applications and allows you to enhance graphical capabilities without significant code changes. Its compatibility with the Win32 API ensures that you can use GDI+ with other Windows technologies.\n\nGDI+ is widely used in various practical applications, showcasing its flexibility and capabilities in different domains. Here are some key areas where GDI+ proves to be particularly useful:\n\nGDI+ is an excellent choice for designing user interfaces. Its ability to render high-quality graphics and text makes it ideal for creating visually appealing and intuitive interfaces.\n\nYou can use GDI+ to draw custom controls, design intricate menus, and enhance the overall look and feel of your application. These advanced imaging capabilities let you integrate detailed images and icons, further enriching the user experience.\n\nWhile not typically associated with high-end gaming, GDI+ can be effectively used in casual game development. Its straightforward API allows you to handle basic graphics rendering tasks such as drawing sprites, handling animations, and managing game states.\n\nIt’s also suitable for developing simple 2D games or prototypes, where ease of use and quick development are more important than utilizing the latest graphical technologies.\n\nGDI+ excels in creating detailed and interactive data visualizations. Whether you need to generate charts, graphs, or custom visual representations of data, GDI+ provides the tools necessary to produce clear and informative graphics. Its capabilities in handling shapes, colors, and text allow you to create dynamic and responsive visualizations that help users interpret complex data sets.\n\nIn the right settings, GDI+ offers a rich feature set with advanced capabilities to produce clear and informative graphics that enhance the user experience and improve data interpretation. This makes it an invaluable tool for many applications including business intelligence, scientific research, and educational software."
    },
    {
        "link": "https://stackoverflow.com/questions/56229863/how-do-i-properly-link-this-gdi-example-to-a-library-file",
        "document": "I copied an example from Microsoft to display a line using GDI+ but I got some errors that have to do with the linker not being set up right for 'gdiplus.lib'. I got these errors:\n\nHow do I set up this program to work right?\n\nI tried putting the folder that contained gdiplus.lib by right clicking the project (using netbeans) and clicking properties>linker>additional library directories>\"C:\\…\\\". I also tried putting gdiplus.lib in 'additional dependencies' in the same window.\n\nI know java very well and am just starting out with c++ and really just need a graphics example to study before porting my programs."
    },
    {
        "link": "https://bloomfield.online/posts/using-gdi-plus-in-cpp-win32-programming",
        "document": "If you do any Win32 programming in C++ then I strongly recommend you learn about GDI+. Although it’s been around for a while now, it doesn’t seem to be well known. It can be great to have on hand even just to illustrate tests and prototypes though.\n\nAs it’s object-oriented, it’s much nicer and easier to use than the basic C-style GDI that used to be the norm. It also provides a lot of additional functionality which otherwise was not possible (or at least not easy) with the regular GDI functions alone. For example, proper alpha blending, matrix transformations, file input/output, and loads more. It’s quite easy to setup too.\n\nOne thing to be aware of first: GDI+ requires Unicode to be enabled. That means that all string literals need to be preceded by or encased in the macro. It also means that you might find you need to change any string classes or functions. It can be a nightmare to port existing code, but it’s alright once you get there (or if you’re starting from scratch).\n\nI’m using Visual C++ Express Edition 2008, which is free to download and use. The best thing to do is setup a simple windows application first. Just create a basic window, and your regular message pump/handler.\n\nNext, you need to make sure Unicode is enabled for your code. To do that, go into your project properties page, select “C/C++” → “Preprocessor”, and beside “Preprocessor Definitions”, add “UNICODE”. Do this for Debug and Release modes, or whatever your configurations are.\n\nAfter that, you need to link to the Gdiplus library. Still in Project Properties, go to “Linker” → “Input”, and beside “Additional Dependencies”, add “gdiplus.lib”. (Once again, do it for all configurations.)\n\nNow you need to add the code to initialise and cleanup the GDI+ system. Put the following code somewhere near the start of your WinMain function (before you create any windows):\n\nNext, put the following code somewhere near the end of your WinMain function, after all other GDI+ objects have been deleted or fallen out of scope:\n\nFinally, somewhere near the top of your source code file(s) where you will be using GDI+, you’ll want to put this:\n\nHow to use it\n\nYou’ll usually want to use GDI+ in your window’s “paint” event (although it can be used to write out to files too if you want). The main class you’ll be working with is the class which handles most of your drawing.\n\nYou have to start by getting a object linked to the device context of your window so it can draw to it safely. There’s lots of ways to handle a paint event, but I’ll follow my preferred approach here (remember to make sure you’re window area is invalidated before doing this):\n\nJust like with the regular GDI, you draw and paint using pens and brushes, but thankfully these are much easier. We will fill in a rectangle with a red brush, and draw a green circle inside it:\n\nFinally, we need to tell our window to finish painting now (this bit isn’t GDI+):\n\nAs you can see, it’s fairly easy to setup and use GDI+. I recommend looking at Microsoft’s GDI+ documentation to help you get going."
    },
    {
        "link": "https://stackoverflow.com/questions/5083610/c-cant-compile-dll-using-gdi",
        "document": "Lines like are dangerous in that they pull everything from that namespace into the current namespace. This can lead to problems linking when you're building a DLL.\n\nIt's also possible that one of those headers is using the same\n\nBut a sampling of the first few error messages would make it a lot easier for people to help you."
    },
    {
        "link": "https://ninjaone.com/blog/a-gdi-tutorial-for-beginners",
        "document": "GDI+ is an enhanced version of the Windows Graphics Device Interface (GDI). GDI+ was introduced with Windows XP and later versions and provides more advanced graphics capabilities. It’s built upon the foundation of GDI, offering improved performance and a richer set of graphical functions for developers.\n\nIf you have ever asked, “What is GDI+?” it’s an API designed to simplify the creation and manipulation of graphical content. GDI+ offers improved 2D graphics rendering over GDI, and better support for gradient fills, alpha blending and anti-aliasing. This results in smoother and more visually appealing graphics. Additionally, GDI+ enhances text rendering by supporting advanced typography features like kerning, ligatures, and complex script processing.\n\nGDI+ is particularly useful for applications that perform complex image-processing tasks. It supports image scaling, cropping, rotation, and format conversion, meaning you can easily manipulate images within your application without relying on external libraries. This means you can draw sophisticated paths and shapes and create complex designs and graphics.\n\nAnother advantage of GDI+ is its compatibility with existing GDI-based applications. While GDI+ offers more advanced features, it maintains backward compatibility. This gives it a smoother transition and integration with older systems and makes GDI+ a practical choice for modernizing legacy applications.\n\nYou should understand its key components to use GDI+ for graphics rendering effectively and provide a flexible and powerful graphical subsystem.\n\nGDI+ provides a set of graphics classes that form the core of its functionality. These classes handle various graphical tasks, such as drawing shapes, rendering text, and managing images. The Graphics class, for example, is central to GDI+ and provides methods for drawing lines, curves, shapes, and text. There are other classes such as the Pen class to draw lines a specific width and style and the Font class to define font type, size, and style attributes.\n\nDrawing surfaces in GDI+ refer to the areas where graphics are rendered. These surfaces can be anything from a window or a control to an off-screen bitmap. The Graphics class works with these surfaces to perform drawing operations.\n\nDrawing surfaces lets you render graphics directly to the screen or create complex images in memory before displaying them. This flexibility allows for more efficient and effective graphics rendering in your applications.\n\nGDI+ excels in image handling, providing advanced capabilities for working with images. The Image and Bitmap classes are fundamental as they allow you to load, manipulate, and save images in various formats.\n\nGDI+ supports operations such as scaling, rotating, cropping, and converting image formats which make it easier to manage and display images within your applications. Features like transparency and alpha blending are also supported and enable the creation of more visually appealing graphics.\n\nHow to use GDI+ for graphics rendering\n\nHere are some steps to follow to use GDI+ to render graphics for your applications:\n• Include the necessary headers and libraries.\n• In a C++ project, this typically means including the Gdiplus.h header and linking against the Gdiplus.lib library.\n• To draw on a window or control, create a Graphics object associated with the device context of the drawing surface.\n• This allows rendering operations directly on the specified surface.\n• Create a Pen object to define the color and style of the outline.\n• Use the DrawLine method of the Graphics class to draw a line on the surface.\n• Similarly, use the DrawRectangle and DrawEllipse methods to render rectangles and ellipses.\n• Create a Font object that specifies the font family, size, and style.\n• Use the DrawString method of the Graphics class to draw text on the surface with the specified font and brush.\n\nDespite the emergence of newer graphical frameworks, GDI+ remains a viable option for many developers. Microsoft continues to support it and it’s included in the Windows operating system. If you are wondering, “Is GDI+ still usable?” the answer is yes, particularly for certain types of applications and scenarios.\n\nGDI+ is still in use because of its compatibility with older systems and applications. Many legacy applications were built using GDI+ and maintaining compatibility is important for businesses that rely on these applications. GDI+ allows you to update or enhance existing software without completely rewriting it.\n\nAdditionally, it is well-suited for applications that require detailed 2D graphics rendering, advanced text handling, and image processing.\n\nIt is important to remember that while GDI+ is still usable, it may not be the best choice for all new developments. Newer graphical interfaces like Direct2D and DirectWrite provide more modern features, better performance, and enhanced security, which might be a better choice for many of your projects.\n\nUsing GDI+ offers several benefits that make it a valuable tool for developers working on Windows applications. These benefits include:\n• Versatility in graphics rendering: GDI+ provides a versatile platform for rendering 2D graphics. It allows you to draw lines, shapes, text, and images with ease while advanced features let you create smooth and visually appealing graphics.\n• Simplified image processing: GDI+ supports various image formats and provides tools to scale, crop, and convert images, which simplifies the process of manipulating images within your application.\n• Integration with Windows applications: GDI+ integrates seamlessly with Windows applications and allows you to enhance graphical capabilities without significant code changes. Its compatibility with the Win32 API ensures that you can use GDI+ with other Windows technologies.\n\nGDI+ is widely used in various practical applications, showcasing its flexibility and capabilities in different domains. Here are some key areas where GDI+ proves to be particularly useful:\n\nGDI+ is an excellent choice for designing user interfaces. Its ability to render high-quality graphics and text makes it ideal for creating visually appealing and intuitive interfaces.\n\nYou can use GDI+ to draw custom controls, design intricate menus, and enhance the overall look and feel of your application. These advanced imaging capabilities let you integrate detailed images and icons, further enriching the user experience.\n\nWhile not typically associated with high-end gaming, GDI+ can be effectively used in casual game development. Its straightforward API allows you to handle basic graphics rendering tasks such as drawing sprites, handling animations, and managing game states.\n\nIt’s also suitable for developing simple 2D games or prototypes, where ease of use and quick development are more important than utilizing the latest graphical technologies.\n\nGDI+ excels in creating detailed and interactive data visualizations. Whether you need to generate charts, graphs, or custom visual representations of data, GDI+ provides the tools necessary to produce clear and informative graphics. Its capabilities in handling shapes, colors, and text allow you to create dynamic and responsive visualizations that help users interpret complex data sets.\n\nIn the right settings, GDI+ offers a rich feature set with advanced capabilities to produce clear and informative graphics that enhance the user experience and improve data interpretation. This makes it an invaluable tool for many applications including business intelligence, scientific research, and educational software."
    },
    {
        "link": "https://forums.codeguru.com/showthread.php?376698-GDI-via-dynamic-linking",
        "document": "\n• Hi all:\n\n \n\n \n\n I'm new to GDI+. Can someone tell me if it's possible to use GDI+ via dynamic linking. If yes, then how?\n\n \n\n My problem is that I need to use it in my program for a simple drawing, which has nothing to do with the main purpose of the program, but it statically links it to GDIPLUS.DLL, which won't let it run on earlier versions of Windows.\n\n \n\n And one more thing, I'm not using MFC.\n\n \n\n Thanks in advance.\n• First of all you have to add\n\n somewhere in your source code. Be sure \"gdiplus.lib\" location is added in \"Directories\" option, else write full path and file name in pragma comment.\n\n Second, include <gdiplus.h>.\n\n If your API has not defined ULONG_PTR, then define it yourself. Also include <objbase.h> before gdiplus.h:\n\n Further you have to initialize GDI+ by calling GdiplusStartup.\n\n Next, enjoy... \n\n \n\n Note also that you have to redistribute gdiplus.dll if the target system is older than Windows XP (best place for it is in your application directory).\n\n \n\n Attached here is a \"Hello World\" Win32 appication transformed in a GDI+ one. \n\n Search for comments to see what I have added.\n\n \n\n \n\n PS. Just asside remark: I have never heard until now about an application \"statically linked with GDI+\". Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• [...] but it statically links it to GDIPLUS.DLL, which won't let it run on earlier versions of Windows. And to clarify a little.\n\n An application is dinamically linked to a DLL, as long as DLL means Dynamic-Link Library.\n\n \n\n However I hope that my previous hints can help you to solve the problem. Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• Thanks for your example & explanation. What I actually meant by \"dynamic\" linking is this:\n\n \n\n Consider this situation -- you need to call SetSuspendState() API available on Windows 98 and later. You can call it two ways:\n\n \n\n (1) Static Linking\n\n //In the header #include <Powrprof.h> ... //When in use SetSuspendState(TRUE, TRUE, TRUE); (2) Dynamic Linking\n\n //During code initialization HMODULE hPwrProf; FARPROC pfnSetSuspendState = NULL; hPwrProf = LoadLibrary(\"powrprof.dll\"); if(hPwrProf) { pfnSetSuspendState = GetProcAddress(hPwrProf, \"SetSuspendState\"); } ... //When in use if(pfnSetSuspendState) (reinterpret_cast<BOOLEAN (WINAPI *)(BOOLEAN, BOOLEAN, BOOLEAN)> (pfnSetSuspendState))(TRUE, TRUE, TRUE); The principle difference is that code #1, although being simpler to program, will make the whole app incompatible with Windows 95 -- when someone attempts to load it there they'll see an error message, something like this: \"A required DLL file, PowrProf.dll was not found.\"\n\n \n\n That is what I am trying to avoid with GDI+. Any suggestions???\n• Anyway and anyhow, no matter if you use LoadLibrary + GetProcAddress or something else GDI+ does not work on Windows 95 platform .\n\n Anyway and anyhow, no matter if [...]\n\n GDIPLUS.DLL is included Windows XP and the Windows Server 2003.\n\n You have to redistribute (ship with your application) GDIPLUS.DLL for: Windows NT 4.0 SP6, Windows 2000, Windows 98, and Windows ME. GDIPLUS.DLL is included Windows XP and the Windows Server 2003.You have to redistribute (ship with your application) GDIPLUS.DLL for: Windows NT 4.0 SP6, Windows 2000, Windows 98, and Windows ME. I have almost quoted that from HERE.\n\n \n\n Do as I said, deliver GDIPLUS.DLL together with your application (put it in the application folder), and all will be OK (except in case of Windows 95).\n\n Anyhow, LoadLibrary + GetProcAddress do not help you anyway if GDIPLUS.DLL is not on the computer. Last edited by ovidiucucu; February 21st, 2006 at . Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• Well, I agree that GDI+ won't work on Windows 95 but my point is that even if I supply that GDIPLUS.DLL in a folder for my app the static linking with GDI+ won't let the whole app run on Windows 95 and a user will see a simple system error message -- which is not good!\n\n \n\n You see the app has nothing to do with graphics and GDI+, all I need it for is to save a logo as a PNG or TIFF file. If this functionality is not present on Windows 95 I still want my app to run. You see my point?\n• Well, on your way, you can use GDI+ Flat API with LoadLibrary/GetProcAddress. Eventually, you can build your own \"Win95 safe\" classes around them.\n\n Here is a little example of loading an image from a file:\n\n However, it's not guaranteed that gdiplus.dll it's present or not on whatever computer. \n\n On Windows 95, initially it's not, but never know, somebody can put it there.\n\n In that case both LoadLibrary and GetProcAddress will succeed and the result is not predictable (most possible your program will harmfully crash).\n\n So, I would like to suggest safer alternatives:\n• Determine Windows Version and Edition. If results an OS which does not support GDI+ do not call GDI+ stuff.\n• Build different project configurations for GDI+ supported and not. In \"Preprocessor directives\" project settings field add for example GDIPLUS_SUPPORTED constant for the configuration which must support GDI+. Then, in your code\n\n Last edited by ovidiucucu; February 22nd, 2006 at . Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• Yeah, thanks. I thought to do it this way.\n• Hey, just for the information I was able to compile GDI+ project via dynamic linking to GDIPLUS.DLL. I updated your sample code and attached it here.\n\n \n\n The way to link to GDI+ dynamically is to simply \"unwrap\" Gdiplus class methods by stepping into them with debugger, and also not to use \"gdiplus.lib\" while linking.\n\n \n\n One interesting thing is that this sample worked under Windows 95 for me (provided I copy GDIPLUS.DLL into the app's folder.)\n• Usually a software manufacturer has some good reasons to not recommend whatever product for whatever target operating system. \n\n However, in your particular case of using only a small subset of functions, if it works on Windows 95, that's good (cannot test it but I believe you ).\n\n And I can bet there is no reason to not work also the \"static\" linking at build time. \n\n \n\n BTW. Nice example. Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• Just an FYI guys, the MSVC linker has an option called '/DELAYLOAD:{dll name}'. Basically, this tells the app NOT to load implicitly linked DLLs at app startup time. It loads the DLL when a function from that DLL is needed.\n\n \n\n Viggy\n• If it's just FOI, we'll keep it secret. Promise. Ovidiu\n\n \"When in Rome, do as Romans do.\" \n\n My latest articles: https://codexpertro.wordpress.com/\n• And I can bet there is no reason to not work [on Windows 95] as the \"static\" linking at build time. Agree. But again, the main purpose of compiling code like in this sample is to get rid of GDIPLUS.DLL dependency in case it is insignificant for the project. Moreover the DLL itself is 1.5 MB in size and I don't know if I would want to include it in the installation.\n\n \n\n Now regarding delayed loading of DLLs. I understand that this is an \"easy fix\" -- simply add two linker directives and it's done. Here is the major downside: You cannot control error messages that will be shown for the user, and your app won't know if DLL is loaded or not.\n\n \n\n Moreover in the updated sample I attached here, the static built with delayed loading of gdiplus.dll crashes on Windows 95 for me. Try it yourself. (I could not isolate that dll in Windows XP, so I assume it will always work there.)\n\n \n\n To build it as \"static\" linking to GDI+ un-comment the following line in StdAfx.h file:\n\n \n\n //#define DELAY_LOAD_GDIPLUS\n• I believe the correct terminology is \"implicit\" linking (this is when you link with the proxy .lib), and \"explicit\" linking.\n\n \n\n Well, my point was more of do the same thing your doing now (wrap all calls to GDI+ objects), but you can remove all the calls to \"LoadLibrary\" and \"GetProcAddress\". Maybe. I've never done this, so, YMMV.\n\n \n\n Viggy\n• You may not post new threads\n• You may not post replies\n• You may not post attachments\n• You may not edit your posts\n\n\n\n\n\n\n\n \n\n \n\n Click Here to Expand Forum to Full Width \n\n \n\n * The Best Reasons to Target Windows 8\n\n Learn some of the best reasons why you should seriously consider bringing your Android mobile development expertise to bear on the Windows 8 platform.\n• * Porting from Android to Windows 8: The Real Story\n\n Do you have an Android application? How hard would it really be to port to Windows 8?\n• * Guide to Porting Android Applications to Windows 8\n\n If you've already built for Android, learn what do you really need to know to port your application to Windows Phone 8.\n• * HTML5 Development Center\n\n Our portal for articles, videos, and news on HTML5, CSS3, and JavaScript\n• * Windows App Gallery\n\n See the Windows 8.x apps we've spotlighted or submit your own app to the gallery!"
    }
]