[
    {
        "link": "https://yara.readthedocs.io/en/stable/writingrules.html",
        "document": "YARA rules are easy to write and understand, and they have a syntax that resembles the C language. Here is the simplest rule that you can write for YARA, which does absolutely nothing:\n\nEach rule in YARA starts with the keyword followed by a rule identifier. Identifiers must follow the same lexical conventions of the C programming language, they can contain any alphanumeric character and the underscore character, but the first character cannot be a digit. Rule identifiers are case sensitive and cannot exceed 128 characters. The following keywords are reserved and cannot be used as an identifier:\n\nRules are generally composed of two sections: strings definition and condition. The strings definition section can be omitted if the rule doesn't rely on any string, but the condition section is always required. The strings definition section is where the strings that will be part of the rule are defined. Each string has an identifier consisting of a $ character followed by a sequence of alphanumeric characters and underscores, these identifiers can be used in the condition section to refer to the corresponding string. Strings can be defined in text or hexadecimal form, as shown in the following example:\n\nText strings are enclosed in double quotes just like in the C language. Hex strings are enclosed by curly brackets, and they are composed by a sequence of hexadecimal numbers that can appear contiguously or separated by spaces. Decimal numbers are not allowed in hex strings.\n\nThe condition section is where the logic of the rule resides. This section must contain a boolean expression telling under which circumstances a file or process satisfies the rule or not. Generally, the condition will refer to previously defined strings by using their identifiers. In this context the string identifier acts as a boolean variable which evaluate to true if the string was found in the file or process memory, or false if otherwise.\n\nThere are three types of strings in YARA: hexadecimal strings, text strings and regular expressions. Hexadecimal strings are used for defining raw sequences of bytes, while text strings and regular expressions are useful for defining portions of legible text. However text strings and regular expressions can be also used for representing raw bytes by mean of escape sequences as will be shown below. Hexadecimal strings allow four special constructions that make them more flexible: wild-cards, not operators, jumps, and alternatives. Wild-cards are just placeholders that you can put into the string indicating that some bytes are unknown and they should match anything. The placeholder character is the question mark (?). Here you have an example of a hexadecimal string with wild-cards: As shown in the example the wild-cards are nibble-wise, which means that you can define just one nibble of the byte and leave the other unknown. Starting with version 4.3.0, you may specify that a byte is not a specific value. For that you can use the not operator with a byte value: In the example above we have a byte prefixed with a tilde (~), which is the not operator. This defines that the byte in that location can take any value except the value specified. In this case the first string will only match if the byte is not 00. The not operator can also be used with nibble-wise wild-cards, so the second string will only match if the second nibble is not zero. Wild-cards and not operators are useful when defining strings whose content can vary but you know the length of the variable chunks, however, this is not always the case. In some circumstances you may need to define strings with chunks of variable content and length. In those situations you can use jumps instead of wild-cards: In the example above we have a pair of numbers enclosed in square brackets and separated by a hyphen, that's a jump. This jump is indicating that any arbitrary sequence from 4 to 6 bytes can occupy the position of the jump. Any of the following strings will match the pattern: Any jump [X-Y] must meet the condition 0 <= X <= Y. In previous versions of YARA both X and Y must be lower than 256, but starting with YARA 2.0 there is no limit for X and Y. If the lower and higher bounds are equal you can write a single number enclosed in brackets, like this: The above string is equivalent to both of these: Starting with YARA 2.0 you can also use unbounded jumps: The first one means , the second one means . There are also situations in which you may want to provide different alternatives for a given fragment of your hex string. In those situations you can use a syntax which resembles a regular expression: This rule will match any file containing or . But more than two alternatives can be also expressed. In fact, there are no limits to the amount of alternative sequences you can provide, and neither to their lengths. As can be seen also in the above example, strings containing wild-cards are allowed as part of alternative sequences. As shown in previous sections, text strings are generally defined like this: This is the simplest case: an ASCII-encoded, case-sensitive string. However, text strings can be accompanied by some useful modifiers that alter the way in which the string will be interpreted. Those modifiers are appended at the end of the string definition separated by spaces, as will be discussed below. Text strings can also contain the following subset of the escape sequences available in the C language: In all versions of YARA before 4.1.0 text strings accepted any kind of unicode characters, regardless of their encoding. Those characters were interpreted by YARA as raw bytes, and therefore the final string was actually determined by the encoding format used by your text editor. This never meant to be a feature, the original intention always was that YARA strings should be ASCII-only and YARA 4.1.0 started to raise warnings about non-ASCII characters in strings. This limitation does not apply to strings in the metadata section or comments. See more details [here](https://github.com/VirusTotal/yara/wiki/Unicode-characters-in-YARA) Text strings in YARA are case-sensitive by default, however you can turn your string into case-insensitive mode by appending the modifier at the end of the string definition, in the same line: With the modifier the string foobar will match Foobar, FOOBAR, and fOoBaR. This modifier can be used in conjunction with any modifier, except , and . The modifier can be used to search for strings encoded with two bytes per character, something typical in many executable binaries. For example, if the string \"Borland\" appears encoded as two bytes per character (i.e. ), then the following rule will match: However, keep in mind that this modifier just interleaves the ASCII codes of the characters in the string with zeroes, it does not support truly UTF-16 strings containing non-English characters. If you want to search for strings in both ASCII and wide form, you can use the modifier in conjunction with , no matter the order in which they appear. The modifier can appear alone, without an accompanying modifier, but it's not necessary to write it because in absence of the string is assumed to be ASCII by default. The modifier can be used to search for strings with a single byte XOR applied to them. The following rule will search for every single byte XOR applied to the string \"This program cannot\" (including the plaintext string): The above rule is logically equivalent to: rule XorExample2 { strings: $xor_string_00 = \"This program cannot\" $xor_string_01 = \"Uihr!qsnfs`l!b`oonu\" $xor_string_02 = \"Vjkq\\\"rpmepco\\\"acllmv\" // Repeat for every single byte XOR condition: any of them } You can also combine the modifier with and modifiers. For example, to search for the and versions of a string after every single byte XOR has been applied you would use: The modifier is applied after every other modifier. This means that using the and together results in the XOR applying to the interleaved zero bytes. For example, the following two rules are logically equivalent: rule XorExample4 { strings: $xor_string = \"This program cannot\" xor wide condition: $xor_string } rule XorExample4 { strings: $xor_string_00 = \"T\\x00h\\x00i\\x00s\\x00 \\x00p\\x00r\\x00o\\x00g\\x00r\\x00a\\x00m\\x00 \\x00c\\x00a\\x00n\\x00n\\x00o\\x00t\\x00\" $xor_string_01 = \"U\\x01i\\x01h\\x01r\\x01!\\x01q\\x01s\\x01n\\x01f\\x01s\\x01`\\x01l\\x01!\\x01b\\x01`\\x01o\\x01o\\x01n\\x01u\\x01\" $xor_string_02 = \"V\\x02j\\x02k\\x02q\\x02\\\"\\x02r\\x02p\\x02m\\x02e\\x02p\\x02c\\x02o\\x02\\\"\\x02a\\x02c\\x02l\\x02l\\x02m\\x02v\\x02\" // Repeat for every single byte XOR operation. condition: any of them } Since YARA 3.11, if you want more control over the range of bytes used with the modifier use: The above example will apply the bytes from 0x01 to 0xff, inclusively, to the string when searching. The general syntax is . The modifier can be used to search for strings that have been base64 encoded. A good explanation of the technique is at: The following rule will search for the three base64 permutations of the string \"This program cannot\": This will cause YARA to search for these three permutations: The modifier works just like the modifier but the results of the modifier are converted to wide. The interaction between (or ) and and is as you might expect. and are applied to the string first, and then the and modifiers are applied. At no point is the plaintext of the or versions of the strings included in the search. If you want to also include those you can put them in a secondary string. The and modifiers also support a custom alphabet. For example: The alphabet must be 64 bytes long. The and modifiers are only supported with text strings. Using these modifiers with a hexadecimal string or a regular expression will cause a compiler error. Also, the , , and modifiers used in combination with or will cause a compiler error. Because of the way that YARA strips the leading and trailing characters after base64 encoding, one of the base64 encodings of \"Dhis program cannow\" and \"This program cannot\" are identical. Similarly, using the keyword on single ASCII characters is not recommended. For example, \"a\" with the keyword matches \"`\", \"b\", \"c\", \"!\", \"\\xA1\", or \"\\xE1\" after base64 encoding, and will not match where the base64 encoding matches the regular expression. Another modifier that can be applied to text strings is . This modifier guarantees that the string will match only if it appears in the file delimited by non-alphanumeric characters. For example the string domain, if defined as , doesn't match www.mydomain.com but it matches www.my-domain.com and www.domain.com. Regular expressions are one of the most powerful features of YARA. They are defined in the same way as text strings, but enclosed in forward slashes instead of double-quotes, like in the Perl programming language. Regular expressions can be also followed by , , , and modifiers just like in text strings. The semantics of these modifiers are the same in both cases. Additionally, they can be followed by the characters and just after the closing slash, which is a very common convention for specifying that the regular expression is case-insensitive and that the dot ( ) can match new-line characters. For example: rule RegExpExample2 { strings: $re1 = /foo/i // This regexp is case-insentitive $re2 = /bar./s // In this regexp the dot matches everything, including new-line $re3 = /baz./is // Both modifiers can be used together condition: any of them } Notice that is equivalent to , but we recommend the latter when defining strings. The syntax is useful when writting case-insentive regular expressions for the operator. In previous versions of YARA, external libraries like PCRE and RE2 were used to perform regular expression matching, but starting with version 2.0 YARA uses its own regular expression engine. This new engine implements most features found in PCRE, except a few of them like capture groups, POSIX character classes ([[:isalpha:]], [[:isdigit:]], etc) and backreferences. Quote the next metacharacter Match the beginning of the file or negates a character class when used as the first character after the opening bracket Match the end of the file The following quantifiers are recognised as well: All these quantifiers have a non-greedy variant, followed by a question mark (?): The following escape sequences are recognised: Character whose ordinal number is the given hexadecimal number These are the recognised character classes: Starting with version 3.3.0 these zero-width assertions are also recognized: All strings in YARA can be marked as which means they will never be included in the output of YARA. They are treated as normal strings everywhere else, so you can still use them as you wish in the condition, but they will never be shown with the flag or seen in the YARA callback if you're using the C API. YARA 4.4.0 allows for unreferenced strings in the condition. If a string identifier starts with an then it does not have to be referenced in the condition. Any other string must be referenced in the condition. This is useful if you want to search for particular strings and handle them in a custom callback but don't really need them for your condition logic. The following string modifiers are processed in the following order, but are only applicable to the string types listed. Cannot use with , , or Also match ASCII characters, only required if is used Cannot use with , , or Cannot use with , , or Convert to 3 base64 encoded strings, then interleaving null characters like Cannot use with , , or Match is not preceded or followed by an alphanumeric character Cannot use with or\n\nConditions are nothing more than Boolean expressions as those that can be found in all programming languages, for example in an if statement. They can contain the typical Boolean operators , , and , and relational operators , , , , and . Also, the arithmetic operators ( , , , , ) and bitwise operators ( , , , , , ) can be used on numerical expressions. Integers are always 64-bits long, even the results of functions like , and are promoted to 64-bits. This is something you must take into account, specially while using bitwise operators (for example, ~0x01 is not 0xFE but 0xFFFFFFFFFFFFFFFE). The following table lists the precedence and associativity of all operators. The table is sorted in descending precedence order, which means that operators listed on a higher row in the list are grouped prior operators listed in rows further below it. Operators within the same row have the same precedence, if they appear together in a expression the associativity determines how they are grouped. Like contains but case-insensitive Logical NOT Check if an expression is defined String identifiers can be also used within a condition, acting as Boolean variables whose value depends on the presence or not of the associated string in the file. rule Example { strings: $a = \"text1\" $b = \"text2\" $c = \"text3\" $d = \"text4\" condition: ($a or $b) and ($c or $d) } Sometimes we need to know not only if a certain string is present or not, but how many times the string appears in the file or process memory. The number of occurrences of each string is represented by a variable whose name is the string identifier but with a # character in place of the $ character. For example: This rule matches any file or process containing the string $a exactly six times, and more than ten occurrences of string $b. Starting with YARA 4.2.0 it is possible to express the count of a string in an integer range, like this: In this example the number of 'a' strings in the last 500 bytes of the file must equal exactly 2. In the majority of cases, when a string identifier is used in a condition, we are willing to know if the associated string is anywhere within the file or process memory, but sometimes we need to know if the string is at some specific offset on the file or at some virtual address within the process address space. In such situations the operator is what we need. This operator is used as shown in the following example: rule AtExample { strings: $a = \"dummy1\" $b = \"dummy2\" condition: $a at 100 and $b at 200 } The expression in the above example is true only if string $a is found at offset 100 within the file (or at virtual address 100 if applied to a running process). The string $b should appear at offset 200. Please note that both offsets are decimal, however hexadecimal numbers can be written by adding the prefix 0x before the number as in the C language, which comes very handy when writing virtual addresses. Also note the higher precedence of the operator over the . While the operator allows to search for a string at some fixed offset in the file or virtual address in a process memory space, the operator allows to search for the string within a range of offsets or addresses. rule InExample { strings: $a = \"dummy1\" $b = \"dummy2\" condition: $a in (0..100) and $b in (100..filesize) } In the example above the string $a must be found at an offset between 0 and 100, while string $b must be at an offset between 100 and the end of the file. Again, numbers are decimal by default. You can also get the offset or virtual address of the i-th occurrence of string $a by using @a[i]. The indexes are one-based, so the first occurrence would be @a[1] the second one @a[2] and so on. If you provide an index greater than the number of occurrences of the string, the result will be a NaN (Not A Number) value. For many regular expressions and hex strings containing jumps, the length of the match is variable. If you have the regular expression /fo*/ the strings \"fo\", \"foo\" and \"fooo\" can be matches, all of them with a different length. You can use the length of the matches as part of your condition by using the character ! in front of the string identifier, in a similar way you use the @ character for the offset. !a[1] is the length for the first match of $a, !a[2] is the length for the second match, and so on. !a is a abbreviated form of !a[1]. String identifiers are not the only variables that can appear in a condition (in fact, rules can be defined without any string definition as will be shown below), there are other special variables that can be used as well. One of these special variables is , which holds, as its name indicates, the size of the file being scanned. The size is expressed in bytes. The previous example also demonstrates the use of the postfix. This postfix, when attached to a numerical constant, automatically multiplies the value of the constant by 1024. The postfix can be used to multiply the value by 2^20. Both postfixes can be used only with decimal constants. The use of only makes sense when the rule is applied to a file. If the rule is applied to a running process it won’t ever match because doesn’t make sense in this context. Another special variable than can be used in a rule is . If the file is a Portable Executable (PE) or Executable and Linkable Format (ELF), this variable holds the raw offset of the executable’s entry point in case we are scanning a file. If we are scanning a running process, the entrypoint will hold the virtual address of the main executable’s entry point. A typical use of this variable is to look for some pattern at the entry point to detect packers or simple file infectors. The presence of the variable in a rule implies that only PE or ELF files can satisfy that rule. If the file is not a PE or ELF, any rule using this variable evaluates to false. The variable is deprecated, you should use the equivalent from the PE module instead. Starting with YARA 3.0 you'll get a warning if you use and it will be completely removed in future versions. There are many situations in which you may want to write conditions that depend on data stored at a certain file offset or virtual memory address, depending on if we are scanning a file or a running process. In those situations you can use one of the following functions to read data from the file at the given offset: The functions read 8, 16, and 32 bits signed integers from <offset or virtual address>, while functions read unsigned integers. Both 16 and 32 bit integers are considered to be little-endian. If you want to read a big-endian integer use the corresponding function ending in . The <offset or virtual address> parameter can be any expression returning an unsigned integer, including the return value of one the functions itself. As an example let's see a rule to distinguish PE files: rule IsPE { condition: // MZ signature at offset 0 and ... uint16(0) == 0x5A4D and // ... PE signature at offset stored in MZ header at 0x3C uint32(uint32(0x3C)) == 0x00004550 } There are circumstances in which it is necessary to express that the file should contain a certain number strings from a given set. None of the strings in the set are required to be present, but at least some of them should be. In these situations the operator can be used. This rule requires that at least two of the strings in the set ($a,$b,$c) must be present in the file, but it does not matter which two. Of course, when using this operator, the number before the keyword must be less than or equal to the number of strings in the set. The elements of the set can be explicitly enumerated like in the previous example, or can be specified by using wild cards. For example: rule OfExample2 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $foo3 = \"foo3\" condition: 2 of ($foo*) // equivalent to 2 of ($foo1,$foo2,$foo3) } rule OfExample3 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $bar1 = \"bar1\" $bar2 = \"bar2\" condition: 3 of ($foo*,$bar1,$bar2) } You can even use to refer to all the strings in your rule, or write the equivalent keyword for more legibility. rule OfExample4 { strings: $a = \"dummy1\" $b = \"dummy2\" $c = \"dummy3\" condition: 1 of them // equivalent to 1 of ($*) } In all the examples above, the number of strings have been specified by a numeric constant, but any expression returning a numeric value can be used. The keywords , and can be used as well. all of them // all strings in the rule any of them // any string in the rule all of ($a*) // all strings whose identifier starts by $a any of ($a,$b,$c) // any of $a, $b or $c 1 of ($*) // same that \"any of them\" none of ($b*) // zero of the set of strings that start with \"$b\" Due to the way YARA works internally, using \"0 of them\" is an ambiguous part of the language which should be avoided in favor of \"none of them\". To understand this, consider the meaning of \"2 of them\", which is true if 2 or more of the strings match. Historically, \"0 of them\" followed this principle and would evaluate to true if at least one of the strings matched. This ambiguity is resolved in YARA 4.3.0 by making \"0 of them\" evaluate to true if exactly 0 of the strings match. To improve on the situation and make the intent clear, it is encouraged to use \"none\" in place of 0. By not using an integer it is easier to reason about the meaning of \"none of them\" without the historical understanding of \"at least 0\" clouding the issue. Starting with YARA 4.2.0 it is possible to express a set of strings in an integer range, like this: all of ($a*) in (filesize-500..filesize) any of ($a*, $b*) in (1000..2000) Starting with YARA 4.3.0 it is possible to express a set of strings at a specific offset, like this: any of ($a*) at 0 Applying the same condition to many strings¶ There is another operator very similar to but even more powerful, the operator. The syntax is: And its meaning is: from those strings in at least of them must satisfy . In other words: is evaluated for every string in and there must be at least of them returning True. Of course, can be any boolean expression accepted in the condition section of a rule, except for one important detail: here you can (and should) use a dollar sign ($) as a place-holder for the string being evaluated. Take a look at the following expression: for any of ($a,$b,$c) : ( $ at pe.entry_point ) The $ symbol in the boolean expression is not tied to any particular string, it will be $a, and then $b, and then $c in the three successive evaluations of the expression. Maybe you already realised that the operator is a special case of . The following expressions are the same: any of ($a,$b,$c) for any of ($a,$b,$c) : ( $ ) You can also employ the symbols #, @, and ! to make reference to the number of occurrences, the first offset, and the length of each string respectively. for all of them : ( # > 3 ) for all of ($a*) : ( @ > @b ) Starting with YARA 4.3.0 you can express conditions over text strings like this: for any s in (\"71b36345516e076a0663e0bea97759e4\", \"1e7f7edeb06de02f2c2a9319de99e033\") : ( pe.imphash() == s ) It is worth remembering here that the two hashes referenced in the rule are normal text strings, and have nothing to do with the string section of the rule. Inside the loop condition the result of the function is compared to each of the text strings, resulting in a more concise rule. Using anonymous strings with and ¶ When using the and operators followed by , the identifier assigned to each string of the rule is usually superfluous. As we are not referencing any string individually we do not need to provide a unique identifier for each of them. In those situations you can declare anonymous strings with identifiers consisting only of the $ character, as in the following example: As seen in String offsets or virtual addresses, the offsets or virtual addresses where a given string appears within a file or process address space can be accessed by using the syntax: @a[i], where i is an index indicating which occurrence of the string $a you are referring to. (@a[1], @a[2],...). Sometimes you will need to iterate over some of these offsets and guarantee they satisfy a given condition. In such cases you can use the syntax, for example: rule Occurrences { strings: $a = \"dummy1\" $b = \"dummy2\" condition: for all i in (1,2,3) : ( @a[i] + 10 == @b[i] ) } The previous rule says that the first occurrence of $b should be 10 bytes after the first occurrence of $a, and the same should happen with the second and third ocurrences of the two strings. The same condition could be written also as: for all i in (1..3) : ( @a[i] + 10 == @b[i] ) Notice that we’re using a range (1..3) instead of enumerating the index values (1,2,3). Of course, we’re not forced to use constants to specify range boundaries, we can use expressions as well like in the following example: for all i in (1..#a) : ( @a[i] < 100 ) In this case we’re iterating over every occurrence of $a (remember that #a represents the number of occurrences of $a). This rule is specifying that every occurrence of $a should be within the first 100 bytes of the file. In case you want to express that only some occurrences of the string should satisfy your condition, the same logic seen in the operator applies here: for any i in (1..#a) : ( @a[i] < 100 ) for 2 i in (1..#a) : ( @a[i] < 100 ) The operator is similar to , but the latter iterates over a set of strings, while the former iterates over ranges, enumerations, arrays and dictionaries. In YARA 4.0 the operator was improved and now it can be used to iterate not only over integer enumerations and ranges (e.g: 1,2,3,4 and 1..4), but also over any kind of iterable data type, like arrays and dictionaries defined by YARA modules. For example, the following expression is valid in YARA 4.0: for any section in pe.sections : ( section.name == \".text\" ) for any i in (0..pe.number_of_sections-1) : ( pe.sections[i].name == \".text\" ) The new syntax is more natural and easy to understand, and is the recommended way of expressing this type of conditions in newer versions of YARA. While iterating dictionaries you must provide two variable names that will hold the key and value for each entry in the dictionary, for example: for any k,v in some_dict : ( k == \"foo\" and v == \"bar\" ) In general the operator has the form: for <quantifier> <variables> in <iterable> : ( <some condition using the loop variables> ) Where is either , or an expression that evaluates to the number of items in the iterator that must satisfy the condition, is a comma-separated list of variable names that holds the values for the current item (the number of variables depend on the type of ) and is something that can be iterated. When writing the condition for a rule you can also make reference to a previously defined rule in a manner that resembles a function invocation of traditional programming languages. In this way you can create rules that depend on others. Let's see an example: As can be seen in the example, a file will satisfy Rule2 only if it contains the string \"dummy2\" and satisfies Rule1. Note that it is strictly necessary to define the rule being invoked before the one that will make the invocation. Another way to reference other rules was introduced in 4.2.0 and that is sets of rules, which operate similarly to sets of strings (see sets-of-strings). For example: This example demonstrates how to use rule sets to describe higher order logic in a way which automatically grows with your rules. If you define another rule named before then it will automatically be included in the expansion of in the condition for MainRule. To use rule sets all of the rules included in the set must exist prior to the rule set being used. For example, the following will produce a compiler error because is defined after the rule set is used in :\n\nExternal variables allow you to define rules that depend on values provided from the outside. For example, you can write the following rule: In this case is an external variable whose value is assigned at run-time (see option of command-line tool, and parameter of and methods in yara-python). External variables could be of types: integer, string or boolean; their type depends on the value assigned to them. An integer variable can substitute any integer constant in the condition and boolean variables can occupy the place of boolean expressions. For example: External variables of type string can be used with the operators: , , and their case-insensitive counterparts: , and . They can be used also with the operator, which returns true if the string matches a given regular expression. Case-insensitive string comparison can be done through special operator which only works with strings. For case-sensitive comparison use regular . You can use regular expression modifiers along with the operator, for example, if you want the regular expression from the previous example to be case insensitive you can use . Notice the following the regular expression in a Perl-like manner. You can also use the modifier for single-line mode, in this mode the dot matches all characters including line breaks. Of course both modifiers can be used simultaneously, like in the following example: Keep in mind that every external variable used in your rules must be defined at run-time, either by using the option of the command-line tool, or by providing the parameter to the appropriate method in ."
    },
    {
        "link": "https://support.phishingtackle.com/hc/en-gb/articles/4410170814609-YARA-Rule-Examples",
        "document": "YARA (\"Yet Another Recursive Algorithm\" / \"Yet Another Ridiculous Acronym\") is a powerful tool that allows you to detect patterns or specific attributes. The rules you create can target the message body, header, attachments or raw. This knowledge base article will provide you with examples and ideas on how to incorporate YARA into your organisation.\n\n\n\nThe official YARA documentation can be found here. \n\n\n\n\n\nYou can click any of the YARA examples below to be taken to that section. Each YARA rule will have their source code linked below the image.\n• Example 1 - Detect messages with a demand for money\n• Example 4 - Using Regular expression to detect URLs\n• Example 5 - Using multiple conditions to improve matches\n\nExample 1 - Detect messages with a demand for money\n\nIn this simple rule we have declared two strings \"pay\" and \"immediately\". As we are using the YARA keyword \"and\" within our condition both strings will need to be in the message for the condition to be true.\n\nThis rule can easily be improved by adding words you consider suspicious, high-level executive names, or certain requests like downloading a file helping to filter any unwanted messages. \n\n\n\nThe Link to this rule can be found here.\n\nYou might decide to cast a wide net when attempting to catch malicious emails rather than creating extremely specific rules. This can be achieved by using the \"any of them\" keyword. if any specified string is found the YARA rule condition is true. You can create a list of keywords or URLs that are known to be malicious and add them into your YARA rule. If any of the strings are detected, you can pick an action to decide what happens.\n\n\n\nAs an example, a hacker has decided to target your organisation. You know their name and aliases they will send the emails from and some of the phishing domains they want you to click. To prevent this attack, you can create a YARA rule that triggers an action if any of the specified strings are found.\n\n\n\nThe Link to this rule can be found here.\n\nHexadecimal can help detect obfuscated malware, by looking at the file signature. YARA rules that use hexadecimal are very flexible. You can create a string and add the hex signature for any file type into your rule, you could also add the file signature for a known malware or use wildcards (placeholders) for any unknown bytes.\n\n\n\nIn the example below we have added the Hex signatures for a PDF and a PNG file, if either is detected this rule will be triggered. You can expand this rule to match your own policies, you may decide to ban all executable files and only allow PDF files to be sent; this choice is yours. \n\nA Link to this rule can be found here.\n\n\n\n\n\nExample 4 - Using Regular expression to detect URLs\n\nRegex (regular expression) can be incorporated into your YARA rules and will allow you to detect certain sequences of characters. In the example below we have created an expression that looks for the common parts that make up a URL. \n\n\n\nRather than block all URLs we can now create another string for our CEO's name \"Bob Kent\" and append the modifier \"nocase\". The nocase modifier will make our CEO's name case insensitive allowing us to find uncapitalised variants. Our condition will be true if we detect a URL and our CEO's name is mentioned. \n\n \n\nA Link to this rule can be found here.\n\n\n\n\n\nExample 5 - Using multiple conditions to improve matches\n\nYARA rules can use multiple conditions to help you find the exact match you are looking for. This is extremely useful when using keywords like \"not\" as you can specify strings to prevent incorrect matches. \n\n\n\nIn the example below we have created three strings. If the string \"Quarantine_Message1\" or \"Quarantine_Message2\" is found in the body of an email the condition is true. As these words are frequently used, we can add the keyword \"not\" which allows our third string to determine what will happen. For example, if an email had a request to install software it would automatically be sent to quarantine, however if the email mentions an upcoming meeting that provides context it would not be sent to quarantine. \n\n\n\nA Link to this rule can be found here.\n\n\n\nIf you have any further questions, please contact our support team by clicking here."
    },
    {
        "link": "https://github.com/InQuest/awesome-yara",
        "document": "A curated list of awesome YARA rules, tools, and resources. Inspired by awesome-python and awesome-php.\n\nYARA, the \"pattern matching swiss knife for malware researchers (and everyone else)\" is developed by @plusvic and @VirusTotal. View it on GitHub.\n• 💎 - Novel, interesting, educational, or otherwise stand-out content.\n\nAn annual YARA challenge started by Greg Lesnewich in 2022, inspired by #100DaysOfCode and taking place in the first 100 days of the year. The goal is to contribute daily to the YARA community through rule creation, source code contributions, or generally teaching/help your colleagues. Other key contributors include Wesley Shields and Steve Miller. For a list of all participants in the first two years of the challenge, see our Twitter List.\n\nRule collections from prior years of the challenge: 100 Days of YARA\n• AlienVault Labs Rules\n• Collection of tools, signatures, and rules from the researchers at AlienVault Labs. Search the repo for .yar and .yara extensions to find about two dozen rules ranging from APT detection to generic sandbox / VM detection. Last updated in January of 2016.\n• Apple OSX\n• Apple has ~40 YARA signatures for detecting malware on OSX. The file, XProtect.yara, is available locally at /System/Library/CoreServices/XProtect.bundle/Contents/Resources/.\n• BinaryAlert YARA Rules\n• A couple dozen rules written and released by AirBnB as part of their BinaryAlert tool (see next section). Detection for hack tools, malware, and ransomware across Linux, Window, and OS X. This is a new and active project.\n• Burp YARA Rules\n• Collection of YARA rules intended to be used with the Burp Proxy through the Yara-Scanner extension. These rules focus mostly on non-exe malware typically delivered over HTTP including HTML, Java, Flash, Office, PDF, etc. Last updated in June of 2016.\n• BinSequencer\n• Find a common pattern of bytes within a set of samples and generate a YARA rule from the identified pattern.\n• CAPE Rules 👀\n• Rules from various authors bundled with the Config And Payload Extraction Cuckoo Sandbox extension (see next section).\n• CDI Rules\n• Collection of YARA rules released by CyberDefenses for public use. Built from information in intelligence profiles, dossiers and file work.\n• Citizen Lab Malware Signatures\n• YARA signatures developed by Citizen Lab. Dozens of signatures covering a variety of malware families. The also inclde a syntax file for Vim. Last update was in November of 2016.\n• ConventionEngine Rules ✨\n• A collection of Yara rules looking for PEs with PDB paths that have unique, unusual, or overtly malicious-looking keywords, terms, or other features.\n• Deadbits Rules 👀\n• A collection of YARA rules made public by Adam Swanda, Splunk's Principal Threat Intel. Analyst, from his own recent malware research.\n• Delivr.to Detections\n• This repo serves as a home for detection content developed by the delivr.to team.\n• Didier Stevens Rules 💎\n• Collection of rules from Didier Stevens, author of a suite of tools for inspecting OLE/RTF/PDF. Didier's rules are worth scrutinizing and are generally written purposed towards hunting. New rules are frequently announced through the NVISO Labs Blog.\n• Ditekshen Rules\n• A set of interrelated network and host detection rules with the aim of improving detection and hunting visibility and context.\n• Elastic Security YARA Rules\n• Elastic Security provides signature-based YARA rules within the Elastic Endpoint product. These rules are used to detect and prevent emerging threats within Linux, Windows, and macOS systems. Our repository holds over 1,000 YARA rules that are used every day to stop a wide range of threats including: Trojans, ransomware, cryptominers, attack penetration frameworks, and more.\n• ESET IOCs 👀\n• Collection of YARA and Snort rules from IOCs collected by ESET researchers. There's about a dozen YARA Rules to glean from in this repo, search for file extension .yar. This repository is seemingly updated on a roughly monthly interval. New IOCs are often mentioned on the ESET WeLiveSecurity Blog.\n• Fidelis Rules\n• You can find a half dozen YARA rules in Fidelis Cyber's IOC repository. They update this repository on a roughly quarterly interval. Complete blog content is also available in this repository.\n• Filescan.io Rules ✨\n• A collection of curated YARA rules used as part of the Filescan.io service.\n• Florian Roth Rules 👀 💎\n• Florian Roth's signature base is a frequently updated collection of IOCs and YARA rules that cover a wide range of threats. There are dozens of rules which are actively maintained. Watch the repository to see rules evolve over time to address false positives / negatives.\n• Florian Roth's IDDQD Rule\n• A proof-of-concept rule that shows how easy it actually is to detect red teamer and threat group tools and code.\n• FSF Rules\n• Mostly filetype detection rules, from the EmersonElectricCo FSF project (see next section).\n• GoDaddy ProcFilter Rules\n• A couple dozen rules written and released by GoDaddy for use with ProcFilter (see next section). Example rules include detection for packers, mimikatz, and specific malware.\n• h3x2b Rules 💎\n• Collection of signatures from h3x2b which stand out in that they are generic and can be used to assist in reverse engineering. There are YARA rules for identifying crypto routines, highly entropic sections (certificate discovery for example), discovering injection / hooking functionality, and more.\n• HydraDragonAntivirus 🏆\n• World's largest open source YARA collection with no duplicates, no invalid ones and only few files. Also it contains ClamAV + YARA-X or YARA + Machine Learning + IDS canner and signatures and SUBLIME + CAPA + SIGMA signatures. Finally it has so big malware collection.\n• Icewater Rules\n• Repository of automatically generated YARA rules from Icewater.io. This repository is updated rapidly with newly generated signatures that mostly match on file size range and partial content hashes.\n• imp0rtp3's Rules\n• A small repository which contains some browser based rules.\n• InQuest Rules 👀\n• YARA rules published by InQuest researchers mostly geared towards threat hunting on Virus Total. Rules are updated as new samples are collected and novel pivots are discovered. The InQuest Blog will often discuss new findings.\n• jeFF0Falltrades Rules ✨\n• A collection of YARA signatures for various malware families.\n• kevthehermit Rules\n• Dozens of rules from the personal collection of Kevin Breen. This repository hasn't been updated since February of 2016.\n• lw-yara\n• Ruleset for scanning Linux servers for shells, spamming, phishing and other webserver baddies.\n• ndaal_YARA_passwords_default\n• YARA rules includes default credentials of at least 1043 organizations which are hashed with different hash permutations such as base64, md5, sha512, etc.\n• ndaal_YARA_passwords_weak\n• YARA rules includes hashed passwords of the top weak passwords. The passwords are hashed in a respective rule according to the following permutations such as base64, md5, sha512, etc.\n• MalGamy's YARA_Rules\n• A small repository which contains some stealer rules.\n• Malice.IO YARA Plugin Rules 👀\n• Collection of topical from a variety of sources for the YARA component of the Malice.IO framework.\n• Malpedia Auto Generated Rules ✨\n• A zip file that contains all automatically generated, code-based rules created using Malpedia's YARA-Signator\n• Malpedia Auto Generated Rules Repo ✨\n• Repository to simplify access to and synchronization of Malpedia's automatically generated, code-based YARA rules.\n• McAfee Advanced Threat Research IOCs\n• IOCs, including YARA rules, to accompany McAfee ATR's blog and other public posts.\n• mikesxrs YARA Rules Collection 👀\n• Large collection of open source rules aggregated from a variety of sources, including blogs and other more ephemeral sources. Over 100 categories, 1500 files, 4000 rules, and 20Mb. If you're going to pull down a single repo to play with, this is the one.\n• QuickSand Lite Rules\n• This repo contains a C framework and standalone tool for malware analysis, along with several useful YARA rules developed for use with the project.\n• Rapid7-Labs\n• This repository contains a curated collection of Sigma & Yara rules and Indicators of Compromise (IOCs) shared by Rapid7 Labs.\n• Rastrea2r\n• Triage suspect systems and hunt for Indicators of Compromise (IOCs) across thousands of endpoints in minutes.\n• ReversingLabs YARA Rules ✨ 👀\n• A collection of yara rules published by ReversingLabs which covers exploits, infostealers, ransomware, trojans, and viruses.\n• Sophos AI YaraML Rules\n• A repository of Yara rules created automatically as translations of machine learning models. Each directory will have a rule and accompanying metadata: hashes of files used in training, and an accuracy diagram (a ROC curve).\n• SpiderLabs Rules\n• Repository of tools and scripts related to malware analysis from the researchers at SpiderLabs. There's only three YARA rules here and the last update was back in 2015, but worth exploring.\n• t4d's PhishingKit-Yara-Rules\n• This repository, dedicated to Phishing Kits zip files YARA rules, is based on zip raw format analysis to find directories and files names, you don't need yara-extend there.\n• Telekom Security Malare Analysis Repository\n• This repository comprises scripts, signatures, and additional IOCs of our blog posts at the telekom.com blog.\n• Volexity - Threat-Intel ✨ 💎\n• This repository contains IoCs related to Volexity public threat intelligence blog posts.\n• YAIDS 💎 ✨\n• YAIDS is a Multi-Threaded Intrusion Detection System using Yara. YAIDS supports all valid Yara rules (including modules) and any PCAP compatible data stream (Network, USB, Bluetooth, etc.).\n• YARA Forge 💎 ✨ 👀\n• YARA Forge specializes in delivering high-quality YARA rule packages for immediate integration into security platforms.\n• yara4pentesters\n• Rules to identify files containing juicy information like usernames, passwords etc.\n• YaraRules Project Official Repo 👀\n• Large collection of rules constantly updated by the community.\n• Yara-Unprotect\n• Rules created for the Unprotect Project for detecting malware evasion techniques.\n• AirBnB BinaryAlert\n• Open-source serverless AWS pipeline where any file uploaded to an S3 bucket is immediately scanned with a configurable set of YARA rules.\n• alterix\n• Converts Yara rules to the query language of CRYPTTECH's SIEM\n• a-ray-grass\n• YARA module that provides support for bloom filters in yara. In the context of hashlookup.io, it allows to quickly discard known files before any further analysis.\n• Arya- The Reverse YARA\n• Arya is a unique tool that produces pseudo-malicious files meant to trigger YARA rules. You can think of it like a reverse YARA because it does exactly the opposite - it creates files that matches your rules.\n• Audit Node Modules With YARA Rules\n• Run a given set of YARA rules against the given node_module folder\n• CAPE: Config And Payload Extraction 👀\n• Extension of Cuckoo specifically designed to extract payloads and configuration from malware. CAPE can detect a number of malware techniques or behaviours, as well as specific malware families, from its initial run on a sample. This detection then triggers a second run with a specific package, in order to extract the malware payload and possibly its configuration, for further analysis.\n• Cloudina Security Hawk ✨\n• Multi Cloud antivirus scanning API based on CLAMAV and YARA for AWS S3, AZURE Blob Storage, GCP Cloud Storage.\n• CrowdStrike Feed Management System\n• Framework for automating collection and processing of samples from VirusTotal, and executing commands based on YARA rule matches.\n• CSE-CST AssemblyLine\n• The Canadian Communications Security Establishment (CSE) open sourced AssemblyLine, a platform for analyzing malicious files. The component linked here provides an interface to YARA.\n• decompressingyara\n• For when your malware samples are stored compressed, but you still want to run rules against them.\n• ExchangeFilter\n• MS Exchange transport agent uses YARA to detect malware in email messages.\n• factual-rules-generator\n• Factual-rules-generator is an open source project which aims to generate YARA rules about installed software from a running operating system.\n• FARA\n• FARA, or Faux YARA, is a simple repository that contains a set of purposefully erroneous Yara rules. It is meant as a training vehicle for new security analysts, those that are new to Yara and even Yara veterans that want to keep their rule writing (and debugging) sharp.\n• Fastfinder\n• Fast customisable cross-platform suspicious file finder. Designed for incident response. Supports md5/sha1/sha256 hashs, litteral/wildcard strings, regular expressions and YARA rules. Can easily be packed to be deployed on any windows / linux host.\n• findcrypt-yara and FindYara\n• IDA pro plugins to scan your binary with YARA rules to find crypto constants (and more).\n• Fibratus\n• A modern tool for Windows kernel exploration and observability with a focus on security and support for YARA.\n• GoDaddy ProcFilter 💎\n• ProcFilter is a process filtering system for Windows with built-in YARA integration. YARA rules can be instrumented with custom meta tags that tailor its response to rule matches. It runs as a Windows service and is integrated with Microsoft's ETW API, making results viewable in the Windows Event Log. Installation, activation, and removal can be done dynamically and does not require a reboot.\n• GhidraYara - A Ghidra extension providing direct integration of YARA through an analyzer, as well as rule generation from code listings and management in the Ghidra UI. Supports an extensive library of cryptographic constants, CRC tables, etc.\n• halogen\n• Halogen is a tool to automate the creation of yara rules against image files embedded within a malicious document.\n• Hyara\n• IDA Pro, Cutter, and BinaryNinja plugin that provides easy creation of YARA rules for ASCII & hex strings between a given start and end address.\n• ida_yara\n• Scan data within an IDB using YARA.\n• KLara\n• Distributed system written in Python, allows researchers to scan one or more YARA rules over collections with samples.\n• Laika BOSS\n• Object scanner and intrusion detection system that strives to achieve the following goals: Scalable, Flexible, Verbose.\n• libyara.NET\n• .NET wrapper for libyara built in C++ CLI used to easily incorporate yara into .NET projects\n• Malcat\n• Hexadecimal editor, disassembler and decompiler for malware analysis. Embeds both a YARA scanner and rule editor for easy in-app rule creation. Free and paid versions are available.\n• MalConfScan\n• MalConfScan is a Volatility plugin extracts configuration data of known malware. This tool searches for malware in memory images and dumps configuration data. In addition, this tool has a function to list strings to which malicious code refers.\n• malscan\n• Scan process memory for YARA matches and execute Python scripts if a match is found.\n• malwatch\n• Fast and lightweight malware scanner written in go that is ideal for Linux based web server environments. Currently used with some of the internet's largest deployments.\n• Manalyzer Yara Validator\n• Compile your rules on all yara versions online to detect compatibility issues!\n• MISP Threat Sharing\n• Threat intelligence platform including indicators, threat intelligence, malware samples and binaries. Includes support for sharing, generating, and validating YARA signatures.\n• MITRE MultiScanner\n• File analysis framework that assists the user in evaluating a set of files by automatically running a suite of tools for the user and aggregating the output.\n• Nextron Systems OSS and Commercial Tools (Florian Roth: @Neo23x0)\n• Loki IOC and YARA rule scanner implemented in Python. Open source and free.\n• THOR Lite IOC and YARA rule scanner implemented in Go. Closed source, free, but registration required.\n• OCYara\n• Performs OCR on image files and scans them for matches to YARA rules.\n• plast\n• Threat hunting tool for detecting and processing IOCs using YARA under the hood.\n• Polichombr\n• Collaborative malware analysis framework with YARA rule matching and other features.\n• PwC Cyber Threat Operations rtfsig\n• This tool is designed to make it easy to signature potentially unique parts of RTF files.\n• VirusTotalTools\n• Tools for checking samples against Virus Total, including VT_RuleMGR, for managing threat hunting YARA rules.\n• shotgunyara\n• Given a string, create 255 xor encoded versions of that string as a YARA rule.\n• stoQ\n• Modular and highly customizable framework for the creation of data sets from multiple disparate data sources.\n• Strelka\n• Detection-Oriented File Analysis System built on Python3, ZeroMQ, and YARA, primarily used for threat detection/hunting and intelligence gathering.\n• SwishDbgExt\n• Microsoft WinDbg extension which includes the ability to use YARA rules to hunt processes in memory.\n• ThreatIngestor\n• Automatically extract and aggregate IOCs including YARA rules from many sources.\n• UXProtect\n• The missing UI to Apple's built-in XProtect YARA signatures. Enumerate signatures, scan files, and more.\n• YARA-CI ✨\n• YARA-CI helps you to keep your YARA rules in good shape. It can be integrated into any GitHub\n• yaradbg-backend 💎\n• YaraDbg is a free web-based Yara debugger to help security analysts to write hunting or detection rules with less effort and more confidence.\n• yaradbg-frontend 👀\n• YaraDbg is a free web-based Yara debugger to help security analysts to write hunting or detection rules with less effort and more confidence.\n• yara-endpoint\n• Tool useful for incident response as well as anti-malware enpoint based on YARA signatures.\n• YaraFileCheckerLib\n• .Net Library designed to make it easier to check potentially malicious files and archives using YARA and make a decision about their harmfulness based on the weights of the detected rules.\n• YaraGenerator\n• Quick, simple, and effective yara rule creation to isolate malware families and other malicious objects of interest.\n• YaraGen and yara_fn\n• Plugins for x64dbg and IDAPython, respectively, that generate YARA rules from function blocks.\n• YaraHunter\n• Malware scanner for cloud-native, as part of CI/CD and at Runtime\n• yara-java\n• Java bindings for YARA (Subreption fork, maintained as of 2024, old bindings).\n• yaralyzer\n• Visually inspect and force decode YARA and regex matches found in both binary and text data. With Colors.\n• Yara Malware Quick menu scanner\n• Adds the awsome YARA pattern scanner to Windows right click menus.\n• Yaramanager (PyPI)\n• Command line tool to manage and organize your Yara ruleset.\n• yaramod\n• A library that provides parsing of YARA rules into AST and a C++ programming interface to build new YARA rulesets.\n• yara-parser\n• Tools for parsing rulesets using the exact grammar as YARA. Written in Go.\n• YaraSharp\n• C# wrapper around the Yara pattern matching library\n• Yara Toolkit\n• This is the Yara editor. You can write your own Yara rules or copy paste one to edit it.\n• YaraStation\n• Yara station is a managment portal designed to facilitate the use of Loki scanner.\n• Yara-Validator\n• Validates YARA rules and tries to repair the broken ones.\n• yaraVT\n• Scan files with Yara and send rule matches to VirusTotal reports as comments.\n• Yara Scanner\n• A wrapper around the yara-python project the providing multiple capabilities.\n• Yarasilly2\n• A Semi automatic handy tool to generate YARA rules from sample virus files ( WIP ) for Malware Analyst, inspired by DIFF function of VirusTotal Premium Account.\n• Yeti\n• Platform meant to organize observables, indicators of compromise, TTPs, and knowledge on threats in a single, unified repository.\n• yaraZeekAlert ✨\n• Scans files with YARA rules and send email alerts which include network context of the file transfer and attaches the suspicious file if it is less than 10 MB.\n• YARI\n• Interactive debugger for the YARA language written in Rust.\n• YLS\n• Language server for YARA to intergrate with e.g. vscode or vim. Offers code completion, function documentation, code formatting, debugging, ...\n• YMCA\n• Displays a table of matches between YARA rules and a collection of samples.\n• Yobi ✨\n• Yobi is a basic firefox extension which allows to run public or private YARA rules on all scripts and pages rendered by the browser.\n• InQuest Labs ✨ 💎\n• See the YARA section for helper routines to convert regular expressions to match on base64 encoded strings, conver strings to sequences of uint() lookups, and more.\n• Koodous\n• Collaborative platform for APK analysis, with community YARA rule repository and large APK sample dataset.\n• YARAify✨\n• YARAify is a project from abuse.ch that allows anyone to scan suspicious files such as malware samples or process dumps against a large repository of YARA rules.\n• Yara Scan Service\n• A simple service to test your Yara rules against a large set of malicious and identified files.\n\nWe're aggregating the Twitter handles for anyone involved with the projects on this page into a single list: awesome-yara Twitter list. Do let us know if anyone is missing.\n• Upping the APT hunting game: learn the best YARA practices from Kaspersky\n• Star-Gazing | Using a Full Galaxy of YARA Methods to Pursue an Apex Actor | By Greg Lesnewich\n• DEF CON 26 - Andrea Marcelli - Looking for the perfect signature an automatic YARA rules\n\nThis list is maintained by InQuest. Feel free to let us know about anything we're missing!"
    },
    {
        "link": "https://kravensecurity.com/yara-rules",
        "document": "YARA rules are powerful pattern-matching tools for identifying, classifying, and detecting malicious activity. Malware analysts, security researchers, and incident responders use them to defend against malware and hunt for bad guys. They are also one of the fundamental pieces of tactical intelligence you will share with operational teams as a cyber threat intelligence analyst.\n\nYARA is a key concept for any cyber security professional to learn, and this guide will teach you everything you need to know. You will discover what YARA rules are and how to use them, explore how to create your own YARA rules with useful tips, and unlock the best practices for using YARA rules in the real world.\n\nLet’s dive in and begin elevating our cyber security skills!\n\nYARA is a powerful pattern-matching tool for searching within data, such as memory dumps, packet captures, or binary files, for patterns. It is used in cyber security primarily to detect malware and hunt for indicators on endpoints. This makes it useful across various fields.\n\nYou can think of YARA as grep or regular expressions on steroids with its advanced pattern-matching features, extension modules, and wide adoption in the malware analysis and incident response community.\n\nAs a threat intelligence analyst, you must become familiar with understanding, handling, and creating your own YARA rules. They are essential to your tactical intelligence toolkit and help operational teams proactively hunt for malicious activity.\n\nLet’s explore what a YARA rule actually looks like so you can begin using them.\n\nThe team behind VirusTotal maintains YARA to help malware researchers identify and classify malware samples. The tool, which has the tagline “The pattern-matching Swiss knife for malware researchers (and everyone else),” has become a staple in the cyber industry. It is widely used by researchers, analysts, and security tooling.\n\nThe most basic YARA rule will consist of three main sections.\n• Meta Section: This contains metadata about the rule, such as its name, a brief description of what it detects, the author, and other references.\n• Strings Section: This section defines the binary strings or patterns the rule should match against. They can be plaintext strings (enclosed in double quotes), hexadecimal byte sequences (enclosed in curly brackets), or regular expressions (enclosed with forward slashes).\n• Condition Section: Where the logic of the rule is stored. This section defines the criteria required to trigger the rule using Boolean logic and the data described in the Strings Section.\n\nYARA rules are typically broken into individual files ending in , each targeting a specific malware variant, TTP, or threat actor. However, you can combine multiple YARA rules into a single file or import other rules into a file.\n\nYARA rules can also include comments. Use for a single comment or for a multi-line comment.\n\nOnce you have created a YARA rule or set of rules, you can use the YARA command line tool or another security tool that uses the YARA engine to test a target, such as a file, folder, or process, against your rules.\n\nOn the Windows command line, execute to scan a file with the YARA executable.\n\nHere, the and files are scanned using the YARA rule. You can see matches against a rule in this file named , whereas the file does not (no output).\n\nYou can download the YARA command line tool from VirusTotal’s GitHub page. Other popular alternative applications that allow you to run YARA rules, along with other common detection rule formats like IOC lists and Sigma rules, include:\n\nIn addition to applications, there are add-ons that allow you to use YARA with popular tools (e.g., Burp Suite, IDA Pro, Binary Ninja, Cutter, Firefox) and wrappers/bindings for popular programming frameworks (e.g., C#, go, OCaml, Java, Rust, etc.). This compatibility allows you to integrate YARA into your own custom tools.\n\nYARA was originally written in Python, so don’t worry. If you are a Python fan, there are plenty of Python modules to create, parse, and run YARA rules.\n\nOne of YARA’s key features is its ability to match various types of strings against files. The most popular of these is hexadecimal byte sequences because attackers find them difficult to hide or obfuscate in binary files. Because of this, YARA includes special hex values to make pattern matching more versatile.\n• Wildcards that let you use the question mark ( ) to match any single byte in a hexadecimal string. For example, would match any sequence that starts with , followed by any byte, and then .\n• Ranges representing consecutive bytes in a hexadecimal string using the hyphen character ( ). For example, would match any sequence that starts with , followed by any byte between and .\n• Negation using the exclamation mark ( ) to exclude patterns.\n• Alternatives to provide different options for a given fragment of a hex string. For example, will match or . This is similar to the OR Boolean operator.\n\nYou can even chain these special values together to create complex patterns.\n\nThis is just a taste of YARA’s string-matching capabilities. For a complete reference guide on text and regular expression capabilities, see the documentation on writing rules.\n\nYARA’s most powerful feature is its module extensions, which provide additional functionality beyond the core features of the YARA engine. These modules allow you to integrate tools, services, and data sources with YARA to extend its capabilities.\n• PE: Match against the fields in a Portable Executable (PE) header. These are Windows executable files.\n• ELF: Match against the fields in an Executable and Linkable Format (ELF) header. These are Linux executable files.\n• Magic: Match against the “magic bytes” that distinguish a file’s type.\n• Hash: Calculate and match against a file’s MD5, SHA1, or SHA256 hash.\n• Math: Calculate certain values from portions of the file and match against them, such as the file size, entropy, and common mathematical functions like mean.\n• Dotnet: Match against attributes and features of the .NET file format.\n• Time: Allows you to use temporal conditions in your rules, such as comparing to the current time.\n• Console: A module for logging information to standard output (stdout) during condition execution.\n• LNK: Match against attributes and features of the LNK file format.\n\nFor instance, to search for files with the filename that are of uncommon size, you can use the following YARA rule:\n\nThis rule uses the function to search for the magic bytes (the MZ header present in all PE files) at offset to match all PE files. It then uses the module to match and a range to find files less than or greater than (uncommon for the genuine explorer.exe process). The field helps an analyst triage the detection.\n\nYou can use community modules or write your own to express more complex conditions. Modules are written in C and built into YARA at compile time. Creating your own YARA modules is outside the scope of this article. For a complete guide, read the documentation for writing your own modules.\n\nNow that you have a basic understanding of YARA rules and how to create them let’s explore some tips to help you get started.\n\nYARA rules can range from simple ones that match a text string to extremely complex ones that use multiple modules and conditions to avoid triggering false positives. This can make mastering YARA rules difficult.\n\nAt times, YARA can seem like a never-ending battle to create a detection rule that accounts for all potential false positives but is not too specific to exclude malware variations. This can quickly add complexity to your rule, impact the performance, and make it hard to maintain.\n\nHere are some useful tips for writing effective YARA rules to help you get started and avoid common pitfalls.\n\nThe documentation is the first step in creating YARA rules! Here, you will find everything you need to start, including instructions on writing rules and references to using specific tool features. Begin by defining the purpose and objective of your rule and create simple detection logic that meets these requirements. Don’t try to go all in from the start by importing several modules or matching all edge cases. Start simple and build up your rule over time to reduce false positives by only including the code you need. The simpler the rule, the faster it will run. Use a name that clearly describes the purpose or functionality of the YARA rule. Using generic names or numbers is useless if you intend to share it with the wider community. It also makes your rules harder to manage as your ruleset grows. Include metadata! Your rule should always include documentation that describes its purpose, the type of threat it targets, and any relevant references or sources it uses (you cannot include all this in a name). This data will help other analysts (and future you) understand and use your rules effectively. YARA rules will generate false positives (trigger on legitimate binaries) or false negatives (not trigger when you want them to). The only way to find these is to rigorously test your rule against diverse samples, including malicious and benign files. This will allow you to evaluate its effectiveness and performance and make necessary changes to improve accuracy. YARA has been widely adopted in cyber by a thriving community of enthusiasts. Use this to your advantage. Collaborate with other cyber security professionals, exchange rules and insights, and contribute to community-driven threat intelligence efforts. This will help you create better rules and strengthen the overall cyber landscape. Contextual information, such as file metadata and attributes, can be incredibly helpful in enhancing the accuracy of your YARA rules. If you know a piece of malware is always a certain size or always includes a certain PE header attribute, you can instantly filter out anything that doesn’t match these requirements. This will reduce the range of false positives and let you narrow in on what you want to search for (specific strings or mutexes). Tune How Specific Your Rules Are Not all YARA rules are designed to fulfill the same purpose. Some are used to hunt potentially malicious behavior and generate more false positives to spread a wider net. Others are focused on detecting threats and will only trigger if a specific malicious thing is found. Ensure you define your rule’s purpose. It will affect how specific you make it.\n\nIf you are still struggling to get started or want to know how your rules compare to others, check out these free learning resources:\n• The YARA toolkit: An excellent collection of YARA tools by Thomas Roocia. It includes a YARA editor, generator, scanner, code generation tools, and database of YARA rules you can search through.\n• Yara-Rules GitHub repository: A great collection of YARA rules that you can use to hunt for malware or as inspiration to create your own rules.\n• Awesome YARA: A curated list of awesome YARA rules, tools, and resources to accelerate your learning journey.\n\nAt this point, you may think, “YARA rules are great. Why not use them for everything?” Unfortunately, like everything in security, they have moments of brilliance and real-world limitations, so let’s explore when it is right to use them.\n\nWhen to Use YARA Rules\n\nYARA is a versatile technology that cyber security analysts can use in various scenarios. These include:\n• Malware Analysis: Write rules that identify, classify, and detect malware using known malware signatures or patterns within files or data.\n• Threat Hunting: Create rules that allow you to proactively search for IOCs or suspicious patterns across systems or networks.\n• Incident Response: Use YARA rules to help you identify and contain compromised systems during a security incident. You can even incorporate them into your incident response playbooks.\n• Threat Intelligence: Share YARA rules with the cyber security community to help others defend against emerging cyber threats and foster collaboration.\n• Detection Engineering: Use YARA to create custom detections tailored to your specific environment based on your threat model or threat profile.\n\nThis versatility allows any organization to strengthen its security posture by leveraging YARA rules effectively and offers the following key benefits:\n\nWhen NOT to Use YARA Rules\n\nDespite their many benefits, YARA rules are not perfect for every situation. Their limitations mainly revolve around performance issues (running a YARA scan is resource-intensive) and skill issues (learning how to use YARA effectively takes time and dedication).\n\nHere are some common limitations you will face when trying to use YARA rules:\n\nThese limitations can make automating and scaling YARA across your enterprise challenging. You must carefully consider the implications of using YARA before incorporating it into your real-world workflows. However, if you are smart about where and when you use YARA rules, the benefits will outweigh the limitations for most organizations.\n\nKnow What You Are Scanning For\n\nAnother important factor to consider when using YARA rules is the type of malware that runs against them. These days, most malware is packed (encrypted or obfuscated to make it difficult to detect) and then unpacked at runtime. YARA struggles to detect packed malware.\n\nThe real value of YARA comes when you write rules that detect things in unpacked malware. This could mean executing YARA rules against a running process’s memory or performing dynamic malware analysis.\n\nBefore you scan all your systems using YARA rules, think about what your YARA rules are actually searching for.\n\nUsing and understanding YARA rules is a fundamental skill for anyone in a technical cyber security role. Their powerful pattern-matching capabilities allow you to identify, classify, and detect malicious activity in files, data, and running processes. This makes them a key piece of intelligence for threat hunting, incident response, and malware analysis.\n\nThis guide has covered everything you need to start using YARA rules and crafting your own custom rules. You saw what a YARA rule looks like, how to scan files using them, and various tips on writing effective rules. Now, it’s time to apply this knowledge.\n\nUse the advice on using YARA in the real world and begin using this awesome technology!"
    },
    {
        "link": "https://varonis.com/blog/yara-rules",
        "document": "YARA rules are used to classify and identify malware samples by creating descriptions of malware families based on textual or binary patterns.\n\nIn this article I will cover:\n• Elements you will need to know about YARA\n\nYARA rules are like a piece of programming language, they work by defining a number of variables that contain patterns found in a sample of malware. If some or all of the conditions are met, depending on the rule, then it can be used to successfully identify a piece of malware.\n\nWhen analyzing a piece of malware researchers will identify unique patterns and strings within the malware that allows them to identify which threat group and malware family the sample is attributed to. By creating a YARA rule from several samples from the same malware family, it is possible to identify multiple samples all associated with perhaps the same campaign or threat actor.\n\nWhen investigating a piece of malware an analyst may create a YARA rule for a new sample they are investigating. This rule could then be used to search their own private malware database or online repositories such VirusTotal for similar samples.\n\nIf the malware analyst works for an organization that deploys an IPS or another YARA-supported platform that is used for malware protection, then YARA rules can be used as an incident response tool to detect malicious binaries within the organization.\n\nYARA has proven to be extremely popular within the infosec community, the reason being is there are a number of use cases for implementing YARA:\n• Incident Responders can deploy YARA rules to identify samples and compromised devices\n• Proactive deployment of custom YARA rules can increase an organization’s defenses\n\nIn order to build a useful YARA rule, you will need to know the various elements that can be used to build your own custom YARA rule.\n\nMetadata doesn’t affect what the YARA rule will search for, instead, it provides useful information about the rule itself.\n• Version – The version number of the YARA rule for tracking amendments.\n• Reference – A link to an article or download of the sample, this is used to provide relevant information on the malware sample the rule is designed to detect.\n• Description – A brief overview of the rule’s purpose and malware it aims to detect.\n• Hash – A list of sample hashes that were used to create the YARA rule.\n\nIt is common to find unique and interesting strings within a malware sample, these are ideal for building out a YARA rule. To define a string within a rule, the string itself needs to be declared as a variable.\n\nIn addition to declaring a string, we can also append modifiers after the declared string to fine-tune the search.\n• $a=”malwarestring” fullword – This modifier will match against an exact word. For example ‘www.malwarestring.com’ would return a match, but ‘www.abcmalwarestring.com’ would not.\n• $a=”malwarestring” wide – This would match unicode strings which are separated by null bytes, for example ‘w.w.w…m.a.l.w.a.r.e.s.t.r.i.n.g…c.o.m.’\n• $a=”malwarestring” wide ascii – This will allow the rule to match on unicode and ascii characters.\n• $a=”MalwareString” nocase – The rule will match the string regardless of case.\n\nIn the image below I have used HxD, a hex editor, here we can see some strings within the tool.\n\nI have highlighted the ASCII string ‘\\photo.png’ and the corresponding hexadecimal representation is also highlighted. Using this information you can declare a hex string within a YARA rule.\n• $a={5C 70 68 6F 74 6F 2E 70 6E 67} – Note the use of curly brackets instead of speech quotations.\n• $a={5C 70 68 6F ?? ?F 2E 70 6E 67} – Question marks can be used as wildcards if you have detected a slight variation of a hex pattern within multiple samples.\n• $a={5C [2-10] 6F 74 6F 2E 70 6E 67} – In this example, I have stated that the string may start with the value ‘5C’ but there may be 2 – 10 random bytes before the matching pattern begins again.\n• $a={5C (01 02 | 03 04) 6F 2E 70 6E 67} – In this example i have stated that the hex values in this location could be ‘01 02’ or ‘03 04’.\n\nSome strings and unique identifiers that are great for YARA rules:\n• Mutexes – Unique to malware families, these are used by malware to check if a device has already been compromised by checking for the presence of the mutex.\n• Rare and unusual user agents – Identified when malware communicates with its C2 infrastructure.\n• Registry keys – Often created by malware as a persistence mechanism.\n• PDB paths – This stands for Program Database, a PDB contains debugging information about a file. It is very unlikely you will have PDB for a piece of malware but the PDB path can often be found and used in a YARA rule i.e. c:\\users\\user\\desktop\\vc++ 6\\6.2.20\\scrollerctrl_demo\\scrollertest\\release\\scrollertest.pdb.\n• Encrypted config strings – Malware will often encrypt its config which contains useful IOCs such as IP addresses and domains. If you have the reverse engineering skills to identify this encrypted data then it can be used within a YARA rule.\n\nThe strings section defines the search criteria that will be used for a YARA rule, the conditions section defines the criteria for the rule to trigger a successful match. There are multiple conditions that can be used which I will outline.\n• uint16(0) == 0x5A4D – Checking the header of a file is a great condition to include in your YARA rules. This condition is stipulating that the file must be a Windows executable, this is because the hex values 4D 5A are always located at the start of an executable file header. This is reversed in YARA due to endianness.\n• uint32(0)==0x464c457f) or (uint32(0) == 0xfeedfacf) or (uint32(0) == 0xcffaedfe) or (uint32(0) == 0xfeedface) or (uint32(0) == 0xcefaedfe) – Used to identify Linux binaries by checking the file header.\n\nThere are a few different ways to specify the file size condition.\n\nOnce the strings have been declared within a rule you can then customize how many matches need to be triggered as a condition for the rule to return what it deems a successful condition.\n• all of them\n• any of them\n\nWhere possible try and use 2-3 groups of conditions in order to avoid generating false positives and to also create a reliable rule.\n\nImports are a great way to implement additional conditions into your YARA rules, in this article I will cover some examples of how to use the PE import.\n\nAdding the syntax ‘import pe’ to the start of a YARA rule will allow you to use the PE functionality of YARA, this is useful if you cannot identify any unique strings.\n\nExports are great additions to a YARA rule, exports are functions that the malware author has created so be sure to make use of their unique names. In the image below I have identified some exports used by a DLL that was dropped by a piece of Formbook malware.\n\nIn the image below I have identified an interesting DLL that is used for HTTP connectivity, winhttp.dll:\n\nWe can also see that this library imports a number of interesting APIs that could be included within a rule.\n\nAn imphash is the hash of the malware’s import address table or IAT which we identified in the previous image using PEStudio. The same IAT will often be used across a malware family so using it in a YARA rule should detect similar samples.\n\nFor a files timestamp to be used in a YARA rule it must be converted to an epoch unix timestamp, in the image below I have identified when the malware was compiled.\n\nUsing the syntax ‘//’ allows comments to be made within the rule, so below I am able to add a comment which specifies what the epoch timestamp is.\n\nThe version section of PEStudio shows that this sample of Lokibot has some unique version identifiers, using the pe.version_info function we can specify which version properties to use such as the ‘CompanyName’ field.\n• pe.language(0x0804) // China – Languages identified can be used by specifying the Microsoft language code.\n\nIn the image below I have identified a number of sections in the malware that aren’t commonly found in other Windows executables I have analyzed. Using this information I can specify specific section names and the associated section number.\n\nNote the sections are zero-indexed, so the first section would be ‘0’, the second would be ‘1’, and so on. So in the example below I have used the section named ‘BSS’ which is section number two.\n\nThe image below is an example YARA rule I have created based on a sample of Redline malware:\n\nThe YARA rule begins with the syntax ‘rule’ followed by the name of the rule. This is then appended with ‘{‘ to signify the content of the YARA rule.\n\nJust above this, I have imported PE functionality by using the statement “import pe”, this functionality is used in the condition section of the rule.\n\nIn the example rule, I have included the author, file type of the malware, date the rule was written, rule version, a reference to where I got the sample from, and also a hash of the malware. This gives some contextual information to anybody else who may use the rule or may even be of use to the author when they revisit the rule at a later point in time.\n\nNext, I have specified some strings that I have found in the malware sample, these are declared as variables within the rule and can be used to search for files with similar content.\n\nThe strings I have used were identified using PEStudio and are a mix of interesting Windows API and strings that I think will be unique to this malware family.\n\nThe conditions section is where the rule declares what conditions must be met in order for the YARA rule to trigger a match, the first rule I have stipulated is that the file header must be a Windows Executable. This is done by specifying the hex values found in the header of a Windows Executable, in the image below you can see how this is identified using a hex editor.\n\nThe file version within the malware also struck me as something that may be unique to the malware so I included this within the rule – “Versium Research 5 Installation”.\n\nI have also specified that three imports must be present which PEStudio has flagged up as suspicious.\n\nWith time and experience, you will be able to spot suspicious sections within samples. Some examples of common sections you will see are ‘.data’, ‘.reloc’, and ‘.rsrc’. In this sample, I have found a few sections which don’t fit this pattern so my YARA rule is looking for the sections named ‘CODE’ and ‘BSS’.\n\nThe other conditions I have stipulated that must be met are that the first string declared as ‘$a1’ must be present OR three of the ‘$b’ strings or one of the ‘$c’ strings. The remaining condition is that the file size must be less than 50000 bytes.\n\nThis rule can now be used to start hunting for additional Redline samples.\n\nYou now have the knowledge to start building out your own YARA rules to start hunting out new samples for analysis or alternatively start implementing some proactive detections within your organization.\n\nIf you are looking to mature your organization’s security posture then check out Varonis’ Edge: Perimeter Detection and Data Security Platform."
    },
    {
        "link": "https://0xdf.gitlab.io/2019/03/27/analyzing-document-macros-with-yara.html",
        "document": "This post is actually inspired by a box I’m building for HTB, so if it ever gets released, some of you may see this post again. But Yara is also something I’ve used a ton professionally, and it is super useful. I’ll introduce Yara, a pattern matching tool which is super useful for malware analysis, and just a general use tool that’s useful to know. I’ll also look at the file format for both Microsoft Office and Libre Office documents, and how to decompress them to identify their contents. I’ll show how for Libre Office files, Yara can be applied to the unzipped document to identify macro contents.\n\nYara is a tool that allows you to write rules to identify, organize, and classify similar files. This is particularly useful to malware analysts, who want to gather various samples that share certain characteristics to analyze together. The tool will scan through a file or directory of files with a provided rule and identify any files that match the patterns in the rule.\n\nMost Linux distros will allow . For Windows, you’ll need to download the binaries (yes, the official docs point to a weird googledrive url).\n\nI’ll borrow an example rule from the Yara Documentation, thought with some modification for my purposes:\n\nThe rule starts with a name, and then has three sections:\n• - metadata about the rule; helpful to keeping lots of rules organized, but not required\n• - defines what combination of strings must be present to make a match\n• you can do things like to specify the location in the file that the string much match as well\n• if you define several strings that start with (such as , , etc), you can also do .\n\nI’ve got three example strings there:\n• is a set of hex bytes to look for\n• is a regex pattern, in this case matching on IPv4 address\n• is a string that will match on that ASCII string; strings can also take descriptors like , , and\n\nAt the heart of it, both modern Office documents ( , , , etc) using the Office Open XML format and Libre Office and Open Office documents ( , , etc) using the OpenDocument format are zip-compressed archives of XML documents.\n\nThis is not the case for legacy Binary File Format used in ( , , etc).\n\nI took a Macro-enabled Excel document that I had around for other purposes, renamed it to , and extracted the contents. Here’s what I got out (macros highlighted with ):\n\nUnfortunately, the macros are in , which is a binary format. The format is well documented, and tools like oledump and olevba will display macros without having to open or unzip the document in Office.\n\nThe OpenDocument Format can be unzipped the same way. If I rename a file to , and unzip, I get:\n\nIn this case, has my full macros in it:\n\nThe module has the following options:\n\nOn running, it will generate a document with a macro. That macro contains code that executes a PowerShell downloader, which reaches back to my Kali box and downloads the rest of the payload, in this case, Meterpreter.\n\nI’ll run this to generate the document and start the listener. I’ll have to chance the as I already have burp listening on 8080, and it won’t create the document if it can’t listen.\n\nI can take my document and run it somewhere to try to get a connection, but for the purposes of this post, I can exit MSF now.\n\nNow I can open up the document and take a look.\n\nI’ll find the macros in the Basic folder, under :\n\nHere’s the code (I’ve pulled it out of the XML and removed some of the simple encoding like replacing with ):\n\nThere’s four functions. I’m going to guess (correctly) that is called on document open. It calls , and if the result is , , or , it calls . issues a common PowerShell command to download and execute further PowerShell from the Metasploit server.\n\nNow that I see how the Metasploit code looks, I can write a yara rule to look for it. A first attempt might be something like this:\n\nI’ll look for strings that seem like they might be specific to the Metasploit generated document, like the function names.\n\nThis is obviously an art, not a science, and there are many ways to with this. I may want to look for better signatures because the function names are arbitrary, and could be modified by the attacker. On the other hand, I could find that other documents have similar function names and return false positives. Perhaps I should look for the PowerShell code instead. Obviously test this for your environment and use-case to both ensure you’re getting as much of the bad stuff as possible while not being flooded with false positives.\n\nI can now run this against the directory containing my unzipped document. I’ll use to search into subdirectories, give it my rule, and the directory to check. It returns the name of the rule that matched, and the file that matched:\n\nI’ll focus the rest of this post on simple rules to look for malicious PowerShell in OpenDocument format, since the macros are easily available once unzipped.\n\nThere are still plenty of things you can do with an unzipped word doc. Some examples:\n• DDE can be used to get RCE, and yara can detect it in Binary Office Documents.\n• Find RTF exploits like CVE-2017-0199, which is often found in Word docs.\n\nThat said, if you’re in a position to unzip a word doc and run yara against it, you’re likely in a position to run against it as well to dump the code, and then run yara against that as well.\n\nThis post only scratches the surface of what can be done with Yara, and how I might look at documents. Yara can be such a powerful tool to matching and identifying malicious files. There is certainly an art of making rules that catch the stuff you want and don’t return false positives, and any rule is likely going to have to be tuned to the environment and use case. Hopefully this sparks some ideas for how you might use Yara to solve a problem you face."
    },
    {
        "link": "https://yara.readthedocs.io/en/stable",
        "document": "YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a. rule, consists of a set of strings and a boolean expression which determine its logic. Let's see an example:\n\nThe above rule is telling YARA that any file containing one of the three strings must be reported as silent_banker. This is just a simple example, more complex and powerful rules can be created by using wild-cards, case-insensitive strings, regular expressions, special operators and many other features that you'll find explained in this documentation."
    },
    {
        "link": "https://yara.readthedocs.io",
        "document": "YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a. rule, consists of a set of strings and a boolean expression which determine its logic. Let's see an example:\n\nThe above rule is telling YARA that any file containing one of the three strings must be reported as silent_banker. This is just a simple example, more complex and powerful rules can be created by using wild-cards, case-insensitive strings, regular expressions, special operators and many other features that you'll find explained in this documentation."
    },
    {
        "link": "https://ecma-international.org/wp-content/uploads/Office-Open-XML-White-Paper.pdf",
        "document": ""
    },
    {
        "link": "https://cloud.google.com/blog/topics/threat-intelligence/detecting-embedded-content-in-ooxml-documents",
        "document": "On Advanced Practices, we are always looking for new ways to find malicious activity and track adversaries over time. Today we’re sharing a technique we use to detect and cluster Microsoft Office documents—specifically those in the Office Open XML (OOXML) file format. Additionally, we’re releasing a tool so analysts and defenders can automatically generate YARA rules using this technique.\n\nBeginning with Microsoft Office 2007, the default file format for Excel, PowerPoint, and Word documents switched from an Object Linking and Embedding (OLE) based format to OOXML. For now, the only part of this that’s important to understand is OOXML documents are just a bunch of folders and files packaged into a ZIP archive. Let’s look at the Word document this blog post is being written in (Figure 1), for example:\n\nNow, even though we used the unzip command, we didn’t actually unzip the archive. The output provided by the -v option is derived from the ZIP local file headers, which contain a wealth of information on the compressed files. Of particular interest is the CRC-32 value.\n\nA cyclic redundancy check (CRC) is an algorithm designed to detect errors or unintended changes to data. The idea is a system can calculate a CRC value before and after a transfer or transformation of data as a simple way to ensure its integrity. For ZIP archives, the CRC-32 values confirm the decompressed files are the same as they were prior to compression. Which is great and all, but they can serve other use cases too.\n\nForget about error-detection. A ZIP CRC-32 value is essentially a small hash of the uncompressed file, and what better way to identify a file than by its hash? While the chance of a collision for CRC-32 is significantly higher than other algorithms such as SHA-256 or even MD5, it can be paired with additional metadata like the file name (or extension) and size to reduce false positives.\n\nHere’s a hex dump of the first local file header from the previous example (Figure 2):"
    }
]