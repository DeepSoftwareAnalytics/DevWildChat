[
    {
        "link": "http://pascal.hansotten.com/uploads/standardpascal/Programming%20standard%20Pascal.pdf",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/cd/E19957-01/802-5762/802-5762.pdf",
        "document": ""
    },
    {
        "link": "https://downloads.freepascal.org/fpc/docs-pdf/ref.pdf",
        "document": ""
    },
    {
        "link": "https://cslab.pepperdine.edu/warford/ComputingFundamentals/PboxCh21.pdf",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Pascal_(programming_language)",
        "document": "Pascal is an imperative and procedural programming language, designed by Niklaus Wirth as a small, efficient language intended to encourage good programming practices using structured programming and data structuring. It is named after French mathematician, philosopher and physicist Blaise Pascal.[a]\n\nPascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version named ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970.\n\nOn top of ALGOL's scalars and arrays, Pascal enables defining complex datatypes and building dynamic and recursive data structures such as lists, trees and graphs. Pascal has strong typing on all objects, which means that one type of data cannot be converted to or interpreted as another without explicit conversions. Unlike C (and also unlike most other languages in the C-family), Pascal allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside subroutines (procedures and functions). A program is thus syntactically similar to a single procedure or function. This is similar to the block structure of ALGOL 60, but restricted from arbitrary block statements to just procedures and functions.\n\nPascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++.\n\nA derivative named Object Pascal designed for object-oriented programming was developed in 1985. This was used by Apple Computer (for the Lisa and Macintosh machines) and Borland in the late 1980s and later developed into Delphi on the Microsoft Windows platform. Extensions to the Pascal concepts led to the languages Modula-2 and Oberon, both developed by Wirth.\n\nMuch of the history of computer language design during the 1960s can be traced to the ALGOL 60 language. ALGOL was developed during the 1950s with the explicit goal of being able to clearly describe algorithms. It included a number of features for structured programming that remain common in languages to this day.\n\nShortly after its introduction, in 1962 Wirth began working on his dissertation with Helmut Weber on the Euler programming language. Euler was based on ALGOL's syntax and many concepts but was not a derivative. Its primary goal was to add dynamic lists and types, allowing it to be used in roles similar to Lisp. The language was published in 1965.\n\nBy this time, a number of problems in ALGOL had been identified, notably the lack of a standardized string system. The group tasked with maintaining the language had begun the ALGOL X process to identify improvements, calling for submissions. Wirth and Tony Hoare submitted a conservative set of modifications to add strings and clean up some of the syntax. These were considered too minor to be worth using as the new standard ALGOL, so Wirth wrote a compiler for the language, which became named ALGOL W.\n\nThe ALGOL X efforts would go on to choose a much more complex language, ALGOL 68. The complexity of this language led to considerable difficulty producing high-performance compilers, and it was not widely used in the industry. This left an opening for newer languages.\n\nPascal was influenced by the ALGOL W efforts, with the explicit goals of teaching programming in a structured fashion and for the development of system software.[5] A generation of students used Pascal as an introductory language in undergraduate courses. Other goals included providing a reliable and efficient tool for writing large programs,[6] and bridging the canyon between scientific and commercial programming, as represented by the then-widespread languages Fortran and COBOL, with a general-purpose language.[7]\n\nOne of the early successes for the language was the introduction of UCSD Pascal, a version that ran on a custom operating system that could be ported to different platforms. A key platform was the Apple II, where it saw widespread use as Apple Pascal. This led to Pascal becoming the primary high-level language used for development in the Apple Lisa, and later, the Macintosh. Parts of the original Macintosh operating system were hand-translated into Motorola 68000 assembly language from the Pascal source code.[8]\n\nThe typesetting system TeX by Donald Knuth was written in WEB, the original literate programming system, based on DEC PDP-10 Pascal. Successful commercial applications like Adobe Photoshop[9] were written in Macintosh Programmer's Workshop Pascal, while applications like Total Commander, Skype[10] and Macromedia Captivate were written in Delphi (Object Pascal). Apollo Computer used Pascal as the systems programming language for its operating systems beginning in 1980.\n\nVariants of Pascal have also been used for everything from research projects to PC games and embedded systems. Newer Pascal compilers exist which are widely used.[11]\n\nWirth's example compiler meant to propagate the language, the Pascal-P system, used a subset of the language designed to be the minimal subset of the language that could compile itself. The idea was that this could allow bootstrapping the compiler, which would then be extended to full Pascal language status. This was done with several compilers, but one notable exception was UCSD Pascal, which was based on Pascal-P2. It kept the subset status of the language based on the idea that this would run better on the new (then) microprocessors with limited memory. UCSD also converted the Pascal-P2 interpreter into a \"byte machine\", again, because it would be a better fit for byte oriented microprocessors.\n\nUCSD Pascal formed the basis of many systems, including Apple Pascal. Borland Pascal was not based on the UCSD codebase, but arrived during the popular period of UCSD and matched many of its features. This started the line that ended with Delphi Pascal and the compatible Open Source compiler FPC/Lazarus.\n\nThe ISO standard for Pascal, ISO 7185, was published in 1983 and was widely implemented and used on mainframes, minicomputers and IBM-PCs and compatibles from 16 bits to 32 bits. The two dialects of Pascal most in use towards the end of the 20th century and up until today are the ISO 7185 standard version and the Delphi/Turbo Pascal versions (of which the two Borland versions are mostly compatible with each other).\n\nThe source for much of the early history on Pascal can be found in the Pascal User's Group newsletters at:\n\nDuring work on the Lisa, Larry Tesler began corresponding with Wirth on the idea of adding object-oriented extensions to the language, to make Pascal a multi-paradigm programming language. This led initially to Clascal, introduced in 1983. As the Lisa program faded and was replaced by the Macintosh, a further version was created and named Object Pascal. This was introduced on the Mac in 1985 as part of the MacApp application framework, and became Apple's main development language into the early 1990s.\n\nThe Object Pascal extensions were added to Turbo Pascal with the release of version 5.5 in 1989.[12] Over the years, Object Pascal became the basis of the Delphi system for Microsoft Windows, which is still used for developing Windows applications, and can cross-compile code to other systems. Free Pascal is an open source, cross-platform alternative with its own graphical IDE called Lazarus.\n\nThe first Pascal compiler was designed in Zürich for the CDC 6000 series mainframe computer family. Niklaus Wirth reports that a first attempt to implement it in FORTRAN 66 in 1969 was unsuccessful due to FORTRAN 66's inadequacy to express complex data structures. The second attempt was implemented in a C-like language (Scallop by Max Engeli) and then translated by hand (by R. Schild) to Pascal itself for boot-strapping.[13] It was operational by mid-1970. Many Pascal compilers since have been similarly self-hosting, that is, the compiler is itself written in Pascal, and the compiler is usually capable of recompiling itself when new features are added to the language, or when the compiler is to be ported to a new environment. The GNU Pascal compiler is one notable exception, being written in C.\n\nThe first successful port of the CDC Pascal compiler to another mainframe was completed by Welsh and Quinn at the Queen's University of Belfast (QUB) in 1972. The target was the International Computers Limited (ICL) 1900 series. This compiler, in turn, was the parent of the Pascal compiler for the Information Computer Systems (ICS) Multum minicomputer. The Multum port was developed – with a view to using Pascal as a systems programming language – by Findlay, Cupples, Cavouras and Davis, working at the Department of Computing Science in Glasgow University. It is thought that Multum Pascal, which was completed in the summer of 1973, may have been the first 16-bit implementation.\n\nA completely new compiler was completed by Welsh et al. at QUB in 1977. It offered a source-language diagnostic feature (incorporating profiling, tracing and type-aware formatted postmortem dumps) that was implemented by Findlay and Watt at Glasgow University. This implementation was ported in 1980 to the ICL 2900 series by a team based at Southampton University and Glasgow University. The Standard Pascal Model Implementation was also based on this compiler, having been adapted, by Welsh and Hay at Manchester University in 1984, to check rigorously for conformity to the BSI 6192/ISO 7185 Standard and to generate code for a portable abstract machine.\n\nThe first Pascal compiler written in North America was constructed at the University of Illinois under Donald B. Gillies for the PDP-11 and generated native machine code. Microsoft had Pascal compilers for IBM PCs, see Microsoft Pascal.\n\nTo propagate the language rapidly, a compiler porting kit was created in Zürich that included a compiler that generated so called p-code for a virtual stack machine, i.e., code that lends itself to reasonably efficient interpretation, along with an interpreter for that code – the Pascal-P system. The P-system compilers were named Pascal-P1, Pascal-P2, Pascal-P3, and Pascal-P4. Pascal-P1 was the first version, and Pascal-P4 was the last to come from Zürich. The version termed Pascal-P1 was coined after the fact for the many different sources for Pascal-P that existed. The compiler was redesigned to enhance portability, and issued as Pascal-P2. This code was later enhanced to become Pascal-P3, with an intermediate code backward compatible with Pascal-P2, and Pascal-P4, which was not backward compatible.\n\nThe Pascal-P4 compiler–interpreter can still be run and compiled on systems compatible with original Pascal (as can Pascal-P2). However, it only accepts a subset of the Pascal language.\n\nPascal-P5, created outside the Zürich group, accepts the full Pascal language and includes ISO 7185 compatibility.\n\nPascal-P6 is a follow on to Pascal-P5 that along with other features, aims to be a compiler for specific CPUs, including AMD64.\n\nUCSD Pascal branched off Pascal-P2, where Kenneth Bowles used it to create the interpretive UCSD p-System. It was one of three operating systems available at the launch of the original IBM Personal Computer.[14] UCSD Pascal used an intermediate code based on byte values, and thus was one of the earliest bytecode compilers. Apple Pascal was released in 1979 for the Apple II and Apple III computer systems. It was an implementation of, or largely based on, UCSD Pascal. Pascal-P1 through Pascal-P4 were not, but rather based on the CDC 6600 60-bit word length.\n\nA compiler based on the Pascal-P4 compiler, which created native binary object files, was released for the IBM System/370 mainframe computer by the Australian Atomic Energy Commission; it was named the AAEC Pascal 8000 Compiler after the abbreviation of the name of the commission.[15]\n\nApple Computer created its own Lisa Pascal for the Lisa Workshop in 1982, and ported the compiler to the Apple Macintosh and MPW in 1985. In 1985 Larry Tesler, in consultation with Niklaus Wirth, defined Object Pascal and these extensions were incorporated in both the Lisa Pascal and Mac Pascal compilers.\n\nIn the 1980s, Anders Hejlsberg wrote the Blue Label Pascal compiler for the Nascom-2. A reimplementation of this compiler for the IBM PC was marketed under the names Compas Pascal and PolyPascal before it was acquired by Borland and renamed Turbo Pascal.\n\nTurbo Pascal became hugely popular, thanks to an aggressive pricing strategy, having one of the first full-screen IDEs, and very fast turnaround time (just seconds to compile, link, and run). It was written and highly optimized entirely in assembly language, making it smaller and faster than much of the competition.\n\nIn 1986, Anders ported Turbo Pascal to the Macintosh and incorporated Apple's Object Pascal extensions into Turbo Pascal. These extensions were then added back into the PC version of Turbo Pascal for version 5.5. At the same time Microsoft also implemented the Object Pascal compiler.[16][17] Turbo Pascal 5.5 had a large influence on the Pascal community, which began concentrating mainly on the IBM PC in the late 1980s. Many PC hobbyists in search of a structured replacement for BASIC used this product. It also began to be adopted by professional developers. Around the same time a number of concepts were imported from C to let Pascal programmers use the C-based application programming interface (API) of Microsoft Windows directly. These extensions included null-terminated strings, pointer arithmetic, function pointers, an address-of operator, and unsafe typecasts.\n\nTurbo Pascal and other derivatives with unit or module structures are modular programming languages. However, it does not provide a nested module concept or qualified import and export of specific symbols.\n\nSuper Pascal adds non-numeric labels, a return statement and expressions as names of types.\n\nTMT Pascal was the first Borland-compatible compiler for 32-bit MS-DOS compatible protected mode, OS/2, and Win32. It extends the language with function and operator overloading.\n\nThe universities of Wisconsin–Madison, Zürich, Karlsruhe, and Wuppertal developed the Pascal-SC[18][19] and Pascal-XSC[20][21][22] (Extensions for Scientific Computation) compilers, aimed at programming numerical computations. Development for Pascal-SC started in 1978 supporting ISO 7185 Pascal level 0, but level 2 support was added at a later stage.[23] Pascal-SC originally targeted the Z80 processor, but was later rewritten for DOS (x86) and 68000. Pascal-XSC has at various times been ported to Unix (Linux, SunOS, HP-UX, AIX) and Microsoft/IBM (DOS with EMX, OS/2, Windows) operating systems. It operates by generating intermediate C source code which is then compiled to a native executable. Some of the Pascal-SC language extensions have been adopted by GNU Pascal.\n\nPascal Sol was designed around 1983 by a French team to implement a Unix-like system named Sol. It was standard Pascal level-1 (with parameterized array bounds) but the definition allowed alternative keywords and predefined identifiers in French and the language included a few extensions to ease system programming (e.g. an equivalent to lseek).[24] The Sol team later on moved to the ChorusOS project to design a distributed operating system.[25]\n\nIP Pascal is an implementation of the Pascal programming language using Micropolis DOS, but was moved rapidly to CP/M-80 running on the Z80. It was moved to the 80386 machine types in 1994, and exists today as Windows XP and Linux implementations. In 2008, the system was brought up to a new level and the resulting language termed \"Pascaline\" (after Pascal's calculator). It includes objects, namespace controls, dynamic arrays, and many other extensions, and generally features the same functionality and type protection as C#. It is the only such implementation that is also compatible with the original Pascal implementation, which is standardized as ISO 7185.\n\nPascal, in its original form, is a purely procedural language and includes the traditional array of ALGOL-like control structures with reserved words such as , , , , , and , ranging on a single statement or a - statements block. Pascal also has data structuring constructs not included in the original ALGOL 60 types, like records, variants, pointers, enumerations, and sets and procedure pointers. Such constructs were in part inherited or inspired from Simula 67, ALGOL 68, Niklaus Wirth's own ALGOL W and suggestions by C. A. R. Hoare.\n\nPascal programs start with the keyword with a list of external file descriptors as parameters[26] (not required in Turbo Pascal etc.); then follows the main block bracketed by the and keywords. Semicolons separate statements, and the full stop (i.e., a period) ends the whole program (or unit). Letter case is ignored in Pascal source.\n\nHere is an example of the source code in use for a very simple \"Hello, World!\" program:\n\nA Type Declaration in Pascal is used to define a range of values which a variable of that type is capable of storing. It also defines a set of operations that are permissible to be performed on variables of that type. The predefined types are:\n\nThe range of values allowed for the basic types (except Boolean) is implementation defined. Functions are provided for some data conversions. For conversion of to , the following functions are available: (which rounds to integer using banker's rounding) and (rounds towards zero).\n\nThe programmer has the freedom to define other commonly used data types (e.g. byte, string, etc.) in terms of the predefined types using Pascal's type declaration facility, for example\n\nOften-used types like byte and string are already defined in many implementations.\n\nNormally the system will use a word to store the data. For instance, the type may be stored in a machine integer - 32 bits perhaps - rather than an 8-bit value. Pascal does not contain language elements that allow the basic storage types to be defined more granularly. This capability was included in a number of Pascal extensions and follow-on languages, while others, like Modula-2, expanded the built-in set to cover most machine data types like 16-bit integers.\n\nThe keyword tells the compiler to use the most efficient method of storage for the structured data types: sets, arrays and records, rather than using one word for each element. Packing may slow access on machines that do not offer easy access to parts of a word.\n\nSubranges of any ordinal data type (any simple type except real) can also be made:\n\nIn contrast with other programming languages from its time, Pascal supports a set type:[27]\n\nA set is a fundamental concept for modern mathematics, and they may be used in many algorithms. Such a feature is useful and may be faster than an equivalent construct in a language that does not support sets. For example, for many Pascal compilers:\n\nSets of non-contiguous values can be particularly useful, in terms of both performance and readability:\n\nFor these examples, which involve sets over small domains, the improved performance is usually achieved by the compiler representing set variables as bit vectors. The set operators can then be implemented efficiently as bitwise machine code operations.\n\nAn example of a Pascal record type:\n\nAn example of a variant record type:\n\nVariant records allow several fields of the record to overlap each other to save space.\n\nTypes can be defined from other types using type declarations:\n\nFurther, complex types can be constructed from simple types:\n\nAs shown in the example above, Pascal files are sequences of components. Every file has a buffer variable which is denoted by f^. The procedures get (for reading) and put (for writing) move the buffer variable to the next element. Read is introduced such that read(f, x) is the same as x := f^; get(f);. Write is introduced such that write(f, x) is the same as f^ := x; put(f); The type is predefined as file of char. While the buffer variable could be used for inspecting the next character to be used (check for a digit before reading an integer), this leads to serious problems with interactive programs in early implementations, but was solved later with the \"lazy I/O\" concept, which waits until the file buffer variable is actually accessed before performing file operations.\n\nPascal supports the use of pointers:\n\nHere the variable NodePtr is a pointer to the data type Node, a record. Pointers can be used before they are declared. This is a forward declaration, an exception to the rule that things must be declared before they are used.\n\nTo create a new record and assign the value 10 and character A to the fields a and b in the record, and to initialise the pointer c to the null pointer (\"NIL\" in Pascal), the statements would be:\n\nThis could also be done using the statement, as follows:\n\nInside of the scope of the with statement, a and b refer to the subfields of the record pointer NodePtr and not to the record Node or the pointer type pNode.\n\nLinked lists, stacks and queues can be created by including a pointer type field (c) in the record.\n\nUnlike many languages that feature pointers, Pascal only allows pointers to reference dynamically created variables that are anonymous, and does not allow them to reference standard static or local variables. Pointers also must have an associated type, and a pointer to one type is not compatible with a pointer to another type (e.g. a pointer to a char is not compatible with a pointer to an integer). This helps eliminate the type security issues inherent with other pointer implementations, particularly those used for PL/I or C. It also removes some risks caused by dangling pointers, but the ability to dynamically deallocate referenced space by using the dispose function (which has the same effect as the free library function found in C) means that the risk of dangling pointers has not been eliminated[28] as it has in languages such as Java and C#, which provide automatic garbage collection (but which do not eliminate the related problem of memory leaks).\n\nSome of these restrictions can be lifted in newer dialects.\n\nPascal is a structured programming language, meaning that the flow of control is structured into standard statements, usually without 'goto' commands.\n\nPascal structures programs into procedures and functions. Generally, a procedure is used for its side effects, whereas a function is used for its return value.\n\nProcedures and functions can be nested to any depth, and the 'program' construct is the logical outermost block.\n\nBy default, parameters are passed by value. If 'var' precedes a parameter's name, it is passed by reference.\n\nEach procedure or function can have its own declarations of goto labels, constants, types, variables, and other procedures and functions, which must all be in that order. This ordering requirement was originally intended to allow efficient single-pass compilation. However, in some dialects (such as Delphi) the strict ordering requirement of declaration sections has been relaxed.\n\nPascal adopted many language syntax features from the ALGOL language, including the use of a semicolon as a statement separator. This is in contrast to other languages, such as PL/I and C, which use the semicolon as a statement terminator. No semicolon is needed before the keyword of a record type declaration, a block, or a case statement; before the keyword of a repeat statement; and before the keyword of an if statement.\n\nThe presence of an extra semicolon was not permitted in early versions of Pascal. However, the addition of ALGOL-like empty statements in the 1973 Revised Report and later changes to the language in ISO 7185:1983 now allow for optional semicolons in most of these cases. A semicolon is still not permitted immediately before the keyword in an if statement, because the follows a single statement, not a statement sequence. In the case of nested ifs, a semicolon cannot be used to avoid the dangling else problem (where the inner if does not have an else, but the outer if does) by putatively terminating the nested if with a semicolon – this instead terminates both if clauses. Instead, an explicit ... block must be used.[29]\n\nSeveral Pascal compilers and interpreters are available for general use:\n• Delphi is Embarcadero's (formerly Borland/CodeGear) flagship rapid application development (RAD) product. It uses the Object Pascal language (termed 'Delphi' by Borland), descended from Pascal, to create applications for Windows, macOS, iOS, and Android. The .NET support that existed from D8 through D2005, D2006, and D2007 has been terminated, and replaced by a new language (Prism, which is rebranded Oxygene, see below) that is not fully backward compatible. In recent years Unicode support and generics were added (D2009, D2010, Delphi XE).\n• Free Pascal is a cross-platform compiler written in Object Pascal (and is self-hosting). It is aimed at providing a convenient and powerful compiler, both able to compile legacy applications and to be the means to develop new ones. It is distributed under the GNU General Public License (GNU GPL), while packages and runtime library come under a modified GNU Lesser General Public License (GNU LGPL). In addition to compatibility modes for Turbo Pascal, Delphi, and Mac Pascal, it has its own procedural and object-oriented syntax modes with support for extended features such as operator overloading. It supports many platforms and operating systems. Current versions also feature an ISO mode.\n• Turbo51 is a free Pascal compiler for the Intel 8051 family of microcontrollers, with Turbo Pascal 7 syntax.\n• Oxygene (formerly named Chrome) is an Object Pascal compiler for the .NET and Mono platforms. It was created and is sold by RemObjects Software, and sold for a while by Embarcadero as the backend compiler of Prism.\n• Kylix was a descendant of Delphi, with support for the Linux operating system and an improved object library. It is no longer supported. Compiler and IDE are available now for non-commercial use.\n• GNU Pascal Compiler (GPC) is the Pascal compiler of the GNU Compiler Collection (GCC). The compiler is written in C, the runtime library mostly in Pascal. Distributed under the GNU General Public License, it runs on many platforms and operating systems. It supports the ANSI/ISO standard languages and has partial Turbo Pascal dialect support. One of the more notable omissions is the absence of a fully Turbo Pascal-compatible (short)string type. Support for Borland Delphi and other language variants is quite limited. There is some support for Mac-pascal, however.\n• Virtual Pascal was created by Vitaly Miryanov in 1995 as a native OS/2 compiler compatible with Borland Pascal syntax. Then, it had been commercially developed by fPrint, adding Win32 support, and in 2000 it became freeware. Today it can compile for Win32, OS/2, and Linux, and is mostly compatible with Borland Pascal and Delphi. Development was canceled on April 4, 2005.\n• Pascal-P4 compiler, the basis for many subsequent Pascal-implemented-in-Pascal compilers. It implements a subset of full Pascal.\n• Pascal-P5 compiler is an ISO 7185 (full Pascal) adaption of Pascal-P4.\n• Pascal-P6 compiler is an extended version of Pascal adaption of Pascal-P5 according to the Pascaline language specification.\n• Turbo Pascal was the dominant Pascal compiler for PCs during the 1980s and early 1990s, popular both because of its powerful extensions and extremely short compilation times. Turbo Pascal was compactly written and could compile, run, and debug all from memory without accessing disk. Slow floppy disk drives were common for programmers at the time, further magnifying Turbo Pascal's speed advantage. Currently, older versions of Turbo Pascal (up to 5.5) are available for free download from Borland's site.\n• IP Pascal implements the language \"Pascaline\" (named after Pascal's calculator), which is a highly extended Pascal compatible with original Pascal according to ISO 7185. It features modules with namespace control, including parallel tasking modules with semaphores, objects, dynamic arrays of any dimensions that are allocated at runtime, overloads, overrides, and many other extensions. IP Pascal has a built-in portability library that is custom tailored to the Pascal language. For example, a standard text output application from 1970's original Pascal can be recompiled to work in a window and even have graphical constructs added.\n• Pascal-XT was created by Siemens for their mainframe operating systems BS2000 and SINIX.\n• PocketStudio is a Pascal subset compiler and RAD tool for Palm OS and MC68xxx processors with some of its own extensions to assist interfacing with the Palm OS API. It resembles Delphi and Lazarus with a visual form designer, an object inspector and a source code editor.\n• MIDletPascal – A Pascal compiler and IDE that generates small and fast Java bytecode specifically designed to create software for mobiles.\n• Vector Pascal is a language for SIMD instruction sets such as the MMX and the AMD 3d Now, supporting all Intel and AMD processors, and Sony's PlayStation 2 Emotion Engine.\n• Morfik Pascal allows the development of Web applications entirely written in Object Pascal (both server and browser side).\n• WDSibyl – Visual Development Environment and Pascal compiler for Win32 and OS/2.\n• PP Compiler, a compiler for Palm OS that runs directly on the handheld computer.\n• CDC 6000 Pascal compiler is the source code for the first (CDC 6000) Pascal compiler.\n• VSI Pascal for OpenVMS (formerly HP Pascal for OpenVMS, Compaq Pascal, DEC Pascal, VAX Pascal and originally VAX-11 Pascal 31 ) is a Pascal compiler that runs on OpenVMS systems. 32 It was also supported under Tru64. 33 34 VSI Pascal for OpenVMS is compatible with ISO/IEC 7185:1990 Pascal as well some of ISO/IEC 10206:1990 Extended Pascal, and also includes its own extensions. 32 The compiler frontend is implemented in BLISS. 35\n• Stony Brook Pascal+ was a 16-bit (later 32-bit) optimizing compiler for DOS and OS/2, marketed as a direct replacement for Turbo Pascal, but producing code that executed at least twice as fast.\n• Dev-Pascal is a Pascal IDE that was designed in Borland Delphi and which supports Free Pascal and GNU Pascal as backends.\n• Lazarus is a free Delphi-like visual cross-platform IDE for rapid application development (RAD). Based on Free Pascal, Lazarus is available for numerous platforms including Linux, FreeBSD, macOS and Microsoft Windows.\n• Fire (macOS) and Water (Windows) for the Oxygene and the Elements Compiler\n• WOL Library for creating GUI applications with the Free Pascal Compiler.\n\nIn 1983, the language was standardized in the international standard IEC/ISO 7185[36] and several local country-specific standards, including the American ANSI/IEEE770X3.97-1983, and ISO 7185:1983. These two standards differed only in that the ISO standard included a \"level 1\" extension for conformant arrays (an array where the boundaries of the array are not known until run time), where ANSI did not allow for this extension to the original (Wirth version) language. In 1989, ISO 7185 was revised (ISO 7185:1990) to correct various errors and ambiguities found in the original document.\n\nThe ISO 7185 was stated to be a clarification of Wirth's 1974 language as detailed by the User Manual and Report [Jensen and Wirth], but was also notable for adding \"Conformant Array Parameters\" as a level 1 to the standard, level 0 being Pascal without conformant arrays. This addition was made at the request of C. A. R. Hoare, and with the approval of Niklaus Wirth. The precipitating cause was that Hoare wanted to create a Pascal version of the (NAG) Numerical Algorithms Library, which had originally been written in FORTRAN, and found that it was not possible to do so without an extension that would allow array parameters of varying size. Similar considerations motivated the inclusion in ISO 7185 of the facility to specify the parameter types of procedural and functional parameters.\n\nNiklaus Wirth himself referred to the 1974 language as \"the Standard\", for example, to differentiate it from the machine specific features of the CDC 6000 compiler. This language was documented in The Pascal Report,[37] the second part of the \"Pascal users manual and report\".\n\nOn the large machines (mainframes and minicomputers) Pascal originated on, the standards were generally followed. On the IBM PC, they were not. On IBM PCs, the Borland standards Turbo Pascal and Delphi have the greatest number of users. Thus, it is typically important to understand whether a particular implementation corresponds to the original Pascal language, or a Borland dialect of it.\n\nThe IBM PC versions of the language began to differ with the advent of UCSD Pascal, an interpreted implementation that featured several extensions to the language, along with several omissions and changes. Many UCSD language features survive today, including in Borland's dialect.\n\nIn 1990, an extended Pascal standard was created as ISO/IEC 10206,[38] which is identical in technical content[39] to IEEE/ANSI 770X3.160-1989[40] As of 2019, Support of Extended Pascal in FreePascal Compiler is planned.[41]\n\nNiklaus Wirth's Zürich version of Pascal was issued outside ETH in two basic forms: the CDC 6000 compiler source, and a porting kit called Pascal-P system. The Pascal-P compiler left out several features of the full language that were not required to bootstrap the compiler. For example, procedures and functions used as parameters, undiscriminated variant records, packing, dispose, interprocedural gotos and other features of the full compiler were omitted.\n\nUCSD Pascal, under Professor Kenneth Bowles, was based on the Pascal-P2 kit, and consequently shared several of the Pascal-P language restrictions. UCSD Pascal was later adopted as Apple Pascal, and continued through several versions there. Although UCSD Pascal actually expanded the subset Pascal in the Pascal-P kit by adding back standard Pascal constructs, it was still not a complete standard installation of Pascal.\n\nIn the early 1990s, Alan Burns and Geoff Davies developed Pascal-FC, an extension to Pl/0 (from the Niklaus' book Algorithms + Data Structures = Programs). Several constructs were added to use Pascal-FC as a teaching tool for Concurrent Programming (such as semaphores, monitors, channels, remote-invocation and resources). To be able to demonstrate concurrency, the compiler output (a kind of P-code) could then be executed on a virtual machine. This virtual machine not only simulated a normal – fair – environment, but could also simulate extreme conditions (unfair mode).\n\nBorland's Turbo Pascal, written by Anders Hejlsberg, was written in assembly language independent of UCSD and the Zürich compilers. However, it adopted much of the same subset and extensions as the UCSD compiler. This is probably because the UCSD system was the most common Pascal system suitable for developing applications on the resource-limited microprocessor systems available at that time.\n\nThe shrink-wrapped Turbo Pascal version 3 and later incarnations, including Borland's Object Pascal and Delphi and non-Borland near-compatibles became popular with programmers including shareware authors, and so the SWAG library of Pascal code features a large amount of code written with such versions as Delphi in mind.\n\nSoftware products (compilers, and IDE/Rapid Application Development (RAD)) in this category:\n• Turbo Pascal – \"TURBO.EXE\" up to version 7, and Turbo Pascal for Windows (\"TPW\") and Turbo Pascal for Macintosh.\n• Pure Pascal and HiSPeed Pascal 2 Pascal language Environment for the Atari ST range of computers.\n• Borland Pascal 7 – A professional version of Turbo Pascal line which targeted both DOS and Windows.\n• Object Pascal – an extension of the Pascal language that was developed at Apple Computer by a team led by Larry Tesler in consultation with Niklaus Wirth, the inventor of Pascal; its features were added to Borland's Turbo Pascal for Macintosh and in 1989 for Turbo Pascal 5.5 for DOS.\n• Free Pascal compiler (FPC) – Free Pascal adopted the standard dialect of Borland Pascal programmers, Borland Turbo Pascal and, later, Delphi.\n• Borland Kylix is a compiler and IDE formerly sold by Borland, but later discontinued. It is a Linux version of the Borland Delphi software development environment and C++Builder.\n• Lazarus – similar to Kylix in function, is a free cross-platform visual IDE for RAD using the Free Pascal compiler, which supports dialects of Object Pascal to varying degrees.\n• Virtual Pascal – VP2/1 is a fully Borland Pascal– and Borland Delphi–compatible 32-bit Pascal compiler for OS/2 and Windows 32 (with a Linux version \"on the way\"). 42\n• Sybil is an open source Delphi-like IDE and compiler; implementations include:\n• WDSibyl 43 for Microsoft Windows and OS/2, a commercial Borland Pascal compatible environment released by a company named Speedsoft that was later developed into a Delphi-like rapid application development (RAD) environment named Sybil and then open sourced under the GPL when that company closed down;\n• Open Sybil, which is an ongoing project, an open source tool for OS/2 and eCS that was originally based on Speedsoft's WDsybl Sibyl Portable Component Classes (SPCC) and Sibyl Visual Development Tool (SVDE) sources, but now its core is IBM System Object Model (SOM), WPS and OpenDoc. 44\n\nPascal generated a wide variety of responses in the computing community, both critical and complimentary.\n\nWirth's initial definition of the language was widely criticized. In particular, Nico Habermann commented in his \"Critical Comments on the Programming Language Pascal\" (1973) that many of its constructs were poorly defined, in particular for data types, ranges, structures, and goto.[45] Later, Brian Kernighan, who popularized the C language, outlined his criticisms of Pascal in 1981 in his article \"Why Pascal is Not My Favorite Programming Language\".[46] The most serious problem Kernighan described was that array sizes and string lengths were part of the type, so it was not possible to write a function that would accept variable-length arrays or even strings as parameters. This made it unfeasible to write, for example, a sorting library. Kernighan also criticized the unpredictable order of evaluation of Boolean expressions, poor library support, and lack of static variables, and raised a number of smaller issues. Also, he stated that the language did not provide any simple constructs to \"escape\" (knowingly and forcibly ignore) restrictions and limitations. More general complaints from other sources[28][47] noted that the scope of declarations was not clearly defined in the original language definition, which sometimes had serious consequences when using forward declarations to define pointer types, or when record declarations led to mutual recursion, or when an identifier may or may not have been used in an enumeration list. Another difficulty was that, like ALGOL 60, the language did not allow procedures or functions passed as parameters to predefine the expected type of their parameters.\n\nIn the two decades after 1975, Pascal gained increasing attention and became a major programming language for important platforms (including Apple II, Apple III, Apple Lisa, Commodore systems, Z-80-based machines and IBM PC) due to the availability of UCSD Pascal and Turbo Pascal.[48]\n\nDespite initial criticisms, Pascal continued to evolve, and most of Kernighan's points do not apply to versions of the language which were enhanced to be suitable for commercial product development, such as Borland's Turbo Pascal. As Kernighan predicted in his article, most of the extensions to fix these issues were incompatible from compiler to compiler. Since the early 1990s, however, most of the varieties seem condensed into two categories: ISO and Borland-like. Extended Pascal addresses many of these early criticisms. It supports variable-length strings, variable initialization, separate compilation, short-circuit Boolean operators, and default ( ) clauses for case statements.[49]\n\nSome of the problems arising from the differences in the implementations of Pascal were later partly solved by the advent of Free Pascal, which supports several dialects with mode directives.[50]\n• Comparison of Pascal and C\n• C. A. R. Hoare: \"Notes on data structuring\". In O.-J. Dahl, E. W. Dijkstra and C. A. R. Hoare, editors, Structured Programming, pages 83–174. Academic Press, 1972.\n• C. A. R. Hoare, Niklaus Wirth: An Axiomatic Definition of the Programming Language Pascal. 335–355, Acta Informatica, Volume 2, 1973.\n• Kathleen Jensen and Niklaus Wirth: Pascal – User Manual and Report. Springer-Verlag, 1974, 1985, 1991, ISBN 0-387-97649-3 and ISBN 3-540-97649-3.\n• Niklaus Wirth: An assessment of the programming language Pascal. 23–30 ACM SIGPLAN Notices Volume 10, Issue 6, June 1975.\n• D. W. Barron (Ed.): Pascal – The Language and its Implementation. John Wiley 1981, ISBN 0-471-27835-1\n• Richard S. Forsyth: Pascal in Work and Play, Chapman and Hall, 1982\n• N. Wirth, M. Broy, ed, and E. Denert, ed: Pascal and its Successors in Software Pioneers: Contributions to Software Engineering. Springer-Verlag, 2002, ISBN 3-540-43081-4\n• N. Wirth: Recollections about the Development of Pascal. ACM SIGPLAN Notices, Volume 28, No 3, March 1993."
    },
    {
        "link": "https://wiki.freepascal.org/Memory_Management",
        "document": "Pascal, by default, provides three kinds of memory management mechanisms for different datatypes and in different contexts: Local Lifetime, Manual Memory Management and Reference Counting.\n\nIn the following these mechanisms will be explained in detail, as well as outlining some best practices for their use.\n\nLocal lifetime is the first form of memory management most programmers come into contact with. This is the default way on how variables and function parameters are handled. Here the compiler fully takes over the management of the lifetime of the variable. Take for example this simple function:\n\nThe compiler will create the memory for both the parameter i and the variable x when the function is called. Once the function ends, the memory will be freed. For functions this is ususally done through the local program stack. When calling the function, the compiler generates code that will push the memory for all local variables and parameters on the stack. This is called a stack frame. Once the function returns, the whole stack frame will be poped from the stack, and thereby freeing the allocated memory.\n\nGlobal variables are created on program startup and will be freed when the program is closed.\n\nHere GlobalX, as a global variable is not bound by the lifetime of the function PrintTenth and will be available as long as the program is running.\n\nLastly there are thread local variables. Those are global variables, whose lifetime is bound to a thread. The memory will be newly allocated for every thread started within the program, and will be freed when it's corresponding thread is finished or killed.\n\nSo when PrintTenth would be called from two different threads, they would use a different memory for their thread local ThreadedX, while when called twice from the same thread, it would be the same memory.\n\nLocal lifetime is a very easy and also very efficient way of memory management. This allows for usually quite care-free usage of that memory, as the compiler will take care of all of it.\n\nThat said, there is a big limitation here, any data can only live as long as it's context. This is not an issue for global variables, because by definition, they live as long as any code that could access them. But specifically when using local variables, it can happen that there may still be references to that variable after the function containing it has ended. This is called a dangling pointer.\n\nTake the following program:\n\nThe function Dangling returns a pointer to a local variable. The problem here is, that as soon as the function ends, x doesn't exist anymore, so the Pointer returned (and stored in p) will point to already freed memory. Those kinds of bugs can be hard to find, because of the nature of the stack, the memory is still around and may not have been reused at this point. In the example above, will still print 42, as nothing happend to override this newly freed memory yet. But if another function is called:\n\nNow the function has it's own stack frame, and it will be overlapping with the memory previously used by and pointed to by .\n\nThis makes finding such bugs quite hard, as the code might work as expected initially, but later, when another function was called, suddenly the results are completely different.\n\nGenerally usage of local lifetime managed variables is very easy and mostly safe. Due to the implementation through the stack it is also very efficient. It is therefore recommended to always use local variables whenever possible, and therefore preferable over the other methods outlined in this article.\n\nThat said, the programmer should take a few precautions to avoid having dangling pointers:\n• Never return the pointer to a local variable:\n\nOne big issue with global variables is the (lack of) scoping. A global variable is, as the name suggests, globally accessible. In order to avoid bugs through misuse, you may want to restrict access to a variable within a context, the so called scope, but without restring the lifetime to that scope. This can be achived with writable consts. Those are local variables with a global lifetime, meaning they will be created when the program first calls the encapsulating function, but they won't be freed until the program ends.\n\nThis function declares CurrentID as writable const, meaning it has a global lifetime, even though it is locally defined in NextID. Therefore every call to the function NextID uses the same memory for CurrentID, so NextID can \"remember\" the CurrentID from the last call. This allows this function to return a new ID, always being one more than the last time, in each consecutive call.\n\nUnlike local variables, because the lifetime of writable consts is the one of a global variable, pointers can be taken and passed without creating the dangling pointer problems outlined above.\n\nFor most types the local lifetime will just manage the memory. Often a programmer wants to associate code with the construction or destruction of the memory. For example, when a TFileStream is created, not only the memory is allocated, but also a file is opend. Similarly when a TFileStream is freed, not only the memory will be freed, but also that file will be closed.\n\nPreviously this was only possible for classes, which had constructors and destructors tied to their memory lifetime. But those classes can only be used with manual memory management, or reference counting (through COM interfaces, see below), and therefore was not available for local lifetime managed variables. This has changed in FPC 3.2.0 with the use of management operators. These allow to write code that will be automatically called by the compiler when the memory is allocated (through the operator), and when it is freed (through the operator). See the wiki article for further information.\n\nWhile local lifetime based memory management is extremely efficient and very safe, it requires the compiler to know exactly what data is required at which point in time. Also it explicetly binds the lifetime of the memory to the lifetime of the scope it is in.\n\nWhile this works great for local variables, this can be a problem for dynamic data, i.e. where the size is not known at compiletime (like for Lists or Arrays), in cases where the type of data may vary (Polymorphism), or where the lifetime is not directly tied to the scope where it is created.\n\nTake for example a linked list, whenever a new item is added to the list, its memory must be allocated and then used by the list. As you may want to use functions for adding, removing or searching the list, the lifetime of each list element cannot be bound to the function that created it, otherwise it would be gone as soon as the add function returns.\n\nFor this dynamic memory allocation, also often called heap allocation, is used. When you allocate memory on the heap, the memory usually (with the exception of the reference counted types outlined below), must be manually freed. Therefore both the creation of the memory as well as the freeing must be done manually.\n\nWhile the reasons for requiring dynamic allocation outlined above seem quite niche, there is a more practical reason why this is required. The major Object-Oriented Programming (OOP) implementation in Pascal, Classes are by design always dynamic and unlike other types like records or Integers, cannot be used as local lifetime variables. So a programmer will often find themselves in the situation where it is theoretically not be necessary to do dynamic (and manual) memory management, but due to the design of classes is practically forced to do so anyway.\n\nThere are 3 kinds of memory allocation:\n\nThis is the rawest form of memory allocation, and is done with the functions GetMem, ReallocMem and FreeMem.\n\nThese functions allocate untyped blocks of memory, where all the initialization and finalization must be performed by the user. This can be utilized for some optimizations, such as Pre Allocation of large chunks of memory, to avoid many smaller allocations and potetnial copying of data in the future.\n\nAs such they are rather rarely used, instead programmers will most often use one of the allocation methods outlined below.\n\nTyped memory allocation allows the programmer to dynamically allocate memory for a specific type. This is done with the New and Dispose functions.\n\nCompared to the untyped memory allocation described above, and have knowledge about the datatype for which memory is allocated and can therefore do the required initialization and size computations.\n\nTherefore the following code:\n\nIs equivalent to the following code using raw memory allocation:\n\nThis initialization and finalization is necessary because Composite Types such as Records or Objects contain member fields, whose lifetime is bound to the lifetime of the owning record. It will therefore call the and operators implicetly (see management operators).\n\nTherefore and are basically just a bit of syntactic sugar to clean up the code and not have all that additional size computation and initialization/finalization code that is required when using raw allocation.\n\nWhile and are the usualy way of implementing dynamic allocation for all base types, as well as Records and Objects, when Classes where introduced, they got their own mechanism for memory allocation, which ties directly with the constructor and destructor functions of the class.\n\nThe constructor, usually named (but can have other names, such as for Exceptions), operates in three steps:\n• Allocation of the memory for the class\n• Initialization of the allocated memory (equivalent to the call that is performed by as described above)\n\nThe complement to the Constructor is the Destructor, which should be a virtual/overriden function named Destroy. The destructor performs similar function to the constructor just in opposite order:\n• Cleanup of the allocated memory (equivalent to the finalize call that is performed by as outlined above)\n• Freeing of the memory used by the class\n\nIn practice the usage of a class looks like this:\n\nNote that usually the destructor is not called directly, but rather , which first checks for nil before calling Destroy. How sensical it is to call instead of directly is debatable, but it's a common convention that can be seen in most code and will also be used here.\n\nNo matter what form of allocation is used, every allocation requires a correspopnding free. So for each , there should be one call to to clean up the allocated memory afterwards. For each call to there should be a corresponding . And for every class created through it's constructor there should be a call to or the Destructor directly.\n\nBecause Programs can get very complex, it can sometimes be quite hard to make sure that all allocated memory is correctly freed. If there is memory which is allocated but never freed, this is called a \"Memory Leak\". Memory leaks can be sole occurances, in which case they are not very harmful. But often memory leaks occur within a piece of code that is called multiple times. Over these calls the memory leaks add up, and could result in major waste of memory, which can result in performance loss and potentially even to the computer running out of memory and having to forcefully kill processes or crash completely.\n\nEven worse than memory leaks are so called use-after-free bugs, which is when the memory was freed to early, while there is still code that has a reference to that memory and wants to access it later in the programs execution. The dangling pointers described above are a form of use-after-free.\n\nUse-After-Free bugs are considered worse than memory leaks, because while memory leaks can result in performance loss and in the worst case crashes, they do not result in any misbehavior. Also memory leaks are usually quite easy to find. Use-After-Free on the other hand can result in unpredicted behavior, and may even result in exploitable vulnerabilities through which an attacker could trick your program into executing malicious code, or circumventing other security mechanisms such as access control.\n\nThe reason for this is, that memory as a limited resource, does not go away after it has been freed, but will be reused eventually, resulting in access to other data than was originally intended. An example for this behavior is:\n\nBecause memory is re-used, in this example sl2 will get the same memory allocated as sl1 previously held. Therefore when accessing sl1 after it has been freed, it will unknowingly access sl2 and print .\n\nThis means in a sufficiently complex program, a use-after-free could potentially access any memory at any time, making the resulting errors hard to predict and hard to catch. Note that in the example above the use-after-free does not throw any exception/error, and produces a completely valid result. This is what makes finding these bugs so difficult, while giving them also the potential to completely alter the behavior of the program, by writing data to memory that the code shouldn't be able to touch.\n\nIn order to avoid both memory leaks, and use-after-free, it is helpful to structure your memory management around an \"ownership model\". The core idea is, similar to the compiler managed local memory described above, that the lifetime of any memory is tied to the one of the logical owner of that piece of memory. Everytime memory is allocated there must be an \"owner\", some piece of code that is responsible for that memory. This onwer then must make sure that to always free the memory, eventually (potentially when itself is finished it frees all the objects it owns). Also important is that whenever the owner \"dies\" no one else has access to that memory anymore.\n\nThis ownership model is already provided by many classes in the RTL, FCL and LCL, e.g. in the Component Model, or in the container libraries like Generics.Collections.\n\nNote, in the following we will always use classes as an example, but the same holds true for memory allocated with new/dispose or GetMem/FreeMem.\n\nThe easiest case is for temporary and local objects, those are essentially equivalent to the local variables whose lifetime is bound to their scope and that are managed by the compiler. E.g. a TStringList to read a config file:\n\nIn this case the owner of that SL is the function ReadConfigFile. It is created by that function, and in the end freed by that function. The Try-Finally ensures that this will always happen, no matter if it has an early break, exception or any other form of jump.\n\nTo avoid use-after-free, sl cannot leave this function. After the finally block sl should not be used anymore. This also includes passing sl to some other object, this is fine as long as this other object can only use SL while the function is still active:\n\nHere this function owns two objects, the enc and ss. Again both are ensured to be freed through try-finally. But enc uses ss, so basically enc is \"borrowing\" the ss, which is owned by the function. It is important to ensure that enc is not using ss after it is freed. The only way to ensure this is by having enc be freed before ss was.\n\nSo when an another piece of code \"borrows\" memory owned by a different piece of code, the borrower must \"give up\" the borrowed memory before it can be freed. When writing object oriented code, most of the time this means either freeing the object that borrows the memory before freeing the borrowed memory. In other cases this may mean to revoke access to said object, or to stretch the borrowing metapher further, for the borrower to return the borrowed memory:\n\nHere the global variable , which is used by anohter function, is the borrower. So before the FileStream can be freed by it's owner (the function), the owner first must make sure that the borrowing is revoked, and does this by resetting the global variable to .\n\nThe examples above describe the easy case, where the creator of the memory is also the owner. In some scenarios this may not be the case. For example, when adding data to the list, the function that creates the data, may be just called to create that piece of data, but the real owner is the list where that data will be stored in even after the creating function is finished.\n\nThe easiest example for this is the use of , because this class already provides functionality for ownership handling:\n\nBy setting the AOwnsObjects parameter of the Constructor of TObjectList to true, we tell the TObjectList that it is the owner of all objects we pass to it. This means, when adding a new object to the list, the list will automatically ensure that the object is going to be freed when the item is deleted, or the list is freed. Because ownership is handed over to the list, the function that creates the object does not need to care about freeing it's memory afterwards.\n\ncan not just claim ownership through the function, but also provides the method to give up ownership of an element:\n\nThe ownership model is an easy way to structure the code in a way to make it clear when memory can be used, and when it can be freed. By always making sure that every manually allocated memory has exactly one owner, this owner can make sure that the data will be freed. It also can help preventing use-after-free bugs, as every piece of memory can live at most as long as it's owner, so by tracking the lifetime of the owner, it can be ensured that the memory is still valid.\n\nThe ownership model is already implemented in many libraries that are provided by the RTL, FCL or RTL, it forms the basis for the whole Component Model, on which the LCL is based:\n\nBy setting the owner of the button to Self, this Button is owned by the Form, and when the Form is destroyed, it will also destroy the button.\n\nThe ownership model can be summarized by a few rules of thumb:\n• Always ensure there is one and only one owner\n• When used only locally use try-finally to enforce ownership\n• Borrows are not allower to live longer than the owner\n• When borrowing a local object, the borrow must be finished within the same try-finally block\n• When borrowing between objects, the borrowing object cannot be destroyed before the borrow ended\n• When transferring ownership ensure that the new owner satisfies all the previous rules\n\nThe only way to truely ensure that there are no use-after-free bugs or memory leaks is through testing. There are multiple levels of testing, but for finding these sorts of bugs, Unit Tests are usually the best approach. These are very small programs, that only test a very small subset of the functionality, e.g. a single class or function. FPC provides the fpcunit framework, which allows to easiely create and manage these test cases.\n\nIn order to detect such memory errors, fpc provides the heaptrc unit. This unit checks if for every allocation there is a free, and then reports any memory leaks, including where the memory was allocated. Despite this, heaptrc also taints memory after it is freed, this helps with finding use-after-free bugs.\n\nThrough the use of the it also prevents memory being reused. While this would in a real application result in massive memory consumption, for small test cases, such as unit tests, this can be used to ensure that use-after-free will always result in access to this taineted memory.\n\nTaking the example from above, simply adding heaptrc and keepreleased:\n\nNow because sl1 has been tainted and is not re-used by sl2, the call to sl1.Text will throw an error, making it easy to find and fix.\n\nAnother tool to detect memory errors is Valgrind. Unlike heaptrc, which simply adds some additional checks to the GetMem and FreeMem functions, valgrind is a complete emulator. When executing your code in Valgrind, it will check at every single instruction if some memory errors are present.\n\nThis makes valgrind by far the most powerful tool for finding memory errors, but this comes at a price. Valgrinds emulation is around a factor 1000 slower than native execution, making it potentially infeasable to test larger programs. So also here this must be used in combination with very small and very specialized unit tests.\n\nThere is this quote, which I could not figure out whom to attribute:\n\nAs outlined above, use-after-free errors are much worse than memory leaks. Infact, when your program is not going to use that much memory in the first place, memory leaks will have nearly no impact on the user at all.\n\nOne strategy can therefore be to simply ignore the memory leaks and never free the memory. This strategy is often employed by extremely security critical software, which have quite a limited memory consumption. For example when creating a CGI module for a webservice, which will be started just to serve a single request, as soon as the request is over, the process is killed and all the memory will be released by the OS anyhow. Therefore memory leaks will not matter. But if it is an external facing webservice, security vulnerabilities that may be introduced by use-after-free could be devastating. Therefore not freeing the memory could be a completely valid strategy in order to avoid any use-after-free errors.\n\nThe problem with this is that classes who need their destructor called (e.g. Streams to flush their buffered content), cannot call the destructor without calling Free. So in order to not use Free, either no classes need to be used, or a memory manager must be installed that does not actually free the memory. While HeapTrc.KeepReleased does exactly that, HeapTrc other functionality may impact the performance to much to make it a viable alternative.\n\nEven when following the ownership model strictly, and doing a lot of tests, memory management errors are unavoidable. Manual memory management is hard, and errors can be very hard to find due to their subtlety.\n\nWhen Mozilla rewrote their CSS engine in Rust, they analyzed the security related bugs that where previously found in that code and published the results in their blog. Of all the bugs they've got reported, nearly half where memory management bugs, i.e. where use-after-free or memory leaks.\n\nBecause memory management is so hard, the most simple solution is often to simply avoid manual memory management whenever possible. Because Classes are designed to require manual memory management most of the time, it may sometimes not be avoidable, but there are a few ways reliance on manual memory management can be reduced:\n• Use (advanced) Records and Objects instead of classes\n• Use Dynamic arrays instead of Class based Datastructures\n• Use COM interfaces to your classes\n\nWhile the ownership principle can help to easiely identify when an and where any memory needs to be freed, it is not applicable in all cases. Sometimes the architecture requires a piece of memory to be shared by multiple peers, where there is no clear owner, or multiple owners.\n\nConsidering an expression tree for the expression . This could be represented as either a strict tree:\n\nThis can be simply put into code, whith each node being it's own object and having exactly one parent. When the parent node is freed, it would free all of it's children.\n\nBut, as an optimization, the representation in code is changed such that equal subtrees are replaced with just a reference to the same object:\n\nBut now there is a problem, because now the \"+\" node has two parents, and thereby no clear owner.\n\nThere are multiple solutions to this. For example, all those nodes could be put into one list, which will be the owner of all the nodes, and all the nodes just borrow each other from that list. But a more flexible solution is to simply allow multiple owners.\n\nThis can be achieved with so called reference counting. For this each allocated object will have a counter embedded. When a new owner gets access to the object, it notifies the counter and the count will be incremented. Then when an owner does not need the object anymore, it just tells the counter that it's reference will not be used anymore, and the counter is decreased. When the counter hits 0, the memory will be freed.\n\nIn the example expression tree above, the reference count of '*' would be 1, '+' is owned two times by '*' so its reference count is 2, '5' and '3' are owned exactly once, so their reference count is 1. When '*' reference is lost reducing the counter to 0, it will reduce the reference counter of it's first child, '+' to 1, and then when freeing the second child, it is reduced again to 0. '+' then reduces both it's childrens reference counter from 1 to 0, freeing them, before freeing itself, and finally '*' get's freed.\n\nThis results in no memory leaks, and when used consequently, no use-after-free, because it can only be used when there are references, but then the counter would not be 0.\n\nThe major problem is, implementing this manually is extremely error prone, as it is easy to simply forget to decrease or increase the counter. But the FPC already implements reference counting, at least for some types, on a language level. Dynamic arrays, Strings and COM Interfaces are already reference counted. This means, whenever such an object is created, it's reference count is set to 1. When it is assigned to a new variable, it's reference count will increment, if a variable pointing to that object is finalized, the reference counter will be decremented:\n\nThis is why, even though Arrays are dynamically allocated, there is no need to manually free them.\n\nWhile the usage of arrays and strings is straight forward, Interfaces are often underutilized for this.\n\nTo use Interfaces to solve the original problem of representing the expression tree of (5+3)*(5+3), we can simply implement the expressions as classes implementing a common interface, and use this:\n\nThis will be able to evalute the expression tree to 64, without any memory leaks, or risk of running into use-after-free.\n\nAnother interesting use of COM interfaces to facilitate reference counting is the GMP unit provided by the FPC. Because one issue with manual memory management is that the usage of any temporary object would create a memory leak.\n\nTake the following expression: . First (a + b) is computed, which gives a temporary object that then is used to be multiplied with c. If the object requires dynamic allocation, because of it's temporary nature, (a + b) could not be freed, resulting in a memory leak, therefore operator overloading is not possible with classes. So in classical, manually managed GMP this computation would be written like this:\n\nThis is alot of boiler plate code distracting from the actually quite simple computation. Here is how it looks like using the reference counted interfaces\n\nSo while normal classes cannot use operators, because the creation of temporary objects would result in memory leaks, through the use of COM interfaces this is possible, which can result in much cleaner code\n\nOne issue with reference counting are circular references. Assuming two objects, A and B, if A has a reference to B and B holds a reference to A, then their respective reference counters can not drop below 1, because they always reference each other. Especially when representing cyclic graphs, this can acutally lead to memory leaks, if not resolved properly.\n\nTherefore, while the usage of interfaces can help massively with writing clean and memory safe code, it is not a \"silver bullet\". The programmer must still always be aware if circular references can occur, and if so, they must be resolved manually."
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_memory.htm",
        "document": "This chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.\n\nWhile doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows −\n\nBut now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic. Here, we need to define a pointer to string without defining how much memory is required.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nNow, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the getmem function or the getmem procedure, which has the following syntax −\n\nIn the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, getmem subprogram allows specifying that. Let us rewrite the previous example, using getmem −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nSo, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.\n\nWhen your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.\n\nPascal provides the procedure dispose to free a dynamically created variable using the procedure new. If you have allocated memory using the getmem subprogram, then you need to use the subprogram freemem to free this memory. The freemem subprograms have the following syntax −\n\nAlternatively, you can increase or decrease the size of an allocated memory block by calling the function ReAllocMem. Let us check the above program once again and make use of ReAllocMem and freemem subprograms. Following is the syntax for ReAllocMem −\n\nFollowing is an example which makes use of ReAllocMem and freemem subprograms −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management −"
    },
    {
        "link": "http://brucemerry.org.za/manual/pascal/dynamic.html",
        "document": "The command in Pascal does not allow you to choose how much memory to allocate at run time; thus when creating an array you must choose an upper bound in advance. This presents problems when for example you need 200 lists with a maximum total size of 60000 bytes. Since each array could be up to 60000 bytes by itself, you would need to allocate 60000 bytes to each array. This is clearly not practical. The usual solution in this case is to use linked lists. However, linked lists are not well suited to all applications, have a high memory overhead and are usually slow to work with. They are also more difficult to write and debug.\n\nThe solution is dynamic allocation, which means to allocate to each array only as much memory as it needs at run time. This will be old news to C programmers who are basically forced to do this using the command. In Pascal you need to use the and commands.\n\nThis code illustrates how to dynamically allocate memory for the array. Note that although the upper limit of 30000 is arbitrary: the actual limit is , and it is up to you to make sure that you never use a higher index (otherwise some really weird stuff can happen). You should make the arbitrary limit as high as possible to prevent range check errors that will result if the error checker thinks you are trying to access something that is out of bounds (the range checker doesn't know about dynamic allocation). You must also make sure that the command specifies the same amount of memory as the command.\n\nIt is not possible to directly resize a dynamically allocated array. You must allocate a new array, copy the data into the new array and free the old array.\n\nBecause of this, it may sometimes be necessary to make an initial pass of the input file to determine how much memory to allocate to each array before doing the main pass to fill the arrays with data."
    },
    {
        "link": "https://stackoverflow.com/questions/20747060/pascal-dynamic-memory-allocation",
        "document": "I would like to have a function, that when called creates a new stack, do some operations and then disposes the memory it used for stack. How can I do that?\n\nI implemented my stack using an array:\n\nEdit: I want to use the stack in a function, and I want it to be local.\n\nWill it dealocate the memory after the variable S once the funcion is done, or do I have to take care of it?"
    },
    {
        "link": "https://cslab.pepperdine.edu/warford/ComputingFundamentals/PboxCh21.pdf",
        "document": ""
    },
    {
        "link": "https://dcs.ed.ac.uk/home/SUNWspro/3.0/pascal/lang_ref/ref_io.doc.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/32679962/pascal-input-a-various-number-of-variables-on-1-line",
        "document": "So I was thinking how is it possible to ask for an input of an unknown number of variables on one line only by using a space to separate them... For instance, if the number of variables I want to input is known, the code would be..\n\nThis would ask for an input of 3 variables, split by a space or by pressing enter after each, but the split by using space is what I am going for. But what if I dont know the number of variables and I need to create them on the go?.. Say, n sets the number of variables I need to input.\n\nNote that the number of variables I read after n need to be equal to the number that n holds, and can not be pre-set in var. I tried different ways of doing this but all I came up with was\n\nBut by using the loop and array, I still can only input one variable on each line, not any number separated by a space. Is there any way to do this?"
    },
    {
        "link": "https://stackoverflow.com/questions/8250924/pascal-readln-multiple-var-types",
        "document": "My problem looks like this. I got a file with data(input) \"text text number number\" on each line, I need to get data from it using ReadLn(myfile, string, string2, real1(or double), real2(or double));, as you can see in my code provided below, but when I do it with the function I've just described, I get an error. I need each data in separate variable. I need to work with numbers(multiply, sum) and I need name and surname for the output(result) file, where data will look like this \"Name Surname number1(from input file) multiplied with number2(from input file)\" for each line from the input file and in the last line will be \"Total: sum(all lines(number1*number2))\". The only problem I need help with is to read each line data from initial file to a separate variable.\n\nI always get an error while trying to read the line data like this:\n\nWhen I try same thing, but after changing numeric values to integer(in file as well):\n\nChanges done in the file:\n\nAnd program code looks like this:\n\nProgram works almost as intended(numeric1 takes both numeric values and 2nd is left blank).\n\nHere's how far I got with my code:\n\nThank you in advance. I've did similar post earlier, but the solution doesn't suite school needs(too complicated for them -.-) I need to use simple way of ReadLn with 4 variables in it(Or 2 or 3, if I'm wrong). In any case, forgive me for posting same problem twice.\n\nP.S. Forgive me for formatting, spelling and idea issues. I was rather sleepy. I hope I made myself clear this time."
    },
    {
        "link": "http://tutordam.50webs.com/paspros/mypascal6.htm",
        "document": "This program accepts any integer value within the range -32,768 and + 32,767. After the user enters the number the program doubles it and outputs the value. READLN reads in data from the pointer position into the variable or variables then it discards the rest of the line and moves the data pointer to the first character position of the next line. program doubleint(input,output);\n\n Var \n\n a : integer; \n\n begin\n\n writeln('Enter an integer value : ');\n\n read(a);\n\n \n\n writeln('When I double ',a,' I get ',a*2)\n\n end.\n\n \n\n Program 6 is made up of three sections: 1. The Program Heading starts with the word PROGRAM followed by the name of the program. The name of this program is doubleint .The heading ends with the first semi-colon after (input, output) which tells us that the program expects user input before it produces output on screen. 2. The declaration section begins with Var followed by only one variable a then a colon before the word INTEGER. The last character on the line is the semi-colon. 3. The body of the progarm starts with the word begin and terminates with the word end."
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_quick_guide.htm",
        "document": "Pascal is a general-purpose, high-level language that was originally developed by Niklaus Wirth in the early 1970s. It was developed for teaching programming as a systematic discipline and to develop reliable and efficient programs.\n\nPascal is Algol-based language and includes many constructs of Algol. Algol 60 is a subset of Pascal. Pascal offers several data types and programming structures. It is easy to understand and maintain the Pascal programs.\n\nPascal has grown in popularity in the teaching and academics arena for various reasons:\n• It can be compiled on a variety of computer platforms.\n\nPascal has the following features −\n• It offers several data types like arrays, records, files and sets.\n• It supports structured programming through functions and procedures.\n• None The Pascal language was named for Blaise Pascal, French mathematician and pioneer in computer development.\n• None Niklaus Wirth completed development of the original Pascal programming language in 1970.\n• None Pascal is based on the block structured style of the Algol programming language.\n• None Pascal was developed as a language suitable for teaching programming as a systematic discipline, whose implementations could be both reliable and efficient.\n• None The ISO 7185 Pascal Standard was originally published in 1983.\n• None Pascal was the primary high-level language used for development in the Apple Lisa, and in the early years of the Mac.\n• None In 1986, Apple Computer released the first Object Pascal implementation, and in 1993, the Pascal Standards Committee published an Object-Oriented Extension to Pascal.\n\nWhy to use Pascal?\n\nPascal allows the programmers to define complex structured data types and build dynamic and recursive data structures, such as lists, trees and graphs. Pascal offers features like records, enumerations, subranges, dynamically allocated variables with associated pointers and sets.\n\nPascal allows nested procedure definitions to any level of depth. This truly provides a great programming environment for learning programming as a systematic discipline based on the fundamental concepts.\n\nAmong the most amazing implementations of Pascal are −\n\nThere are several Pascal compilers and interpreters available for general use. Among these are −\n• None Turbo Pascal − provides an IDE and compiler for running Pascal programs on CP/M, CP/M-86, DOS, Windows and Macintosh.\n• None Delphi − provides compilers for running Object Pascal and generates native code for 32- and 64-bit Windows operating systems, as well as 32-bit Mac OS X and iOS. Embarcadero is planning to build support for the Linux and Android operating system.\n• None Free Pascal − it is a free compiler for running Pascal and Object Pascal programs. Free Pascal compiler is a 32- and 64-bit Turbo Pascal and Delphi compatible Pascal compiler for Linux, Windows, OS/2, FreeBSD, Mac OS X, DOS and several other platforms.\n• None Turbo51 − It is a free Pascal compiler for the 8051 family of microcontrollers, with Turbo Pascal 7 syntax.\n• None Oxygene − It is an Object Pascal compiler for the .NET and Mono platforms.\n• None GNU Pascal (GPC) − It is a Pascal compiler composed of a front end to GNU Compiler Collection.\n\nWe will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: Download Free Pascal\n\nThe Linux distribution of Free Pascal comes in three forms −\n• None a tar.gz version, also available as separate files.\n\nWhere X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).\n\nInstallation code for the Debian version (like Ubuntu) −\n\nWhere XXX is the version number of the .deb file.\n\nIf you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.\n\nFor Windows, you will download the Windows installer, setup.exe. This is a usual installation program. You need to take the following steps for installation −\n• None Select parts of the package you want to install.\n• None Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.\n\nThis will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.\n\nName and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux or UNIX.\n\nThe files you create with your editor are called source files and contain program source code. The source files for Pascal programs are typically named with the extension .pas.\n\nBefore starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.\n\nBefore we study basic building blocks of the Pascal programming language, let us look a bare minimum Pascal program structure so that we can take it as a reference in upcoming chapters.\n\nA Pascal program basically consists of the following parts −\n• Statements and Expressions within each block\n\nEvery pascal program generally has a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program −\n\nFollowing is a simple pascal code that would print the words \"Hello, World!\" −\n\nThis will produce following result −\n\nLet us look various parts of the above program −\n• None The first line of the program program HelloWorld; indicates the name of the program.\n• None The second line of the program uses crt; is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.\n• None The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a begin statement and an end statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;).\n• None The begin statement of the main program block is where the program execution begins.\n• None The lines within (*...*) will be ignored by the compiler and it has been put to add a comment in the program.\n• None The statement writeln('Hello, World!'); uses the writeln function available in Pascal which causes the message \"Hello, World!\" to be displayed on the screen.\n• None The statement readkey; allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.\n• None The last statement end. ends your program.\n• None Open a command prompt and go to the directory, where you saved the file.\n• None Type fpc hello.pas at command prompt and press enter to compile your code.\n• None If there are no errors in your code, the command prompt will take you to the next line and would generate hello executable file and hello.o object file.\n• None Now, type hello at command prompt to execute your program.\n• None You will be able to see \"Hello World\" printed on the screen and program waits till you press any key.\n\nMake sure that free pascal compiler fpc is in your path and that you are running it in the directory containing source file hello.pas.\n\nYou have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.\n\nA variable definition is put in a block beginning with a var keyword, followed by definitions of the variables as follows:\n\nPascal variables are declared outside the code-body of the function which means they are not declared within the begin and end pairs, but they are declared after the definition of the procedure/function and before the begin keyword. For global variables, they are defined after the program header.\n\nIn Pascal, a procedure is set of instructions to be executed, with no return value and a function is a procedure with a return value. The definition of function/procedures will be as follows −\n\nThe multiline comments are enclosed within curly brackets and asterisks as (* ... *). Pascal allows single-line comment enclosed within curly brackets { ... }.\n\nPascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.\n\nPascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.\n\nThe statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.\n\nFollowing is a list of reserved words available in Pascal.\n\nThe entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier. An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.\n\nData types of an entity indicates the meaning, constraints, possible values, operations, functions and mode of storage associated with it.\n\nInteger, real, Boolean and character types are referred as standard data types. Data types can be categorized as scalar, pointer and structured data types. Examples of scalar data types are integer, real, Boolean, character, subrange and enumerated. Structured data types are made of the scalar types; for example, arrays, records, files and sets. We will discuss the pointer data types later.\n\nPascal data types can be summarized as below in the following diagram −\n\nThe type declaration is used to declare the data type of an identifier. Syntax of type declaration is −\n\nFor example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.\n\nFollowing table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal −\n\nUse of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows numerical, logical, string and character constants. Constants can be declared in the declaration part of the program by specifying the const declaration.\n\nSyntax of constant type declaration is follows −\n\nFollowing are some examples of constant declarations −\n\nAll constant declarations must be given before the variable declaration.\n\nEnumerated data types are user-defined data types. They allow values to be specified in a list. Only assignment operators and relational operators are permitted on enumerated data type. Enumerated data types can be declared as follows −\n\nFollowing are some examples of enumerated type declarations −\n\nThe order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.\n\nSubrange types allow a variable to assume values that lie within a certain range. For example, if the age of voters should lie between 18 to 100 years, a variable named age could be declared as −\n\nWe will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows −\n\nFollowing are some examples of subrange type declarations −\n\nSubrange types can be created from a subset of an already defined enumerated type, For example −\n\nA variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Pascal has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.\n\nThe name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Pascal is not case-sensitive, so uppercase and lowercase letters mean same here. Based on the basic types explained in previous chapter, there will be following basic variable types −\n\nPascal programming language also allows defining various other types of variables, which we will cover in subsequent chapters like Pointer, Array, Records, Sets, and Files, etc. For this chapter, let us study only basic variable types.\n\nAll variables must be declared before we use them in Pascal program. All variable declarations are followed by the var keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is −\n\nHere, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here −\n\nIn the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,\n\nNow, the types so defined can be used in variable declarations −\n\nPlease note the difference between type declaration and var declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare type declaration in Pascal with typedef in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.\n\nVariables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is −\n\nBy default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the var keyword and the syntax of initialization is as follows −\n\nLet us look at an example, which makes use of various types of variables discussed so far −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as −\n\nWhen you have declared an enumerated type, you can declare variables of that type. For example,\n\nThe following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nThe following program illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared −\n• Pointer types (but the only allowed value is Nil).\n\nSyntax for declaring constants is as follows −\n\nThe following table provides examples of some valid constant declarations −\n\nThe following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nObserve the formatting in the output statement of the program. The variable c is to be formatted with total number of digits 7 and 2 digits after the decimal sign. Pascal allows such output formatting with the numerical variables.\n\nAn operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Pascal allows the following types of operators −\n\nLet us discuss the arithmetic, relational, Boolean and bit operators one by one. We will discuss the set operators and string operations later.\n\nFollowing table shows all the arithmetic operators supported by Pascal. Assume variable A holds 10 and variable B holds 20, then −\n\nFollowing table shows all the relational operators supported by Pascal. Assume variable A holds 10 and variable B holds 20, then −\n\nFollowing table shows all the Boolean operators supported by Pascal language. All these operators work on Boolean operands and produce Boolean results. Assume variable A holds true and variable B holds false, then −\n\nBitwise operators work on bits and perform bit-by-bit operation. All these operators work on integer operands and produces integer results. The truth table for bitwise and (&), bitwise or (|), and bitwise not (~) are as follows −\n\nAssume if A = 60; and B = 13; now in binary format they will be as follows −\n\nThe Bitwise operators supported by Pascal are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:\n\nPlease note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators −\n\nOperator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.\n\nFor example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.\n\nHere, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.\n\nDecision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.\n\nFollowing is the general form of a typical decision making structure found in most of the programming languages −\n\nPascal programming language provides the following types of decision making statements. Click the following links to check their detail.\n\nThere may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.\n\nProgramming languages provide various control structures that allow for more complicated execution paths.\n\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −\n\nPascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.\n\nLoop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\n\nPascal supports the following control statements. Click the following links to check their details.\n\nA subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design.' A subprogram can be invoked by a subprogram/program, which is called the calling program.\n\nPascal provides two kinds of subprograms −\n• None Procedures − these subprograms do not return a value directly.\n\nA function is a group of statements that together perform a task. Every Pascal program has at least one function, which is the program itself, and all the most trivial programs can define additional functions.\n\nA function declaration tells the compiler about a function's name, return type, and parameters. A function definition provides the actual body of the function.\n\nPascal standard library provides numerous built-in functions that your program can call. For example, function AppendStr() appends two strings, function New() dynamically allocates memory to variables and many more functions.\n\nIn Pascal, a function is defined using the function keyword. The general form of a function definition is as follows −\n\nA function definition in Pascal consists of a function header, local declarations and a function body. The function header consists of the keyword function and a name given to the function. Here are all the parts of a function −\n• None Arguments − The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type. The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.\n• None Return Type − All functions must return a value, so all functions must be assigned a type. The function-type is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.\n• None Local declarations − Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.\n• None Function Body − The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end. It is the part of a function where all computations are done. There must be an assignment statement of the type - name := expression; in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.\n\nFollowing is an example showing how to define a function in pascal −\n\nA function declaration tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.\n\nA function declaration has the following parts −\n\nFor the above-defined function max(), following is the function declaration −\n\nFunction declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.\n\nWhile creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.\n\nTo call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nProcedures are subprograms that, instead of returning a single value, allow to obtain a group of results.\n\nIn Pascal, a procedure is defined using the procedure keyword. The general form of a procedure definition is as follows −\n\nA procedure definition in Pascal consists of a header, local declarations and a body of the procedure. The procedure header consists of the keyword procedure and a name given to the procedure. Here are all the parts of a procedure −\n• None Arguments − The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.\n• None Local declarations − Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.\n• None Procedure Body − The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.\n\nFollowing is the source code for a procedure called findMin(). This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by reference (we will discuss passing arguments by reference a little later) −\n\nA procedure declaration tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.\n\nA procedure declaration has the following syntax −\n\nPlease note that the name of the procedure is not associated with any type. For the above defined procedure findMin(), following is the declaration −\n\nWhile creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.\n\nTo call a procedure, you simply need to pass the required parameters along with the procedure name as shown below −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nWe have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.\n\nTo illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as −\n\nThe following program calculates the factorial of a given number by calling itself recursively.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFollowing is another example, which generates the Fibonacci Series for a given number using a recursive function −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIf a subprogram (function or procedure) is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the formal parameters of the subprogram.\n\nThe formal parameters behave like other local variables inside the subprogram and are created upon entry into the subprogram and destroyed upon exit.\n\nWhile calling a subprogram, there are two ways that arguments can be passed to the subprogram −\n\nBy default, Pascal uses call by value to pass arguments. In general, this means that code within a subprogram cannot alter the arguments used to call the subprogram. The example program we used in the chapter 'Pascal - Functions' called the function named max() using call by value.\n\nWhereas, the example program provided here (exProcedure) calls the procedure findMin() using call by reference.\n\nA scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places, where variables can be declared in Pascal programming language −\n• None Inside a subprogram or a block which is called local variables\n• None Outside of all subprograms which is called global variables\n• None In the definition of subprogram parameters which is called formal parameters\n\nLet us explain what are local and global variables and formal parameters.\n\nVariables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here, all the variables a, b and c are local to program named exLocal.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nNow, let us extend the program little more, let us create a procedure named display, which will have its own set of variables a, b and c and display their values, right from the program exLocal.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nGlobal variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.\n\nA global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using global and local variables −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPlease note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.\n\nLet us change the previous example a little, now the local variables for the procedure display has same names as a, b, c −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nThe string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more common types of strings used in programs.\n\nYou can define a string in many ways −\n• None Character arrays − This is a character string which is a sequence of zero or more byte-sized characters enclosed in single quotes.\n• None String variables − The variable of String type, as defined in Turbo Pascal.\n• None Short strings − The variable of String type with size specification.\n• None AnsiStrings − Ansistrings are strings that have no length limit.\n\nPascal provides only one string operator, string concatenation operator (+).\n\nThe following program prints first four kinds of strings. We will use AnsiStrings in the next example.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFollowing example makes use of few more functions, let's see −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal supports a wide range of functions and procedures that manipulate strings. These subprograms vary implement-wise. Here, we are listing various string manipulating subprograms provided by Free Pascal −\n\nPascal provides data type Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions, etc.\n\nBoolean values are basically integer type. Boolean type variables have two pre-defined possible values True and False. The expressions resolving to a Boolean value can also be assigned to a Boolean type.\n\nFree Pascal also supports the ByteBool, WordBool and LongBool types. These are of type Byte, Word or Longint, respectively.\n\nThe value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value. A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.\n\nIt should be noted that logical operators and, or and not are defined for Boolean data types.\n\nA variable of Boolean type is declared using the var keyword.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n\nInstead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.\n\nAll arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.\n\nPlease note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.\n\nTo declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.\n\nThe general form of type declaration of one-dimensional array is −\n• None array-identifier − indicates the name of the array type.\n• None index-type − specifies the subscript of the array; it can be any scalar data type except real\n• None element-type − specifies the types of values that are going to be stored\n\nNow, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.\n\nTo start the array from 0 index, the declaration would be −\n\nIn Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.\n\nLet us take up another example where the subscript is of character type −\n\nSubscript could be of enumerated type −\n\nIn Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.\n\nAn element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example −\n\nThe above statement will take the first element from the array named alphabet and assign the value to the variable a.\n\nFollowing is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nArrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer −\n\nPointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Pascal programmer. Let's start learning them in simple and easy steps.\n\nAs you know, every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.\n\nA pointer is a dynamic variable, whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is −\n\nThe pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type. The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the var declaration to declare pointer variables.\n\nFollowing are some valid pointer declarations −\n\nThe pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer rptr, is rptr^. It can be accessed as −\n\nThe following example will illustrate this concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIn Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.\n\nLet us extend the above example to print the memory address stored in the pointer iptr −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIt is always a good practice to assign a NIL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NIL points to nowhere. Consider the following program −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nTo check for a nil pointer you can use an if statement as follows −\n\nPointers have many but easy concepts and they are very important to Pascal programming. There are following few important pointer concepts, which should be clear to a Pascal programmer −\n\nPascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user-defined data type available in Pascal which allows you to combine data items of different kinds.\n\nRecords consist of different fields. Suppose you want to keep track of your books in a library, you might want to track the following attributes about each book −\n\nTo define a record type, you may use the type declaration statement. The record type is defined as −\n\nHere is the way you would declare the Book record −\n\nThe record variables are defined in the usual way as\n\nAlternatively, you can directly define a record type variable as −\n\nTo access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou can define pointers to records in very similar way as you define pointer to any other variable as follows −\n\nNow, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword −\n\nBefore using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.\n\nTo access the members of a record using a pointer to that record, you must use the ^. operator as follows −\n\nFinally, don't forget to dispose the used storage, when it is no longer in use −\n\nLet us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nWe have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The With statement provides an alternative way to do that.\n\nLook at the following code snippet taken from our first example −\n\nThe same assignment could be written using the With statement as −\n\nPascal supports a unique type of storage named variants. You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime. Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.\n\nStructured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant. You can also assign a pointer to a variant.\n\nYou can declare variant type like any other types using the var keyword. The syntax for declaring a variant type is −\n\nNow, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.\n\nThe following example would illustrate the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within braces{}. However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.\n\nVariables of set type are defined as\n\nExamples of some valid set type declaration are −\n\nYou can perform the following set operations on Pascal sets.\n\nFollowing table shows all the set operators supported by Free Pascal. Assume that S1 and S2 are two character sets, such that −\n\nThe following example illustrates the use of some of these operators −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal treats a file as a sequence of components, which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as −\n\nWhere, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the var declaration −\n\nFollowing are some examples of defining some file types and file variables −\n\nLet us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it −\n\nWhen compiled and run, the program would create a file named students.dat into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.\n\nWe have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.\n\nPlease note that, if you use a file parameter with subprograms, it must be declared as a var parameter.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as −\n\nDifference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nAppending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFree Pascal provides the following functions/procedures for file handling −\n\nThis chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.\n\nWhile doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows −\n\nBut now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic. Here, we need to define a pointer to string without defining how much memory is required.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nNow, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the getmem function or the getmem procedure, which has the following syntax −\n\nIn the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, getmem subprogram allows specifying that. Let us rewrite the previous example, using getmem −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nSo, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.\n\nWhen your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.\n\nPascal provides the procedure dispose to free a dynamically created variable using the procedure new. If you have allocated memory using the getmem subprogram, then you need to use the subprogram freemem to free this memory. The freemem subprograms have the following syntax −\n\nAlternatively, you can increase or decrease the size of an allocated memory block by calling the function ReAllocMem. Let us check the above program once again and make use of ReAllocMem and freemem subprograms. Following is the syntax for ReAllocMem −\n\nFollowing is an example which makes use of ReAllocMem and freemem subprograms −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management −\n\nA Pascal program can consist of modules called units. A unit might consist of some code blocks, which in turn are made up of variables and type declarations, statements, procedures, etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.\n\nBoth the built-in units and user-defined units are included in a program by the uses clause. We have already used the variants unit in Pascal - Variants tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit crt in your program −\n\nThe following example illustrates using the crt unit −\n\nIt is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.\n\nTo create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with .pas extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example −\n\nFollowing are three important steps in creating a Pascal unit −\n• None The name of the file and the name of the unit should be exactly same. So, our unit calculateArea will be saved in a file named calculateArea.pas.\n• None The next line should consist of a single keyword interface. After this line, you will write the declarations for all the functions and procedures that will come in this unit.\n• None Right after the function declarations, write the word implementation, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.\n\nThe following program creates the unit named calculateArea −\n\nNext, let us write a simple program that would use the unit we defined above −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nMost of the softwares you write need implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers.\n\nPascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nThe Date function returns the current date in TDateTime format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nThe Now function returns the current date and time −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nFree Pascal provides a simple time stamp structure named TTimeStamp, which has the following format −\n\nFree Pascal provides the following date and time functions −\n\nThe following example illustrates the use of some of the above functions −\n\nWhen the above code was compiled and executed, it produced the following result:\n\nWe can imagine our universe made of different objects like sun, earth, moon, etc. Similarly, we can imagine our car made of different objects like wheel, steering, gear, etc. Same way, there are object-oriented programming concepts, which assume everything as an object and implement a software using different objects. In Pascal, there are two structural data types used to implement a real world object −\n\nBefore we go in detail, let's define important Pascal terms related to Object-Oriented Pascal.\n• None Object − An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.\n• None Class − A Class is defined in almost the same way as an Object, but there is a difference in way they are created. The Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. It is a pointer to the object, not the object itself.\n• None Instantiation of a class − Instantiation means creating a variable of that class type. Since a class is just a pointer, when a variable of a class type is declared, there is memory allocated only for the pointer, not for the entire object. Only when it is instantiated using one of its constructors, memory is allocated for the object. Instances of a class are also called 'objects', but do not confuse them with Object Pascal Objects. In this tutorial, we will write 'Object' for Pascal Objects and 'object' for the conceptual object or class instance.\n• None Member Variables − These are the variables defined inside a Class or an Object.\n• None Member Functions − These are the functions or procedures defined inside a Class or an Object and are used to access object data.\n• None Visibility of Members − The members of an Object or Class are also called the fields. These fields have different visibilities. Visibility refers to accessibility of the members, i.e., exactly where these members will be accessible. Objects have three visibility levels: public, private and protected. Classes have five visibility types: public, private, strictly private, protected and published. We will discuss visibility in details.\n• None Inheritance − When a Class is defined by inheriting existing functionalities of a parent Class, then it is said to be inherited. Here child class will inherit all or few member functions and variables of a parent class. Objects can also be inherited.\n• None Parent Class − A Class that is inherited by another Class. This is also called a base class or super class.\n• None Child Class − A class that inherits from another class. This is also called a subclass or derived class.\n• None Polymorphism − This is an object-oriented concept where same function can be used for different purposes. For example, function name will remain same but it may take different number of arguments and can do different tasks. Pascal classes implement polymorphism. Objects do not implement polymorphism.\n• None Overloading − It is a type of polymorphism in which some or all of operators have different implementations depending on the types of their arguments. Similarly functions can also be overloaded with different implementation. Pascal classes implement overloading, but the Objects do not.\n• None Data Abstraction − Any representation of data in which the implementation details are hidden (abstracted).\n• None Encapsulation − Refers to a concept where we encapsulate all the data and member functions together to form an object.\n• None Constructor − Refers to a special type of function which will be called automatically whenever there is an object formation from a class or an Object.\n• None Destructor − Refers to a special type of function which will be called automatically whenever an Object or Class is deleted or goes out of scope.\n\nAn object is declared using the type declaration. The general form of an object declaration is as follows −\n\nLet us define a Rectangle Object that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.\n\nAfter creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.\n\nFollowing example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.\n\nFollowing is a complete example to show how to use objects in Pascal −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nVisibility indicates the accessibility of the object members. Pascal object members have three types of visibility −\n\nBy default, fields and methods of an object are public and are exported outside the current unit.\n\nConstructors are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.\n\nDestructors are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.\n\nFollowing example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named TableTop, which is inheriting from the Rectangle object.\n\nFollowing are the important points which should be noted down −\n• None The object Tabletop has inherited all the members of the Rectangle object.\n• None There is a draw method in TableTop also. When the draw method is called using a TableTop object, TableTop's draw gets invoked.\n• None There is an implicit instance named self that refers to the current instance of the object.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou have seen that Pascal Objects exhibit some characteristics of object-oriented paradigm. They implement encapsulation, data hiding and inheritance, but they also have limitations. For example, Pascal Objects do not take part in polymorphism. So classes are widely used to implement proper object-oriented behavior in a program, especially the GUI-based software.\n\nA Class is defined in almost the same way as an Object, but is a pointer to an Object rather than the Object itself. Technically, this means that the Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. In other words, when you declare a variable the object type, it will take up as much space on the stack as the size of the object, but when you declare a variable of the class type, it will always take the size of a pointer on the stack. The actual class data will be on the heap.\n\nA class is declared in the same way as an object, using the type declaration. The general form of a class declaration is as follows −\n\nIts worth to note following important points −\n• None Class definitions should come under the type declaration part of the program only.\n• None A class is defined using the class keyword.\n• None Fields are data items that exist in each instance of the class.\n• None Methods are declared within the definition of a class.\n• None There is a predefined constructor called Create in the Root class. Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.\n• None There is a predefined destructor called Destroy in the Root class. Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.\n\nLet us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.\n\nLet us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions −\n• None You will need to include the {$mode objfpc} directive for using the classes.\n• None You will need to include the {$m+} directive for using constructors.\n• None Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.\n\nHere is the complete example −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nVisibility indicates the accessibility of the class members. Pascal class members have five types of visibility −\n\nConstructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.\n\nPascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.\n\nFollowing example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nLike the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.\n\nPascal class definitions can optionally inherit from a parent class definition. The syntax is as follows −\n\nFollowing example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIts worth to note following important points −\n• None The members of the Books class have protected visibility.\n• None The Novels class has two constructors, so the overload operator is used for function overloading.\n• None The Books.Display procedure has been declared virtual, so that the same method from the Novels class can override it.\n• None The Novels.Create constructor calls the base class constructor using the inherited keyword.\n\nInterfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface −\n\nPlease note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.\n\nAn abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this −\n\nWhen inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.\n\nDeclaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou must use the directive {$static on} for using the static members."
    }
]