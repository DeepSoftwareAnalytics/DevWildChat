[
    {
        "link": "https://docs.python-telegram-bot.org",
        "document": "We have made you a wrapper you can’t refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nYou can install or upgrade via To install a pre-release, use the flag in addition. You can also install from source, though this is usually not necessary. To enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures. Starting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value . Earlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format . In addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix . tries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don’t need the optional features. The only required dependency is httpx ~= 0.27 for , the default networking backend. is most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out. PTB can be installed with optional dependencies:\n• None installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• None installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• None installs httpx[http2]. Use this, if you want to use HTTP/2.\n• None installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• None installs the tornado~=6.4 library. Use this, if you want to use / .\n• None installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• None installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the . To install multiple optional dependencies, separate them by commas, e.g. .\n• None installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let’s get started! Our Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• None The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• None The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• None Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• None The official Telegram Bot API documentation is of course always worth a read. If the resources mentioned above don’t answer your questions or simply overwhelm you, there are several ways of getting help.\n• None We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• None You can even ask for help on Stack Overflow using the python-telegram-bot tag. Since v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• None all classes in the module that allow to add/remove allowed users/chats at runtime\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don’t have to be."
    },
    {
        "link": "https://docs.python-telegram-bot.org/en/stable/examples.html",
        "document": "In this section we display small examples to show what a bot written with looks like. Some bots focus on one specific aspect of the Telegram Bot API while others focus on one of the mechanics of this library. Except for the rawapibot.py example, they all use the high-level framework this library provides with the submodule.\n\nAll examples are licensed under the CC0 License and are therefore fully dedicated to the public domain. You can use them as the base for your own bots without worrying about copyrights.\n\nDo note that we ignore one pythonic convention. Best practice would dictate, in many handler callbacks function signatures, to replace the argument with an underscore, since is an unused local variable in those callbacks. However, since these are examples and not having a name for that argument confuses beginners, we decided to have it present.\n\nThis bot uses the class to send timed messages. The user sets a timer by using command with a specific time, for example . The bot then sets up a job to send a message to that user after 30 seconds. The user can also cancel the timer by sending . To learn more about the , read this wiki article. Note: To use , you must install PTB via\n\nA common task for a bot is to ask information from the user. In v5.0 of this library, we introduced the for that exact purpose. This example uses it to retrieve user-information in a conversation-like style. To get a better understanding, take a look at the state diagram.\n\nA even more complex example of a bot that uses the nested s. While it’s certainly not that complex that you couldn’t built it without nested s, it gives a good impression on how to work with them. Of course, there is a fancy state diagram for this example, too!\n\nA basic example of how Telegram WebApps can be used. Use in combination with the HTML page. For your convenience, this file is hosted by the PTB team such that you don’t need to host it yourself. Uses the iro.js JavaScript library to showcase a user interface that is hard to achieve with native Telegram functionality."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot",
        "document": "We have made you a wrapper you can't refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nThis library provides a pure Python, asynchronous interface for the Telegram Bot API. It's compatible with Python versions 3.9+.\n\nIn addition to the pure API implementation, this library features several convenience methods and shortcuts as well as a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the submodule.\n\nAfter installing the library, be sure to check out the section on working with PTB.\n\nAll types and methods of the Telegram Bot API 8.3 are natively supported by this library. In addition, Bot API functionality not yet natively included can still be used as described in our wiki.\n\nYou can install or upgrade via\n\nTo install a pre-release, use the flag in addition.\n\nYou can also install from source, though this is usually not necessary.\n\nTo enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures.\n\nStarting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value .\n\nEarlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format .\n\nIn addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix .\n\ntries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don't need the optional features.\n\nThe only required dependency is httpx ~= 0.27 for , the default networking backend.\n\nis most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out.\n\nPTB can be installed with optional dependencies:\n• installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• installs httpx[http2]. Use this, if you want to use HTTP/2.\n• installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• installs the tornado~=6.4 library. Use this, if you want to use / .\n• installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the .\n\nTo install multiple optional dependencies, separate them by commas, e.g. .\n• installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let's get started!\n\nOur Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• The official Telegram Bot API documentation is of course always worth a read.\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n• We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• You can even ask for help on Stack Overflow using the python-telegram-bot tag.\n\nSince v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• all classes in the module that allow to add/remove allowed users/chats at runtime\n\nContributions of all sizes are welcome. Please review our contribution guidelines to get started. You can also help by reporting bugs or feature requests.\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be."
    },
    {
        "link": "https://medium.com/@moraneus/building-telegram-bot-with-python-telegram-bot-a-comprehensive-guide-7e33f014dc79",
        "document": "Creating a Telegram bot can significantly extend the functionality of your messaging experience, allowing for everything from automated responses to sophisticated interactions. This comprehensive guide will walk you through the process of building a basic Telegram bot with Python, incorporating user commands, message handling, and custom keyboards. We’ll use the library for its simplicity and powerful features.\n\nIn this article, I will demonstrate a very simple Car Sales Listing Bot that is designed to streamline the process of gathering some necessary information from users wishing to list their cars for sale. By engaging in a structured conversation, the bot collects details such as the car’s type, color, and mileage, and even allows for photo uploads, culminating in a summary that confirms the listing’s details.\n• Ability to upload a photo of the car.\n• Summary of the listing details for confirmation.\n• Create Your Bot: Open Telegram and search for the “BotFather” account. Start a conversation and use the command to create a new bot. Follow the prompts to set up your bot's name and username. BotFather will then give you a token, which is crucial for accessing the Telegram Bot API. Keep this token secure and do not share it.\n\nNow, let’s dive into coding your bot. Please create a new Python file, e.g., and open it in your favorite text editor. Then, follow these steps to write your bot.\n\nStart by importing necessary modules and setting up logging to help with debugging:\n\nStates in a Telegram bot, especially when using a conversation handler, serve as a framework to manage the flow of interaction between the bot and the user. They are essentially markers or checkpoints that define what part of the conversation the user is currently engaged with and determine what the bot should do next based on the user’s input. Here’s a more general overview of the role and functionality of states in managing bot conversations. The purpose and functionality of states in the Telegram bot are:\n• Sequential Flow Management: States allow the bot to manage a sequential flow of conversation. By moving from one state to another, the bot can guide the user through a series of steps, questions, or options in a logical order.\n• Context Awareness: They help the bot maintain context in a conversation. By knowing the current state, the bot understands what information has been provided by the user and what information is still needed, enabling it to respond appropriately.\n• User Input Processing: Based on the current state, the bot can process user inputs differently. For example, an input in the “CAR_TYPE” state would be understood as the user specifying the type of car they’re selling, while the same input in the “CAR_COLOR” state would be interpreted as the color of the car.\n• Conditional Logic Implementation: States allow for the implementation of conditional logic in the conversation. Depending on user responses or choices, the bot can decide to skip certain states, repeat them, or take the user down a different conversational path.\n• Error Handling and Repetition: They facilitate error handling and the repetition of questions if the user provides unexpected or invalid responses. By keeping track of the current state, the bot can re-prompt the user for information correctly.\n• State Persistence: In more complex bots, states can be stored and persisted across sessions, allowing users to pick up the conversation where they left off, even if they temporarily leave the chat or if the bot restarts.\n\nLet’s enumerate the states for our bot to manage the flow:\n\nConversation handlers in Telegram bots, particularly when using libraries like , are powerful tools that manage the flow of conversations based on user inputs and predefined states. They are crucial for developing bots that require a sequence of interactions, such as collecting information, guiding users through menus, or executing commands in a specific order. Here's a closer look at how conversation handlers work and their role in bot development:\n• Managing Conversational States: Conversation handlers keep track of the current state of the dialogue with each user. They determine what the bot should do next based on the user’s input and the current state, allowing for a smooth and logical progression through different stages of interaction.\n• Routing User Inputs: They route user inputs to different callback functions based on the current state. This means that the same input can lead to different outcomes depending on where the user is in the conversation flow.\n• Handling Commands and Text: Conversation handlers can differentiate between commands (like or ) and regular text messages, allowing developers to specify distinct responses or actions for each type of input.\n• Integrating with Keyboards and Buttons: They work seamlessly with custom keyboards and inline buttons, enabling developers to create interactive and user-friendly interfaces within the conversation. Users can select options or navigate through the bot’s features using these UI elements.\n• Fallbacks and Timeouts: Conversation handlers support fallback functions, which can be triggered when the user sends unexpected input or when the conversation needs to be reset. They can also handle timeouts, ending a conversation automatically after a period of inactivity.\n• Entry Points: These are triggers that start the conversation. Commonly, the command is used as an entry point, but you can define multiple entry points for different conversation flows.\n• States: As discussed, states represent different points in the conversation. Each state is associated with one or more callback functions that define the bot’s behavior at that stage. Developers map states to these callbacks, dictating the flow of the conversation.\n• Fallbacks: Fallback functions are defined to handle unexpected situations or to provide a way to exit or reset the conversation. A common fallback is a command that allows users to stop the conversation at any point.\n\nFollowing, is the handler function initiates the conversation (entry point), presenting the user with a selection of car types:\n\nHere you can find the rest of the handlers:\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sport\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\nIn the function, set up the and , including entry points, states, and fallbacks. Start the bot with polling to listen for updates:\n\nComplete your script with a call to the function. Run your bot by executing the Python script in your terminal.\n\nHere you can find the whole code:\n\nimport logging\n\nfrom telegram import (ReplyKeyboardMarkup, ReplyKeyboardRemove, Update,\n\n InlineKeyboardButton, InlineKeyboardMarkup)\n\nfrom telegram.ext import (Application, CallbackQueryHandler, CommandHandler,\n\n ContextTypes, ConversationHandler, MessageHandler, filters)\n\n\n\n# Enable logging\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\n level=logging.INFO)\n\n\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Define states\n\nCAR_TYPE, CAR_COLOR, CAR_MILEAGE_DECISION, CAR_MILEAGE, PHOTO, SUMMARY = range(6)\n\n\n\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Starts the conversation and asks the user about their preferred car type.\"\"\"\n\n reply_keyboard = [['Sedan', 'SUV', 'Sports', 'Electric']]\n\n\n\n await update.message.reply_text(\n\n '<b>Welcome to the Car Sales Listing Bot!\n\n'\n\n 'Let\\'s get some details about the car you\\'re selling.\n\n'\n\n 'What is your car type?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True, resize_keyboard=True),\n\n )\n\n\n\n return CAR_TYPE\n\n\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sports\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\n\n\n\n\ndef main() -> None:\n\n \"\"\"Run the bot.\"\"\"\n\n application = Application.builder().token(\"YOUR TOKEN HERE\").build()\n\n\n\n conv_handler = ConversationHandler(\n\n entry_points=[CommandHandler('start', start)],\n\n states={\n\n CAR_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_type)],\n\n CAR_COLOR: [CallbackQueryHandler(car_color)],\n\n CAR_MILEAGE_DECISION: [CallbackQueryHandler(car_mileage_decision)],\n\n CAR_MILEAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_mileage)],\n\n PHOTO: [\n\n MessageHandler(filters.PHOTO, photo),\n\n CommandHandler('skip', skip_photo)\n\n ],\n\n SUMMARY: [MessageHandler(filters.ALL, summary)]\n\n },\n\n fallbacks=[CommandHandler('cancel', cancel)],\n\n )\n\n\n\n application.add_handler(conv_handler)\n\n\n\n # Handle the case when a user sends /start but they're not in a conversation\n\n application.add_handler(CommandHandler('start', start))\n\n\n\n application.run_polling()\n\n\n\n\n\nif __name__ == '__main__':\n\n main()\n\nStep 3: Testing and Interacting with Your Bot\n\nAfter running your script, find your bot on Telegram and start interacting with it. You should now be able to use the command to start a conversation, which will guide you through listing a car for sale."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-create-a-telegram-bot-using-python",
        "document": "Automated chatbots are quite useful for stimulating interactions. We can create chatbots for Slack, Discord, and other platforms.\n\nIn this article, I'll teach you how to build a Telegram chatbot that will tell you your horoscope. So, let’s get started!\n\nHow to Get Your Bot Token\n\nTo set up a new bot, you will need to talk to BotFather. No, he’s not a person – he’s also a bot, and he's the boss of all the Telegram bots.\n• Start a conversation with BotFather by clicking on the Start button.\n• Type , and follow the prompts to set up a new bot. The BotFather will give you a token that you will use to authenticate your bot and grant it access to the Telegram API.\n\nNote: Make sure you store the token securely. Anyone with your token access can easily manipulate your bot.\n\nHow to Set Up Your Coding Environment\n\nLet’s set up the coding environment. While there are various libraries available to create a Telegram bot, we’ll use the pyTelegramBotAPI library. It is a simple but extensible Python implementation for the Telegram Bot API with both synchronous and asynchronous capabilities.\n\nNext, open your favorite code editor and create a file to store your token as below:\n\nAfter that, run the command to read the environment variables from the file.\n\nHow to Create Your First Bot\n\nAll the API implementations are stored in a single class called . It offers many ways to listen for incoming messages as well as functions like , , and others to send messages.\n\nCreate a new file and paste the following code there:\n\nIn the above code, we use the library in order to read the environment variables stored in our system.\n\nIf you remember, we exported an environment variable called in the previous step. The value of is read in a variable called . Further, we use the class to create a bot instance and passed the to it.\n\nWe then need to register message handlers. These message handlers contain filters that a message must pass. If a message passes the filter, the decorated function is called and the incoming message is supplied as an argument.\n\nAny name is acceptable for a function that is decorated by a message handler, but it can only have one parameter (the message).\n\nLet’s add another handler that echoes all incoming text messages back to the sender.\n\nThe above code uses a expression to test a message. Since we need to echo all the messages, we always return from the function.\n\nYou now have a simple bot that responds to the and commands with a static message and echoes all the other sent messages. Add the following to the end of your file to launch the bot:\n\nThat’s it! We have a Telegram bot ready. Let’s run the Python file and go to Telegram to test the bot.\n\nSearch for the bot using its username if you’re unable to find it. You can test it by sending the commands like and and other random texts.\n\nNote: All the message handlers are tested in the order in which they were declared in the source file.\n\nFor more information on using the pyTelegramBotAPI library, you can refer to their documentation.\n\nHow to Code the Horoscope Bot\n\nLet’s shift our attention to building our Horoscope Bot now. We will use message chaining in the bot. The bot will first ask for your zodiac sign, and then the day, and then it will respond with the horoscope for that particular day.\n\nUnder the hood, the bot interacts with an API to get the horoscope data.\n\nWe are going to use the Horoscope API that I built in another tutorial. If you wish to learn how to build one, you can go through this tutorial. Make sure you explore the APIs here before getting started.\n\nHow to fetch the horoscope data\n\nLet’s create a utility function to fetch the horoscope data for a particular day.\n\nIn the above Python code, we created a function that accepts two string arguments – and – and returns JSON data. We send a GET request on the API URL and pass and as the query parameters.\n\nIf you test the function, you will get an output similar to below:\n\nNote: You can explore more about the library in Python in this tutorial.\n\nNow that we have a function that returns the horoscope data, let’s create a message handler in our bot that asks for the zodiac sign of the user.\n\nThe above function is a bit different from the other functions we defined earlier. The bot’s horoscope functionality will be invoked by the command. We are sending a text message to the user, but notice that we have set the to Markdown while sending the message.\n\nSince we’ll use message chaining, we used the method. This method accepts two parameters: the message sent by the user and the callback function which should be called after the message. Thus, we pass the variable and a new function that we’ll define next.\n\nLet’s define the function that accepts the message.\n\nWe fetch the zodiac sign from the attribute. Similar to the previous function, it also asks the day for which you want to know the horoscope.\n\nIn the end, we use the same method and pass the , the callback function, and the .\n\nLet’s now define the function that accepts the message and the sign.\n\nThis is the final function where we get the sign from the function parameter and the day from the attribute.\n\nNext, we fetch the horoscope using the function and construct our message. In the end, we send the message with the horoscope data.\n\nOnce you run the Python file, you can test this functionality. Here’s the demo:\n\nAs of now, the bot stops working as soon as we stop our Python application. In order to make it run always, you can deploy the bot on platforms like Heroku, Render, and so on.\n\nHere's a link to the GitHub repo for this project - feel free to check it out.\n\nYou can also add more functionalities to the bot by exploring the Telegram APIs.\n\nThanks for reading! You can follow me on Twitter."
    },
    {
        "link": "https://realpython.com/python-sqlite-sqlalchemy",
        "document": "All programs process data in one form or another, and many need to be able to save and retrieve that data from one invocation to the next. Python, SQLite, and SQLAlchemy give your programs database functionality, allowing you to store data in a single file without the need for a database server.\n\nYou can achieve similar results using flat files in any number of formats, including CSV, JSON, XML, and even custom formats. Flat files are often human-readable text files—though they can also be binary data—with a structure that can be parsed by a computer program. Below, you’ll explore using SQL databases and flat files for data storage and manipulation and learn how to decide which approach is right for your program.\n\nIn this tutorial, you’ll learn how to use:\n• SQLAlchemy to work with data as Python objects\n\nYou can get all of the code and data you’ll see in this tutorial by clicking on the link below:\n\nA flat file is a file containing data with no internal hierarchy and usually no references to external files. Flat files contain human-readable characters and are very useful for creating and reading data. Because they don’t have to use fixed field widths, flat files often use other structures to make it possible for a program to parse text. For example, comma-separated value (CSV) files are lines of plain text in which the comma character separates the data elements. Each line of text represents a row of data, and each comma-separated value is a field within that row. The comma character delimiter indicates the boundary between data values. Python excels at reading from and saving to files. Being able to read data files with Python allows you to restore an application to a useful state when you rerun it at a later time. Being able to save data in a file allows you to share information from the program between users and sites where the application runs. Before a program can read a data file, it has to be able to understand the data. Usually, this means the data file needs to have some structure that the application can use to read and parse the text in the file. Below is a CSV file named , used by the first example program in this tutorial: The first line provides a comma-separated list of fields, which are the column names for the data that follows in the remaining lines. The rest of the lines contain the data, with each line representing a single record. Note: Though the authors, books, and publishers are all real, the relationships between books and publishers are fictional and were created for the purposes of this tutorial. Next, you’ll take a look at some of the advantages and disadvantages of using flat files like the above CSV to work with your data. Working with data in flat files is manageable and straightforward to implement. Having the data in a human-readable format is helpful not only for creating the data file with a text editor but also for examining the data and looking for any inconsistencies or problems. Many applications can export flat-file versions of the data generated by the file. For example, Excel can import or export a CSV file to and from a spreadsheet. Flat files also have the advantage of being self-contained and transferable if you want to share the data. Almost every programming language has tools and libraries that make working with CSV files easier. Python has the built-in module and the powerful pandas module available, making working with CSV files a potent solution. The advantages of working with flat files start to diminish as the data becomes larger. Large files are still human-readable, but editing them to create data or look for problems becomes a more difficult task. If your application will change the data in the file, then one solution would be to read the entire file into memory, make the changes, and write the data out to another file. Another problem with using flat files is that you’ll need to explicitly create and maintain any relationships between parts of your data and the application program within the file syntax. Additionally, you’ll need to generate code in your application to use those relationships. A final complication is that people you want to share your data file with will also need to know about and act on the structures and relationships you’ve created in the data. To access the information, those users will need to understand not only the structure of the data but also the programming tools necessary for accessing it. The example program uses the file to get the data and relationships in it. This CSV file maintains a list of authors, the books they’ve published, and the publishers for each of the books. Note: The data files used in the examples are available in the directory. There’s also a program file in the directory that generates the data. That application is useful if you change the data and want to get back to a known state. To get access to the data files used in this section and throughout the tutorial, click on the link below: Download the sample code: Click here to get the code you’ll use to learn about data management with SQLite and SQLAlchemy in this tutorial. The CSV file presented above is a pretty small data file containing only a few authors, books, and publishers. You should also notice some things about the data:\n• The authors Stephen King and Tom Clancy appear more than once because multiple books they’ve published are represented in the data.\n• The authors Stephen King and Pearl Buck have the same book published by more than one publisher. These duplicated data fields create relationships between other parts of the data. One author can write many books, and one publisher can work with multiple authors. Authors and publishers share relationships with individual books. The relationships in the file are represented by fields that appear multiple times in different rows of the data file. Because of this data redundancy, the data represents more than a single two-dimensional table. You’ll see more of this when you use the file to create an SQLite database file. The example program uses the relationships embedded in the file to generate some data. It first presents a list of the authors and the number of books each has written. It then shows a list of publishers and the number of authors for which each has published books. It also uses the module to display a tree hierarchy of the authors, books , and publishers. Lastly, it adds a new book to the data and redisplays the tree hierarchy with the new book in place. Here’s the entry-point function for this program: \"\"\"The main entry point of the program\"\"\" # Get the resources for the program # Get the number of books printed by each publisher # Get the number of authors each publisher publishes # Add a new book to the data structure The Python code above takes the following steps:\n• Lines 4 to 7 read the file into a pandas DataFrame.\n• Lines 10 to 13 print the number of books published by each publisher.\n• Lines 16 to 19 print the number of authors associated with each publisher.\n• Line 22 outputs the book data as a hierarchy sorted by authors.\n• Lines 25 to 30 add a new book to the in-memory structure.\n• Line 33 outputs the book data as a hierarchy sorted by authors, including the newly added book. Running this program generates the following output: The author hierarchy above is presented twice in the output, with the addition of Stephen King’s The Stand, published by Random House. The actual output above has been edited and shows only the first hierarchy output to save space. calls other functions to perform the bulk of the work. The first function it calls is : \"\"\"Get book data from the csv file\"\"\" This function takes in the file path to the CSV file and uses pandas to read it into a pandas DataFrame, which it then passes back to the caller. The return value of this function becomes the data structure passed to the other functions that make up the program. calculates the number of books published by each publisher. The resulting pandas Series uses the pandas GroupBy functionality to group by publisher and then sort based on the flag: \"\"\"Return the number of books by each publisher as a pandas series\"\"\" does essentially the same thing as the previous function, but for authors: \"\"\"Returns the number of authors by each publisher as a pandas series\"\"\" creates a new book in the pandas DataFrame. The code checks to see if the author, book, or publisher already exists. If not, then it creates a new book and appends it to the pandas DataFrame: \"\"\"Adds a new book to the system\"\"\" uses nested loops to iterate through the levels of the data structure. It then uses the module to output a hierarchical listing of the authors, the books they’ve published, and the publishers who’ve published those books: \"\"\"Output the data as a hierarchy list of authors\"\"\" This application works well and illustrates the power available to you with the pandas module. The module provides excellent functionality for reading a CSV file and interacting with the data. Let’s push on and create an identically functioning program using Python, an SQLite database version of the author and publication data, and SQLAlchemy to interact with that data.\n\nAs you saw earlier, there’s redundant data in the file. For example, all information about Pearl Buck’s The Good Earth is listed twice because two different publishers have published the book. Imagine if this data file contained more related data, like the author’s address and phone number, publication dates and ISBNs for books, or addresses, phone numbers, and perhaps yearly revenue for publishers. This data would be duplicated for each root data item, like author, book, or publisher. It’s possible to create data this way, but it would be exceptionally unwieldy. Think about the problems keeping this data file current. What if Stephen King wanted to change his name? You’d have to update multiple records containing his name and make sure there were no typos. Worse than the data duplication would be the complexity of adding other relationships to the data. What if you decided to add phone numbers for the authors, and they had phone numbers for home, work, mobile, and perhaps more? Every new relationship that you’d want to add for any root item would multiply the number of records by the number of items in that new relationship. This problem is one reason that relationships exist in database systems. An important topic in database engineering is database normalization, or the process of breaking apart data to reduce redundancy and increase integrity. When a database structure is extended with new types of data, having it normalized beforehand keeps changes to the existing structure to a minimum. The SQLite database is available in Python, and according to the SQLite home page, it’s used more than all other database systems combined. It offers a full-featured relational database management system (RDBMS) that works with a single file to maintain all the database functionality. It also has the advantage of not requiring a separate database server to function. The database file format is cross-platform and accessible to any programming language that supports SQLite. All of this is interesting information, but how is it relevant to the use of flat files for data storage? You’ll find out below! The brute force approach to getting the data into an SQLite database would be to create a single table matching the structure of the CSV file. Doing this would ignore a good deal of SQLite’s power. Relational databases provide a way to store structured data in tables and establish relationships between those tables. They usually use Structured Query Language (SQL) as the primary way to interact with the data. This is an oversimplification of what RDBMSs provide, but it’s sufficient for the purposes of this tutorial. An SQLite database provides support for interacting with the data table using SQL. Not only does an SQLite database file contain the data, but it also has a standardized way to interact with the data. This support is embedded in the file, meaning that any programming language that can use an SQLite file can also use SQL to work with it. SQL is a declarative language used to create, manage, and query the data contained in a database. A declarative language describes what is to be accomplished rather than how it should be accomplished. You’ll see examples of SQL statements later when you get to creating database tables.\n\nTo take advantage of the power in SQL, you’ll need to apply some database normalization to the data in the file. To do this, you’ll separate the authors, books, and publishers into separate database tables. Conceptually, data is stored in the database in two-dimensional table structures. Each table consists of rows of records, and each record consists of columns, or fields, containing data. The data contained in the fields is of pre-defined types, including text, integers, floats, and more. CSV files are different because all the fields are text and must be parsed by a program to have a data type assigned to them. Each record in the table has a primary key defined to give a record a unique identifier. The primary key is similar to the key in a Python dictionary. The database engine itself often generates the primary key as an incrementing integer value for every record inserted into the database table. Though the primary key is often automatically generated by the database engine, it doesn’t have to be. If the data stored in a field is unique across all other data in the table in that field, then it can be the primary key. For example, a table containing data about books could use the book’s ISBN as the primary key. Here’s how you can create the three tables representing the authors, books, and publishers in the CSV file using SQL statements: Notice there are no file operations, no variables created, and no structures to hold them. The statements describe only the desired result: the creation of a table with particular attributes. The database engine determines how to do this. Once you’ve created and populated this table with author data from the file, you can access it using SQL statements. The following statement (also called a query) uses the wildcard character ( ) to get all the data in the table and output it: You can use the command-line tool to interact with the database file in the directory: Once the SQLite command-line tool is running with the database open, you can enter SQL commands. Here’s the above SQL command and its output, followed by the command to exit the program: Notice that each author exists only once in the table. Unlike the CSV file, which had multiple entries for some of the authors, here, only one unique record per author is necessary. SQL provides ways to work with existing databases and tables by inserting new data and updating or deleting existing data. Here’s an example SQL statement for inserting a new author into the table: This SQL statement inserts the values ‘ ’ and ‘ ’ into the respective columns and of the table. Notice that the column isn’t specified. Because that column is the primary key, the database engine generates the value and inserts it as part of the statement execution. Updating records in a database table is an uncomplicated process. For instance, suppose Stephen King wanted to be known by his pen name, Richard Bachman. Here’s an the SQL statement to update the database record: The SQL statement locates the single record for using the conditional statement and then updates the and fields with the new values. SQL uses the equals sign ( ) as both the comparison operator and assignment operator. You can also delete records from a database. Here’s an example SQL statement to delete a record from the table: This SQL statement deletes a single row from the table where the is equal to and the is equal to . Be careful when deleting records! The conditions you set must be as specific as possible. A conditional that’s too broad can lead to deleting more records than you intend. For example, if the condition were based only on the line , then all authors with a first name of Paul would be deleted from the database. Note: To avoid the accidental deletion of records, many applications don’t allow deletions at all. Instead, the record has another column to indicate if it’s in use or not. This column might be named and contain a value that evaluates to either True or False, indicating whether the record should be included when querying the database. For example, the SQL query below would get all columns for all active records in : SQLite doesn’t have a Boolean data type, so the column is represented by an integer with a value of or to indicate the state of the record. Other database systems may or may not have native Boolean data types. It’s entirely possible to build database applications in Python using SQL statements directly in the code. Doing so returns data to the application as a list of lists or list of dictionaries. Using raw SQL is a perfectly acceptable way to work with the data returned by queries to the database. However, rather than doing that, you’re going to move directly into using SQLAlchemy to work with databases.\n\nAnother feature of database systems that you might find even more powerful and useful than data persistence and retrieval is relationships. Databases that support relationships allow you to break up data into multiple tables and establish connections between them. The data in the file represents the data and relationships by duplicating data. A database handles this by breaking the data up into three tables— , , and —and establishing relationships between them. After getting all the data you want into one place in the CSV file, why would you want to break it up into multiple tables? Wouldn’t it be more work to create and put back together again? That’s true to an extent, but the advantages of breaking up the data and putting it back together using SQL could win you over! A one-to-many relationship is like that of a customer ordering items online. One customer can have many orders, but each order belongs to one customer. The database has a one-to-many relationship in the form of authors and books. Each author can write many books, but each book is written by one author. As you saw in the table creation above, the implementation of these separate entities is to place each into a database table, one for authors and one for books. But how does the one-to-many relationship between these two tables get implemented? Remember, each table in a database has a field designated as the primary key for that table. Each table above has a primary key field named using this pattern: . The table shown above contains a field, , that references the table. The field establishes a one-to-many relationship between authors and books that looks like this: The diagram above is a simple entity-relationship diagram (ERD) created with the JetBrains DataGrip application showing the tables and as boxes with their respective primary key and data fields. Two graphical items add information about the relationship:\n• The small yellow and blue key icons indicate the primary and foreign keys for the table, respectively.\n• The arrow connecting to indicates the relationship between the tables based on the foreign key in the table. When you add a new book to the table, the data includes an value for an existing author in the table. In this way, all the books written by an author have a lookup relationship back to that unique author. Now that you have separate tables for authors and books, how do you use the relationship between them? SQL supports what’s called a operation, which you can use to tell the database how to connect two or more tables. The SQL query below joins the and table together using the SQLite command-line application: The SQL query above gathers information from both the author and book table by joining the tables using the relationship established between the two. SQL string concatenation assigns the author’s full name to the alias . The data gathered by the query are sorted in ascending order by the field. There are a few things to notice in the SQL statement. First, authors are presented by their full names in a single column and sorted by their last names. Also, authors appear in the output multiple times because of the one-to-many relationship. An author’s name is duplicated for each book they’ve written in the database. By creating separate tables for authors and books and establishing the relationship between them, you’ve reduced redundancy in the data. Now you only have to edit an author’s data in one place, and that change appears in any SQL query accessing the data. Many-to-many relationships exist in the database between authors and publishers as well as between books and publishers. One author can work with many publishers, and one publisher can work with many authors. Similarly, one book can be published by many publishers, and one publisher can publish many books. Handling this situation in the database is more involved than a one-to-many relationship because the relationship goes both ways. Many-to-many relationships are created by an association table acting as a bridge between the two related tables. The association table contains at least two foreign key fields, which are the primary keys of each of the two associated tables. This SQL statement creates the association table relating the and tables: The SQL statements create a new table referencing the primary keys of the existing and tables. The table is an association table establishing relationships between an author and a publisher. Because the relationship is between two primary keys, there’s no need to create a primary key for the association table itself. The combination of the two related keys creates a unique identifier for a row of data. As before, you use the keyword to connect two tables together. Connecting the table to the table is a two-step process:\n• the table with the table.\n• the table with the table. The association table provides the bridge through which the connects the two tables. Here’s an example SQL query returning a list of authors and the publishers publishing their books: The statements above perform the following actions:\n• Line 1 starts a statement to get data from the database.\n• Line 2 selects the first and last name from the table using the alias for the table and concatenates them together with a space character.\n• Line 3 selects the publisher’s name aliased to .\n• Line 4 uses the table as the first source from which to retrieve data and assigns it to the alias .\n• Line 5 is the first step of the process outlined above for connecting the table to the table. It uses the alias for the association table and performs a operation to connect the foreign key reference to the primary key in the table.\n• Line 6 is the second step in the two-step process mentioned above. It uses the alias for the table and performs a operation to relate the foreign key reference to the primary key in the table.\n• Line 7 sorts the data by the author’s last name in ascending alphabetical order and ends the SQL query.\n• Lines 8 to 17 are the output of the SQL query. Note that the data in the source and tables are normalized, with no data duplication. Yet the returned results have duplicated data where necessary to answer the SQL query. The SQL query above demonstrates how to make use of a relationship using the SQL keyword, but the resulting data is a partial re-creation of the CSV data. What’s the win for having done the work of creating a database to separate the data? Here’s another SQL query to show a little bit of the power of SQL and the database engine: The SQL query above returns the list of authors and the number of books they’ve written. The list is sorted first by the number of books in descending order, then by the author’s name in alphabetical order:\n• Line 1 begins the SQL query with the keyword.\n• Line 2 selects the author’s first and last names, separated by a space character, and creates the alias .\n• Line 3 counts the number of books written by each author, which will be used later by the clause to sort the list.\n• Line 4 selects the table to get data from and creates the alias.\n• Line 5 connects to the related table through a to the and creates the alias for the table.\n• Line 6 generates the aggregated author and total number of books data by using the keyword. is what groups each and controls what books are tallied by for that author.\n• Line 7 sorts the output first by number of books in descending order, then by the author’s last name in ascending alphabetical order.\n• Lines 8 to 14 are the output of the SQL query. In the above example, you take advantage of SQL to perform aggregation calculations and sort the results into a useful order. Having the database perform calculations based on its built-in data organization ability is usually faster than performing the same kinds of calculations on raw data sets in Python. SQL offers the advantages of using set theory embedded in RDBMS databases. An entity-relationship diagram (ERD) is a visual depiction of an entity-relationship model for a database or part of a database. The SQLite database is small enough that the entire database can be visualized by the diagram shown below: This diagram presents the table structures in the database and the relationships between them. Each box represents a table and contains the fields defined in the table, with the primary key indicated first if it exists. The arrows show the relationships between the tables connecting a foreign key field in one table to a field, often the primary key, in another table. The table has two arrows, one connecting it to the table and another connecting it to the table. The arrow indicates the many-to-many relationship between the and tables. The table provides the same relationship between and .\n\nSQLAlchemy is a powerful database access tool kit for Python, with its object-relational mapper (ORM) being one of its most famous components, and the one discussed and used here. When you’re working in an object-oriented language like Python, it’s often useful to think in terms of objects. It’s possible to map the results returned by SQL queries to objects, but doing so works against the grain of how the database works. Sticking with the scalar results provided by SQL works against the grain of how Python developers work. This problem is known as object-relational impedance mismatch. The ORM provided by SQLAlchemy sits between the SQLite database and your Python program and transforms the data flow between the database engine and Python objects. SQLAlchemy allows you to think in terms of objects and still retain the powerful features of a database engine. One of the fundamental elements to enable connecting SQLAlchemy to a database is creating a model. The model is a Python class defining the data mapping between the Python objects returned as a result of a database query and the underlying database tables. The entity-relationship diagram displayed earlier shows boxes connected with arrows. The boxes are the tables built with the SQL commands and are what the Python classes will model. The arrows are the relationships between the tables. The models are Python classes inheriting from an SQLAlchemy class. The class provides the interface operations between instances of the model and the database table. Below is the file that creates the models to represent the database: Here’s what’s going on in this module:\n• Line 1 imports the , , , , and classes from SQLAlchemy, which are used to help define the model attributes.\n• Line 2 imports the and objects, which are used to create the relationships between objects.\n• Line 3 imports the object, which connects the database engine to the SQLAlchemy functionality of the models.\n• Line 5 creates the class, which is what all models inherit from and how they get SQLAlchemy ORM functionality.\n• Lines 21 to 29 define the class model to the database table.\n• Lines 31 to 38 define the class model to the database table.\n• Lines 40 to 49 define the class model to the database table. The description above shows the mapping of the five tables in the database. But it glosses over some SQLAlchemy ORM features, including , , , and . Let’s get into those now. and are both instances of the class that create the many-to-many association tables used between the and tables and the and tables, respectively. The SQLAlchemy class creates a unique instance of an ORM mapped table within the database. The first parameter is the table name as defined in the database, and the second is , which provides the connection between the SQLAlchemy functionality and the database engine. The rest of the parameters are instances of the class defining the table fields by name, their type, and in the example above, an instance of a . The SQLAlchemy class defines a dependency between two fields in different tables. A is how you make SQLAlchemy aware of the relationships between tables. For example, this line from the instance creation establishes a foreign key relationship: The statement above tells SQLAlchemy that there’s a column in the table named . The type of that column is , and is a foreign key related to the primary key in the table. Having both and defined in the instance creates the connection from the table to the table and vice versa, establishing a many-to-many relationship. Having a defines the existence of the relationship between tables but not the collection of books an author can have. Take a look at this line in the class definition: The code above defines a parent-child collection. The attribute being plural (which is not a requirement, just a convention) is an indication that it’s a collection. The first parameter to , the class name (which is not the table name ), is the class to which the attribute is related. The informs SQLAlchemy that there’s a relationship between the and classes. SQLAlchemy will find the relationship in the class definition: SQLAlchemy recognizes that this is the connection point between the two classes. You’ll get to the parameter in in a moment. The other relationship in is to the class. This is created with the following statement in the class definition: Like , the attribute indicates a collection of publishers associated with an author. The first parameter, , informs SQLAlchemy what the related class is. The second and third parameters are and :\n• tells SQLAlchemy that the relationship to the class is through a secondary table, which is the association table created earlier in . The parameter makes SQLAlchemy find the defined in the association table.\n• is a convenience configuration telling SQLAlchemy that there’s a complementary collection in the class called . The parameter of the collection creates an attribute for each instance. This attribute refers to the parent that the instance is related to. For example, if you executed the following Python code, then a instance would be returned from the SQLAlchemy query. The instance has attributes that can be used to print out information about the book: The existence of the attribute in the above is because of the definition. A can be very handy to have when you need to refer to the parent and all you have is a child instance. You can make a basic query like in SQLAlchemy like this: The is an SQLAlchemy object used to communicate with SQLite in the Python example programs. Here, you tell the session you want to execute a query against the model and return all records. At this point, the advantages of using SQLAlchemy instead of plain SQL might not be obvious, especially considering the setup required to create the models representing the database. The returned by the query is where the magic happens. Instead of getting back a list of lists of scalar data, you’ll get back a list of instances of objects with attributes matching the column names you defined. The and collections maintained by SQLAlchemy create a hierarchical list of authors and the books they’ve written as well as the publishers who’ve published them. Behind the scenes, SQLAlchemy turns the object and method calls into SQL statements to execute against the SQLite database engine. SQLAlchemy transforms the data returned by SQL queries into Python objects. With SQLAlchemy, you can perform the more complex aggregation query shown earlier for the list of authors and the number of books they’ve written like this: The query above gets the author’s first and last name, along with a count of the number of books that the author has written. The aggregating used by the clause is based on the author’s last name. Finally, the results are sorted in descending order based on the aggregated and aliased . The example program has the same functionality as but uses SQLAlchemy exclusively to interface with the SQLite database. The program is broken up into the function and the functions it calls: # Connect to the database using SQLAlchemy # Get the number of books printed by each publisher # Get the number of authors each publisher publishes This program is a modified version of . Let’s go over the differences:\n• Lines 4 to 7 first initialize the variable to the database file path. Then they create the variable to communicate with SQLite and the database file, which is SQLAlchemy’s access point to the database.\n• Line 8 creates the class from the SQLAlchemy’s .\n• Line 9 binds the to the engine created in line 8.\n• Line 10 creates the instance, which is used by the program to communicate with SQLAlchemy. The rest of the function is similar, except for the replacement of with as the first parameter to all the functions called by . has been refactored to use SQLAlchemy and the models you defined earlier to get the data requested: \"\"\"Get a list of publishers and the number of books they've published\"\"\" Here’s what the new function, , is doing:\n• Line 6 creates the variable and sets it equal to the SQLAlchemy or function depending on the value of the parameter.\n• Lines 9 to 11 query the table for data to return, which in this case are and the aggregate total of objects associated with an author, aliased to .\n• Line 13 aggregates the book counts by the attribute.\n• Line 14 sorts the output by the book counts according to the operator defined by .\n• Line 15 closes the object, executes the query, and returns the results to the caller. All the above code expresses what is wanted rather than how it’s to be retrieved. Now instead of using SQL to describe what’s wanted, you’re using Python objects and methods. What’s returned is a list of Python objects instead of a list of tuples of data. has also been modified to work exclusively with SQLAlchemy. Its functionality is very similar to the previous function, so a function description is omitted: \"\"\"Get a list of publishers and the number of authors they've published\"\"\" has been added to get a list of authors sorted by their last names. The result of this query is a list of objects containing a collection of books. The objects already contain hierarchical data, so the results don’t have to be reformatted: \"\"\"Get a list of author objects sorted by last name\"\"\" Like its previous version, is relatively complex but straightforward to understand. It determines if a book with the same title, author, and publisher exists in the database already. If the search query finds an exact match, then the function returns. If no book matches the exact search criteria, then it searches to see if the author has written a book using the passed in title. This code exists to prevent duplicate books from being created in the database. If no matching book exists, and the author hasn’t written one with the same title, then a new book is created. The function then retrieves or creates an author and publisher. Once instances of the , and exist, the relationships between them are created, and the resulting information is saved to the database: \"\"\"Adds a new book to the system\"\"\" # Get the author's first and last names # Does the book by the author and publisher already exist? # Get the book by the author # Create the new book if needed # Do we need to create the author? # Do we need to create the publisher? The code above is relatively long. Let’s break the functionality down to manageable sections:\n• Lines 7 to 18 set the variable to an instance of a if a book with the same title, author, and publisher is found. Otherwise, they set to .\n• Lines 20 and 21 determine if the book already exists and return if it does.\n• Lines 24 to 37 set the variable to an instance of a if a book with the same title and author is found. Otherwise, they create a new instance.\n• Lines 40 to 52 set the variable to an existing author, if found, or create a new instance based on the passed-in author name.\n• Lines 55 to 63 set the variable to an existing publisher, if found, or create a new instance based on the passed-in publisher name.\n• Line 66 sets the instance to the instance. This creates the relationship between the author and the book, which SQLAlchemy will create in the database when the session is committed.\n• Line 67 adds the instance to the collection. This creates the many-to-many relationship between the and tables. SQLAlchemy will create references in the tables as well as in the association table that connects the two.\n• Line 68 adds the instance to the session, making it part of the session’s unit of work.\n• Line 71 commits all the creations and updates to the database. There are a few things to take note of here. First, there’s is no mention of the or association tables in either the queries or the creations and updates. Because of the work you did in setting up the relationships, SQLAlchemy can handle connecting objects together and keeping those tables in sync during creations and updates. Second, all the creations and updates happen within the context of the object. None of that activity is touching the database. Only when the statement executes does the session then go through its unit of work and commit that work to the database. For example, if a new instance is created (as in line 37 above), then the book has its attributes initialized except for the primary key and foreign key. Because no database activity has happened yet, the is unknown, and nothing was done in the instantiation of to give it an . When is executed, one of the things it will do is insert into the database, at which point the database will create the primary key. The session will then initialize the value with the primary key value created by the database engine. is also aware of the insertion of the instance in the collection. The object’s primary key will be added to the instance appended to the collection as the foreign key.\n\nTo this point, you’ve seen how to use pandas, SQLite, and SQLAlchemy to access the same data in different ways. For the relatively straightforward use case of the author, book, and publisher data, it could still be a toss-up whether you should use a database. One deciding factor when choosing between using a flat file or a database is data and relationship complexity. If the data for each entity is complicated and contains many relationships between the entities, then creating and maintaining it in a flat file might become more difficult. Another factor to consider is whether you want to share the data between multiple users. The solution to this problem might be as simple as using a sneakernet to physically move data between users. Moving data files around this way has the advantage of ease of use, but the data can quickly get out of sync when changes are made. The problem of keeping the data consistent for all users becomes even more difficult if the users are remote and want to access the data across networks. Even when you’re limited to a single language like Python and using pandas to access the data, network file locking isn’t sufficient to ensure the data doesn’t get corrupted. Providing the data through a server application and a user interface alleviates this problem. The server is the only application that needs file-level access to the database. By using a database, the server can take advantage of SQL to access the data using a consistent interface no matter what programming language the server uses. The last example program demonstrates this by providing a web application and user interface to the Chinook sample SQLite database. Peter Stark generously maintains the Chinook database as part of the SQLite Tutorial site. If you’d like to learn more about SQLite and SQL in general, then the site is a great resource. The Chinook database provides artist, music, and playlist information along the lines of a simplified Spotify. The database is part of the example code project in the folder.\n\nUsing Flask With Python, SQLite, and SQLAlchemy The program creates a Flask application that you can interact with using a browser. The application makes use of the following technologies:\n• Flask Blueprint is part of Flask and provides a good way to follow the separation of concerns design principle and create distinct modules to contain functionality.\n• Flask SQLAlchemy is an extension for Flask that adds support for SQLAlchemy in your web applications.\n• Flask_Bootstrap4 packages the Bootstrap front-end tool kit, integrating it with your Flask web applications.\n• Flask_WTF extends Flask with WTForms, giving your web applications a useful way to generate and validate web forms.\n• python_dotenv is a Python module that an application uses to read environment variables from a file and keep sensitive information out of program code. Though not necessary for this example, a file holds the environment variables for the application. The file exists to contain sensitive information like passwords, which you should keep out of your code files. However, the content of the project file is shown below since it doesn’t contain any sensitive data: The example application is fairly large, and only some of it is relevant to this tutorial. For this reason, examining and learning from the code is left as an exercise for the reader. That said, you can take a look at an animated screen capture of the application below, followed by the HTML that renders the home page and the Python Flask route that provides the dynamic data. Here’s the application in action, navigating through various menus and features: The animated screen capture starts on the application home page, styled using Bootstrap 4. The page displays the artists in the database, sorted in ascending order. The remainder of the screen capture presents the results of clicking on the displayed links or navigating around the application from the top-level menu. Here’s the Jinja2 HTML template that generates the home page of the application: {% extends \"base.html\" %} {% block content %} Create New Artist {{ form.csrf_token }} {{ render_field(form.name, placeholder=form.name.label.text) }} Create List of Artists Artist Name {% for artist in artists %} {{ artist.name }} {% endfor %} {% endblock %} Here’s what’s going on in this Jinja2 template code:\n• Line 1 uses Jinja2 template inheritance to build this template from the template. The template contains all the HTML5 boilerplate code as well as the Bootstrap navigation bar consistent across all pages of the site.\n• Lines 3 to 37 contain the block content of the page, which is incorporated into the Jinja2 macro of the same name in the base template.\n• Lines 9 to 13 render the form to create a new artist. This uses the features of Flask-WTF to generate the form.\n• Lines 24 to 32 create a loop that renders the table of artist names.\n• Lines 27 to 29 render the artist name as a link to the artist’s album page showing the songs associated with a particular artist. Here’s the Python route that renders the page: Let’s go over what the above code is doing:\n• Lines 1 to 6 import all the modules necessary to render the page and initialize forms with data from the database.\n• Lines 9 to 11 create the blueprint for the artists page.\n• Lines 13 to 20 create a custom validator function for the Flask-WTF forms to make sure a request to create a new artist doesn’t conflict with an already existing artist.\n• Lines 22 to 25 create the form class to handle the artist form rendered in the browser and provide validation of the form field inputs.\n• Lines 27 to 28 connect two routes to the function they decorate.\n• Line 30 creates an instance of the class.\n• Line 33 determines if the page was requested through the HTTP methods GET or POST (submit). If it was a POST, then it also validates the fields of the form and informs the user if the fields are invalid.\n• Lines 35 to 37 create a new artist object, add it to the SQLAlchemy session, and commit the artist object to the database, persisting it.\n• Line 38 redirects back to the artists page, which will be rerendered with the newly created artist.\n• Line 40 runs an SQLAlchemy query to get all the artists in the database and sort them by .\n• Line 41 renders the artists page if the HTTP request method was a GET. You can see that a great deal of functionality is created by a reasonably small amount of code."
    },
    {
        "link": "https://freecodecamp.org/news/work-with-sqlite-in-python-handbook",
        "document": "SQLite is one of the most popular relational database management systems (RDBMS). It’s lightweight, meaning that it doesn’t take up much space on your system. One of its best features is that it’s serverless, so you don’t need to install or manage a separate server to use it.\n\nInstead, it stores everything in a simple file on your computer. It also requires zero configuration, so there’s no complicated setup process, making it perfect for beginners and small projects.\n\nSQLite is a great choice for small to medium applications because it’s easy to use, fast, and can handle most tasks that bigger databases can do, but without the hassle of managing extra software. Whether you're building a personal project or prototyping a new app, SQLite is a solid option to get things up and running quickly.\n\nIn this tutorial, you'll learn how to work with SQLite using Python. Here’s what we’re going to cover in this tutorial:\n• None How to Set Up Your Python Environment\n• None How to Create an SQLite Database\n• None How to Insert Data into a Table\n• None How to Update and Delete Data\n• None How to Use Transactions\n• None How to Optimize SQLite Query Performance with Indexing\n• None How to Handle Errors and Exceptions\n• None How to Export and Import Data [Bonus Section]\n\nThis tutorial is perfect for anyone who wants to get started with databases without diving into complex setups.\n\nHow to Set Up Your Python Environment\n\nBefore working with SQLite, let’s ensure your Python environment is ready. Here’s how to set everything up.\n\nIf you don’t have Python installed on your system yet, you can download it from the official Python website. Follow the installation instructions for your operating system (Windows, macOS, or Linux).\n\nTo check if Python is installed, open your terminal (or command prompt) and type:\n\nThis should show the current version of Python installed. If it’s not installed, follow the instructions on the Python website.\n\nThe good news is that SQLite3 comes built-in with Python! You don’t need to install it separately because it’s included in the standard Python library. This means you can start using it right away without any additional setup.\n\nHow to Create a Virtual Environment (Optional but Recommended)\n\nIt’s a good idea to create a virtual environment for each project to keep your dependencies organized. A virtual environment is like a clean slate where you can install packages without affecting your global Python installation.\n• None First, open your terminal or command prompt and navigate to the directory where you want to create your project.\n• None Run the following command to create a virtual environment:\n\nHere, is the name of the virtual environment. You can name it anything you like.\n\nAfter activating the virtual environment, you’ll notice that your terminal prompt changes, showing the name of the virtual environment. This means you’re now working inside it.\n\nWe’ll need a few additional libraries for this project. Specifically, we’ll use:\n• None : This is an optional library for handling and displaying data in tabular format, useful for advanced use cases.\n• None : This library will help us generate fake data, like random names and addresses, which we can insert into our database for testing.\n\nTo install and , simply run the following commands:\n\nThis installs both and into your virtual environment. With this, your environment is set up, and you’re ready to start creating and managing your SQLite database in Python!\n\nHow to Create an SQLite Database\n\nA database is a structured way to store and manage data so that it can be easily accessed, updated, and organized. It’s like a digital filing system that allows you to efficiently store large amounts of data, whether it’s for a simple app or a more complex system. Databases use tables to organize data, with rows and columns representing individual records and their attributes.\n\nUnlike most other database systems, SQLite is a serverless database. This means that it doesn’t require setting up or managing a server, making it lightweight and easy to use. All the data is stored in a single file on your computer, which you can easily move, share, or back up. Despite its simplicity, SQLite is powerful enough to handle many common database tasks and is widely used in mobile apps, embedded systems, and small to medium-sized projects.\n\nHow to Create a New SQLite Database\n\nLet’s create a new SQLite database and learn how to interact with it using Python’s library.\n\nSince is pre-installed, you just need to import it in your Python script. To create a new database or connect to an existing one, we use the method. This method takes the name of the database file as an argument. If the file doesn’t exist, SQLite will automatically create it.\n\nIn this example, a file named is created in the same directory as your script. If the file already exists, SQLite will just open the connection to it.\n\nOnce you have a connection, the next step is to create a cursor object. The cursor is responsible for executing SQL commands and queries on the database.\n\nAfter you’ve finished working with the database, it’s important to close the connection to free up any resources. You can close the connection with the following command:\n\nHowever, you should only close the connection once you’re done with all your operations.\n\nWhen you run your Python script, a file named will be created in your current working directory. You’ve now successfully created your first SQLite database!\n\nHow to Use Context Manager to Open and Close Connections\n\nPython provides a more efficient and cleaner way to handle database connections using the statement, also known as a context manager. The statement automatically opens and closes the connection, ensuring that the connection is properly closed even if an error occurs during the database operations. This eliminates the need to manually call .\n\nHere’s how you can use the statement to handle database connections:\n\nFrom now on, we’ll use the statement in our upcoming code examples to manage database connections efficiently. This will make the code more concise and easier to maintain.\n\nNow that we’ve created an SQLite database and connected to it, the next step is to create tables inside the database. A table is where we’ll store our data, organized in rows (records) and columns (attributes). For this example, we’ll create a table called to store information about students, which we’ll reuse in upcoming sections.\n\nTo create a table, we use SQL's statement. This command defines the table structure, including the column names and the data types for each column.\n\nHere’s a simple SQL command to create a table with the following fields:\n• None : A unique identifier for each student (an integer).\n• None name: The student's name (text).\n\nThe SQL command to create this table would look like this:\n\nWe can execute this SQL command in Python using the library. Let’s see how to do that.\n• None : This ensures that the table is only created if it doesn’t already exist, preventing errors if the table has been created before.\n• None : This saves (commits) the changes to the database.\n\nWhen you run the Python code above, it will create the table in the database file. You’ll also see a message in the terminal confirming that the table has been created successfully.\n\nIf you’re using Visual Studio Code, you can install the SQLite Viewer extension to view SQLite databases.\n\nData Types in SQLite and Their Mapping to Python\n\nSQLite supports several data types, which we need to understand when defining our tables. Here’s a quick overview of common SQLite data types and how they map to Python types:\n• None is of type , which maps to Python’s .\n• None and are of type , which map to Python’s .\n• None is also of type , mapping to Python’s .\n\nHow to Insert Data into a Table\n\nNow that we have our table created, it’s time to start inserting data into the database. In this section, we’ll cover how to insert both single and multiple records using Python and SQLite, and how to avoid common security issues like SQL injection by using parameterized queries.\n\nTo insert data into the database, we use the SQL command. Let’s start by inserting a single record into our table.\n\nHowever, instead of writing SQL directly in our Python script with hardcoded values, we’ll use parameterized queries to make our code more secure and flexible. Parameterized queries help prevent SQL injection, a common attack where malicious users can manipulate the SQL query by passing harmful input.\n\nHere’s how we can insert a single record into the table using a parameterized query:\n\nThe placeholders represent the values to be inserted into the table. The actual values are passed as a tuple ( ) in the method.\n\nIf you want to insert multiple records at once, you can use the method in Python. This method takes a list of tuples, where each tuple represents one record.\n\nTo make our example more dynamic, we can use the library to generate random student data. This is useful for testing and simulating real-world scenarios.\n• None generates random names, ages, and emails for students. Passing the locale( ) is optional.\n• None : This method allows us to insert multiple records at once, making the code more efficient.\n• None : A list of tuples where each tuple represents one student’s data.\n\nSQL injection is a security vulnerability where attackers can insert or manipulate SQL queries by providing harmful input. For example, an attacker might try to inject code like to delete the table.\n\nBy using parameterized queries (as demonstrated above), we avoid this issue. The placeholders in parameterized queries ensure that input values are treated as data, not as part of the SQL command. This makes it impossible for malicious code to be executed.\n\nNow that we’ve inserted some data into our table, let’s learn how to retrieve the data from the table. We'll explore different methods for fetching data in Python, including , , and .\n\nTo query data from a table, we use the statement. Here’s a simple SQL command to select all columns from the table:\n\nThis command retrieves all records and columns from the table. We can execute this query in Python and fetch the results.\n\nHow to Fetch All Records\n\nHere’s how we can fetch all records from the table:\n\nIn this example, the method retrieves all rows returned by the query as a list of tuples.\n\nIf you want to retrieve only one record, you can use the method:\n\nTo fetch a specific number of records, you can use :\n\nHow to Use for Better Data Presentation\n\nFor better data presentation, we can use the library to create a from our query results. This makes it easier to manipulate and visualize the data.\n\nHere’s how to fetch all records and display them as a pandas DataFrame:\n\nThe function executes the SQL query and directly returns the results as a pandas DataFrame.\n\nIn this section, we’ll learn how to update existing records and delete records from our table using SQL commands in Python. This is essential for managing and maintaining your data effectively.\n\nTo modify existing records in a database, we use the SQL command. This command allows us to change the values of specific columns in one or more rows based on a specified condition.\n\nFor example, if we want to update a student's age, the SQL command would look like this:\n\nNow, let’s write Python code to update a specific student's age in our table.\n\nIn this example, we used parameterized queries to prevent SQL injection.\n\nHow to Delete Records from the Table\n\nTo remove records from a database, we use the SQL command. This command allows us to delete one or more rows based on a specified condition.\n\nFor example, if we want to delete a student named 'Jane Doe', the SQL command would look like this:\n\nLet’s write Python code to delete a specific student from our table using the statement.\n• None Conditions: Always use the clause when updating or deleting records to avoid modifying or removing all rows in the table. Without a clause, the command affects every row in the table.\n• None Backup: It’s good practice to back up your database before performing updates or deletions, especially in production environments.\n\nHow to Use Transactions\n\nA transaction is a sequence of one or more SQL operations that are treated as a single unit of work. In the context of a database, a transaction allows you to perform multiple operations that either all succeed or none at all. This ensures that your database remains in a consistent state, even in the face of errors or unexpected issues.\n\nFor example, if you are transferring money between two bank accounts, you would want both the debit from one account and the credit to the other to succeed or fail together. If one operation fails, the other should not be executed to maintain consistency.\n• None Atomicity: Transactions ensure that a series of operations are treated as a single unit. If one operation fails, none of the operations will be applied to the database.\n• None Consistency: Transactions help maintain the integrity of the database by ensuring that all rules and constraints are followed.\n• None Isolation: Each transaction operates independently of others, preventing unintended interference.\n• None Durability: Once a transaction is committed, the changes are permanent, even in the event of a system failure.\n\nWhen to Use Transactions?\n\nYou should use transactions when:\n• None Performing multiple related operations that must succeed or fail together.\n• None Working with operations that can potentially fail, such as financial transactions or data migrations.\n\nHow to Manage Transactions in Python\n\nIn SQLite, transactions are managed using the , , and commands. However, when using the module in Python, you typically manage transactions through the connection object.\n\nA transaction begins implicitly when you execute any SQL statement. To start a transaction explicitly, you can use the command:\n\nHowever, it’s usually unnecessary to start a transaction manually, as SQLite starts a transaction automatically when you execute an SQL statement.\n\nTo save all changes made during a transaction, you use the method. This makes all modifications permanent in the database.\n\nWe have already used the method in the above provided examples.\n\nIf something goes wrong and you want to revert the changes made during a transaction, you can use the method. This will undo all changes made since the transaction started.\n\nExample of Using Transactions in Python\n\nTo illustrate the use of transactions in a real-world scenario, we’ll create a new table called to manage customer accounts. In this example, we’ll assume each customer has a . We will add two customers to this table and perform a funds transfer operation between them.\n\nFirst, let's create the table and insert two customers:\n\nNow, let’s perform the funds transfer operation between Ashutosh and Krishna:\n\nIn this example, we first created a table and inserted two customers, Ashutosh with a balance of ₹100, and Krishna with a balance of ₹50. We then performed a funds transfer of ₹80 from Ashutosh to Krishna. By using transactions, we ensure that both the debit from Ashutosh's account and the credit to Krishna's account are executed as a single atomic operation, maintaining data integrity in the event of any errors. If the transfer fails (for example, due to insufficient funds), the transaction will roll back, leaving both accounts unchanged.\n\nHow to Optimize SQLite Query Performance with Indexing\n\nIndexing is a powerful technique used in databases to improve query performance. An index is essentially a data structure that stores the location of rows based on specific column values, much like an index at the back of a book helps you quickly locate a topic.\n\nWithout an index, SQLite has to scan the entire table row by row to find the relevant data, which becomes inefficient as the dataset grows. By using an index, SQLite can jump directly to the rows you need, significantly speeding up query execution.\n\nHow to Populate the Database with Fake Data\n\nTo effectively test the impact of indexing, we need a sizable dataset. Instead of manually adding records, we can use the library to quickly generate fake data. In this section, we’ll generate 10,000 fake records and insert them into our table. This will simulate a real-world scenario where databases grow large, and query performance becomes important.\n\nWe will use the method to insert the records as below:\n\nBy running this script, 10,000 fake student records will be added to the table. In the next section, we'll query the database and compare the performance of queries with and without indexing.\n\nHow to Query Without Indexes\n\nIn this section, we’ll query the table without any indexes to observe how SQLite performs when there are no optimizations in place. This will serve as a baseline to compare the performance when we add indexes later.\n\nWithout indexes, SQLite performs a full table scan, which means that it must check every row in the table to find matching results. For small datasets, this is manageable, but as the number of records grows, the time taken to search increases dramatically. Let’s see this in action by running a basic query to search for a specific student by name and measure how long it takes.\n\nFirst, we’ll query the table by looking for a student with a specific name. We’ll log the time taken to execute the query using Python’s module to measure the performance.\n\nBy running the above script, you'll see how long it takes to search the table without any indexes. For example, if there are 10,000 records in the table, the query might take 1000-2000 microseconds depending on the size of the table and your hardware. This may not seem too slow for a small dataset, but the performance will degrade as more records are added.\n\nWe use to measure the time taken for the query execution in nanoseconds. This method is highly accurate for benchmarking small time intervals. We convert the time to microseconds( ) for easier readability.\n\nWhen working with databases, understanding how queries are executed can help you identify performance bottlenecks and optimize your code. SQLite provides a helpful tool for this called , which allows you to analyze the steps SQLite takes to retrieve data.\n\nIn this section, we’ll introduce how to use to visualize and understand the inner workings of a query—specifically, how SQLite performs a full table scan when no index is present.\n\nLet’s use to see how SQLite retrieves data from the table without any indexes. We’ll search for a student by name, and the query plan will reveal the steps SQLite takes to find the matching rows.\n\nWhen you run this code, SQLite will return a breakdown of how it plans to execute the query. Here’s an example of what the output might look like:\n\nThis indicates that SQLite is scanning the entire table (a full table scan) to find the rows where the column matches the provided value ( ). Since there is no index on the column, SQLite must examine each row in the table.\n\nHow to Create an Index\n\nCreating an index on a column allows SQLite to find rows more quickly during query operations. Instead of scanning the entire table, SQLite can use the index to jump directly to the relevant rows, significantly speeding up queries—especially those involving large datasets.\n\nTo create an index, use the following SQL command:\n\nIn this example, we will create an index on the column of the table. Here’s how you can do it using Python:\n\nEven though creating the index takes this long (102768.6 microseconds), it's a one-time operation. You will still get substantial speed-up when running multiple queries. In the following sections, we will query the database again to observe the performance improvements made possible by this index.\n\nHow to Query with Indexes\n\nIn this section, we will perform the same query we executed earlier, but this time we will take advantage of the index we created on the column of the table. We'll measure and log the execution time to observe the performance improvements provided by the index.\n\nHere’s what we get in the output:\n\nWe can observe a significant reduction in execution time compared to when the query was performed without an index.\n\nLet’s analyze the query execution plan for the query with the index on the column of the table. If you execute the same script again to explain the query, you’ll get the below output:\n\nThe plan now shows that the query uses the index , significantly reducing the number of rows that need to be scanned, which leads to faster query execution.\n\nNow, let's summarize the performance results we obtained when querying with and without indexes.\n• None The query with the index is approximately 4.04 times faster than the query without the index.\n• None The execution time improved by about 75.24% after adding the index.\n\nBest Practices for Using Indexes\n\nIndexes can significantly enhance the performance of your SQLite database, but they should be used judiciously. Here are some best practices to consider when working with indexes:\n\nWhen and Why to Use Indexes\n• None Frequent Query Columns: Use indexes on columns that are frequently used in queries, especially those used in , , and clauses. This is because indexing these columns can drastically reduce query execution time.\n• None Uniqueness Constraints: When you have columns that must hold unique values (like usernames or email addresses), creating an index can enforce this constraint efficiently.\n• None Large Datasets: For tables with a large number of records, indexes become increasingly beneficial. They enable quick lookups, which is essential for maintaining performance as your data grows.\n• None Composite Indexes: Consider creating composite indexes for queries that filter or sort by multiple columns. For example, if you often search for students by both and , an index on both columns can optimize such queries.\n\nWhile indexes provide significant advantages, there are some potential downsides:\n• None Slower Insert/Update Operations: When you insert or update records in a table with indexes, SQLite must also update the index, which can slow down these operations. This is because each insert or update requires additional overhead to maintain the index structure.\n• None Increased Storage Requirements: Indexes consume additional disk space. For large tables, the storage cost can be substantial. Consider this when designing your database schema, especially for systems with limited storage resources.\n• None Complex Index Management: Having too many indexes can complicate database management. It may lead to situations where you have redundant indexes, which can degrade performance rather than enhance it. Regularly reviewing and optimizing your indexes is a good practice.\n\nIndexes are powerful tools for optimizing database queries, but they require careful consideration. Striking a balance between improved read performance and the potential overhead on write operations is key. Here are some strategies for achieving this balance:\n• None Monitor Query Performance: Use SQLite’s to analyze how your queries perform with and without indexes. This can help identify which indexes are beneficial and which may be unnecessary.\n• None Regular Maintenance: Periodically review your indexes and assess whether they are still needed. Remove redundant or rarely used indexes to streamline your database operations.\n• None Test and Evaluate: Before implementing indexes in a production environment, conduct thorough testing to understand their impact on both read and write operations.\n\nBy following these best practices, you can leverage the benefits of indexing while minimizing potential drawbacks, ultimately enhancing the performance and efficiency of your SQLite database.\n\nHow to Handle Errors and Exceptions\n\nIn this section, we’ll discuss how to handle errors and exceptions when working with SQLite in Python. Proper error handling is crucial for maintaining the integrity of your database and ensuring that your application behaves predictably.\n\nWhen interacting with an SQLite database, several common errors may arise:\n• None Constraint Violations: This occurs when you try to insert or update data that violates a database constraint, such as primary key uniqueness or foreign key constraints. For example, trying to insert a duplicate primary key will trigger an error.\n• None Data Type Mismatches: Attempting to insert data of the wrong type (for example, inserting a string where a number is expected) can lead to an error.\n• None Database Locked Errors: If a database is being written to by another process or connection, trying to access it can result in a \"database is locked\" error.\n• None Syntax Errors: Mistakes in your SQL syntax will result in errors when you try to execute your commands.\n\nHow to Use Python's Exception Handling\n\nPython’s built-in exception handling mechanisms ( and ) are essential for managing errors in SQLite operations. By using these constructs, you can catch exceptions and respond appropriately without crashing your program.\n\nHere’s a basic example of how to handle errors when inserting data into the database:\n\nIn this example:\n• None We catch , which is raised for violations like unique constraints.\n• None We catch for general database-related issues (like database locked errors).\n• None We also have a generic block to handle any unexpected exceptions.\n• None Use Transactions: Always use transactions (as discussed in the previous section) when performing multiple related operations. This helps ensure that either all operations succeed or none do, maintaining consistency.\n• None Validate Input Data: Before executing SQL commands, validate the input data to ensure it meets the expected criteria (for example, correct types, within allowable ranges).\n• None Catch Specific Exceptions: Always catch specific exceptions to handle different types of errors appropriately. This allows for clearer error handling and debugging.\n• None Log Errors: Instead of just printing errors to the console, consider logging them to a file or monitoring system. This will help you track issues in production.\n• None Graceful Degradation: Design your application to handle errors gracefully. If an operation fails, provide meaningful feedback to the user rather than crashing the application.\n• None Regularly Backup Data: Regularly back up your database to prevent data loss in case of critical failures or corruption.\n• None Use Prepared Statements: Prepared statements help prevent SQL injection attacks and can also provide better performance for repeated queries.\n\nHow to Export and Import Data [Bonus Section]\n\nIn this section, we will learn how to export data from an SQLite database to common formats like CSV and JSON, as well as how to import data into SQLite from these formats using Python. This is useful for data sharing, backup, and integration with other applications.\n\nExporting data to a CSV (Comma-Separated Values) file is straightforward with Python’s built-in libraries. CSV files are widely used for data storage and exchange, making them a convenient format for exporting data.\n\nHere’s how to export data from an SQLite table to a CSV file:\n\nHow to Export Data to JSON\n\nSimilarly, you can export data to a JSON (JavaScript Object Notation) file, which is a popular format for data interchange, especially in web applications.\n\nHere’s an example of how to export data to JSON:\n\nHow to Import Data into SQLite from CSV\n\nYou can also import data from a CSV file into an SQLite database. This is useful for populating your database with existing datasets.\n\nHere's how to import data from a CSV file:\n\nHow to Import Data into SQLite from JSON\n\nSimilarly, importing data from a JSON file is simple. You can read the JSON file and insert the data into your SQLite table.\n\nHere's how to do it:\n\nAnd that’s a wrap! This guide has introduced you to the fundamentals of working with SQLite in Python, covering everything from setting up your environment to querying and manipulating data, as well as exporting and importing information. I hope you found it helpful and that it has sparked your interest in using SQLite for your projects.\n\nNow it's time to put your newfound knowledge into practice! I encourage you to create your project using SQLite and Python. Whether it’s a simple application for managing your library, a budgeting tool, or something unique, the possibilities are endless.\n\nOnce you’ve completed your project, share it on Twitter and tag me! I’d love to see what you’ve created and celebrate your accomplishments.\n\nYou can find all the code from this tutorial on GitHub. Thank you for following along, and happy coding!"
    },
    {
        "link": "https://pythonforthelab.com/blog/storing-data-with-sqlite",
        "document": "Using databases for storing data may sound much more complicated than what it actually is. In this article, we are going to cover how to use databases to store different types of data. We will quickly review how you can search for specific parameters and how to get exactly what you want.\n\nIn the previous articles, we have seen how to store data into plain text files, which is nothing more than a particular way of serializing our objects. On the second release, we have seen how to serialize complex objects using Python's built-in tools to save them as binary files. In this article, we are going to explore another very useful module called SQLite which will allow us to store data in databases.\n\nMost likely you have heard about databases in the context of websites. It is where your username, email, and password are stored. It is where the government saves all the information it has about you. However, databases can also be used for smaller scale projects, such as a software for controlling devices in the laboratory or for data analysis.\n\nThe simplest form of a database can be thought as a table with columns and rows. If you have ever used a spreadsheet, it looks exactly like that. Pandas' Data Frames have the same format. Tables with a header for each column and a different entry on each row. This really forces you to be systematic in the way in which you store your information.\n\nInteracting with databases is a complex subject because it normally involves learning a new scripting language in order to store and retrieve information. In this tutorial, you are going to learn the basics of one of these languages called SQL. Just with the basics, there is a lot that you can achieve.\n\nSomething important to point out is that normally you need to install more software in order to use a database. If you have ever heard of MySQL or Postgres, you are probably aware that those are big libraries that need an entire course on themselves. However, Python bundles SQLite, a very simple, single-file database. No extra software needed to run the examples here.\n\nLet's start quickly with SQLite. The first thing you need to do to work with databases is to create the database itself. In the case of SQLite, this is going to be a file. It is as easy as this:\n\nWhen you use , SQLite will try to open the file that you are specifying and if it doesn't exist, it will create a new one. Once you have the database, you need to create a table in it. This is where the SQL language that I mentioned before comes into play. Let's assume you want to create a table that stores two variables, the description of an experiment and the name of the person who performed it. You would do the following:\n\nAfter opening (or creating) the database, we have to create a cursor. The cursor is going to allow you to execute the SQL code. To create a table, we need to use the following command:\n\nIt is quite descriptive: you are creating a table called experiments with two columns: and . Each one of those columns will be of type . Don't worry too much about it right now. The command saves the changes to the database and then you close the connection. Congratulations, you have created your first table!\n\nThe problem right now is that there is no feedback on what you have done. If you are using PyCharm, for example, it comes with a built-in SQLite implementation. Therefore, you can just click on the file and you will be able to navigate through the contents of the database. You can also try an application like SQLite browser to visualize the files. There is also a Firefox Add-On.\n\nNow that you have a database, is time to store some data into it. All the examples always start by creating a connection and a cursor, which we are going to skip from now on, but you should include in your code. Adding information to a database also involves the use of SQL. You will need to do the following:\n\nYou can run this command as many times as you want, and if you are checking your database with an external tool, you will see that you keep adding rows to the table. As you see above, the SQL code can give rise to problems if you are using variables instead of plain text.\n\nImagine that you try to save a string that includes the character . SQL will think that the from your variable is actually closing the argument and it will give an error. Even worse, if it is a variable submitted by someone else, this can give rise to something called SQL injection. In the same way, in which Pickle can be used to run arbitrary code, SQL can be tricked to perform unwanted operations. Soon enough you will be able to understand the XKCD SQL injection joke.\n\nA proper way of adding new values to a table is:\n\nAssuming that the access to the database is only yours, i.e. you are not going to take variables from the public, you shouldn't worry too much about safety. In any case, it is important to be aware.\n\nNow that you have some data stored in the database, we need to be able to retrieve it. You can do the following:\n\nThe first line is asking for all the columns from experiments. That is what the means. The second line is actually getting the values. We have used , but you could have also used to get just one element.\n\nSo far, nothing particularly special. Imagine that you want to get only the entries where a particular user was involved. You can do the following:\n\nOf course, it can also happen that there are no entries matching your criteria and therefore the result is going to be an empty list. Again, remember that what we are looking for, may be a variable, and again you are exposed to SQL errors if you have special characters.\n\nAt this point, there are two concerns that may have come up to your mind. On one hand, there is no way to refer to specific entries in the database. Two different entries, with the same content, are indistinguishable from each other.\n\nThe other is more of a feature request. Imagine that you would like to store more information about the user, not just the name. It doesn't make sense to add extra columns to the experiments database, because we would be duplicating a lot of information. Ideally, we would start a new table, just to register users and their information.\n\nIf you have ever seen any spreadsheet program or even a Pandas Data Frame, you have probably noticed that every row is identified with a number. This is very handy because once you learn that the important information is on line N, you just remember that number and retrieve the data specifically.\n\nThe table that we have created does not include this numbering, also known as a primary key. Adding a new column is normally not a problem, but since we are dealing with a primary key, SQLite does not allow us to do it in a single step. We should create a new table, copy the contents of the old one, etc. Since we only have toy data, we can start from scratch.\n\nFirst, we will remove the table from the database, losing all its contents. Then we will create a new table, with its primary key and we will add some content to it. We can do everything with a very long SQL command instead of running multiple . For that, we use the triple-quote notation of Python:\n\nThe important part here is the SQL command. First, we drop the table if it exists. If it doesn't exist, it will throw an error and the rest of the code will not be executed. Then, we create a new table, with one new column called , of type integer. At the end of the statement, we defined that as the primary key of the table. Finally, we add two elements to the table.\n\nIf you run the retrieval code again, you will notice that each element has a unique number that identifies it. If we want to fetch the first (or the second, etc.) element, we can simply do the following:\n\nNotice that we are using instead of because we know that the output should be only one element. Check what is the difference if you use one or the other command in the data that you get from the database.\n\nAdding a primary key is fundamental to decrease the time it takes to fetch the data that you are looking for. Not only because it allows you to refer to specific entries, but also because of how databases work, it is much faster addressing data by their key.\n\nSo far we have used only two types of variables: and . The varchar has been used for the name of the person doing the experiment and its description, while the integer is used only for the number. However, we can develop much more complex tables. For example, we can specify not only the type but also limits to the length. We can also specify default values, simplifying the operations when storing new entries to a table. One of the advantages of doing this is that our data is going to be very consistent.\n\nImagine that you want to store also the date at which the experiment is run, you could add an extra field and every time you create a new experiment, you also add a field with the date, or you instruct the database to automatically add the date. At the moment of creating the table, you should do the following:\n\nNote the new field called , which uses as its type, and it also specifies a value. If you check the two inserted experiments (you can use the code of the previous example) you will see that there is a new field with the current date and time. You can also add default values for other fields, for example:\n\nNext time you add a new experiment, if you don't specify the user who performed it, it will default to (my name). Specifying defaults is a very useful way of avoiding missing information. For example, the will always be added. This ensures that even if someone forgets to explicitly declare the time of an experiment, at least a very reasonable assumption has been made.\n\nSQLite is different from other database managers, such as MySQL or Postgres because of its flexibility regarding data types and lengths. SQLite defines only 4 types of fields:\n• NULL. The value is a NULL value.\n• INTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.\n• REAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.\n• TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).\n• BLOB. The value is a blob of data, stored exactly as it was input.\n\nAnd then it defines something called affinities, which specifies the preferred type of data to be stored in a column. This is very useful to maintain compatibility with other database sources and can generate some headaches if you are following tutorials designed for other types of databases. The type we have used, is not one of the specified datatypes, but it is supported through the affinities. It will be treated as a field.\n\nThe way SQLite manages data types, if you are new to databases, is not important. If you are not new to databases, you should definitely look at the official documentation <https://www.sqlite.org/datatype3.html>_ in order to understand the differences and make the best out of the capabilities.\n\nPerhaps you have already heard about relational databases. So far, in the way we have used SQLite, it is hard to see advantages compared to plain CSV files, for example. If you are just storing a table, then you could perfectly do the same with a spreadsheet or a Pandas Data Frame. The power of databases is much more noticeable when you start making relationships between fields.\n\nIn the examples that we have discussed earlier, you have seen that when you run an experiment you would like to store who was to the user performing the measurement. The number of users is most likely going to be limited and perhaps you would like to keep track of some information, such as the name, email and phone number.\n\nThe way to organize all of this information is by creating a table in which you store the users. Each entry will have a primary key. From the table experiments, instead of storing the name of the user, you store the key of the user. Moreover, you can specify that, when creating a new experiment, the user associated with the experiment already exists. All this is achieved through the use of foreign keys, like this:\n\nFirst, you need to create a new user, for example:\n\nAnd then you can create a new experiment:\n\nNote that if you try to add an experiment with a user_id that does not exist, you will get an error:\n\nWhen you run the code above using Python, you will get the following message:\n\nWhich is exactly what we were expecting. Note, however, that if you leave the out, i.e., if you don't specify a value, it will default to , which is valid (an experiment without a user). If you would like to prevent this behavior, you will need to specify it explicitly:\n\nNow we have specified that the is . If we try to run the following code:\n\nIt will raise the following error:\n\nStoring complex data into databases is not a trivial task. Databases specify only some data types and numpy arrays are not between them. This means that we have to convert the arrays into something that can be stored in a database. Since SQLite specifies only 4 major data types, we should stick to one of them. In the previous article we have discussed a lot about serialization. The same ideas can be used to store an array in a database.\n\nFor example, you can use Pickle in order to transform your data into bytes and store them using base64 as a field. You could also store the Pickle object directly into a field. You can convert your array into a list and separate its values with or use a specific notation to separate rows and columns, etc. However, SQLite offers also the possibility of registering new data types. As explained in this answer on Stack Overflow we need to create an adapter and a converter:\n\nWhat we are doing in the code above is to tell SQLite what to do when a field of type is declared. When we are storing the field, it will be transformed into bytes, that can be stored as a BLOB in the database. When retrieving the data, we are going to read the bytes and transform them into a numpy array. Note that this is possible because the methods and know how to deal with bytes when saving/loading.\n\nIt is important to note that it is not necessary to register both adapter and converter. The first one is responsible for transforming a specific data type into an SQLite-compatible object. You could do this to automatically serialize your own classes, etc. The converter is responsible for converting back into your object. You can play around and see what happens when you don't register one of the two.\n\nWhen you define your table, you can use your newly created 'array' data type:\n\nIt is important to note that for the above code to work when you start the connection with the database, you should add the following:\n\nThe option is telling SQLite to use the registered adapters and converters. If you don't include that option, it will not use what you have registered and will default to the standard data types.\n\nTo store the array, you can do the following:\n\nThis will transform your array into bytes, and it will store it in the database. When you read it back, it will transform the Bytes back into an array.\n\nWhat you have to keep in mind is that when you store numpy arrays (or any non-standard object) into a database, you lose the intrinsic advantages of databases, i.e. the capabilities to operate on the elements. What I mean is that with SQL it is very easy to replace a field in all the entries that match a criterion, for example, but you won't be able to do that for a numpy array, at least with SQL commands.\n\nSo far, we have seen how to create some tables with values, and how to relate them through the use of primary and foreign keys. However, SQL is much more powerful than that, especially when retrieving information. One of the things that you can do is to join the information from different tables into a single table. Let's see quickly what can be done. First, we are going to re-create the tables with the experiments and the users, as we have seen before. You can check the code in here. You should have two entries for users and two entries for the experiments.\n\nYou can run the following code:\n\nWhat you will see printed is the id of the user, the name and the description of the experiment. This is much handier than just seeing the id of the user because you immediately see the information that you need. Moreover, you can filter the results based on the properties of either of the tables. Imagine you want to get the experiments performed by , but you don't know its user id. You can change the command above to the following:\n\nAnd you will see that only the data related to that user is retrieved.\n\nJoin statements are complex and very flexible. You probably noticed that we have used the option, but it is not the only possibility. If you want to combine tables that are not related through a foreign key, for example, you would like to combine data from different sources that belong to the same day, you can use other types of joins. The diagram in this website is very explicit, but going through the details exceeds the capabilities of an introductory tutorial.\n\nHow to Use Databases in Scientific Projects\n\nLeveraging the power of databases is not obvious for first-time developers, especially if you don't belong to the web-development realm. One of the main advantages of databases is that you don't need to keep in memory the entire structure. For example, Imagine that you would have a very large project, with millions of measurements of thousands of experiments with hundreds of users. Most likely you can't load all the information as in memory variables.\n\nBy using databases, you will be able to filter the measurements done by a specific user in a given time frame, or that match a specific description without actually loading everything into memory. Even if simple, this example already shows you a very clear use case where Data Frames or numpy arrays would fail.\n\nDatabases are used in many large-scale scientific projects, such as astronomical observations, simulations, etc. By using databases, different groups are able to give users access to filtering and joining capabilities, getting the desired data and not the entire collection. Of course, for small groups, it may look like an overshoot. But imagine that you could filter through your data, acquired during years, to find a specific measurement.\n\nOne of the main challenges of using databases is that they require learning a new language called SQL. In this article we have tried to point to the most basic concepts, that would allow anyone to get started and build his/her way up through clever Google searches.\n\nPython has built-in support for SQLite, a file-based database that is ideal for getting started. There is no further setting up involved, everything works out of the box, and many of the tutorials that can be found online relating to SQL will also work with SQLite.\n\nUsing databases for one-off projects may be an overkill, but for long-running programs, such as software for controlling setups or custom data analysis it may open the door to very creative solutions. Combining databases for metadata and files for data has the added advantage of a high portability (sharing data is sharing just a file) and an easy way to search through the collection of metadata stored onto a database."
    },
    {
        "link": "https://medium.com/analytics-vidhya/programming-with-databases-in-python-using-sqlite-4cecbef51ab9",
        "document": "If you are aspiring to be a data scientist you are going to be working with a lot of Data. Much of the data resides in Databases and hence you should be comfortable accessing data from databases through queries and then working on them to find key insights.\n\nData forms an integral part of the lives of Data Scientists. From the number of passengers in an airport to the count of stationary in a bookshop, everything is recorded today in form of digital files called databases. Databases are nothing more than electronic lists of information. Some databases are simple, and designed for smaller tasks while others are powerful, and designed for big data. All of them, however, have the same commonalities and perform a similar function. Different database tools store that information in unique ways. Flat files use a table, SQL databases use a relational model and NoSQL databases use a key-value model.\n\nIn this article, we will focus only on the Relational Databases and accessing them in Python. We will begin by having a quick overview of the Relational databases and their important constituents."
    },
    {
        "link": "https://stackoverflow.com/questions/1725880/best-practices-for-sqlite-db-and-contentprovider",
        "document": "My Android app is reading and writing to a local SQLite DB from a few different Activities and a Service. Pretty standard. But I'm not happy with the way I've got all the DB details stored as constants that I then use anywhere I access the DB. I've been advised to wrap the DB in a ContentProvider. Sounds good to me. While I'm refactoring my code, I figured I'd ask:\n• What are your best practices for local DB data storage in Android?\n• Where and how do you store \"CREATE TABLE\" statements, column names, other SQL?\n• Would you mind sharing a list of the classes you instantiate and what goes into each (ContentProvider, DatabaseProvider, DatabaseHelper...)?\n• How do you coordinate the structure of your local Android DB with a server-side DB available through a REST interface?\n\nYeah, I realize I'm getting at the perennial \"where's the Android object-relation-mapping framework?\" question. For now, I'm mainly curious to hear how you structure your Android apps with what's available in the standard SDK.\n\nAs always, thanks for the pointers!"
    },
    {
        "link": "https://github.com/marcpaulo15/GPS_TelegramBot",
        "document": "Welcome to this friendly guide to building a GPS-based Telegram bot! At its core, this Bot serves as a user-friendly GPS assistant on the Telegram platform. It empowers users to effortlessly navigate from one point to another within their current cities, all while maintaining a warm and conversational interaction.\n\nThis project also serves as a tutorial, guiding aspiring developers in the art of creating their very own GPS bots :)\n• : This file, providing an overview of the project.\n• : Configuration file to set the plotting parameters: colors, icons, etc.\n• : Contains the icons (images) displayed in the maps to highlight relevant locations.\n• : Contains the images used in this README file.\n• : Contains the list of Python libraries (and their versions) needed to work on this project.\n• : Your Bot's token (created by the BotFather).\n• : Contains the images that describe each route. These images are sent to the user.\n• : OpenStreetMap graphs that are saved to be loaded when needed (instead of downloaded every time).\n• : Contains the Python code. The three main modules are explained below.\n\nThis module defines a class for working with street network graphs using the library (OpenStreetMaps). It allows to download, save, and load OpenStreet Maps of different cities.\n\nThis module computes the shortest route between two points in the same city and displays the route on a map. The route is split into legs which are represented as a dictionary with the following format: (a route is represented as a sequence of legs)\n\nThe colors and line widths of the map can be customized through the file. Here is an example of the different legs (segments from one checkpoint to the next one) of a route in the city of Barcelona (Spain).\n\nThis module uses the Telegram API to serve as a GPS Telegram Bot that will guide you wherever you want. This module uses a Guide instance to compute routes between points. It preprocesses the route to create meaningful messages that will guide users to their final destination. The messages are sent depending on the users' location in real-time.\n• Search for the @Botfather in your Telegram app\n• Enter the new bot’s name (e.g. )\n• Get bot’s API Token, and save it in a file. Then, we will use this token to initialize your bot using Python.\n• [OPTIONAL] Change the profile photo of your Bot.\n• Type the command to start the conversation.\n• Type the command to know what can you do with this Bot.\n• Share your location with the Bot. If done correctly, you will receive a confirmation message.\n• Type the command to know where you are: city, street name, etc.\n• If you call the command without sharing your location, the Bot will ask you to share your location first.\n• Type the command, followed by the destination you want to reach (like ).\n• You don't have to specify the city since the Bot already knows it from the location you are sharing.\n• If you call the command without any destination (empty destination), the Bot will ask you to enter a destination.\n• If you call the command without sharing your location, the Bot will ask you to share your location first.\n• If you call the command with an unreachable destination, the Bot will ask you to try another one.\n• Type the command to cancel your ongoing route.\n• If you don't have any ongoing route, the Bot will let you know it.\n• If the Bot detects that you are moving away from the route, the Bot will send you a warning message.\n\nFirst, please make sure you have Python installed.\n\nBefore installing the Python libraries used in this project, you may want to create a Python Virtual Environment (venv), to avoid problems if you are working on other projects as well.\n\nThe Python Libraries used in this project are listed in the file. There you will find the Python libraries and their versions. You may use a package manager called to install them. If is not installed, you need to install it. If you have Python 3.4 or newer, pip should come pre-installed.\n\nCreate and activate your Python Virtual Environment. Then run the following command to install the libraries listed in your requirements.txt file:\n\nTo activate the Bot, run the following command in your project directory:\n\nThen, you can interact with your Bot through the Telegram App (mobile or desktop)\n\nThe Haversine library is a Python package designed to calculate the distance between two points on the Earth given their latitude and longitude. The library is handy for applications that involve geospatial calculations, such as determining distances between locations. It uses the haversine formula to compute distances. The library supports various units for distance measurement, such as kilometers, miles, nautical miles, and meters.\n\nThe NetworkX library is a powerful Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks (a.k.a. graphs). Networks, in this context, are mathematical representations of relationships between a set of objects, and they are widely used in various fields such as social network analysis, biological network analysis, transportation networks, and more.\n\nThe library includes a wide range of algorithms for analyzing graphs, including algorithms for finding paths, clustering coefficients, centrality measures, and community detection. It also allows for the visualization of graphs, providing tools to create clear and informative visual representations of network structures.\n\nOSMnx is a Python library for retrieving, modeling, analyzing, and visualizing street networks from OpenStreetMap (OSM) data. It simplifies the process of working with spatial and network data related to urban planning, transportation, and geography. This library allows users to download and construct street networks from OpenStreetMap data by specifying a bounding box or by providing other location information. The library provides a NetworkX graph representation of the street network, making it compatible with various network analysis tools (like the ```NetworkX`` library)\n\nA small, python-based library for creating map images with lines and markers. StaticMap is open source and licensed under Apache License, Version 2.0.\n\nThe GeoPy library is a Python client for several popular geocoding web services. Geocoding is the process of converting addresses (like \"1600 Amphitheatre Parkway, Mountain View, CA\") into geographic coordinates (like latitude 37.423021 and longitude -122.083739), which can then be used for mapping or other location-based applications.\n\nFor interacting with the Telegram API in Python, the python-telegram-bot library is commonly used. This library provides a convenient interface for working with the Telegram Bot API, allowing you to create and manage Telegram bots. The library facilitates the creation of Telegram bots, allowing developers to handle messages,and process commands and updates. The library supports sending and receiving files, location, photos, videos, and other media types.\n\n\"Yet Another Markup Language\" (YAML) is a human-readable data serialization format. It's often used for configuration files, data exchange between languages with different data structures, and in various applications where data needs to be stored, transmitted, or configured in a human-readable format. YAML's design aims to be simple and easy for both humans to read and write and for machines to parse and generate.\n\nThis Bot does not store the personal information of the user and does not track the location of the user.\n\nEvery piece of information collected while the Bot is running is intended to be used just to make the bot work properly, not to leave the local environment and be used for other purposes outside the scope of this project.\n\nContributions to this project are welcome! If you'd like to improve the game, fix bugs, or add new features, feel free to fork the repository and submit a pull request.\n\nThis project is licensed under the Apache-2.0 License. See the LICENSE file for details."
    },
    {
        "link": "https://medium.com/@moraneus/building-telegram-bot-with-python-telegram-bot-a-comprehensive-guide-7e33f014dc79",
        "document": "Creating a Telegram bot can significantly extend the functionality of your messaging experience, allowing for everything from automated responses to sophisticated interactions. This comprehensive guide will walk you through the process of building a basic Telegram bot with Python, incorporating user commands, message handling, and custom keyboards. We’ll use the library for its simplicity and powerful features.\n\nIn this article, I will demonstrate a very simple Car Sales Listing Bot that is designed to streamline the process of gathering some necessary information from users wishing to list their cars for sale. By engaging in a structured conversation, the bot collects details such as the car’s type, color, and mileage, and even allows for photo uploads, culminating in a summary that confirms the listing’s details.\n• Ability to upload a photo of the car.\n• Summary of the listing details for confirmation.\n• Create Your Bot: Open Telegram and search for the “BotFather” account. Start a conversation and use the command to create a new bot. Follow the prompts to set up your bot's name and username. BotFather will then give you a token, which is crucial for accessing the Telegram Bot API. Keep this token secure and do not share it.\n\nNow, let’s dive into coding your bot. Please create a new Python file, e.g., and open it in your favorite text editor. Then, follow these steps to write your bot.\n\nStart by importing necessary modules and setting up logging to help with debugging:\n\nStates in a Telegram bot, especially when using a conversation handler, serve as a framework to manage the flow of interaction between the bot and the user. They are essentially markers or checkpoints that define what part of the conversation the user is currently engaged with and determine what the bot should do next based on the user’s input. Here’s a more general overview of the role and functionality of states in managing bot conversations. The purpose and functionality of states in the Telegram bot are:\n• Sequential Flow Management: States allow the bot to manage a sequential flow of conversation. By moving from one state to another, the bot can guide the user through a series of steps, questions, or options in a logical order.\n• Context Awareness: They help the bot maintain context in a conversation. By knowing the current state, the bot understands what information has been provided by the user and what information is still needed, enabling it to respond appropriately.\n• User Input Processing: Based on the current state, the bot can process user inputs differently. For example, an input in the “CAR_TYPE” state would be understood as the user specifying the type of car they’re selling, while the same input in the “CAR_COLOR” state would be interpreted as the color of the car.\n• Conditional Logic Implementation: States allow for the implementation of conditional logic in the conversation. Depending on user responses or choices, the bot can decide to skip certain states, repeat them, or take the user down a different conversational path.\n• Error Handling and Repetition: They facilitate error handling and the repetition of questions if the user provides unexpected or invalid responses. By keeping track of the current state, the bot can re-prompt the user for information correctly.\n• State Persistence: In more complex bots, states can be stored and persisted across sessions, allowing users to pick up the conversation where they left off, even if they temporarily leave the chat or if the bot restarts.\n\nLet’s enumerate the states for our bot to manage the flow:\n\nConversation handlers in Telegram bots, particularly when using libraries like , are powerful tools that manage the flow of conversations based on user inputs and predefined states. They are crucial for developing bots that require a sequence of interactions, such as collecting information, guiding users through menus, or executing commands in a specific order. Here's a closer look at how conversation handlers work and their role in bot development:\n• Managing Conversational States: Conversation handlers keep track of the current state of the dialogue with each user. They determine what the bot should do next based on the user’s input and the current state, allowing for a smooth and logical progression through different stages of interaction.\n• Routing User Inputs: They route user inputs to different callback functions based on the current state. This means that the same input can lead to different outcomes depending on where the user is in the conversation flow.\n• Handling Commands and Text: Conversation handlers can differentiate between commands (like or ) and regular text messages, allowing developers to specify distinct responses or actions for each type of input.\n• Integrating with Keyboards and Buttons: They work seamlessly with custom keyboards and inline buttons, enabling developers to create interactive and user-friendly interfaces within the conversation. Users can select options or navigate through the bot’s features using these UI elements.\n• Fallbacks and Timeouts: Conversation handlers support fallback functions, which can be triggered when the user sends unexpected input or when the conversation needs to be reset. They can also handle timeouts, ending a conversation automatically after a period of inactivity.\n• Entry Points: These are triggers that start the conversation. Commonly, the command is used as an entry point, but you can define multiple entry points for different conversation flows.\n• States: As discussed, states represent different points in the conversation. Each state is associated with one or more callback functions that define the bot’s behavior at that stage. Developers map states to these callbacks, dictating the flow of the conversation.\n• Fallbacks: Fallback functions are defined to handle unexpected situations or to provide a way to exit or reset the conversation. A common fallback is a command that allows users to stop the conversation at any point.\n\nFollowing, is the handler function initiates the conversation (entry point), presenting the user with a selection of car types:\n\nHere you can find the rest of the handlers:\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sport\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\nIn the function, set up the and , including entry points, states, and fallbacks. Start the bot with polling to listen for updates:\n\nComplete your script with a call to the function. Run your bot by executing the Python script in your terminal.\n\nHere you can find the whole code:\n\nimport logging\n\nfrom telegram import (ReplyKeyboardMarkup, ReplyKeyboardRemove, Update,\n\n InlineKeyboardButton, InlineKeyboardMarkup)\n\nfrom telegram.ext import (Application, CallbackQueryHandler, CommandHandler,\n\n ContextTypes, ConversationHandler, MessageHandler, filters)\n\n\n\n# Enable logging\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\n level=logging.INFO)\n\n\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Define states\n\nCAR_TYPE, CAR_COLOR, CAR_MILEAGE_DECISION, CAR_MILEAGE, PHOTO, SUMMARY = range(6)\n\n\n\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Starts the conversation and asks the user about their preferred car type.\"\"\"\n\n reply_keyboard = [['Sedan', 'SUV', 'Sports', 'Electric']]\n\n\n\n await update.message.reply_text(\n\n '<b>Welcome to the Car Sales Listing Bot!\n\n'\n\n 'Let\\'s get some details about the car you\\'re selling.\n\n'\n\n 'What is your car type?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True, resize_keyboard=True),\n\n )\n\n\n\n return CAR_TYPE\n\n\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sports\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\n\n\n\n\ndef main() -> None:\n\n \"\"\"Run the bot.\"\"\"\n\n application = Application.builder().token(\"YOUR TOKEN HERE\").build()\n\n\n\n conv_handler = ConversationHandler(\n\n entry_points=[CommandHandler('start', start)],\n\n states={\n\n CAR_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_type)],\n\n CAR_COLOR: [CallbackQueryHandler(car_color)],\n\n CAR_MILEAGE_DECISION: [CallbackQueryHandler(car_mileage_decision)],\n\n CAR_MILEAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_mileage)],\n\n PHOTO: [\n\n MessageHandler(filters.PHOTO, photo),\n\n CommandHandler('skip', skip_photo)\n\n ],\n\n SUMMARY: [MessageHandler(filters.ALL, summary)]\n\n },\n\n fallbacks=[CommandHandler('cancel', cancel)],\n\n )\n\n\n\n application.add_handler(conv_handler)\n\n\n\n # Handle the case when a user sends /start but they're not in a conversation\n\n application.add_handler(CommandHandler('start', start))\n\n\n\n application.run_polling()\n\n\n\n\n\nif __name__ == '__main__':\n\n main()\n\nStep 3: Testing and Interacting with Your Bot\n\nAfter running your script, find your bot on Telegram and start interacting with it. You should now be able to use the command to start a conversation, which will guide you through listing a car for sale."
    },
    {
        "link": "https://stackoverflow.com/questions/43424621/telegram-bot-location-python",
        "document": "You need to do the following:\n\nCall function with the following params:"
    },
    {
        "link": "https://docs.python-telegram-bot.org",
        "document": "We have made you a wrapper you can’t refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nYou can install or upgrade via To install a pre-release, use the flag in addition. You can also install from source, though this is usually not necessary. To enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures. Starting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value . Earlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format . In addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix . tries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don’t need the optional features. The only required dependency is httpx ~= 0.27 for , the default networking backend. is most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out. PTB can be installed with optional dependencies:\n• None installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• None installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• None installs httpx[http2]. Use this, if you want to use HTTP/2.\n• None installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• None installs the tornado~=6.4 library. Use this, if you want to use / .\n• None installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• None installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the . To install multiple optional dependencies, separate them by commas, e.g. .\n• None installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let’s get started! Our Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• None The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• None The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• None Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• None The official Telegram Bot API documentation is of course always worth a read. If the resources mentioned above don’t answer your questions or simply overwhelm you, there are several ways of getting help.\n• None We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• None You can even ask for help on Stack Overflow using the python-telegram-bot tag. Since v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• None all classes in the module that allow to add/remove allowed users/chats at runtime\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don’t have to be."
    },
    {
        "link": "https://geeksforgeeks.org/create-a-telegram-bot-using-python",
        "document": "In this article, we are going to see how to create a telegram bot using Python.\n\nIn recent times Telegram has become one of the most used messaging and content sharing platforms, it has no file sharing limit like Whatsapp and it comes with some preinstalled bots one can use in any channels (groups in case of whatsapp) to control the behavior or filter the spam messages sent by users.\n• A Telegram Account: If you don’t have the Telegram app installed just download it from the play store. After downloading create an account using your mobile number just like WhatsApp.\n• .python-telegram-bot module: Here we will need a module called python-telegram-bot, This library provides a pure Python interface for the Telegram Bot API. It’s compatible with Python versions 3.6.8+. In addition to the pure API implementation, this library features a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the “telegram.ext” submodule. For more information, you can check their official GitHub repo.\n\nWe can install this module via pip and conda with the below command.\n\nSteps to create your first bot\n\nStep 1: After opening an account on Telegram, in the search bar at the top search for “BotFather”\n\nStep 2: Click on the ‘BotFather’ (first result) and type /newbot\n\nStep 3: Give a unique name to your bot. After naming it, Botfather will ask for its username. Then also give a unique name BUT remember the username of your bot must end with the bot, like my_bot, hellobot etc.\n\nStep 4: After giving a unique name and if it gets accepted you will get a message something like this –\n\nHere the token value will be different for you, we will use this token in our python code to make changes in our bot and make it just like we want, and add some commands in it.\n\nBrief usage of the functions we are importing:\n• Updater: This will contain the API key we got from BotFather to specify in which bot we are adding functionalities to using our python code.\n• Update: This will invoke every time a bot receives an update i.e. message or command and will send the user a message.\n• CallbackContext: We will not use its functionality directly in our code but when we will be adding the dispatcher it is required (and it will work internally)\n• CommandHandler: This Handler class is used to handle any command sent by the user to the bot, a command always starts with “/” i.e “/start”,”/help” etc.\n• MessageHandler: This Handler class is used to handle any normal message sent by the user to the bot,\n• FIlters: This will filter normal text, commands, images, etc from a sent message.\n\nStart function: It will display the first conversation, you may name it something else but the message inside it will be sent to the user whenever they press ‘start’ at the very beginning.\n\nBasically, in the start message, you should add something like “Hello Welcome to the Bot” etc.\n\nHelp function: It is basically in this function you should add any kind of help the user might need, i.e. All the commands your bot understands, The information related to the bot, etc)\n\nAdding some more functionalities to the Bot.\n\nHere we have added 4 functions one to open Gmail, one for youtube, one for LinkedIn, and the last one for GeeksforGeeks. These are not MANDATORY functions, you can add any kind of functions and their reply_text as you want, these are just for demonstration. Here the unknown_text function will send the message written inside it whenever it gets some unknown messages and the unknown function will Filter out all the unknown commands sent by the user and reply to the message written inside it.\n\nStep 3: Adding the Handlers to handle our messages and commands\n\nHere each line suggests that whenever a user writes a command i.e. the first parameter of the CommandHandler in reply the user gets the message written inside the function mentioned in the next parameter.\n\nHere whenever we start polling the bot will be active and it will look for any new message sent by any of the users and if it matches the command specified there it will reply accordingly.\n\nBelow is the full implementation:"
    }
]