[
    {
        "link": "https://doc.qt.io/qt-6/qpainter.html",
        "document": "The QPainter class performs low-level painting on widgets and other paint devices. More...\n\nNote: All functions in this class are reentrant.\n\nThis list gives an indication of which features to safely use in an application where performance is critical. For certain setups, other operations may be fast too, but before making extensive use of them, it is recommended to benchmark and verify them on the system where the software will run in the end. There are also cases where expensive operations are ok to use, for instance when the result is cached in a QPixmap .\n\nThe backends we focus on as high-performance engines are:\n\nQPainter is a rich framework that allows developers to do a great variety of graphical operations, such as gradients, composition modes and vector graphics. And QPainter can do this across a variety of different hardware and software stacks. Naturally the underlying combination of hardware and software has some implications for performance, and ensuring that every single operation is fast in combination with all the various combinations of composition modes, brushes, clipping, transformation, etc, is close to an impossible task because of the number of permutations. As a compromise we have selected a subset of the QPainter API and backends, where performance is guaranteed to be as good as we can sensibly get it for the given combination of hardware and software.\n\nThe outlines generated by Qt's stroker are only an approximation when dealing with curved shapes. It is in most cases impossible to represent the outline of a bezier curve segment using another bezier curve segment, and so Qt approximates the curve outlines by using several smaller curves. For performance reasons there is a limit to how many curves Qt uses for these outlines, and thus when using large pen widths or scales the outline error increases. To generate outlines with smaller errors it is possible to use the QPainterPathStroker class, which has the setCurveThreshold member function which let's the user specify the error tolerance. Another workaround is to convert the paths to polygons first and then draw the polygons instead.\n\nIf you are using coordinates with Qt's raster-based paint engine, it is important to note that, while coordinates greater than +/- 2 15 can be used, any painting performed with coordinates outside this range is not guaranteed to be shown; the drawing may be clipped. This is due to the use of short int in the implementation.\n\nThe Composition Modes example, available in Qt's examples directory, allows you to experiment with the various composition modes and see the results immediately.\n\nNote that composition transformation operates pixelwise. For that reason, there is a difference between using the graphic primitive itself and its bounding rectangle: The bounding rect contains pixels with alpha == 0 (i.e the pixels surrounding the primitive). These pixels will overwrite the other image's pixels, effectively clearing those, while the primitive only overwrites its own area.\n\nThe two most common forms of composition are Source and SourceOver . Source is used to draw opaque objects onto a paint device. In this mode, each pixel in the source replaces the corresponding pixel in the destination. In SourceOver composition mode, the source object is transparent and is drawn on top of the destination.\n\nQPainter provides the CompositionMode enum which defines the Porter-Duff rules for digital image compositing; it describes a model for combining the pixels in one image, the source, with the pixels in another image, the destination.\n\nAfter QPainter's clipping, the paint device may also clip. For example, most widgets clip away the pixels used by child widgets, and most printers clip away an area near the edges of the paper. This additional clipping is not reflected by the return value of clipRegion () or hasClipping ().\n\nQPainter can clip any drawing operation to a rectangle, a region, or a vector path. The current clip is available using the functions clipRegion () and clipPath (). Whether paths or regions are preferred (faster) depends on the underlying paintEngine (). For example, the QImage paint engine prefers paths while the X11 paint engine prefers regions. Setting a clip is done in the painters logical coordinates.\n\nWhen drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's combinedTransform (), a combination of viewport () and window () and worldTransform (). The viewport () represents the physical coordinates specifying an arbitrary rectangle, the window () describes the same rectangle in logical coordinates, and the worldTransform () is identical with the transformation matrix.\n\nThe setWorldTransform () function can replace or add to the currently set worldTransform (). The resetTransform () function resets any transformations that were made using translate (), scale (), shear (), rotate (), setWorldTransform (), setViewport () and setWindow () functions. The deviceTransform () returns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device. The latter function is only needed when using platform painting commands on the platform dependent handle, and the platform does not do transformations nativly.\n\nAll the transformation operations operate on the transformation worldTransform (). A matrix transforms a point in the plane to another point. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe Affine Transformations example shows Qt's ability to perform affine transformations on painting operations. The demo also allows the user to experiment with the transformation operations and see the results immediately.\n\nSee also the Transformations example which shows how transformations influence the way that QPainter renders graphics primitives. In particular it shows how the order of transformations affects the result.\n\nThe most commonly used transformations are scaling, rotation, translation and shearing. Use the scale () function to scale the coordinate system by a given offset, the rotate () function to rotate it clockwise and translate () to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the shear () function. See the Affine Transformations example for a visualization of a sheared coordinate system.\n\nNormally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformations.\n\nThe renderHints () function returns a flag that specifies the rendering hints that are set for this painter. Use the setRenderHint () function to set or clear the currently set RenderHints .\n\nThe RenderHint enum specifies flags to QPainter that may or may not be respected by any given engine. QPainter::Antialiasing indicates that the engine should antialias edges of primitives if possible, QPainter::TextAntialiasing indicates that the engine should antialias text if possible, and the QPainter::SmoothPixmapTransform indicates that the engine should use a smooth pixmap transformation algorithm.\n\nThese are often used in combination with the QPainter::Antialiasing render hint.\n\nThe QPainter class also provides a means of controlling the rendering quality through its RenderHint enum and the support for floating point precision: All the functions for drawing primitives have floating point versions.\n\nTo get the optimal rendering result using QPainter, you should use the platform independent QImage as paint device; i.e. using QImage will ensure that the result has an identical pixel representation on any platform.\n\nThis is for example the case when drawing a QPixmap of 64x64 pixels size with a device pixel ratio of 2 onto a high DPI screen which also has a device pixel ratio of 2. Note that the pixmap is then effectively 32x32 pixels in user space . Code paths in Qt that calculate layout geometry based on the pixmap size will use this size. The net effect of this is that the pixmap is displayed as high DPI pixmap rather than a large pixmap.\n\nHigh resolution versions of pixmaps have a device pixel ratio value larger than 1 (see QImageReader , QPixmap::devicePixelRatio ()). Should it match the value of the underlying QPaintDevice , it is drawn directly onto the device with no additional transformation applied.\n\nThere is a drawPicture () function that draws the contents of an entire QPicture . The drawPicture () function is the only function that disregards all the painter's settings as QPicture has its own settings.\n\nThere are functions to draw pixmaps/images, namely drawPixmap (), drawImage () and drawTiledPixmap (). Both drawPixmap () and drawImage () produce the same result, except that drawPixmap () is faster on-screen while drawImage () may be faster on a QPrinter or other devices.\n\nText drawing is done using drawText (). When you need fine-grained positioning, boundingRect () tells you where a given drawText () command will draw.\n\nSee also the Vector Deformation example which shows how to use advanced vector techniques to draw text using a QPainterPath , the Gradients example which shows the different types of gradients that are available in Qt, and the Path Stroking example which shows Qt's built-in dash patterns and shows how custom patterns can be used to extend the range of available patterns.\n\nQPainter also provides the fillPath () function which fills the given QPainterPath with the given QBrush , and the strokePath () function that draws the outline of the given path (i.e. strokes the path).\n\nThe Painter Paths example shows how painter paths can be used to build complex shapes for rendering.\n\nThe QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused.\n\nIf you need to draw a complex shape, especially if you need to do so repeatedly, consider creating a QPainterPath and drawing it using drawPath ().\n\nThe Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the QPainter class.\n\nAll of these functions have both integer and floating point versions.\n\nThe QPainter class also provides the fillRect () function which fills the given QRect , with the given QBrush , and the eraseRect () function that erases the area inside the given rectangle.\n\nQPainter provides functions to draw most primitives: drawPoint (), drawPoints (), drawLine (), drawRect (), drawRoundedRect (), drawEllipse (), drawArc (), drawPie (), drawChord (), drawPolyline (), drawPolygon (), drawConvexPolygon () and drawCubicBezier(). The two convenience functions, drawRects () and drawLines (), draw the given number of rectangles or lines in the given array of QRects or QLines using the current pen and brush.\n\nYou can at any time save the QPainter's state by calling the save () function which saves all the available settings on an internal stack. The restore () function pops them back.\n\nNote that some of these settings mirror settings in some paint devices, e.g. QWidget::font (). The QPainter::begin () function (or equivalently the QPainter constructor) copies these attributes from the paint device.\n\nThere are several settings that you can customize to make QPainter draw according to your preferences:\n\nWarning: When the paintdevice is a widget, QPainter can only be used inside a paintEvent() function or in a function called by paintEvent().\n\nSometimes it is desirable to make someone else paint on an unusual QPaintDevice . QPainter supports a static function to do this, setRedirected().\n\nTogether with the QPaintDevice and QPaintEngine classes, QPainter form the basis for Qt's paint system. QPainter is the class used to perform drawing operations. QPaintDevice represents a device that can be painted on using a QPainter. QPaintEngine provides the interface that the painter uses to draw onto different types of devices. If the painter is active, device () returns the paint device on which the painter paints, and paintEngine () returns the paint engine that the painter is currently operating on. For more information, see the Paint System .\n\nThe isActive () function indicates whether the painter is active. A painter is activated by the begin () function and the constructor that takes a QPaintDevice argument. The end () function, and the destructor, deactivates it.\n\nThe core functionality of QPainter is drawing, but the class also provide several functions that allows you to customize QPainter's settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter's composition mode.\n\nThe common use of QPainter is inside a widget's paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the QPainter object after drawing. For example:\n\nQPainter provides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a \"natural\" coordinate system, but it can also do view and world transformation. QPainter can operate on any object that inherits the QPaintDevice class.\n\nSee also QPaintDevice, QPaintEngine, Qt SVG, Basic Drawing Example, and Drawing Utility Functions.\n\nSee also renderHints (), setRenderHint (), and Rendering Quality .\n\nThe RenderHints type is a typedef for QFlags <RenderHint>. It stores an OR combination of RenderHint values.\n\nRenderhints are used to specify flags to QPainter that may or may not be respected by any given engine.\n\nSee also QPainter::drawPixmapFragments () and QPainter::PixmapFragment .\n\nThe PixmapFragmentHints type is a typedef for QFlags <PixmapFragmentHint>. It stores an OR combination of PixmapFragmentHint values.\n\nWhen a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.\n\nSeveral composition modes require an alpha channel in the source or target images to have an effect. For optimal performance the image format Format_ARGB32_Premultiplied is preferred.\n\nThe most common type is SourceOver (often referred to as just alpha blending) where the source pixel is blended on top of the destination pixel in such a way that the alpha component of the source defines the translucency of the pixel.\n\nPlease note that the bitwise raster operation modes, denoted with a RasterOp prefix, are only natively supported in the X11 and raster paint engines. This means that the only way to utilize these modes on the Mac is via a QImage . The RasterOp denoted blend modes are not supported for pens and brushes with alpha components. Also, turning on the QPainter::Antialiasing render hint will effectively disable the RasterOp modes.\n\nDefines the modes supported for digital image compositing. Composition modes are used to specify how the pixels in one image, the source, are merged with the pixel in another image, the destination.\n\nSee also begin() and end().\n\nThis constructor is convenient for short-lived painters, e.g. in a QWidget::paintEvent() and should be used only once. The constructor calls begin() for you and the QPainter destructor automatically calls end().\n\nHere's an example using begin() and end():\n\nThe same example using this constructor:\n\nSince the constructor cannot provide feedback when the initialization of the painter failed you should rather use begin() and end() to paint on external devices, e.g. printers.\n\nSee also begin() and end().\n\nSee also setBackground() and Settings.\n\nSee also setBackgroundMode() and Settings.\n\nBegins painting the paint device and returns if successful; otherwise returns .\n\nNotice that all painter settings (setPen(), setBrush() etc.) are reset to default values when begin() is called.\n\nThe errors that can occur are serious problems, such as these:\n\nNote that most of the time, you can use one of the constructors instead of begin(), and that end() is automatically done at destruction.\n\nSee also end() and QPainter().\n\nFlushes the painting pipeline and prepares for the user issuing commands directly to the underlying graphics context. Must be followed by a call to endNativePainting().\n\nNote that only the states the underlying paint engine changes will be reset to their respective default states. The states we reset may change from release to release. The following states are currently reset in the OpenGL 2 engine:\n• the depth, stencil and scissor tests are disabled\n• the active texture unit is reset to 0\n• the depth mask, depth function and the clear depth are reset to their default values\n• the stencil mask, stencil operation and stencil function are reset to their default values\n• the current color is reset to solid white\n\nIf, for example, the OpenGL polygon mode is changed by the user inside a beginNativePaint()/endNativePainting() block, it will not be reset to the default state by endNativePainting(). Here is an example that shows intermixing of painter commands and raw OpenGL commands:\n\nReturns the bounding rectangle of the text as it will appear when drawn inside the given rectangle with the specified flags using the currently set font(); i.e the function tells you where the drawText() function will draw when given the same arguments.\n\nIf the text does not fit within the given rectangle using the specified flags, the function returns the required rectangle.\n\nThe flags argument is a bitwise OR of the following flags:\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nSee also drawText(), Qt::Alignment, and Qt::TextFlag.\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the text as it will appear when drawn inside the given rectangle with the specified flags using the currently set font().\n\nThis is an overloaded function.\n\nInstead of specifying flags as a bitwise OR of the Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes an option argument. The QTextOption class provides a description of general rich text properties.\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the given text as it will appear when drawn inside the rectangle beginning at the point (x, y) with width w and height h.\n\nSee also QPainter::setBrush() and Settings.\n\nSee also setBrushOrigin() and Settings.\n\nReturns the bounding rectangle of the current clip if there is a clip; otherwise returns an empty rectangle. Note that the clip region is given in logical coordinates.\n\nThe bounding rectangle is not guaranteed to be tight.\n\nSee also setClipRect(), setClipPath(), and setClipRegion().\n\nSee also setClipPath(), clipRegion(), and setClipping().\n\nReturns the currently set clip region. Note that the clip region is given in logical coordinates.\n\nSee also setClipRegion(), clipPath(), and setClipping().\n\nReturns the transformation matrix combining the current window/viewport and world transformation.\n\nSee also setWorldTransform(), setWindow(), and setViewport().\n\nSee also CompositionMode and setCompositionMode().\n\nReturns the paint device on which this painter is currently painting, or if the painter is not active.\n\nReturns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device.\n\nThis function is only needed when using platform painting commands on the platform dependent handle (Qt::HANDLE), and the platform does not do transformations nativly.\n\nThe QPaintEngine::PaintEngineFeature enum can be queried to determine whether the platform performs the transformations or not.\n\nSee also worldTransform() and QPaintEngine::hasFeature().\n\nDraws the arc defined by the given rectangle, startAngle and spanAngle.\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawPie(), drawChord(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the arc defined by the given rectangle, startAngle and spanAngle.\n\nThis is an overloaded function.\n\nDraws the arc defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nDraws the chord defined by the given rectangle, startAngle and spanAngle. The chord is filled with the current brush().\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawArc(), drawPie(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the chord defined by the given rectangle, startAngle and spanAngle.\n\nThis is an overloaded function.\n\nDraws the chord defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nDraws the convex polygon defined by the first pointCount points in the array points using the current pen.\n\nThe first point is implicitly connected to the last point, and the polygon is filled with the current brush(). If the supplied polygon is not convex, i.e. it contains at least one angle larger than 180 degrees, the results are undefined.\n\nOn some platforms (e.g. X11), the drawConvexPolygon() function can be faster than the drawPolygon() function.\n\nSee also drawPolygon(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by polygon using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by polygon using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by the first pointCount points in the array points using the current pen.\n\nDraws the ellipse defined by the given rectangle.\n\nA filled ellipse has a size of rectangle.size(). A stroked ellipse has a size of rectangle.size() plus the pen width.\n\nSee also drawPie() and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the ellipse defined by the given rectangle.\n\nThis is an overloaded function.\n\nDraws the ellipse positioned at center with radii rx and ry.\n\nThis is an overloaded function.\n\nDraws the ellipse positioned at center with radii rx and ry.\n\nThis is an overloaded function.\n\nDraws the ellipse defined by the rectangle beginning at (x, y) with the given width and height.\n\nDraws the glyphs represented by glyphs at position. The position gives the edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font selected on glyphs and at offsets given by the positions in glyphs.\n\nSee also QGlyphRun::setRawFont(), QGlyphRun::setPositions(), and QGlyphRun::setGlyphIndexes().\n\nDraws the rectangular portion source of the given image into the target rectangle in the paint device.\n\nIf the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the flags to specify how you would prefer this to happen.\n\nSee also drawPixmap() and QImage::devicePixelRatio().\n\nThis is an overloaded function.\n\nDraws the given image at the given point.\n\nThis is an overloaded function.\n\nDraws the given image at the given point.\n\nThis is an overloaded function.\n\nDraws the given image into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the given image into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image into the target rectangle in the paint device.\n\nThis is an overloaded function.\n\nDraws an image at (x, y) by copying a part of image into the paint device.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto. (sx, sy) specifies the top-left point in image that is to be drawn. The default is (0, 0).\n\n(sw, sh) specifies the size of the image that is to be drawn. The default, (0, 0) (and negative) means all the way to the bottom-right of the image.\n\nSee also drawLines(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array lines using the current pen.\n\nSee also drawLine() and drawPolyline().\n\nThis is an overloaded function.\n\nDraws the set of lines defined by the list lines using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the set of lines defined by the list lines using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws a line for each pair of points in the vector pointPairs using the current pen.\n\nThis is an overloaded function.\n\nDraws a line for each pair of points in the vector pointPairs using the current pen. If there is an odd number of points in the array, the last point will be ignored.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array lines using the current pen.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array pointPairs using the current pen.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array pointPairs using the current pen. The lines are specified as pairs of points so the number of entries in pointPairs must be at least lineCount * 2.\n\nDraws the given painter path using the current pen for outline and the current brush for filling.\n\nSee also the Painter Paths example and the Vector Deformation example.\n\nReplays the given picture at the given point.\n\nThe QPicture class is a paint device that records and replays QPainter commands. A picture serializes the painter commands to an IO device in a platform-independent format. Everything that can be painted on a widget or pixmap can also be stored in a picture.\n\nThis function does exactly the same as QPicture::play() when called with point = QPointF(0, 0).\n\nThis is an overloaded function.\n\nReplays the given picture at the given point.\n\nThis is an overloaded function.\n\nDraws the given picture at point (x, y).\n\nDraws a pie defined by the given rectangle, startAngle and spanAngle.\n\nThe pie is filled with the current brush().\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawEllipse(), drawChord(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws a pie defined by the given rectangle, startAngle and and spanAngle.\n\nThis is an overloaded function.\n\nDraws the pie defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nDraws the rectangular portion source of the given pixmap into the given target in the paint device.\n\nIf pixmap is a QBitmap it is drawn with the bits that are \"set\" using the pens color. If backgroundMode is Qt::OpaqueMode, the \"unset\" bits are drawn using the color of the background brush; if backgroundMode is Qt::TransparentMode, the \"unset\" bits are transparent. Drawing bitmaps with gradient or texture colors is not supported.\n\nSee also drawImage() and QPixmap::devicePixelRatio().\n\nThis is an overloaded function.\n\nDraws the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given pixmap into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap into the given target in the paint device.\n\nThis is an overloaded function.\n\nDraws the given pixmap at position (x, y).\n\nThis is an overloaded function.\n\nDraws the pixmap into the rectangle at position (x, y) with the given width and height.\n\nThis is an overloaded function.\n\nDraws a pixmap at (x, y) by copying a part of the given pixmap into the paint device.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto. (sx, sy) specifies the top-left point in pixmap that is to be drawn. The default is (0, 0).\n\n(sw, sh) specifies the size of the pixmap that is to be drawn. The default, (0, 0) (and negative) means all the way to the bottom-right of the pixmap.\n\nThis is an overloaded function.\n\nDraws the rectangular portion with the origin (sx, sy), width sw and height sh, of the given pixmap , at the point (x, y), with a width of w and a height of h. If sw or sh are equal to zero the width/height of the pixmap is used and adjusted by the offset sx/sy;\n\nThis function is used to draw pixmap, or a sub-rectangle of pixmap, at multiple positions with different scale, rotation and opacity. fragments is an array of fragmentCount elements specifying the parameters used to draw each pixmap fragment. The hints parameter can be used to pass in drawing hints.\n\nThis function is potentially faster than multiple calls to drawPixmap(), since the backend can optimize state changes.\n\nSee also QPainter::PixmapFragment and QPainter::PixmapFragmentHint.\n\nDraws a single point at the given position using the current pen's color.\n\nThis is an overloaded function.\n\nDraws a single point at the given position using the current pen's color.\n\nThis is an overloaded function.\n\nDraws the first pointCount points in the array points using the current pen's color.\n\nThis is an overloaded function.\n\nDraws the points in the vector points.\n\nThis is an overloaded function.\n\nDraws the points in the vector points.\n\nThis is an overloaded function.\n\nDraws the first pointCount points in the array points using the current pen's color.\n\nDraws the polygon defined by the first pointCount points in the array points using the current pen and brush.\n\nThe first point is implicitly connected to the last point, and the polygon is filled with the current brush().\n\nIf fillRule is Qt::WindingFill, the polygon is filled using the winding fill algorithm. If fillRule is Qt::OddEvenFill, the polygon is filled using the odd-even fill algorithm. See Qt::FillRule for a more detailed description of these fill rules.\n\nSee also drawConvexPolygon(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the given points using the fill rule fillRule.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the given points using the fill rule fillRule.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the first pointCount points in the array points.\n\nDraws the polyline defined by the first pointCount points in points using the current pen.\n\nNote that unlike the drawPolygon() function the last point is not connected to the first, neither is the polyline filled.\n\nSee also drawLines(), drawPolygon(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the given points using the current pen.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the given points using the current pen.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the first pointCount points in points using the current pen.\n\nDraws the current rectangle with the current pen and brush.\n\nA filled rectangle has a size of rectangle.size(). A stroked rectangle has a size of rectangle.size() plus the pen width.\n\nSee also drawRects(), drawPolygon(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the current rectangle with the current pen and brush.\n\nThis is an overloaded function.\n\nDraws a rectangle with upper left corner at (x, y) and with the given width and height.\n\nDraws the first rectCount of the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the first rectCount of the given rectangles using the current pen and brush.\n\nDraws the given rectangle rect with rounded corners.\n\nThe xRadius and yRadius arguments specify the radii of the ellipses defining the corners of the rounded rectangle. When mode is Qt::RelativeSize, xRadius and yRadius are specified in percentage of half the rectangle's width and height respectively, and should be in the range 0.0 to 100.0.\n\nA filled rectangle has a size of rect.size(). A stroked rectangle has a size of rect.size() plus the pen width.\n\nSee also drawRect() and QPen.\n\nThis is an overloaded function.\n\nDraws the given rectangle rect with rounded corners.\n\nThis is an overloaded function.\n\nDraws the given rectangle x, y, w, h with rounded corners.\n\nDraws the given staticText at the given topLeftPosition.\n\nThe text will be drawn using the font and the transformation set on the painter. If the font and/or transformation set on the painter are different from the ones used to initialize the layout of the QStaticText, then the layout will have to be recalculated. Use QStaticText::prepare() to initialize staticText with the font and transformation with which it will later be drawn.\n\nIf topLeftPosition is not the same as when staticText was initialized, or when it was last drawn, then there will be a slight overhead when translating the text to its new position.\n\nThis is an overloaded function.\n\nDraws the staticText at the topLeftPosition.\n\nThis is an overloaded function.\n\nDraws the staticText at coordinates left and top.\n\nDraws the given text with the currently defined text direction, beginning at the given position.\n\nThis function does not handle the newline character (\n\n), as it cannot break text into multiple lines, and it cannot display the newline character. Use the QPainter::drawText() overload that takes a rectangle instead if you want to draw multiple lines of text with the newline character, or if you want the text to be wrapped.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text with the currently defined text direction, beginning at the given position.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text in the rectangle specified using the option to control its positioning, direction, and orientation. The options given in option override those set on the QPainter object itself.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text at position (x, y), using the painter's currently defined text direction.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text within the provided rectangle according to the specified flags.\n\nThe boundingRect (if not null) is set to the what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents rectangle:\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text within the provided rectangle. The rectangle along with alignment flags defines the anchors for the text.\n\nThe boundingRect (if not null) is set to what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents rectangle:\n\nThe flags argument is a bitwise OR of the following flags:\n\nSee also Qt::AlignmentFlag, Qt::TextFlag, boundingRect(), and layoutDirection().\n\nThis is an overloaded function.\n\nDraws the given text within the rectangle with origin (x, y), width and height.\n\nThe boundingRect (if not null) is set to the what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents the rectangle defined by x, y, width and height:\n\nThe flags argument is a bitwise OR of the following flags:\n\nSee also Qt::AlignmentFlag, Qt::TextFlag, setFont(), and setPen().\n\nDraws a tiled pixmap, inside the given rectangle with its origin at the given position.\n\nCalling drawTiledPixmap() is similar to calling drawPixmap() several times to fill (tile) an area with a pixmap, but is potentially much more efficient depending on the underlying window system.\n\ndrawTiledPixmap() will produce the same visual tiling pattern on high-dpi displays (with devicePixelRatio > 1), compared to normal- dpi displays. Set the devicePixelRatio on the pixmap to control the tile size. For example, setting it to 2 halves the tile width and height (on both 1x and 2x displays), and produces high-resolution output on 2x displays.\n\nThe position offset is always in the painter coordinate system, indepentent of display devicePixelRatio.\n\nThis is an overloaded function.\n\nDraws a tiled pixmap, inside the given rectangle with its origin at the given position.\n\nThis is an overloaded function.\n\nDraws a tiled pixmap in the specified rectangle.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto; with the given width and height. (sx, sy) specifies the top-left point in the pixmap that is to be drawn; this defaults to (0, 0).\n\nEnds painting. Any resources used while painting are released. You don't normally need to call this since it is called by the destructor.\n\nReturns if the painter is no longer active; otherwise returns .\n\nSee also begin() and isActive().\n\nRestores the painter after manually issuing native painting commands. Lets the painter restore any native state that it relies on before calling any other painter commands.\n\nErases the area inside the given rectangle. Equivalent to calling\n\nThis is an overloaded function.\n\nErases the area inside the given rectangle.\n\nThis is an overloaded function.\n\nErases the area inside the rectangle beginning at (x, y) with the given width and height.\n\nFills the given path using the given brush. The outline is not drawn.\n\nAlternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.\n\nFills the given rectangle with the brush specified.\n\nAlternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified gradient preset.\n\nThis is an overloaded function.\n\nFills the given rectangle with the brush style specified.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified color.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified brush.\n\nThis is an overloaded function.\n\nFills the given rectangle with the color specified.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified gradient preset.\n\nThis is an overloaded function.\n\nFills the given rectangle with the brush style specified.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified color.\n\nThis is an overloaded function.\n\nFills the given rectangle with the color specified.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given gradient preset.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the brush style specified.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given color.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given brush.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given color.\n\nReturns the currently set font used for drawing text.\n\nSee also setFont(), drawText(), and Settings.\n\nReturns the font info for the painter if the painter is active. Otherwise, the return value is undefined.\n\nSee also font(), isActive(), and Settings.\n\nReturns the font metrics for the painter if the painter is active. Otherwise, the return value is undefined.\n\nSee also font(), isActive(), and Settings.\n\nReturns if clipping has been set; otherwise returns .\n\nSee also setClipping() and Clipping.\n\nReturns if begin() has been called and end() has not yet been called; otherwise returns .\n\nSee also begin() and QPaintDevice::paintingActive().\n\nReturns the layout direction used by the painter when drawing text.\n\nSee also QTextOption::textDirection(), setLayoutDirection(), drawText(), and Settings.\n\nReturns the opacity of the painter. The default value is 1.\n\nReturns the paint engine that the painter is currently operating on if the painter is active; otherwise 0.\n\nSee also setPen() and Settings.\n\nReturns a flag that specifies the rendering hints that are set for this painter.\n\nSee also setRenderHints(), testRenderHint(), and Rendering Quality.\n\nResets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldTransform(), setViewport() and setWindow().\n\nRestores the current painter state (pops a saved state off the stack).\n\nRotates the coordinate system clockwise. The given angle parameter is in degrees.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nSaves the current painter state (pushes the state onto a stack). A save() must be followed by a corresponding restore(); the end() function unwinds the stack.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nSets the background brush of the painter to the given brush.\n\nThe background brush is the brush that is filled in when drawing opaque text, stippled lines and bitmaps. The background brush has no effect in transparent background mode (which is the default).\n\nSee also background(), setBackgroundMode(), and Settings.\n\nSets the background mode of the painter to the given mode\n\nQt::TransparentMode (the default) draws stippled lines and text without setting the background pixels. Qt::OpaqueMode fills these space with the current background color.\n\nNote that in order to draw a bitmap or pixmap transparently, you must use QPixmap::setMask().\n\nSee also backgroundMode(), setBackground(), and Settings.\n\nSets the painter's brush to the given brush.\n\nThe painter's brush defines how shapes are filled.\n\nSee also brush() and Settings.\n\nThis is an overloaded function.\n\nSets the painter's brush to black color and the specified style.\n\nThe brush origin specifies the (0, 0) coordinate of the painter's brush.\n\nNote that while the brushOrigin() was necessary to adopt the parent's background for a widget in Qt 3, this is no longer the case since the Qt 4 painter doesn't paint the background unless you explicitly tell it to do so by setting the widget's autoFillBackground property to true.\n\nSee also brushOrigin() and Settings.\n\nThis is an overloaded function.\n\nSets the brush's origin to the given position.\n\nThis is an overloaded function.\n\nEnables clipping, and sets the clip path for the painter to the given path, with the clip operation.\n\nNote that the clip path is specified in logical (painter) coordinates.\n\nSee also clipPath(), clipRegion(), and Clipping.\n\nEnables clipping, and sets the clip region to the given rectangle using the given clip operation. The default operation is to replace the current clip rectangle.\n\nNote that the clip rectangle is specified in logical (painter) coordinates.\n\nSee also clipRegion(), setClipping(), and Clipping.\n\nEnables clipping, and sets the clip region to the rectangle beginning at (x, y) with the given width and height.\n\nThis is an overloaded function.\n\nEnables clipping, and sets the clip region to the given rectangle using the given clip operation.\n\nSets the clip region to the given region using the specified clip operation. The default clip operation is to replace the current clip region.\n\nNote that the clip region is given in logical coordinates.\n\nSee also clipRegion(), setClipRect(), and Clipping.\n\nEnables clipping if enable is true, or disables clipping if enable is false.\n\nSee also hasClipping() and Clipping.\n\nSets the composition mode to the given mode.\n\nSets the painter's font to the given font.\n\nThis font is used by subsequent drawText() functions. The text color is the same as the pen color.\n\nIf you set a font that isn't available, Qt finds a close match. font() will return what you set using setFont() and fontInfo() returns the font actually being used (which may be the same).\n\nSee also font(), drawText(), and Settings.\n\nSets the layout direction used by the painter when drawing text, to the specified direction.\n\nThe default is Qt::LayoutDirectionAuto, which will implicitly determine the direction from the text drawn.\n\nSee also QTextOption::setTextDirection(), layoutDirection(), drawText(), and Settings.\n\nSets the opacity of the painter to opacity. The value should be in the range 0.0 to 1.0, where 0.0 is fully transparent and 1.0 is fully opaque.\n\nOpacity set on the painter will apply to all drawing operations individually.\n\nSets the painter's pen to be the given pen.\n\nThe pen defines how to draw lines and outlines, and it also defines the text color.\n\nSee also pen() and Settings.\n\nThis is an overloaded function.\n\nSets the painter's pen to have the given style, width 1 and black color.\n\nThis is an overloaded function.\n\nSets the painter's pen to have style Qt::SolidLine, width 1 and the specified color.\n\nSets the given render hint on the painter if on is true; otherwise clears the render hint.\n\nSee also setRenderHints(), renderHints(), and Rendering Quality.\n\nSets the given render hints on the painter if on is true; otherwise clears the render hints.\n\nSee also setRenderHint(), renderHints(), and Rendering Quality.\n\nSets the world transformation matrix. If combine is true, the specified transform is combined with the current matrix; otherwise it replaces the current matrix.\n\nSee also transform() and setWorldTransform().\n\nEnables view transformations if enable is true, or disables view transformations if enable is false.\n\nSee also viewTransformEnabled() and Window-Viewport Conversion.\n\nSets the painter's viewport rectangle to the given rectangle, and enables view transformations.\n\nThe viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system. Its sister, the window(), specifies the logical coordinate system.\n\nThe default viewport rectangle is the same as the device's rectangle.\n\nSee also viewport(), viewTransformEnabled(), and Window-Viewport Conversion.\n\nThis is an overloaded function.\n\nSets the painter's viewport rectangle to be the rectangle beginning at (x, y) with the given width and height.\n\nSets the painter's window to the given rectangle, and enables view transformations.\n\nThe window rectangle is part of the view transformation. The window specifies the logical coordinate system. Its sister, the viewport(), specifies the device coordinate system.\n\nThe default window rectangle is the same as the device's rectangle.\n\nSee also window(), viewTransformEnabled(), and Window-Viewport Conversion.\n\nThis is an overloaded function.\n\nSets the painter's window to the rectangle beginning at (x, y) and the given width and height.\n\nEnables transformations if enable is true, or disables transformations if enable is false. The world transformation matrix is not changed.\n\nSee also worldMatrixEnabled(), worldTransform(), and Coordinate Transformations.\n\nSets the world transformation matrix. If combine is true, the specified matrix is combined with the current matrix; otherwise it replaces the current matrix.\n\nSee also worldTransform(), transform(), and setTransform().\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nDraws the outline (strokes) the path path with the pen specified by pen\n\nSee also fillPath() and Drawing.\n\nReturns if hint is set; otherwise returns .\n\nSee also renderHints() and setRenderHint().\n\nSee also setTransform() and worldTransform().\n\nTranslates the coordinate system by the given offset; i.e. the given offset is added to points.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nThis is an overloaded function.\n\nTranslates the coordinate system by the given offset.\n\nThis is an overloaded function.\n\nTranslates the coordinate system by the vector (dx, dy).\n\nReturns if view transformation is enabled; otherwise returns false.\n\nSee also setViewTransformEnabled() and worldTransform().\n\nSee also setViewport() and setViewTransformEnabled().\n\nSee also setWindow() and setViewTransformEnabled().\n\nReturns if world transformation is enabled; otherwise returns false.\n\nSee also setWorldMatrixEnabled(), worldTransform(), and Coordinate System."
    },
    {
        "link": "https://qtcentre.org/threads/41113-How-to-set-QPainter-Background-color",
        "document": "Qt is a trademark of The Qt Company."
    },
    {
        "link": "https://stackoverflow.com/questions/71140195/qt-set-background-image-on-qtextdocument-using-html-to-generate-pdf-file",
        "document": "i am wrapping my head in this problem for a few time. I need to create a report by creating a pdf file with some data on it. So my plan was to instead of using the QTextCursor, i use HTML + CSS to create the content in my pdf file. Unfortunately I can't go with the QWebEngine widgets solution because I am compiling into MinGW and setting the MVSC 2017 environment is a huge mess. Sadly i have to go with the QTextDocument and his HTML subset support.\n\nMy problem is I can't put a background image in my pdf file. I want to put this image as a background image:\n\nWhat make me crazy is that I use the css property to display a background image in my pdf file.\n\nAnd it seems that Qt is taking this into account but it still don't display the background.\n\nThe first pdf file don't contain the css property background image on the html content but the second does and you can see that the size of the file is bigger so it has considered the css property. But it hasn't displayed the background: On the left is the first file and on the right is the second file with the css property.\n\nI use a html file in the ressource to generate the report :\n\nThis html file is open and read in the constructor of the class:\n\nThen i use a custom class with this function that use QPrinter and QPainter to write the data:\n\nHere is the function to add the html data into the measures QTextDocument:\n\nSo what i am doing wrong? Thanks in advance for your responses."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtGui/QPainter.html",
        "document": "The QPainter class performs low-level painting on widgets and other paint devices. More …\n\nprovides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a “natural” coordinate system, but it can also do view and world transformation. can operate on any object that inherits the class. The common use of is inside a widget’s paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the object after drawing. For example: The core functionality of is drawing, but the class also provide several functions that allows you to customize ‘s settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter’s composition mode. The function indicates whether the painter is active. A painter is activated by the function and the constructor that takes a argument. The function, and the destructor, deactivates it. Together with the and classes, form the basis for Qt’s paint system. is the class used to perform drawing operations. represents a device that can be painted on using a . provides the interface that the painter uses to draw onto different types of devices. If the painter is active, returns the paint device on which the painter paints, and returns the paint engine that the painter is currently operating on. For more information, see the Paint System . Sometimes it is desirable to make someone else paint on an unusual . supports a static function to do this, . When the paintdevice is a widget, can only be used inside a paintEvent() function or in a function called by paintEvent()."
    },
    {
        "link": "https://felgo.com/doc/qt/qpainter",
        "document": "The QPainter class performs low-level painting on widgets and other paint devices. More...\n\nNote: All functions in this class are reentrant.\n\nThis list gives an indication of which features to safely use in an application where performance is critical. For certain setups, other operations may be fast too, but before making extensive use of them, it is recommended to benchmark and verify them on the system where the software will run in the end. There are also cases where expensive operations are ok to use, for instance when the result is cached in a QPixmap .\n\nThe backends we focus on as high-performance engines are:\n\nQPainter is a rich framework that allows developers to do a great variety of graphical operations, such as gradients, composition modes and vector graphics. And QPainter can do this across a variety of different hardware and software stacks. Naturally the underlying combination of hardware and software has some implications for performance, and ensuring that every single operation is fast in combination with all the various combinations of composition modes, brushes, clipping, transformation, etc, is close to an impossible task because of the number of permutations. As a compromise we have selected a subset of the QPainter API and backends, where performance is guaranteed to be as good as we can sensibly get it for the given combination of hardware and software.\n\nThe outlines generated by Qt's stroker are only an approximation when dealing with curved shapes. It is in most cases impossible to represent the outline of a bezier curve segment using another bezier curve segment, and so Qt approximates the curve outlines by using several smaller curves. For performance reasons there is a limit to how many curves Qt uses for these outlines, and thus when using large pen widths or scales the outline error increases. To generate outlines with smaller errors it is possible to use the QPainterPathStroker class, which has the setCurveThreshold member function which let's the user specify the error tolerance. Another workaround is to convert the paths to polygons first and then draw the polygons instead.\n\nIf you are using coordinates with Qt's raster-based paint engine, it is important to note that, while coordinates greater than +/- 2 15 can be used, any painting performed with coordinates outside this range is not guaranteed to be shown; the drawing may be clipped. This is due to the use of short int in the implementation.\n\nThe Composition Modes example, available in Qt's examples directory, allows you to experiment with the various composition modes and see the results immediately.\n\nNote that composition transformation operates pixelwise. For that reason, there is a difference between using the graphic primitive itself and its bounding rectangle: The bounding rect contains pixels with alpha == 0 (i.e the pixels surrounding the primitive). These pixels will overwrite the other image's pixels, effectively clearing those, while the primitive only overwrites its own area.\n\nThe two most common forms of composition are Source and SourceOver . Source is used to draw opaque objects onto a paint device. In this mode, each pixel in the source replaces the corresponding pixel in the destination. In SourceOver composition mode, the source object is transparent and is drawn on top of the destination.\n\nQPainter provides the CompositionMode enum which defines the Porter-Duff rules for digital image compositing; it describes a model for combining the pixels in one image, the source, with the pixels in another image, the destination.\n\nAfter QPainter's clipping, the paint device may also clip. For example, most widgets clip away the pixels used by child widgets, and most printers clip away an area near the edges of the paper. This additional clipping is not reflected by the return value of clipRegion () or hasClipping ().\n\nQPainter can clip any drawing operation to a rectangle, a region, or a vector path. The current clip is available using the functions clipRegion () and clipPath (). Whether paths or regions are preferred (faster) depends on the underlying paintEngine (). For example, the QImage paint engine prefers paths while the X11 paint engine prefers regions. Setting a clip is done in the painters logical coordinates.\n\nWhen drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's combinedTransform (), a combination of viewport () and window () and worldTransform (). The viewport () represents the physical coordinates specifying an arbitrary rectangle, the window () describes the same rectangle in logical coordinates, and the worldTransform () is identical with the transformation matrix.\n\nThe setWorldTransform () function can replace or add to the currently set worldTransform (). The resetTransform () function resets any transformations that were made using translate (), scale (), shear (), rotate (), setWorldTransform (), setViewport () and setWindow () functions. The deviceTransform () returns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device. The latter function is only needed when using platform painting commands on the platform dependent handle, and the platform does not do transformations nativly.\n\nAll the transformation operations operate on the transformation worldTransform (). A matrix transforms a point in the plane to another point. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe Affine Transformations example shows Qt's ability to perform affine transformations on painting operations. The demo also allows the user to experiment with the transformation operations and see the results immediately.\n\nSee also the Transformations example which shows how transformations influence the way that QPainter renders graphics primitives. In particular it shows how the order of transformations affects the result.\n\nThe most commonly used transformations are scaling, rotation, translation and shearing. Use the scale () function to scale the coordinate system by a given offset, the rotate () function to rotate it clockwise and translate () to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the shear () function. See the Affine Transformations example for a visualization of a sheared coordinate system.\n\nNormally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformations.\n\nThe renderHints () function returns a flag that specifies the rendering hints that are set for this painter. Use the setRenderHint () function to set or clear the currently set RenderHints .\n\nThe RenderHint enum specifies flags to QPainter that may or may not be respected by any given engine. QPainter::Antialiasing indicates that the engine should antialias edges of primitives if possible, QPainter::TextAntialiasing indicates that the engine should antialias text if possible, and the QPainter::SmoothPixmapTransform indicates that the engine should use a smooth pixmap transformation algorithm.\n\nThe application's main window displays several widgets which are drawn using the various combinations of precision and anti-aliasing.\n\nThe Concentric Circles example shows the improved rendering quality that can be obtained using floating point precision and anti-aliasing when drawing custom widgets.\n\nThe QPainter class also provides a means of controlling the rendering quality through its RenderHint enum and the support for floating point precision: All the functions for drawing primitives has a floating point version. These are often used in combination with the QPainter::Antialiasing render hint.\n\nTo get the optimal rendering result using QPainter, you should use the platform independent QImage as paint device; i.e. using QImage will ensure that the result has an identical pixel representation on any platform.\n\nThis is for example the case when drawing a QPixmap of 64x64 pixels size with a device pixel ratio of 2 onto a high DPI screen which also has a device pixel ratio of 2. Note that the pixmap is then effectively 32x32 pixels in user space . Code paths in Qt that calculate layout geometry based on the pixmap size will use this size. The net effect of this is that the pixmap is displayed as high DPI pixmap rather than a large pixmap.\n\nHigh resolution versions of pixmaps have a device pixel ratio value larger than 1 (see QImageReader , QPixmap::devicePixelRatio ()). Should it match the value of the underlying QPaintDevice , it is drawn directly onto the device with no additional transformation applied.\n\nThere is a drawPicture () function that draws the contents of an entire QPicture . The drawPicture () function is the only function that disregards all the painter's settings as QPicture has its own settings.\n\nThere are functions to draw pixmaps/images, namely drawPixmap (), drawImage () and drawTiledPixmap (). Both drawPixmap () and drawImage () produce the same result, except that drawPixmap () is faster on-screen while drawImage () may be faster on a QPrinter or other devices.\n\nText drawing is done using drawText (). When you need fine-grained positioning, boundingRect () tells you where a given drawText () command will draw.\n\nSee also the Vector Deformation example which shows how to use advanced vector techniques to draw text using a QPainterPath , the Gradients example which shows the different types of gradients that are available in Qt, and the Path Stroking example which shows Qt's built-in dash patterns and shows how custom patterns can be used to extend the range of available patterns.\n\nQPainter also provides the fillPath () function which fills the given QPainterPath with the given QBrush , and the strokePath () function that draws the outline of the given path (i.e. strokes the path).\n\nThe Painter Paths example shows how painter paths can be used to build complex shapes for rendering.\n\nThe QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused.\n\nIf you need to draw a complex shape, especially if you need to do so repeatedly, consider creating a QPainterPath and drawing it using drawPath ().\n\nThe Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the QPainter class.\n\nAll of these functions have both integer and floating point versions.\n\nThe QPainter class also provides the fillRect () function which fills the given QRect , with the given QBrush , and the eraseRect () function that erases the area inside the given rectangle.\n\nQPainter provides functions to draw most primitives: drawPoint (), drawPoints (), drawLine (), drawRect (), drawRoundedRect (), drawEllipse (), drawArc (), drawPie (), drawChord (), drawPolyline (), drawPolygon (), drawConvexPolygon () and drawCubicBezier(). The two convenience functions, drawRects () and drawLines (), draw the given number of rectangles or lines in the given array of QRects or QLines using the current pen and brush.\n\nYou can at any time save the QPainter's state by calling the save () function which saves all the available settings on an internal stack. The restore () function pops them back.\n\nNote that some of these settings mirror settings in some paint devices, e.g. QWidget::font (). The QPainter::begin () function (or equivalently the QPainter constructor) copies these attributes from the paint device.\n\nThere are several settings that you can customize to make QPainter draw according to your preferences:\n\nWarning: When the paintdevice is a widget, QPainter can only be used inside a paintEvent() function or in a function called by paintEvent().\n\nSometimes it is desirable to make someone else paint on an unusual QPaintDevice . QPainter supports a static function to do this, setRedirected().\n\nTogether with the QPaintDevice and QPaintEngine classes, QPainter form the basis for Qt's paint system. QPainter is the class used to perform drawing operations. QPaintDevice represents a device that can be painted on using a QPainter. QPaintEngine provides the interface that the painter uses to draw onto different types of devices. If the painter is active, device () returns the paint device on which the painter paints, and paintEngine () returns the paint engine that the painter is currently operating on. For more information, see the Paint System .\n\nThe isActive () function indicates whether the painter is active. A painter is activated by the begin () function and the constructor that takes a QPaintDevice argument. The end () function, and the destructor, deactivates it.\n\nThe core functionality of QPainter is drawing, but the class also provide several functions that allows you to customize QPainter's settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter's composition mode.\n\nThe common use of QPainter is inside a widget's paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the QPainter object after drawing. For example:\n\nQPainter provides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a \"natural\" coordinate system, but it can also do view and world transformation. QPainter can operate on any object that inherits the QPaintDevice class.\n\nSee also QPaintDevice, QPaintEngine, Qt SVG, Basic Drawing Example, and Drawing Utility Functions.\n\nThe RenderHints type is a typedef for QFlags <RenderHint>. It stores an OR combination of RenderHint values.\n\nRenderhints are used to specify flags to QPainter that may or may not be respected by any given engine.\n\nSee also QPainter::drawPixmapFragments () and QPainter::PixmapFragment .\n\nThe PixmapFragmentHints type is a typedef for QFlags <PixmapFragmentHint>. It stores an OR combination of PixmapFragmentHint values.\n\nWhen a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.\n\nSeveral composition modes require an alpha channel in the source or target images to have an effect. For optimal performance the image format Format_ARGB32_Premultiplied is preferred.\n\nThe most common type is SourceOver (often referred to as just alpha blending) where the source pixel is blended on top of the destination pixel in such a way that the alpha component of the source defines the translucency of the pixel.\n\nPlease note that the bitwise raster operation modes, denoted with a RasterOp prefix, are only natively supported in the X11 and raster paint engines. This means that the only way to utilize these modes on the Mac is via a QImage . The RasterOp denoted blend modes are not supported for pens and brushes with alpha components. Also, turning on the QPainter::Antialiasing render hint will effectively disable the RasterOp modes.\n\nDefines the modes supported for digital image compositing. Composition modes are used to specify how the pixels in one image, the source, are merged with the pixel in another image, the destination.\n\nThis constructor is convenient for short-lived painters, e.g. in a QWidget::paintEvent() and should be used only once. The constructor calls begin() for you and the QPainter destructor automatically calls end().\n\nHere's an example using begin() and end():\n\nThe same example using this constructor:\n\nSince the constructor cannot provide feedback when the initialization of the painter failed you should rather use begin() and end() to paint on external devices, e.g. printers.\n\nSee also begin() and end().\n\nSee also begin() and end().\n\nSee also setBackground() and Settings.\n\nSee also setBackgroundMode() and Settings.\n\nBegins painting the paint device and returns if successful; otherwise returns .\n\nNotice that all painter settings (setPen(), setBrush() etc.) are reset to default values when begin() is called.\n\nThe errors that can occur are serious problems, such as these:\n\nNote that most of the time, you can use one of the constructors instead of begin(), and that end() is automatically done at destruction.\n\nSee also end() and QPainter().\n\nFlushes the painting pipeline and prepares for the user issuing commands directly to the underlying graphics context. Must be followed by a call to endNativePainting().\n\nNote that only the states the underlying paint engine changes will be reset to their respective default states. The states we reset may change from release to release. The following states are currently reset in the OpenGL 2 engine:\n• the depth, stencil and scissor tests are disabled\n• the active texture unit is reset to 0\n• the depth mask, depth function and the clear depth are reset to their default values\n• the stencil mask, stencil operation and stencil function are reset to their default values\n• the current color is reset to solid white\n\nIf, for example, the OpenGL polygon mode is changed by the user inside a beginNativePaint()/endNativePainting() block, it will not be reset to the default state by endNativePainting(). Here is an example that shows intermixing of painter commands and raw OpenGL commands:\n\nReturns the bounding rectangle of the text as it will appear when drawn inside the given rectangle with the specified flags using the currently set font(); i.e the function tells you where the drawText() function will draw when given the same arguments.\n\nIf the text does not fit within the given rectangle using the specified flags, the function returns the required rectangle.\n\nThe flags argument is a bitwise OR of the following flags:\n\nIf several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.\n\nSee also drawText(), Qt::Alignment, and Qt::TextFlag.\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the text as it will appear when drawn inside the given rectangle with the specified flags using the currently set font().\n\nThis is an overloaded function.\n\nReturns the bounding rectangle of the given text as it will appear when drawn inside the rectangle beginning at the point (x, y) with width w and height h.\n\nThis is an overloaded function.\n\nInstead of specifying flags as a bitwise OR of the Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes an option argument. The QTextOption class provides a description of general rich text properties.\n\nSee also QPainter::setBrush() and Settings.\n\nSee also setBrushOrigin() and Settings.\n\nReturns the bounding rectangle of the current clip if there is a clip; otherwise returns an empty rectangle. Note that the clip region is given in logical coordinates.\n\nThe bounding rectangle is not guaranteed to be tight.\n\nSee also setClipRect(), setClipPath(), and setClipRegion().\n\nSee also setClipPath(), clipRegion(), and setClipping().\n\nReturns the currently set clip region. Note that the clip region is given in logical coordinates.\n\nSee also setClipRegion(), clipPath(), and setClipping().\n\nReturns the transformation matrix combining the current window/viewport and world transformation.\n\nSee also setWorldTransform(), setWindow(), and setViewport().\n\nSee also CompositionMode and setCompositionMode().\n\nReturns the paint device on which this painter is currently painting, or if the painter is not active.\n\nReturns the matrix that transforms from logical coordinates to device coordinates of the platform dependent paint device.\n\nThis function is only needed when using platform painting commands on the platform dependent handle (Qt::HANDLE), and the platform does not do transformations nativly.\n\nThe QPaintEngine::PaintEngineFeature enum can be queried to determine whether the platform performs the transformations or not.\n\nSee also worldTransform() and QPaintEngine::hasFeature().\n\nDraws the arc defined by the given rectangle, startAngle and spanAngle.\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawPie(), drawChord(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the arc defined by the given rectangle, startAngle and spanAngle.\n\nThis is an overloaded function.\n\nDraws the arc defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nDraws the chord defined by the given rectangle, startAngle and spanAngle. The chord is filled with the current brush().\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawArc(), drawPie(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the chord defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nThis is an overloaded function.\n\nDraws the chord defined by the given rectangle, startAngle and spanAngle.\n\nDraws the convex polygon defined by the first pointCount points in the array points using the current pen.\n\nThe first point is implicitly connected to the last point, and the polygon is filled with the current brush(). If the supplied polygon is not convex, i.e. it contains at least one angle larger than 180 degrees, the results are undefined.\n\nOn some platforms (e.g. X11), the drawConvexPolygon() function can be faster than the drawPolygon() function.\n\nSee also drawPolygon(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by polygon using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by the first pointCount points in the array points using the current pen.\n\nThis is an overloaded function.\n\nDraws the convex polygon defined by polygon using the current pen and brush.\n\nDraws the ellipse defined by the given rectangle.\n\nA filled ellipse has a size of rectangle.size(). A stroked ellipse has a size of rectangle.size() plus the pen width.\n\nSee also drawPie() and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the ellipse defined by the given rectangle.\n\nThis is an overloaded function.\n\nDraws the ellipse defined by the rectangle beginning at (x, y) with the given width and height.\n\nThis is an overloaded function.\n\nDraws the ellipse positioned at center with radii rx and ry.\n\nThis is an overloaded function.\n\nDraws the ellipse positioned at center with radii rx and ry.\n\nDraws the glyphs represented by glyphs at position. The position gives the edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font selected on glyphs and at offsets given by the positions in glyphs.\n\nSee also QGlyphRun::setRawFont(), QGlyphRun::setPositions(), and QGlyphRun::setGlyphIndexes().\n\nDraws the rectangular portion source of the given image into the target rectangle in the paint device.\n\nIf the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the flags to specify how you would prefer this to happen.\n\nSee also drawPixmap() and QImage::devicePixelRatio().\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image into the target rectangle in the paint device.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given image with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given image into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the given image into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the given image at the given point.\n\nThis is an overloaded function.\n\nDraws the given image at the given point.\n\nThis is an overloaded function.\n\nDraws an image at (x, y) by copying a part of image into the paint device.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto. (sx, sy) specifies the top-left point in image that is to be drawn. The default is (0, 0).\n\n(sw, sh) specifies the size of the image that is to be drawn. The default, (0, 0) (and negative) means all the way to the bottom-right of the image.\n\nSee also drawLines(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array lines using the current pen.\n\nSee also drawLine() and drawPolyline().\n\nThis is an overloaded function.\n\nDraws the set of lines defined by the list lines using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array pointPairs using the current pen. The lines are specified as pairs of points so the number of entries in pointPairs must be at least lineCount * 2.\n\nThis is an overloaded function.\n\nDraws a line for each pair of points in the vector pointPairs using the current pen. If there is an odd number of points in the array, the last point will be ignored.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array lines using the current pen.\n\nThis is an overloaded function.\n\nDraws the set of lines defined by the list lines using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the first lineCount lines in the array pointPairs using the current pen.\n\nThis is an overloaded function.\n\nDraws a line for each pair of points in the vector pointPairs using the current pen.\n\nDraws the given painter path using the current pen for outline and the current brush for filling.\n\nSee also the Painter Paths example and the Vector Deformation example.\n\nReplays the given picture at the given point.\n\nThe QPicture class is a paint device that records and replays QPainter commands. A picture serializes the painter commands to an IO device in a platform-independent format. Everything that can be painted on a widget or pixmap can also be stored in a picture.\n\nThis function does exactly the same as QPicture::play() when called with point = QPointF(0, 0).\n\nThis is an overloaded function.\n\nDraws the given picture at point (x, y).\n\nThis is an overloaded function.\n\nReplays the given picture at the given point.\n\nDraws a pie defined by the given rectangle, startAngle and spanAngle.\n\nThe pie is filled with the current brush().\n\nThe startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.\n\nSee also drawEllipse(), drawChord(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the pie defined by the rectangle beginning at (x, y) with the specified width and height, and the given startAngle and spanAngle.\n\nThis is an overloaded function.\n\nDraws a pie defined by the given rectangle, startAngle and and spanAngle.\n\nDraws the rectangular portion source of the given pixmap into the given target in the paint device.\n\nIf pixmap is a QBitmap it is drawn with the bits that are \"set\" using the pens color. If backgroundMode is Qt::OpaqueMode, the \"unset\" bits are drawn using the color of the background brush; if backgroundMode is Qt::TransparentMode, the \"unset\" bits are transparent. Drawing bitmaps with gradient or texture colors is not supported.\n\nSee also drawImage() and QPixmap::devicePixelRatio().\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap into the given target in the paint device.\n\nThis is an overloaded function.\n\nDraws the rectangular portion with the origin (sx, sy), width sw and height sh, of the given pixmap , at the point (x, y), with a width of w and a height of h. If sw or sh are equal to zero the width/height of the pixmap is used and adjusted by the offset sx/sy;\n\nThis is an overloaded function.\n\nDraws a pixmap at (x, y) by copying a part of the given pixmap into the paint device.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto. (sx, sy) specifies the top-left point in pixmap that is to be drawn. The default is (0, 0).\n\n(sw, sh) specifies the size of the pixmap that is to be drawn. The default, (0, 0) (and negative) means all the way to the bottom-right of the pixmap.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the rectangular portion source of the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given pixmap with its origin at the given point.\n\nThis is an overloaded function.\n\nDraws the given pixmap at position (x, y).\n\nThis is an overloaded function.\n\nDraws the given pixmap into the given rectangle.\n\nThis is an overloaded function.\n\nDraws the pixmap into the rectangle at position (x, y) with the given width and height.\n\nThis function is used to draw pixmap, or a sub-rectangle of pixmap, at multiple positions with different scale, rotation and opacity. fragments is an array of fragmentCount elements specifying the parameters used to draw each pixmap fragment. The hints parameter can be used to pass in drawing hints.\n\nThis function is potentially faster than multiple calls to drawPixmap(), since the backend can optimize state changes.\n\nSee also QPainter::PixmapFragment and QPainter::PixmapFragmentHint.\n\nDraws a single point at the given position using the current pen's color.\n\nThis is an overloaded function.\n\nDraws a single point at the given position using the current pen's color.\n\nThis is an overloaded function.\n\nDraws the first pointCount points in the array points using the current pen's color.\n\nThis is an overloaded function.\n\nDraws the points in the vector points.\n\nThis is an overloaded function.\n\nDraws the first pointCount points in the array points using the current pen's color.\n\nThis is an overloaded function.\n\nDraws the points in the vector points.\n\nDraws the polygon defined by the first pointCount points in the array points using the current pen and brush.\n\nThe first point is implicitly connected to the last point, and the polygon is filled with the current brush().\n\nIf fillRule is Qt::WindingFill, the polygon is filled using the winding fill algorithm. If fillRule is Qt::OddEvenFill, the polygon is filled using the odd-even fill algorithm. See Qt::FillRule for a more detailed description of these fill rules.\n\nSee also drawConvexPolygon(), drawPolyline(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the given points using the fill rule fillRule.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the first pointCount points in the array points.\n\nThis is an overloaded function.\n\nDraws the polygon defined by the given points using the fill rule fillRule.\n\nDraws the polyline defined by the first pointCount points in points using the current pen.\n\nNote that unlike the drawPolygon() function the last point is not connected to the first, neither is the polyline filled.\n\nSee also drawLines(), drawPolygon(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the given points using the current pen.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the first pointCount points in points using the current pen.\n\nThis is an overloaded function.\n\nDraws the polyline defined by the given points using the current pen.\n\nDraws the current rectangle with the current pen and brush.\n\nA filled rectangle has a size of rectangle.size(). A stroked rectangle has a size of rectangle.size() plus the pen width.\n\nSee also drawRects(), drawPolygon(), and Coordinate System.\n\nThis is an overloaded function.\n\nDraws a rectangle with upper left corner at (x, y) and with the given width and height.\n\nThis is an overloaded function.\n\nDraws the current rectangle with the current pen and brush.\n\nDraws the first rectCount of the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the first rectCount of the given rectangles using the current pen and brush.\n\nThis is an overloaded function.\n\nDraws the given rectangles using the current pen and brush.\n\nDraws the given rectangle rect with rounded corners.\n\nThe xRadius and yRadius arguments specify the radii of the ellipses defining the corners of the rounded rectangle. When mode is Qt::RelativeSize, xRadius and yRadius are specified in percentage of half the rectangle's width and height respectively, and should be in the range 0.0 to 100.0.\n\nA filled rectangle has a size of rect.size(). A stroked rectangle has a size of rect.size() plus the pen width.\n\nSee also drawRect() and QPen.\n\nThis is an overloaded function.\n\nDraws the given rectangle x, y, w, h with rounded corners.\n\nThis is an overloaded function.\n\nDraws the given rectangle rect with rounded corners.\n\nDraws the given staticText at the given topLeftPosition.\n\nThe text will be drawn using the font and the transformation set on the painter. If the font and/or transformation set on the painter are different from the ones used to initialize the layout of the QStaticText, then the layout will have to be recalculated. Use QStaticText::prepare() to initialize staticText with the font and transformation with which it will later be drawn.\n\nIf topLeftPosition is not the same as when staticText was initialized, or when it was last drawn, then there will be a slight overhead when translating the text to its new position.\n\nThis is an overloaded function.\n\nDraws the staticText at the topLeftPosition.\n\nThis is an overloaded function.\n\nDraws the staticText at coordinates left and top.\n\nThis is an overloaded function.\n\nDraws the given text within the provided rectangle. The rectangle along with alignment flags defines the anchors for the text.\n\nThe boundingRect (if not null) is set to what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents rectangle:\n\nThe flags argument is a bitwise OR of the following flags:\n\nSee also Qt::AlignmentFlag, Qt::TextFlag, boundingRect(), and layoutDirection().\n\nDraws the given text with the currently defined text direction, beginning at the given position.\n\nThis function does not handle the newline character (\n\n), as it cannot break text into multiple lines, and it cannot display the newline character. Use the QPainter::drawText() overload that takes a rectangle instead if you want to draw multiple lines of text with the newline character, or if you want the text to be wrapped.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text with the currently defined text direction, beginning at the given position.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text at position (x, y), using the painter's currently defined text direction.\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text within the provided rectangle according to the specified flags.\n\nThe boundingRect (if not null) is set to the what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents rectangle:\n\nSee also setFont() and setPen().\n\nThis is an overloaded function.\n\nDraws the given text within the rectangle with origin (x, y), width and height.\n\nThe boundingRect (if not null) is set to the what the bounding rectangle should be in order to enclose the whole text. For example, in the following image, the dotted line represents boundingRect as calculated by the function, and the dashed line represents the rectangle defined by x, y, width and height:\n\nThe flags argument is a bitwise OR of the following flags:\n\nSee also Qt::AlignmentFlag, Qt::TextFlag, setFont(), and setPen().\n\nThis is an overloaded function.\n\nDraws the given text in the rectangle specified using the option to control its positioning, direction, and orientation. The options given in option override those set on the QPainter object itself.\n\nSee also setFont() and setPen().\n\nDraws a tiled pixmap, inside the given rectangle with its origin at the given position.\n\nCalling drawTiledPixmap() is similar to calling drawPixmap() several times to fill (tile) an area with a pixmap, but is potentially much more efficient depending on the underlying window system.\n\ndrawTiledPixmap() will produce the same visual tiling pattern on high-dpi displays (with devicePixelRatio > 1), compared to normal- dpi displays. Set the devicePixelRatio on the pixmap to control the tile size. For example, setting it to 2 halves the tile width and height (on both 1x and 2x displays), and produces high-resolution output on 2x displays.\n\nThe position offset is always in the painter coordinate system, indepentent of display devicePixelRatio.\n\nThis is an overloaded function.\n\nDraws a tiled pixmap in the specified rectangle.\n\n(x, y) specifies the top-left point in the paint device that is to be drawn onto; with the given width and height. (sx, sy) specifies the top-left point in the pixmap that is to be drawn; this defaults to (0, 0).\n\nThis is an overloaded function.\n\nDraws a tiled pixmap, inside the given rectangle with its origin at the given position.\n\nEnds painting. Any resources used while painting are released. You don't normally need to call this since it is called by the destructor.\n\nReturns if the painter is no longer active; otherwise returns .\n\nSee also begin() and isActive().\n\nRestores the painter after manually issuing native painting commands. Lets the painter restore any native state that it relies on before calling any other painter commands.\n\nErases the area inside the given rectangle. Equivalent to calling\n\nThis is an overloaded function.\n\nErases the area inside the rectangle beginning at (x, y) with the given width and height.\n\nThis is an overloaded function.\n\nErases the area inside the given rectangle.\n\nFills the given path using the given brush. The outline is not drawn.\n\nAlternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.\n\nFills the given rectangle with the brush specified.\n\nAlternatively, you can specify a QColor instead of a QBrush; the QBrush constructor (taking a QColor argument) will automatically create a solid pattern brush.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given brush.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified brush.\n\nThis is an overloaded function.\n\nFills the given rectangle with the color specified.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given color.\n\nThis is an overloaded function.\n\nFills the given rectangle with the color specified.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given color.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified color.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified color.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the brush style specified.\n\nThis is an overloaded function.\n\nFills the given rectangle with the brush style specified.\n\nThis is an overloaded function.\n\nFills the given rectangle with the brush style specified.\n\nThis is an overloaded function.\n\nFills the rectangle beginning at (x, y) with the given width and height, using the given gradient preset.\n\nThis function was introduced in Qt 5.12.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified gradient preset.\n\nThis function was introduced in Qt 5.12.\n\nThis is an overloaded function.\n\nFills the given rectangle with the specified gradient preset.\n\nThis function was introduced in Qt 5.12.\n\nReturns the currently set font used for drawing text.\n\nSee also setFont(), drawText(), and Settings.\n\nReturns the font info for the painter if the painter is active. Otherwise, the return value is undefined.\n\nSee also font(), isActive(), and Settings.\n\nReturns the font metrics for the painter if the painter is active. Otherwise, the return value is undefined.\n\nSee also font(), isActive(), and Settings.\n\nReturns if clipping has been set; otherwise returns .\n\nSee also setClipping() and Clipping.\n\nReturns if begin() has been called and end() has not yet been called; otherwise returns .\n\nSee also begin() and QPaintDevice::paintingActive().\n\nReturns the layout direction used by the painter when drawing text.\n\nSee also QTextOption::textDirection(), setLayoutDirection(), drawText(), and Settings.\n\nReturns the opacity of the painter. The default value is 1.\n\nReturns the paint engine that the painter is currently operating on if the painter is active; otherwise 0.\n\nSee also setPen() and Settings.\n\nReturns a flag that specifies the rendering hints that are set for this painter.\n\nSee also setRenderHints(), testRenderHint(), and Rendering Quality.\n\nResets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldTransform(), setViewport() and setWindow().\n\nRestores the current painter state (pops a saved state off the stack).\n\nRotates the coordinate system clockwise. The given angle parameter is in degrees.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nSaves the current painter state (pushes the state onto a stack). A save() must be followed by a corresponding restore(); the end() function unwinds the stack.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nSets the background brush of the painter to the given brush.\n\nThe background brush is the brush that is filled in when drawing opaque text, stippled lines and bitmaps. The background brush has no effect in transparent background mode (which is the default).\n\nSee also background(), setBackgroundMode(), and Settings.\n\nSets the background mode of the painter to the given mode\n\nQt::TransparentMode (the default) draws stippled lines and text without setting the background pixels. Qt::OpaqueMode fills these space with the current background color.\n\nNote that in order to draw a bitmap or pixmap transparently, you must use QPixmap::setMask().\n\nSee also backgroundMode(), setBackground(), and Settings.\n\nSets the painter's brush to the given brush.\n\nThe painter's brush defines how shapes are filled.\n\nSee also brush() and Settings.\n\nThis is an overloaded function.\n\nSets the painter's brush to black color and the specified style.\n\nThe brush origin specifies the (0, 0) coordinate of the painter's brush.\n\nNote that while the brushOrigin() was necessary to adopt the parent's background for a widget in Qt 3, this is no longer the case since the Qt 4 painter doesn't paint the background unless you explicitly tell it to do so by setting the widget's autoFillBackground property to true.\n\nSee also brushOrigin() and Settings.\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nSets the brush's origin to the given position.\n\nEnables clipping, and sets the clip path for the painter to the given path, with the clip operation.\n\nNote that the clip path is specified in logical (painter) coordinates.\n\nSee also clipPath(), clipRegion(), and Clipping.\n\nEnables clipping, and sets the clip region to the given rectangle using the given clip operation. The default operation is to replace the current clip rectangle.\n\nNote that the clip rectangle is specified in logical (painter) coordinates.\n\nSee also clipRegion(), setClipping(), and Clipping.\n\nThis is an overloaded function.\n\nEnables clipping, and sets the clip region to the given rectangle using the given clip operation.\n\nEnables clipping, and sets the clip region to the rectangle beginning at (x, y) with the given width and height.\n\nSets the clip region to the given region using the specified clip operation. The default clip operation is to replace the current clip region.\n\nNote that the clip region is given in logical coordinates.\n\nSee also clipRegion(), setClipRect(), and Clipping.\n\nEnables clipping if enable is true, or disables clipping if enable is false.\n\nSee also hasClipping() and Clipping.\n\nSets the composition mode to the given mode.\n\nSets the painter's font to the given font.\n\nThis font is used by subsequent drawText() functions. The text color is the same as the pen color.\n\nIf you set a font that isn't available, Qt finds a close match. font() will return what you set using setFont() and fontInfo() returns the font actually being used (which may be the same).\n\nSee also font(), drawText(), and Settings.\n\nSets the layout direction used by the painter when drawing text, to the specified direction.\n\nThe default is Qt::LayoutDirectionAuto, which will implicitly determine the direction from the text drawn.\n\nSee also QTextOption::setTextDirection(), layoutDirection(), drawText(), and Settings.\n\nSets the opacity of the painter to opacity. The value should be in the range 0.0 to 1.0, where 0.0 is fully transparent and 1.0 is fully opaque.\n\nOpacity set on the painter will apply to all drawing operations individually.\n\nSets the painter's pen to be the given pen.\n\nThe pen defines how to draw lines and outlines, and it also defines the text color.\n\nSee also pen() and Settings.\n\nThis is an overloaded function.\n\nSets the painter's pen to have style Qt::SolidLine, width 1 and the specified color.\n\nThis is an overloaded function.\n\nSets the painter's pen to have the given style, width 1 and black color.\n\nSets the given render hint on the painter if on is true; otherwise clears the render hint.\n\nSee also setRenderHints(), renderHints(), and Rendering Quality.\n\nSets the given render hints on the painter if on is true; otherwise clears the render hints.\n\nSee also setRenderHint(), renderHints(), and Rendering Quality.\n\nSets the world transformation matrix. If combine is true, the specified transform is combined with the current matrix; otherwise it replaces the current matrix.\n\nSee also transform() and setWorldTransform().\n\nEnables view transformations if enable is true, or disables view transformations if enable is false.\n\nSee also viewTransformEnabled() and Window-Viewport Conversion.\n\nSets the painter's viewport rectangle to the given rectangle, and enables view transformations.\n\nThe viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system. Its sister, the window(), specifies the logical coordinate system.\n\nThe default viewport rectangle is the same as the device's rectangle.\n\nSee also viewport(), viewTransformEnabled(), and Window-Viewport Conversion.\n\nThis is an overloaded function.\n\nSets the painter's viewport rectangle to be the rectangle beginning at (x, y) with the given width and height.\n\nSets the painter's window to the given rectangle, and enables view transformations.\n\nThe window rectangle is part of the view transformation. The window specifies the logical coordinate system. Its sister, the viewport(), specifies the device coordinate system.\n\nThe default window rectangle is the same as the device's rectangle.\n\nSee also window(), viewTransformEnabled(), and Window-Viewport Conversion.\n\nThis is an overloaded function.\n\nSets the painter's window to the rectangle beginning at (x, y) and the given width and height.\n\nEnables transformations if enable is true, or disables transformations if enable is false. The world transformation matrix is not changed.\n\nSee also worldMatrixEnabled(), worldTransform(), and Coordinate Transformations.\n\nSets the world transformation matrix. If combine is true, the specified matrix is combined with the current matrix; otherwise it replaces the current matrix.\n\nSee also worldTransform(), transform(), and setTransform().\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nDraws the outline (strokes) the path path with the pen specified by pen\n\nSee also fillPath() and Drawing.\n\nReturns if hint is set; otherwise returns .\n\nSee also renderHints() and setRenderHint().\n\nSee also setTransform() and worldTransform().\n\nTranslates the coordinate system by the given offset; i.e. the given offset is added to points.\n\nSee also setWorldTransform() and Coordinate Transformations.\n\nThis is an overloaded function.\n\nTranslates the coordinate system by the given offset.\n\nThis is an overloaded function.\n\nTranslates the coordinate system by the vector (dx, dy).\n\nReturns if view transformation is enabled; otherwise returns false.\n\nSee also setViewTransformEnabled() and worldTransform().\n\nSee also setViewport() and setViewTransformEnabled().\n\nSee also setWindow() and setViewTransformEnabled().\n\nReturns if world transformation is enabled; otherwise returns false.\n\nSee also setWorldMatrixEnabled(), worldTransform(), and Coordinate System."
    },
    {
        "link": "https://forum.qt.io/topic/14952/render-qgraphicsscene-to-a-qprinter-to-export-pdf",
        "document": "In my experience, it is sometime useful to pass the \"source\" and \"target\" parameters to render().\n\nFor example, your example doesn't show your call to scene.setSceneRect(). Note that render() by default uses the sceneRect as the source rect, and scales it into the target rect. Other Qt docs say the sceneRect is for \"internal bookkeeping\" for picking items, but doesn't it matter here also? if you don't specify a source rect parameter to render()? In my case, the sceneRect was very large, and thus when I exported to SVG, it scaled my drawing to an infinitesimal. In your case, might there be a difference in how render() works for a physical printer and for a PDF print to a file?\n\nIt seems to me that you are not handling the responsibility to paginate (to break your drawing up into separate painting sessions (iterations) on the painter.) Could that be an issue?\n\nYou also don't say whether the PDF file is created, and what it looks like."
    },
    {
        "link": "https://doc.qt.io/qt-6/qgraphicsview.html",
        "document": "The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. More...\n\nQGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework. To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example: You can explicitly scroll to any position on the scene by using the scroll bars, or by calling centerOn(). By passing a point to centerOn(), QGraphicsView will scroll its viewport to ensure that the point is centered in the view. An overload is provided for scrolling to a QGraphicsItem, in which case QGraphicsView will see to that the center of the item is centered in the view. If all you want is to ensure that a certain area is visible, (but not necessarily centered,) you can call ensureVisible() instead. QGraphicsView can be used to visualize a whole scene, or only parts of it. The visualized area is by default detected automatically when the view is displayed for the first time (by calling QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle yourself, you can call setSceneRect(). This will adjust the scroll bars' ranges appropriately. Note that although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). QGraphicsView visualizes the scene by calling render(). By default, the items are drawn onto the viewport by using a regular QPainter, and using default render hints. To change the default render hints that QGraphicsView passes to QPainter when painting items, you can call setRenderHints(). By default, QGraphicsView provides a regular QWidget for the viewport widget. You can access this widget by calling viewport(), or you can replace it by calling setViewport(). To render using OpenGL, simply call setViewport(new QOpenGLWidget). QGraphicsView takes ownership of the viewport widget. QGraphicsView supports affine transformations, using QTransform. You can either pass a matrix to setTransform(), or you can call one of the convenience functions rotate(), scale(), translate() or shear(). The most two common transformations are scaling, which is used to implement zooming, and rotation. QGraphicsView keeps the center of the view fixed during a transformation. Because of the scene alignment (setAlignment()), translating the view will have no visual impact. You can interact with the items on the scene by using the mouse and keyboard. QGraphicsView translates the mouse and key events into scene events, (events that inherit QGraphicsSceneEvent,), and forward them to the visualized scene. In the end, it's the individual item that handles the events and reacts to them. For example, if you click on a selectable item, the item will typically let the scene know that it has been selected, and it will also redraw itself to display a selection rectangle. Similarly, if you click and drag the mouse to move a movable item, it's the item that handles the mouse moves and moves itself. Item interaction is enabled by default, and you can toggle it by calling setInteractive(). You can also provide your own custom scene interaction, by creating a subclass of QGraphicsView, and reimplementing the mouse and key event handlers. To simplify how you programmatically interact with items in the view, QGraphicsView provides the mapping functions mapToScene() and mapFromScene(), and the item accessors items() and itemAt(). These functions allow you to map points, rectangles, polygons and paths between view coordinates and scene coordinates, and to find items on the scene using view coordinates. When using a QOpenGLWidget as a viewport, stereoscopic rendering is supported. This is done using the same pattern as QOpenGLWidget::paintGL. To enable it, enable the QSurfaceFormat::StereoBuffers flag. Because of how the flag is handled internally, set QSurfaceFormat::StereoBuffers flag globally before the window is created using QSurfaceFormat::setDefaultFormat(). If the flag is enabled and there is hardware support for stereoscopic rendering, then drawBackground() and drawForeground() will be triggered twice each frame. Call QOpenGLWidget::currentTargetBuffer() to query which buffer is currently being drawn to. Note: Using an OpenGL viewport limits the ability to use QGraphicsProxyWidget. Not all combinations of widgets and styles can be supported with such a setup. You should carefully test your UI and make the necessary adjustments.\n\nSee also QGraphicsScene, QGraphicsItem, and QGraphicsSceneEvent.\n\nThis enum describes the flags that you can set for a QGraphicsView's cache mode. All painting is done directly onto the viewport. The background is cached. This affects both custom backgrounds, and backgrounds based on the backgroundBrush property. When this flag is enabled, QGraphicsView will allocate one pixmap with the full size of the viewport. The CacheMode type is a typedef for QFlags<CacheModeFlag>. It stores an OR combination of CacheModeFlag values. This enum describes the default action for the view when pressing and dragging the mouse over the viewport. Nothing happens; the mouse event is ignored. The cursor changes into a pointing hand, and dragging the mouse around will scroll the scrolbars. This mode works both in interactive and non-interactive mode. A rubber band will appear. Dragging the mouse will set the rubber band geometry, and all items covered by the rubber band are selected. This mode is disabled for non-interactive views. See also dragMode and QGraphicsScene::setSelectionArea(). This enum describes flags that you can enable to improve rendering performance in QGraphicsView. By default, none of these flags are set. Note that setting a flag usually imposes a side effect, and this effect can vary between paint devices and platforms. When rendering, QGraphicsView protects the painter state (see QPainter::save()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call QPainter::setPen() or QPainter::setBrush() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent QGraphicsView from doing the same. Disables QGraphicsView's antialiasing auto-adjustment of exposed areas. Items that render antialiased lines on the boundaries of their QGraphicsItem::boundingRect() can end up rendering parts of the line outside. To prevent rendering artifacts, QGraphicsView expands all exposed regions by 2 pixels in all directions. If you enable this flag, QGraphicsView will no longer perform these adjustments, minimizing the areas that require redrawing, which improves performance. A common side effect is that items that do draw with antialiasing can leave painting traces behind on the scene as they are moved. Since Qt 4.6, restore the old painting algorithm that calls QGraphicsView::drawItems() and QGraphicsScene::drawItems(). To be used only for compatibility with old code. The OptimizationFlags type is a typedef for QFlags<OptimizationFlag>. It stores an OR combination of OptimizationFlag values. This enums describe the possible anchors that QGraphicsView can use when the user resizes the view or when the view is transformed. No anchor, i.e. the view leaves the scene's position unchanged. The scene point at the center of the view is used as the anchor. The point under the mouse is used as the anchor. See also resizeAnchor and transformationAnchor. This enum describes how QGraphicsView updates its viewport when the scene contents change or are exposed. When any visible part of the scene changes or is reexposed, QGraphicsView will update the entire viewport. This approach is fastest when QGraphicsView spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QOpenGLWidget, and for viewports that need to disable scroll optimization. QGraphicsView will determine the minimal viewport region that requires a redraw, minimizing the time spent drawing by avoiding a redraw of areas that have not changed. This is QGraphicsView's default mode. Although this approach provides the best performance in general, if there are many small visible changes on the scene, QGraphicsView might end up spending more time finding the minimal approach than it will spend drawing. QGraphicsView will attempt to find an optimal update mode by analyzing the areas that require a redraw. The bounding rectangle of all changes in the viewport will be redrawn. This mode has the advantage that QGraphicsView searches only one region for changes, minimizing time spent determining what needs redrawing. The disadvantage is that areas that have not changed also need to be redrawn. QGraphicsView will never update its viewport when the scene changes; the user is expected to control all updates. This mode disables all (potentially slow) item visibility testing in QGraphicsView, and is suitable for scenes that either require a fixed frame rate, or where the viewport is otherwise updated externally.\n\nThis property holds the alignment of the scene in the view when the whole scene is visible. If the whole scene is visible in the view, (i.e., there are no visible scroll bars,) the view's alignment will decide where the scene will be rendered in the view. For example, if the alignment is Qt::AlignCenter, which is default, the scene will be centered in the view, and if the alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in the top-left corner of the view. This property holds the background brush of the scene. This property sets the background brush for the scene in this view. It is used to override the scene's own background, and defines the behavior of drawBackground(). To provide custom background drawing for this view, you can reimplement drawBackground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::backgroundBrush and foregroundBrush. This property holds which parts of the view are cached QGraphicsView can cache pre-rendered content in a QPixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render. Texture, gradient and alpha blended backgrounds, for example, can be notibly slow to render; especially with a transformed view. The CacheBackground flag enables caching of the view's background. For example: The cache is invalidated every time the view is transformed. However, when scrolling, only partial invalidation is required. By default, nothing is cached. See also resetCachedContent() and QPixmapCache. This property holds the behavior for dragging the mouse over the scene while the left mouse button is pressed. This property defines what should happen when the user clicks on the scene background and drags the mouse (e.g., scrolling the viewport contents using a pointing hand cursor, or selecting multiple items with a rubber band). The default value, NoDrag, does nothing. This behavior only affects mouse clicks that are not handled by any item. You can define a custom behavior by creating a subclass of QGraphicsView and reimplementing mouseMoveEvent(). This property holds the foreground brush of the scene. This property sets the foreground brush for the scene in this view. It is used to override the scene's own foreground, and defines the behavior of drawForeground(). To provide custom foreground drawing for this view, you can reimplement drawForeground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::foregroundBrush and backgroundBrush. This property holds whether the view allows scene interaction. If enabled, this view is set to allow scene interaction. Otherwise, this view will not allow interaction, and any mouse or key events are ignored (i.e., it will act as a read-only view). By default, this property is . flags that can be used to tune QGraphicsView's performance. QGraphicsView uses clipping, extra bounding rect adjustments, and certain other aids to improve rendering quality and performance for the common case graphics scene. However, depending on the target platform, the scene, and the viewport in use, some of these operations can degrade performance. The effect varies from flag to flag; see the OptimizationFlags documentation for details. By default, no optimization flags are enabled. This property holds the default render hints for the view These hints are used to initialize QPainter before each visible item is drawn. QPainter uses render hints to toggle rendering features such as antialiasing and smooth pixmap transformation. how the view should position the scene when the view is resized. QGraphicsView uses this property to decide how to position the scene in the viewport when the viewport widget's size changes. The default behavior, NoAnchor, leaves the scene's position unchanged during a resize; the top-left corner of the view will appear to be anchored while resizing. Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and transformationAnchor. This property holds the behavior for selecting items with a rubber band selection rectangle. This property defines how items are selected when using the RubberBandDrag drag mode. The default value is Qt::IntersectsItemShape; all items whose shape intersects with or is contained by the rubber band are selected. See also dragMode, items(), and rubberBandRect(). This property holds the area of the scene visualized by this view. The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars. If unset, or if a null QRectF is set, this property has the same value as QGraphicsScene::sceneRect, and it changes with QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected by the scene. Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use translate() to navigate the scene instead. By default, this property contains a rectangle at the origin with zero width and height. how the view should position the scene during transformations. QGraphicsView uses this property to decide how to position the scene in the viewport when the transformation matrix changes, and the coordinate system of the view is transformed. The default behavior, AnchorViewCenter, ensures that the scene point at the center of the view remains unchanged during transformations (e.g., when rotating, the scene will appear to rotate around the center of the view). Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and resizeAnchor. how the viewport should update its contents. QGraphicsView uses this property to decide how to update areas of the scene that have been reexposed or changed. Usually you do not need to modify this property, but there are some cases where doing so can improve rendering performance. See the ViewportUpdateMode documentation for specific details. The default value is MinimalViewportUpdate, where QGraphicsView will update as small an area of the viewport as possible when the contents change. See also ViewportUpdateMode and cacheMode.\n\nConstructs a QGraphicsView and sets the visualized scene to scene. parent is passed to QWidget's constructor. Scrolls the contents of the viewport to ensure that the scene coordinate pos, is centered in the view. Because pos is a floating point coordinate, and the scroll bars operate on integer coordinates, the centering is only an approximation. Note: If the item is close to or outside the border, it will be visible in the view, but not centered. This is an overloaded function. Scrolls the contents of the viewport to ensure that item is centered in the view. This is an overloaded function. This function is provided for convenience. It's equivalent to calling centerOn(QPointF(x, y)). Draws the background of the scene using painter, before any items and the foreground are drawn. Reimplement this function to provide a custom background for this view. If all you want is to define a color, texture or gradient for the background, you can call setBackgroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's backgroundBrush. If no such brush is defined (the default), the scene's drawBackground() function is called instead. See also drawForeground() and QGraphicsScene::drawBackground(). Draws the foreground of the scene using painter, after the background and all items are drawn. Reimplement this function to provide a custom foreground for this view. If all you want is to define a color, texture or gradient for the foreground, you can call setForegroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's foregroundBrush. If no such brush is defined (the default), the scene's drawForeground() function is called instead. See also drawBackground() and QGraphicsScene::drawForeground(). Scrolls the contents of the viewport so that the scene rectangle rect is visible, with margins specified in pixels by xmargin and ymargin. If the specified rect cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. Scrolls the contents of the viewport so that the center of item item is visible, with margins specified in pixels by xmargin and ymargin. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. This function is provided for convenience. It's equivalent to calling ensureVisible(QRectF(x, y, w, h), xmargin, ymargin). Scales the view matrix and scrolls the scroll bars to ensure that the scene rectangle rect fits inside the viewport. rect must be inside the scene rect; otherwise, fitInView() cannot guarantee that the whole rect is visible. This function keeps the view's rotation, translation, or shear. The view is scaled according to aspectRatioMode. rect will be centered in the view if it does not fit tightly. It's common to call fitInView() from inside a reimplementation of resizeEvent(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside resizeEvent() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see horizontalScrollBarPolicy() and verticalScrollBarPolicy()). If rect is empty, or if the viewport is too small, this function will do nothing. See also setTransform(), ensureVisible(), and centerOn(). This is an overloaded function. Ensures that item fits tightly inside the view, scaling the view according to aspectRatioMode. See also ensureVisible() and centerOn(). This is an overloaded function. This convenience function is equivalent to calling fitInView(QRectF(x, y, w, h), aspectRatioMode). See also ensureVisible() and centerOn(). Invalidates and schedules a redraw of layers inside rect. rect is in scene coordinates. Any cached content for layers inside rect is unconditionally invalidated and redrawn. You can call this function to notify QGraphicsView of changes to the background or the foreground of the scene. It is commonly used for scenes with tile-based backgrounds to notify changes when QGraphicsView has enabled background caching. Note that QGraphicsView currently supports background caching only (see QGraphicsView::CacheBackground). This function is equivalent to calling update() if any layer but QGraphicsScene::BackgroundLayer is passed. See also QGraphicsScene::invalidate() and update(). Returns if the view is transformed (i.e., a non-identity transform has been assigned, or the scrollbars are adjusted). See also setTransform(), horizontalScrollBar(), and verticalScrollBar(). Returns the item at position pos, which is in viewport coordinates. If there are several items at this position, this function returns the topmost item. CustomView mousePressEvent( event) { ( item itemAt(event pos())) { qDebug() item; } { qDebug( \"You didn't click on an item.\" ); } } See also items() and Sorting. This is an overloaded function. This function is provided for convenience. It's equivalent to calling itemAt(QPoint(x, y)). Returns a list of all the items in the associated scene, in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also QGraphicsScene::items() and Sorting. Returns a list of all the items at the position pos in the view. The items are listed in descending stacking order (i.e., the first item in the list is the uppermost item, and the last item is the lowermost item). pos is in viewport coordinates. This function is most commonly called from within mouse event handlers in a subclass in QGraphicsView. pos is in untransformed viewport coordinates, just like QMouseEvent::pos(). See also QGraphicsScene::items() and Sorting. This function is provided for convenience. It's equivalent to calling items(QPoint(x, y)). This convenience function is equivalent to calling items(QRectF(x, y, w, h), mode). This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with path. path is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by path are returned. See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with polygon. polygon is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by polygon are returned. The items are sorted by descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with rect. rect is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by rect are returned. The items are sorted in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This function is provided for convenience. It's equivalent to calling mapFromScene(QPointF(x, y)). This function is provided for convenience. It's equivalent to calling mapFromScene(QRectF(x, y, w, h)). Note: It can be useful to map the whole rectangle covered by the pixel at point instead of the point itself. To do this, you can call mapToScene(QRect(point, QSize(2, 2))). This function is provided for convenience. It's equivalent to calling mapToScene(QPoint(x, y)). This function is provided for convenience. It's equivalent to calling mapToScene(QRect(x, y, w, h)). Renders the source rect, which is in view coordinates, from the scene into target, which is in paint device coordinates, using painter. This function is useful for capturing the contents of the view onto a paint device, such as a QImage (e.g., to take a screenshot), or for printing to QPrinter. For example: If source is a null rect, this function will use viewport()->rect() to determine what to draw. If target is a null rect, the full dimensions of painter's paint device (e.g., for a QPrinter, the page size) will be used. The source rect contents will be transformed according to aspectRatioMode to fit into the target rect. By default, the aspect ratio is kept, and source is scaled to fit in target. Resets any cached content. Calling this function will clear QGraphicsView's cache. If the current cache mode is CacheNone, this function does nothing. This function is called automatically for you when the backgroundBrush or QGraphicsScene::backgroundBrush properties change; you only need to call this function if you have reimplemented QGraphicsScene::drawBackground() or QGraphicsView::drawBackground() to draw a custom background, and need to trigger a full redraw. Resets the view transformation to the identity matrix. See also transform() and setTransform(). See also setTransform(), transform(), scale(), shear(), and translate(). This signal is emitted when the rubber band rect is changed. The viewport Rect is specified by rubberBandRect. The drag start position and drag end position are provided in scene points with fromScenePoint and toScenePoint. When rubberband selection ends this signal will be emitted with null vales. This functions returns the current rubber band area (in viewport coordinates) if the user is currently doing an itemselection with rubber band. When the user is not using the rubber band this functions returns (a null) QRectF(). Notice that part of this QRect can be outside the visual viewport. It can e.g contain negative values. See also rubberBandSelectionMode and rubberBandChanged(). See also setTransform(), transform(), rotate(), shear(), and translate(). Returns a pointer to the scene that is currently visualized in the view. If no scene is currently visualized, is returned. Enables flag if enabled is true; otherwise disables flag. If enabled is true, the render hint hint is enabled; otherwise it is disabled. Sets the current scene to scene. If scene is already being viewed, this function does nothing. When a scene is set on a view, the QGraphicsScene::changed() signal is automatically connected to this view's updateScene() slot, and the view's scroll bars are adjusted to fit the size of the scene. The view does not take ownership of scene. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix transforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interaction with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordinate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also transform(), resetTransform(), rotate(), scale(), shear(), and translate(). This slot is called by QAbstractScrollArea after setViewport() has been called. Reimplement this function in a subclass of QGraphicsView to initialize the new viewport widget before it is used. See also setTransform(), transform(), rotate(), scale(), and translate(). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setTransform(), rotate(), scale(), shear(), and translate(). See also setTransform(), transform(), rotate(), and shear(). Schedules an update of the scene rectangles rects. Notifies QGraphicsView that the scene's scene rect has changed. rect is the new scene rect. If the view already has an explicitly set scene rect, this function does nothing. See also sceneRect and QGraphicsScene::sceneRectChanged(). See also mapToScene() and mapFromScene()."
    },
    {
        "link": "https://stackoverflow.com/questions/3803170/how-to-print-content-of-a-qgraphicsview",
        "document": "Take a look at the official Qt documentation: http://doc.qt.io/archives/4.6/graphicsview.html#printing\n\n\"Graphics View provides single-line printing through its rendering functions, and . The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a to either of the rendering functions. This example shows how to print the whole scene into a full page, using .\""
    },
    {
        "link": "https://qtcentre.org/threads/47972-Render-QGraphicsScene-to-a-QPrinter-to-export-PDF",
        "document": "\n• None printer. ; // file will be created in your build directory (where debug/release directories are)\n\nTo copy to clipboard, switch view to plain text mode"
    },
    {
        "link": "https://stackoverflow.com/questions/73461816/qgraphicsscene-artifacts-when-rendering-and-saving-the-scene-to-a-file",
        "document": "I am working with PyQt5 (Version 5.15.7) in PyCharm Community on Windows 11.\n\nI have subclassed the QGraphicsScene and added some attribute and methods I need. I add some QGraphicsItems and QGraphicsItemGroups on the scene and display it in a QMainWindow using a QGraphicsView. Now I want to store the content of the whole scene as simple PNG with transparency. I added to my QGraphicsScene subclass.\n\nI use now the following Code to render from my QGraphicsScene into a QImage and then I store the QImage:\n\nI found the code above as question here on stackoverflow and adapted it respecting to the comments. Everything is fine, BUT the PNG contains very often artifacts like this: (Enlarged screenshots from MSPaint):\n• One example with artifacts\n\nThis is the original picture taken as screenshot from my app\n\nThe PNG should look like the last screenshot...without these strange points and lines... The artifacts are sometimes really hard, sometimes they don't appear... Does anybody have an idea why these artifacts appear and how I could evade them?"
    }
]