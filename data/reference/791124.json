[
    {
        "link": "https://stackoverflow.com/questions/17955638/how-to-structure-a-library-of-c-source",
        "document": "I'm developing a collection of C++ classes and am struggling with how to share the code in a way that maintains organization without compromising ease of compilation for a user of the collection.\n\nOptions that I have seen include:\n• Put the source in the header file (with implicit inline as discussed in this answer)\n• Use symbolic links to allow the compiler to find the files.\n\nI'm currently using the third option where, for each class the I want to include I symbolic link each classess headers and source files (e.g. ) This works well except that I can't move the project folder location (it breaks all the symlinks) and I have to have all those symlinked files hanging around.\n\nI like the second option (it has the appearance of Java), but I'm worried about code size bloat if everything is declared inline.\n\nA user of the collection will create a project folder somewhere, and somehow include the collection into their compilation process.\n\nI'd like a few things to be possible:\n• Easy compilation (something like from the project folder)\n\nI'm not worried about documentation (Doxygen takes care of that) or compile time: the overall modules are small and even the largest projects on the slowest machines won't take more than a few seconds to compile.\n\nI'm using the GCC compiler, if it makes any difference."
    },
    {
        "link": "https://stackoverflow.com/questions/2732978/c-how-to-declare-a-struct-in-a-header-file",
        "document": "I've been trying to include a structure called \"student\" in a file, but I'm not quite sure how to do it.\n\nMy file code consists of entirely:\n\nwhile the file consists of entirely:\n\nUnfortunately, files that use come up with numerous errors like\n\nIt appears the compiler (VC++) does not recognize struct Student from \"student.h\"?\n\nHow can I declare struct Student in \"student.h\" so that I can just #include \"student.h\" and start using the struct?"
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/classes-and-header-files",
        "document": "All of the classes that we have written so far have been simple enough that we have been able to implement the member functions directly inside the class definition itself. For example, here’s a simple class where all member functions are defined inside the class definition:\n\nHowever, as classes get longer and more complicated, having all the member function definitions inside the class can make the class harder to manage and work with. Using an already-written class only requires understanding its public interface (the public member functions), not how the class works underneath the hood. The member function implementations clutter up the public interface with details that aren’t relevant to actually using the class.\n\nTo help address this, C++ allows us to separate the “declaration” portion of the class from the “implementation” portion by defining member functions outside of the class definition.\n\nHere is the same class as above, with the constructor and member functions defined outside the class definition. Note that the prototypes for these member functions still exist inside the class definition (as these functions need to be declared as part of the class type definition), but the actual implementation has been moved outside:\n\nMember functions can be defined outside the class definition just like non-member functions. The only difference is that we must prefix the member function names with the name of the class type (in this case, ) so the compiler knows we’re defining a member of that class type rather than a non-member.\n\nNote that we left the access functions defined inside the class definition. Because access functions are typically only one line, defining these functions inside the class definition adds minimal clutter, whereas moving them outside the class definition would result in many extra lines of code. For this reason, the definitions of access functions (and other trivial, one-line functions) are often left inside the class definition.\n\nIf you define a class inside a source (.cpp) file, that class is only usable within that particular source file. In larger programs, it’s common that we’ll want to use the classes we write in multiple source files.\n\nIn lesson 2.11 -- Header files, you learned that you can put function declarations in a header files. Then you can #include those functions declarations into multiple code files (or even multiple projects). Classes are no different. A class definitions can be put in a header files, and then #included into any other files that want to use the class type.\n\nUnlike functions, which only need a forward declaration to be used, the compiler typically needs to see the full definition of a class (or any program-defined type) in order for the type to be used. This is because the compiler needs to understand how members are declared in order to ensure they are used properly, and it needs to be able to calculate how large objects of that type are in order to instantiate them. So our header files usually contain the full definition of a class rather than just a forward declaration of the class.\n\nMost often, classes are defined in header files of the same name as the class, and any member functions defined outside of the class are put in a .cpp file of the same name as the class.\n\nHere’s our Date class again, broken into a .cpp and .h file:\n\nNow any other header or code file that wants to use the class can simply . Note that Date.cpp also needs to be compiled into any project that uses Date.h so that the linker can connect calls to the member functions to their definitions.\n\nDoesn’t defining a class in a header file violate the one-definition rule if the header is #included more than once?\n\nTypes are exempt from the part of the one-definition rule (ODR) that says you can only have one definition per program. Therefore, there isn’t an issue #including class definitions into multiple translation units. If there was, classes wouldn’t be of much use.\n\nIncluding a class definition more than once into a single translation unit is still an ODR violation. However, header guards (or ) will prevent this from happening.\n\nMember functions are not exempt from the ODR, so you may be wondering how we avoid ODR violations when member functions are defined in a header file (that may then be included into more than one translation unit).\n\nMember functions defined inside the class definition are implicitly inline. Inline functions are exempt from the one definition per program part of the one-definition rule.\n\nMember functions defined outside the class definition are not implicitly inline (and thus are subject to the one definition per program part of the one-definition rule). This is why such functions are usually defined in a code file (where they will only have one definition across the whole program).\n\nAlternatively, member functions defined outside the class definition can be left in the header file if they are made inline (using the keyword). Here’s our Date.h header again, with the member functions defined outside the class marked as :\n\nThis Date.h can be included into multiple translation units without issue.\n\nThe compiler must be able to see a full definition of a function in order to perform inline expansion. Most often, such functions (e.g. access functions) are defined inside the class definition. However, if you want to define a member function outside the class definition, but still want it to be eligible for inline expansion, you can define it as an inline function just below the class definition (in the same header file). That way the definition of the function is accessible to anybody who #includes the header.\n\nSo why not put everything in a header file?\n\nYou might be tempted to put all of your member function definitions into the header file, either inside the class definition, or as inline functions below the class definition. While this will compile, there are a couple of downsides to doing so.\n\nFirst, as mentioned above, defining members inside the class definition clutters up your class definition.\n\nSecond, if you change any of the code in the header, then you’ll need to recompile every file that includes that header. This can have a ripple effect, where one minor change causes the entire program to need to recompile. The cost of recompilation can vary significantly: a small project may only take a minute or less to build, whereas a large commercial project can take hours.\n\nConversely, if you change the code in a .cpp file, only that .cpp file needs to be recompiled. Therefore, given the choice, it’s generally better to put non-trivial code in a .cpp file when you can.\n\nThere are a few cases where it might make sense to violate the best practice of putting the class definition in a header and non-trivial member functions in a code file.\n\nFirst, for a small class that is used in only one code file and not intended for general reuse, you may prefer to define the class (and all member functions) directly in the single .cpp file it is used in. This helps make it clear that the class is only used within that single file, and is not intended for wider use. You can always move the class to a separate header/code file later if you later find you want to use it in more than one file, or are finding that the class and member function definitions are cluttering your source file.\n\nSecond, if a class only has a small number of non-trivial member functions that are unlikely to change, creating a .cpp file that contains only one or two definitions may not be worth the effort (as it clutters your project). In such cases, it may be preferable to make the member functions and place them beneath the class definition in the header.\n\nThird, in modern C++, classes or libraries are increasingly being distributed as “header-only”, meaning all of the code for the class or library is placed in a header file. This is done primarily to make distributing and using such files easier, as a header only needs to be #included, whereas a code file needs to be explicitly added to every project that uses it, so that it can be compiled. If intentionally creating a header-only class or library for distribution, all non-trivial member functions can be made and placed in the header file beneath the class definition.\n\nFinally, for template classes, template member functions defined outside the class are almost always defined inside the header file, beneath the class definition. Just like non-member template functions, the compiler needs to see the full template definition in order to instantiate it. We cover template member functions in lesson 15.5 -- Class templates with member functions.\n\nIn lesson 11.5 -- Default arguments, we discussed the best practice for default arguments of non-member functions: “If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.”\n\nBecause member functions are always declared (or defined) as part of the class definition, the best practice for member functions is actually simpler: always put the default argument inside the class definition.\n\nThroughout your programs, you’ve used classes that are part of the standard library, such as . To use these classes, you simply need to #include the relevant header (such as ). Note that you haven’t needed to add any code files (such as or ) into your projects.\n\nThe header files provide the declarations that the compiler requires in order to validate that the programs you’re writing are syntactically correct. However, the implementations for the classes that belong to the C++ standard library are contained in a precompiled file that is linked in automatically at the link stage. You never see the code.\n\nMany open source software packages provide both .h and .cpp files for you to compile into your program. However, most commercial libraries provide only .h files and a precompiled library file. There are several reasons for this: 1) It’s faster to link a precompiled library than to recompile it every time you need it, 2) A single copy of a precompiled library can be shared by many applications, whereas compiled code gets compiled into every executable that uses it (inflating file sizes), and 3) Intellectual property reasons (you don’t want people stealing your code).\n\nWe discuss how to include 3rd party precompiled libraries into your projects in the appendix.\n\nWhile you probably won’t be creating and distributing your own libraries for a while, separating your classes into header files and source files is not only good form, it also makes creating your own custom libraries easier. Creating your own libraries is beyond the scope of these tutorials, but separating your declaration and implementation is a prerequisite to doing so if you want to distribute precompiled binaries.\n\nh/t to reader “learnccp lesson reviewer” for these quiz questions.\n\nWhat is the purpose of defining member functions outside the class definition?\n\na) To make the class definition shorter and easier to manage.\n\nb) To separate the public interface from the implementation details.\n\nc) When defined in a source file, to minimize recompilation times when an implementation detail changes.\n\nd) All of the above.\n\nd) All of the above.\n\nHow do you define a member function outside the class definition?\n\na) Simply define the function as a normal function without any class prefix.\n\nb) Define the function with the class name prefixed using the scope resolution operator (::).\n\nc) Declare the function inside the class definition and define it outside using the friend keyword.\n\nd) None of the above.\n\nb) Define the function with the class name prefixed using the scope resolution operator (::).\n\nWhen should trivial member functions be defined inside the class definition?\n\na) Always, to improve performance.\n\nb) When the functions have a single line of code.\n\nc) When the functions are called frequently.\n\nd) It is not recommended to define any member functions inside the class definition.\n\nb) When the functions have a single line of code.\n\nWhere should the class definition be placed to facilitate reuse in multiple files or projects?\n\na) In a .cpp file with the same name as the class.\n\nb) In a separate header file with the same name as the class.\n\nc) In a .cpp file that includes the header file.\n\nd) Anywhere in the code, as long as the functions are defined outside the class.\n\nb) In a separate header file with the same name as the class.\n\nWhich of the following is true about the one-definition rule for classes and member functions?\n\na) It prohibits defining a class in a header file.\n\nb) It allows including the class definition multiple times in the same file.\n\nc) Member functions defined inside the class definition are exempt from the one-definition rule.\n\nd) Non-trivial member functions should always be defined in the header file.\n\nc). Member functions defined inside the class definition are implicitly inline, and thus exempt from the one-definition rule."
    },
    {
        "link": "https://geeksforgeeks.org/how-do-i-create-a-library-in-cpp",
        "document": "How Do I Create a Library in C++?\n\nLibraries are reusable code packages that can be imported into our program to use the code defined in them. In C++, libraries can be either static or dynamic. A static library is a library that is linked to the program at compile-time whereas dynamic libraries in C++ are linked at runtime but they have the advantage that they don’t get included in the executable file, which keeps the executable size low. In this article, we will learn how to create a library in C++.\n\nTo create a static library in a G++ compiler, follow the below steps:\n\nFirst, open your preferred text editor or IDE and start off by creating a new header file with the .h a and declaring the functions that we want to have in the library.\n\nNow, create another file that is the source code file with .cpp extension and write the function body of the function that we declared in the header file.\n\nCompile the source code into object files. By opening the terminal in the directory containing the source code file (math_operations.cpp) and run the following command:\n\nThis command generates an object file (math_operations.o) from the source code.\n\nUse the ar (archive) command to bundle the object files into a static library and create a static library named libmath_operations.a from the object file math_operations.o. Run the following command:\n\nThis command creates the static library, and its is now ready to use in our program.\n\nWrite a Main Program that Uses the Static Library\n\nNow, we can use the created static library in another C++ program.\n\n5. Compile the Main Program Using the Static Library\n\nRun the following command to compile the main.cpp file and link it with the static library:\n\nThis command links the main.cpp file with your static library (-lmath_operations ) and produces an executable named main_executable.\n\nRun the compiled program using following command:\n\nTo create a dynamic library in G++ compiler, follow the below steps:\n\nSimilar to the static library, we start by creating a header file with the .h extension and a source file with the .cpp extension.\n\nCompile the Library Source Code to an Object File\n\nOpen a terminal in the directory containing and run the following command:\n\nThis command generates an object file ( ) from the source code.\n\nUse the compiler to create a dynamic library named from the object file . Run the following command:\n\nThis command creates the dynamic library, and it is now ready to use in our program.\n\nWrite a Main Program that Uses the Dynamic Library\n\nCreate a new file named that uses the functions from the dynamic library.\n\nCompile the file and link it with the dynamic library. For this, run the following command:\n\nThis command links the file with your dynamic library ( ) and produces an executable named ."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/13v0gar/how_should_i_structure_my_c_classes_that_are",
        "document": "I have 2 small classes ; Alien and Alien bomb to be used in AlienSwarm class with a \"Has-A\" relationship. These 2 classes (Aliend & Alien bomb) will have properties and getters, setters, maybe some basic functions as well.\n\nThese classes are dependent to each other and when used in other files, most likely will be used together.\n\nI am trying to decide which method is better than the other.\n\n1)Separating all classes to their own .h and .cpp files. Like Alien.h & cpp, AlienBomb.h & cpp, AlienSwarm.h & cpp.\n\n2) Declaring these classes in one header and .cpp all together since they have rather close relationship and small code size. So, we do not use lots of small header and cpp files.\n\nHere my current code which uses the latter method :"
    },
    {
        "link": "https://stackoverflow.com/questions/5947067/how-to-create-a-static-library-with-g",
        "document": "You can create a file using the utility, like so:\n\nis a directory that contains all your libraries. it is good practice to organise your code this way and separate the code and the object files. Having everything in one directory generally looks ugly. The above line creates in the directory . So, in your current directory, do:\n\nThen run the above command.\n\nWhen linking all libraries, you can do it like so:\n\nThe flag will get to add the directory to the path. This way, knows what directory to search when looking for . flags the specific library to link.\n\nwhere test.o is created like so:"
    },
    {
        "link": "https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/developer_guide/gcc-using-libraries",
        "document": "This chapter describes how to use libraries in code.\n\nDevelopers have a choice of using static or dynamic linking when building applications with fully compiled languages. This section lists the differences, particularly in the contexti of using the C and C++ languages on Red Hat Enterprise Linux. To summarize, Red Hat discourages the use of static linking in applications for Red Hat Enterprise Linux. Static linking makes libraries part of the resulting executable file. Dynamic linking keeps these libraries as separate files. Dynamic and static linking can be compared in a number of ways: Static linking results in larger executable files which contain more code. This additional code coming from libraries cannot be shared across multiple programs on the system, increasing file system usage and memory usage at run time. Multiple processes running the same statically linked program will still share the code. On the other hand, static applications need fewer run-time relocations, leading to reduced startup time, and require less private resident set size (RSS) memory. Generated code for static linking can be more efficient than for dynamic linking due to the overhead introduced by position-independent code (PIC). Dynamically linked libraries which provide ABI compatibility can be updated without changing the executable files depending on these libraries. This is especially important for libraries provided by Red Hat as part of Red Hat Enterprise Linux, where Red Hat provides security updates. Static linking against any such libraries is strongly discouraged. Additionally, security measures such as load address randomization cannot be used with a statically linked executable file. This further reduces security of the resulting application. Static linking appears to provide executable files independent of the versions of libraries provided by the operating system. However, most libraries depend on other libraries. With static linking, this dependency becomes inflexible and as a result, both forward and backward compatibility is lost. Static linking is guaranteed to work only on the system where the executable file was built. Applications linking static libraries from the GNU C library (glibc) still require glibc to be present on the system as a dynamic library. Furthermore, the dynamic library variant of glibc available at the application’s run time must be a bitwise identical version of the one present while linking the application. As a result, static linking is guaranteed to work only on the system where the executable file was built. Most static libraries provided by Red Hat are in the channel and not supported by Red Hat. Some libraries, notably the GNU C Library (glibc), offer reduced functionality when linked statically. For example, when statically linked, glibc does not support threads and any form of calls to the function in the same program. As a result of the listed disadvantages, static linking should be avoided at all costs, particularly for whole applications and the glibc and libstdc++ libraries. The compat-glibc package is included with Red Hat Enterprise Linux 7, but it is not a run time package and therefore not required for running anything. It is solely a development package, containing header files and dummy libraries for linking. This allows compiling and linking packages to run in older Red Hat Enterprise Linux versions (using compat-gcc-\\* against those headers and libraries). For more information on use of this package, run: . Static linking might be a reasonable choice in some cases, such as:\n• A library which is not enabled for dynamic linking\n• Fully static linking can be required for running code in an empty environment or container. However, static linking using the package is not supported by Red Hat.\n\nA library is a package of code which can be reused in your program. A C or C++ library consists of two parts: The header files describe the interface of the library: The functions and variables available in the library. Information from the header files is needed for compiling the code. Typically, header files of a library will be placed in a different directory than your application’s code. To tell GCC where the header files are, use the option: Replace include_path with the actual path to the header file directory. The option can be used multiple times to add multiple directories with header files. When looking for a header file, these directories are searched in the order of their appearance in the options. When linking an executable file, both the object code of your application and the binary code of the library must be available. The code for static and dynamic libraries is present in different forms:\n• Static libraries are available as archive files. They contain a group of object files. The archive file has the file name extension .\n• Dynamic libraries are available as shared objects. They are a form of executable file. A shared object has the file name extension . To tell GCC where the archives or shared object files of a library are, use the option: Replace library_path with the actual path to the library directory. The option can be used multiple times to add multiple directories. When looking for a library, these directories are searched in the order of their options. The order of options matters: GCC cannot link against a library foo unless it knows the directory of this library. Therefore, use the options to specify library directories before using the options for linking against libraries. Compiling and Linking Code Which Uses a Library in One Step When the situation allows the code to be compiled and linked in one command, use the options for both situations mentioned above at once.\n• Using the GNU Compiler Collection (GCC) — 3.16 Options for Directory Search\n• Using the GNU Compiler Collection (GCC) — 3.15 Options for Linking\n\nStatic libraries are available as archives containing object files. After linking, they become part of the resulting executable file. Red Hat discourages the use of static linking for various reasons. See Section 16.2, “Static and dynamic linking”. Use static linking only when necessary, especially against libraries provided by Red Hat.\n• GCC is installed on your system\n• A set of source or object files forming a valid program, requiring some static library and no other libraries\n• The library is available as a file , and no file is provided for dynamic linking. Most libraries which are part of Red Hat Enterprise Linux are supported for dynamic linking only. The steps below only work for libraries which are not enabled for dynamic linking. See Section 16.6, “Using Both Static and Dynamic Libraries with GCC”. To link a program from source and object files, add a statically linked library foo, which is named :\n• Change to the directory containing your code.\n• None Compile the program source files with headers of the foo library: Replace header_path with the path to the directory containing the header files for the foo library.\n• None Link the program with the foo library: Replace library_path with the path to the directory containing the file . The GCC option related to static linking forbids all dynamic linking. Instead, use the and options to control linker behavior more precisely. See Section 16.6, “Using Both Static and Dynamic Libraries with GCC”.\n\nDynamic libraries are available as standalone executable files, required at both linking time and run time. They stay independent of your application’s executable file.\n• GCC is installed on the system\n• A set of source or object files forming a valid program, requiring some dynamic library and no other libraries\n• The library available as a file When a program is linked against a dynamic library, the resulting program must always load the library at run time. There are two options for locating the library:\n• Using an value stored in the executable file itself\n• Using the variable at runtime Using an Value Stored in the Executable File The is a special value saved as a part of an executable file when it is being linked. Later, when the program is loaded from its executable file, the runtime linker will use the value to locate the library files. While linking with GCC, to store the path library_path as an : The path library_path must point to a directory containing the file libfoo.so. There is no space after the comma in the option To run the program later, execute: If no is found in the program’s executable file, the runtime linker will use the environment variable. The value of this variable must be changed for each program according to the path where the shared library objects are located. To run the program without set, with libraries present in the library_path, execute: Leaving out the value offers flexibility, but requires setting the variable every time the program is to run. Placing the Library into the Default Directories The runtime linker configuration specifies a number of directories as a default location of dynamic library files. To use this default behaviour, copy your library to the appropriate directory. A full description of the dynamic linker behavior is out of scope for this document. For more information, see the following resources:\n• None Report of the libraries recognized by the dynamic linker without additional configuration, which includes directories:\n\n16.6. Using Both Static and Dynamic Libraries with GCC Sometimes it is required to link some libraries statically and some dynamically. gcc recognizes both dynamic and static libraries. When the option is encountered, gcc will first attempt to locate a shared object (a file) containing a dynamically linked version of the foo library, and then look for the archive file ( ) containing a static version of the library. Thus, the following situations can result from this search:\n• Only the shared object is found and links against it dynamically\n• Only the archive is found and links against it statically\n• Both the shared object and archive are found; selects by default dynamic linking against the shared object\n• Neither shared object nor archive is found and linking fails Because of these rules, the best way to select the static or dynamic version of a library for linking is having only that version found by gcc. This can be controlled to some extent by using or leaving out directories containing the library versions when specifying the options. Additionally, because dynamic linking is the default, the only situation where linking must be explicitly specified is when a library with both versions present should be linked statically. There are two possible solutions:\n• Specifying the static libraries by file path instead of the option\n• Using the option to pass options to the linker Specifying the static libraries by file Usually, gcc is instructed to link against a library foo with the option. However, it is possible to specify the full path to the file containing the library instead: From the file extension , gcc will understand that this is a library to link with the program. However, specifying the full path to the library file is a less flexible method. The gcc option is a special option for passing options to the underlying linker. Syntax of this option differs from the other gcc options. The -Wl option is followed by a comma-separated list of linker options, while other gcc options require a space-separated list of options. The ld linker used by gcc offers the options and to specify whether libraries following this option should be linked statically or dynamically, respectively. After passing and a library to the linker, the default dynamic linking behaviour must be restored manually for the following libraries to be linked dynamically with the option. To link a program, linking a library first statically ( ) and second dynamically ( ), run: gcc can be configured to use linkers other than the default ld. The option applies to the gold linker, too.\n• Using the GNU Compiler Collection (GCC) — 3.15 Options for Linking"
    },
    {
        "link": "https://stackoverflow.com/questions/17252946/creating-shared-and-static-libraries-using-g-under-windows",
        "document": "How do I create static and dynamic libraries for Windows using g++?\n\nI've found a few commands for Linux for creating files and I've tried to apply them on a Windows shell, but they build files that my applications fail to link with at runtime.\n\nI've only managed to build files using Visual C++ but I would like to build them manually on the command line, preferably using . I would also like to know how to build static libraries too for Windows."
    },
    {
        "link": "https://iram.fr/~roche/code/c++/AddNumbers.html",
        "document": "Create and use static and shared C++ libraries\n\nThe goal of this document is to explain how to compile, link and use static and shared C++ libraries using g++ (GNU GCC) and ar (GNU ar) commands. If you are not familiar to g++ read first the create a simple C++ program tutorial.\n\nClick on following links to download the AddNumbers examples: AddNumbers.tar.bz2 and AddNumbersClient.tar.bz2.\n\nLet us write a simple code for the AddNumbers library that allow to store and add two integers. It is composed of both interface and source files.\n\nFirst the source file src/AddNumbers.cpp is turned into an object file.\n\nA static library is basically a set of object files that were copied into a single file. It is created invoking the archiver ar. The library name must start with the three letters lib and have the suffix .a.\n\nYou can also write similar rules in a makefile. See the file Makefile.static given in the AddNumbers.tar.bz2 archive.\n\nRefer to useful options of g++ for details.\n\nThe -fpic option tells g++ to create position independant code which is needed for shared libraries.\n\nFinally the shared library is created. Note the library name must start with the three letters lib and have the suffix .so.\n\nAs a makefile example see the file Makefile.shared given in the AddNumbers.tar.bz2 archive.\n\nRefer to useful options of g++ for details.\n\nCommands nm and c++filt allow to list and demangle C++ symbols from object files. Let us try those commands with the static library libAddNumbers.a.\n\nIt means the library libAddNumbers.a has been built with the AddNumbers.o object file that contains some symbols. First column is the symbol value (it represent the position of the symbol in the library). The second column is the symbol type. And the third column is the symbol name.\n\nSee the following table that describe some usual symbol types.\n\nSee the nm manual for more details. Symbols are not human comprehensible. It is with the fact C++ language provides function overloading, which means that you can write many functions with the same name (providing each takes parameters of different types). All C++ function names are encoded into a low-level assembly label (this process is known as mangling). The c++filt program does the inverse mapping: it decodes (demangling process) low-level names into user-level names.\n\nThe program nm allow to directly demangle symbols using the -C option.\n\nSee useful options of nm for more options.\n\nThis section describes how to use static or shared libraries in programs. First we need to create a main program.\n\nTo link this program against the static library, write the following command that compile and link the main executable.\n\nNote that the first three letters lib as well as the suffix .a are not specified for the name of the library. Now the program AddNumbersClient_static can be executed.\n\nTo link against the shared library, enter the following command.\n\nThe first three letters lib as well as the suffix .so are not specified for the name of the library. To run the program AddNumbersClient_shared you need to tell to the LD_LIBRARY_PATH environment variable where found the shared library.\n\nIn the real world it is better to use an absolute path for LD_LIBRARY_PATH.\n\nAs makefile examples see Makefile.static and Makefile.shared files given in the AddNumbersClient.tar.bz2 archive.\n\nThe command ldd prints the shared libraries required by each program or shared library specified on the command line.\n\nThe GNU ar program creates, modifies, and extracts from archives. An archive is a single file holding a collection of other files in a structure that makes it possible to retrieve the original individual files (called members of the archive). The original files'contents, mode (permissions), timestamp, owner, and group are preserved in the archive, and can be restored on extraction.\n\nThe GNU nm program lists the symbols from object files objfile."
    },
    {
        "link": "https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html",
        "document": "These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.\n\nThis option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually. If is ‘ ’, code generation produces a static binary. In this case and are both disabled. If is ‘ ’, code generation produces a shared library. In this case or is preserved, but not enabled automatically. This allows to build shared libraries without position-independent code on architectures where this is possible, i.e. on x86. If is ‘ ’, code generation produces an executable. This results in similar optimizations as ‘ ’ except that is not disabled if specified at compilation time. If is ‘ ’, the compiler assumes that incremental linking is done. The sections containing intermediate code for link-time optimization are merged, pre-optimized, and output to the resulting object file. In addition, if is specified, binary code is produced for future non-LTO linking. The object file produced by incremental linking is smaller than a static library produced from the same object files. At link time the result of incremental linking also loads faster than a static library assuming that the majority of objects in the library are used. Finally ‘ ’ configures the compiler for incremental linking where code generation is forced, a final binary is produced, and the intermediate code for later link-time optimization is stripped. When multiple object files are linked together the resulting code is better optimized than with link-time optimizations disabled (for example, cross-module inlining happens), but most of benefits of whole program optimizations are lost. During the incremental link (by ) the linker plugin defaults to . With current interfaces to GNU Binutils it is however not possible to incrementally link LTO objects and non-LTO objects into a single mixed object file. If any of object files in incremental link cannot be used for link-time optimization, the linker plugin issues a warning and uses ‘ ’. To maintain whole program optimization, it is recommended to link such objects into static library instead. Alternatively it is possible to use H.J. Lu’s binutils with support for mixed objects.\n\nSearch the library named when linking. (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.) The option is passed directly to the linker by GCC. Refer to your linker documentation for exact details. The general description below applies to the GNU linker. The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with . Static libraries are archives of object files, and have file names like . Some targets also support shared libraries, which typically have names like . If both static and shared libraries are found, the linker gives preference to linking with the shared library unless the option is used. It makes a difference where in the command you write this option; the linker searches and processes libraries and object files in the order they are specified. Thus, ‘ ’ searches library ‘ ’ after file but before . If refers to functions in ‘ ’, those functions may not be loaded.\n\nDo not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as or , are ignored. The compiler may generate calls to , , and . These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified. One of the standard libraries bypassed by and is , a library of internal subroutines which GCC uses to overcome shortcomings of particular machines, or special needs for some languages. (See Interfacing to GCC Output in , for more discussion of .) In most cases, you need even when you want to avoid other standard libraries. In other words, when you specify or you should usually specify as well. This ensures that you have no unresolved references to internal GCC library subroutines. (An example of such an internal subroutine is , used to ensure C++ constructors are called; see in .)\n\nOn systems that provide as a shared library, these options force the use of either the shared or static version, respectively. If no shared version of was built when the compiler was configured, these options have no effect. There are several situations in which an application should use the shared instead of the static version. The most common of these is when the application wishes to throw and catch exceptions across different shared libraries. In that case, each of the libraries as well as the application itself should use the shared . Therefore, the G++ driver automatically adds whenever you build a shared library or a main executable, because C++ programs typically use exceptions, so this is the right thing to do. If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared . If GCC finds, at its configuration time, that you have a non-GNU linker or a GNU linker that does not support option , it links the shared version of into shared libraries by default. Otherwise, it takes advantage of the linker and optimizes away the linking with the shared version of , linking with the static version of libgcc by default. This allows exceptions to propagate through such shared libraries, without incurring relocation costs at library load time. However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option , such that it is linked with the shared .\n\nPass as an option to the linker. You can use this to supply system-specific linker options that GCC does not recognize. If you want to pass an option that takes a separate argument, you must use twice, once for the option and once for the argument. For example, to pass , you must write . It does not work to write , because this passes the entire string as a single argument, which is not what the linker expects. When using the GNU linker, it is usually more convenient to pass arguments to linker options using the syntax than as separate arguments. For example, you can specify rather than . Other linkers may not support this syntax for command-line options."
    }
]