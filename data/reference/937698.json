[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals",
        "document": "Template literals are literals delimited with backtick ( ) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal.\n\nTemplate literals are enclosed by backtick ( ) characters instead of double or single quotes. Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: . The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string. To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal. To escape a backtick in a template literal, put a backslash ( ) before the backtick. Dollar signs can be escaped as well to prevent interpolation.\n\nAny newline characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings: Using template literals, you can do the same with this: Like normal string literals, you can write a single-line string across multiple lines for source code readability, by escaping the newline with a backslash ( ):\n\nIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an placeholder within the template. For example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following: With a template literal but without nesting, you could do this: With nesting of template literals, you can do this:\n\nA more advanced form of template literals are tagged templates. Tags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions. The tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.) The name of the function used for the tag can be whatever you want. const person = \"Mike\"; const age = 28; function myTag(strings, personExp, ageExp) { const str0 = strings[0]; // \"That \" const str1 = strings[1]; // \" is a \" const str2 = strings[2]; // \".\" const ageStr = ageExp < 100 ? \"youngster\" : \"centenarian\"; // We can even return a string built using a template literal return `${str0}${personExp}${str1}${ageStr}${str2}`; } const output = myTag`That ${person} is a ${age}.`; console.log(output); // That Mike is a youngster. The tag does not have to be a plain identifier. You can use any expression with precedence greater than 16, which includes property access, function call, new expression, or even another tagged template literal. console.log`Hello`; // [ 'Hello' ] console.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ] new Function(\"console.log(arguments)\")`Hello`; // [Arguments] { '0': [ 'Hello' ] } function recursive(strings, ...values) { console.log(strings, values); return recursive; } recursive`Hello``World`; // [ 'Hello' ] [] // [ 'World' ] [] While technically permitted by the syntax, untagged template literals are strings and will throw a when chained. console.log(`Hello``World`); // TypeError: \"Hello\" is not a function The only exception is optional chaining, which will throw a syntax error. Note that these two expressions are still parsable. This means they would not be subject to automatic semicolon insertion, which will only insert semicolons to fix code that's otherwise unparsable. Tag functions don't even need to return a string! function template(strings, ...keys) { return (...values) => { const dict = values[values.length - 1] || {}; const result = [strings[0]]; keys.forEach((key, i) => { const value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); }); return result.join(\"\"); }; } const t1Closure = template`${0}${1}${0}!`; // const t1Closure = template([\"\",\"\",\"\",\"!\"],0,1,0); t1Closure(\"Y\", \"A\"); // \"YAY!\" const t2Closure = template`${0} ${\"foo\"}!`; // const t2Closure = template([\"\",\" \",\"!\"],0,\"foo\"); t2Closure(\"Hello\", { foo: \"World\" }); // \"Hello World!\" const t3Closure = template`I'm ${\"name\"}. I'm almost ${\"age\"} years old.`; // const t3Closure = template([\"I'm \", \". I'm almost \", \" years old.\"], \"name\", \"age\"); t3Closure(\"foo\", { name: \"MDN\", age: 30 }); // \"I'm MDN. I'm almost 30 years old.\" t3Closure({ name: \"MDN\", age: 30 }); // \"I'm MDN. I'm almost 30 years old.\" The first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of ) plus one, and is therefore always non-empty. For any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated. const callHistory = []; function tag(strings, ...values) { callHistory.push(strings); // Return a freshly made object return {}; } function evaluateLiteral() { return tag`Hello, ${\"world\"}!`; } console.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object console.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array This allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its property are both frozen, so you can't mutate them in any way.\n\nThe special property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing escape sequences. function tag(strings) { console.log(strings.raw[0]); } tag`string text line 1 \n\n string text line 2`; // Logs \"string text line 1 \n\n string text line 2\", // including the two characters '\\' and 'n' In addition, the method exists to create raw strings just like the default template function and string concatenation would create. functions like an \"identity\" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the \"cooked\" (i.e. escape sequences are processed) literal array to , pretending they are raw strings. This is useful for many tools which give special treatment to literals tagged by a particular name. const html = (strings, ...values) => String.raw({ raw: strings }, ...values); // Some formatters will format this literal's content as HTML const doc = html`<!doctype html> <html lang=\"en-US\"> <head> <title>Hello</title> </head> <body> <h1>Hello world!</h1> </body> </html>`;\n\nIn normal template literals, the escape sequences in string literals are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:\n• followed by any decimal digit other than , or followed by a decimal digit; for example and (which is a deprecated syntax)\n• followed by fewer than two hex digits (including none); for example\n• not followed by and followed by fewer than four hex digits (including none); for example\n• enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than ; for example and Note: followed by other characters, while they may be useless since nothing is escaped, are not syntax errors. However, this is problematic for tagged templates, which, in addition to the \"cooked\" literal, also have access to the raw literals (escape sequences are preserved as-is). Tagged templates enable the embedding of arbitrary string content, where escape sequences may follow a different syntax. Consider for an example where we embed LaTeX source text in JavaScript via . We want to still be able to use LaTeX macros that start with or without following JavaScript syntax restrictions. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates. The example below uses MathJax to render LaTeX in one element: However, illegal escape sequences must still be represented in the \"cooked\" representation. They will show up as element in the \"cooked\" array: Note that the escape-sequence restriction is only dropped from tagged templates, but not from untagged template literals:"
    },
    {
        "link": "https://w3schools.com/js/js_string_templates.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/1408289/string-interpolation-in-javascript",
        "document": "There is no direct way to do it, as per ECMAScript 5 specifications, but ECMAScript 6 has template strings, which were also known as quasi-literals during the drafting of the spec. Use them like this:\n\nYou can use any valid JavaScript expression inside the . For example:\n\nThe other important thing is, you don't have to worry about multi-line strings anymore. You can write them simply as\n\nNote: I used io.js v2.4.0 to evaluate all the template strings shown above. You can also use the latest Chrome to test the above shown examples.\n\nNote: ES6 Specifications are now finalized, but have yet to be implemented by all major browsers. \n\nAccording to the Mozilla Developer Network pages, this will be implemented for basic support starting in the following versions: Firefox 34, Chrome 41, Internet Explorer 12. If you're an Opera, Safari, or Internet Explorer user and are curious about this now, this test bed can be used to play around until everyone gets support for this."
    },
    {
        "link": "https://mimo.org/glossary/javascript/template-literals",
        "document": "JavaScript template literals provide a modern and flexible way to handle strings. They allow for string interpolation, multi-line strings, and embedded expressions, making them a powerful alternative to traditional concatenation.\n\nHow to Use Template Literals in JavaScript\n\nTemplate literals are enclosed in backticks (````) instead of quotes ( or ). They support string interpolation, allowing variables and expressions to be inserted using .\n\nIn this example, the variable is inserted into the string without using concatenation, making the code easier to read and maintain.\n\nUnlike traditional strings, template literals let you write multi-line strings without needing escape characters ( ).\n\nBy using backticks, you can preserve line breaks directly in the string, improving readability.\n\nWhen to Use Template Literals in JavaScript\n\nTemplate literals improve readability and maintainability, especially when dealing with dynamic content. Some common use cases include:\n• Multi-line strings to format text across multiple lines without escape characters.\n\nInstead of manually concatenating strings, template literals allow you to insert variables directly into a string.\n\nThis approach makes the code shorter and easier to understand compared to using the operator.\n\nYou can use ternary operators within template literals for simple conditional logic.\n\nThis eliminates the need for extra statements when constructing strings dynamically.\n\nBy using template literals, you avoid the repetitive operator, making the code more readable.\n\nThis approach allows you to write structured HTML without needing concatenation or escape characters.\n\nYou can combine conditions and expressions inside template literals.\n\nThis keeps logic inside the template and avoids separate variable assignments.\n\nTagged template literals process template strings using a function before outputting them.\n\nHere, the function modifies the output before displaying it, which can be useful for styling or formatting.\n\nUsing JavaScript Template Literals with an If Statement\n\nThis keeps the conditional logic inside the string declaration, making it easier to follow.\n\nThis makes functions that return messages or logs much simpler.\n\nThis allows mathematical expressions to be directly embedded inside strings.\n\nThis is useful when dynamically generating JSON from objects.\n\nYou can loop through arrays inside template literals.\n\nInstead of manually concatenating array elements, is used to create a readable list.\n\nYou can generate CSS styles dynamically using template literals.\n\nThis is useful for applying styles dynamically in JavaScript applications.\n\nThis approach makes it easier to build queries dynamically based on input values.\n\nJavaScript template literals provide a more flexible and readable way to handle strings compared to traditional concatenation. They allow variables, expressions, and multi-line text to be embedded directly into strings using backticks."
    },
    {
        "link": "https://geeksforgeeks.org/string-interpolation-in-javascript",
        "document": "These are the following ways to interpolate the given strings:\n\nTemplate literals are the most modern and preferred method for string interpolation in JavaScript. They use backticks (“ ` “) and ${} syntax to embed expressions.\n\nBefore ES6, string interpolation was achieved using the + operator to concatenate strings and variables.\n\nThe String.concat() method can also be used for string concatenation, though it’s less commonly used for interpolation.\n\nYou can use an array and the join() method to interpolate strings, though this is less common and more verbose.\n\nA custom function can be used to handle string interpolation, especially if the string structure is complex or repeated.\n\nTagged template literals allow you to parse template literals with a function."
    },
    {
        "link": "https://syncfusion.com/blogs/post/top-javascript-naming-convention",
        "document": "Following standard naming conventions increases readability and makes it easier to understand your code. However, many developers are not aware of how to use naming conventions correctly, and sometimes they make things complicated.\n\nIn this article, I will discuss 10 JavaScript naming convention best practices you should follow.\n\nJavaScript variable names are case-sensitive. Lowercase and uppercase letters are distinct. For example, you can define three unique variables to store a dog name, as follows.\n\nHowever, the most recommended way to declare JavaScript variables is with camel case variable names. You can use the camel case naming convention for all types of variables in JavaScript, and it will ensure that there aren’t multiple variables with the same name.\n\nThe names of variables should be self-explanatory and describe the stored value. For example, if you need a variable to store a dog’s name, you should use dogName instead of just Name since it is more meaningful.\n\nWhen it comes to Boolean variables, we should use is or has as prefixes. For example, if you need a Boolean variable to check if a dog has an owner, you should use hasOwner as the variable name.\n\nJavaScript function names are also case-sensitive. So, similar to variables, the camel case approach is the recommended way to declare function names.\n\nIn addition to that, you should use descriptive nouns and verbs as prefixes. For example, if we declare a function to retrieve a name, the function name should be getName.\n\nJavaScript constants are also case-sensitive. However, these constants should be written in uppercase because they are nonchanging variables.\n\nIf the variable declaration name contains more than one word, you should use SCREAMING_SNAKE_CASE\n\nAll the constants should be defined at the start of your file, method, or class.\n\nNaming convention rules for JavaScript classes are pretty similar to functions. We have to use descriptive titles that explain the class’s capabilities.\n\nThe major difference between function and class names is that we have to use Pascal case for class names.\n\nJavaScript components are widely used in front-end frameworks like React. Although components are used in the DOM, treating them similarly to classes and using Pascal case to define names is recommended.\n\nSince the initial letter is always written in uppercase, a component stands out from native HTML and web components when utilized.\n\nAlthough there are some differences, the structure of a JavaScript function and a method are pretty similar. So, naming convention rules are the same.\n\nWe must use camel case to declare JavaScript methods and use verbs as prefixes to make names more meaningful.\n\nUnderscores ( _ ) are widely used in languages like MySQL and PHP to define variables, functions, and methods. But in JavaScript, an underscore is used to denote private variables or functions.\n\nFor example, if you have a private function name like toonName, you can denote it as a private function by adding an underscore as a prefix (_toonName).\n\nFor global JavaScript variables, there are no specific naming standards.\n\nIt is recommended to use camel case for mutable global variables and uppercase for immutable global variables.\n\nMost web servers (Apache, Unix) are case-sensitive when it comes to handling files. For example, flower.jpg isn’t Flower.jpg.\n\nOn the other hand, web servers, such as Microsoft’s IIS, do not care about the case. In such servers, you can use Flower.jpg or flower.jpg to access Flower.jpg.\n\nHowever, if you switch from a case-insensitive server to a case-sensitive server, even a tiny mistake can cause your website to crash.\n\nSo, it is recommended to use lowercase file names in all servers despite their case-sensitive support.\n\nIn this article, I discussed 10 JavaScript naming conventions that can be used to improve our coding skills. As developers, we should always adhere to best practices since that will increase readability and make it easier for you and your team to understand your code.\n\nI hope those suggestions will help you improve your coding skills. Thank you for reading.\n\nThe Syncfusion JavaScript suite will be the only suite you will ever need to build an application. It contains over 80 high-performance, lightweight, modular, and responsive UI components in a single package. Download the FREE trial and evaluate the controls today.\n\nIf you have any questions or comments, you can contact us through our support forums, support portal, or feedback portal. We are always happy to assist you!"
    },
    {
        "link": "https://medium.com/@laddhaanshul/variable-naming-best-practices-in-javascript-458d31d3a60d",
        "document": "When writing JavaScript code, one of the simplest yet most crucial aspects of ensuring readability, maintainability, and avoidable errors is choosing clear and meaningful variable names. Bad variable names can make even the most logical code difficult to understand, while good naming can enhance clarity and save time in debugging and collaboration.\n\nIn this post, we’ll explore some best practices for naming variables in JavaScript, complete with both good and bad examples for each principle.\n\nA good variable name should give an idea of its purpose or content. is clear about representing the sum of a price, whereas is vague and doesn't provide any context. Avoid cryptic, one-letter names like , , or unless they are used in mathematical formulas or loop counters.\n\nJavaScript has a few common naming conventions that, when followed consistently, help make the code easier to read and understand."
    },
    {
        "link": "http://w3schools.com/JS/js_conventions.asp",
        "document": "Always use the same coding conventions for all your JavaScript projects.\n\nCoding conventions are style guidelines for programming. They typically cover:\n• Naming and declaration rules for variables and functions.\n• Rules for the use of white space, indentation, and comments.\n\nCoding conventions can be documented rules for teams to follow, or just be your individual coding practice.\n\nAt W3schools we use camelCase for identifier names (variables and functions).\n\nAt the bottom of this page, you will find a wider discussion about naming rules.\n\nAlways put spaces around operators ( = + - * / ), and after commas:\n\nAlways use 2 spaces for indentation of code blocks:\n• Put the opening bracket at the end of the first line.\n• Use one space before the opening bracket.\n• Put the closing bracket on a new line, without leading spaces.\n• Do not end a complex statement with a semicolon.\n• Place the opening bracket on the same line as the object name.\n• Use colon plus one space between each property and its value.\n• Use quotes around string values, not around numeric values.\n• Do not add a comma after the last property-value pair.\n• Place the closing bracket on a new line, without leading spaces.\n• Always end an object definition with a semicolon.\n\nShort objects can be written compressed, on one line, using spaces only between properties, like this:\n\nIf a JavaScript statement does not fit on one line, the best place to break it, is after an operator or a comma.\n\nAlways use the same naming convention for all your code. For example:\n• Global variables written in UPPERCASE (We don't, but it's quite common)\n\nShould you use hyp-hens, camelCase, or under_scores in variable names?\n\nThis is a question programmers often discuss. The answer depends on who you ask:\n\nMany programmers prefer to use underscores (date_of_birth), especially in SQL databases.\n\nUnderscores are often used in PHP documentation.\n\nPascalCase is often preferred by C programmers.\n\ncamelCase is used by JavaScript itself, by jQuery, and other JavaScript libraries.\n\nUse simple syntax for loading external scripts (the type attribute is not necessary):\n\nA consequence of using \"untidy\" HTML styles, might result in JavaScript errors.\n\nThese two JavaScript statements will produce different results:\n\nIf possible, use the same naming convention (as JavaScript) in HTML.\n\nHTML files should have a .html extension (.htm is allowed).\n\nMost web servers (Apache, Unix) are case sensitive about file names:\n\nlondon.jpg cannot be accessed as London.jpg.\n\nOther web servers (Microsoft, IIS) are not case sensitive:\n\nlondon.jpg can be accessed as London.jpg or london.jpg.\n\nIf you use a mix of upper and lower case, you have to be extremely consistent.\n\nIf you move from a case insensitive, to a case sensitive server, even small errors can break your web site.\n\nTo avoid these problems, always use lower case file names (if possible).\n\nCoding conventions are not used by computers. Most rules have little impact on the execution of programs.\n\nIndentation and extra spaces are not significant in small scripts.\n\nFor code in development, readability should be preferred. Larger production scripts should be minimized."
    },
    {
        "link": "https://codedamn.com/news/javascript/the-art-of-naming-variables-in-javascript-tips-and-best-practices",
        "document": "JavaScript, one of the most widely used programming languages in the world, plays a significant role in modern web development. One pivotal aspect of writing clean, understandable, and maintainable JavaScript code is the effective naming of variables. In this blog post, we would delve into the art of naming variables in JavaScript, elucidating tips and best practices that would significantly improve your code quality and readability.\n\nBefore we start with the best practices, it's essential to understand what variables are in the context of programming. Variables are named containers used to store data values. In JavaScript, a variable can be declared using three keywords: var, let, and const.\n\nNaming conventions are essential in any programming language, and JavaScript is no exception. They are a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation.\n\nA variable name should be clear and descriptive enough to indicate what it holds. The name should specify what the variable means and what purpose it serves in the code.\n\nJavaScript uses camel casing as the standard naming convention for variables. In camel casing, the first letter of the variable is in lowercase, and the first letter of each subsequent concatenated word is in uppercase.\n\nIn JavaScript, variable names should start with a lowercase letter. Starting a variable name with an uppercase letter is usually reserved for constructor functions in JavaScript, which is beyond the scope of this blog post.\n\nIn JavaScript, variable names cannot start with a number. They can start with a letter, underscore (_), or dollar sign ($). However, starting a variable name with an underscore or dollar sign is generally discouraged unless there's a compelling reason.\n\nQ: Can I use JavaScript reserved keywords as variable names?\n\nNo, JavaScript reserved keywords cannot be used as variable names. These keywords have special meanings in the language syntax. Examples of JavaScript reserved keywords include: if, else, function, return, etc.\n\nQ: Is it mandatory to use camel casing for variable names in JavaScript?\n\nWhile it's not mandatory, it's a standard practice in JavaScript and many other programming languages. Using camel casing improves code readability and consistency.\n\nQ: What should I do if I have to use a variable name that's already taken?\n\nYou can append or prepend words to make the variable name unique. However, the new name should still be descriptive and adhere to the best practices discussed above.\n\nFor further reading, you can refer to the Mozilla Developer Network's guide on JavaScript variables.\n\nIn conclusion, the art of naming variables is a fundamental skill in JavaScript programming. It not only makes your code more readable and maintainable but also reduces the potential for errors. By following the tips and best practices outlined in this blog post, you can write JavaScript code that's clean, efficient, and professional. Happy coding on codedamn!"
    },
    {
        "link": "https://binary-studio.com/blog/javascript-naming-conventions",
        "document": "It is no secret that developers have to ponder over numerous everyday tasks. Part of their thoughts is always dedicated to various routine matters, such as \"In which module should I place this function?\", \"How should I name this variable?\", or \"What should this variable do?\". Despite these questions appearing simple and trivial, they consistently consume mental resources. However, if there are ways to simplify this process by automating some routine tasks, thereby focusing attention on more critical matters, it undoubtedly makes sense to take advantage of them.\n\nIn this context, naming conventions play a crucial role. Acquiring knowledge and employing these conventions judiciously contribute to enhanced code readability, simplifying comprehension, and reducing the developer's cognitive load. However, not all node.js developers are aware of, and sometimes forget, how to correctly apply these conventions, mindlessly diverting their attention to seemingly more critical matters. This, in turn, complicates the readability and understanding of their code, making ostensibly \"more critical\" tasks more intricate than they could actually be.\n\nBelow is a screenshot from a real project I had the opportunity to work on. Take note of each import. Try to guess, based on the names, what item we can obtain from each of the imports.\n\nIn this article, we will explore most of them, learning or reminding ourselves which principles are best to follow when choosing names for the constructs you write. This will help both you and anyone who works with your code in the future – whether it is your team or yourself after some time – avoid guesswork and enhance the readability of your code.\n\nThis article will consist of a set of naming recommendations. I would not want you to perceive them as the sole truth. Firstly, it is not entirely the case, as most recommendations come with a disclaimer that there are numerous exceptions, hinting that the conventions themselves do not cover all cases. Secondly, while most recommendations are accepted in the JavaScript community, not everyone follows them for various reasons, and some recommendations are either partially or significantly modified to suit specific teams.\n\nThe main message of the article is that each project should establish its naming conventions, whether they align with widely adopted ones or are unique to your team. The crucial aspect is to have conventions and adhere to them.\n\nOn the internet, there is a considerable number of articles written about best naming practices. Well-known conventions emphasize that a name should be short and, more importantly, understandable. The name should be specific, correspond to the context in which it is used, and convey the meaning of the code at a glance. In reality, these conventions can and should be applied not only when working with JavaScript but also with any programming language. In these general rules, I would like to focus on some specific details in conventions that are widely known but often forgotten or not fully adhered to.\n\nUniformity. In JavaScript projects, there are numerous conventions, but the most valuable one to adhere to is maintaining a consistent coding style within a single project. Individuals involved in different projects know better than anyone that writing styles can vary significantly between projects.\n\nSituations often arise where different parts of an application are developed by different teams or use different technologies in their development. Naming conventions may differ based on the chosen programming language or the preferences of the development team. Despite these differences, different parts of the application need to interact with each other, such as data exchange between the frontend and backend. For example, the naming style for data requested from the backend might differ from the style used in the frontend code.\n\nDespite the convention in the JavaScript language to write in , it is worth noting that nothing is preventing the use of, for instance, . As already mentioned, this notation might be more familiar to many other programming languages and some teams. There might be situations where a naming case different from the style of your application starts creeping into your code.\n\nIt is not our place to judge whether using different naming cases is good or bad, as various reasons may drive such choices. However, explicit mixing of two or more naming cases can pose challenges. For new developers joining the project, understanding what is happening and deciding which naming case to use can become quite challenging.\n\nThere are several ways to address this issue, ranging from using renaming with destructuring, import renaming, using mapping functions (e.g., Array.prototype.map()), and more advanced approaches like utilizing the Adapter design pattern.\n\nThe key is to adopt a consistent approach, not only in naming conventions but also in how tasks are accomplished. Whenever possible, prefer a single method for a particular action. Avoid forcing yourself and other developers to spend time and extra mental resources deciding which approach to use. Consider delegating such tasks, especially those related to coding style, to tools like ESLint.\n\nEnglish only. Despite the fact that you can use non-Latin letters when writing in JavaScript, it is not recommended to do so. While there will not be any programming errors, it is strongly discouraged to use any languages other than English. Even if you are writing something for yourself, every piece of code has the ability to \"live long\", and there may come a time when you need to share this code with other developers. For other developers, especially from different countries, it will be difficult to understand what is happening in the code.\n\nWhen emphasizing the use of only English, people often think only about keyboard layout. However, one should not forget about abbreviations and the general use of short forms for names. They should only be used with commonly accepted words, such as , , , , , and other historically accepted words in the community. In other cases, the use of abbreviations and short forms of words is strongly discouraged, as they often lead to confusion, and deciphering them can take a lot of time.\n\nIt is also recommended to enable a spell checker in your code editor, which will highlight grammatical errors in words. In many editors it is enabled by default, and for some you may need to install an extension, such as Code Spell Checker for VS Code. Today's spell checkers are smart enough, and most commonly accepted abbreviations and short forms of words will not be flagged as errors.\n\nNot only camelCase. Many resources emphasize using camelCase notation exclusively when writing in JavaScript. However, this is not entirely accurate. The recommendation is more about adhering to the notation used by the language itself. While a significant portion of the JavaScript language is written in camelCase, it is not universally so. Here are a few examples:\n\nAs we can see, JavaScript incorporates not only notation but also some others. All classes and constructor functions in JavaScript are written using notation. When declaring custom classes and constructor functions, it is customary to follow the same naming convention as the language itself. The same applies to constants, representing fixed values. Both built-in JavaScript constants and those created by developers are conventionally named in .\n\nIn contrast to some programming languages where the API is written using various cases without clear distribution, JavaScript's API does not suffer from this issue. Therefore, it is customary to adhere to the conventions present in the language itself.\n\nFollow readme.md. Suppose you are working with a network request library like , and the library's README recommends using the standard name axios for imports.\n\nChanging the name from to can cause confusion and errors, as other developers working on the project and expecting the standard name may encounter issues. Therefore, it is important to adhere to the recommendations set in the library's README to ensure compatibility and code understanding.\n\nAt first glance, the example with the library may seem harmless, but similar renaming scenarios can arise with the use of more complex libraries and frameworks deeply integrated into a project. Teams that adopt meaningful renaming practices will need to create their own documentation because new team members will not find sufficient information in the official documentation to understand the changes in the technology's usage style.\n\nTypically, meaningful renaming into something more abstract, is used in conjunction with the dependency inversion principle. However, it is important to understand the fine line here. You and your team must have a clear understanding of what you are doing and why, as there needs to be a balance in adopting such practices.\n\nNo data types. It can be tempting to include data types in variable names, but succumbing to this temptation often adds unnecessary semantic load to the name. For instance, using the name arr for a variable containing an array can lead to conflicts if a variable with the same name is used elsewhere. Moreover, the name arr does not convey meaningful information. Making the name more specific, like userArr, is an improvement, but it does not address all the issues.\n\nFor each language construct, whether built-in or custom data structures, there exists a conventional way to indicate the intended data type of the value. This is reflected in the name of the construct, which should align with both the established community conventions and those within your team. It is advisable to prioritize community conventions, as explaining something widely accepted is generally easier than introducing something entirely unique. In the case of community conventions, you can refer someone to an internet article, while for team-specific conventions, you might need to write that article yourself.\n\nIn this section, we will discuss specific naming conventions for data types and data structures. While JavaScript may appear limited in its built-in data types and structures, it offers extensive capabilities. These encompass a variety of methods, which in other programming languages are often segregated into distinct built-in types or data structures.\n\nFor instance, in JavaScript, an object can serve as an , ( ), , and more. The data type in JavaScript includes handling both integers and floating-point numbers. Depending on specific requirements, JavaScript data types and structures can be flexibly adapted for use, providing JavaScript with versatility and power.\n\nIt is in this context that the importance of naming conventions becomes clear. They not only enhance code readability but also prevent confusion and errors when interacting with other parts of the codebase. Good naming conventions ensure clarity within the code and facilitate understanding of data structures and their purposes for other developers, contributing to more effective collaboration within a team.\n\nBooleans. Names of boolean values should start with an affirmative prefix, meaning the prefix should answer the question \"yes.\" Although there are several affirmative words (should, can, will, etc.) that answer \"yes,\" it is advisable to prefer the two most common ones – and . While using other affirmative words will not be considered an error, their use should be treated as an exception, and if possible, it is better to avoid using them.\n\nAn important addition to this convention, often overlooked, is that the affirmative prefix should not include a negation. The reason behind this is that the negation operator ( ) is most commonly used with boolean values. Therefore, a value named something like with the negation applied to it can be quite misleading. Do not believe so? Then try quickly figuring out what (double negation) equals. Even if you manage to do it quickly, imagine working with real code where all these negation inversions are scattered throughout the file. Keeping track of such logic, especially when there is a lot of it, can be quite challenging. In such cases, it is better to alter the logic of evaluating the boolean variable using a positive affirmative in its name.\n\nAlong with the convention to use affirmative prefixes for boolean names, we diverge from the W3C specification recommendations, as it advises against using these prefixes for boolean names. This contradicts the idea mentioned earlier to prefer conventions used by the language itself. However, there are always exceptions, and this is one of them. It is normal since the way specification authors think may differ from the community's perspective.\n\nJavaScript was created a long time ago, and at the time of its inception, the authors decided not to use affirmative prefixes for boolean names. Now, they do their best by continuing to follow their convention, even if it goes against the community's opinion. Even if the authors wanted to introduce new naming conventions in the specification, they could not do it, at least not coherently. Old code cannot be renamed because JavaScript must remain backward-compatible. And starting to write new code using new approaches is not a great idea either, as there would be two ways to do the same thing, which is also undesirable.\n\nExceptions are normal. Nothing in this world is perfect. Even the specification itself has exceptions – or . The key is to try to minimize them while adhering to previously established conventions.\n\nFunctions & Methods. The name of a function/method should be a verb and correspond to the action it performs.\n\nAlthough the naming convention for functions/methods may seem simple at first glance, their naming is the one that has the most exceptions and other conventions.\n• Following the JavaScript writing style ( , , , constructor functions, etc.).\n• Library functions, for example, a reducer function in the Redux library ( ), functional components in React ( ), and many other exceptions and conventions proposed by libraries and frameworks.\n\nYou can learn about all of them by working directly with them. However, for most functions and methods, the main convention that the name should be a verb and correspond to the action they perform remains unchanged.\n\nCollections & Iterators. The naming convention is as follows – if Iterator or indexed collections (e.g., , , , etc.) are used, the name should be a plural noun. Otherwise, if keyed collections ( , ) are used, and we are only interested in values that we can obtain by keys (usually using or spread syntax), the naming convention remains the same – the name should be a plural noun. However, if the keys are also important to us in keyed collections, then such collections should be named using a singular noun, and at the end of the name, add one of the prefixes that signifies a set of something. For example, , , , and others.\n\nAn important addition is that this convention should also be applied to user-created indexed or keyed collections using Iteration protocols.\n\nClasses. When working with classes, it is important to follow several conventions. Here is the list:\n• Use for the class name, following the same case style that JavaScript uses for classes and constructor functions.\n• The class name should be a singular noun.\n• Names of all class members should not include the class name.\n\nIf there is a temptation to use the class name in the names of its members, it is likely that the class is overloaded with logic or is responsible for more things than it should be. In such cases, a violation of the Single Responsibility Principle can often be observed. To avoid such situations, it is recommended to create additional classes and use inheritance or dependency injection to limit the responsibility of each class.\n\nConstants. Used to describe values which are known before the program's execution and that should not change during its execution.\n\nConstants are a crucial and widely adopted approach to organizing a program's code. Regarding naming conventions, there is an important agreement among developers: the name of a constant should be written using the notation.\n\nAlthough there are several ways to declare a variable in JavaScript, and for constants, it might seem logical to use only the const keyword, which prevents it from being changed during program execution, as some teams prefer not to worry about choosing the keyword for variable declarations. They may use automation tools like ESLint to enforce the use of only the let keyword for variable declarations in the program code.\n\nAgain, every team is different, and each may have its own conventions. However, even the prohibition of using seemingly more appropriate constructs and keywords is not an indicator of how something should be done or named. Naming always carries more meaning than the use of any keywords. This is why naming is such a crucial aspect of code writing.\n\nEnums. Also known as enumerations. In JavaScript, this data structure is used to enumerate a set of fixed values.\n\nUnlike many other programming languages that have a separate data type for enumerations, JavaScript does not have such a data type (at least, as of now). Instead, to simulate an enumeration in JavaScript, a plain object can be used, but with specific naming conventions. Here is a list of these naming conventions:\n• The name of the enumeration should start with a capital letter.\n• The name of the enumeration should be in the singular noun.\n• The keys of the enumeration should be in uppercase.\n\nSince TypeScript is now a significant part of JavaScript development, it is worth mentioning that TypeScript has the enum keyword for enumerations. If you decide to use TypeScript's enumerations with your team, it is customary to follow the same naming conventions.\n\nMaps. Also known as a data structure. This data structure is used for mapping one value to another.\n\nA map is a very useful and frequently used data structure in any programming language. For maps in the JavaScript world, there is a specific naming convention. The name should follow the pattern , where serves as the key for retrieving values from the map, followed by the preposition , implying the mapping of two things, and then , which is the mapped value for .\n\nThere is a built-in class in JavaScript. The main difference from a regular object is the ability to use any data type (even an object) as a key. Usually, using the native class is redundant for creating a map as a data structure. However, if you need the functionality provided by the native , you can use it to create a map data structure. In most cases, a regular object will suffice.\n\nTypes & Interfaces. As mentioned earlier, TypeScript has become an integral part of JavaScript development today. In general, in most cases, types and interfaces are interchangeable. However, since there are already enough discussions about which one to choose, in this article, we will focus specifically on naming. For types and interfaces, the following naming conventions exist:\n• Names of types and interfaces should be written in notation.\n• The name should describe what the type or interface will be used for, often as straightforwardly as possible: / .\n• If a development team has decided to actively use both types and interfaces in one codebase, it is recommended to add a prefix to interfaces to distinguish them. The most popular prefixes are and .\n\nIt is important to realize that despite the extensive overview of JavaScript naming conventions in this article, it cannot cover all possible scenarios. Even within the presented points, numerous exceptions should be considered. The naming process, although fundamental, implies flexibility in application, taking into account the unique features and requirements of each project.\n\nDuring development, we often delve into complex technical details, forgetting that the power often lies in the details. Years of development experience only affirm the truth that attention to details, such as naming, plays a crucial role in creating efficient and readable code. Simplicity and the absence of the need to ponder over how to name a value and how quickly to understand what it contains bring incredible relief in the daily work of a developer.\n\nCan a developer consider themselves strong if their variables are not clearly named? Clear naming not only makes the code more understandable for other developers but also for the programmer themselves, making the development process more efficient and less error-prone.\n\nIt often happens that searching for poor naming leads to the discovery of bad code. This only underscores how naming conventions serve as an indicator of code quality. Proper naming reflects care for details, which, in turn, speaks to an attentive approach to development.\n\nHere is how the import of values from the introductory part looks when applying the conventions discussed in this article. Now it looks much clearer, doesn't it? I am sure it will take you much less effort now to understand the meaning of each import.\n\nIn conclusion, it is essential to remember that while naming standards are important, they are not absolute. Every project has its peculiarities, and it is crucial to define your conventions. The main thing is that they should exist, and you adhere to them to ensure consistency in the code and improve collective productivity. Also, if possible, try to delegate code style issues to tools like ESLint to simplify and enhance the development process."
    },
    {
        "link": "https://w3schools.com/js/js_if_else.asp",
        "document": "JavaScript if, else, and else if\n\nConditional statements are used to perform different actions based on different conditions.\n\nVery often when you write code, you want to perform different actions for different decisions.\n\nYou can use conditional statements in your code to do this.\n\nIn JavaScript we have the following conditional statements:\n• Use to specify a block of code to be executed, if a specified condition is true\n• Use to specify a block of code to be executed, if the same condition is false\n• Use to specify a new condition to test, if the first condition is false\n• Use to specify many alternative blocks of code to be executed\n\nUse the statement to specify a block of JavaScript code to be executed if a condition is true.\n\nUse the statement to specify a block of code to be executed if the condition is false.\n\nThe else if Statement\n\nUse the statement to specify a new condition if the first condition is false.\n\nThis example will write a link to either W3Schools or to the World Wildlife Foundation (WWF). By using a random number, there is a 50% chance for each of the links. let text;\n\n if (Math.random() < 0.5) {\n\n text = \"<a href='https://w3schools.com'>Visit W3Schools</a>\";\n\n } else {\n\n text = \"<a href='https://wwf.org'>Visit WWF</a>\";\n\n }\n\n document.getElementById(\"demo\").innerHTML = text;\n\n Try it Yourself »"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else",
        "document": "Multiple statements can be nested to create an clause. Note that there is no (in one word) keyword in JavaScript.\n\nTo see how this works, this is how it would look if the nesting were properly indented:\n\nTo execute multiple statements within a clause, use a block statement ( ) to group those statements.\n\nNot using blocks may lead to confusing behavior, especially if the code is hand-formatted. For example:\n\nThis code looks innocent — however, executing will log \"a is not 1\". This is because in the case of dangling else, the clause will be connected to the closest clause. Therefore, the code above, with proper indentation, would look like:\n\nIn general, it is a good practice to always use block statements, especially in code involving nested statements.\n\nDo not confuse the primitive Boolean values and with truthiness or falsiness of the object. Any value that is not , , , , , , or the empty string ( ), and any object, including a Boolean object whose value is , is considered truthy when used as the condition. For example:"
    },
    {
        "link": "https://programiz.com/javascript/if-else",
        "document": "The JavaScript statement is used to execute/skip a block of code based on a condition.\n\nHere's a quick example of the statement. You can read the rest of the tutorial if you want to learn about in greater detail. let score = 45; // check if score is fifty or greater if (score >= 50) { console.log(\"You passed the examination.\"); } else { console.log(\"You failed the examination.\"); } // Output: You failed the examination. In the above example, the program displays if the variable is equal to 50. Otherwise, it displays\n\nIn computer programming, the statement is a conditional statement that executes a block of code only when a specific condition is met. For example,\n\nSuppose we need to assign different grades to students based on their scores.\n• If a student scores above 65, assign grade C.\n\nThese conditional tasks can be achieved using the statement.\n\nWe use the keyword to execute code based on some specific condition.\n\nThe syntax of statement is:\n\nThe keyword checks the condition inside the parentheses .\n• If the condition is evaluated to , the code inside is executed.\n• If the condition is evaluated to , the code inside is skipped.\n\nNote: The code inside is also called the body of the statement.\n\nIn the above program, when we enter 5, the condition evaluates to . Thus, the body of the statement is executed.\n\nAgain, when we enter -1, the condition evaluates to . Hence, the body of the statement is skipped.\n\nSince is outside the body of the statement, it is always executed.\n\nNote: We use comparison and logical operators in our conditions. To learn more, you can visit JavaScript Comparison and Logical Operators.\n\nWe use the keyword to execute code when the condition specified in the preceding statement evaluates to .\n\nThe syntax of the statement is:\n\nThe statement checks the and executes code in two ways:\n• If is true, the code inside is executed. And, the code inside is skipped.\n• If is false, the code inside is skipped. Instead, the code inside is executed.\n\nIn the above example, the statement checks for the condition .\n\nSince we set the value of to 17, the condition evaluates to .\n\nThus, the code inside is skipped. And, code inside is executed.\n\nWe can use the keyword to check for multiple conditions.\n\nThe syntax of the statement is:\n• First, the condition in the statement is checked. If the condition evaluates to , the body of is executed, and the rest is skipped.\n• Otherwise, the condition in the statement is checked. If , its body is executed and the rest is skipped.\n• Finally, if no condition matches, the block of code in is executed.\n\nIn the above example, we used the statement to check for the condition .\n\nLikewise, we used the statement to check for another condition, .\n\nSince the condition is satisfied, the code inside it is executed.\n\nWhen we use an statement inside another statement, we create a nested if...else statement. For example,\n\nIn the above example, the outer condition checks if a student has passed or failed using the condition . If it evaluates to , the outer statement will print .\n\nOn the other hand, if evaluates to , the program moves to the inner statement.\n\nThe inner condition checks whether the student has passed with distinction using the condition .\n\nIf evaluates to , the inner statement will print .\n\nOtherwise, the inner statement will print .\n\nNote: Avoid nesting multiple statements within each other to maintain code readability and simplify debugging."
    },
    {
        "link": "https://geeksforgeeks.org/conditional-statements-in-javascript",
        "document": "JavaScript conditional statements allow you to execute specific blocks of code based on conditions. If the condition is met, a particular block of code will run; otherwise, another block of code will execute based on the condition.\n\nThe if statement is used to evaluate a particular condition. If the condition holds true, the associated code block is executed.\n\nThe if-else statement will perform some action for a specific condition. Here we are using the else statement in which the else statement is written after the if statement and it has no condition in their code block.\n\nThe else if statement in JavaScript allows handling multiple possible conditions and outputs, evaluating more than two options based on whether the conditions are true or false.\n\nPlease refer JavaScript If-Else for more detailed explanation.\n\nAs the number of conditions increases, you can use multiple else-if statements in JavaScript. but when we dealing with many conditions, the switch statement may be a more preferred option.\n\nThe conditional operator, also referred to as the ternary operator (?:), is a shortcut for expressing conditional statements in JavaScript.\n\nPlease refer JavaScript Ternary Operator for more details\n\nNested if…else statements in JavaScript allow us to create complex conditional logic by checking multiple conditions in a hierarchical manner. Each if statement can have an associated else block, and within each if or else block, you can nest another if…else statement. This nesting can continue to multiple levels, but it’s important to maintain readability and avoid excessive complexity.\n\nThis table outlines the key characteristics and use cases of each type of conditional statement. Now let’s understand each conditional statement in detail along with the examples."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_if.asp",
        "document": "The if/else statement executes a block of code if a specified condition is true. If the condition is false, another block of code can be executed.\n\nThe if/else statement is a part of JavaScript's \"Conditional\" Statements, which are used to perform different actions based on different conditions.\n\nIn JavaScript we have the following conditional statements:\n• Use if to specify a block of code to be executed, if a specified condition is true\n• Use else to specify a block of code to be executed, if the same condition is false\n• Use else if to specify a new condition to test, if the first condition is false\n• Use switch to select one of many blocks of code to be executed\n\nThe if statement specifies a block of code to be executed if a condition is true:\n\nThe else statement specifies a block of code to be executed if the condition is false:\n\nThe else if statement specifies a new condition if the first condition is false:\n\nif (condition1) {\n\n // block of code to be executed if condition1 is true\n\n } else if (condition2) {\n\n // block of code to be executed if the condition1 is false and condition2 is true\n\n } else {\n\n // block of code to be executed if the condition1 is false and condition2 is false\n\n }\n\nvar x, text;\n\n\n\n// Get the value of the input field with id=\"numb\"\n\nx = document.getElementById(\"numb\").value;\n\n\n\n// If x is Not a Number or less than 1 or greater than 10, output \"input is not valid\"\n\n// If x is a number between 1 and 10, output \"Input OK\"\n\n\n\nif (isNaN(x) || x < 1 || x > 10) {\n\n text = \"Input not valid\";\n\n} else {\n\n text = \"Input OK\";\n\n} Try it Yourself »\n\nIt is supported in all browsers:"
    }
]