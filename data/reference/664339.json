[
    {
        "link": "https://cplusplus.com/reference/stack/stack",
        "document": "usually the same as"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/stack",
        "document": "The class is a container adaptor that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.\n\nThe class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The stack pushes and pops the element from the back of the underlying container, known as the top of the stack.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe type of the stored elements. The program is ill-formed if is not the same type as . The type of the underlying container to use to store the elements. The container must satisfy the requirements of . Additionally, it must provide the following functions with the usual semantics: The standard containers std::vector (including ), std::deque and std::list satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container std::deque is used.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/stack-in-cpp-stl",
        "document": "In C++, stack container follows LIFO (Last In First Out) order of insertion and deletion. It means that most recently inserted element is removed first and the first inserted element will be removed last. This is done by inserting and deleting elements at only one end of the stack which is generally called the top of the stack.\n\nExplanation: In the above program, we created a stack of integers s. The element 1, 2 and 3 are then pushed one after other into the stack. Due to LIFO order, the elements are stored in the stack in the reverse order as they are inserted.\n\nStack is defined as std::stack class template inside the <stack> header file.\n• T: Type of elements in the stack.\n• st: Name assigned to the stack.\n\nIn C++, stack can be declared and initialized in two ways as shown in the below example:\n\nExplanation: In the above program,\n• stack<int> st1 creates an empty stack of integers. Elements are later added into st1\n• stack<int> st2 (s1) st2 with the same elements as st1\n\nHere are the basic operations that can be performed on a stack:\n\nIn stack, new elements can only be inserted at the top of the stack by using push() method. There is no way to inserting element at any other position of the stack.\n\nOnly the top element of the stack can be accessed using top() method. We can’t access any middle element of stack.\n\nIn stack, only the top element of the stack can be deleted by using pop() method in one operation. To delete any other element, we have to first delete all the elements inserted after that element (i.e. elements on top of the that element).\n\nAs any element other than the top element cannot be accessed in the stack, it cannot be actually traversed. But we can create a copy of it, access the top element and delete the top. By doing this till the copy stack is empty, we can effectively traverse without modifying the original stack.\n\nExplanation: In the above program, pseudo-traversal is done by creating a copy of the st to avoid modifying the original stack. The while loop prints and removes elements from temp using top() and pop() till the stack is not empty.\n\nThe below table lists the time complexity of the above operations on stack:\n\nThe following are some more operations on stack that helps you become more familiarize with it:\n\nStack container provides the built-in implementation of the stack data structure in C++. It is implemented as container adapter built over other containers such as vectors, lists, etc. It uses the LIFO (Last In, First Out) principle to push and pop elements. The top element is always the most recently added element, and operations are limited to this end of the stack.\n\nFollowing is the list of all member functions of std::stack class in C++:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/stack-class?view=msvc-170",
        "document": "A template container adaptor class that provides a restriction of functionality limiting access to the element most recently added to some underlying container type. The class is used when it is important to be clear that only operations are being performed on the container.\n\n\n\n The element data type to be stored in the stack.\n\n\n\n The type of the underlying container used to implement the stack. The default value is the class .\n\nThe elements of class stipulated in the first template parameter of a stack object are synonymous with and must match the type of element in the underlying container class stipulated by the second template parameter. The must be assignable, so that it is possible to copy objects of that type and to assign values to variables of that type.\n\nSuitable underlying container classes for stack include , class, and class, or any other sequence container that supports the operations of , , and . The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.\n\nThe objects are equality comparable if and only if the elements of class are equality comparable and are less-than comparable if and only if the elements of class are less-than comparable.\n• None The class supports a last-in, first-out (LIFO) data structure. A good analogue to keep in mind would be a stack of plates. Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container. The restriction to accessing only the top element is the reason for using the class.\n• None The class supports a first-in, first-out (FIFO) data structure. A good analogue to keep in mind would be people lining up for a bank teller. Elements (people) may be added to the back of the line and are removed from the front of the line. Both the front and the back of a line may be inspected. The restriction to accessing only the front and back elements in this way is the reason fur using the class.\n• None The class orders its elements so that the largest element is always at the top position. It supports insertion of an element and the inspection and removal of the top element. A good analogue to keep in mind would be people lining up where they are arranged by age, height, or some other criterion.\n\nA type that provides the base container to be adapted.\n\nThe type is a synonym for the template parameter . All three C++ Standard Library sequence container classes — the class, class, and the default class — meet the requirements to be used as the base container for a object. User-defined types satisfying these requirements may also be used.\n\nFor more information on , see the Remarks section of the Class topic.\n\nSee the example for for an example of how to declare and use .\n\nif the stack is empty; if the stack is nonempty.\n\nRemoves the element from the top of the stack.\n\nThe stack must be nonempty to apply the member function. The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.\n\nAdds an element to the top of the stack.\n\n\n\n The element added to the top of the stack.\n\nThe top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.\n\nReturns the number of elements in the stack.\n\nThe current length of the stack.\n\nAn unsigned integer type that can represent the number of elements in a stack.\n\nThe type is a synonym for of the base container adapted by the stack.\n\nSee the example for for an example of how to declare and use .\n\nConstructs a stack that is empty or that is a copy of a base container class.\n\n\n\n The container of which the constructed stack is to be a copy.\n\nReturns a reference to an element at the top of the stack.\n\nA reference to the last element in the container at the top of the stack.\n\nThe stack must be nonempty to apply the member function. The top of the stack is the position occupied by the most recently added element and is the last element at the end of the container.\n\nIf the return value of is assigned to a , the object cannot be modified. If the return value of is assigned to a , the object can be modified.\n\nA type that represents the type of object stored as an element in a stack.\n\nThe type is a synonym for of the base container adapted by the stack.\n\nThread Safety in the C++ Standard Library\n\n C++ Standard Library Reference"
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-stack",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/queue",
        "document": "The class template is a container adaptor that gives the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.\n\nThe class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The queue pushes the elements on the back of the underlying container and pops them from the front.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe type of the stored elements. The program is ill-formed if is not the same type as . The type of the underlying container to use to store the elements. The container must satisfy the requirements of . Additionally, it must provide the following functions with the usual semantics: The standard containers std::deque and std::list satisfy these requirements.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards.\n• . The resolution of this DR\n\nadded support of and . The changes involving \n\nare for maintaining consistency. Such as containers similar to with additional support of. The resolution of this DRadded support of forand. The changes involvingare for maintaining consistency."
    },
    {
        "link": "https://geeksforgeeks.org/queue-cpp-stl",
        "document": "In C++, queue container follows the FIFO (First In First Out) order of insertion and deletion. According to it, the elements that are inserted first should be removed first. This is possible by inserting elements at one end (called back) and deleting them from the other end (called front) of the data structure.\n\nExplanation: In this program, we created a queue of integers and pushed three elements {3, 4, 5} into it.\n\nQueue is defined as the std::queue class template inside <queue> header file.\n• T: Type of elements in the queue.\n• q: Name assigned to the queue.\n\nIn C++, queue can be declared and initialized in multiple ways as shown in the below example:\n\nExplanation: In the above program,\n• queue<int> q1 creates an empty queue of integers. Elements are later added into it.\n• queue<int> q2(q1) q2 with same elements as q1\n\nHere are the basic operations that can be performed on a queue:\n\nNew elements can only be inserted at back of the queue using push() function. The process of inserting elements in a queue is also called enqueue.\n\nOnly the front and back elements of the queue can be accessed by using front() and back() functions respectively. We can’t access any middle element of queue.\n\nElements can only be deleted from the front of the queue using the function. This operation is also called dequeue.\n\nSince only the front and back element can be accessed in a queue, we cannot directly traverse it. On the other hand, we can create a copy of the queue, access the front element, and then delete it. By continuing this process until the copied queue is empty, we can effectively traverse all the elements of the queue.\n\nThe below table lists the time complexity of the basic operations on a queue:\n\nThe following are some more operations on queue that will help you become more familiarize with this container:\n\nQueue container provides the built-in implementation of the Queue data structure in C++. It is a container adaptor that is built over another container like deque or list. The queue follows the FIFO (First In, First Out) principle to insert and delete elements. This behaviour is achieved using underlying data structures that allow constant time insert and delete operations at both ends.\n\nExample, we cannot use vector as it does not allow constant time for deletion at both ends. But on the other hand, deque allows the constant time insertion at the back and deletion at the front. All the other operations of deque are restricted.\n\nFollowing is the list of all member functions of std::queue class in C++:"
    },
    {
        "link": "https://cplusplus.com/reference/queue/queue",
        "document": "usually the same as"
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/queue-in-cpp",
        "document": ""
    },
    {
        "link": "https://programiz.com/cpp-programming/queue",
        "document": "In C++, the STL provides the functionality of a queue data structure.\n\nThe queue data structure follows the FIFO (First In First Out) principle where elements that are added first will be removed first.\n\nIn order to create a queue in C++, we first need to include the header file.\n\nOnce we import this file, we can create a using the following syntax:\n\nHere, indicates the data type we want to store in the queue. For example,\n\nIn C++, is a class that provides various methods to perform different operations on a queue.\n\nWe use the method to insert an element to the back of a queue. For example,\n\nIn the above example, we have created a of strings called . Here, we have used the method to add elements to the end of the queue.\n\nInstead of directly printing the contents of the queue, we have used a loop and various queue methods.\n\nThis is because the STL queue is an STL Container Adapter that provides restrictive access to make it behave like a standard queue data structure.\n\nAs a result, we cannot iterate through the queue like iterating through vectors or other containers.\n\nInstead, we print its front and then pop the element repeatedly inside a loop until the queue is empty.\n\nWe will learn about , and in the coming sections.\n\nWe can use the method to remove an element from the front of a queue. For example,\n\nIn the above example, we have used the method to remove an element from the queue.\n\nInitially, the contents of the queue are , and .\n\nHere removes the element at the front of the queue i.e. the element inserted at the very beginning which is .\n\nHence, the final queue contains the elements and .\n\nWe can access the elements of a using the following methods:\n• - returns the element from the front of the queue\n• - returns the element from the back of the queue\n\nIn the above example, we have used the and methods to get the first and last elements from a queue of integers called .\n\nWe can get the first element i.e. the element at the front using:\n\nHere, 1 was inserted first so it is at the front.\n\nSimilarly, we find the last element i.e. the rear (back) element using:\n\nHere, 3 was inserted last, so it is at the back.\n\nGet the size of a Queue\n\nWe use the method to get the number of elements in the . For example,\n\nIn the above example, we have created a queue of strings called and added three elements to it.\n\nThen, we used the method to find the number of elements in the queue:\n\nSince we have added three elements to the queue, returns 3.\n\nCheck if the Queue is Empty\n\nWe use the method to check if the is empty. This method returns:\n• 1 (true) - if the queue is empty\n• 0 (false) - if the queue is not empty\n\nIn the above example, we have used the method to determine if the is empty,\n\nInitially, the queue has no elements in it. So returns .\n\nWe then add elements to the queue.\n\nThen we again use again to determine if the queue is empty. This time, it returns ."
    },
    {
        "link": "https://geeksforgeeks.org/difference-between-stack-and-queue-data-structures",
        "document": "In computer science, data structures are fundamental concepts that are crucial for organizing and storing data efficiently. Among the various data structures, stacks and queues are two of the most basic yet essential structures used in programming and algorithm design. Despite their simplicity, they form the backbone of many complex systems and applications. This article provides the differences between stack and queue data structures, exploring their characteristics, operations, and use cases.\n\nA stack is a linear data structure that follows the Last In, First Out (LIFO) principle. This means that the last element added to the stack is the first one to be removed. It can be visualized as a pile of plates where you can only add or remove the top plate.\n\nThe primary operations associated with a stack are:\n• Push : Adds an element to the top of the stack.\n• Pop : Removes and returns the top element of the stack.\n• Peek (or Top) : Returns the top element of the stack without removing it.\n• IsEmpty : Checks if the stack is empty.\n• Size : Returns the number of elements in the stack.\n\nStacks are used in various applications, including:\n• Function Call Management : The call stack in programming languages keeps track of function calls and returns.\n• Expression Evaluation : Used in parsing expressions and evaluating postfix or prefix notations.\n• Backtracking : Helps in algorithms that require exploring all possibilities, such as maze solving and depth-first search.\n\nA queue is a linear data structure that follows the First In, First Out (FIFO) principle. This means that the first element added to the queue is the first one to be removed. It can be visualized as a line of people waiting for a service, where the first person in line is the first to be served.\n\nThe primary operations associated with a queue are:\n• Enqueue : Adds an element to the end (rear) of the queue.\n• Dequeue : Removes and returns the front element of the queue.\n• Front (or Peek) : Returns the front element of the queue without removing it.\n• IsEmpty : Checks if the queue is empty.\n• Size : Returns the number of elements in the queue.\n\nQueues are used in various applications, including:\n• Task Scheduling : Operating systems use queues to manage tasks and processes.\n• Breadth-First Search (BFS) : In graph traversal algorithms, queues help in exploring nodes level by level.\n• Buffering : Used in situations where data is transferred asynchronously, such as IO buffers and print spooling.\n\nHere is a table that highlights the key differences between stack and queue data structures:\n\nA linear data structure that follows the Last In First Out (LIFO) A linear data structure that follows the First In First Out (FIFO) Push (add an item), Pop (remove an item), Peek (view the top item) Enqueue (add an item), Dequeue (remove an item), Front (view the first item), Rear (view the last item) Elements are added and removed from the same end (the top). Elements are added at the rear and removed from the front. Scheduling processes in operating systems, managing requests in a printer queue, breadth-first search in graphs. A stack of plates: you add and remove plates from the top. A queue at a ticket counter: the first person in line is the first to be served. Typically uses a contiguous block of memory or linked list. Can be implemented using arrays or linked lists. Can be implemented using arrays, linked lists, or circular buffers.\n\nStacks and queues are fundamental data structures that serve different purposes based on their unique characteristics and operations. Stacks follow the LIFO principle and are used for backtracking, function call management, and expression evaluation. Queues follow the FIFO principle and are used for task scheduling, resource management, and breadth-first search algorithms. Understanding the differences between these two data structures helps in selecting the appropriate one for specific applications, leading to more efficient and effective programming solutions."
    },
    {
        "link": "https://stackoverflow.com/questions/36801924/which-data-structure-is-best-for-basic-stacks-and-queues-in-c",
        "document": "I'm doing some newbie HackerRank problems in C++ and I'm finding that there seems to be several ways to solve this problem and I'm wondering which way is most widely used and/or most efficient. The problem requires creating a class that contains both and variables as well as / and / functions for them.\n\nFrom what I've googled it seems I could either use , and , or , and maybe others.\n\nI'm not sure how to determine which is best to use. Any suggestions?\n\nEDIT: I implemented using for both and then using along with and I saw the same exact performance with both for a small-ish test case. EDIT2: With a much bigger test case it looks like / outperforms . I'm guessing this is because of the FIFO queue half not being efficient with a vector, but I'll need to test this out more."
    },
    {
        "link": "https://stackoverflow.com/questions/2074970/stack-and-queue-why",
        "document": "You've been to a cafeteria, right? and seen a stack of plates? When a clean plate is added to the stack, it is put on top. When a plate is removed, it is removed from the top. So it is called Last-In-First-Out (LIFO). A computer stack is like that, except it holds numbers, and you can make one out of an array or a list, if you like. (If the stack of plates has a spring underneath, they say you \"push\" one onto the top, and when you remove one you \"pop\" it off. That's where those words come from.)\n\nIn the cafeteria, go in back, where they wash dishes. They have a conveyor-belt where they put plates to be washed in one end, and they come out the other end, in the same order. That's a queue or First-In-First-Out (FIFO). You can also make one of those out of an array or a list if you like.\n\nWhat are they good for? Well, suppose you have a tree data structure (which is like a real tree made of wood except it is upside down), and you want to write a program to walk completely through it, so as to print out all the leaves.\n\nOne way is to do a depth-first walk. You start at the trunk and go to the first branch, and then go to the first branch of that branch, and so on, until you get to a leaf, and print it. But how do you back up to get to the next branch? Well, every time you go down a branch, you \"push\" some information in your stack, and when you back up you \"pop\" it back out, and that tells you which branch to take next. That's how you keep track of which branch to do next at each point.\n\nAnother way is a breadth-first walk. Starting from the trunk, you number all the branches off the trunk, and put those numbers in the queue. Then you take a number out the other end, go to that branch, and for every branch coming off of it, you again number them (consecutively with the first) and put those in the queue. As you keep doing this you are going to visit first the branches that are 1 branch away from the trunk. Then you are going to visit all the branches that are 2 branches away from the trunk, and so on. Eventually you will get to the leaves and you can print them.\n\nThese are two fundamental concepts in programming."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/4hj9bz/c_why_use_stacks_and_queues",
        "document": "I'm confused as to why you can't do the exact same thing with an array that do with stacks and queues. I mean, I get that stacks are LIFO and queues are FIFO, but couldn't you just get the same results by storing your values in an array and running a for loop -\n\nso why is a separate data type needed for these? Is this something of a holdover from C, like unions, or am I missing something critical here that stacks and queues are better for than a standard array?\n\nEDIT: Thanks very much for the responses. I was thinking about stacks and queues from the wrong perspective entirely - I was thinking they were their own data type, not thinking about them as a method of processing data. Thanks for setting me straight."
    },
    {
        "link": "https://medium.com/@RobuRishabh/understanding-how-to-use-stack-queues-c-9f1fc06d1c5e",
        "document": "There are cars at given miles away from the starting mile 0, traveling to reach the mile .\n\nYou are given two integer array and , both of length , where is the starting mile of the car and is the speed of the car in miles per hour.\n\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\n\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\n\nIf a car catches up to a car fleet at the mile , it will still be considered as part of the car fleet.\n\nReturn the number of car fleets that will arrive at the destination.\n\nExample 1:\n\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n\nOutput: 3\n\nExplanation:\n\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, \n\nmeeting each other at 12. The fleet forms at target.\n\nThe car starting at 0 (speed 1) does not catch up to any other car, \n\nso it is a fleet by itself.\n\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, \n\nmeeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n\n\nExample 2:\n\nInput: target = 10, position = [3], speed = [3]\n\nOutput: 1\n\nExplanation:\n\nThere is only one car, hence there is only one fleet.\n\n\n\nExample 3:\n\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\n\nOutput: 1\n\nExplanation:\n\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, \n\nmeeting each other at 4. The car starting at 4 (speed 1) travels to 5.\n\nThen, the fleet at 4 (speed 2) and the car at position 5 (speed 1) \n\nbecome one fleet, meeting each other at 6. The fleet moves at speed 1 \n\nuntil it reaches target.\n\nFor each car, calculate the time to reach the target:\n\nNow, form a list of cars with position and time:\n• starts from the last element ( in this case).\n• ends one step before the first element ( in this case).\n\nBy sorting in reverse, we effectively sort the cars by position in descending order.\n\nWe sort the array by the field in descending order:\n\nNow, process cars from farthest to closest using the sorted array:\n• If the stack is empty or the current car’s time is greater than the top of the stack, it forms a new fleet.\n• Otherwise, it joins the fleet already in the stack.\n\nThe total number of fleets is the size of the stack: Output = 3\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\n\npublic:\n\n int carFleet(int target, vector<int>& position, vector<int>& speed) {\n\n // No. of cars\n\n int n = position.size();\n\n // Pair of position and time to reach target\n\n vector<pair<int, double>> cars;\n\n\n\n // Step1. Calculate the time to reach the target for each car\n\n for(int i=0; i<n; i++){\n\n double time = (double)(target - position[i]) / speed[i];\n\n cars.push_back({position[i], time});\n\n }\n\n // Step2. Sort cars by their starting positions (farther -> closer)\n\n std::sort(cars.rbegin(), cars.rend()); //Sort in descending order\n\n // Step3. Use a stack to track the fleet\n\n stack<double> fleetTimes;\n\n for(auto& car : cars){\n\n double time = car.second;\n\n // If stack is empty or this car takes more time, it forms a new fleet\n\n if(fleetTimes.empty() || time > fleetTimes.top()){\n\n fleetTimes.push(time);\n\n }\n\n }\n\n // Number of fleet is the size of the stack\n\n return fleetTimes.size();\n\n }\n\n};\n\n\n\n// Space Complexity : O(n) (due to the cars vector and stack).\n\n// Time Complexity : Sorting(O(nlogn))+Iterating through cars(O(n)) = O(nlogn)"
    }
]