[
    {
        "link": "https://nextjs.org/docs/pages/building-your-application/configuring/environment-variables",
        "document": "Next.js comes with built-in support for environment variables, which allows you to do the following:\n• Bundle environment variables for the browser by prefixing with\n\nNext.js has built-in support for loading environment variables from files into .\n\nThis loads , , and into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes.\n\nFor example, using :\n\nIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the package.\n\nThis package is used internally by Next.js to load environment variables from files.\n\nTo use it, install the package and use the function to load the environment variables:\n\nThen, you can import the configuration where needed. For example:\n\nNext.js will automatically expand variables that use to reference other variables e.g. inside of your files. This allows you to reference other secrets. For example:\n\nIn the above example, would be set to .\n\nNon- environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).\n\nIn order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to with a hard-coded value. To tell it to do this, you just have to prefix the variable with . For example:\n\nThis will tell Next.js to replace all references to in the Node.js environment with the value from the environment in which you run , allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.\n\nNote: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).\n\nNote that dynamic lookups will not be inlined, such as:\n\nNext.js can support both build time and runtime environment variables.\n\nBy default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with . However, these public environment variables will be inlined into the JavaScript bundle during .\n\nTo read runtime environment variables, we recommend using or incrementally adopting the App Router.\n\nThis allows you to use a singular Docker image that can be promoted through multiple environments with different values.\n• You can run code on server startup using the function.\n• We do not recommend using the option, as this does not work with the standalone output mode. Instead, we recommend incrementally adopting the App Router if you need this feature.\n\nWhen deploying your Next.js application to Vercel , Environment Variables can be configured in the Project Settings .\n\nAll types of Environment Variables should be configured there. Even Environment Variables used in Development – which can be downloaded onto your local device afterwards.\n\nIf you've configured Development Environment Variables you can pull them into a for usage on your local machine using the following command:\n\nApart from and environments, there is a 3rd option available: . In the same way you can set defaults for development or production environments, you can do the same with a file for the environment (though this one is not as common as the previous two). Next.js will not load environment variables from or in the environment.\n\nThis one is useful when running tests with tools like or where you need to set specific environment vars only for testing purposes. Test default values will be loaded if is set to , though you usually don't need to do this manually as testing tools will address it for you.\n\nThere is a small difference between environment, and both and that you need to bear in mind: won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your (which is intended to override the default set).\n\nWhile running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the function from the package.\n\nEnvironment variables are looked up in the following places, in order, stopping once the variable is found.\n\nFor example, if is and you define a variable in both and , the value in will be used.\n• If you are using a directory, files should remain in the root of your project.\n• If the environment variable is unassigned, Next.js automatically assigns when running the command, or for all other commands."
    },
    {
        "link": "https://nextjs.org/docs/app/building-your-application/configuring/environment-variables",
        "document": "Next.js comes with built-in support for environment variables, which allows you to do the following:\n• Bundle environment variables for the browser by prefixing with\n\nNext.js has built-in support for loading environment variables from files into .\n\nIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the package.\n\nThis package is used internally by Next.js to load environment variables from files.\n\nTo use it, install the package and use the function to load the environment variables:\n\nThen, you can import the configuration where needed. For example:\n\nNext.js will automatically expand variables that use to reference other variables e.g. inside of your files. This allows you to reference other secrets. For example:\n\nIn the above example, would be set to .\n\nNon- environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).\n\nIn order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to with a hard-coded value. To tell it to do this, you just have to prefix the variable with . For example:\n\nThis will tell Next.js to replace all references to in the Node.js environment with the value from the environment in which you run , allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.\n\nNote: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).\n\nNote that dynamic lookups will not be inlined, such as:\n\nNext.js can support both build time and runtime environment variables.\n\nBy default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with . However, these public environment variables will be inlined into the JavaScript bundle during .\n\nYou can safely read environment variables on the server during dynamic rendering:\n\nThis allows you to use a singular Docker image that can be promoted through multiple environments with different values.\n• You can run code on server startup using the function.\n• We do not recommend using the option, as this does not work with the standalone output mode. Instead, we recommend incrementally adopting the App Router if you need this feature.\n\nWhen deploying your Next.js application to Vercel , Environment Variables can be configured in the Project Settings .\n\nAll types of Environment Variables should be configured there. Even Environment Variables used in Development – which can be downloaded onto your local device afterwards.\n\nIf you've configured Development Environment Variables you can pull them into a for usage on your local machine using the following command:\n\nApart from and environments, there is a 3rd option available: . In the same way you can set defaults for development or production environments, you can do the same with a file for the environment (though this one is not as common as the previous two). Next.js will not load environment variables from or in the environment.\n\nThis one is useful when running tests with tools like or where you need to set specific environment vars only for testing purposes. Test default values will be loaded if is set to , though you usually don't need to do this manually as testing tools will address it for you.\n\nThere is a small difference between environment, and both and that you need to bear in mind: won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your (which is intended to override the default set).\n\nWhile running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the function from the package.\n\nEnvironment variables are looked up in the following places, in order, stopping once the variable is found.\n\nFor example, if is and you define a variable in both and , the value in will be used.\n• If you are using a directory, files should remain in the root of your project.\n• If the environment variable is unassigned, Next.js automatically assigns when running the command, or for all other commands."
    },
    {
        "link": "https://stackoverflow.com/questions/70804091/using-env-file-to-specify-server-listening-port-of-the-next-js-server",
        "document": "I've been searching for a method how to set up the server port of the Next.js application. I found 2 methods:\n• { \"scripts\": { \"dev\": \"next dev -p 8012\", \"build\": \"next build\", \"start\": \"next start -p 8012\", } }\n• None From the command line: OR\n\nNone of these looks fine to me. The problem with the first approach is that package.json is versioned by git. This means that I must use the same port on my local env as is used on production. I may have some other program listening on that port locally. This is inconvenient to me.\n\nThe second approach implies that my memory serves me very well. I have to memorize the port I want to use locally as well as on production, staging or any other environemnt. This is not OK too.\n\nIdeally, I would like to have the PORT specified in the files. I tried it - doesn't work.\n\nHave anyone come across such an issue?"
    },
    {
        "link": "https://blog.logrocket.com/customizing-environment-variables-next-js-13",
        "document": "Environment variables are values that can be used to modify an application’s behavior to suit the needs and requirements of a specific environment during production. Most frontend frameworks and cloud hosting services have built-in support for configuring and managing environment variables. Next.js is no exception. In this article, we will take a deep dive into environment variables and explore their customization in Next.js.\n• Understanding environment variables\n• What do you store in environment variables?\n• Using environment variables in local development vs. production\n\nEnvironment variables are external values that developers define outside of the actual application code. These values can be used to influence the behavior of an application, and they often store sensitive data like API keys. Environment variables consist of name-value pairs like in the example below:\n\nAn application can have different requirements when running in development, testing, and production environments. Instead of having different codebases for the same application, where each codebase is tailored towards a specific environment, an application can have a single codebase whose behavior in the different environments is determined using the environment variable settings.\n\nThe application can read the environment variable settings and modify its behavior to meet the requirements of that specific environment. This keeps the codebase short, clean, and organized:\n\nIn a development environment, tools for code formatting, linting, and testing are essential. However these tools are not necessary in the production stage. When working with tools such as npm, setting the value of the built-in environment variable to will install dependencies that the application needs in production, excluding those needed in the development stage. This behavior is configurable if necessary.\n\nSimilarly, during development, you may need to set up a local instance of your database server separate from the production server. You will have to use environment variables to pick the correct database connection string.\n\nUsually, modifying an environment variable modifies the behavior of an application without requiring you to rebuild or redeploy the application. But in frameworks like Next.js, some environment variables are hardcoded in the codebase at build time. You may need to build and redeploy after modifying an environment variable.\n\nWhat do you store in environment variables?\n\nYou can use environment variables to store the following:\n• Information about the environment or context in which your application runs. The requirements of a production environment are almost always different from the requirements of development, staging, and testing environments\n• Credentials for third-party services like API keys that you don’t want to expose\n• Resource URIs, database connection strings, and API endpoints you want to keep private\n• Constants and default values that you want to declare at a central location but want to reference from different modules or places in your code\n\nAs mentioned earlier, Next.js has built-in support for environment variables. To start using them, you can declare at the root of your project directory:\n\nNext.js will load the above environment variables into the object out of the box so that you can access them in the Node.js environment:\n\nThe above environment variables are only available in the Node.js environment and are referred to as private environment variables. Prefixing the variable name with turns them into public environment variables:\n\nPublic environment variables are available both in the browser and Node.js environments. We will explore public and private environment variables later in this article.\n\nIn addition to the file, Next.js also gives you the flexibility to store constants and default values in , , and environment files. These files are not meant for storing secrets but for environment-specific configurations and settings.\n\nAs its name suggests, the file is for environment variables you want to use only in development. In Next.js, you can launch the development server using the command. The variables you declare in the file won’t be available in production.\n\nThe file, on the other hand, is for variables that you want to use only in production. The command builds the project and launches the production environment. The variables you declare in the file won’t be available in the development environment.\n\nThe variables you declare in the file will be available in both development and production environments. Be aware that an environment variable that you look up dynamically, such as in the example below, will not be hardcoded into your production build as we just described:\n\nYou can use this sample application to try out the examples in this article. Follow the steps below to clone the repository to your machine and experiment with the environment variables this article highlights.\n\nFirst, clone a sample application. Use to clone the sample application to your machine. Then, install dependencies by running the command.\n\nThere are several environment variable files at the root of your project directory. In Next.js, you only store secrets in the file. Because environment variables holding secrets should not be shared, there is a file you can use to create your file.\n\nTo add secrets, create a file at the root of your project repository and copy the contents of into it. You can add any secrets you don’t want to expose in a version control system in the file.\n\nNext, you can launch the development server using the command. The environment variables in the file are available only in the development environment. On the other hand, you can build the project and launch the production server using the and commands. The environment variables in the file are available only in the production environment.\n\nNow, the environment variables in the file are available in both the development and production environments.\n\nAs we introduced earlier, Next.js environment variables can be categorized into public and private environment variables, but they are private by default. Private environment variables are only accessible from the Node.js environment. You can declare private environment variables in any of your files like so:\n\nTo make an environment variable public, prefix its name with as in the example below:\n\nAt build time, Next.js will access and replace references to the public environment variables with their actual values in the codebase bundled for the browser environment.\n\nTherefore, in the example below, will be replaced in line with the actual value of the environment variable at build time:\n\nPublic environment variables are mostly used for storing constants or default values that you don’t want to import or declare in multiple files. You can declare such variables once in a file, as in the example above, and access them from anywhere in your codebase. They are available both in the browser and in Node.js.\n\nUsing environment variables in local development vs. production\n\nThe requirements of an application while in development may not be the same as those in production. Therefore, some environment variables may only be required in development, others in production, and some in both environments.\n\nFor example, if you declare the environment variables below in the file, they will be available only in the production environment:\n\nRegardless of the file in which you declare the above environment variables, the environment variable will be available in the Node.js environment because it is a private variable. And will be available in both the browser and Node.js environments because it is a public environment variable.\n\nNext.js offers flexible ways of working with environment variables. You can use the legacy property of the file to configure environment variables, or the newer, more intuitive, and ergonomic files described above.\n\nYou can declare the environment variable as a property of the object in the file and access it in your codebase as a property of the object:\n\nBe aware that using the file for your environment variables will inline the values of the variables at build time and bundle them in your frontend code, irrespective of whether you prefix the variable name with or not:\n\nSoftware development across remote, distributed teams requires the use of version control systems such as Git and cloud Git hosting services like GitHub, BitBucket, and GitLab. During development, certain secrets such as API endpoints, usernames, passwords, API keys, database connection strings, and other credentials that are specific to your local development environment must not be exposed.\n\nIn Next.js, you can securely store secrets in the file. You can add the file to your file to avoid checking it into a version control system like Git and pushing it to a cloud Git hosting service like GitHub. Do not store secrets in other environment variables that are not meant for storing secrets.\n\nChecking environment variables to a version control system may result in incurring significant costs if unknown individuals get access to your API keys or production database connection string.\n\nYou can share a template of the file and its contents in a or file so that project contributors can set up their development environment using the file template.\n\nNext.js will evaluate all references to environment variables and hardcode them in your client code at build time. After that, all the evaluated values won’t respond to changes in the environment variable.\n\nIf your frontend application needs access to dynamic environment variables at runtime, you should set up your own API and provide the variables to your client code.\n\nSimilarly, dynamically looking up or destructuring environment variables in your frontend code, as in the example below, won’t work. The value of the environment value will be . Always access your environment variables using on the client side:\n\nAs explained above, you can declare environment variables in different files. These files are for environment variables that are usually made available in specific environments.\n\nNext.js follows the order below when looking for an environment variable and stops after finding the variable it needs. The value of is set to in a development environment, in a production environment, and in a test environment:\n\nIf you declare the same environment variable in multiple files, the environment variable declared in the lowest file in the above list wins.\n\nIn Next.js, you can create an environment variable by referencing or composing other environment variables using the syntax. Next.js will expand and replace any referenced variable with its actual value.\n\nThe example below uses the and environment variables to create . The value of the variable will evaluate to :\n\nSuch composition avoids repetition and keeps your environment variable files organized. You can now reference each environment variable independently from your codebase:\n\nCross-file environment variable referencing is also possible in Next.js. You can reference an environment variable declared in the file from the file. However, you should pay attention to the order of the environment variable lookup as highlighted above if you have variables with similar names in different files.\n\nReferencing a variable declared in from and vice versa won’t work because those environment variables will only be available in their respective environments.\n\nEnvironment variables influence the way an application runs or behaves in different contexts and environments. Next.js, like most web frameworks, has the necessary setup for flexibly configuring and using environment variables in your application.\n\nIn this article, we explored the differences between private and public environment variables in Next.js. We also learned about functionalities that allow you to declare development-only and production-only environment variables, such as the and files.\n\nFinally, we learned that in a typical Next.js project, you only need the file to store credentials that you want to keep secret. Always add the file to your file to avoid exposing your secrets in a version control system like Git."
    },
    {
        "link": "https://stackoverflow.com/questions/59462614/how-to-use-different-env-files-with-nextjs",
        "document": "I would like to have different configuration files for the environment variables and be able to use them in my next project. I saw the example with dotenv. But I don't like to define the variables in the .env file and also define them in the config.next.js file. if for some reason I put the variables in the .env file but forget to put them in the config.next.js file the code starts having problems. Theres is a way to do it more eficiently? \"scripts\": { \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"eslint pages --ext .ts,.tsx,.js\", \"test\": \"jest\", \"commit\": \"git-cz\", \"dev:production\": \"dotenv next\" }, import { NextPage } from 'next'; import { FunctionComponent } from 'react'; interface HelloWorldProps { nombre: string, saludo?: string } const HelloWorld: FunctionComponent<HelloWorldProps> = ({ nombre, saludo = 'noches' }: HelloWorldProps) => ( <> <h1>Hola {nombre} buenas {saludo}</h1> {/* eslint-disable-next-line multiline-ternary */} <h2>{process.env.TITULO ? 'hola' : 'adios'}</h2> </> ); const Home: NextPage = () => <HelloWorld nombre=\"cristian\" />; export default Home;"
    },
    {
        "link": "https://next-auth.js.org/errors",
        "document": "This is a list of errors output from NextAuth.js.\n\nAll errors indicate an unexpected problem, you should not expect to see errors.\n\nIf you are seeing any of these errors in the console, something is wrong.\n\nThese errors are returned from the client. As the client is Universal JavaScript (or \"Isomorphic JavaScript\") it can be run on the client or server, so these errors can occur both in the terminal and in the browser console.\n\nThis error occurs when the Context has a problem fetching session data.\n\nThis can happen for multiple reasons. Make sure that you configured NextAuth.js correctly, and if you used that it's correctly set.\n\nThese errors are displayed on the terminal.\n\nThis occurs when there was an error in the POST request to the OAuth provider and we were not able to retrieve the access token.\n\nThis error is explicitly related to older OAuth v1.x providers, if you are using one of these, please double check all available settings.\n\nThis error is a result of either a problem with the provider response or the user canceling the action with the provider, unfortunately, we can't discern which with the information we have.\n\nThis error should also log the exception and available to further aid debugging.\n\nThis error will occur when there was an issue parsing the JSON request body, for example.\n\nThere should also be further details logged when this occurs, such as the error is thrown, and the request body itself to aid in debugging.\n\nThis error occurs during the redirection to the authorization URL of the OAuth provider. Possible causes:\n• Cookie handling Either PKCE code verifier or the generation of the CSRF token hash in the internal state failed.\n\nIf set, check your configuration, and make sure the browser is not blocking/restricting cookies.\n\nPlease check your OAuth provider and make sure your URLs and other options are correctly set.\n\nIf you are using an OAuth v1 provider, check your OAuth v1 provider settings, especially the OAuth token and OAuth token secret.\n\nIf you are seeing expected 200 OK with body but no body was returned , it might have happened due to (which is a dependency we rely on) node version mismatch. For instance, requires for and has similar limits for the other versions. For the full list of the compatible node versions please see package.json.\n\nThis can occur during the handling of the callback if the cookie was not found or an invalid state was returned from the OAuth provider.\n\nThis error can occur when a user tries to sign in via an email link; for example, if the email token could not be generated or the verification request failed.\n\nThis can occur during the email callback process. Specifically, if there was an error signing the user in via email, encoding the jwt, etc.\n\nThe Email authentication provider can only be used if a database is configured.\n\nThis is required to store the verification token. Please see the email provider for more details.\n\nThe Credentials Provider can only be used if JSON Web Tokens are used for sessions.\n\nJSON Web Tokens are used for Sessions by default if you have not specified a database. However, if you are using a database, then Database Sessions are enabled by default and you need to explicitly enable JWT Sessions to use the Credentials Provider.\n\nIf you are using a Credentials Provider, NextAuth.js will not persist users or sessions in a database - user accounts used with the Credentials Provider must be created and managed outside of NextAuth.js.\n\nIn most cases it does not make sense to specify a database in NextAuth.js options and support a Credentials Provider.\n\nThis error occurs when there was no handler defined on the credential authentication provider.\n\nThe provider you tried to use failed when setting PKCE or Proof Key for Code Exchange. The is saved in a cookie called (by default) which expires after 15 minutes. Check if is configured correctly.\n\nThe default is . This is currently not configurable to , as per RFC7636:\n\nThe provided was either invalid or not defined. See specifying a for more information.\n\nJWEDecryptionFailed: NextAuth.js needs environment variable to encrypt JWTs and to hash email verification tokens. This can also occur if you have changed the , but you still had an active session with the old secret. Logging in again solves the issue.\n\nJWTKeySupport: the key does not support HS512 verify algorithm\n\nThe algorithm used for generating your key isn't listed as supported. You can generate a HS512 key using\n\nThis error occurs when there was an issue deleting the session from the database, for example.\n\nThis error happens when file is not found inside .\n\nMake sure the file is there and the filename is written correctly.\n\nIn production, we expect you to define a property in your configuration. In development, this is shown as a warning for convenience. Read more\n\nYou have a custom error page defined that was rendered due to an error, but the page also required authentication. To avoid an infinite redirect loop, NextAuth.js bailed out and rendered its default error page instead.\n\nIf you are using a Middleware, make sure you include the same configuration in your and files. Or use the option to only require authentication for certain sites (and exclude your custom error page).\n\nIf you do not use a Middleware, make sure you don't try redirecting the user to the sign-in page when hitting your custom error page."
    },
    {
        "link": "https://next-auth.js.org/configuration/callbacks",
        "document": "Callbacks are asynchronous functions you can use to control what happens when an action is performed.\n\nCallbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs.\n\nYou can specify a handler for any of the callbacks below.\n\nThe documentation below shows how to implement each callback, their default behaviour and an example of what the response for each callback should be. Note that configuration options and authentication providers you are using can impact the values passed to the callbacks.\n\nUse the callback to control if a user is allowed to sign in.\n• None When using the Email Provider the callback is triggered both when the user makes a Verification Request (before they are sent an email with a link that will allow them to sign in) and again after they activate the link in the sign-in email. Email accounts do not have profiles in the same way OAuth accounts do. On the first call during email sign in the object will include a property to indicate it is being triggered in the verification request flow. When the callback is invoked after a user has clicked on a sign-in link, this property will not be present. You can check for the property to avoid sending emails to addresses or domains on a blocklist (or to only explicitly generate them for email address in an allow list).\n• When using the Credentials Provider the object is the response returned from the callback and the object is the raw body of the submission.\n\nThe redirect callback is called anytime the user is redirected to a callback URL (e.g. on signin or signout).\n\nBy default only URLs on the same URL as the site are allowed, you can use the redirect callback to customise that behaviour.\n\nThe default redirect callback looks like this:\n\nThis callback is called whenever a JSON Web Token is created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). The returned value will be encrypted, and it is stored in a cookie.\n\nRequests to , and calls to , , will invoke this function, but only if you are using a JWT session. This method is not invoked when you persist sessions in a database.\n• As with database persisted session expiry times, token expiry time is extended whenever a session is active.\n• The arguments user, account, profile and isNewUser are only passed the first time this callback is called on a new session, after the user signs in. In subsequent calls, only will be available.\n\nThe contents user, account, profile and isNewUser will vary depending on the provider and if you are using a database. You can persist data such as User ID, OAuth Access Token in this token, see the example below for and . To expose it on the client side, check out the callback as well.\n\nThe session callback is called whenever a session is checked. By default, only a subset of the token is returned for increased security. If you want to make something available you added to the token (like and from above) via the callback, you have to explicitly forward it here to make it available to the client.\n• When using database sessions, the User ( ) object is passed as an argument.\n• When using JSON Web Tokens for sessions, the JWT payload ( ) is provided instead."
    },
    {
        "link": "https://github.com/nextauthjs/next-auth/discussions/8209",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://next-auth.js.org/v3/errors",
        "document": "This is a list of errors output from NextAuth.js.\n\nAll errors indicate an unexpected problem, you should not expect to see errors.\n\nIf you are seeing any of these errors in the console, something is wrong.\n\nThese errors are returned from the client. As the client is Universal JavaScript (or \"Isomorphic JavaScript\") it can be run on the client or server, so these errors can occur in both in the terminal and in the browser console.\n\nThis error occurs when the React Hook has a problem fetching session data.\n\nIf you see make sure you have configured the environment variable.\n\nThese errors are displayed on the terminal.\n\nThe Email authentication provider can only be used if a database is configured.\n\nThe Credentials Provider can only be used if JSON Web Tokens are used for sessions.\n\nJSON Web Tokens are used for Sessions by default if you have not specified a database. However if you are using a database, then Database Sessions are enabled by default and you need to explicitly enable JWT Sessions to use the Credentials Provider.\n\nIf you are using a Credentials Provider, NextAuth.js will not persist users or sessions in a database - user accounts used with the Credentials Provider must be created and managed outside of NextAuth.js.\n\nIn most cases it does not make sense to specify a database in NextAuth.js options and support a Credentials Provider.\n\nThe provider you tried to use failed when setting PKCE or Proof Key for Code Exchange. The is saved in a cookie called (by default) which expires after 15 minutes. Check if is configured correctly. The default is . This is currently not configurable to , as it is not recommended, and in most cases it is only supported for backward compatibility.\n\nhttps://next-auth.js.org/errors#jwt_session_error JWKKeySupport: the key does not support HS512 verify algorithm\n\nThe algorithm used for generating your key isn't listed as supported. You can generate a HS512 key using\n\nIf you are unable to use an HS512 key (for example to interoperate with other services) you can define what is supported using\n\nThese errors are logged by the TypeORM Adapter, which is the default database adapter.\n\nThey all indicate a problem interacting with the database.\n\nThis error occurs when the Email Authentication Provider is unable to send an email.\n\nThis error happens when file is not found inside .\n\nMake sure the file is there and the filename is written correctly."
    },
    {
        "link": "https://bswanson.dev/blog/nextauth-oauth-passing-errors-to-the-client",
        "document": "Note: The Next.js package for Auth.js is still called NextAuth. The code examples in this article use NextAuth, but my solution will likely work on other frameworks that Auth.js supports, like SvelteKit, SolidStart, and Qwik.\n\nRecently, I was building a Next.js app with NextAuth. I had to add an OAuth provider with an additional authorization check. However, if the authorization check failed, I found that the client received this obscure error message:\n\nThis is hardly user-friendly, so I tried to throw a custom error in my authorization handler:\n\n// Pass the `user` field from the user's JWT to their session, // allowing us to access it with the `auth()` function or via `useSession()` on the client. // `account` is only present on the initial login. // Fetch some data from an external service that should be attached to the user's JWT. // Don't do this with data that you expect to change while the user is signed in! // You will have to re-issue a new JWT every time it changes. // Add the info to the user's token \"We couldn't find your profile. Please contact us if the error persists.\" // Augment the User interface with some custom data // Add a user field to the JWT so that the information can be transferred to the session\n\nHowever, my new error message wasn’t being displayed. I did some research and came across this GitHub issue about passing errors to the client from a credential provider’s handler.\n\nThe only difference between their situation and mine was that I was using a handler on the user’s first login instead of implementing my logic with a credentials provider, and the issue’s proposed solution and its eventual implementation didn’t support that use case.\n\nNote: If you are using a credentials provider and your error-prone logic is in the callback, see this pull request for a built-in solution.\n\nMy idea was to add a field on the token when an error occurs that can be checked in middleware or on the client. Here’s how you can replicate this in your own app.\n\nFirst, if you’re using TypeScript, augment the JWT and Session interfaces:\n\nPassing The Error to The Client\n\nThen, in your callback, set an property on the user’s token when an exception is thrown:\n\n// This function should be in the `callbacks` object in your Auth.js config. // Some code that could throw an error \"You are not allowed to access this application.\" \"There was a problem signing you in.\"\n\nFinally, in your callback, pass the property from the user’s token to their session:\n\nNow, you can access the error from the client or in middleware. Here’s a Next.js middleware example:\n\n// `req.auth` is populate with the user's session when using // For example, you can use the error as a URL parameter: // Side note: you can save middleware invocations by configuring it to not run on static files and API routes.\n\nLearn more about Auth.js middleware for Next.js in their official docs.\n\n⚠️ If you create a custom error page as shown in the middleware example, make sure to sign the user out when they visit it! Otherwise, you may accidentally create an infinite loop that prevents the user from making another sign-in attempt.\n\nIf you want to access it on the client, you can write a component like this:\n\nYou can use this as a normal React component in your root layout:\n\nAfter writing this, I realized the NextAuth developers used the same pattern in their documentation! In the section about handling Google refresh tokens, if there was an error refreshing the user’s access token, the callback sets an error on the user’s token, which is passed to the user’s session. When the client sees a session with a , it signs the user out."
    },
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/pagination",
        "document": "Offset pagination uses and to skip a certain number of results and select a limited range. The following query skips the first 3 records and returns records 4 - 7:\n\nTo implement pages of results, you would just the number of pages multiplied by the number of results you show per page.\n• You can jump to any page immediately. For example, you can 200 records and 10, which simulates jumping straight to page 21 of the result set (the underlying SQL uses ). This is not possible with cursor-based pagination.\n• You can paginate the same result set in any sort order. For example, you can jump to page 21 of a list of records sorted by first name. This is not possible with cursor-based pagination, which requires sorting by a unique, sequential column.\n• Offset pagination does not scale at a database level. For example, if you skip 200,000 records and take the first 10, the database still has to traverse the first 200,000 records before returning the 10 that you asked for - this negatively affects performance.\n• Shallow pagination of a small result set. For example, a blog interface that allows you to filter records by author and paginate the results.\n\nThe following query returns all records where the field contains . The query skips the first 40 records and returns records 41 - 50.\n\nThe following query returns all records where the field contains , and sorts the result by the field. The query skips the first 200 records and returns records 201 - 220.\n\nCursor-based pagination uses and to return a limited set of results before or after a given cursor. A cursor bookmarks your location in a result set and must be a unique, sequential column - such as an ID or a timestamp.\n\nThe following example returns the first 4 records that contain the word and saves the ID of the last record as :\n\nThe following diagram shows the IDs of the first 4 results - or page 1. The cursor for the next query is 29:\n\nThe second query returns the first 4 records that contain the word after the supplied cursor (in other words - IDs that are larger than 29):\n\nThe following diagram shows the first 4 records after the record with ID 29. In this example, the new cursor is 52:\n\nIf you do not , your result set will include your previous cursor. The first query returns four results and the cursor is 29:\n\nWithout , the second query returns 4 results after (and including) the cursor:\n\nIf you , the cursor is not included:\n\nYou can choose to or not depending on the pagination behavior that you want.\n\nIf you guess the value of the next cursor, you will page to an unknown location in your result set. Although IDs are sequential, you cannot predict the rate of increment ( , , is more likely than , , , particularly in a filtered result set).\n\nNo, cursor pagination does not use cursors in the underlying database (e.g. PostgreSQL ).\n\nUsing a nonexistent cursor returns . Prisma Client does not try to locate adjacent values.\n• Cursor-based pagination scales. The underlying SQL does not use , but instead queries all records with an ID greater than the value of .\n• You must sort by your cursor, which has to be a unique, sequential column.\n• You cannot jump to a specific page using only a cursor. For example, you cannot accurately predict which cursor represents the start of page 400 (page size 20) without first requesting pages 1 - 399.\n• Infinite scroll - for example, sort blog posts by date/time descending and request 10 blog posts at a time.\n• Paging through an entire result set in batches - for example, as part of a long-running data export.\n\nCursor-based pagination requires you to sort by a sequential, unique column such as an ID or a timestamp. This value - known as a cursor - bookmarks your place in the result set and allows you to request the next set.\n\nTo page backwards, set to a negative value. The following query returns 4 records with an of less than 200, excluding the cursor:"
    },
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/query-optimization-performance",
        "document": "This guide shows how to identify and optimize query performance, debug performance issues, and address common challenges.\n\nSeveral common practices can lead to slow queries and performance problems, such as:\n\nPrisma Optimize offers recommendations to identify and address the inefficiencies listed above and more, helping to improve query performance.\n\nTo get started, follow the integration guide and add Prisma Optimize to your project to begin diagnosing slow queries.\n\nIt is generally more performant to read and write large amounts of data in bulk - for example, inserting records in batches of rather than as separate inserts. supports the following bulk queries:\n\nCreating multiple instances of can exhaust your database connection pool, especially in serverless or edge environments, potentially slowing down other queries. Learn more in the serverless challenge.\n\nFor applications with a traditional server, instantiate once and reuse it throughout your app instead of creating multiple instances. For example, instead of:\n\nDefine a single instance in a dedicated file and re-export it for reuse:\n\nFor serverless development environments with frameworks that use HMR (Hot Module Replacement), ensure you properly handle a single instance of Prisma in development.\n\nThe n+1 problem occurs when you loop through the results of a query and perform one additional query per result, resulting in number of queries plus the original (n+1). This is a common problem with ORMs, particularly in combination with GraphQL, because it is not always immediately obvious that your code is generating inefficient queries.\n\nThe Prisma Client dataloader automatically batches queries that occur in the same tick and have the same and parameters if:\n• All criteria of the filter are on scalar fields (unique or non-unique) of the same model you're querying.\n• All criteria use the filter, whether that's via the shorthand or explicit syntax .\n• No boolean operators or relation filters are present.\n\nAutomatic batching of is particularly useful in a GraphQL context. GraphQL runs a separate resolver function for every field, which can make it difficult to optimize a nested query.\n\nFor example - the following GraphQL runs the resolver to get all users, and the resolver once per user to get each user's posts (n+1):\n\nThe query uses to return all users:\n\nHowever, the resolver function for is then invoked once per user. This results in a query ✘ per user rather than a single to return all posts by all users (expand CLI output to see queries).\n\nUse in combination with the fluent API ( ) as shown to return a user's posts. Even though the resolver is called once per user, the Prisma dataloader in Prisma Client ✔ batches the queries.\n\nIf the resolver is invoked once per user, the dataloader in Prisma Client groups queries with the same parameters and selection set. Each group is optimized into a single .\n\nYou can perform the query with a database join by setting to , ensuring that only one query is executed against the database.\n\nThe n+1 problem is most commonly seen in a GraphQL context because you have to find a way to optimize a single query across multiple resolvers. However, you can just as easily introduce the n+1 problem by looping through results with in your own code.\n\nThe following code results in n+1 queries - one to get all users, and one per user to get each user's posts:\n\nThis is not an efficient way to query. Instead, you can:\n• Use nested reads ( ) to return users and related posts\n\nYou can use to return each user's posts. This only results in two SQL queries - one to get users, and one to get posts. This is known as a nested read.\n\nIf you have a list of user IDs, you can use the filter to return all posts where the is that list of IDs:\n\nYou can perform the query with a database join by setting to , ensuring that only one query is executed against the database."
    },
    {
        "link": "https://medium.com/@mohantaankit2002/optimizing-database-queries-in-prisma-real-world-examples-for-improving-performance-d7bf77d023ec",
        "document": "When working with databases, performance matters, especially as your app scales. If your queries aren’t optimized, you’ll eventually face slow response times, high memory usage, and server overloads, which could turn into a disaster. Enter Prisma: an intuitive ORM that provides powerful querying capabilities. But even with Prisma, you need to be mindful of how you craft your queries to ensure optimal performance.\n\nIn this blog, we’ll dive deep into how to optimize Prisma queries with real-world examples. By the end, you’ll have a better grasp of how to handle complex queries efficiently and ensure your database interactions are fast and scalable.\n\nPrisma is an excellent choice for working with databases in a type-safe way. It makes query writing clean and straightforward, especially with TypeScript. But as your application grows, poorly optimized queries can still become a bottleneck. Here are some reasons why query optimization matters:"
    },
    {
        "link": "https://github.com/prisma/prisma/discussions/3087",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting",
        "document": "Prisma Client supports filtering with the query option, and sorting with the query option.\n\nPrisma Client allows you to filter records on any combination of model fields, including related models, and supports a variety of filter conditions.\n• Returns all records with:\n• an email address that ends with and\n• at least one published post (a relation query)\n\nRefer to Prisma Client's reference documentation for a full list of operators , such as and .\n\nYou can use operators (such as and ) to filter by a combination of conditions. The following query returns all users whose ends with or , but excludes any emails ending with\n\nThe following query returns all posts whose field is :\n\nThe following query returns all posts whose field is not :\n\nPrisma Client supports filtering on related records. For example, in the following schema, a user can have many blog posts:\n\nThe one-to-many relation between and allows you to query users based on their posts - for example, the following query returns all users where at least one post ( ) has more than 10 views:\n\nYou can also query posts based on the properties of the author. For example, the following query returns all posts where the author's contains :\n\nScalar lists (for example, ) have a special set of filter conditions - for example, the following query returns all posts where the array contains :\n\nCase-insensitive filtering is available as a feature for the PostgreSQL and MongoDB providers. MySQL, MariaDB and Microsoft SQL Server are case-insensitive by default, and do not require a Prisma Client feature to make case-insensitive filtering possible.\n\nTo use case-insensitive filtering, add the property to a particular filter and specify :\n\nFor MySQL and PostgreSQL, Prisma Client utilizes the (and ) operator to search for a given pattern. The operators have built-in pattern matching using symbols unique to . The pattern-matching symbols include for zero or more characters (similar to in other regex implementations) and for one character (similar to )\n\nTo match the literal characters, or , make sure you escape those characters. For example:\n\nThe above query will match any user whose name starts with a character followed by such as or . If you instead wanted to find any user whose name starts with the literal string , you could do:\n\nUse to sort a list of records or a nested list of records by a particular field or set of fields. For example, the following query returns all records sorted by and , and each user's posts sorted by :\n\nYou can also sort by properties of a relation. For example, the following query sorts all posts by the author's email address:\n\nIn 2.19.0 and later, you can sort by the count of related records.\n\nFor example, the following query sorts users by the number of related posts:\n\nIn 3.5.0+ for PostgreSQL and 3.8.0+ for MySQL, you can sort records by relevance to the query using the keyword. This uses the relevance ranking functions from full text search features.\n\nThis feature is further explain in the PostgreSQL documentation and the MySQL documentation .\n\nFor PostgreSQL, you need to enable order by relevance with the preview feature:\n\nOrdering by relevance can be used either separately from or together with the filter: is used to order the list, while filters the unordered list.\n\nFor example, the following query uses to filter by the term in the field, and then sorts the result by relevance in a descending manner:\n\nYou can sort the results so that records with fields appear either first or last.\n\nIf is an optional field, then the following query using sorts users by , with records at the end:\n\nIf you want the records with values to appear at the beginning of the returned array, use :\n\nNote that also is the default value, so if you omit the option, values will appear first in the returned array."
    }
]