[
    {
        "link": "https://stackoverflow.com/questions/29623148/how-to-create-interactive-graphics-with-wpf",
        "document": "I wonder how I can code an application that allows the user to handle simple graphic objects like in a vector graphics program. As a starting point I would like to have a program which allows the user to draw some rectangles, select them with the mouse and move them around.\n\nI have some base knowledge in WinForms but it seems that WPF is a better choice for this task (tell me if you think different. I wouldn't mind using a free graphics library for Winforms as alternative).\n\nI think I know hot to draw a rectangle and how to find out which rectange was clicked by the user. But I don't know how to move the rectangle around with the mouse. Can you give me a hint? I had a look into animations where I could move the rectanle around programatically but I am not sure whether this is the right way to implement it for mouse control."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/shapes-and-basic-drawing-in-wpf-overview?view=netframeworkdesktop-4.8",
        "document": "This topic gives an overview of how to draw with Shape objects. A Shape is a type of UIElement that enables you to draw a shape to the screen. Because they are UI elements, Shape objects can be used inside Panel elements and most controls.\n\nWindows Presentation Foundation (WPF) offers several layers of access to graphics and rendering services. At the top layer, Shape objects are easy to use and provide many useful features, such as layout and participation in the Windows Presentation Foundation (WPF) event system.\n\nShape-related types are in the namespace. Geometry-related types are in the namespace.\n\nWPF provides a number of ready-to-use Shape objects. All shape objects inherit from the Shape class. Available shape objects include Ellipse, Line, Path, Polygon, Polyline, and Rectangle. Shape objects share the following common properties.\n• None Stroke: Describes how the shape's outline is painted.\n• None StrokeThickness: Describes the thickness of the shape's outline.\n• None Fill: Describes how the interior of the shape is painted.\n• None Data properties to specify coordinates and vertices, measured in device-independent pixels.\n\nBecause they derive from UIElement, shape objects can be used inside panels and most controls. The Canvas panel is a particularly good choice for creating complex drawings because it supports absolute positioning of its child objects.\n\nThe Line class enables you to draw a line between two points. The following example shows several ways to specify line coordinates and stroke properties.\n\nThe following image shows the rendered Line.\n\nAlthough the Line class does provide a Fill property, setting it has no effect because a Line has no area.\n\nAnother common shape is the Ellipse. Create an Ellipse by defining the shape's Width and Height properties. To draw a circle, specify an Ellipse whose Width and Height values are equal.\n\nThe following image shows an example of a rendered Ellipse.\n\nThe Path class enables you to draw curves and complex shapes. These curves and shapes are described using Geometry objects. To use a Path, you create a Geometry and use it to set the Path object's Data property.\n\nThere are a variety of Geometry objects to choose from. The LineGeometry, RectangleGeometry, and EllipseGeometry classes describe relatively simple shapes. To create more complex shapes or create curves, use a PathGeometry.\n\nPathGeometry objects are comprised of one or more PathFigure objects; each PathFigure represents a different \"figure\" or shape. Each PathFigure is itself comprised of one or more PathSegment objects, each representing a connected portion of the figure or shape. Segment types include the following: LineSegment, BezierSegment, and ArcSegment.\n\nIn the following example, a Path is used to draw a quadratic Bezier curve.\n\nThe following image shows the rendered shape.\n\nFor more information about PathGeometry and the other Geometry classes, see the Geometry Overview.\n\nIn Extensible Application Markup Language (XAML), you may also use a special abbreviated syntax to describe a Path. In the following example, abbreviated syntax is used to draw a complex shape.\n\nThe Data attribute string begins with the \"moveto\" command, indicated by M, which establishes a start point for the path in the coordinate system of the Canvas. Path data parameters are case-sensitive. The capital M indicates an absolute location for the new current point. A lowercase m would indicate relative coordinates. The first segment is a cubic Bezier curve beginning at (100,200) and ending at (400,175), drawn using the two control points (100,25) and (400,350). This segment is indicated by the C command in the Data attribute string. Again, the capital C indicates an absolute path; the lowercase c would indicate a relative path.\n\nThe second segment begins with an absolute horizontal \"lineto\" command H, which specifies a line drawn from the preceding subpath's endpoint (400,175) to a new endpoint (280,175). Because it is a horizontal \"lineto\" command, the value specified is an x-coordinate.\n\nFor the complete path syntax, see the Data reference and Create a Shape by Using a PathGeometry.\n\nBrush objects are used to paint a shape's Stroke and Fill. In the following example, the stroke and fill of an Ellipse are specified. Note that valid input for brush properties can be either a keyword or hexadecimal color value. For more information about available color keywords, see properties of the Colors class in the System.Windows.Media namespace.\n\nThe following image shows the rendered Ellipse.\n\nAlternatively, you can use property element syntax to explicitly create a SolidColorBrush object to paint the shape with a solid color.\n\nThe following illustration shows the rendered shape.\n\nYou can also paint a shape's stroke or fill with gradients, images, patterns, and more. For more information, see the Painting with Solid Colors and Gradients Overview.\n\nThe Line, Path, Polygon, Polyline, and Rectangle classes all have a Stretch property. This property determines how a Shape object's contents (the shape to be drawn) is stretched to fill the Shape object's layout space. A Shape object's layout space is the amount of space the Shape is allocated by the layout system, because of either an explicit Width and Height setting or because of its HorizontalAlignment and VerticalAlignment settings. For additional information on layout in Windows Presentation Foundation, see Layout overview.\n\nThe Stretch property takes one of the following values:\n• None None: The Shape object's contents are not stretched.\n• None Fill: The Shape object's contents are stretched to fill its layout space. Aspect ratio is not preserved.\n• None Uniform: The Shape object's contents are stretched as much as possible to fill its layout space while preserving its original aspect ratio.\n• None UniformToFill: The Shape object's contents are stretched to completely fill its layout space while preserving its original aspect ratio.\n\nNote that, when a Shape object's contents are stretched, the Shape object's outline is painted after the stretching.\n\nIn the following example, a Polygon is used to draw a very small triangle from (0,0) to (0,1) to (1,1). The Polygon object's Width and Height are set to 100, and its stretch property is set to Fill. As a result, the Polygon object's contents (the triangle) are stretched to fill the larger space.\n\nThe Transform class provides the means to transform shapes in a two-dimensional plane. The different types of transformation include rotation (RotateTransform), scale (ScaleTransform), skew (SkewTransform), and translation (TranslateTransform).\n\nA common transform to apply to a shape is a rotation. To rotate a shape, create a RotateTransform and specify its Angle. An Angle of 45 rotates the element 45 degrees clockwise; an angle of 90 rotates the element 90 degrees clockwise; and so on. Set the CenterX and CenterY properties if you want to control the point about which the element is rotated. These property values are expressed in the coordinate space of the element being transformed. CenterX and CenterY have default values of zero. Finally, apply the RotateTransform to the element. If you don't want the transform to affect layout, set the shape's RenderTransform property.\n\nIn the following example, a RotateTransform is used to rotate a shape 45 degrees about the shape's top left corner (0,0).\n\nIn the next example, another shape is rotated 45 degrees, but this time it's rotated about the point (25,50).\n\nThe following illustration shows the results of applying the two transforms.\n\nIn the previous examples, a single transform was applied to each shape object. To apply multiple transforms to a shape (or any other UI element), use a TransformGroup."
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-wpf?view=vs-2022",
        "document": "In this tutorial, you become familiar with many of the tools, dialog boxes, and designers that you can use when you develop applications with Visual Studio. You create a \"Hello, World\" application, design the user interface, add code, and debug errors. At the same time, learn about working in the Visual Studio integrated development environment (IDE).\n• If you don't have Visual Studio, go to Visual Studio downloads to install it for free.\n• Make sure the .NET desktop development workload is installed. You can verify this configuration in Visual Studio Installer.\n• You can use either .NET Framework or .NET Core for this tutorial. .NET Core is the newer, more modern framework. .NET Core requires Visual Studio 2019 version 16.3 or later.\n\nWindows Presentation Foundation (WPF) is a user interface (UI) framework that creates desktop client applications. The WPF development platform supports a broad set of application development features, including an application model, resources, controls, graphics, layout, data binding, documents, and security.\n\nWPF is part of .NET. If you previously built applications with .NET using ASP.NET or Windows Forms, the programming experience should be familiar. WPF uses the Extensible Application Markup Language (XAML) to provide a declarative model for application programming. For more information, see Desktop Guide (WPF .NET).\n\nWhen you launch Visual Studio, the start window opens. Select Continue without code to open the development environment. You see tool windows, the menus and toolbars, and the main window space. Tool windows are docked on the sides of the application window. The search box, menu bar, and the standard toolbar are located at the top. When you load a solution or project, editors and designers appear in the central space of the application window. When you develop an application, you spend most of your time in this central area.\n\nWhen you create an application in Visual Studio, you first create a project and a solution. For this example, you create a Windows Presentation Foundation (WPF) project.\n• None On the start window, choose Create a new project.\n• None On the Create a new project screen, search for WPF. Choose WPF Application, and then choose Next.\n• None At the next screen, give the project a name, HelloWPFApp, and choose Next.\n• None In the Additional information window, .NET Core 3.1 should already be selected for your target framework. If not, select .NET Core 3.1. Then, choose Create. Visual Studio creates the HelloWPFApp project and solution. Solution Explorer shows the various files. The WPF Designer shows a design view and a XAML view of in a split view. You can slide the splitter to show more or less of either view. You can choose to see only the visual view or only the XAML view. For more information about XAML, see the XAML overview for WPF page. After you create the project, you can customize it. To do so, choose Properties Window from the View menu, or press F4. You can display and change options for project items, controls, and other items in an application.\n• None On the start window, choose Create a new project.\n• None On the Create a new project screen, search for WPF. Choose WPF Application, and then choose Next.\n• None At the next screen, give the project a name, HelloWPFApp, and choose Next.\n• None In the Additional information window, verify that .NET 8.0 is selected for your target framework. Then, choose Create. Visual Studio creates the HelloWPFApp project and solution. Solution Explorer shows the various files. The WPF Designer shows a design view and a XAML view of in a split view. You can slide the splitter to show more or less of either view. You can choose to see only the visual view or only the XAML view. For more information the Extensible Application Markup Language (XAML)), see XAML overview for WPF. After you create the project, you can customize it. To do so, choose Properties Window from the View menu, or press F4. Then, you can display and change options for project items, controls, and other items in an application.\n\nIf the designer isn't open, select and select Shift+F7 to open the designer.\n\nIn this tutorial, you add three types of controls to this application: a TextBlock control, two RadioButton controls, and a Button control.\n\nCustomize the text in the text block\n\nYou can change what text the TextBlock displays.\n• None In the XAML view, locate the markup for TextBlock and change the Text attribute from to Select a message option and then choose the Display button. The XAML markup should look like this example: <Grid> <TextBlock HorizontalAlignment=\"Left\" Margin=\"387,60,0,0\" TextWrapping=\"Wrap\" Text=\"Select a message option and then choose the Display button.\" VerticalAlignment=\"Top\"/> </Grid>\n• None Center the TextBlock again, and then save your changes by selecting Ctrl+S or using the File menu item.\n\nNext, add two RadioButton controls to the form.\n\nNext, add display text for each RadioButton control. The following procedure updates the Content property for a RadioButton control.\n• None Update the Content attribute for the two radio buttons and to and in the XAML. The XAML markup should now look similar to this example: <Grid> <TextBlock HorizontalAlignment=\"Left\" Margin=\"252,47,0,0\" TextWrapping=\"Wrap\" Text=\"Select a message option and then choose the Display button.\" VerticalAlignment=\"Top\"/> <RadioButton x:Name=\"HelloButton\" Content=\"Hello\" HorizontalAlignment=\"Left\" Margin=\"297,161,0,0\" VerticalAlignment=\"Top\"/> <RadioButton x:Name=\"GoodbyeButton\" Content=\"Goodbye\" HorizontalAlignment=\"Left\" Margin=\"488,161,0,0\" VerticalAlignment=\"Top\"/> </Grid>\n\nSet a radio button to be checked by default\n\nIn this step, set HelloButton to be checked by default so that one of the two radio buttons is always selected.\n• None In the XAML view, locate the markup for HelloButton.\n• None Add an IsChecked attribute and set it to True. Specifically, add . The XAML markup should now look similar to this example: <Grid> <TextBlock HorizontalAlignment=\"Left\" Margin=\"252,47,0,0\" TextWrapping=\"Wrap\" Text=\"Select a message option and then choose the Display button.\" VerticalAlignment=\"Top\"/> <RadioButton x:Name=\"HelloButton\" Content=\"Hello\" IsChecked=\"True\" HorizontalAlignment=\"Left\" Margin=\"297,161,0,0\" VerticalAlignment=\"Top\"/> <RadioButton x:Name=\"GoodbyeButton\" Content=\"Goodbye\" HorizontalAlignment=\"Left\" Margin=\"488,161,0,0\" VerticalAlignment=\"Top\"/> </Grid>\n\nThe final UI element that you add is a Button control.\n\nNext, debug the application to look for errors and test that both message boxes appear correctly. The following instructions tell you how to build and launch the debugger. For more information, see Build a WPF application (WPF) and Debug WPF.\n\nChange the name of MainWindow.xaml\n\nGive MainWindow a more specific name. In Solution Explorer, right-click and choose Rename. Rename the file to Greetings.xaml. In this example, this change creates an error used later to demonstrate debugging.\n\nIn this step, you find the error that was caused earlier by changing the name of the file.\n\nSpecify Greetings.xaml as the startup URI\n• None Change to , and save the changes.\n\nAs an optional step, it avoids confusion to change the title of your application window to match this new name.\n• None In Solution Explorer, open the file that you just renamed.\n• None Change the value of the Window.Title property from to , and save the changes.\n\nStart the debugger again (press F5). You should now see the Greetings window of your application.\n\nYou can test the code during debugging by adding some breakpoints. You can add breakpoints by choosing Debug > Toggle Breakpoint, by clicking in the left margin of the editor next to the line of code where you want the break to occur, or by pressing F9.\n\nIn the running app, you should see a widget that appears at the top of your window. The widget is a runtime helper that provides quick access to some helpful debugging features. Select the first button, Go to Live Visual Tree. You should see a window with a tree that contains all the visual elements of your page. Expand the nodes to find the buttons you added.\n\nAfter you verify that everything works, you can prepare a release build of the application.\n• None On the main menu, select Build > Clean solution to delete intermediate files and output files that were created during previous builds. This step isn't required, but it cleans up the debug build outputs.\n• None Change the build configuration for HelloWPFApp from Debug to Release by using the dropdown control on the toolbar. It says Debug currently.\n\nCongratulations on completing this tutorial! You can find the you built under your solution and project directory (...\\HelloWPFApp\\HelloWPFApp\\bin\\Release).\n\nCongratulations on completing this tutorial! To learn even more, continue with the following tutorials."
    },
    {
        "link": "https://stackoverflow.com/questions/16613948/drawing-an-interactive-user-interface-in-wpf",
        "document": "Is there any way to make a user interface in WPF that replicates the following diagram?\n\nThe idea was to have a control with three possible directions. In this control users could select the direction they want to add a new point.\n\nFor saving the point informations I was planning on using a structure like this:"
    },
    {
        "link": "https://github.com/microsoft/InteractiveDataDisplay.WPF",
        "document": "Interactive Data Display for WPF is a set of controls for adding interactive visualization of dynamic data to your application. It allows to create line graphs, bubble charts, heat maps and other complex 2D plots which are very common in scientific software. Interactive Data Display for WPF integrates well with Bing Maps control to show data on a geographic map in latitude/longitude coordinates. The controls can also be operated programmatically.\n\nThe IDD for WPF can be installed from NuGet:\n\nOne line of C# code to draw simple linegraph:\n\nIf we get arrays and as:\n\nSee the source code here.\n\nInteractive Data Display for WPF is under the MIT license.\n\nThere is also Interactive Data Display for Javascript. You can see interactive samples here.\n\nThis project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com.\n\nWhen you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.\n\nThis project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments."
    },
    {
        "link": "https://stackoverflow.com/questions/61944962/mouse-events-in-custom-wpf-controls",
        "document": "You're close, but you're thinking too much like WinForms and not quite enough like WPF. Custom rendering is hardly ever done in WPF- at least not in my experience. The framework handles just about everything you could need, but I'm getting ahead of myself.\n\nFirst thing's first: you don't want to inherit from , you want to inherit from . It's purpose is to \"position and arrange child objects\". All the usual \"containers\" you will find in WPF ( , , etc.) inherit from this class.\n\nI think most of your problems are stemming from the fact that doesn't, by itself, support child elements. is build to provide just that functionality, and so you will find it already implements most of the properties you had to declare, such as .\n\nMicrosoft has a simple example for makeing a custom panel:\n\n How to: Create a Custom Panel Element\n\nYour class should end up looking something like this:\n\nThis does just about everything your current class did.\n\nOf course, the above just stacks children on top of each other, so it's not really useful. In order to fix that, you'll need to understand the WPF layout system. There's plenty to say on the subject, and Microsoft has said most of it here. To summarize a bit, there are two main methods:\n• None , which asks an element how big it wants to be.\n• None , which tells the control how big it will actually be and where it will be placed relative to its parent.\n\nA 's job is to take the result from all of it's children, determine the size and position of those children, and then call on those children to assign a final .\n\nNote that the is not responsable for actually rendering its children. The only positions them, the rendering is handled by WPF itself.\n\nThe method can be used to \"add custom graphical effects to a layout element\". Microsoft gives an exmaple of using in a custom here:\n\n How to: Override the Panel OnRender Method\n\nIn the code I showed previously, I kept with your original question and drew an \"X\" on the 's background. The 's children are then drawn on top of that automatically."
    },
    {
        "link": "https://stackoverflow.com/questions/16037753/wpf-drawing-on-canvas-with-mouse-events",
        "document": "I have a problem with handling mouse events on canvas. I want to draw on it using mouse and I've come up with these event handlers, but they don't do anything when I start drawing.\n\nCan you help me by telling what's missing or how to rewrite it so it'll start working?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/901362/send-mouse-events-to-c-wpf-window",
        "document": "An object-oriented and type-safe programming language that has its roots in the C family of languages and includes support for component-oriented programming."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1488437/custom-event-handling-of-mouse-events-in-programma",
        "document": "Hi, \n\n all UI controls derived from FrameworkElement have the Tag property. If you don't want to use the Tag property for additional values on events, you can use your own EventArgs in your own event, like in the following demo: XAML:"
    },
    {
        "link": "https://codeproject.com/Articles/457985/WPF-Drawing-Canvas-Control",
        "document": "I have been play around for quite some time with a custom Drawing canvas that could do some simple but yet useful stuff, a program that had some of the functionality of normal drawing program, and could be used to generate some XAML content. For writing code that looks interesting and useful to others, we often want to use \"real world\" data as input. Meaning that we might have a picture of, let’s say, a race track, but it’s a pain to construct the XAML code from that alone, just to code some other fancy stuff in WPF.\n\nAs always, the first thing I did was some searching on the CodeProject site and elsewhere, and I did find a WPF drawing tool here on this very site. The article I found was WPF-DrawTools, which covers all the basic needs of a drawing program. I had some different ideas for implementing some stuff, like zooming and panning, loading images and other things, that would require quite a lot of redesigning of the program, and I needed a challenge, so I decided to write my own drawing program.\n\nAs I looked around the web for interesting ideas, I came upon a couple of articles on this site that gave me some ideas; there were especially two that really stood out:\n• WPF: A* search by Sacha Barber. The code in the article had a really nice structure to it, and was easy to read. One could easily maintain the code and expand it, so I tried to follow his example, but that was not easy.\n• None WPF Diagram Designer: Part 1 by sukram. The way he designed the resize using an Adorner was brilliant, and I used his code nearly without making any changes.\n\nThe control I would describe here would inherit two custom controls and a control form the framework itself. The only control that is fully custom is my Drawing canvas, that inherits the Canvas control with some simple modifications.\n\nI have, at my previous work places, done quite a lot of editing digital maps, and have witnessed how vital a real good editing tool for digital drawing program is. I have also had some experience in how difficult it can be if you lack those tools, they can litterally mean the difference between swearing and not. Unfortunately, a real good all purpose drawing program, are huge, and normally requires a whole programming team to be implemented in an easy to use way. So this program will eventually have short comings, but I hope its a good start.\n\nBased on the other programs I could find the easiest thing seem to be to create a custom user control that inherited the . This canvas would hold all the drawn elements, and it would also be necessary to override some of the default properties. The standard canvas also has some problem, in that it is not intended, as it is, to have any scrolling or limits. This would have to be solved by using some additional outer controls that could remedy the situation.\n\nI would also have to create a control for resizing the drawing area, as I don’t want it to be infinite large. This was perhaps the easiest thing, as I implemented the WPF Diagram Designer items, tweaked the design slightly and voila.\n\nLast I would also need to create a customized control that inherits the Scroll View control. This control would be responsible for panning and zooming the main drawing area, it would also have to be the outer most control, meaning that it would house the Adorner resize and the custom canvas.\n\nA drawing program like this would have to handle quite a lot of very complex events. Events would have to be stopped, tunneled, and routed, based on the actions that are going to be performed. I will start with the Zoom and panning event. After some thinking I eventually came to the conclusion that the panning would have to be handled by the scroll control, and the zooming would have to be initiated from the same control as well, as both the two lower controls would depend on this.\n\nI would also have to in part, exclude the resize control from the zooming event, as it would become invisible if I zoomed out far enough. Its size, meaning height and width, would have to change according to the changes in the height and width of the canvas though.\n\nHowever, dragging and resizing of the actual drawings on the canvas, would have to take place on the canvas control itself, as it would have all the necessary information of the custom framework elements that I would create my own custom classes in. This meant that my main custom control would consist of three distinct parts:\n• A custom resize control, which stems from this project here on the Codeproject site.\n• A custom control that inherits the Canvas and adds zoom features.\n\nThis would also, however mean that I would have to design tall the controls that did the actual drawing, to also be able to find out whether or not you clicked a point or the line, meaning they would have to be implemented inheriting a and using to hold the visual objects shown on the control. I call all of these controls Basic Controls, as they form the underlying for the elements to be drawn, while the outer controls just are housing blocks and organizers of the content inside them. The bad news is that some information would have to be routed cross several controls, making the program much harder to read and reuse for other, but I really didn’t know how to implement it another way.\n\nThe program has in all 5 different controls that implement some drawing capabilities. They are however all implemented using the same logic, although the Canvas Point is just an element used by the other controls, as I needed hit testing on the points on a line and polygon, so it’s just used indirectly. It’s the only control that I will show the complete code from, as it is the smallest of them, and it has the following structure:\n\nThe four other controls that are implemented are given below:\n\nThey consist of more elaborate handling, as they inevitable would have more elements to hold. You should also notice that I could create a whole set of properties that would make you able to control all aspects of the design. For simplicity these are not implemented in this program.\n\nThis is by far the most complex control in the program, as it handles most of the drawing functions, and stops and initiates nearly all the functions.\n\nThe beginning of the includes a whole set of private variables that are used for preview drawing. The way I allowed the preview drawings was to register the entire mouse down events in the PointCollection called . When I mouse move event occurred, I simply cloned the mouse down and added the current mouse position as the last element to . When I clicked on mouse right button the preview drawing and solid drawing for the PolyLines were cleared.\n\nSome dependency properties follow, as well as the Type of , given below as an Enum:\n\nIf you hold in the button and turn the mouse Wheel you can also resize just the selected element:\n\nYou can also move the complete or by holding down the mouse on the lines. If you Right click on one of the points, you would just move the selected point and not the complete element.\n\nThe mouse down event on the is given in code blow. Becouse of the complex dragging events, applying to points and lines, I would have to control both the Preview MouseDown and the MouseDown event.\n\nI also registered two events. A and a . The last one I implemented to send the Select zoom to the custom . This control handles all the zooming done on the .\n\nAs you noticed the Control has a host of preview subs that is primarily used were you need to check what kind of event it is, and you have the need to stop it from bubbling and tunneling past this point. The preview events are nearly always followed by the normal event, were all the necessary implementation won’t happen in any other control.\n\nThere is also one other feature that I didn’t explain, if you hold down the key, you'll get a 90 degree bend on the lines, whether they are Polygon or Line drawings.\n\nWhen you are zooming you usually want to keep the focus on the spot where your cursor is, meaning that the position on the canvas remains on the same spot after zooming in with a mouse wheel event. This requires some coding on the custom Scrollviewer to function like that, and the code is taken from MSDN WPF Forum site and was an answer given in this thread.\n\nAll that is needed it to take advantage of the ScaleTransform to zoom in. I do however have the ability to set the render area, which means that I would have to use ScaleTransform on the DrawingCanas alone, and calculate the new resize border around the actual drawing area. This is done by registering when the mouse it over the resize icon, and if you are, you cannot zoom in with the mouse wheel. The complete class for DrawingScrollViewer is given below:\n\nAll zoom events are hosed in the DrawingCanvasControl, and it is this that forms the actual user control whitch you implement in the main program. It was however not easy to implement becouse I wanted to attach a specific zooming that did the following:\n\nChanged the size of the DrawingCanvas only, meaning that I could call LayoutTransfrom on this object, but at the same time not to change the layout of the Resize control.\n\nThe only thin I'll say about how the styles is implemented, and especially the RadioButtons for selecting the type of drawing elements you select. They are implemented as an own class that consists of a with three variables. How its connected to the Window is also given below, and you could read more about the approch here.\n\nThere is however one thing that you should know about adding resources to your project. If you do it on the main form like this:\n\nThe styles won't be found in other forms that you have stored in your project. You can add them as a resource to those projects also but that seems to be a little cumbersome way to do it. The easier thing to do is to add the styles to the main file like this:\n\nThis would mean that all your styles are available in all your windows, regardless where they are stored. You would of course have to set your local resources in your main window though:\n\nThe styling in the main window, regarding the are done the following way:\n\nAnd the style, which is converted from a Silverlight template by Michael Sync, and its implemented and is set in the AppStyles.XAML:\n\nHow to use it\n\nLet’s say you want to draw a Race car track, and you could get a hold of the satellite photo of the complete track. And you want to incorporate the track in XAML code in your program. You would simply do this:\n• Click on Add Picture, and add the overview picture of the track.\n• Zoom in by either using the mouse wheel, while the Pointer button is blue. If you want to Pan the image a little you simply click on the Hand for dragging, and drag the image into position.\n• Select the Draw Polygon (assuming the track is circular). Left Click on the points that represent the track and end with a mouse right button to close the polygon. You don’t have to be very accurate, as you could adjust the track afterwards. You do this by selecting the Pointer, and click on the Polygon to get it selected. Click on the Add point’s button. And place the mouse were you want to add points.\n• That would complete the Race track, but you want to scale the track up. You click on the pointer button, select the polygon. Hold down the Ctrl button and start the mouse Wheel and you’ll see that is either a scale the track up or down, the track is now the right size but some of the lanes are outside the boundaries.\n• You move your mouse to the lower left corner; make sure the Pointer button I clicked. It's located just outside the gray square. Hold the Left mouse button down, and simply drag into the empty gray area and you'll see it would get bigger. Now you want to move the entre circuit.\n• Again make sure the Pointer button is blue and click and hold (Left button down on one of the line segments. Start dragging it, into the right position.\n• Click on export to XAML and a window would open to show you all the lines that make up the Race track circuit.\n\nTip: You complete each drawing or zoom event by .\n\nAnd yes, I was thinking of a possible editor for WPF Grand Prix program by Marcelo Ricardo de Oliveira\n\nWell.... Quite a lot actually. There are some things I did not include, as I though the program code was enough for my purposes. The most pressing needs are probably:\n• A properties editor that binds to the selected element, were you could set the properties of the different shapes that is showed on the canvas. This would involve creating a lot of dependency properties on each custom user control. I could however use the properties editor from this project at the CodePlex site.\n• An undo history so that you could go back.\n• Saving the drawings to file, and of course loading from file.\n• Some basic elements are missing: Circles, Ellipses, Bezier segments etc. Have not included those, but they are definitely useful in a drawing program.\n\nWell, that was the whole run through. There are some styling issues that I did not mention, but I assume that they are not so difficult to find out, and I left those out of the article and would refer you to the source code to check it out.\n\nAnyways, I hope you'll find the tool useful. I might revisit this program in the future and expand the functionality much more.\n\nA couple of CodeProject articles are used in the creation of the program:\n\nMy own article of Adding a point to a Polyline is also used in the program:\n\nThe GlassButton style is taken from the blog entery by Michael Sync:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/how-to-create-a-shape-by-using-a-pathgeometry?view=netframeworkdesktop-4.8",
        "document": "How to: Create a Shape by Using a PathGeometry\n\nThis example shows how to create a shape using the PathGeometry class. PathGeometry objects are composed of one or more PathFigure objects; each PathFigure represents a different \"figure\" or shape. Each PathFigure is itself composed of one or more PathSegment objects, each representing a connected portion of the figure or shape. Segment types include LineSegment, ArcSegment, and BezierSegment.\n\nThe following example uses a PathGeometry to create a triangle. The PathGeometry is displayed using a Path element.\n\nThe following illustration shows the shape created in the previous example.\n\nThe previous example showed how to create a relatively simple shape, a triangle. A PathGeometry can also be used to create more complex shapes, including arcs and curves. For examples, see Create an Elliptical Arc, Create a Cubic Bezier Curve, and Create a Quadratic Bezier Curve.\n\nThis example is part of larger sample; for the complete sample, see the Geometries Sample."
    },
    {
        "link": "https://stackoverflow.com/questions/10170527/how-to-draw-this-wpf-path-in-c-sharp",
        "document": "I have been struggling to convert this piece of WPF code to C#. I am relatively new to WPF, and I really hope someone can help me out here :)\n\nI seemed to get along just fine until I got to the PathGeometry Figures... If anyone can supply me with a C# code snippet of this WPF code, it will be greatly appreciated!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/shapes-and-basic-drawing-in-wpf-overview?view=netframeworkdesktop-4.8",
        "document": "This topic gives an overview of how to draw with Shape objects. A Shape is a type of UIElement that enables you to draw a shape to the screen. Because they are UI elements, Shape objects can be used inside Panel elements and most controls.\n\nWindows Presentation Foundation (WPF) offers several layers of access to graphics and rendering services. At the top layer, Shape objects are easy to use and provide many useful features, such as layout and participation in the Windows Presentation Foundation (WPF) event system.\n\nShape-related types are in the namespace. Geometry-related types are in the namespace.\n\nWPF provides a number of ready-to-use Shape objects. All shape objects inherit from the Shape class. Available shape objects include Ellipse, Line, Path, Polygon, Polyline, and Rectangle. Shape objects share the following common properties.\n• None Stroke: Describes how the shape's outline is painted.\n• None StrokeThickness: Describes the thickness of the shape's outline.\n• None Fill: Describes how the interior of the shape is painted.\n• None Data properties to specify coordinates and vertices, measured in device-independent pixels.\n\nBecause they derive from UIElement, shape objects can be used inside panels and most controls. The Canvas panel is a particularly good choice for creating complex drawings because it supports absolute positioning of its child objects.\n\nThe Line class enables you to draw a line between two points. The following example shows several ways to specify line coordinates and stroke properties.\n\nThe following image shows the rendered Line.\n\nAlthough the Line class does provide a Fill property, setting it has no effect because a Line has no area.\n\nAnother common shape is the Ellipse. Create an Ellipse by defining the shape's Width and Height properties. To draw a circle, specify an Ellipse whose Width and Height values are equal.\n\nThe following image shows an example of a rendered Ellipse.\n\nThe Path class enables you to draw curves and complex shapes. These curves and shapes are described using Geometry objects. To use a Path, you create a Geometry and use it to set the Path object's Data property.\n\nThere are a variety of Geometry objects to choose from. The LineGeometry, RectangleGeometry, and EllipseGeometry classes describe relatively simple shapes. To create more complex shapes or create curves, use a PathGeometry.\n\nPathGeometry objects are comprised of one or more PathFigure objects; each PathFigure represents a different \"figure\" or shape. Each PathFigure is itself comprised of one or more PathSegment objects, each representing a connected portion of the figure or shape. Segment types include the following: LineSegment, BezierSegment, and ArcSegment.\n\nIn the following example, a Path is used to draw a quadratic Bezier curve.\n\nThe following image shows the rendered shape.\n\nFor more information about PathGeometry and the other Geometry classes, see the Geometry Overview.\n\nIn Extensible Application Markup Language (XAML), you may also use a special abbreviated syntax to describe a Path. In the following example, abbreviated syntax is used to draw a complex shape.\n\nThe Data attribute string begins with the \"moveto\" command, indicated by M, which establishes a start point for the path in the coordinate system of the Canvas. Path data parameters are case-sensitive. The capital M indicates an absolute location for the new current point. A lowercase m would indicate relative coordinates. The first segment is a cubic Bezier curve beginning at (100,200) and ending at (400,175), drawn using the two control points (100,25) and (400,350). This segment is indicated by the C command in the Data attribute string. Again, the capital C indicates an absolute path; the lowercase c would indicate a relative path.\n\nThe second segment begins with an absolute horizontal \"lineto\" command H, which specifies a line drawn from the preceding subpath's endpoint (400,175) to a new endpoint (280,175). Because it is a horizontal \"lineto\" command, the value specified is an x-coordinate.\n\nFor the complete path syntax, see the Data reference and Create a Shape by Using a PathGeometry.\n\nBrush objects are used to paint a shape's Stroke and Fill. In the following example, the stroke and fill of an Ellipse are specified. Note that valid input for brush properties can be either a keyword or hexadecimal color value. For more information about available color keywords, see properties of the Colors class in the System.Windows.Media namespace.\n\nThe following image shows the rendered Ellipse.\n\nAlternatively, you can use property element syntax to explicitly create a SolidColorBrush object to paint the shape with a solid color.\n\nThe following illustration shows the rendered shape.\n\nYou can also paint a shape's stroke or fill with gradients, images, patterns, and more. For more information, see the Painting with Solid Colors and Gradients Overview.\n\nThe Line, Path, Polygon, Polyline, and Rectangle classes all have a Stretch property. This property determines how a Shape object's contents (the shape to be drawn) is stretched to fill the Shape object's layout space. A Shape object's layout space is the amount of space the Shape is allocated by the layout system, because of either an explicit Width and Height setting or because of its HorizontalAlignment and VerticalAlignment settings. For additional information on layout in Windows Presentation Foundation, see Layout overview.\n\nThe Stretch property takes one of the following values:\n• None None: The Shape object's contents are not stretched.\n• None Fill: The Shape object's contents are stretched to fill its layout space. Aspect ratio is not preserved.\n• None Uniform: The Shape object's contents are stretched as much as possible to fill its layout space while preserving its original aspect ratio.\n• None UniformToFill: The Shape object's contents are stretched to completely fill its layout space while preserving its original aspect ratio.\n\nNote that, when a Shape object's contents are stretched, the Shape object's outline is painted after the stretching.\n\nIn the following example, a Polygon is used to draw a very small triangle from (0,0) to (0,1) to (1,1). The Polygon object's Width and Height are set to 100, and its stretch property is set to Fill. As a result, the Polygon object's contents (the triangle) are stretched to fill the larger space.\n\nThe Transform class provides the means to transform shapes in a two-dimensional plane. The different types of transformation include rotation (RotateTransform), scale (ScaleTransform), skew (SkewTransform), and translation (TranslateTransform).\n\nA common transform to apply to a shape is a rotation. To rotate a shape, create a RotateTransform and specify its Angle. An Angle of 45 rotates the element 45 degrees clockwise; an angle of 90 rotates the element 90 degrees clockwise; and so on. Set the CenterX and CenterY properties if you want to control the point about which the element is rotated. These property values are expressed in the coordinate space of the element being transformed. CenterX and CenterY have default values of zero. Finally, apply the RotateTransform to the element. If you don't want the transform to affect layout, set the shape's RenderTransform property.\n\nIn the following example, a RotateTransform is used to rotate a shape 45 degrees about the shape's top left corner (0,0).\n\nIn the next example, another shape is rotated 45 degrees, but this time it's rotated about the point (25,50).\n\nThe following illustration shows the results of applying the two transforms.\n\nIn the previous examples, a single transform was applied to each shape object. To apply multiple transforms to a shape (or any other UI element), use a TransformGroup."
    },
    {
        "link": "https://stackoverflow.com/questions/22589778/geometry-drawing-in-wpf",
        "document": "I'm kinda new to all this geometry part, but I can see it gives me the ability to draw basically whatever I want. I can't find a good manual that teaches how to create whatever image I have in my head. I really hoped to find some kinda painter that extracts the data of the geometry for me but no luck so far.\n\nFor example, I found this online:\n\nYou can tell by the name what it draws, but I would like to know how to do it myself?\n\nIf anyone could point me to a manual/any kind of program that would be fantastic!"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/11vmynt/how_tf_do_you_draw_in_wpf",
        "document": "What I'm trying to do:\n\nIn a canvas, display 1,000,000 points and a few thousand polygons, the user can zoom in by clicking and dragging (forming the desired zoom area). When zoomed, the user can pan i.e move and see the other parts too. The points can be of different colors.\n\nWhat I've done until now:\n\nI've used line geometry (with 0 length) to create points and path geometry to create the polygons. And I finally add all the paths to the canvas as children. I also create a single transform and pass it to all the geometries I'm creating. So when I zoom I just increase the scale transform values and when I pan I change the translate transform values.\n\nIt's super slowwwwwwww :'( it takes a lot of time to render and if I change the transform values it takes a lot of time to apply it to all the points. When I have 100 points and pan it seamlessly moves, but when I have more points and pan it just stops and renders. I'm not explicitly redrawing anything, I'm just changing the transform values.\n\nPlease suggest me things I should try.... I'm trying to use SkiaSharp now and see if there's a performance boost."
    }
]