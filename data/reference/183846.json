[
    {
        "link": "https://help.autodesk.com/cloudhelp/CHS/MayaCRE-Tech-Docs/CommandsPython/angleBetween.html",
        "document": ""
    },
    {
        "link": "https://forums.autodesk.com/t5/maya-programming/python-scripting-in-maya/td-p/11085909",
        "document": "I am new to maya and I want to build a GUI that would help a user (who is not familiar with Maya) to just drag and drop shapes to create the model of a complex shape they want and then let Maya automatically professionally draw it for them. For example, the screen is divided into a canvas and a bar with basic 2d shapes like squares, circles, stars,.... and the user would drag a rectangle to the canvas then drags two circles and put them at the bottom edges of the rectangle then submits this sketch then Maya would understand that this sketch is a car and would model a professional 3d car as a result.\n\nofc I would direct the GUI to be specific for example models vehicles only or rooms or so\n\nIs this something even possible to create on Maya by python scripting?\n\nIf anyone has ever done something similar or has experience or ideas or good resources please help."
    },
    {
        "link": "https://stackoverflow.com/questions/37172852/resize-images-in-maya-with-python",
        "document": "I'm pretty new to coding in general. I want a script that could batch process images inside Maya. The process should be simple: open an image from a given path folder, resize it, overwrite it.\n\nI know PIL should be able to do that, however it appears so it's not supported since Maya 2014 or something. I've tried the code in Maya 2012 and it works but since I want my code to be accessible to all, I want to find a workaround.\n\nI'm aware someone re-released a module so it can be supported on more recent builds (on windows only though).\n\nBut even when I install it in my build, I get this error when attempting to open my file:\n\nI've tried copying the whole module into my own script and it does the same thing.\n\nOn the side I've also tried the OpenMaya module\n\nand this gives me an empty image of 12mb (so by the way, if I could keep it compressed, that would be awesome).\n\nSo now, I've reached the limit of my powers. What can I do from here?"
    },
    {
        "link": "https://stackoverflow.com/questions/30263603/maya-using-python-to-render-a-sequence",
        "document": "I am making a test render script in Python and am having problems getting my render calls to output sequences, and not just one frame.\n\nI am working in Maya 2015 on a Windows 7 machine.\n\nI have tried using the ogsRender() (Hardware 2.0) and render() (Software Render) commands. And while both of them proclaim to be able to output sequences in the docs, I can't seem to get them to do so.\n\nBeing a test render script, it doesn't need to be pretty--just fast.\n\nhwRender() (old Hardware Render) seems to work fine, outputting frames according to render settings. However, I get a lot of white artifacts from any intersections when using that render, making it hard to see if things are correct.\n\nDoes anyone know how to get render() or ogsRender() to output sequences?\n\nOr maybe remove the white artifacts hwRender() produces?\n\nThanks for your time!"
    },
    {
        "link": "https://instructables.com/Time-Lapse-Batch-Image-Manipulation-Using-Python",
        "document": "More by the author: \n\n\n\n I recently found a cool Time Lapse app for my phone, but the files needed to be rotated and touched up a bit to make them into a movie. I wrote a Python script to do that, and am sharing that with you here.\n\n\n\n\n\n The problem, as you can see below, is that the images need to be rotated and touched up a bit. There are many ways to do this including I'm using an app called Time Lapse Camera ( http://www.thirdwishsoftware.com/timelapsemaker/ ) on a Palm Pre. It places sequentially numbered photos in a directory. I'm sure what ever phone you use, \"there is an app for that.\" You could use a webcam as well.The problem, as you can see below, is that the images need to be rotated and touched up a bit. There are many ways to do this including Gimp and ImageMagick , but for me a Python script was the easiest and quickest. Python is available at http:// www.python.org/getit /. I am also using the Python Image LIbrary (PIL), available at http:// www.pythonware.com/products/pil/.\n\nPlace the script in a folder with or below the folder containing the images to be processes.\n\n\n\n The script can be run from the command line with the desired options.\n\n In this example, the script is located in:\n\n C:\\Users\\Ken\\Pictures\n\n And the images in:\n\n C\\Users\\Ken\\Pictures\\commute\n\n\n\n The command to rotate and brighten images in the folder is:\n\n python ./imageBatch.py -d commute -r 90 -b 1.5\n\n\n\n Or, if you would rather, open, modify it, and run it from Python's own command line tool, Idle.\n\n\n\n Just a side note, I had to add python to my path to get the command line option to work in windows.\n\n\n\n Here are the command line options if you enter \"imageBatch.py -h\":\n\n\n\n -h --help : displays this help message\n\n -d --directory : directory, relative to this file, where the photos are located (omit if in same directory)\n\n -e --equalize : equalize image contrast\n\n -r --rotation : degrees to rotate (+ = ccw, - = cw)\n\n -c --contrast : contrast factor (1.0 = unchanged)\n\n -b --brightness : brightness factor (1.0 = unchanged)\n\n -s --sharpness : sharpness factor (1.0 = unchanged)\n\n -t --timestamp : add file created time to images\n\n\n\n You are not stuck with just these options. Visit http://www.pythonware.com/library/pil/handbook/ to learn what is available in the library and modify the script to do what you want. I've merely given you a frame work to put options in to.\n\nOnce you have the images the way you want, time to make a movie. I used Movie Maker Live. You can import the entire folder of images at once and set their duration to something low like 0.2 seconds.\n\n\n\n That is it. Good luck."
    },
    {
        "link": "https://help.autodesk.com/cloudhelp/2024/JPN/MAYA-API-REF/py_ref/class_open_maya_render_1_1_m_renderer.html",
        "document": ""
    },
    {
        "link": "https://help.autodesk.com/cloudhelp/2023/ENU/MAYA-API-REF/py_ref/class_open_maya_1_1_m_image.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/29446321/maya-python-modules-complete-documentation",
        "document": "I've started using Python to script Maya for a school projet but i'm facing a problem with the documentation : I can't find anywhere a complete documentation of all the modules classes and function of the Maya API.\n\nI've already foun the Python-style documentation for PyMEL module, but where is the reste of it ? E.g, the module ?"
    },
    {
        "link": "https://tech-artists.org/t/maya-c-api-create-mimage-from-viewport-and-camera/16493",
        "document": "I am developing a tool for Maya with the OpenMaya API in C++.\n\n My goal is to retrieve an image from a specific camera and specific objects, for testing purposes I would like to have a viewport image. My first question is to know if there is a way to do this through the Maya API only ? Or should I pass by lets say OpenGL to render my own image ? If it is preferable for me to use OpenGL, is there a way to retrieve Vertex Buffer from a specific object, so I can use this, its World Matrix and the camera’s World Matrix to generate the image ? Thanks a lot for your help, please let me know if that’s unclear\n\nGreetings!\n\n To begin with, you can get acquainted with the functionality of the class\n\n This class contains functions that meet many of your needs:\n\n OpenMayaUI.M3dView Class Reference import maya.cmds as cmds import maya.api.OpenMaya as om2 import maya.api.OpenMayaUI as omui2 def maya_useNewAPI(): pass # or: # maya_useNewAPI = True image_format = \"jpg\" image_snapshot_01 = r'c:\\temp\\shapshot_01.jpg' image_snapshot_02 = r'c:\\temp\\shapshot_02.jpg' cmds.setFocus('modelPanel4') cmds.toggleAxis(origin = false) current_view = omui2.M3dView.active3dView() current_image = om2.MImage() current_image.create(current_view.portWidth(), current_view.portHeight()) cmds.modelEditor('modelPanel4', edit = True, grid = False, useDefaultMaterial = True, wireframeOnShaded = True) current_view.refresh(force = True, all = False) current_view.readColorBuffer(current_image, True) current_image.writeToFile(image_snapshot_01, outputFormat = image_format) cmds.modelEditor('modelPanel4', edit = True, useDefaultMaterial = False, wireframeOnShaded = False) current_view.refresh(force = True, all = False) current_view.readColorBuffer(current_image, True) current_image.writeToFile(image_snapshot_02, outputFormat = image_format) cmds.modelEditor('modelPanel4', edit = True, grid = True) current_view.refresh(force = True, all = False) Depending on the goals and conditions (Viewport 2.0. / OpenGL\\DX / legacy default viewport), for effective processing you will have to use both , and , and Here are links to great examples from the documentation for : Almost all examples (directly or indirectly) use the Viewport 2.0 API.\n\n A good starting point is this documentation:\n\nThanks a lot for your answer. I have tried to use this method with C++ and the M3dView.readColorBuffer is deprecated since Maya 2019. I am supposed to be using MHWRender::MRenderTargetManager::acquireRenderTarget instead, but I am having a really hard time to set this up. At the moment I have something like this, but I am probably missing something because it fails to create the MRenderOverride and it displays the error “Failed to find viewport render override.” : void captureViewportImage(const MString& filePath) { MHWRender::MRenderer* renderer = MHWRender::MRenderer::theRenderer(); if (!renderer) { MGlobal::displayError(\"Viewport 2.0 renderer not available.\"); return; } const MString& overrideName = renderer->activeRenderOverride(); const MHWRender::MRenderOverride* override = renderer->findRenderOverride(overrideName); if (!override) { MGlobal::displayError(\"Failed to find viewport render override.\"); return; } const MHWRender::MRenderTargetManager* targetManager = renderer->getRenderTargetManager(); MHWRender::MRenderTargetDescription targetDesc; MHWRender::MRenderTarget* renderTarget = targetManager->acquireRenderTarget(targetDesc); if (!renderTarget) { MGlobal::displayError(\"Failed to acquire render target.\"); return; } MHWRender::MDrawContext* context = MHWRender::MRenderUtilities::acquireSwatchDrawContext(renderTarget); MHWRender::MTextureManager* textureManager = renderer->getTextureManager(); MHWRender::MTexture* colorTexture = context->copyCurrentColorRenderTargetToTexture(); textureManager->saveTexture(colorTexture, filePath); targetManager->releaseRenderTarget(renderTarget); } I am new to all this viewport stuff so I am probably missing something, and not understanding how it actually works.\n\nI have tried to use this method with C++ and the M3dView.readColorBuffer is deprecated since Maya 2019 Who would have thought… (s)\n\n Yes, this is true for OpenMaya-1/C++.\n\n But in a (OpenMaya-2) this works correctly with , the function is automatically completed correctly.\n\n Here’s a recommendation from the Maya developers themselves:\n\n Get image from M3dView::readColorBuffer in Viewport 2 import maya.OpenMaya as openmaya import maya.OpenMayaUI as openmayaUI view = openmayaUI.M3dView.active3dView() img = openmaya.MImage() if view.getRendererName() == view.kViewport2Renderer: img .create(view.portWidth(), view.portHeight(), 4, openmaya.MImage.kFloat) view.readColorBuffer(img) img.convertPixelFormat(openmaya.MImage.kByte) else: view.readColorBuffer(img) Despite the fact that the entire class (in the latest documentation) is positioned as “deprecated”, in the examples (the latest documentation) this class is used very actively. \n\n Because for simple needs, this method is simpler and just as effective. To my great regret, I cannot help you with checking the C++ code \n\n Maybe something like this:\n\nI managed to do the first step that I wanted to begin with, the previous messaged helped a lot so I got this bit of code: Now the next I am trying to do is to get the image from another camera, a camera that I am not looking from. I am not sure the viewport 2.0 has function that allows for rendering a viewport image from a specific camera, so I decided to render my own image through OpenGL and so far this the code I have: This code is executed inside a node that I am creating, but the output image changes if I have the hypershade open:\n\n It looks like it picks up an already existing viewport with its coordinates system, so my question is, is that possible to create another, invisible, OpenGL viewport with default projection, modelview… matrices so I can render the image from it ? Thank you for your help \n\n Cheers !"
    },
    {
        "link": "https://chadvernon.com/maya-api-programming",
        "document": "Check out my Introduction to the Maya API video series at CGCircuit:\n\nThis workshop is geared towards individuals wanting to learn how to extend and customize Maya with the Maya API. Individuals should have existing C++ and/or Python experience as well as an intermediate to advanced level of knowledge of Maya. A good understanding of Object Oriented Programming (OOP) is extremely helpful as the Maya API makes heavy use of OOP. You will not learn everything about the Maya API from this workshop. The purpose of this workshop is not to make you expert Maya programmers, but to give you a solid foundation from which to further your Maya API studies.\n\nThe techniques and code included in this workflow may not be perfect or accepted by elite Maya API programmers as the best way to utilize the API. The code and knowledge presented here is based off of my experience in creating dozens of nodes, deformers, and tool sets using the Maya API in both C++ and Python in the production of animated and effects heavy feature films a large studios. If you think something is incorrect, let me know. Maya API learning resources are limited so hopefully these notes will help you add to your tool set.\n\nWhat is the Maya API?\n\nThe Maya API is a C++/Python API that lets programmers and scripters access the internal libraries of Maya. With the Maya API, programmers can customize Maya with new technology and create tools to help integrate the software into a studios production pipeline. Tasks written with the Maya API execute several times faster than the same tasks written in MEL.\n\nWhat Can Be Implemented with the Maya API?\n\nThe Maya API is traditionally used to make plug-ins, which are dynamic libraries loaded by Maya at runtime. Plug-ins contain implementations of many different types of objects you want to add to Maya. When I refer to “objects” here, I am referring to objects in the Object Oriented Programming sense. The Maya API provides several base classes that programmers will inherit from and fill in the desired implementations. Some possible object types are:\n\nStarting with Maya 8.5, the Maya API became accessible via Python. With Python, not only can we make plug-ins as described above, but we can also access API commands in scripts, which adds a significant performance gain to existing toolsets.\n\nPlug-ins can be made with both C++ and Python. So which one should you use? Both are useful but there are situations where one should be used over the other.\n\nAnything complex or that works with larger data sets like deformers should probably be made with C++ for speeds sake. For simple nodes that are not performance critical, Python works fine. Anything dealing with OpenGL such as viewports and locators should be made with C++ as I have seen significant slowdowns with Python implementations.\n\nAlso, some API calls in Python are a total pain syntax-wise because the API expects a lot of C++ pointers and references, which is wrapped with a very cryptic module in Python (MScriptUtil) which is not documented very well.\n\nI have used both C++ and Python when developing plug-ins. When I am writing a new node, I sometimes start with Python to work out algorithm details. Since Python isn’t compiled like C++, the iteration time is faster. There’s also less of a chance to crash Maya with array index and memory errors.\n\nMost of the time, I stick with C++ just because that is what the end product is going to be. However, I use the API a lot with Python in scripts so it is still worth learning. All the API calls are the same; it is just a difference in syntax.\n\nThe first step in learning the API is setting up your build environment. The Maya API is packaged as a set of libraries that you will need to access. From the documentation, these libraries are:\n• OpenMaya - Contains fundamental classes for defining nodes and commands and for assembling them into a plug-in.\n• OpenMayaUI - Contains classes necessary for creating new user interface elements such as manipulators, contexts, and locators.\n• OpenMayaAnim - Contains classes for animation, including deformers and inverse kinematics.\n\nIf you are using Python, accessing these libraries is as simple as importing them into your code:\n\nI recommend using CMake to help create your build environment on Windows, Linux, and OSX. You can view a video series I created going over how to use CMake with Maya. The corresponding CMake modules can be found on my github project.\n\nThe rest of this page describes the older pre-Maya 2016 evaluation model with dirty propagation.\n\nWhen writing most Maya plug-ins, knowledge of the Maya Dependency Graph architecture is necessary. Explanations of the Maya DG can be found in most Maya books and the documentation. It is basically a node network that passes information from one node to the next. The most important aspects for a developer to know about the DG are how and when Maya recalculates and propagates data through the graph.\n\nNodes have a set of inputs and outputs. The outputs depend on the values of the inputs. These outputs are said to be dependents of their corresponding inputs and the inputs are said to affect the corresponding outputs. As an optimization, Maya’s DG is designed to only calculate data when it needs to. It accomplishes this with a dirty flag on a node’s inputs and outputs. When an input value is changed, any dependent output is marked dirty. The output is not actually recalculated. Any connection to this output is marked dirty and the dirty propagation continues until the end of the graph is reached. No data recalculation has occurred yet; only the dirty flag has been pushed through the DG. When Maya requests a DG reevaluation, such as in a screen refresh, Maya will check if a node output is dirty. If it is, Maya tells the node to evaluate itself. When that node evaluates, it sees that its inputs are dirty and so asks any connected input node to reevaluate. This process occurs until the data in the graph is reevaluated and the inputs and outputs are marked clean.\n\nThis knowledge is useful when trying to figure out why your node is not being computed. If a node is not being computed, its outputs are not being requested.\n\nSince descriptions of the Maya DG architecture are already discussed in depth else where, I will not reproduce it here. I recommend reading more about Maya's dependency graph architecture in the documentation and in various other Maya books and white papers.\n\nThe Maya API consists of four types of C++ objects: wrappers, objects, function sets, and proxies.\n\nA wrapper is simply a convenience class for a data or mathematical structure. The Maya API includes wrappers for arrays, vectors, matrices, quaternions, etc. Wrappers also include utility tools such as selection lists, DAG paths, viewports, etc. These classes start with the “M” prefix. Examples include MIntArray, MFloatArray, MMatrix, MVector, MQuaternion, MPlane, MPointArray, MSelectionList, etc.\n\nWrappers also include iterators, which are classes used to traverse over sequences of data. There are iterators to traverse Maya's dependency graph, to iterate over a meshes vertices, edges, and faces, to iterate over a surfaces cvs, etc. Iterator classes are prefixed with “MIt” and include MItMesh, MItDependencyGraph, MItKeyFrame, MItMeshEdge, MItSurfaceCV, etc.\n\nAn object, known as an MObject, is the generic base class that represents all Maya objects (curves, surfaces, DAG nodes, DG nodes, lights, shaders, textures, IK solvers, dynamics fields, etc). This common base allows many different types of MObjects to be passed through the API and lets API developers take advantage of the inheritance structure of all the nodes in Maya. Each instance of an MObject represents either a node or an attribute on a node. However, an MObject is not really the actual node or attribute, but rather a handle to the node or attribute. This is so Maya can maintain ownership of the nodes and attributes and make sure it runs all the necessary routines to keep Maya running smoothly. Because an MObject is a pointer to an internal Maya object, you should not hang on to MObjects between calls to your plug-in as Maya may move these internal objects around in memory making your MObject invalid. To access specific functionality of the data that an MObject represents, we use function sets.\n\nBecause MObjects are the base class for all nodes, it is not practical to include all the functions necessary to interact with the node in the MObject class. The functions that operate on a specific type of node are broken into C++ classes called function sets. For example there are function sets for cameras, skin clusters, IK handles, meshes, surfaces, transforms, etc. Function sets operate on MObjects. The general workflow for objects and function sets is to determine what function set an object is compatible with, using the MFn::Type enumeration, and then attaching that function set to the object:\n\nOften, you will already know the type of data that an MObject represents and won’t need to explicitly check the type of data. Function set classes are prefixed with “MFn”. Examples include MFnMesh, MFnNurbsCurve, MFnDagNode, MFnLatticeDeformer, MFnRenderPass, etc.\n\nThe object/function set workflow creates a separation of data vs. functionality, which differentiates from classic OOP where a class usually encapsulates both data and functionality to operate on the data. In Maya, data is represented with MObjects and functionality is achieved with function sets.\n\nProxies are the abstract classes that plug-in developers use to implement new types of Maya objects such as custom nodes, deformers, ik solvers, commands, transforms, etc. When developing a new object, we create a new class that inherits from one of these proxy classes and then implement all the required functions. Proxy classes are prefixed with “MPx” and include MPxNode, MPxDeformerNode, MPxConstraint, MPxCommand, MPxIkSolver, etc.\n\nError checking in C++ is done with the MStatus class. Most functions in the API accept or return an MStatus variable. We can query this variable to determine if a specific function succeeded or not. If a function fails, the MStatus variable contains information about why the function failed. It is important to check for these errors because when functions fail in the Maya API, they fail silently. There will be no warning, the rest of the code may just not work or Maya might just crash. Therefore, you should always check if a function succeeded with MStatus.\n\nThe Maya API comes with a couple of useful macros for checking MStatus variables. These are:\n\nThe macro performs the same functionality as above. The macro is the same as except it returns the status if it failed.\n\nMStatus is not available with Python. When using the Maya API with Python, a failed function will throw an exception and you can use Python’s built-in error handling to deal with it.\n\nAs an introduction to the Maya API, we will create a simple command plug-in. This will show you template code that is common in all plug-ins as well as display various Maya API concepts discussed earlier. The command will simply print text into the script editor.\n\nIn all plug-ins, you need to implement 3 common functions:\n• initializePlugin – Called when the plug-in is loaded. Used to register new commands, tools, nodes, etc with Maya.\n• uninitializePlugin – Called when the plug-in is unloaded. Used to de-register whatever was registered in initializedPlugin.\n• creator – Maya calls this to create a new instance of the object, such as when createNode is called or the command is called.\n\nThese functions look like the following in our HelloWorld command:\n\nThis is boiler plate code that is usually copied and pasted into all of my plug-ins and altered just slightly to include all the nodes/commands/deformers included in the plug-in. The code simply registers and deregisters any new nodes, commands, etc. that our plug-in contains. This is also where we tell Maya what type of node we are creating, such as if it is a normal dependency node, a deformer, a custom locator, an ik solver, a constraint, etc.\n\nYou can read about the specifics of these functions in the documentation, but this is where we can specify a plug-in version number, a required Maya version, plug-in author, etc.\n\nSince we are implementing a new command, we need to create a class that inherits from the proxy class, MPxCommand:\n\nThe above code shows the header declaration for our HelloWorld command. We begin by including the necessary header files. Each class in Maya has its own header file, so if you use a specific class in your plug-in, you need to include its header file in order to use it.\n\nThe documentation for MPxCommand lists many different functions that we can choose to implement. Since this is our first plug-in, we will only implement the one necessary function for commands: the doIt function. When we end up calling our new command in Maya, Maya will create our new HelloWorld object and then call the doIt function of that object. The doIt function looks like this:\n\nMPxCommand::doIt accepts an MArgList object, which is used for passing in command arguments. We will learn how to use that in a later section. The only line of interest in this function is the MGlobal::displayInfo call. MGlobal is a class that provides lots of useful functionality such as printing text and selecting objects. Here, we are simply printing some text.\n\nOnce the plug-in is compiled and loaded, we can call the command with:\n\nThe entire plug-in looks like this:\n\nOne thing to keep in mind is that maya/MFnPlugin.h should only be included once in your plug-in. This header file is necessary to register your plug-in with Maya. If you include it in multiple source files in your plug-in, you’ll get an error. If your plug-in has multiple nodes and commands, you’ll probably put the initializePlugin and uninitializePlugin functions in a separate file, so just include MFnPlugin in that file.\n\nThe identical Python implementation of the command is:\n\nIn Python, we can either use the MGlobal class to print text or we can just use the built-in Python print command.\n\nNow that we have introduced the Maya API, we can start learning how to implement more interesting and useful plug-ins.\n\nA dependency graph plug-in is the most common type of plug-in. Developers usually create custom nodes to perform some sort of mathematical calculation or geometric operation. Before continuing, you should read the Dependency Graph Plug-ins section of the Maya documentation. It contains a lot of useful information about Maya dependency graph architecture and node creation workflow. Once you have read that information, it will be easier to follow along as we create our first dependency graph node. Our first node will be a simple node that takes an input float value, doubles it, and sets the doubled value as the output. It is a pretty useless node, but it will introduce us to the structure of node plug-ins and lay the foundation for more interesting nodes.\n\nTo create a dependency graph node, we create a class that inherits from the proxy class, MPxNode:\n\nThis should look very similar to the command that we created earlier. Instead of a doIt function, we are implementing a compute function. We also have some static member variables. The MObjects represent the attributes that the node will have. The “a” prefix is just a naming convention I follow for MObjects that represent node attributes.\n\nThe MTypeId member variable is an id value that is necessary in all nodes that you create. All nodes in Maya require a unique hexadecimal id number. From the Maya documentation:\n\nIf you are creating nodes at a studio, you should request an id range from Autodesk. If you just use a random id value, there is a chance that it will conflict with an existing node id value and you will see undesirable behavior in Maya. You can request a block of node ids here\n\nNodes can have input and output attributes of many different types from numerical attributes like integers, floats, and booleans, to more complex types like meshes, curves, numerical arrays, etc. When implementing a new node, we need to define all of the attributes of that node as well as which attributes will trigger dirty flag propagation. We do this in an initialization function that we specify when we register the node with Maya. Here is the initialization function for our DoublerNode:\n\nSince our node contains only numeric attributes, we create them with MFnNumericAttribute. There are different classes to create different types of attributes; these include:\n\nWe will go over each of these in later sections as they are encountered.\n\nWhen creating an attribute, we need to specify various options for the attribute such as whether the attribute is an input or output, whether it is keyable, an array, cached, stored when the file is saved, etc. In the above example, by setting the aOutput attribute to not writable, we are specifying that it can never be set with a setAttr command and that it cannot be used as a destination connection; basically that the attribute is an output attribute and only the node itself should set its value. By setting storable to false, we are telling Maya not to store this value in the .mb or .ma file when the scene is saved. This makes sense because since it is an output attribute, the value will get calculated anyways so there is no need to store it to disk.\n\nThe aInput attribute is then created and set to keyable. When an attribute is keyable, it appears in the channel box when the node is selected. To read about all the options you can set for an attribute, refer to the MFnAttribute documentation. Once the aInput attribute is created and added to the node, we then specify that the aInput attribute affects the aOutput attribute by calling attributeAffects. This creates the input/output relationship that tells Maya that when aInput changes, it should mark aOutput as dirty and that Maya will need to re-evaluate it the next time it is requested. You will need to call this function for every attribute dependency in your node.\n\nThe Maya API has the notion of attributes and plugs. Scripters are probably familiar with attributes being the collection of values and options available on a node. In the API, attributes refer to the data interface that defines a node and that is shared across nodes of the same type. For example, all polySphere nodes have a radius attribute. The actual data or value of the attribute is stored in a plug. The actual C++ class is MPlug. So attributes are shared across all nodes of the same type and plugs are unique to a single instance of a node. When talking about attributes and plugs throughout this workshop, I may refer to them interchangeably, but technically speaking, there is a difference between the two.\n\nWhen creating a new node, there are two objects we need to be aware of. These are MDataBlock and MDataHandle. The data block is a nodes storage object for all the data necessary to compute an output attribute. When calculating a nodes outputs, all attribute values, inputs and outputs, are managed through the data block. This data block object is only valid during the time you are calculating a nodes outputs so you should not store pointers to the data block.\n\nTo access data inside of the data block, we use data handles. A data handle is a pointer object to data inside of the data block. The general workflow of working with data blocks and handles is:\n• Request a data handle from the data block to a specific attribute. Maya provides the data block.\n• Read the data from the data handle.\n• Request an output data handle so we can store our outputs into the data block.\n• Store our calculated data into the data block using our output data handle.\n\nThere are also cases where we are reading array data from an attribute. In these cases, we use the MArrayDataHandle object. We will learn more about this class in later sections.\n\nWhen calculating an output attribute, we should only use the data provided to the node through its data block. This includes any input attributes and connections. We should never look outside of the node to get data required for our calculations. For example, say we write a node and we want normalized painted weight maps such as on a skin cluster node. In the computation of our output plugs in our node, we should not find the skin cluster node in the DG and query its weight values. If you want these weight values, you should either copy these weights into your nodes data block with a separate command, create your own painted weight normalization algorithms, or connect all the painted weight plugs to your node. If you look outside of your node while your node is computing, you may trigger unwanted node evaluations. A node should behave as a black box and only have knowledge of its inputs and outputs.\n\nWith the node attribute interface defined in the initialize function, we can now implement the actual calculation of the output values. This is done in a nodes compute method. Whenever Maya requests an output value from a node and the output value is dirty, Maya will call that nodes compute function to recalculate the output value. In our node, we simply get the input value, double it, and set it as the output:\n\nThis compute functions performs the same workflow steps previously outlined. We get the input data handle and the input value both on the same line. We then perform our calculation, get the output data handle, and then store the result back into the data block. Once the output has been calculated and stored, we need to mark the output plug as clean so Maya knows not to calculate its value again.\n\nThe initial conditional statement checks which output plug that Maya is currently requesting. This is to ensure we do not execute unnecessary calculations and lets us filter our computations when a node has multiple output attributes. When everything is calculated and stored back into the data block, we return a success code to tell Maya that nothing went wrong.\n\nThe entire plug-in for the DoublerNode is listed below:\n\nAnd here is the corresponding Python implementation:\n\nWhen the plug-in is compiled and loaded, we can test it out with the following code:\n\nThis code creates a douberNode and connects it to the translateY value of a locator. Animating the input of the doublerNode shows the effect of our node.\n\nDeformers are a subset of dependency graph nodes that perform deformation algorithms on input geometry and outputs the deformed geometry to the output attribute of the deformer. When you think of an algorithm to move points or cvs around on mesh or surface, you usually want to create a deformer. Example deformers that I have implemented in the past include wrap, jiggle, displacement, blend shape, and skin sliding deformers. To create a deformer node, we create a class that inherits from the proxy class, MPxDeformerNode.\n\nSince deformers are a subset of dependency nodes, they can be created with the createNode command just like all other nodes, however, deformers have a lot of special functionality that depends on additional connections made to the deformer node. These connections get made for you when you use the deformer command. This functionality includes membership editing and reordering of deformation history.\n\nA deformer has the same structure as a normal dependency node except we implement a deform function instead of a compute function. To show some of the process involved with making deformers, we will create a simple blend shape node that blends one mesh to another mesh.\n\nAs inputs to our deformer, we will need a target mesh and a blend weight value:\n\nAbove is our deformers initialize function where we specify all the attributes for our deformer. To create a mesh attribute, we use MFnTypedAttribute. A typed attribute is used to create most attributes of non-simple types like meshes, surfaces, curves, arrays, etc. After the mesh attribute is added, we set it to affect the output geometry attribute, outputGeom. All deformers have an outputGeom attribute which is part of the MPxDeformerNode class. Once the mesh attribute is finished, we create the blend weight attribute which is identical to the float attributes we added in the dependency node example.\n\nThe last code of interest in the initialize function is the makePaintable call. makePaintable is a MEL (and Python) command used to make a particular attribute paintable. All deformers come with a per-vertex weight attribute so we are simple activating the paintability of that attribute. With our deformer initialized, we can move on to the deform function.\n\nThe deform function is where all the deformation implementation code occurs. The workflow is similar to normal dependency nodes where we:\n• Get our inputs from the data block\n• Store the deformed geometry back into the data block.\n\nOur deform function begins with getting the envelope and blend weight input values from the data block. The envelope is a built-in deformer attribute that you can use as a magnitude multiplier for your deformation. After we grab the numeric attribute values, we get the blend target mesh. We need to check if the data is valid because if there is no target mesh connected to the deformer, the MObject will be null and we cannot perform the deformation. Once we have a valid MObject representing our target mesh, we need to extract its point positions. We do this by attaching an MFnMesh function set to the MObject. MFnMesh is the function set used to query, edit, and create polygonal meshes. Now that we have all the inputs, we can begin the deformation algorithm.\n\nThe deform function comes with an MItGeometry parameter that is used to iterate over the components of the input mesh. If you want to take advantage of deformer set membership, you must use this iterator as it only iterates over the vertices or cvs included in the deformer membership. You can query the current vertex id with MItGeometry::index().\n\nAs we iterate over each vertex, we grab the painted weight value for that vertex. MPxDeformerNode has a built-in convenience function, weightValue, which we can use to query each painted weight value. The multiIndex attribute passed into this function is the index of the input geometry. Some deformers can affect multiple meshes at the same time, each having their own painted weight value map. This index specifies which index to use. Most of the time, this is 0. It is for this reason that all paintable attributes need a parent compound array attribute, which we will learn about in later sections.\n\nAfter we have the weight value, we can perform the actual deformation, which is on one line. The blend shape deformation is a simple weighted vector delta addition to the current vertex. With the new point position calculated, we put it back into the geometry iterator. Notice we do not have to do any setClean calls. Unless we add any custom outputs to a deformer, MPxDeformerNode automatically handles that for us when we use the deform function.\n\nYou’ll notice that out of all that code, the actual deformation algorithm is just one line. This is the common case when making plug-ins in the Maya API. Most of the code is usually all the node setup, event handling, and clean up. Coming up with the algorithm is almost the easy part.\n\nAnd here is the full code listing for the blendNode deformer. Notice when we register the node with Maya, we also specify that it is a deformer node.\n\nAnd here is the corresponding Python implementation:\n\nThe only difference besides syntax here is the access of the built-in static variables, outputGeom and envelope, of the proxy class, MPxDeformerNode. We cannot just use self.outputGeom or self.envelope; instead, we can use similar code:\n\nYou can read more about scripted plug-in workflow in the Maya Python API section of the documentation.\n\nOften when we are writing a deformer, we want access to the input geometry MObject in order to get information such as vertex normals, uvs, etc. In the MPxDeformerNode::deform function, all we have available is the MItGeometry iterator which only gives us positional information. We can get the MObject from the datablock but we have to be careful not to trigger any unnecessary dependency graph calculations.\n\nIn MPxDeformerNode, the compute method is already implemented for us. The compute method gets the input geometry for us, creates the geometry interator, and calls the deform method, which is what we implement. Notice when I get the data handles, I use outputArrayValue and outputValue. This prevents Maya from triggering a dirty propagation. If I were to use inputArrayValue and inputValue, Maya would recalculate the input geometry, causing an unnecessary graph evaluation since this was already done in the compute method.\n\nOften when we create a node, we want to customize the attribute editor display of the node to be more user friendly. We do this through attribute editor templates. Attribute editor templates are MEL files describing the attribute editor interface for your node. By default, Maya will automatically arrange the attributes of a node in the attribute editor. Attribute editor templates allow us to customize this display. To create an attribute editor template, create a MEL file called AE{nodeName}Template.mel with an AE{nodeName}Template function inside and place the file in your MAYA_SCRIPT_PATH. The AE{nodeName}Template function contains editorTemplate commands that instruct the attribute editor how to alter the default layout for the attributes in the node. Below is a sample attribute editor template for an imaginary node with 4 attributes, one of which is a ramp attribute.\n\nMScriptUtil is the cumbersome class we must use when using the Maya API with Python. Since the Maya API is designed as a C++ library, it has many pointers and references that are passed into and returned from various functions. Since Python has no pointers or references to simple types, we must use MScriptUtil when we encounter these in the Maya API. Note if you use the Python API 2.0, you don't have to use MScriptUtil. The documentation contains useful information about general usage of MScriptUtil, so I will not reproduce it here. What I will show are various code samples that demonstrate how to use MScriptUtil in various situations since at the time of this writing, the code examples for MScriptUtil are quite limited. Luckily, I don't need to use MScriptUtil often, but when I do encounter it, I will put a snippet on this page to build up a useful reference.\n\nMRampAttribute allows you to create an adjustable curve or color attribute where users can insert and adjust the interpolation of points along the ramp.\n\nTo create ramp attributes, we call the convenient classes contained in MRampAttribute:\n\nTo access the ramp attribute values inside a node or deformer:\n\nYou will also need to make sure the attribute is set correctly in your attribute editor template for the node:\n\nBelow are additional resources to learn the Maya API."
    }
]