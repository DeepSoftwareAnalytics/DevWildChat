[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-keybd_event",
        "document": "Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The keyboard driver's interrupt handler calls the keybd_event function.\n\nA virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see Virtual Key Codes.\n\nControls various aspects of function operation. This parameter can be one or more of the following values.\n\nAn additional value associated with the key stroke.\n\nAn application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To do this, call keybd_event with the bVk parameter set to VK_SNAPSHOT.\n\nThe following sample program toggles the NUM LOCK light by using keybd_event with a virtual key of VK_NUMLOCK. It takes a Boolean value that indicates whether the light should be turned off (FALSE) or on (TRUE). The same technique can be used for the CAPS LOCK key (VK_CAPITAL) and the SCROLL LOCK key (VK_SCROLL)."
    },
    {
        "link": "https://learn.microsoft.com/is-is/windows/win32/api/winuser/nf-winuser-keybd_event",
        "document": "Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The keyboard driver's interrupt handler calls the keybd_event function.\n\nA virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see Virtual Key Codes.\n\nControls various aspects of function operation. This parameter can be one or more of the following values.\n\nAn additional value associated with the key stroke.\n\nAn application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To do this, call keybd_event with the bVk parameter set to VK_SNAPSHOT.\n\nThe following sample program toggles the NUM LOCK light by using keybd_event with a virtual key of VK_NUMLOCK. It takes a Boolean value that indicates whether the light should be turned off (FALSE) or on (TRUE). The same technique can be used for the CAPS LOCK key (VK_CAPITAL) and the SCROLL LOCK key (VK_SCROLL)."
    },
    {
        "link": "https://timgolden.me.uk/pywin32-docs/win32api.html",
        "document": ""
    },
    {
        "link": "https://github.com/wuxc/pywin32doc/blob/master/md/win32api.md",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://github.com/mhammond/pywin32/blob/main/win32/src/win32apimodule.cpp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/13564851/how-to-generate-keyboard-events",
        "document": "I am trying to create a program that will send keyboard events to the computer that for all purposes the simulated events should be treated as actual keystrokes on the keyboard.\n\nI am looking for a way to generate keyboard events using python.\n\nAssume that the function receives a key that it must simulate pressing, like so:\n\nThe above are obviously examples, but what I am looking for is a library, module, or whatever, which I can use to simulate keyboard events.\n\nnote: This is different than sending characters to notepads, or inputting text into fields or such. I want the python script to simulate an actual keyboard event, the computer will think that there is really a keyboard event.\n\nI don't want to send keystrokes to the active window - I want the system to believe the keyboard's keys are being pressed, subtle difference, as some active-windows do not accept certain key-combinations, or if I wanted to use keyboard shortcuts for background processes through my script, they don't need to go through the active-window\n\nSo far I have looked at these things:\n\nHow to generate keyboard keypress events through Python?\n\nWhich were all about apple and didn't help at all.\n\nWhich is the easiest way to simulate keyboard and mouse on Python?\n\nWhich seems like it might be what I need, but I can not find the library for it or any documentation.\n\nI have searched more places as well, but have yet to find a solution."
    },
    {
        "link": "https://stackoverflow.com/questions/12996985/send-some-keys-to-inactive-window-with-python",
        "document": "This is a really old post but there has not been an answer here, I was looking for something exactly like this, and I had spend 6 hours going through Stackoverflow, and ended up just reading all the C documentation because it was more useful.\n\nI've seen posts all over to use\n\nbut I could never figure it out. In addition to that all documentation on Microsoft's site is vary ambiguous, So I've added my own of how I understand it.\n\nThat should get you started and should be helpful for others. If anyone else had revisions let me know."
    },
    {
        "link": "https://gist.github.com/chriskiehl/2906125",
        "document": "You signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://pythonhosted.org/pyglet/programming_guide/keyboard_events.html",
        "document": "The Window.on_key_press and Window.on_key_release events are fired when any key on the keyboard is pressed or released, respectively. These events are not affected by \"key repeat\" -- once a key is pressed there are no more events for that key until it is released.\n\nBoth events are parameterised by the same arguments:\n\nThe argument is an integer that represents a \"virtual\" key code. It does //not// correspond to any particular numbering scheme; in particular the symbol is //not// an ASCII character code. pyglet has key symbols that are hardware and platform independent for many types of keyboard. These are defined in pyglet.window.key as constants. For example, the Latin-1 alphabet is simply the letter itself: The numeric keys have an underscore to make them valid identifiers: Various control and directional keys are identified by name: Keys on the number pad have separate symbols: Some modifier keys have separate symbols for their left and right sides (however they cannot all be distinguished on all platforms): Key symbols are independent of any modifiers being held down. For example, lower-case and upper-case letters both generate the A symbol. This is also true of the number keypad.\n\nThe modifiers that are held down when the event is generated are combined in a bitwise fashion and provided in the parameter. The modifier constants defined in are: MOD_SHIFT MOD_CTRL MOD_ALT Not available on Mac OS X MOD_WINDOWS Available on Windows only MOD_COMMAND Available on Mac OS X only MOD_OPTION Available on Mac OS X only MOD_CAPSLOCK MOD_NUMLOCK MOD_SCROLLLOCK MOD_ACCEL Equivalent to MOD_CTRL, MOD_COMMAND on Mac OS X. For example, to test if the shift key is held down: Unlike the corresponding key symbols, it is not possible to determine whether the left or right modifier is held down (though you could emulate this behaviour by keeping track of the key states yourself).\n\npyglet does not define key symbols for every keyboard ever made. For example, non-Latin languages will have many keys not recognised by pyglet (however, their Unicode representation will still be valid, see ). Even English keyboards often have additional so-called \"OEM\" keys added by the manufacturer, which might be labelled \"Media\", \"Volume\" or \"Shopping\", for example. In these cases pyglet will create a key symbol at runtime based on the hardware scancode of the key. This is guaranteed to be unique for that model of keyboard, but may not be consistent across other keyboards with the same labelled key. The best way to use these keys is to record what the user presses after a prompt, and then check for that same key symbol. Many commercial games have similar functionality in allowing players to set up their own key bindings."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/learnwin32/keyboard-input",
        "document": "Keyboard Input (Get Started with Win32 and C++)\n\nThe keyboard is used for several distinct types of input, including:\n• Character input. Text that the user types into a document or edit box.\n• Keyboard shortcuts. Key strokes that invoke application functions; for example, CTRL + O to open a file.\n• System commands. Key strokes that invoke system functions; for example, ALT + TAB to switch windows.\n\nWhen thinking about keyboard input, it is important to remember that a key stroke is not the same as a character. For example, pressing the A key could result in any of the following characters.\n\nFurther, if the ALT key is held down, pressing the A key produces ALT+A, which the system does not treat as a character at all, but rather as a system command.\n\nWhen you press a key, the hardware generates a scan code. Scan codes vary from one keyboard to the next, and there are separate scan codes for key-up and key-down events. You will almost never care about scan codes. The keyboard driver translates scan codes into virtual-key codes. Virtual-key codes are device-independent. Pressing the A key on any keyboard generates the same virtual-key code.\n\nIn general, virtual-key codes do not correspond to ASCII codes or any other character-encoding standard. This is obvious if you think about it, because the same key can generate different characters (a, A, á), and some keys, such as function keys, do not correspond to any character.\n\nThat said, the following virtual-key codes do map to ASCII equivalents:\n\nIn some respects this mapping is unfortunate, because you should never think of virtual-key codes as characters, for the reasons discussed.\n\nThe header file WinUser.h defines constants for most of the virtual-key codes. For example, the virtual-key code for the LEFT ARROW key is VK_LEFT (0x25). For the complete list of virtual-key codes, see Virtual-Key Codes. No constants are defined for the virtual-key codes that match ASCII values. For example, the virtual-key code for the A key is 0x41, but there is no constant named VK_A. Instead, just use the numeric value.\n\nWhen you press a key, the window that has keyboard focus receives one of the following messages.\n\nThe WM_SYSKEYDOWN message indicates a system key, which is a key stroke that invokes a system command. There are two types of system key:\n\nThe F10 key activates the menu bar of a window. Various ALT-key combinations invoke system commands. For example, ALT + TAB switches to a new window. In addition, if a window has a menu, the ALT key can be used to activate menu items. Some ALT key combinations do not do anything.\n\nAll other key strokes are considered nonsystem keys and produce the WM_KEYDOWN message. This includes the function keys other than F10.\n\nWhen you release a key, the system sends a corresponding key-up message:\n\nIf you hold down a key long enough to start the keyboard's repeat feature, the system sends multiple key-down messages, followed by a single key-up message.\n\nIn all four of the keyboard messages discussed so far, the wParam parameter contains the virtual-key code of the key. The lParam parameter contains some miscellaneous information packed into 32 bits. You typically do not need the information in lParam. One flag that might be useful is bit 30, the \"previous key state\" flag, which is set to 1 for repeated key-down messages.\n\nAs the name implies, system key strokes are primarily intended for use by the operating system. If you intercept the WM_SYSKEYDOWN message, call DefWindowProc afterward. Otherwise, you will block the operating system from handling the command.\n\nKey strokes are converted into characters by the TranslateMessage function, which we first saw in Module 1. This function examines key-down messages and translates them into characters. For each character that is produced, the TranslateMessage function puts a WM_CHAR or WM_SYSCHAR message on the message queue of the window. The wParam parameter of the message contains the UTF-16 character.\n\nAs you might guess, WM_CHAR messages are generated from WM_KEYDOWN messages, while WM_SYSCHAR messages are generated from WM_SYSKEYDOWN messages. For example, suppose the user presses the SHIFT key followed by the A key. Assuming a standard keyboard layout, you would get the following sequence of messages:\n\nOn the other hand, the combination ALT + P would generate:\n\nThe WM_SYSCHAR message indicates a system character. As with WM_SYSKEYDOWN, you should generally pass this message directly to DefWindowProc. Otherwise, you may interfere with standard system commands. In particular, do not treat WM_SYSCHAR as text that the user has typed.\n\nThe WM_CHAR message is what you normally think of as character input. The data type for the character is wchar_t, representing a UTF-16 Unicode character. Character input can include characters outside the ASCII range, especially with keyboard layouts that are commonly used outside of the United States. You can try different keyboard layouts by installing a regional keyboard and then using the On-Screen Keyboard feature.\n\nUsers can also install an Input Method Editor (IME) to enter complex scripts, such as Japanese characters, with a standard keyboard. For example, using a Japanese IME to enter the katakana character カ (ka), you might get the following messages:\n\nSome CTRL key combinations are translated into ASCII control characters. For example, CTRL+A is translated to the ASCII ctrl-A (SOH) character (ASCII value 0x01). For text input, you should generally filter out the control characters. Also, avoid using WM_CHAR to implement keyboard shortcuts. Instead, use WM_KEYDOWN messages; or even better, use an accelerator table. Accelerator tables are described in the next topic, Accelerator Tables.\n\nThe following code displays the main keyboard messages in the debugger. Try playing with different keystroke combinations and see what messages are generated.\n\nSome other keyboard messages can safely be ignored by most applications.\n• The WM_DEADCHAR message is sent for a combining key, such as a diacritic. For example, on a Spanish language keyboard, typing accent (') followed by E produces the character é. The WM_DEADCHAR is sent for the accent character.\n• The WM_UNICHAR message is obsolete. It enables ANSI programs to receive Unicode character input.\n• The WM_IME_CHAR character is sent when an IME translates a keystroke sequence into characters. It is sent in addition to the usual WM_CHAR message.\n\nThe keyboard messages are event-driven. That is, you get a message when something interesting happens, such as a key press, and the message tells you what just happened. But you can also test the state of a key at any time, by calling the GetKeyState function.\n\nFor example, consider how would you detect the combination of left mouse click + ALT key. You could track the state of the ALT key by listening for key-stroke messages and storing a flag, but GetKeyState saves you the trouble. When you receive the WM_LBUTTONDOWN message, just call GetKeyState as follows:\n\nThe GetKeyState message takes a virtual-key code as input and returns a set of bit flags (actually just two flags). The value 0x8000 contains the bit flag that tests whether the key is currently pressed.\n\nMost keyboards have two ALT keys, left and right. The previous example tests whether either of them of pressed. You can also use GetKeyState to distinguish between the left and right instances of the ALT, SHIFT, or CTRL keys. For example, the following code tests if the right ALT key is pressed.\n\nThe GetKeyState function is interesting because it reports a virtual keyboard state. This virtual state is based on the contents of your message queue, and gets updated as you remove messages from the queue. As your program processes window messages, GetKeyState gives you a snapshot of the keyboard at the time that each message was queued. For example, if the last message on the queue was WM_LBUTTONDOWN, GetKeyState reports the keyboard state at the moment when the user clicked the mouse button.\n\nBecause GetKeyState is based on your message queue, it also ignores keyboard input that was sent to another program. If the user switches to another program, any key presses that are sent to that program are ignored by GetKeyState. If you really want to know the immediate physical state of the keyboard, there is a function for that: GetAsyncKeyState. For most UI code, however, the correct function is GetKeyState."
    }
]