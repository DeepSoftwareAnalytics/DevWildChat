[
    {
        "link": "https://guides.rubyonrails.org/active_record_querying.html",
        "document": "What is the Active Record Query Interface?\n\nIf you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.\n\nActive Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.\n\nCode examples throughout this guide will refer to one or more of the following models:\n\nTo retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.\n\nFinder methods that return a collection, such as and , return an instance of . Methods that find a single entity, such as and , return a single instance of the model.\n\nThe primary operation of can be summarized as:\n• Convert the supplied options to an equivalent SQL query.\n• Fire the SQL query and retrieve the corresponding results from the database.\n• Instantiate the equivalent Ruby object of the appropriate model for every resulting row.\n• Run and then callbacks, if any.\n\nActive Record provides several different ways of retrieving a single object.\n\nUsing the method, you can retrieve the object corresponding to the specified primary key that matches any supplied options. For example:\n\nThe SQL equivalent of the above is:\n\nThe method will raise an exception if no matching record is found.\n\nYou can also use this method to query for multiple objects. Call the method and pass in an array of primary keys. The return will be an array containing all of the matching records for the supplied primary keys. For example:\n\nThe SQL equivalent of the above is:\n\nIf your table uses a composite primary key, you'll need to pass find an array to find a single item. For instance, if customers were defined with as a primary key:\n\nThe SQL equivalent of the above is:\n\nTo find multiple customers with composite IDs, you would pass an array of arrays:\n\nThe SQL equivalent of the above is:\n\nThe method retrieves a record without any implicit ordering. For example:\n\nThe SQL equivalent of the above is:\n\nThe method returns if no record is found and no exception will be raised.\n\nYou can pass in a numerical argument to the method to return up to that number of results. For example\n\nThe SQL equivalent of the above is:\n\nThe method behaves exactly like , except that it will raise if no matching record is found.\n\nThe method finds the first record ordered by primary key (default). For example:\n\nThe SQL equivalent of the above is:\n\nThe method returns if no matching record is found and no exception will be raised.\n\nIf your default scope contains an order method, will return the first record according to this ordering.\n\nYou can pass in a numerical argument to the method to return up to that number of results. For example\n\nThe SQL equivalent of the above is:\n\nModels with composite primary keys will use the full composite primary key for ordering. For instance, if customers were defined with as a primary key:\n\nThe SQL equivalent of the above is:\n\nOn a collection that is ordered using , will return the first record ordered by the specified attribute for .\n\nThe SQL equivalent of the above is:\n\nThe method behaves exactly like , except that it will raise if no matching record is found.\n\nThe method finds the last record ordered by primary key (default). For example:\n\nThe SQL equivalent of the above is:\n\nThe method returns if no matching record is found and no exception will be raised.\n\nModels with composite primary keys will use the full composite primary key for ordering. For instance, if customers were defined with as a primary key:\n\nThe SQL equivalent of the above is:\n\nIf your default scope contains an order method, will return the last record according to this ordering.\n\nYou can pass in a numerical argument to the method to return up to that number of results. For example\n\nThe SQL equivalent of the above is:\n\nOn a collection that is ordered using , will return the last record ordered by the specified attribute for .\n\nThe SQL equivalent of the above is:\n\nThe method behaves exactly like , except that it will raise if no matching record is found.\n\nThe method finds the first record matching some conditions. For example:\n\nIt is equivalent to writing:\n\nThe SQL equivalent of the above is:\n\nNote that there is no in the above SQL. If your conditions can match multiple records, you should apply an order to guarantee a deterministic result.\n\nThe method behaves exactly like , except that it will raise if no matching record is found. For example:\n\nThis is equivalent to writing:\n\nWhen specifying conditions on methods like and , the use of will match against an attribute on the model. This is different from , where the ID passed in should be a primary key value.\n\nTake caution when using on models where is not the primary key, such as composite primary key models. For example, if customers were defined with as a primary key:\n\nHere, we might intend to search for a single record with the composite primary key , but Active Record will search for a record with an column of either 5 or 10, and may return the wrong record.\n\nWe often need to iterate over a large set of records, as when we send a newsletter to a large set of customers, or when we export data.\n\nThis may appear straightforward:\n\nBut this approach becomes increasingly impractical as the table size increases, since instructs Active Record to fetch the entire table in a single pass, build a model object per row, and then keep the entire array of model objects in memory. Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.\n\nRails provides two methods that address this problem by dividing records into memory-friendly batches for processing. The first method, , retrieves a batch of records and then yields each record to the block individually as a model. The second method, , retrieves a batch of records and then yields the entire batch to the block as an array of models.\n\nThe method retrieves records in batches and then yields each one to the block. In the following example, retrieves customers in batches of 1000 and yields them to the block one by one:\n\nThis process is repeated, fetching more batches as needed, until all of the records have been processed.\n\nworks on model classes, as seen above, and also on relations:\n\nas long as they have no ordering, since the method needs to force an order internally to iterate.\n\nIf an order is present in the receiver the behavior depends on the flag . If true, is raised, otherwise the order is ignored and a warning issued, which is the default. This can be overridden with the option , explained below.\n\nThe option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. For example, to retrieve records in batches of 5000:\n\nBy default, records are fetched in ascending order of the primary key. The option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need. This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.\n\nFor example, to send newsletters only to customers with the primary key starting from 2000:\n\nSimilar to the option, allows you to configure the last ID of the sequence whenever the highest ID is not the one you need. This would be useful, for example, if you wanted to run a batch process using a subset of records based on and .\n\nFor example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:\n\nAnother example would be if you wanted multiple workers handling the same processing queue. You could have each worker handle 10000 records by setting the appropriate and options on each worker.\n\nOverrides the application config to specify if an error should be raised when an order is present in the relation.\n\nSpecifies the primary key order (can be or ). Defaults to .\n\nThe method is similar to , since both retrieve batches of records. The difference is that yields batches to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:\n\nworks on model classes, as seen above, and also on relations:\n\nas long as they have no ordering, since the method needs to force an order internally to iterate.\n\nThe method accepts the same options as :\n\nJust like for , establishes how many records will be retrieved in each group. For example, retrieving batches of 2500 records can be specified as:\n\nThe option allows specifying the beginning ID from where records will be selected. As mentioned before, by default records are fetched in ascending order of the primary key. For example, to retrieve customers starting on ID: 5000 in batches of 2500 records, the following code can be used:\n\nThe option allows specifying the ending ID of the records to be retrieved. The code below shows the case of retrieving customers in batches, up to the customer with ID: 7000:\n\nThe option overrides the application config to specify if an error should be raised when a specific order is present in the relation.\n\nThe method allows you to specify conditions to limit the records returned, representing the -part of the SQL statement. Conditions can either be specified as a string, array, or hash.\n\nIf you'd like to add conditions to your find, you could just specify them in there, just like . This will find all books where the field value is 'Introduction to Algorithms'.\n\nNow what if that title could vary, say as an argument from somewhere? The find would then take the form:\n\nActive Record will take the first argument as the conditions string and any additional arguments will replace the question marks in it.\n\nIf you want to specify multiple conditions:\n\nIn this example, the first question mark will be replaced with the value in and the second will be replaced with the SQL representation of , which depends on the adapter.\n\nbecause of argument safety. Putting the variable directly into the conditions string will pass the variable to the database as-is. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.\n\nSimilar to the replacement style of params, you can also specify keys in your conditions string along with a corresponding keys/values hash:\n\nThis makes for clearer readability if you have a large number of variable conditions.\n\nAlthough condition arguments are automatically escaped to prevent SQL injection, SQL wildcards (i.e., and ) are not escaped. This may cause unexpected behavior if an unsanitized value is used in an argument. For example:\n\nIn the above code, the intent is to match titles that start with a user-specified string. However, any occurrences of or in will be treated as wildcards, leading to surprising query results. In some circumstances, this may also prevent the database from using an intended index, leading to a much slower query.\n\nTo avoid these problems, use to escape wildcard characters in the relevant portion of the argument:\n\nActive Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them:\n\nThis will generate SQL like this:\n\nThe field name can also be a string:\n\nIn the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.\n\nHash conditions may also be specified in a tuple-like syntax, where the key is an array of columns and the value is an array of tuples:\n\nThis syntax can be useful for querying relations where the table uses a composite primary key:\n\nThis will find all books created yesterday by using a SQL statement:\n\nThis demonstrates a shorter syntax for the examples in Array Conditions\n\nBeginless and endless ranges are supported and can be used to build less/greater than conditions.\n\nThis would generate SQL like:\n\nIf you want to find records using the expression you can pass an array to the conditions hash:\n\nThis code will generate SQL like this:\n\nSQL queries can be built by :\n\nIn other words, this query can be generated by calling with no argument, then immediately chain with passing conditions. This will generate SQL like this:\n\nIf a query has a hash condition with non-nil values on a nullable column, the records that have values on the nullable column won't be returned. For example:\n\nconditions between two relations can be built by calling on the first relation, and passing the second one as an argument.\n\nconditions can be built by chaining conditions.\n\nconditions for the logical intersection between relations can be built by calling on the first relation, and passing the second one as an argument.\n\nTo retrieve records from the database in a specific order, you can use the method.\n\nFor example, if you're getting a set of records and want to order them in ascending order by the field in your table:\n\nYou could specify or as well:\n\nIf you want to call multiple times, subsequent orders will be appended to the first:\n\nYou can also order from a joined table\n\nBy default, selects all the fields from the result set using .\n\nTo select only a subset of fields from the result set, you can specify the subset via the method.\n\nFor example, to select only and columns:\n\nThe SQL query used by this find call will be somewhat like:\n\nBe careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:\n\nWhere is the attribute you asked for. The method will not raise the , so just be careful when working with associations because they need the method to function properly.\n\nIf you would like to only grab a single record per unique value in a certain field, you can use :\n\nThis would generate SQL like:\n\nYou can also remove the uniqueness constraint:\n\nTo apply to the SQL fired by the , you can specify the using and methods on the relation.\n\nYou can use to specify the number of records to be retrieved, and use to specify the number of records to skip before starting to return the records. For example\n\nwill return a maximum of 5 customers and because it specifies no offset it will return the first 5 in the table. The SQL it executes looks like this:\n\nwill return instead a maximum of 5 customers beginning with the 31st. The SQL looks like:\n\nTo apply a clause to the SQL fired by the finder, you can use the method.\n\nFor example, if you want to find a collection of the dates on which orders were created:\n\nAnd this will give you a single object for each date where there are orders in the database.\n\nThe SQL that would be executed would be something like this:\n\nTo get the total of grouped items on a single query, call after the .\n\nThe SQL that would be executed would be something like this:\n\nSQL uses the clause to specify conditions on the fields. You can add the clause to the SQL fired by the by adding the method to the find.\n\nThe SQL that would be executed would be something like this:\n\nThis returns the date and total price for each order object, grouped by the day they were ordered and where the total is more than $200.\n\nYou would access the for each order object returned like this:\n\nYou can specify certain conditions to be removed using the method. For example:\n\nThe SQL that would be executed:\n\nYou can also unscope specific clauses. For example, this will remove condition from the where clause:\n\nA relation which has used will affect any relation into which it is merged:\n\nYou can also override conditions using the method. For example:\n\nThe SQL that would be executed:\n\nThe method overrides an existing select statement. For example:\n\nThe SQL that would be executed:\n\nCompare this to the case where the clause is not used:\n\nthe SQL executed would be:\n\nThe method overrides the default scope order. For example if the class definition includes this:\n\nAnd you execute this:\n\nThe SQL that would be executed:\n\nYou can using the clause to specify a different way to order the books:\n\nThe SQL that would be executed:\n\nThe method reverses the ordering clause if specified.\n\nThe SQL that would be executed:\n\nIf no ordering clause is specified in the query, the orders by the primary key in reverse order.\n\nThe SQL that would be executed:\n\nThe method overrides an existing, named condition. For example:\n\nThe SQL that would be executed:\n\nIf the clause is not used, the where clauses are ANDed together:\n\nthe SQL executed would be:\n\nThe method overrides an existing, named condition. For example:\n\nThe SQL that would be executed:\n\nIf the clause is not used, the group clauses are combined together:\n\nthe SQL executed would be:\n\nThe method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.\n\nActive Record provides the method on a relation to explicitly disallow modification of any of the returned objects. Any attempt to alter a readonly record will not succeed, raising an exception.\n\nAs is explicitly set to be a readonly object, the above code will raise an exception when calling with an updated value of visits.\n\nLocking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.\n\nOptimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. It does this by checking whether another process has made changes to a record since it was opened. An exception is thrown if that has occurred and the update is ignored.\n\nIn order to use optimistic locking, the table needs to have a column called of type integer. Each time the record is updated, Active Record increments the column. If an update request is made with a lower value in the field than is currently in the column in the database, the update request will fail with an .\n\nYou're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.\n\nThis behavior can be turned off by setting .\n\nTo override the name of the column, provides a class attribute called :\n\nPessimistic locking uses a locking mechanism provided by the underlying database. Using when building a relation obtains an exclusive lock on the selected rows. Relations using are usually wrapped inside a transaction for preventing deadlock conditions.\n\nThe above session produces the following SQL for a MySQL backend:\n\nYou can also pass raw SQL to the method for allowing different types of locks. For example, MySQL has an expression called where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:\n\nIf you already have an instance of your model, you can start a transaction and acquire the lock in one go using the following code:\n\nActive Record provides two finder methods for specifying clauses on the resulting SQL: and . While should be used for or custom queries, is used for queries using .\n\nThere are multiple ways to use the method.\n\nYou can just supply the raw SQL specifying the clause to :\n\nThis will result in the following SQL:\n\nActive Record lets you use the names of the associations defined on the model as a shortcut for specifying clauses for those associations when using the method.\n\nAll of the following will produce the expected join queries using :\n\nOr, in English: \"return a Book object for all books with reviews\". Note that you will see duplicate books if a book has more than one review. If you want unique books, you can use .\n\nOr, in English: \"return all books that have an author and at least one review\". Note again that books with multiple reviews will show up multiple times.\n\nOr, in English: \"return all books that have a review by a customer.\"\n\nOr, in English: \"return all authors that have books with reviews and have been ordered by a customer, and the suppliers for those books.\"\n\nSpecifying Conditions on the Joined Tables\n\nYou can specify conditions on the joined tables using the regular Array and String conditions. Hash conditions provide a special syntax for specifying conditions for the joined tables:\n\nThis will find all customers who have orders that were created yesterday, using a SQL expression to compare .\n\nAn alternative and cleaner syntax is to nest the hash conditions:\n\nFor more advanced conditions or to reuse an existing named scope, may be used. First, let's add a new named scope to the model:\n\nNow we can use to merge in the scope:\n\nThis will find all customers who have orders that were created yesterday, again using a SQL expression.\n\nIf you want to select a set of records whether or not they have associated records you can use the method.\n\nWhich means: \"return all customers with their count of reviews, whether or not they have any reviews at all\"\n\nThe and query methods let you select a set of records based on the presence or absence of an association.\n\nWhich means \"return all customers that have made at least one review\".\n\nWhich means \"return all customers that have not made any reviews\".\n\nEager loading is the mechanism for loading the associated records of the objects returned by using as few queries as possible.\n\nConsider the following code, which finds 10 books and prints their authors' last_name:\n\nThis code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = 11 queries in total.\n\nActive Record lets you specify in advance all the associations that are going to be loaded.\n\nWith , Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.\n\nRevisiting the above case using the method, we could rewrite to eager load authors:\n\nThe above code will execute just 2 queries, as opposed to the 11 queries from the original case:\n\nActive Record lets you eager load any number of associations with a single call by using an array, hash, or a nested hash of array/hash with the method.\n\nThis loads all the customers and the associated orders and reviews for each.\n\nThis will find the customer with id 1 and eager load all of the associated orders for it, the books for all of the orders, and the author and supplier for each of the books.\n\nEven though Active Record lets you specify conditions on the eager loaded associations just like , the recommended way is to use joins instead.\n\nHowever if you must do this, you may use as you would normally.\n\nThis would generate a query which contains a whereas the method would generate one using the function instead.\n\nIf there was no condition, this would generate the normal set of two queries.\n\nIf, in the case of this query, there were no books for any authors, all the authors would still be loaded. By using (an INNER JOIN), the join conditions must match, otherwise no records will be returned.\n\nWith , Active Record loads each specified association using one query per association.\n\nRevisiting the N + 1 queries problem, we could rewrite to preload authors:\n\nThe above code will execute just 2 queries, as opposed to the 11 queries from the original case:\n\nWith , Active Record loads all specified associations using a .\n\nRevisiting the case where N + 1 was occurred using the method, we could rewrite to authors:\n\nThe above code will execute just 1 query, as opposed to the 11 queries from the original case:\n\nEager loading can prevent N + 1 queries but you might still be lazy loading some associations. To make sure no associations are lazy loaded you can enable .\n\nBy enabling strict loading mode on a relation, an will be raised if the record tries to lazily load any association:\n\nTo enable for all relations, change the flag to .\n\nTo send violations to the logger instead, change to .\n\nWe can also enable strict loading on the record itself by calling :\n\nalso takes a argument. Setting it to will only raise an error if an association that will lead to an N + 1 query is lazily loaded:\n\nWe can also enable strict loading for a single association by providing the option:\n\nScoping allows you to specify commonly-used queries which can be referenced as method calls on the association objects or models. With these scopes, you can use every method previously covered such as , and . All scope bodies should return an or to allow for further methods (such as other scopes) to be called on it.\n\nTo define a simple scope, we use the method inside the class, passing the query that we'd like to run when this scope is called:\n\nTo call this scope we can call it on either the class:\n\nOr on an association consisting of objects:\n\nScopes are also chainable within scopes:\n\nYour scope can take arguments:\n\nCall the scope as if it were a class method:\n\nHowever, this is just duplicating the functionality that would be provided to you by a class method.\n\nThese methods will still be accessible on the association objects:\n\nLike the other examples, this will behave similarly to a class method.\n\nHowever, there is one important caveat: A scope will always return an object, even if the conditional evaluates to , whereas a class method, will return . This can cause when chaining class methods with conditionals, if any of the conditionals return .\n\nIf we wish for a scope to be applied across all queries to the model we can use the method within the model itself.\n\nWhen queries are executed on this model, the SQL query will now look something like this:\n\nIf you need to do more complex things with a default scope, you can alternatively define it as a class method:\n\nBe aware that, when given in the format, query arguments cannot be converted to a for default attribute assignment. E.g.:\n\nJust like clauses, scopes are merged using conditions.\n\nWe can mix and match and conditions and the final SQL will have all conditions joined with .\n\nIf we do want the last clause to win then can be used.\n\nOne important caveat is that will be prepended in and conditions.\n\nAs you can see above the is being merged in both and conditions.\n\nIf we wish to remove scoping for any reason we can use the method. This is especially useful if a is specified in the model and should not be applied for this particular query.\n\nThis method removes all scoping and will do a normal query on the table.\n\nFor every field (also known as an attribute) you define in your table, Active Record provides a finder method. If you have a field called on your model for example, you get the instance method for free from Active Record. If you also have a field on the model, you also get method.\n\nYou can specify an exclamation point ( ) on the end of the dynamic finders to get them to raise an error if they do not return any records, like\n\nIf you want to find both by and , you can chain these finders together by simply typing \" \" between the fields. For example, .\n\nAn enum lets you define an Array of values for an attribute and refer to them by name. The actual value stored in the database is an integer that has been mapped to one of the values.\n• Create scopes that can be used to find all objects that have or do not have one of the enum values\n• Create an instance method that can be used to determine if an object has a particular value for the enum\n• Create an instance method that can be used to change the enum value of an object\n\nfor all possible values of an enum.\n\nFor example, given this declaration:\n\nThese scopes are created automatically and can be used to find all objects with or without a particular value for :\n\nThese instance methods are created automatically and query whether the model has that value for the enum:\n\nThese instance methods are created automatically and will first update the value of to the named value and then query whether or not the status has been successfully set to the value:\n\nFull documentation about enums can be found here.\n\nThe Active Record pattern implements Method Chaining, which allow us to use multiple Active Record methods together in a simple and straightforward way.\n\nYou can chain methods in a statement when the previous method called returns an , like , , and . Methods that return a single object (see Retrieving a Single Object Section) have to be at the end of the statement.\n\nThere are some examples below. This guide won't cover all the possibilities, just a few as examples. When an Active Record method is called, the query is not immediately generated and sent to the database. The query is sent only when the data is actually needed. So each example below generates a single query.\n\nThe result should be something like this:\n\nThe above should generate:\n\nIt's common that you need to find a record or create it if it doesn't exist. You can do that with the and methods.\n\nThe method checks whether a record with the specified attributes exists. If it doesn't, then is called. Let's see an example.\n\nSuppose you want to find a customer named \"Andy\", and if there's none, create one. You can do so by running:\n\nThe SQL generated by this method looks like this:\n\nreturns either the record that already exists or the new record. In our case, we didn't already have a customer named Andy so the record is created and returned.\n\nThe new record might not be saved to the database; that depends on whether validations passed or not (just like ).\n\nSuppose we want to set the 'locked' attribute to if we're creating a new record, but we don't want to include it in the query. So we want to find the customer named \"Andy\", or if that customer doesn't exist, create a customer named \"Andy\" which is not locked.\n\nWe can achieve this in two ways. The first is to use :\n\nThe second way is using a block:\n\nThe block will only be executed if the customer is being created. The second time we run this code, the block will be ignored.\n\nYou can also use to raise an exception if the new record is invalid. Validations are not covered on this guide, but let's assume for a moment that you temporarily add\n\nto your model. If you try to create a new without passing an , the record will be invalid and an exception will be raised:\n\nThe method will work just like but it will call instead of . This means that a new model instance will be created in memory but won't be saved to the database. Continuing with the example, we now want the customer named 'Nina':\n\nBecause the object is not yet stored in the database, the SQL generated looks like this:\n\nWhen you want to save it to the database, just call :\n\nIf you'd like to use your own SQL to find records in a table you can use . The method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:\n\nprovides you with a simple way of making custom calls to the database and retrieving instantiated objects.\n\nhas a close relative called . will retrieve objects from the database using custom SQL just like but will not instantiate them. This method will return an instance of class and calling on this object would return you an array of hashes where each hash indicates a record.\n\ncan be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns an array of values of the specified columns with the corresponding data type.\n\nmakes it possible to replace code like:\n\nUnlike , directly converts a database result into a Ruby , without constructing objects. This can mean better performance for a large or frequently-run query. However, any model method overrides will not be available. For example:\n\nYou are not limited to querying fields from a single table, you can query multiple tables as well.\n\nFurthermore, unlike and other scopes, triggers an immediate query, and thus cannot be chained with any further scopes, although it can work with scopes already constructed earlier:\n\nOne way to avoid this is to the includes:\n\ncan be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns the first row of the specified column values ​​with corresponding data type. is a short-hand for , which is primarily useful when you already have a relation that is limited to one row.\n\nmakes it possible to replace code like:\n\ncan be used to pluck all the IDs for the relation using the table's primary key.\n\nIf you simply want to check for the existence of the object there's a method called . This method will query the database using the same query as , but instead of returning an object or collection of objects it will return either or .\n\nThe method also takes multiple values, but the catch is that it will return if any one of those records exists.\n\nIt's even possible to use without any arguments on a model or a relation.\n\nThe above returns if there is at least one customer with the 'Ryan' and otherwise.\n\nThe above returns if the table is empty and otherwise.\n\nYou can also use and to check for existence on a model or relation. will use SQL to determine if the item exists.\n\nThis section uses as an example method in this preamble, but the options described apply to all sub-sections.\n\nYou can also use various finder methods on a relation for performing complex calculations:\n\nIf you want to see how many records are in your model's table you could call and that will return the number. If you want to be more specific and find all the customers with a title present in the database you can use .\n\nFor options, please see the parent section, Calculations.\n\nIf you want to see the average of a certain number in one of your tables you can call the method on the class that relates to the table. This method call will look something like this:\n\nThis will return a number (possibly a floating-point number such as 3.14159265) representing the average value in the field.\n\nFor options, please see the parent section, Calculations.\n\nIf you want to find the minimum value of a field in your table you can call the method on the class that relates to the table. This method call will look something like this:\n\nFor options, please see the parent section, Calculations.\n\nIf you want to find the maximum value of a field in your table you can call the method on the class that relates to the table. This method call will look something like this:\n\nFor options, please see the parent section, Calculations.\n\nIf you want to find the sum of a field for all records in your table you can call the method on the class that relates to the table. This method call will look something like this:\n\nFor options, please see the parent section, Calculations.\n\nYou can run on a relation. EXPLAIN output varies for each database.\n\nmay yield this for MySQL and MariaDB:\n\nActive Record performs a pretty printing that emulates that of the corresponding database shell. So, the same query running with the PostgreSQL adapter would yield instead:\n\nEager loading may trigger more than one query under the hood, and some queries may need the results of previous ones. Because of that, actually executes the query, and then asks for the query plans. For example, running:\n\nmay yield this for MySQL and MariaDB:\n\nand may yield this for PostgreSQL:\n\nFor databases and adapters which support them (currently PostgreSQL, MySQL, and MariaDB), options can be passed to provide deeper analysis.\n\nUsing PostgreSQL, the following:\n\nUsing MySQL or MariaDB, the following:\n\nInterpretation of the output of EXPLAIN is beyond the scope of this guide. The following pointers may be helpful:"
    },
    {
        "link": "https://iamtusharxo.medium.com/activerecord-querying-in-rails-a-comprehensive-guide-80928efe4a72",
        "document": "ActiveRecord, the ORM (Object-Relational Mapping) framework in Ruby on Rails, simplifies database interactions by allowing developers to work with databases using Ruby objects. One of the most powerful features of ActiveRecord is its querying interface, which enables developers to retrieve and manipulate data from the database effortlessly. In this guide, we’ll delve into ActiveRecord querying in detail, exploring its various methods, syntax, and best practices.\n\nActiveRecord querying involves retrieving data from the database using methods provided by ActiveRecord models. These methods allow developers to construct SQL queries dynamically without writing raw SQL. By leveraging Ruby’s expressive syntax, developers can build complex queries in a concise and readable manner.\n• and : Restricts the number of records returned and specifies the starting point for retrieval, respectively.\n\nThese examples demonstrate how ActiveRecord queries are constructed and their corresponding outputs, showcasing the versatility and power of ActiveRecord in interacting with databases within Ruby on Rails applications\n• Associations: ActiveRecord associations enable developers to retrieve associated records using methods like , , and .\n• Aggregations: Methods like , , , and allow developers to perform aggregate calculations on database columns.\n• Joins: ActiveRecord supports different types of joins, such as , , and , for fetching associated records efficiently.\n• Dynamic Finders: ActiveRecord provides dynamic finder methods like , , and for convenient record retrieval based on attribute values.\n• Use ActiveRecord Methods: Prefer using ActiveRecord methods over raw SQL to maintain consistency and leverage Rails conventions.\n• Optimize Queries: Avoid N+1 query problems by eager loading associations using or when fetching associated records.\n• Keep Queries Readable: Write clear and concise queries that are easy to understand and maintain.\n\nBuilding reliable and effective Rails applications requires a solid understanding of ActiveRecord queries. Through comprehension of its diverse techniques, phrasing, and optimal methodologies, developers can fully harness the capabilities of ActiveRecord to effortlessly engage with databases. ActiveRecord offers the resources required to manage database interactions elegantly and with ease, regardless of the complexity of the data manipulations or basic CRUD activities.’\n\nVisit Rails Guides for more Information on ActiveRecord — Rails-Guide"
    },
    {
        "link": "https://kinsta.com/blog/active-record-query-optimization",
        "document": "As a Ruby on Rails developer, it’s important to understand optimizing database queries to improve performance and enhance the user experience. Active Record, the Rails ORM (Object-Relational Mapping) tool, offers powerful features for querying databases efficiently.\n\nQuery optimization is a complex subject, with many books written on the subject. Here, we will explore a few techniques and some tips to optimize your Active Record queries and boost your application’s speed and responsiveness.\n\nOne of the most effective ways to optimize Active Record queries is to retrieve only the necessary columns from the database. By specifying the exact columns you require, you minimize the data transferred between the database and your Ruby on Rails application. For example, if we were only looking to use names from the database:\n\nEager loading helps reduce the number of database queries by loading associated records in advance. By preloading associations, you avoid the N+1 query problem, where additional queries are executed for each associated record. Below is an example of the N+1 query problem, and then we introduce an alternative technique called Russian Doll Caching.\n\nIn the above example, we fetch all the users and then iterate over each user to retrieve the count of their associated posts. This results in N additional queries being executed, leading to performance degradation.\n\nTo overcome this issue, we can employ eager loading with the method, as shown below:\n\nBy using , we load the associated posts for all users in just two queries. The method efficiently preloads the association data, eliminating the need for additional queries and significantly improving performance.\n\nBesides eager loading, an alternative technique to optimize database queries is Russian Doll Caching. This technique involves caching hierarchical data structures and their associations, allowing for efficient retrieval without redundant queries.\n\nLet’s consider an example where we retrieve a list of blog posts and their associated comments:\n\nIn the above code, each iteration of the loop triggers a query to fetch the comments for each post, leading to N additional queries.\n\nTo implement Russian Doll Caching, we can use a caching approach like fragment caching. By caching the entire view or partial, including the associated records, we can avoid redundant queries. Here’s an example:\n\nIn this implementation, we cache the object and each individual post using the helper. When rendering the view or partial, Rails checks the cache before executing any code, eliminating the need for additional queries.\n\nBy implementing Russian Doll Caching, you can optimize performance by minimizing database queries and efficiently retrieving hierarchical data structures and their associations.\n\nEager loading is a powerful technique to avoid the N+1 query problem by preloading associations. Additionally, Russian Doll Caching provides an alternative approach to optimize database queries by caching hierarchical data structures and their associations.\n\nBy employing these techniques, you can boost the performance and responsiveness of your Ruby on Rails applications. Choose the approach that best fits your application’s needs and intricacies.\n\nThere are gems that will assist you in identifying N+1 queries while you are developing your application. Gems like Bullet, Rack Mini Profiler, and Prosopite are some examples that are worth trying on your project.\n\nIndexes improve query performance by allowing the database to locate records more quickly. In Active Record, you can add indexes to your database schema, particularly on columns used frequently in queries. For example:\n\nAdditionally, there are gems that can assist you with identifying where you should be adding indexes, such as lol_dba or database_consistency gems.\n\nWhen constructing queries, consider using database-specific features for conditions to avoid unnecessary data retrieval. Active Record provides various methods for optimizing query conditions, such as , , , and . Here’s an example:\n\nWorking with large datasets can impact performance due to memory constraints. Consider using batch processing techniques to break down queries into smaller chunks, reducing memory usage. This approach is especially useful when performing operations like updating or deleting records.\n\nHowever, it’s important to use batch processing correctly to achieve optimal performance. Let’s take a look at an example of poor batch processing and how it can negatively affect your application:\n\nIn the above code snippet, we fetch all the user records from the database using . This can pose a significant performance issue when dealing with large datasets because it loads all the records into memory at once. As a result, the application may consume excessive memory resources and slow down.\n\nTo address this problem, let’s refactor the code using a more optimized batch processing approach:\n\nIn this updated implementation, we use the method provided by Active Record. This method fetches records in smaller batches, specified by the , reducing the memory footprint. It processes each batch of records within its own memory context, greatly improving the application’s performance when dealing with large datasets.\n\nBy using , you can effectively process large datasets in a memory-efficient manner. Remember to adjust the based on your application’s need and available system resources.\n\nOptimizing Active Record queries is crucial for enhancing the performance of your Ruby on Rails applications. By following the tips outlined in this article – including selective column retrieval, eager loading, indexing, optimizing conditions, and batch processing – you can significantly improve the speed and efficiency of your database queries.\n\nRemember, fine-tuning your queries not only improves the user experience but also reduces the load on your database server. Keep these optimization techniques in mind, and your Ruby on Rails application will run smoothly, even with large amounts of data. Happy coding!"
    },
    {
        "link": "https://snapsheetclaims.com/11-ways-to-boost-your-activerecord-query-performance",
        "document": "ActiveRecord has lots of tools to help us simplify database interactions, but it's important to make sure our queries are still efficient and easy to understand as our apps get bigger. This article outlines all the ways you can make ActiveRecord queries simpler, faster, and easier to maintain. When necessary, we’ll dive into the limitations of each and what alternative performance technique can be used instead. Ever come across a website where all of the images, gifs, and text display a loading sign upon the initial load? If yes, you may have witnessed eager loading. Achieved through the includes method, eager loading is the process in which a query for one type of model also loads related model(s). In other words, eager loading ensures that your page’s model and all its associated models are loaded all at once. You have a Blog model with related Blog Post models. Your Blog Post models each have many Comment models. You want to show a list of blog posts with the number of comments for each post. Without eager loading, you might end up with slow performance due to additional queries fetching the comments for each blog post.\n\nlimit and offset help to \"paginate\" the loaded data, preventing all of it from being loaded into memory at once. where allows conditions to be applied to the data, filtering out records that do not match the conditions. Only the matching records are then loaded into memory. Use where when you need to filter records based on specific conditions. Use limit when you want to cap the number of records returned by a query to a specific number, such as for implementing pagination. Use offset when you want to skip a certain number of records from the beginning of the result set. This is commonly used in combination with limit for implementing pagination. Data Overload: Sometimes, even when querying with conditions or pagination, the number of records we are loading into memory at once is still too large. In cases with extremely large datasets, it is advisable to use batch processing to load records. Using ActiveRecord’s where, all, or find methods may not be the best way to query records when we’re dealing with large datasets. With large datasets, the performance is bound to decrease when we use these methods because all of the matching records are loaded into memory. Performance can be improved by processing records in smaller groups, AKA batch processing. This can be accomplished through Rails’ find_each, find_in_batches and in_batches methods. Note: The in_batches method was introduced in Rails 5.\n\nNewer Ruby versions have enhanced garbage collection, which helps reduce memory usage. Efficient memory usage can contribute to improved application performance, including the execution of ActiveRecord queries. Newer versions of Rails often come with performance enhancements, bug fixes, and optimizations in the ActiveRecord query interface. These improvements can lead to faster and more efficient query execution, reducing the time required to grab data from the database. Indexing in ActiveRecord improves query performance by creating data structures that enable the database engine to quickly locate and retrieve records. For instance, adding an index on the name column in a 'Product' model allows faster retrieval of a product by name, optimizing the performance of queries like Product.find_by(name:'Woody from Toy Story'). Implement an index in a database when dealing with large tables containing a substantial amount of records, especially if certain columns are frequently queried in the WHERE clause, involved in JOIN operations, or used for sorting and grouping. Focus on indexing critical parts of the application where query performance is important. Storage Requirements Increase: While indexes enhance read performance, it's essential to carefully choose which columns to index based on query patterns. Indexing increases storage requirements, as each index consumes additional disk space when used. When space and memory are limited, too many indexes can be a problem. Slower write speed: Storage requirements increasing also means slower write speed for INSERT / UPDATE / DELETE operations with indexes. Every insert, update, or delete operation on a table with indexes requires additional maintenance of those indexes. When a record is added or modified, the corresponding indexes must be updated to reflect the changes. For example, when a new record is inserted, the database must update the index to include the new entry. The more indexes there are, the more maintenance work is required for each insert operation. 10. Prefer these query methods over these:\n• None Prefer exists? over present? or any?: When checking the existence of records, using the exists? method is more efficient than present? because it avoids unnecessary record retrieval. It retrieves a boolean value unlike present? and any? which are fetching the actual records.\n• None Prefer size over count: In scenarios where you only need the number of records and not the actual records themselves, using the size method is more performant. size fetches the count directly from the database, while count retrieves all matching records and then counts them.\n• None Prefer pluck over select: When you only need specific attribute values from a query result, pluck is generally more efficient than select. pluck retrieves only the specified attribute values from the database, whereas select fetches the entire record object.\n• None Prefer find_by over where: If you expect a single record to match a condition, find_by is more performant than where. find_by stops searching and returns the first matching record, whereas where retrieves all matching records and then returns the first one. As we went over above, lazy loading can be a performance enhancer or a performance killer. When lazy loading happens in a loop, it’s called the “N+1 query problem”. The tools below can help us prevent N+1 queries. The Bullet gem is a well-known tool designed to boost your app’s performance by decreasing its query count. The bullet gem can detect N+1 query problems and suggest solutions for when eager loading of associations is optimal. This gem also helps identify unnecessary database queries and increased load times due to unused eager loaded associations. Finally, it can flag areas where additional indexes are beneficial and advise when counter cache usage is appropriate. With the Bullet gem installed and configured to log into the Bullet log file log/bullet.log, you can capture log entries that notify you when a query can be optimized. The entries below indicate whether eager loading is being used and should be avoided, or when it's not in use but should be.\n\nUse strict_loading mode if you only intend to eager load the query/record/association/model/application you enabled the mode for, and want to prevent any lazy loading on that particular query/record/association/model/application. Be careful not to enable strict_loading if you’re not 100% sure you intend on using eager loading on every part of the query/record/association/model/application it’s been enabled for. Otherwise, you’ll receive an unwanted ActiveRecord::StrictLoadingViolationError. Note that you can choose to switch off the StrictLoadingViolationError exception and log it instead. We all want our queries to be fast, but if we try to optimize our ActiveRecord queries too early, it can lead to complex SQL queries or custom caching mechanisms that add unnecessary complexity to our code, making it hard to read and maintain. Some queries just don’t have a significant impact on performance. Make sure to evaluate the real performance bottlenecks and optimize where it matters most. Regularly monitoring and profiling your Rails application, along with familiarizing yourself with traffic metrics, can help you identify areas for improvement. Consider a scenario where one request takes 4 seconds to complete and another takes 2 seconds. Even though both can be optimized, the first one is accessed only once a day, while the second is accessed 100 times a day. Although the second request isn't the slowest, it's the one users interact with more frequently and might need higher priority. Remember, speed is important, but it's not the only thing that matters. Make sure you optimize only where it counts, and keep your code clean and easy to read for future developers. Don't let optimization make your queries harder to understand!"
    },
    {
        "link": "https://blog.nonstopio.com/rails-query-optimization-part-1-introduction-and-best-practices-7cfb5c529388",
        "document": "Optimizing database queries is crucial for maintaining a fast and efficient Ruby on Rails application. Poorly written queries can lead to performance bottlenecks, memory leaks, and even downtime. In this multi-part series, we’ll explore various techniques and tools to optimize Rails queries, from basic practices to advanced strategies.\n• Scalability: Properly optimized queries allow your application to scale seamlessly as data grows.\n\nActive Record provides an intuitive interface for writing database queries in Rails. However, writing queries without understanding their impact on the database can lead to performance issues.\n\nExample:\n\nBest Practice: Use to select only needed columns:\n\nN+1 queries occur when querying associated records inefficiently.\n\nExample of N+1 Query:\n\nThis results in one query for all users, followed by one query per user to fetch posts.\n\nThis loads all users and their posts in just two queries.\n\nWhen dealing with large datasets, using or can lead to high memory consumption.\n\nExample:\n\nRails caches queries within the same request, but repeating queries outside the cached scope can hurt performance.\n\nExample:\n\n6. Using Instead of\n\nTo check if a record exists, using loads the object into memory, whereas only checks for existence.\n\nExample:\n\nWhen to Use Indexes\n• On columns used in , , , and clauses.\n• On foreign keys to speed up association lookups.\n\nRails provides built-in caching to store the results of expensive queries, reducing database load and speeding up response times.\n• The first time this query runs, it fetches data from the database and stores it in the cache.\n• Use caching for expensive and infrequently changing queries.\n• The query runs only once, even if the method is called multiple times.\n• Useful for controllers and views to avoid redundant database hits.\n• N+1 Queries: When associated records are fetched in a loop.\n• Unused Eager Loading: When associations are loaded but not used.\n\nThen, install and generate the configuration:\n\nProsopite is a modern alternative to Bullet for detecting N+1 queries. It integrates seamlessly with Active Record and offers:\n• Better Compatibility: Works well with modern Rails versions.\n• Bullet is more mature and offers comprehensive alerting.\n• Prosopite is lighter and better suited for performance-sensitive applications.\n\nMemory leaks can occur when large query results are kept in memory longer than necessary.\n• Use or to load only necessary columns.\n• Use for batch processing to free memory between batches.\n\nActive Record provides the method to analyze query performance and understand database execution plans.\n• SELECT Type: Shows if the query is , , or a .\n• Key Used: Indicates the index used for the query.\n• Add Indexes: If no index is used, consider adding one to the column.\n• Refactor Queries: Rewrite complex queries to reduce the number of scanned rows.\n\nIn Part 2, we will cover:"
    },
    {
        "link": "https://medium.com/doctolib/how-to-find-fix-and-prevent-n-1-queries-on-rails-6b30d9cfbbaf",
        "document": "A shortlist of actionable advice on how to get rid of N+1 Queries in a Rails application\n\nThis article is a part of the series: Guide to Rails Performance ⚡️\n\nAn N+1 query is a type of performance issue that often occurs when using an object-relational mapper (ORM) such as Active Record in a Rails application. It occurs when the ORM executes a separate query for each of the objects coming from a list of objects, instead of using a single query to load all of them at once.\n\nFor example, consider the following code:\n\nIf the table has 1000 records, this code will execute 1000 separate queries to get the author for each post, which can be very inefficient. This is an example of an N+1 query.\n\nN+1 queries can occur when you are working with associations, such as or if you are not careful about how you load the associated objects.\n\nN+1 queries can also greatly reduce the performance of a Rails application, especially if the queries are executing expensive operations like JOINs or aggregations. To optimize the performance of a Rails application, it is important to identify and fix any N+1 queries that are causing performance issues. That's exactly what we'll talk about in this post!\n\nHow to identify N+1 queries in a Rails app? 🕵🏻‍♂️\n\nThere are several ways you can detect N+1 queries in a Rails application:\n• Using a tool like the bullet gem (or Rails built-in strict loading mode), which can automatically detect and alert you of N+1 queries.\n• Using to monitor the performance of your application and, while on it, identify N+1 queries.\n• Similarly to New Relic, you can locally use both the rack-mini-profiler and the stackprof gems to plot flame graphs and, thus, detect N+1s.\n• Manually review your application’s log files and look for repeated queries that are being executed.\n\nKeep in mind that it’s not always possible to completely eliminate N+1 queries from a Rails application. Still, by using these tools and techniques you should be able to identify the N+1 queries causing performance issues.\n\nHow to fix N+1 queries on Rails? 👨🏻‍🏭\n\nThere are several common techniques you can use to fix N+1 queries in a Rails application:\n\nUse the method to eager load associated records, which will reduce the number of queries needed to load the data.\n\nAttention tho! There are three different methods allowing you to achieve pretty much the same results, but by doing completely different things. These methods are , , and .\n\nAs a rule of thumb, if you don't know what you're doing, go with as it will decide on its own whether to split your query into two subqueries, or a single query with a . In any case, I strongly recommend you to read this article from BigBinary on the topic.\n\nIt's a controversial opinion, but one could argue that N+1 queries are a feature in Rails. And that is exactly what David, the creator of Ruby on Rails, explains in this live discussion about performance with Nate Berkopec, a specialist and renowned author on Rails performance:\n\nIf you opt for that, you can try the Russian Doll Caching strategy.\n\nRussian Doll Caching works by using fragment caching to cache the entire rendered output of a page or partial, along with any nested partials that it includes. It optimizes the performance by reducing the number of database queries needed to render a page, as well as reducing the amount of processing needed to generate the HTML output.\n\nHere is an example of how you can use Russian Doll Caching in a Rails application:\n\nIn this example, the view includes a list of comments for the post. When the view is rendered:\n• The outermost cache block caches the entire rendered output of the view, using the object as the cache key.\n• The second cache block then caches the rendered output of the comments partial, using the object as the cache key.\n• Finally, the innermost cache block caches the rendered output of each individual comment, using the comment object as the cache key.\n\nThis allows the entire rendered output of the view to be cached, along with the rendered output of any nested partials, using a hierarchy of cache keys. When the view is rendered again, the cache will be checked for each level of the hierarchy, and the cached output will be used if it is available, reducing the number of database queries needed to render the view.\n\nHowever, there are some trade-offs to consider:\n• Cache invalidation: With Russian Doll Caching, you need to be careful and properly plan the cache key hierarchy to ensure that the cache keys are properly invalidated when the data changes. Rails' got your back, but if you do not invalidate the cache keys correctly, you may end up with stale data being displayed to users.\n• Memory usage: Caching the entire rendered output of a page or partial can consume a significant amount of memory, especially for pages with large amounts of data or complex layouts. You might need to monitor the memory usage of your application and ensure that you have enough memory to accommodate the cache.\n• Costs: If you are using Russian Doll Caching to cache large amounts of data in a high-traffic application, you may need to use a large number of Redis instances or a high-memory machine to accommodate the cache. This can increase the cost of running the application.\n• Deployment considerations: When you deploy a new version of your application, you may need to clear the cache to ensure that the new version is properly displayed to users. This can cause temporary performance degradation while the cache is warming up again.\n\nOverall, Russian Doll Caching can be a powerful tool for optimizing the performance of a Rails application, but it is important to carefully evaluate the trade-offs and ensure that it is the right approach for you.\n\nAs a last resource, you could also opt to create a database view that pre-aggregates data which can then be more easily reused by the view.\n\nFor example, suppose you have a table and a table, and you want to retrieve a list of all posts along with the number of comments for each post. Instead of executing a separate query for each post to count the comments, you can create a view that pre-joins the and tables and aggregates the information you need into a column.\n\nIMHO, for the vast majority of cases, this solution is not desirable. Creating and maintaining database views come with a high complexity cost. You will need to write custom SELECT statements to define the views, then ensure that the views are updated whenever the underlying data changes.\n\nVanilla Active Record is plenty! \n\n(and here's another great article if you missed the ref)\n\nHow to prevent N+1 queries on Rails? ‍👨🏻‍⚕️\n\nHere are some strategies you can use to prevent N+1 queries in a Rails application:\n\nUse the gem (old but gold)\n\nThe gem can automatically detect and alert you to N+1 queries in your application. It also suggests ways to optimize the queries, such as by using the already mentioned . However, if you're using a more recent version of Rails, the next option might work best for you.\n\nStrict loading was introduced in Rails 6.1. Prior to Rails 6.1, there was no built-in way to enable strict loading in a Rails application. You would have to manually check if the association had been loaded before accessing it, or use a tool like the gem to detect N+1 queries.\n\nBy default, Rails will not raise an error if you try to access an association that has not been loaded. However, you can manually use the option to cause an error to be raised if you try to access an unloaded association. This can help prevent N+1 queries by alerting you about cases where you accidentally executed unnecessary queries.\n\nTo use strict loading in a Rails application, you can set the option to for the association you want to enable strict loading for.\n\nFor example, suppose you have a model that has many models, and you want to enable strict loading for the association. You can set the option as follows:\n\nIf you don't want to activate strict loading mode for all queries coming from this association, you can also do it on a per-query basis:\n\nYou could also choose to activate strict loading for the whole app, or only on logs, it's really up to you. If you're interested in more details about these options, once again, I recommend another BigBinary article."
    },
    {
        "link": "https://medium.com/@salujabhavesh/taming-n-1-queries-understanding-and-mastering-eager-loading-in-ruby-on-rails-2cedea66ff53",
        "document": "Imagine your Rails application fetching data from the database, one record at a time, leading to an endless loop of queries. This dreaded phenomenon, known as N+1 queries, can cripple your application’s performance. But fear not, intrepid developer! Eager loading comes to the rescue, a powerful technique that empowers you to fetch associated data in a single, efficient query.\n• The Problem: When you access associated data through methods like or , Rails automatically issues separate queries for each association. This can become inefficient, especially for large datasets or frequent association access.\n• The Impact: N+1 queries significantly impact performance, slowing down your application and hindering scalability.\n\nEager loading allows you to pre-fetch associated data alongside the main record in a single database query. This significantly reduces the number of queries and enhances application performance.\n• : Preloads data with an inner join, ensuring all related data is available, but might be less performant for large datasets.\n• : Similar to but uses LEFT OUTER JOINs, potentially returning fewer rows and improving performance, especially with large datasets.\n• : Similar to but uses eager joins, forcing all related data to be loaded, regardless of whether it's used or not. Use this cautiously due to potential performance drawbacks.\n• Conditional Eager Loading: Only load specific associations based on certain conditions:\n• Join Clauses for Complex Scenarios: Utilize SQL join clauses for fine-grained control over eager loading:\n\nBy mastering eager loading, you take control of your applications’ database interactions, minimizing N+1 queries and boosting performance. Remember, choosing the right eager loading strategy depends on your specific data model and access patterns. Experiment, explore advanced techniques, and embrace eager loading as a valuable tool in your Rails development toolkit.\n\nHappy coding, and may your applications never drown in a sea of queries!"
    },
    {
        "link": "https://snapsheetclaims.com/11-ways-to-boost-your-activerecord-query-performance",
        "document": "ActiveRecord has lots of tools to help us simplify database interactions, but it's important to make sure our queries are still efficient and easy to understand as our apps get bigger. This article outlines all the ways you can make ActiveRecord queries simpler, faster, and easier to maintain. When necessary, we’ll dive into the limitations of each and what alternative performance technique can be used instead. Ever come across a website where all of the images, gifs, and text display a loading sign upon the initial load? If yes, you may have witnessed eager loading. Achieved through the includes method, eager loading is the process in which a query for one type of model also loads related model(s). In other words, eager loading ensures that your page’s model and all its associated models are loaded all at once. You have a Blog model with related Blog Post models. Your Blog Post models each have many Comment models. You want to show a list of blog posts with the number of comments for each post. Without eager loading, you might end up with slow performance due to additional queries fetching the comments for each blog post.\n\nlimit and offset help to \"paginate\" the loaded data, preventing all of it from being loaded into memory at once. where allows conditions to be applied to the data, filtering out records that do not match the conditions. Only the matching records are then loaded into memory. Use where when you need to filter records based on specific conditions. Use limit when you want to cap the number of records returned by a query to a specific number, such as for implementing pagination. Use offset when you want to skip a certain number of records from the beginning of the result set. This is commonly used in combination with limit for implementing pagination. Data Overload: Sometimes, even when querying with conditions or pagination, the number of records we are loading into memory at once is still too large. In cases with extremely large datasets, it is advisable to use batch processing to load records. Using ActiveRecord’s where, all, or find methods may not be the best way to query records when we’re dealing with large datasets. With large datasets, the performance is bound to decrease when we use these methods because all of the matching records are loaded into memory. Performance can be improved by processing records in smaller groups, AKA batch processing. This can be accomplished through Rails’ find_each, find_in_batches and in_batches methods. Note: The in_batches method was introduced in Rails 5.\n\nNewer Ruby versions have enhanced garbage collection, which helps reduce memory usage. Efficient memory usage can contribute to improved application performance, including the execution of ActiveRecord queries. Newer versions of Rails often come with performance enhancements, bug fixes, and optimizations in the ActiveRecord query interface. These improvements can lead to faster and more efficient query execution, reducing the time required to grab data from the database. Indexing in ActiveRecord improves query performance by creating data structures that enable the database engine to quickly locate and retrieve records. For instance, adding an index on the name column in a 'Product' model allows faster retrieval of a product by name, optimizing the performance of queries like Product.find_by(name:'Woody from Toy Story'). Implement an index in a database when dealing with large tables containing a substantial amount of records, especially if certain columns are frequently queried in the WHERE clause, involved in JOIN operations, or used for sorting and grouping. Focus on indexing critical parts of the application where query performance is important. Storage Requirements Increase: While indexes enhance read performance, it's essential to carefully choose which columns to index based on query patterns. Indexing increases storage requirements, as each index consumes additional disk space when used. When space and memory are limited, too many indexes can be a problem. Slower write speed: Storage requirements increasing also means slower write speed for INSERT / UPDATE / DELETE operations with indexes. Every insert, update, or delete operation on a table with indexes requires additional maintenance of those indexes. When a record is added or modified, the corresponding indexes must be updated to reflect the changes. For example, when a new record is inserted, the database must update the index to include the new entry. The more indexes there are, the more maintenance work is required for each insert operation. 10. Prefer these query methods over these:\n• None Prefer exists? over present? or any?: When checking the existence of records, using the exists? method is more efficient than present? because it avoids unnecessary record retrieval. It retrieves a boolean value unlike present? and any? which are fetching the actual records.\n• None Prefer size over count: In scenarios where you only need the number of records and not the actual records themselves, using the size method is more performant. size fetches the count directly from the database, while count retrieves all matching records and then counts them.\n• None Prefer pluck over select: When you only need specific attribute values from a query result, pluck is generally more efficient than select. pluck retrieves only the specified attribute values from the database, whereas select fetches the entire record object.\n• None Prefer find_by over where: If you expect a single record to match a condition, find_by is more performant than where. find_by stops searching and returns the first matching record, whereas where retrieves all matching records and then returns the first one. As we went over above, lazy loading can be a performance enhancer or a performance killer. When lazy loading happens in a loop, it’s called the “N+1 query problem”. The tools below can help us prevent N+1 queries. The Bullet gem is a well-known tool designed to boost your app’s performance by decreasing its query count. The bullet gem can detect N+1 query problems and suggest solutions for when eager loading of associations is optimal. This gem also helps identify unnecessary database queries and increased load times due to unused eager loaded associations. Finally, it can flag areas where additional indexes are beneficial and advise when counter cache usage is appropriate. With the Bullet gem installed and configured to log into the Bullet log file log/bullet.log, you can capture log entries that notify you when a query can be optimized. The entries below indicate whether eager loading is being used and should be avoided, or when it's not in use but should be.\n\nUse strict_loading mode if you only intend to eager load the query/record/association/model/application you enabled the mode for, and want to prevent any lazy loading on that particular query/record/association/model/application. Be careful not to enable strict_loading if you’re not 100% sure you intend on using eager loading on every part of the query/record/association/model/application it’s been enabled for. Otherwise, you’ll receive an unwanted ActiveRecord::StrictLoadingViolationError. Note that you can choose to switch off the StrictLoadingViolationError exception and log it instead. We all want our queries to be fast, but if we try to optimize our ActiveRecord queries too early, it can lead to complex SQL queries or custom caching mechanisms that add unnecessary complexity to our code, making it hard to read and maintain. Some queries just don’t have a significant impact on performance. Make sure to evaluate the real performance bottlenecks and optimize where it matters most. Regularly monitoring and profiling your Rails application, along with familiarizing yourself with traffic metrics, can help you identify areas for improvement. Consider a scenario where one request takes 4 seconds to complete and another takes 2 seconds. Even though both can be optimized, the first one is accessed only once a day, while the second is accessed 100 times a day. Although the second request isn't the slowest, it's the one users interact with more frequently and might need higher priority. Remember, speed is important, but it's not the only thing that matters. Make sure you optimize only where it counts, and keep your code clean and easy to read for future developers. Don't let optimization make your queries harder to understand!"
    },
    {
        "link": "https://stackoverflow.com/questions/26892991/rails-reducing-queries-performed-using-includes-or-eager-load",
        "document": "I have a thread Model that has many , and each post has an author (User)\n\nIn my Thread controller action + view I want to iterate through all the posts of that particular thread and access information about the user.\n\nWhat's happening at the moment is it's doing a query to find the correct , one query to find all of the and then for each post is it doing:\n\nEven if the same user makes 10 posts, it will still be called 10 times for a particular user.\n\nIs there some way to use or to avoid the repetition of this query?"
    },
    {
        "link": "https://dev.to/junko911/rails-n-1-queries-and-eager-loading-10eh",
        "document": "What is the N+1 query problem?\n\nThe N+1 query problem is one of the common performance antipatterns in ORMs. It happens when a query is executed on each result of the previous query, in other words, when an application gets data from the database and then loop through the result of that data.\n\nThis works just fine if your application is small enough and there are only a small number of requests and queries, but if you want to keep your application scalable, you have to eliminate the N+1 problem from your application.\n\nHere's an example with Rails:\n\nLet's print the and 's for all the .\n\nIt first retrieved all the objects and then for each . There are 6 in the database in this example, so 7 queries in total were executed.\n\nWhat if there are 10,000 posts in the database? The number of database connections is limited and you might hit query timeout.\n\nAs opposed to lazy loading, eager loading is the process whereby a query loads a resource as soon as the code is executed. It also loads related entities as part of the query.\n\nIn Rails, you can use method for eager loading.\n\nThe method specifies relationships to be included in the result set.\n\nLet's rewrite the example using the method:\n\nNow we got the same output by only 2 queries.\n\nWhat happened is told ActiveRecord to retrieve the corresponding records from the database immediately after the initial request for all . Since the records of were already in the memory, could be retrieved by only one query. Now, even if we have 10,000 posts in our database, we can execute the example code above by just 2 queries! This is a huge difference.\n\nFind the N+1 query problem with the Bullet Gem\n\nEven if you review your code carefully trying to eliminate N+1 queries from your application, errors can slip into production code. The Bullet Gem is a great tool to automate the process.\n\nThe Bullet gem is designed to help you increase your application's performance by reducing the number of queries it makes.\n\n It will watch your queries while you develop your application and notify you when you should add eager loading (N+1 queries), when you're using eager loading that isn't necessary and when you should use counter cache.\n\n >- Bullet Gem README https://github.com/flyerhzm/bullet\n\nAs your application gets bigger, you need to pay more attention to its speed and performance. Eager loading in Rails is really easy to implement but makes a big difference."
    }
]