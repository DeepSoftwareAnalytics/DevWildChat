[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random",
        "document": "The static method returns a floating-point, pseudo-random number that's greater than or equal to 0 and less than 1, with approximately uniform distribution over that range — which you can then scale to your desired range. The implementation selects the initial seed to the random number generation algorithm; it cannot be chosen or reset by the user. Note: does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the method.\n\nNote that as numbers in JavaScript are IEEE 754 floating point numbers with round-to-nearest-even behavior, the ranges claimed for the functions below (excluding the one for itself) aren't exact. Usually, the claimed upper bound is not attainable, but if returns a number very close to 1, the tiny difference may not be representable at the requested maximum, therefore causing the upper bound to be attained.\n\nGetting a random number between two values This example returns a random number between the specified values. The returned value is no lower than (and may possibly equal) , and is less than (and not equal) .\n\nGetting a random integer between two values This example returns a random integer between the specified values. The value is no lower than (or the next integer greater than if isn't an integer), and is less than (but not equal to) . function getRandomInt(min, max) { const minCeiled = Math.ceil(min); const maxFloored = Math.floor(max); return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive } Note: It might be tempting to use to accomplish that, but doing so would cause your random numbers to follow a non-uniform distribution, which may not be acceptable for your needs.\n\nGetting a random integer between two values, inclusive While the function above is inclusive at the minimum, it's exclusive at the maximum. What if you need the results to be inclusive at both the minimum and the maximum? The function below accomplishes that. function getRandomIntInclusive(min, max) { const minCeiled = Math.ceil(min); const maxFloored = Math.floor(max); return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled); // The maximum is inclusive and the minimum is inclusive }"
    },
    {
        "link": "https://stackoverflow.com/questions/33609404/node-js-how-to-generate-random-numbers-in-specific-range-using-crypto-randomby",
        "document": "To generate numbers in the range [55 .. 956], you first generate a random number in the range [0 .. 901] where 901 = 956 - 55. Then add 55 to the number you just generated.\n\nTo generate a number in the range [0 .. 901], pick off two random bytes and mask off 6 bits. That will give you a 10 bit random number in the range [0 .. 1023]. If that number is <= 901 then you are finished. If it is bigger than 901, discard it and get two more random bytes. Do not attempt to use MOD, to get the number into the right range, that will distort the output making it non-random.\n\nETA: To reduce the chance of having to discard a generated number.\n\nSince we are taking two bytes from the RNG, we get a number in the range [0 .. 65535]. Now 65535 MOD 902 is 591. Hence, if our two-byte random number is less than (65535 - 591), that is, less than 64944, we can safely use the MOD operator, since each number in the range [0 .. 901] is now equally likely. Any two-byte number >= 64944 will still have to be thrown away, as using it would distort the output away from random. Before, the chances of having to reject a number were (1024 - 901) / 1024 = 12%. Now the chances of a rejection are (65535 - 64944) / 65535 = 1%. We are far less likely to have to reject the randomly generated number."
    },
    {
        "link": "https://w3schools.com/js/js_random.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/71327425/best-choice-for-javascript-random-number-generator",
        "document": "The thing is - only software random number generators cannot provide true random numbers, only approximations to them. The standard JS way via is sufficient for most cases.\n\nThis can be improved a bit if you use the Crypto API. by Kamil Kiełczewski\n\nBut the purpose of the numbers is also important. Because both approaches produce consecutive equal numbers in the sequence. If you use random numbers to output dummy images in the prototype phase of a project, for example, you would have identical images one after the other, which you would rather avoid. For this purpose, good random numbers would be those without producing the same number twice in a row. This can only be done by storing the last number and recursion."
    },
    {
        "link": "https://reddit.com/r/learnjavascript/comments/11b10x5/how_bad_is_mathrandom",
        "document": "I was reading a thread on a post in one of the JS subs that was saying Math.random() isn't particularly good when it comes to making random numbers. Is it particularly bad? Are some use cases worse than others for using Math.random()? What are some ways to do it better?"
    },
    {
        "link": "https://stackoverflow.com/questions/12310837/implementation-of-luhn-algorithm",
        "document": "Lookup tables or arrays can simplify algorithm implementations - save many lines of code - and with that increase performance... if the calculation of the lookup index is simple - or simpler - and the array's memory footprint is affordable.\n\nOn the other hand, understanding how the particular lookup array or data structure came to be can at times be quite difficult, because the related algorithm implementation may look - at first sight - quite different from the original algorithm specification or description.\n\nIndication to use lookup tables are number oriented algorithms with simple arithmetics, simple comparisons, and equally structured repetition patterns - and of course - of quite finite value sets.\n\nThe many answers in this thread go for different lookup tables and with that for different algorithms to implement the very same Luhn algorithm. Most implementations use the lookup array to avoid the cumbersome figuring out of the value for doubled digits:\n\nAn equal implementation for getting the luhnFinalValue looks like this:\n\nWhich - with the comments in above true and false terms - is of course simplified:\n\nNow I'm not sure if I 'saved' anything at all... ;-) especially thanks the value-formed or short form of if-then-else. Without it, the code may look like this - with 'orderly' blocks and embedded in the next higher context layer of the algorithm and therefore luhnValue:\n\nBtw, with modern, optimizing interpreters and (just in time) compilers, the difference is only in the source code and matters only for readability.\n\nHaving come that far with explanation - and 'justification' - of the use of lookup tables and comparison to straight forward coding, the lookup table looks now a bit overkill to me. The algorithm without is now quite easy to finish - and it looks pretty compact too:\n\nWhat strikes me after going through the explanation exercise is that the initially most enticing implementation - the one using reduce() from @kalypto - just lost totally its luster for me... not only because it is faulty on several levels, but more so because it shows that bells and whistles may not always 'ring the victory bell'. But thank you, @kalypto, it made me actually use - and understand - reduce():\n\nTo be true to this thread, some more lookup table options have to be mentioned:\n• how about just adjust varues for doubled digits - as posted by @yngum\n• how about just everything with lookup tables - as posted by @Simon_Weaver - where also the values for the non-doubled digits are taken from a look up table.\n• how about just everything with just ONE lookup table - as inspired by the use of an offset as done in the extensively discussed luhnValid() function.\n\nThe code for the latter - using reduce - may look like this:\n\nAnd for closing lunValid4() - very compact - and using just 'old fashioned' (compatible) JavaScript - with one single lookup table:\n\nCorollar: Strings can be looked at as lookup tables of characters... ;-)\n\nA perfect example of a nice lookup table application is the counting of set bits in bits lists - bits set in a a (very) long 8-bit byte string in (an interpreted) high-level language (where any bit operations are quite expensive). The lookup table has 256 entries. Each entry contains the number of bits set in an unsigned 8-bit integer equal to the index of the entry. Iterating through the string and taking the unsigned 8-bit byte equal value to access the number of bits for that byte from the lookup table. Even for low-level language - such as assembler / machine code - the lookup table is the way to go... especially in an environment, where the microcode (instruction) can handle multiple bytes up to 256 or more in an (single CISC) instruction.\n• numberString * 1 and parseInt(numberStr) do about the same.\n• there are some superfluous indentations, parenthesis,etc... supporting my brain in getting the semantics quicker... but some that I wanted to leave out, are actually required... when it comes to arithmetic operations with short-form, value-if-then-else expressions as terms.\n• some formatting may look new to you; for examples, I use the continuation comma with the continuation on the same line as the continuation, and I 'close' things - half a tab - indented to the 'opening' item.\n• All formatting is all done for the human, not the computer... 'it' does care less."
    },
    {
        "link": "https://geeksforgeeks.org/luhn-algorithm",
        "document": "The Luhn algorithm, also known as the modulus 10 or mod 10 algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, Canadian Social Insurance Numbers. The LUHN formula was created in the late 1960s by a group of mathematicians. Shortly thereafter, credit card companies adopted it. Because the algorithm is in the public domain, it can be used by anyone. Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from mistyped or otherwise incorrect numbers. It was designed to protect against accidental errors, not malicious attacks.\n\nLet’s understand the algorithm with an example: \n\nConsider the example of an account number “79927398713“.\n\nStep 1 – Starting from the rightmost digit, double the value of every second digit,\n\nStep 2 – If doubling of a number results in a two digit number i.e greater than 9(e.g., 6 × 2 = 12), then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6), to get a single digit number.\n\nStep 3 – Now take the sum of all the digits.\n\nStep 4 – If the total modulo 10 is equal to 0 (if the total ends in zero) then the number is valid according to the Luhn formula; else it is not valid.\n\n\n\nSince the sum is 70 which is a multiple of 10, the account number is possibly valid.\n\nThe idea is simple; we traverse from the end. For every second digit, we double it before adding it. We add two digits of the number obtained after doubling.\n\nThe Luhn algorithm detects any single-digit error, as well as almost all transpositions of adjacent digits."
    },
    {
        "link": "https://github.com/TheDragonCode/card-number",
        "document": "Generation and verification of card numbers using Luhn's algorithm: credit, customer loyalty and others.\n\nTo get the latest version of , simply require the project using Composer:\n\nOr manually update block of and run console command.\n\nYou can validate any numbers with the Luhn algorithm with any input format.\n\nYou can validate bank card numbers. To do this, pass the card type as the second argument:\n\nYou can also check for invalid numbers:\n\nIn addition to numerical values, you can also validate number-letter combinations. For example:\n\nIn some cases there may not be enough built-in validators and therefore you can easily use your own. To do this, create a class and inherit it from the abstract , and then pass a reference to it in the parameter:\n\nYou can also easily generate any numbers using the Luhn algorithm:\n\nYou can also use the formatter to format the resulting value:\n\nYou can also create your own formatter. To do this, create a class and inherit it from the abstract class:\n\nAnd use this one:\n\nIn addition to numeric formatters, you can also use number-letter combinations. For example, using the formatter, you can generate a letter code instead of a numeric number, which will be valid when verified by the Luhn's algorithm:\n\nIn addition, you can specify factories as an incoming identifier parameter. In this way, you can form unique identification rules using fluent methods.\n\nThis is useful when, for example, you create a customer loyalty card number and want to specify in its number the year of issue as well as its level.\n\nIf you use the Laravel framework, you can also use the validation rule:\n\nYou can also check bank cards:\n\nThis package is licensed under the MIT License."
    },
    {
        "link": "https://medium.com/hootsuite-engineering/a-comprehensive-guide-to-validating-and-formatting-credit-cards-b9fa63ec7863",
        "document": "\n• The user can see at a glance whether they missed or added an extra character\n• It’s easier for the user to go back and change a digit in the case of typos\n\nThere are also a couple of UX goals we want to accomplish when adding auto-formatting:\n• We don’t want to disallow the user from typing spaces as they enter their card number\n• The user should be able to insert and remove digits before and after a formatted space\n• The cursor position should be retained when inserting and removing digits\n• When formatting is changed (ex. American Express → Visa), digits should be re-formatted to match the new layout\n\nWith those goals in mind, here are a couple of approaches to formatting cards:\n• many libraries to choose from\n• some are bulky and slow to load\n• many have bugs that are hard to fix without modifying the source\n• all give you less control over what’s happening\n\nHere are some of the input masking libraries I’ve tested:\n\nRegardless of the library used, the logic behind each implementation should be similar:\n\nHere’s an implementation of RobinHerbots’s Inputmask, which I believe to be the best library from the list above. Although it is significantly larger in size and comes with an array of unnecessary features, it allows user input of spaces, inserting/removing digits after spaces, and re-formatting of cards.\n\nHowever, the cursor position isn’t retained if the card is re-formatted. If you start out by entering an American Express number (ex. 3782 822463 10005), and then delete the 3 in the beginning, the card is re-formatted correctly but the cursor skips to the end.\n\nAlthough this isn’t that big of an issue, I wasn’t happy with it. It seemed that whatever library I used would miss out on at least one of the 4 goals. In the end, I got fed up and decided to implement my own input mask.\n\nI wanted my custom input mask to achieve all of the 4 goals while also retaining some quality of life features of input masking libraries, such as limiting the length. At its core, an input mask updates the current input value with the correctly formatted value.\n\nTo accomplish this, I created a function that takes in a card number and outputs the correctly formatted number. In this function, I also limit the length of the input depending on the card type:\n\nThe core functionality is achieved by a chain of methods. This allows for the card to be formatted as it is being typed. As such, we’re also not making use of the object that we defined earlier on. The RegEx is modified to match the IIN ranges of each issuer. For example, we can change the mask to 4–6–5 as soon as 34 or 37 is entered (American Express). Furthermore, for the cards that we support, only American Express (15 digits) and Diner’s Club (14 digits) require special formatting.\n\nWe can then update our input to reflect the formatted value:\n\nFor 25 lines of code, this isn’t too bad. It allows user-input of spaces and re-formats credit card numbers. However, deleting any digit or inserting a digit before a space will move the cursor to the end. You also can’t delete spaces.\n\nAll of these bugs happen because updating the value of an input will move the cursor to the end. We can fix this by storing the cursor position and then updating it. There are also two blocks here that adjust the cursor position to allow for the removal of spaces and the insertion of digits before a space.\n\nPerfect! Now users can type spaces as they’re entering their card number, insert/remove digits before and after a formatted space, retain the cursor position when a digit is inserted or removed, and, when formatting is changed, re-format the card while preserving the cursor position."
    },
    {
        "link": "https://mihnea.hashnode.dev/how-to-generate-credit-card-numbers",
        "document": ""
    }
]