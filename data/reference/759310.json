[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing.bitmap?view=windowsdesktop-9.0",
        "document": "The following code example demonstrates how to construct a new Bitmap from a file, using the GetPixel and SetPixel methods to recolor the image. It also uses the PixelFormat, Width, and Height properties.\n\nThis example is designed to be used with a Windows Forms that contains a Label, PictureBox, and Button named , , and , respectively. Paste the code into the form and associate the method with the button's Click event.\n\nA bitmap consists of the pixel data for a graphics image and its attributes. There are many standard formats for saving a bitmap to a file. GDI+ supports the following file formats: BMP, GIF, EXIF, JPG, PNG, and TIFF. For more information about supported formats, see Types of Bitmaps.\n\nYou can create images from files, streams, and other sources by using one of the Bitmap constructors and save them to a stream or to the file system with the Save method. Images are drawn to the screen or to memory by using the DrawImage method of the Graphics object. For a list of topics about working with image files, see Working with Images, Bitmaps, Icons, and Metafiles."
    },
    {
        "link": "https://stackoverflow.com/questions/57473121/c-sharp-bitmap-screenshot-size",
        "document": "This is an interesting puzzle.\n\nIt consists of three questions:\n• Why do the numbers change for the stream?\n• Why do the numbers change for the byte array?\n• Why do the numbers for stream and array differ?\n\nAny compression result will depend on content; even slight changes, like a moving clock hand or an additional line in the the VS output pane will make some difference..\n\nLet's add another result, this time for and with a constant screen content:\n\nNow we can conclude:\n• None The stream numbers differ as long as we don't make sure that either the screen content won't change or we use a non-compressed format like . We must hide the output pane, disable any clocks with a seond hand etc..\n• None The array numbers differ as long as the screen content changes\n• The stream and array numbers are the same when we store as .\n\nFrom this we can conclude that stores images compressed as byte arrays in the format; this is nice as it saves memory. MSDN doesn't document it, though. (They probably don't want to guarantee this..)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/gdi/capturing-an-image",
        "document": "You can use a bitmap to capture an image, and you can store the captured image in memory, display it at a different location in your application's window, or display it in another window.\n\nIn some cases, you may want your application to capture images and store them only temporarily. For example, when you scale or zoom a picture created in a drawing application, the application must temporarily save the normal view of the image and display the zoomed view. Later, when the user selects the normal view, the application must replace the zoomed image with a copy of the normal view that it temporarily saved.\n\nTo store an image temporarily, your application must call CreateCompatibleDC to create a DC that is compatible with the current window DC. After you create a compatible DC, you create a bitmap with the appropriate dimensions by calling the CreateCompatibleBitmap function and then select it into this device context by calling the SelectObject function.\n\nAfter the compatible device context is created and the appropriate bitmap has been selected into it, you can capture the image. The BitBlt function captures images. This function performs a bit block transfer that is, it copies data from a source bitmap into a destination bitmap. However, the two arguments to this function are not bitmap handles. Instead, BitBlt receives handles that identify two device contexts and copies the bitmap data from a bitmap selected into the source DC into a bitmap selected into the target DC. In this case, the target DC is the compatible DC, so when BitBlt completes the transfer, the image has been stored in memory. To redisplay the image, call BitBlt a second time, specifying the compatible DC as the source DC and a window (or printer) DC as the target DC.\n\nThis section contains a code example that captures an image of the entire desktop, scales it down to the current window size, and then saves it to a file (as well as displaying it in the client area).\n\nTo try out the code example, begin by creating a new project in Visual Studio based on the Windows Desktop Application project template. It's important to name the new project so that the code listing below will compile (for example, it includes , which will exist in your new project if you name it as suggested).\n\nOpen the source code file in your new project, and replace its contents with the listing below. Then build and run. Each time you resize the window, you'll see the captured screenshot displayed in the client area."
    },
    {
        "link": "https://cyotek.com/blog/capturing-screenshots-using-csharp-and-p-invoke",
        "document": "Capturing screenshots using C# and p/invoke\n\nI was recently updating some documentation and wanted to programmatically capture some screenshots of the application in different states. This article describes how you can easily capture screenshots in your own applications.\n\nThis article makes use of a number of Win32 API methods. Although you may not have much call to use them directly in day to day .NET (not to mention Microsoft wanting everyone to use universal \"apps\" these days), they are still extraordinarily useful and powerful.\n\nThis article does assume you know the basics of platform invoke so I won't cover it here. In regards to the actual API's I'm using, you can find lots of information about them either on MSDN, or PInvoke.net.\n\nA number of the API's used in this article are GDI calls. Generally, when you're using the Win32 GDI API, you need to do things in pairs. If something is created (pens, brushes, bitmaps, icons etc.), then it usually needs to be explicitly destroyed when finished with (there are some exceptions just to keep you on your toes). Although there haven't been GDI limits in Windows for some time now (as far as I know!), it's still good not to introduce memory leaks. In addition, device contexts always have a number of objects associated with them. If you assign a new object to a context, you must restore the original object when you're done. I'm a little rusty with this so hopefully I'm not missing anything out.\n\nSetting up a device context for use with BitBlt\n\nTo capture a screenshot, I'm going to be using the API. This copies information from one device context to another, meaning I'm going to need a source and destination context to process.\n\nThe source is going to be the desktop, so first I'll use the and calls to obtain this. As calling essentially places a lock on it, I also need to release it when I'm finished with it.\n\nNow for the destination - for this, I'm going to create a memory context using . When you call this API, you pass in an existing DC and the new one will be created based on that.\n\nThere's still one last step to perform - by itself, that memory DC isn't hugely useful. We need to create and assign a GDI bitmap to it. To do this, first create a bitmap using and then attach it to the DC using . will also return the relevant old object which we need to restore (again using ) when we're done. We also use to clean up the bitmap.\n\nAlthough this might seem like a lot of effort, it's not all that different from using objects implementing in C#, just C# makes it a little easier with things like the statement.\n\nWith the above setup out the way, we have a device context which provides access to a bitmap of the desktop, and we have a new device context ready to transfer data to. All that's left to do is make the call.\n\nIf you've ever used the method of a object before, this call should be fairly familiar - we pass in the DC to write too, along with the upper left corner where data will be copied ( in this example), followed by the and of the rectangle - this applies to both the source and destination. Finally, we pass in the source device context, and the upper left corner where data will be copied from, along with flags that detail how the data will be copied.\n\nIn my old VB6 days, I would just use (direct copy), but in those days windows were simpler things. The flag ensures the call works properly with layered windows.\n\nIf the call fails, I throw a new object without any parameters - this will take care of looking up the result code for the failure and filling in an appropriate message.\n\nNow that our destination bitmap has been happily \"painted\" with the specified region from the desktop we need to get it into .NET-land. We can do this via the static method of the class - this method accepts a GDI bitmap handle and return a fully fledged .NET object from it.\n\nPutting it all together\n\nAs the above code is piecemeal, the following helper method will accept a which describes which part of the desktop you want to capture and will then return a object containing the captured information.\n\nNow that we have this method, we can use it in various ways as demonstrated below.\n\nIf you want to capture a window in your application, you could call with the value of the property of your . But if you want to capture an external window then you're going to need to go back to the Win32 API. The function will return any window's boundaries.\n\nWin32 has its own version of .NET's structure, named . This differs slightly from the .NET version in that it has and properties, not and . The class has a helper method, which constructs a from left, top, right and bottom properties which means you don't need to perform the subtraction yourself.\n\nAs a slight variation on the previous section, you can use the API call to get the handle of the active window.\n\n.NET offers the static class which provides access to all monitors on your system via the property. You can use the method to find out which monitor a form is hosted on, and get the region that represents the monitor - with or without areas covered by the task bar and other app bars. This means it trivial to capture the contents of a given monitor.\n\nIt is also quite simple to capture the entire desktop without having to know all the details of monitor arrangements. We just need to enumerate the available monitors and use to merge two rectangles together. When this is complete, you'll have one rectangle which describes all available monitors.\n\nOf course, you could just call with a custom rectangle to pick up some arbitrary part of the desktop. The above helpers are just that, helpers!\n\nAlthough I don't have a high DPI monitor, I did temporarily scale the display to 125% to test that the correct regions were still captured. I tested with a manifest stating that the application supported high DPI and again without, in both cases the correct sized images were captured.\n\nA demonstration program for the techniques in this article is available from the links below. It's also available on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/45968878/take-screenshot-and-show-it-in-form",
        "document": "A object is a sort of wrapper around an image that lets you draw on the image. They are usually temporary, and don't actually own the pixels that you're drawing.\n\nIn your case, is just providing the ability to draw onto , which is where the image actually lives in memory.\n\nYou should throw away the and return the :\n\nThen you can assign the bitmap to a :"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/input-keyboard/how-to-simulate-events?view=netdesktop-9.0",
        "document": "Windows Forms provides a few options for programmatically simulating keyboard input. This article provides an overview of these options.\n\nWindows Forms provides the System.Windows.Forms.SendKeys class for sending keystrokes to the active application. There are two methods to send keystrokes to an application: SendKeys.Send and SendKeys.SendWait. The difference between the two methods is that blocks the current thread when the keystroke is sent, waiting for a response, while doesn't. For more information about , see To send a keystroke to a different application.\n\nBehind the scenes, uses an older Windows implementation for sending input, which may fail on modern Windows where it's expected that the application isn't running with administrative rights. If the older implementation fails, the code automatically tries the newer Windows implementation for sending input. Additionally, when the SendKeys class uses the new implementation, the SendWait method no longer blocks the current thread when sending keystrokes to another application.\n\nIf your application relies on consistent behavior regardless of the operating system, you can force the SendKeys class to use the new implementation by adding the following application setting to your app.config file. To force the SendKeys class to only use the previous implementation, use the value instead.\n\nTo send a keystroke to the same application\n\nCall the SendKeys.Send or SendKeys.SendWait method of the SendKeys class. The specified keystrokes will be received by the active control of the application.\n\nThe following code example uses to simulate pressing the and keys together. These keystrokes cause the ComboBox control to display its dropdown. This example assumes a Form with a Button and ComboBox.\n\nTo send a keystroke to a different application\n\nThe SendKeys.Send and SendKeys.SendWait methods send keystrokes to the active application, which is usually the application you're sending keystrokes from. To send keystrokes to another application, you first need to activate it. Because there's no managed method to activate another application, you must use native Windows methods to focus the other application. The following code example uses platform invoke to call the and methods to activate the Calculator application window, and then calls to issue a series of calculations to the Calculator application.\n\nThe following code example uses to simulate pressing keys into the Windows 10 Calculator application. It first searches for an application window with title of and then activates it. Once activated, the keystrokes are sent to calculate 10 plus 10.\n\nThe easiest way to simulate keyboard events is to call a method on the object that raises the event. Most events have a corresponding method that invokes them, named in the pattern of followed by , such as . This option is only possible within custom controls or forms, because these methods are protected and can't be accessed from outside the context of the control or form.\n\nThese protected methods are available to simulate keyboard events.\n\nFor more information about these events, see Using keyboard events (Windows Forms .NET).\n• Overview of using the keyboard (Windows Forms .NET)"
    },
    {
        "link": "https://stackoverflow.com/questions/20482338/simulate-keyboard-input-in-c-sharp",
        "document": "I like @Gareth's approach at it. However, in his method, you need to hard code your key strokes into the SendInputWithAPI() method. I made a few changes to the code; you now can call Send() and pass ScanCodeShort parameter to it. This allows you to pass any keystroke to it, any time, any place."
    },
    {
        "link": "https://learn.microsoft.com/en-gb/dotnet/desktop/winforms/how-to-simulate-mouse-and-keyboard-events-in-code?view=netframeworkdesktop-4.8",
        "document": "How to: Simulate Mouse and Keyboard Events in Code\n\nWindows Forms provides several options for programmatically simulating mouse and keyboard input. This topic provides an overview of these options.\n\nThe best way to simulate mouse events is to call the EventName method that raises the mouse event you want to simulate. This option is usually possible only within custom controls and forms, because the methods that raise events are protected and cannot be accessed outside the control or form. For example, the following steps illustrate how to simulate clicking the right mouse button in code.\n\nTo programmatically click the right mouse button\n• None Create a MouseEventArgs whose Button property is set to the MouseButtons.Right value.\n• None Call the OnMouseClick method with this MouseEventArgs as the argument.\n\nFor more information on custom controls, see Developing Windows Forms Controls at Design Time.\n\nThere are other ways to simulate mouse input. For example, you can programmatically set a control property that represents a state that is typically set through mouse input (such as the Checked property of the CheckBox control), or you can directly call the delegate that is attached to the event you want to simulate.\n\nAlthough you can simulate keyboard input by using the strategies discussed above for mouse input, Windows Forms also provides the SendKeys class for sending keystrokes to the active application.\n\nThe SendKeys class has been updated for the .NET Framework 3.0 to enable its use in applications that run on Windows Vista. The enhanced security of Windows Vista (known as User Account Control or UAC) prevents the previous implementation from working as expected. The SendKeys class is susceptible to timing issues, which some developers have had to work around. The updated implementation is still susceptible to timing issues, but is slightly faster and may require changes to the workarounds. The SendKeys class tries to use the previous implementation first, and if that fails, uses the new implementation. As a result, the SendKeys class may behave differently on different operating systems. Additionally, when the SendKeys class uses the new implementation, the SendWait method will not wait for messages to be processed when they are sent to another process. If your application relies on consistent behavior regardless of the operating system, you can force the SendKeys class to use the new implementation by adding the following application setting to your app.config file. To force the SendKeys class to use the previous implementation, use the value instead.\n\nTo send a keystroke to the same application\n• None Call the Send or SendWait method of the SendKeys class. The specified keystrokes will be received by the active control of the application. The following code example uses Send to simulate pressing the ENTER key when the user double-clicks the surface of the form. This example assumes a Form with a single Button control that has a tab index of 0. // Send a key to the button when the user double-clicks anywhere // on the form. private: void Form1_DoubleClick(Object^ sender, EventArgs^ e) { // Send the enter key to the button, which triggers the click // event for the button. This works because the tab stop of // the button is 0. SendKeys::Send(\"{ENTER}\"); } // Send a key to the button when the user double-clicks anywhere // on the form. private void Form1_DoubleClick(object sender, EventArgs e) { // Send the enter key to the button, which raises the click // event for the button. This works because the tab stop of // the button is 0. SendKeys.Send(\"{ENTER}\"); } ' Send a key to the button when the user double-clicks anywhere ' on the form. Private Sub Form1_DoubleClick(ByVal sender As Object, _ ByVal e As EventArgs) Handles Me.DoubleClick ' Send the enter key to the button, which raises the click ' event for the button. This works because the tab stop of ' the button is 0. SendKeys.Send(\"{ENTER}\") End Sub\n\nTo send a keystroke to a different application\n• None Activate the application window that will receive the keystrokes, and then call the Send or SendWait method. Because there is no managed method to activate another application, you must use native Windows methods to force focus on other applications. The following code example uses platform invoke to call the and methods to activate the Calculator application window, and then calls SendWait to issue a series of calculations to the Calculator application. The correct parameters of the call that locates the Calculator application vary based on your version of Windows. The following code finds the Calculator application on Windows 7. On Windows Vista, change the first parameter to \"SciCalc\". You can use the Spy++ tool, included with Visual Studio, to determine the correct parameters. // Get a handle to an application window. public: [DllImport(\"USER32.DLL\", CharSet = CharSet::Unicode)] static IntPtr FindWindow(String^ lpClassName, String^ lpWindowName); public: // Activate an application window. [DllImport(\"USER32.DLL\")] static bool SetForegroundWindow(IntPtr hWnd); // Send a series of key presses to the Calculator application. private: void button1_Click(Object^ sender, EventArgs^ e) { // Get a handle to the Calculator application. The window class // and window name were obtained using the Spy++ tool. IntPtr calculatorHandle = FindWindow(\"CalcFrame\", \"Calculator\"); // Verify that Calculator is a running process. if (calculatorHandle == IntPtr::Zero) { MessageBox::Show(\"Calculator is not running.\"); return; } // Make Calculator the foreground application and send it // a set of calculations. SetForegroundWindow(calculatorHandle); SendKeys::SendWait(\"111\"); SendKeys::SendWait(\"*\"); SendKeys::SendWait(\"11\"); SendKeys::SendWait(\"=\"); } // Get a handle to an application window. [DllImport(\"USER32.DLL\", CharSet = CharSet.Unicode)] public static extern IntPtr FindWindow(string lpClassName, string lpWindowName); // Activate an application window. [DllImport(\"USER32.DLL\")] public static extern bool SetForegroundWindow(IntPtr hWnd); // Send a series of key presses to the Calculator application. private void button1_Click(object sender, EventArgs e) { // Get a handle to the Calculator application. The window class // and window name were obtained using the Spy++ tool. IntPtr calculatorHandle = FindWindow(\"CalcFrame\",\"Calculator\"); // Verify that Calculator is a running process. if (calculatorHandle == IntPtr.Zero) { MessageBox.Show(\"Calculator is not running.\"); return; } // Make Calculator the foreground application and send it // a set of calculations. SetForegroundWindow(calculatorHandle); SendKeys.SendWait(\"111\"); SendKeys.SendWait(\"*\"); SendKeys.SendWait(\"11\"); SendKeys.SendWait(\"=\"); } ' Get a handle to an application window. Declare Auto Function FindWindow Lib \"USER32.DLL\" ( _ ByVal lpClassName As String, _ ByVal lpWindowName As String) As IntPtr ' Activate an application window. Declare Auto Function SetForegroundWindow Lib \"USER32.DLL\" _ (ByVal hWnd As IntPtr) As Boolean ' Send a series of key presses to the Calculator application. Private Sub button1_Click(ByVal sender As Object, _ ByVal e As EventArgs) Handles button1.Click ' Get a handle to the Calculator application. The window class ' and window name were obtained using the Spy++ tool. Dim calculatorHandle As IntPtr = FindWindow(\"CalcFrame\", \"Calculator\") ' Verify that Calculator is a running process. If calculatorHandle = IntPtr.Zero Then MsgBox(\"Calculator is not running.\") Return End If ' Make Calculator the foreground application and send it ' a set of calculations. SetForegroundWindow(calculatorHandle) SendKeys.SendWait(\"111\") SendKeys.SendWait(\"*\") SendKeys.SendWait(\"11\") SendKeys.SendWait(\"=\") End Sub\n\nThe following code example is the complete application for the previous code examples.\n• References to the System, System.Drawing and System.Windows.Forms assemblies."
    },
    {
        "link": "https://stackoverflow.com/questions/3047375/simulating-key-press-c-sharp",
        "document": "You can use the Win32 API or FindWindowEx to find the window handle of the open browser and then just call SendMessage with WM_KEYDOWN. Typically it's easiest just to pass the window caption to and have it find the associated window handle for you.\n\nIf you are starting the browser process yourself via a object then you can use instead of calling .\n\nSpy++ is a very useful tool when you want to start working with other windows. It basically allows you to learn another program's hierarchy of UI elements. You can also monitor all of the messages that go into the window you're monitoring. I have more info in this thread.\n\nThe F5 keystroke has this virtual key code:\n\nThe p/invoke signature for in C# is:\n\nYou can p/invoke (bring in) the Win32 API like this:\n\nSo to recap, you call directly from your C# code after having the above code somewhere inside your class. will return a window handle. Then once you have the window handle, you can send any keystroke(s) to the window, or call many other Win32 API calls on the window handle. Or even find a child window by using another call to . For example you could select the edit control of the browser even and then change it's text.\n\nIf all else goes wrong and you think you're sending the right key to the window, you can use to see what messages are sent to the window when you manually set focus to the browser and manually press ."
    },
    {
        "link": "https://devindeep.com/how-to-send-keys-to-another-application-using-c",
        "document": "Today we are going to cover the topic on how to send keys to another application using C#.\n\nFull Source Code is available at:\n\nThis guide is a continuation on our previous post. Last week we were talking about how to get the active window using C#. This time around we are going to send commands and keystrokes to an external application.\n\nAs a result, the user will be able to connect their custom C# application to another one. Or simply put, take control over it.\n\nIf you need a refresher on the subject, please follow this tutorial first.\n\nOr, you can continue on the next segment here.\n• How to Scrape Web Page using C#\n• Face Mask Detection using ML.NET Model Builder and C#\n• How to implement Text Detection with C#\n\nIf you already know how to import the “User32.dll” and obtain the current active window, then you are all set to continue from here.\n\nFor the purposes of this demo, we are going to reuse the code from the ActiveWindowWatcher class.\n\nIn this second part, we are going to send keys to another application. Once we have the current active window, then we can send keystrokes or commands to it.\n\nAs an example, I am going to use Notepad. It’s perfect to demonstrate this demo. We can send different commands to open a file, or we can send a shortcut to close the application all together. However, Notepad also allows us to write custom text as well. So, we will connect our own text field to Notepad, and anything we write inside of it, it will be displayed there.\n\nFirst things first. We are going to open Notepad. Then, we will obtain the handle of the main window. And afterwards, we are going to take control over the app from our C# code. We will send commands, for example Ctrl + O, Alt + F4 or send keyboard keystrokes. It will look just like the user is performing these operations through their physical keyboard.\n\nOur Windows Forms C# application will control the work of Notepad. So, let’s see how we can achieve this. Remember this is all part of the Virtual Keyboard series that we are working towards.\n\nIn the first post we learned how to obtain the current active window. Now, we are going to learn how to send keys to another application (current active window). Basically, we are building a virtual keyboard. Because, that’s what a virtual keyboard does. It sends keystrokes to the currently active application/window.\n\nBut, let’s not be hasty. Let’s take each step as it comes. We are going to do one thing at a time. Let’s send keystrokes to another application first.\n\nThis is the demo application we are going to build. It is a standard Windows Forms, C# project. Once, the application is started it is running an instance of ActiveWindowWatcher.\n\nIf you don’t have the code for this class, you can download it from here. Also make sure to check out the tutorial.\n\nWhat this class does, is it captures the current active window every second. By clicking on the button Lock Window it will retrieve the current active windows application and save the Title and Handle of the window.\n\nIn our case, the app captured the Window Handle and Window Title of Notepad. It was able to do that via the ActiveWindowChanged event. This event is raised every time when a different window is active (comes into focus).\n\nHere is the code for handling the event\n\nactiveWindow is a field inside the Form class that holds information about the current active application. So every time the focused application changes, this field will too.\n\nBy now, we have already obtained the active window. In our case, that would be the Notepad Application Window. Now it’s time to send some commands and/or keystrokes.\n\nBut, before we do that, let’s see what else do we need.\n• Learn ML.NET from start to finish using C#\n\nIn order to send keys to another application we need to obtain the main window handle. This is needed because, when we click on our application form, we are the ones getting the focus. As a result, the send keys function would send keystrokes to our app. And we don’t want that. So, when we click on a button hosted by our application, we would need to activate the window we want to send the keys to.\n\nTo do that we need to use the SetForegroundWindow function. According to the MSDN documentation, this User32.dll method, brings the thread that created the specified window into the foreground and activates the window. As a result, keyboard input is directed to the window, and various visual cues are changed for the user.\n\nThis is exactly what we need. When user press a button on our application, we are going to send keys to a particular window. But then, we also need the focus back on our application, in case we want to continue on sending keystrokes. This might not be the best explanation, but bare with me. Run the demo and you will see what I am talking about.\n\nSo, let’s declare the SetForegroundWindow function in our WindowAPI.cs.\n\nIn this code block, we are importing SetForegroundWindow. You should always wrap these methods inside another one that is public, and that the client code can call. It is a good practice to wrap these methods into your own custom ones, because then you can handle any exception that comes your way. But, you can also use your own user defined types if needed. However, this is just an example, and we are not going to dig deep into best practices for this current scenario.\n\nThe SendKeys method is part of the System.Windows.Forms namespace. Please note that this can be used from Windows Forms or WPF. But, in the case of WPF applications, you do need to reference the System.Windows.Forms library. And you would also need to use the SendWait method instead of Send.\n\nWe are going to use WPF to build the Virtual Keyboard, so this change will be demonstrated in the next post.\n\nSend Keys method is described as: Sends keystrokes to the active application. This is what we need, so let’s see how to use it. What follows is the C# implementation of the method\n\nIn our WindowAPI.cs class we implement the SendKeys method. It takes a window handle which points to the main window of the application we want to send keys to.\n\nPlease note that in the definition of SendKeys method it says that the function sends keystrokes to the active application. This means that before we send the keys to the other application we must first activate its main window.\n\nWe do that by using the SetForegroundWindow method by providing the Window Handle of the Application we want to focus on. If the window is in focus then we simply use SendKeys.Send(key_to_send).\n\nThere is one more override of this function. Here is the C# code for it:\n\nThis C# code block simply handles situations when user has pressed Ctrl or Alt.\n\nThe plus sign (+), caret (^), percent sign (%), tilde (~), and parentheses () have special meanings to SendKeys. To specify one of these characters, enclose it within braces ({})\n\nWe can use this function when we want to execute Ctrl + O or Alt + F4 commands on the another application.\n\nSend Keys to Another Application C#\n\nLet’s now look at the code behind the Send button\n\nIt is important to note, that the send button only sends commands to the active application. As you can see we still provide the window handle of the active application main window, but we also provide other information as well.\n\nThe second parameter, signals the method if the user has Control or Ctrl key/button active. The third parameter, signals if the Alt key is checked. Finally, we are sending the letter key code.\n\nIt may look a little bit weird how this code is wired up, but be patient. This examples leads us one step closer to building a proper virtual keyboard.\n\nThe idea behind this example is to see how we can execute shortcut commands. They should simulate the user pressing keyboard buttons such as: Ctrl + O, Ctrl + A, Alt + F4 and so on.\n\nThe next C# code we are going to review is the one behind the KeyPress event handler of the text box.\n\nWe want to be able to send any key stroke the user enters into our text field to Notepad. That is why we are handling KeyPress event.\n\nThis KeyPress event occurs when a character, space or backspace key is pressed while the control has the focus.\n\nOnce a Key Press event is dispatched on our main window under the text box control, we are sending that key to the active application. In our example that is Notepad. Notepad, will identify this as a user typing on the keyboard as well. Thus, it will display the characters we are inserting in our text box.\n\nThe second line of the code activates or puts focus back on our window. Because, if you remember, when sending keys to another application, the main window of that app must come into focus. So, if we focus there we will loose focus on our window, and thus we will loose focus of our text box control. As a result, right after we send the keys to Notepad, we are going to put the focus back on our main window. This will allow the user to continue typing.\n\nThe problem with this scenario is the constant window flickering. Or the constant focus transfer from one window to another. It’s distracting. This could put you off a little, but there is a solution. We will resolve this problem in our next and probably final post of these series.\n\nHow to detect File Content Change using C# – CODE-AI (devindeep.com)\n\nIn this article we saw How to Send Keys to Another Application in C#. Knowing how to use the Windows API and how to get the active window, combine it with the Send Keys functionality we described today, puts us very close to building a Virtual Keyboard.\n\nThere is one more thing to improve. And that is the constant flicking or focus transferring between applications. We will cover the issue and the fix in our next post."
    },
    {
        "link": "https://stackoverflow.com/questions/16338485/simulating-mouse-events-c-sharp",
        "document": "I'm trying to create a windows forms program which makes the computer act as if I pressed a mouse-button. I want to control the events manually (timing is not decided in advance) and it needs to possible to press and hold, so the mouse-button release should be a separate event.\n\nThe following information should not change the code, just help you further understand my situation:\n• The purpose is to allow user input from a Xbox 360 controller (compatible with PC) to steer/control the computer that it is connected to.\n• The best solution that I have so far found is the \"Windows.Forms.SendKeys\" method but it only works for keyboard events."
    },
    {
        "link": "https://stackoverflow.com/questions/16174834/simulate-mouse-events",
        "document": "I'm trying to simulate a mouse move using the following code:\n\nIt works fine, but the X and Y coordinates start from my current cursor position. Is there a way I can make them start at the upper left of my screen?\n\nI'm working in a Windows form app using c#\n\nIf you have no clue of what I'm asking, I tried to draw it for you;"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-mouse_event",
        "document": "Controls various aspects of mouse motion and button clicking. This parameter can be certain combinations of the following values.\n\nThe values that specify mouse button status are set to indicate changes in status, not ongoing conditions. For example, if the left mouse button is pressed and held down, MOUSEEVENTF_LEFTDOWN is set when the left button is first pressed, but not for subsequent motions. Similarly, MOUSEEVENTF_LEFTUP is set only when the button is first released.\n\nYou cannot specify both MOUSEEVENTF_WHEEL and either MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP simultaneously in the dwFlags parameter, because they both require use of the dwData field.\n\nThe mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of MOUSEEVENTF_ABSOLUTE. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of mickeys moved. A mickey is the amount that a mouse has to move for it to report that it has moved.\n\nThe mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of MOUSEEVENTF_ABSOLUTE. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of mickeys moved.\n\nIf dwFlags contains MOUSEEVENTF_WHEEL, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120.\n\nIf dwFlags contains MOUSEEVENTF_HWHEEL, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.\n\nIf dwFlags contains MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP, then dwData specifies which X buttons were pressed or released. This value may be any combination of the following flags.\n\nIf dwFlags is not MOUSEEVENTF_WHEEL, MOUSEEVENTF_XDOWN, or MOUSEEVENTF_XUP, then dwData should be zero.\n\nAn additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.\n\nIf the mouse has moved, indicated by MOUSEEVENTF_MOVE being set, dx and dy hold information about that motion. The information is specified as absolute or relative integer values.\n\nIf MOUSEEVENTF_ABSOLUTE value is specified, dx and dy contain normalized absolute coordinates between 0 and 65,535. The event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the upper-left corner of the display surface, (65535,65535) maps onto the lower-right corner.\n\nIf the MOUSEEVENTF_ABSOLUTE value is not specified, dx and dy specify relative motions from when the last mouse event was generated (the last reported position). Positive values mean the mouse moved right (or down); negative values mean the mouse moved left (or up).\n\nRelative mouse motion is subject to the settings for mouse speed and acceleration level. An end user sets these values using the Mouse application in Control Panel. An application obtains and sets these values with the SystemParametersInfo function.\n\nThe system applies two tests to the specified relative mouse motion when applying acceleration. If the specified distance along either the x or y axis is greater than the first mouse threshold value, and the mouse acceleration level is not zero, the operating system doubles the distance. If the specified distance along either the x- or y-axis is greater than the second mouse threshold value, and the mouse acceleration level is equal to two, the operating system doubles the distance that resulted from applying the first threshold test. It is thus possible for the operating system to multiply relatively-specified mouse motion along the x- or y-axis by up to four times.\n\nOnce acceleration has been applied, the system scales the resultant value by the desired mouse speed. Mouse speed can range from 1 (slowest) to 20 (fastest) and represents how much the pointer moves based on the distance the mouse moves. The default value is 10, which results in no additional modification to the mouse motion.\n\nThe mouse_event function is used to synthesize mouse events by applications that need to do so. It is also used by applications that need to obtain more information from the mouse than its position and button state. For example, if a tablet manufacturer wants to pass pen-based information to its own applications, it can write a DLL that communicates directly to the tablet hardware, obtains the extra information, and saves it in a queue. The DLL then calls mouse_event with the standard button and x/y position data, along with, in the dwExtraInfo parameter, some pointer or index to the queued extra information. When the application needs the extra information, it calls the DLL with the pointer or index stored in dwExtraInfo, and the DLL returns the extra information."
    },
    {
        "link": "https://pinvoke.net/default.aspx/user32.mouse_event",
        "document": "Type a page name and press Enter. You'll jump to the page if it exists, or you can create it if it doesn't.\n\n To create a page in a module other than user32, prefix the name with the module name and a period. This function is useful to simulate mouse buttons and wheel event to screen. <DllImport(\"user32.dll\")> _\n\n Private Shared Sub mouse_event(dwFlags As UInteger, dx As UInteger, dy As UInteger, dwData As UInteger, dwExtraInfo As Integer)\n\n End Sub\n\n \n\n Public Declare Sub mouse_event Lib \"user32\" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal dwData As Long, ByVal dwExtraInfo As Long)\n\n \n\n Note that for non-relative mouse movement (i.e. if MOUSEEVENTF_ABSOLUTE is not specified as part of dwFlags), negative values for dx and dy are desirable. As such, the \"uint\" type specification for C# can be safely replaced with Int32. [Flags]\n\n public enum MouseEventFlags : uint\n\n {\n\n LEFTDOWN = 0x00000002,\n\n LEFTUP = 0x00000004,\n\n MIDDLEDOWN = 0x00000020,\n\n MIDDLEUP = 0x00000040,\n\n MOVE = 0x00000001,\n\n ABSOLUTE = 0x00008000,\n\n RIGHTDOWN = 0x00000008,\n\n RIGHTUP = 0x00000010,\n\n WHEEL = 0x00000800,\n\n XDOWN = 0x00000080,\n\n XUP = 0x00000100\n\n }\n\n \n\n //Use the values of this enum for the 'dwData' parameter\n\n //to specify an X button when using MouseEventFlags.XDOWN or\n\n //MouseEventFlags.XUP for the dwFlags parameter.\n\n public enum MouseEventDataXButtons : uint\n\n {\n\n XBUTTON1 = 0x00000001,\n\n XBUTTON2 = 0x00000002\n\n }\n\n \n\n This function does indeed return a value, just as the keybd_event API does. If there is a real error, it will in fact return a value of false, or zero. The dwExtraInfo appears to be a ULONG_PTR in C++ (IntPtr in VB.NET) Declare Function apimouse_event Lib \"user32.dll\" Alias \"mouse_event\" (ByVal dwFlags As Int32, ByVal dX As Int32, ByVal dY As Int32, ByVal cButtons As Int32, ByVal dwExtraInfo As Int32) As Boolean\n\n \n\n FYI, Microsoft tells us for \"Windows NT/2000/XP: This function has been superseded. Use SendInput instead.\" The C# code below works fine. However you have to keep in mind to add the namespace \"System.Runtime.InteropServices\" and keep in mind to write the code into a class. I wanted to emulate the scroll. Searching for this information wasn't easy ... but here is how you do the mouse scroll button ScrollValue = 120 'or -120 for up or down scrolling The scroll value can actually be any value larger than 1, if used within a loop. This allows you to smoothly increment the scrollbar, instead of relying on the inconsistent wheel delta, which is a variable limited by the user, for mouse wheel. Start-Control Panel-Mouse-Wheel-Scrolling using System;\n\n using System.Collections.Generic;\n\n using System.Drawing;\n\n using System.Text;\n\n using System.Windows.Forms;\n\n \n\n using System.Runtime.InteropServices;\n\n using System.Threading;\n\n \n\n namespace PInvoke_DllImport_Cs\n\n {\n\n public partial class Form1 : Form\n\n {\n\n public Form1()\n\n {\n\n InitializeComponent();\n\n }\n\n \n\n const uint MOUSEEVENTF_LEFTDOWN = 0x0002;\n\n const uint MOUSEEVENTF_LEFTUP = 0x0004;\n\n \n\n [DllImport(\"user32.dll\")]\n\n private static extern void mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, int dwExtraInfo);\n\n \n\n private void timer1_Tick(System.Object sender, System.EventArgs e)\n\n {\n\n mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);\n\n Thread.Sleep(100);\n\n mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);\n\n }\n\n }\n\n }\n\n \n\n ' Clicks left mouse button in current coordinates\n\n \n\n Imports System.Runtime.InteropServices\n\n Imports System.Threading\n\n \n\n Public Class Form1\n\n \n\n Const MOUSEEVENTF_LEFTDOWN As UInteger = &H2 '0x0002\n\n Const MOUSEEVENTF_LEFTUP As UInteger = &H4 '0x0004\n\n \n\n <DllImport(\"user32.dll\")> _\n\n Private Shared Sub mouse_event(ByVal dwFlags As UInteger, ByVal dx As UInteger, ByVal dy As UInteger, ByVal dwData As UInteger, ByVal dwExtraInfo As Integer)\n\n End Sub\n\n \n\n 'Public Declare Sub mouse_event Lib \"user32\" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal dwData As Long, ByVal dwExtraInfo As Long)\n\n \n\n Private Sub Timer1_Tick(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Timer1.Tick\n\n mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)\n\n Thread.Sleep(100)\n\n mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)\n\n End Sub\n\n \n\n End Class\n\n \n\n Const MOUSEEVENTF_WHEEL As Int32 = 2048\n\n Const MOUSEEVENTF_WHEEL_DELTA As Int32 = 120\n\n \n\n Private Declare Function apimouse_event Lib \"user32\" Alias \"mouse_event\" (ByVal dwFlags As Int32, ByVal dX As Int32, ByVal dY As Int32, ByVal cButtons As Int32, ByVal dwExtraInfo As Int32) As Boolean\n\n Private Declare Function apiGetMessageExtraInfo Lib \"user32\" Alias \"GetMessageExtraInfo\" () As Int32\n\n \n\n Private Sub PlayScroll(ByVal number As Int32, Optional ByVal increment As Int32 = 2)\n\n On Error Resume Next\n\n For i As Int32 = 1 To number\n\n apimouse_event(MOUSEEVENTF_WHEEL, 0, 0, increment, apiGetMessageExtraInfo)\n\n Next\n\n End Sub\n\n \n\n This code assumes a form called frmMain with a command button called cmdClick a picture box called picClicker and a text box called txtResults Note Twips are no more. Also, I stripped the FOR loop of delta moves from the command button click to the middle of the picture box. Inherits System.Windows.Forms.Form\n\n \n\n Declare Auto Sub mouse_event Lib \"user32\" (ByVal dwFlags As Int32, ByVal dx As Int32, ByVal dy As Int32, ByVal cButtons As Int32, ByVal dwExtraInfo As IntPtr)\n\n \n\n Const MOUSEEVENTF_MOVE As Int32 = &H1 ' mouse move\n\n Const MOUSEEVENTF_LEFTDOWN As Int32 = &H2 ' left button down\n\n Const MOUSEEVENTF_LEFTUP As Int32 = &H4 ' left button up\n\n Const MOUSEEVENTF_RIGHTDOWN As Int32 = &H8 ' right button down\n\n Const MOUSEEVENTF_RIGHTUP As Int32 = &H10 ' right button up\n\n Const MOUSEEVENTF_MIDDLEDOWN As Int32 = &H20 ' middle button down\n\n Const MOUSEEVENTF_MIDDLEUP As Int32 = &H40 ' middle button up\n\n Const MOUSEEVENTF_ABSOLUTE As Int32 = &H8000 ' absolute move\n\n Const MOUSEEVENTF_WHEEL As Int32 = &H800 ' wheel button rolled\n\n \n\n ' Simulate moving the mouse to the center of the\n\n ' PictureBox and clicking.\n\n Private Sub cmdClick_Click(ByVal eventSender As System.Object, ByVal eventArgs As System.EventArgs) Handles cmdClick.Click\n\n Dim cur_x As Single\n\n Dim cur_y As Single\n\n Dim dest_x As Single\n\n Dim dest_y As Single\n\n \n\n ' mouse_event moves in a coordinate system where\n\n ' (0, 0) is in the upper left corner and\n\n ' (65535,65535) is in the lower right corner.\n\n \n\n ' Get the current mouse coordinates and convert\n\n ' them into this new system.\n\n cur_x = System.Windows.Forms.Cursor.Position.X * 65535 / System.Windows.Forms.Screen.PrimaryScreen.Bounds.Width\n\n cur_y = System.Windows.Forms.Cursor.Position.Y * 65535 / System.Windows.Forms.Screen.PrimaryScreen.Bounds.Height\n\n \n\n ' Convert the coordinates of the center of the\n\n ' picClicker PictureBox into this new system.\n\n Dim pt As Point = picClicker.PointToScreen(New Point(picClicker.ClientRectangle.Width / 2, picClicker.ClientRectangle.Height / 2))\n\n \n\n dest_x = pt.X * 65535 / System.Windows.Forms.Screen.PrimaryScreen.Bounds.Width\n\n dest_y = pt.Y * 65535 / System.Windows.Forms.Screen.PrimaryScreen.Bounds.Height\n\n \n\n txtResults.Text = txtResults.Text & \"From \" & System.Windows.Forms.Cursor.Position.X & \" \" & System.Windows.Forms.Cursor.Position.Y & \" to \" & pt.X & \" \" & pt.Y & vbCrLf\n\n txtResults.Text = txtResults.Text & \"From \" & cur_x & \" \" & cur_y & \" to \" & dest_x & \" \" & dest_y & vbCrLf\n\n \n\n ' Move the mouse to its final destination and click it.\n\n mouse_event(MOUSEEVENTF_ABSOLUTE + MOUSEEVENTF_MOVE + MOUSEEVENTF_LEFTDOWN + MOUSEEVENTF_LEFTUP, dest_x, dest_y, 0, 0)\n\n End Sub\n\n \n\n Private Sub picClicker_Click(ByVal eventSender As System.Object, ByVal eventArgs As System.EventArgs) Handles picClicker.Click\n\n txtResults.Text = txtResults.Text & \"MouseClick\" & vbCrLf\n\n End Sub\n\n \n\n Private Sub picClicker_MouseDown(ByVal sender As System.Object, ByVal e As System.Windows.Forms.MouseEventArgs) Handles picClicker.MouseDown\n\n txtResults.Text = txtResults.Text & \"MouseDown (\" & e.X & \", \" & e.Y & \")\" & vbCrLf\n\n End Sub\n\n \n\n Private Sub picClicker_MouseUp(ByVal sender As System.Object, ByVal e As System.Windows.Forms.MouseEventArgs) Handles picClicker.MouseUp\n\n txtResults.Text = txtResults.Text & \"MouseUp (\" & e.X & \", \" & e.Y & \")\" & vbCrLf\n\n End Sub\n\n Per http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/win32map.asp , mouse_event is supposed to be replaced by .NET Framework API System.Windows.Forms.MouseEventArgs but this is not the case. MouseEventArgs is just a data structure w/out event capability. I tried to get: to work as desired. Although it did trigger mouse events in the form showing the movement and click action desired, it didn't move the mouse pointer on the screen nor did it trigger events in the picture box located at pt.X, pt.Y Thus I have resigned myself to unmanaged code for now. I will post the SendInput version shortly as mouse_event has been deprecated by Bill in favor of SendInput. You can use the System.Windows.Forms.Cursor.Position property to set the position of the mouse, if you would like. You will note I have replaced the GetCursorPos calls in the original VB source with this as suggested in the MSDN URL I mention above. An IntPtr is a pointer to a memory location (unmanaged) that adapts to the platform it is running on (64-bit, etc.) UNLIKE a standard int/Integer. You should always use this type for unmanaged calls that require it, even though an int will appear to work on your development machine.\n• helpful tips or sample code to share for using this API in managed code?\n• variations of the signature you want to share?\n• additional languages you want to include? Select \"Edit This Page\" on the right hand toolbar and edit it! Or add new pages containing supporting types needed for this API (structures, delegates, and more)."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/input-mouse/how-to-simulate-events?view=netdesktop-9.0",
        "document": "Simulating mouse events in Windows Forms isn't as straight forward as simulating keyboard events. Windows Forms doesn't provide a helper class to move the mouse and invoke mouse-click actions. The only option for controlling the mouse is to use native Windows methods. If you're working with a custom control or a form, you can simulate a mouse event, but you can't directly control the mouse.\n\nMost events have a corresponding method that invokes them, named in the pattern of followed by , such as . This option is only possible within custom controls or forms, because these methods are protected and can't be accessed from outside the context of the control or form. The disadvantage to using a method such as is that it doesn't actually control the mouse or interact with the control, it simply raises the associated event. For example, if you wanted to simulate hovering over an item in a ListBox, and the doesn't visually react with a highlighted item under the cursor.\n\nThese protected methods are available to simulate mouse events.\n\nFor more information about these events, see Using mouse events (Windows Forms .NET)\n\nConsidering most controls do something when clicked, like a button calling user code, or checkbox change its checked state, Windows Forms provides an easy way to trigger the click. Some controls, such as a combobox, don't do anything special when clicked and simulating a click has no effect on the control.\n\nThe System.Windows.Forms.IButtonControl interface provides the PerformClick method which simulates a click on the control. Both the System.Windows.Forms.Button and System.Windows.Forms.LinkLabel controls implement this interface.\n\nWith a form a custom control, use the InvokeOnClick method to simulate a mouse click. This is a protected method that can only be called from within the form or a derived custom control.\n\nFor example, the following code clicks a checkbox from .\n\nWindows provides methods you can call to simulate mouse movements and clicks such as and . The following example moves the mouse cursor to the center of a control:\n• Overview of using the mouse (Windows Forms .NET)\n• How to distinguish between clicks and double-clicks (Windows Forms .NET)"
    }
]