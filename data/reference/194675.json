[
    {
        "link": "https://doc.qt.io/qt-5/qlist.html",
        "document": "The QList class is a template class that provides lists. More...\n\nNote: All functions in this class are reentrant.\n\nFor a detailed discussion comparing Qt containers with each other and with STL containers, see Understand the Qt Containers .\n\nIf T is QString , this class has the following additional members: filter , join , removeDuplicates , sort .\n\nIf T is a QByteArray , this class has a couple more members that can be used. See the documentation for QByteArrayList for more information.\n\nTo avoid failures when your list can be empty, call isEmpty () before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by size () but not less than 0.\n\nTo make QList as efficient as possible, its member functions don't validate their input before using it. Except for isEmpty (), member functions always assume the list is not empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means QList member functions can fail. If you define QT_NO_DEBUG when you compile, failures will not be detected. If you don't define QT_NO_DEBUG, failures will be detected using Q_ASSERT () or Q_ASSERT_X () with an appropriate message.\n\nQList does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nLike the other container classes, QList provides Java-style iterators ( QListIterator and QMutableListIterator ) and STL-style iterators ( QList::const_iterator and QList::iterator ). In practice, these are rarely used, because you can use indexes into the QList. QList is implemented in such a way that direct index-based access is just as fast as using iterators.\n\nQList's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nIf you simply want to check whether a list contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the list, use count (). If you want to replace all occurrences of a particular value with another, use replace ().\n\n\"First occurrence of Jane is at position \"\n\nIf you want to find all occurrences of a particular value in a list, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:\n\nInserting and removing items at either end of the list is very fast ( constant time in most cases), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nA common requirement is to remove an item from a list and do something with it. For this, QList provides takeAt (), takeFirst (), and takeLast (). Here's a loop that removes the items from a list one at a time and calls delete on them:\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nBecause QList is implemented as an array of pointers for types that are larger than a pointer or are not movable, this operation requires ( constant time ). For read-only access, an alternative syntax is to use at ():\n\nQList uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item and can be used on the left side of an assignment:\n\noperator<< () allows to conveniently add multiple elements to a list:\n\nQList provides these basic functions to add, move, and remove items: insert (), replace (), removeAt (), move (), and swap (). In addition, it provides the following convenience functions: append (), operator<< (), operator+= (), prepend (), removeFirst (), and removeLast ().\n\nQList stores a list of items. The default constructor creates an empty list. You can use the initializer-list constructor to create a list with elements:\n\nQt includes a QStringList class that inherits QList< QString > and adds a few convenience functions, such as QStringList::join () and QStringList::filter (). QString::split () creates QStringLists from strings.\n\nHere's an example of a QList that stores integers and a QList that stores QDate values:\n\nNote that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.\n\nNote, however, that when the conditions specified above are not met, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation will make QVector a better choice for use cases that do a lot of appending or inserting, because QVector can allocate memory for many items in a single heap allocation.\n\nThe array representation allows very fast insertions and index-based access. The prepend () and append () operations are also very fast because QList preallocates memory at both ends of its internal array. (See Algorithmic Complexity for details.\n\nInternally, QList<T> is represented as an array of T if sizeof(T) <= sizeof(void*) and T has been declared to be either a Q_MOVABLE_TYPE or a Q_PRIMITIVE_TYPE using Q_DECLARE_TYPEINFO . Otherwise, QList<T> is represented as an array of T* and the items are allocated on the heap.\n\nNote: Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a QVector and non-heap-allocating QLists.\n\nNote: QVector and QVarLengthArray both guarantee C-compatible array layout. QList does not. This might be important if your application must interface with a C API.\n\nQList<T>, QLinkedList<T>, and QVector <T> provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:\n\nQList<T> is one of Qt's generic container classes . It stores items in a list that provides fast index-based access and index-based insertions and removals.\n\nSee also QListIterator, QMutableListIterator, QLinkedList, and QVector.\n\nSee also QList::rbegin (), QList::rend (), QList::const_reverse_iterator , and QList::iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<iterator> .\n\nThe QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for QList .\n\nSee also QList::rbegin (), QList::rend (), QList::reverse_iterator , and QList::const_iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<const_iterator> .\n\nThe QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for QList .\n\nConstructs a QList with the contents in the iterator range [first, last).\n\nThe value type of must be convertible to .\n\nThis function was introduced in Qt 5.14.\n\nConstruct a list from the std::initializer_list specified by args.\n\nThis constructor is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 4.8.\n\nMove-constructs a QList instance, making it point at the same object that other was pointing to.\n\nThis function was introduced in Qt 5.2.\n\nThis operation takes constant time, because QList is implicitly shared. This makes returning a QList from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nMove-assigns other to this QList instance.\n\nThis function was introduced in Qt 5.2.\n\nAssigns other to this list and returns a reference to this list.\n\nDestroys the list. References to the values in the list and all iterators of this list become invalid.\n\nInserts value at the end of the list.\n\nThis is the same as list.insert(size(), value).\n\nIf this list is not shared, this operation is typically very fast (amortized constant time), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nAppends the items of the value list to this list.\n\nThis function was introduced in Qt 4.5.\n\nSee also operator<<() and operator+=().\n\nReturns the item at index position i in the list. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nThis function is very fast (constant time).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the list.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns a const STL-style iterator pointing to the first item in the list.\n\nThis function was introduced in Qt 5.0.\n\nSee also begin() and cend().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the list.\n\nThis function was introduced in Qt 5.0.\n\nSee also cbegin() and end().\n\nRemoves all items from the list.\n\nReturns a const STL-style iterator pointing to the first item in the list.\n\nSee also begin() and constEnd().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the list.\n\nSee also constBegin() and end().\n\nReturns a const reference to the first item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.6.\n\nSee also constLast(), isEmpty(), and first().\n\nReturns a reference to the last item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.6.\n\nSee also constFirst(), isEmpty(), and last().\n\nReturns if the list contains an occurrence of value; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the list.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nReturns the number of items in the list. This is effectively the same as size().\n\nReturns a const STL-style reverse iterator pointing to the first item in the list, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), rbegin(), and rend().\n\nReturns a const STL-style reverse iterator pointing to one past the last item in the list, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), rend(), and rbegin().\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty() and returns if the list is empty.\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the list.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns if this list is not empty and its last item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and contains().\n\nRemoves the item associated with the iterator pos from the list, and returns an iterator to the next item in the list (which may be end()).\n\nSee also insert() and removeAt().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nReturns a reference to the first item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also constFirst(), last(), and isEmpty().\n\nThis is an overloaded function.\n\nReturns a QList object with the data contained in vector.\n\nSee also toVector() and QVector::toList().\n\nThis function is provided for STL compatibility. It is equivalent to first(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the list, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nNote that QList uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.\n\nSee also lastIndexOf() and contains().\n\nInserts value at index position i in the list.\n\nIf i == 0, the value is prepended to the list. If i == size(), the value is appended to the list.\n\nSee also append(), prepend(), replace(), and removeAt().\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.\n\nReturns if the list contains no items; otherwise returns false.\n\nReturns a reference to the last item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also constLast(), first(), and isEmpty().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of value in the list, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nNote that QList uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.\n\nThis function is identical to count().\n\nThis function was introduced in Qt 4.5.\n\nReturns a sub-list which includes elements from this list, starting at position pos. If length is -1 (the default), all elements from pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included.\n\nMoves the item at index position from to index position to.\n\nThis is the same as insert(to, takeAt(from)).This function assumes that both from and to are at least 0 but less than size(). To avoid failure, test that both from and to are at least 0 and less than size().\n\nSee also swap(), insert(), and takeAt().\n\nThis function is provided for STL compatibility. It is equivalent to removeLast(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nInserts value at the beginning of the list.\n\nThis is the same as list.insert(0, value).\n\nIf this list is not shared, this operation is typically very fast (amortized constant time), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nSee also append() and insert().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nReturns a STL-style reverse iterator pointing to the first item in the list, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), crbegin(), and rend().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nRemoves all occurrences of value in the list and returns the number of entries removed.\n\nThis function requires the value type to have an implementation of .\n\nSee also removeOne(), removeAt(), takeAt(), and replace().\n\nRemoves the item at index position i. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also takeAt(), removeFirst(), removeLast(), and removeOne().\n\nRemoves the first item in the list. Calling this function is equivalent to calling removeAt(0). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also removeAt() and takeFirst().\n\nRemoves the last item in the list. Calling this function is equivalent to calling removeAt(size() - 1). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also removeAt() and takeLast().\n\nRemoves the first occurrence of value in the list and returns true on success; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nThis function was introduced in Qt 4.4.\n\nSee also removeAll(), removeAt(), takeAt(), and replace().\n\nReturns a STL-style reverse iterator pointing to one past the last item in the list, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), crend(), and rbegin().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReplaces the item at index position i with value. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also operator[]() and removeAt().\n\nIf alloc is smaller than the current size of the list, nothing will happen.\n\nUse this function to avoid repetetive reallocation of QList's internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.\n\nThis function was introduced in Qt 4.7.\n\nReturns the number of items in the list.\n\nSee also isEmpty() and count().\n\nReturns if this list is not empty and its first item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and contains().\n\nSwaps list other with this list. This operation is very fast and never fails.\n\nThis function was introduced in Qt 4.8.\n\nExchange the item at index position i with the item at index position j. This function assumes that both i and j are at least 0 but less than size(). To avoid failure, test that both i and j are at least 0 and less than size().\n\nThis function was introduced in Qt 5.13.\n\nRemoves the item at index position i and returns it. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nIf you don't use the return value, removeAt() is more efficient.\n\nSee also removeAt(), takeFirst(), and takeLast().\n\nRemoves the first item in the list and returns it. This is the same as takeAt(0). This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf this list is not shared, this operation takes constant time.\n\nIf you don't use the return value, removeFirst() is more efficient.\n\nSee also takeLast(), takeAt(), and removeFirst().\n\nRemoves the last item in the list and returns it. This is the same as takeAt(size() - 1). This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf this list is not shared, this operation takes constant time.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nSee also takeFirst(), takeAt(), and removeLast().\n\nReturns a QVector object with the data contained in this QList.\n\nSee also fromVector() and QVector::fromList().\n\nReturns the value at index position i in the list.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that the index is going to be within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns if other is not equal to this list; otherwise returns .\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a list that contains all the items in this list followed by all the items in the other list.\n\nAppends the items of the other list to this list and returns a reference to this list.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the list.\n\nSee also append() and operator<<().\n\nAppends the items of the other list to this list and returns a reference to this list.\n\nSee also operator+=() and append().\n\nThis is an overloaded function.\n\nAppends value to the list.\n\nReturns if other is equal to this list; otherwise returns false.\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nIf this function is called on a list that is currently being shared, it will trigger a copy of all elements. Otherwise, this function runs in constant time. If you do not want to modify the list you should use QList::at().\n\nSee also at() and value().\n\nThis is an overloaded function.\n\nSame as at(). This function runs in constant time."
    },
    {
        "link": "https://doc.qt.io/qt-6/qlist.html",
        "document": "The QList class is a template class that provides a dynamic array. More...\n\nNote: All functions in this class are reentrant.\n\nNote that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.\n\nWhen memory allocation fails, QList uses the Q_CHECK_PTR macro, which throws a std::bad_alloc exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.\n\nThe maximum size of QList depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a QList is this maximum size divided by the size of a stored element.\n\nFor a detailed discussion comparing Qt containers with each other and with STL containers, see Understand the Qt Containers .\n\nIn addition to QList, Qt also provides QVarLengthArray , a very low-level class with little functionality that is optimized for speed.\n\nFor iterating over the items, see Iterating over Containers . For using QList with functions from <algorithm> header, such as std::sort() , std::reverse() , and std::count_if() , see Qt containers and std algorithms .\n\nQList's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nNote that using non-const operators and functions can cause QList to do a deep copy of the data, due to implicit sharing .\n\nIf you're building a QList gradually and know in advance approximately how many elements it will contain, you can call reserve (), asking QList to preallocate a certain amount of memory. You can also call capacity () to find out how much memory the QList actually has allocated.\n\nUnlike plain C++ arrays, QLists can be resized at any time by calling resize (). If the new size is larger than the old size, QList might need to reallocate the whole list. QList tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nQList provides these basic functions to add, move, and remove items: insert (), replace (), remove (), prepend (), append (). With the exception of append (), prepend () and replace (), these functions can be slow ( linear time ) for large lists, because they require moving many items in the list by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use std::list instead.\n\nIf you simply want to check whether a list contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the list, use count ().\n\n\"First occurrence of Harumi is at position \"\n\nIf you want to find all occurrences of a particular value in a list, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nAnother way to access the data stored in a QList is to call data (). The function returns a pointer to the first item in the list. You can use the pointer to directly access and modify the elements stored in the list. The pointer is also useful if you need to pass a QList to a function that accepts a plain C++ array.\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nFor read-only access, an alternative syntax is to use at ():\n\nQList uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nYou can also call fill () at any time to fill the list with a value.\n\nThe elements are automatically initialized with a default-constructed value . If you want to initialize the list with a different value, pass that value as the second argument to the constructor:\n\nQList stores its items in an array of continuous memory. Typically, lists are created with an initial size. For example, the following code constructs a QList with 200 elements:\n\nHere's an example of a QList that stores integers and a QList that stores QString values:\n\nNote: QList in Qt 5 did not always have a C-compatible array layout and we often recommended to use QVector instead for more predictable performance. This is not the case in Qt 6 anymore, where both classes now share an implementation and can be used interchangeably.\n\nQList<T> and QVarLengthArray <T> provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:\n\nQList<T> is one of Qt's generic container classes . It stores its items in adjacent memory locations and provides fast index-based access. QVector <T> used to be a different class in Qt 5, but is now a simple alias to QList.\n\nSee also QList::rbegin (), QList::rend (), QList::const_reverse_iterator , and QList::iterator .\n\nWarning: Iterators are invalidated when QList is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nThe QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for QList .\n\nSee also QList::rbegin (), QList::rend (), QList::reverse_iterator , and QList::const_iterator .\n\nWarning: Iterators are invalidated when QList is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nThe QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for QList .\n\nSets the size of the list to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with either a default-constructed value or c. If size is less than the current size, elements are removed from the end.\n\nIf this list is not shared, the capacity() is preserved. Use squeeze() to shed excess capacity.\n\nThis function was introduced in Qt 6.0.\n\nInserts value at the beginning of the list.\n\nThis is the same as list.insert(0, value).\n\nNormally this operation is relatively fast (amortized constant time). QList is able to allocate extra memory at the beginning of the list data and grow in that direction without reallocating or moving the data on each operation. However if you want a container class with a guarantee of constant time prepend, use std::list instead, but prefer QList otherwise.\n\nSee also append() and insert().\n\nAdds a new element to the end for the container. This new element is constructed in-place using args as the arguments for its construction.\n\nReturns a reference to the new element.\n\nIt is also possible to access a newly created object by using returned reference:\n\nThis is the same as list.emplace(list.size(), args).\n\nInserts value at index position i in the list. If i is 0, the value is prepended to the list. If i is size(), the value is appended to the list.\n\nFor large lists, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use std::list instead.\n\nSee also append(), prepend(), and remove().\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nIt returns the maximum number of elements that the list can theoretically hold. In practice, the number can be much smaller, limited by the amount of memory available to the system.\n\nThis function was introduced in Qt 6.8.\n\nReturns a list that contains all the items in this list followed by all the items in the other list.\n\nConstructs a list with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nConstructs a list from the std::initializer_list given by args.\n\nConstructs a list with the contents in the iterator range [first, last).\n\nThe value type of must be convertible to .\n\nConstructs a list with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nConstructs a list with an initial size of size elements.\n\nQList will make an attempt at not initializing the elements.\n• if has a constructor that accepts , that constructor will be used to initialize the elements;\n• otherwise, each element is default constructed. For trivially constructible types (such as , , etc.) this is equivalent to not initializing them.\n\nThis function was introduced in Qt 6.8.\n\nThis operation takes constant time, because QList is implicitly shared. This makes returning a QList from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nMove-constructs a QList instance, making it point at the same object that other was pointing to.\n\nInserts value at the end of the list.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the list.\n\nThis operation is relatively fast, because QList typically allocates more memory than necessary, so it can grow without reallocating the entire list each time.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nMoves the items of the value list to the end of this list.\n\nThis function was introduced in Qt 6.0.\n\nSee also operator<<() and operator+=().\n\nThis is an overloaded function.\n\nThis is an overloaded function.\n\nAppends the items of the value list to this list.\n\nSee also operator<<() and operator+=().\n\nReplaces the contents of this list with a copy of the elements of l.\n\nThe size of this list will be equal to the number of elements in l.\n\nThis function only allocates memory if the number of elements in l exceeds the capacity of this list or this list is shared.\n\nThis function was introduced in Qt 6.6.\n\nReplaces the contents of this list with a copy of the elements in the iterator range [first, last).\n\nThe size of this list will be equal to the number of elements in the range [first, last).\n\nThis function will only allocate memory if the number of elements in the range exceeds the capacity of this list or this list is shared.\n\nThis function was introduced in Qt 6.6.\n\nReplaces the contents of this list with n copies of t.\n\nThe size of this list will be equal to n.\n\nThis function will only allocate memory if n exceeds the capacity of the list or this list is shared.\n\nThis function was introduced in Qt 6.6.\n\nReturns the item at index position i in the list.\n\ni must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the list.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns the maximum number of items that can be stored in the list without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QList's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the list, call size().\n\nSee also reserve() and squeeze().\n\nReturns a const STL-style iterator pointing to the first item in the list.\n\nSee also begin() and cend().\n\nReturns a const STL-style iterator pointing just after the last item in the list.\n\nSee also cbegin() and end().\n\nRemoves all the elements from the list.\n\nIf this list is not shared, the capacity() is preserved. Use squeeze() to shed excess capacity.\n\nSee also resize() and squeeze().\n\nReturns a const STL-style iterator pointing to the first item in the list.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the list. The pointer can be used to access the items in the list.\n\nThis function is mostly useful to pass a list to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing just after the last item in the list.\n\nSee also constBegin() and end().\n\nReturns a const reference to the first item in the list. This function assumes that the list isn't empty.\n\nSee also constLast(), isEmpty(), and first().\n\nReturns a const reference to the last item in the list. This function assumes that the list isn't empty.\n\nSee also constFirst(), isEmpty(), and last().\n\nReturns if the list contains an occurrence of value; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the list.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded function.\n\nReturns a const STL-style reverse iterator pointing to the first item in the list, in reverse order.\n\nSee also begin(), rbegin(), and rend().\n\nReturns a const STL-style reverse iterator pointing just after the last item in the list, in reverse order.\n\nSee also end(), rend(), and rbegin().\n\nReturns a pointer to the data stored in the list. The pointer can be used to access and modify the items in the list.\n\nThis function is mostly useful to pass a list to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded function.\n\nExtends the container by inserting a new element at position i. This new element is constructed in-place using args as the arguments for its construction.\n\nReturns an iterator to the new element.\n\nThis is an overloaded function.\n\nCreates a new element in front of the item pointed to by the iterator before. This new element is constructed in-place using args as the arguments for its construction.\n\nReturns an iterator to the new element.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning if the list is empty; otherwise returns .\n\nReturns an STL-style iterator pointing just after the last item in the list.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns if this list is not empty and its last item is equal to value; otherwise returns .\n\nSee also isEmpty() and last().\n\nRemoves the item pointed to by the iterator pos from the list, and returns an iterator to the next item in the list (which may be end()).\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nSee also insert() and remove().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nAssigns value to all items in the list. If size is different from -1 (the default), the list is resized to size beforehand.\n\nReturns a reference to the first item in the list. This function assumes that the list isn't empty.\n\nSee also last(), isEmpty(), and constFirst().\n\nReturns a sub-list that contains the first n elements of this list.\n\nThis function was introduced in Qt 6.0.\n\nSee also last() and sliced().\n\nThis is an overloaded function.\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the list, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nThis is an overloaded function.\n\nInserts count copies of value at index position i in the list.\n\nReturns if the list has size 0; otherwise returns .\n\nSee also size() and resize().\n\nReturns a reference to the last item in the list. This function assumes that the list isn't empty.\n\nSee also first(), isEmpty(), and constLast().\n\nReturns a sub-list that contains the last n elements of this list.\n\nThis function was introduced in Qt 6.0.\n\nSee also first() and sliced().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of the value value in the list, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSame as size() and count().\n\nSee also size() and count().\n\nReturns a sub-list which contains elements from this list, starting at position pos. If length is -1 (the default), all elements after pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included.\n\nMoves the item at index position from to index position to.\n\nThis function is provided for STL compatibility. It is equivalent to removeLast().\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis is an overloaded function.\n\nReturns a STL-style reverse iterator pointing to the first item in the list, in reverse order.\n\nSee also begin(), crbegin(), and rend().\n\nThis is an overloaded function.\n\nRemoves n elements from the list, starting at index position i.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nSee also insert(), replace(), and fill().\n\nRemoves all elements that compare equal to t from the list. Returns the number of elements removed, if any.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nRemoves the element at index position i. Equivalent to\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nRemoves the first item in the list. Calling this function is equivalent to calling remove(0). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nSee also remove(), takeFirst(), and isEmpty().\n\nRemoves all elements for which the predicate pred returns true from the list. Returns the number of elements removed, if any.\n\nThis function was introduced in Qt 6.1.\n\nRemoves the last item in the list. Calling this function is equivalent to calling remove(size() - 1). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nSee also remove(), takeLast(), removeFirst(), and isEmpty().\n\nRemoves the first element that compares equal to t from the list. Returns whether an element was, in fact, removed.\n\nElement removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call squeeze().\n\nReturns a STL-style reverse iterator pointing just after the last item in the list, in reverse order.\n\nSee also end(), crend(), and rbegin().\n\nThis is an overloaded function.\n\nAttempts to allocate memory for at least size elements.\n\nIf you know in advance how large the list will be, you should call this function to prevent reallocations and memory fragmentation. If you resize the list often, you are also likely to get better performance.\n\nIf in doubt about how much space shall be needed, it is usually better to use an upper bound as size, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If size is an underestimate, the list will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.\n\nSee also squeeze(), capacity(), and resize().\n\nSets the size of the list to size. If size is less than the current size, elements are removed from the end. If size is greater than the current size, elements are added to the end; QList will make an attempt at not initializing these new elements.\n• if has a constructor that accepts , that constructor will be used to initialize the elements;\n• otherwise, each element is default constructed. For trivially constructible types (such as , , etc.) this is equivalent to not initializing them.\n\nThis function was introduced in Qt 6.8.\n\nThis function is provided for STL compatibility. It is equivalent to squeeze().\n\nReturns the number of items in the list.\n\nSee also isEmpty() and resize().\n\nReturns a sub-list that contains n elements of this list, starting at position pos.\n\nThis function was introduced in Qt 6.0.\n\nSee also first() and last().\n\nThis is an overloaded function.\n\nReturns a sub-list that contains the elements of this list starting at position pos and extending to its end.\n\nThis function was introduced in Qt 6.0.\n\nSee also first() and last().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QList's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns if this list is not empty and its first item is equal to value; otherwise returns .\n\nSee also isEmpty() and first().\n\nSwaps this list with other. This operation is very fast and never fails.\n\nExchange the item at index position i with the item at index position j. This function assumes that both i and j are at least 0 but less than size(). To avoid failure, test that both i and j are at least 0 and less than size().\n\nRemoves the element at index position i and returns it.\n\nSee also takeFirst() and takeLast().\n\nRemoves the first item in the list and returns it. This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nSee also takeLast() and removeFirst().\n\nRemoves the last item in the list and returns it. This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nSee also takeFirst() and removeLast().\n\nReturns the value at index position i in the list.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns if other is not equal to this list; otherwise returns .\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nAppends the items of the other list to this list and returns a reference to this list.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 6.0.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the list.\n\nSee also append() and operator<<().\n\nThis is an overloaded function.\n\nSee also append() and operator<<().\n\nReturns if this list is lexically less than other; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nAppends value to the list and returns a reference to this list.\n\nSee also append() and operator+=().\n\nAppends other to the list and returns a reference to the list.\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 6.0.\n\nThis is an overloaded function.\n\nSee also append() and operator+=().\n\nReturns if this list is lexically less than or equal to other; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nMove-assigns other to this QList instance.\n\nAssigns other to this list and returns a reference to this list.\n\nAssigns the collection of values in args to this QList instance.\n\nReturns if other is equal to this list; otherwise returns .\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns if this list is lexically greater than other; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nReturns if this list is lexically greater than or equal to other; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the list (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QList to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded function."
    },
    {
        "link": "https://stackoverflow.com/questions/31918728/qt-qlist-removeall-deallocating-memory",
        "document": "has nothing to do with Qt 3's .\n\nNone of the methods interpret stored pointers in a special way. You must be testing it wrongly. For example, the code below happily leaks two C instances and never deletes them.\n\nPerhaps you were thinking of from ? This one will delete the instances.\n\nNote that 's implementation may allocate per-item memory to store your instances in, and will free that memory when appropriate. In no case will implementation delete a pointer that you store in the list: the only way interprets the stored data is via its type, and then it's only to decide whether the items are memory-movable, and whether they fit into a or do they need to be individually allocated. In fact, all pointer types are stored in as if it were a , with a bit of room added at the beginning and the end to make and have amortized O(1) cost."
    },
    {
        "link": "https://stackoverflow.com/questions/17174239/qt5-c-remove-item-from-qlistviews-model-and-how-to-count-items",
        "document": "1. I'm trying to remove one of a few listed files from a QListView model. I'm using this code but it doesn't work:\n\nSame thing is if I use:\n\nWhat's wrong with this code, and how do I delete an item from the list?\n\n2. loads only files from the selected directory. How do I count all those items from 's model?"
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_versions/freesurfer/lib/qt/qt_doc/html/qlist.html",
        "document": "The QList class is a template class that provides lists. More...\n\nNote: All functions in this class are reentrant.\n\nTo avoid failures when your list can be empty, call isEmpty () before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by size () but not less than 0.\n\nTo make QList as efficient as possible, its member functions don't validate their input before using it. Except for isEmpty (), member functions always assume the list is not empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means QList member functions can fail. If you define QT_NO_DEBUG when you compile, failures will not be detected. If you don't define QT_NO_DEBUG, failures will be detected using Q_ASSERT () or Q_ASSERT_X () with an appropriate message.\n\nQList does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nLike the other container classes, QList provides Java-style iterators ( QListIterator and QMutableListIterator ) and STL-style iterators ( QList::const_iterator and QList::iterator ). In practice, these are rarely used, because you can use indexes into the QList. QList is implemented in such a way that direct index-based access is just as fast as using iterators.\n\nQList's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nIf you simply want to check whether a list contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the list, use count (). If you want to replace all occurrences of a particular value with another, use replace ().\n\nIf you want to find all occurrences of a particular value in a list, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:\n\nInserting and removing items at either ends of the list is very fast ( constant time in most cases), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nA common requirement is to remove an item from a list and do something with it. For this, QList provides takeAt (), takeFirst (), and takeLast (). Here's a loop that removes the items from a list one at a time and calls delete on them:\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nBecause QList is implemented as an array of pointers, this operation is very fast ( constant time ). For read-only access, an alternative syntax is to use at ():\n\nQList uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item and can be used on the left side of an assignment:\n\nQList provides these basic functions to add, move, and remove items: insert (), replace (), removeAt (), move (), and swap (). In addition, it provides the following convenience functions: append (), prepend (), removeFirst (), and removeLast ().\n\nQList stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use operator<<():\n\nQt includes a QStringList class that inherits QList< QString > and adds a few convenience functions, such as QStringList::join () and QStringList::find (). ( QString::split () creates QStringLists from strings.)\n\nHere's an example of a QList that stores integers and a QList that stores QDate values:\n\nNote that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.\n\nInternally, QList<T> is represented as an array of pointers to items of type T. If T is itself a pointer type or a basic type that is no larger than a pointer, or if T is one of Qt's shared classes , then QList<T> stores the items directly in the pointer array. For lists under a thousand items, this array representation allows for very fast insertions in the middle, and it allows index-based access. Furthermore, operations like prepend () and append () are very fast, because QList preallocates memory at both ends of its internal array. (See Algorithmic Complexity for details.) Note, however, that for unshared list items that are larger than a pointer, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation might make QVector a better choice in cases that do lots of appending or inserting, since QVector allocates memory for its items in a single heap allocation.\n\nQList<T> is one of Qt's generic container classes . It stores a list of values and provides fast index-based access as well as fast insertions and removals.\n\nThe QList class is a template class that provides lists.\n\nSee also QListIterator, QMutableListIterator, QLinkedList, and QVector.\n\nThis operation takes constant time, because QList is implicitly shared. This makes returning a QList from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nDestroys the list. References to the values in the list and all iterators of this list become invalid.\n\nInserts value at the end of the list.\n\nThis is the same as list.insert(size(), value).\n\nThis operation is typically very fast (constant time), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nAppends the items of the value list to this list.\n\nThis function was introduced in Qt 4.5.\n\nSee also operator<<() and operator+=().\n\nReturns the item at index position i in the list. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nThis function is very fast (constant time).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the list.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nRemoves all items from the list.\n\nReturns a const STL-style iterator pointing to the first item in the list.\n\nSee also begin() and constEnd().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the list.\n\nSee also constBegin() and end().\n\nReturns true if the list contains an occurrence of value; otherwise returns false.\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the list.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nReturns the number of items in the list. This is effectively the same as size().\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty() and returns true if the list is empty.\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the list.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns true if this list is not empty and its last item is equal to value; otherwise returns false.\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and contains().\n\nRemoves the item associated with the iterator pos from the list, and returns an iterator to the next item in the list (which may be end()).\n\nSee also insert() and removeAt().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nReturns a reference to the first item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also last() and isEmpty().\n\nThis is an overloaded function.\n\nReturns a QList object with the data contained in set. The order of the elements in the QList is undefined.\n\nSee also fromVector(), toSet(), QSet::toList(), and qSort().\n\nReturns a QList object with the data contained in list. The order of the elements in the QList is the same as in list.\n\nSee also toStdList() and QVector::fromStdVector().\n\nReturns a QList object with the data contained in vector.\n\nSee also fromSet(), toVector(), and QVector::toList().\n\nThis function is provided for STL compatibility. It is equivalent to first(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the list, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nNote that QList uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.\n\nSee also lastIndexOf() and contains().\n\nInserts value at index position i in the list. If i is 0, the value is prepended to the list. If i is size(), the value is appended to the list.\n\nSee also append(), prepend(), replace(), and removeAt().\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.\n\nReturns true if the list contains no items; otherwise returns false.\n\nReturns a reference to the last item in the list. The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also first() and isEmpty().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of value in the list, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nNote that QList uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.\n\nThis function is identical to count().\n\nThis function was introduced in Qt 4.5.\n\nReturns a list whose elements are copied from this list, starting at position pos. If length is -1 (the default), all elements from pos are copied; otherwise length elements (or all remaining elements if there are less than length elements) are copied.\n\nMoves the item at index position from to index position to.\n\nThis is the same as insert(to, takeAt(from)).This function assumes that both from and to are at least 0 but less than size(). To avoid failure, test that both from and to are at least 0 and less than size().\n\nSee also swap(), insert(), and takeAt().\n\nThis function is provided for STL compatibility. It is equivalent to removeLast(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst(). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nInserts value at the beginning of the list.\n\nThis is the same as list.insert(0, value).\n\nThis operation is usually very fast (constant time), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.\n\nSee also append() and insert().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nRemoves all occurrences of value in the list and returns the number of entries removed.\n\nThis function requires the value type to have an implementation of .\n\nSee also removeOne(), removeAt(), takeAt(), and replace().\n\nRemoves the item at index position i. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also takeAt(), removeFirst(), removeLast(), and removeOne().\n\nRemoves the first item in the list. Calling this function is equivalent to calling removeAt(0). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also removeAt() and takeFirst().\n\nRemoves the last item in the list. Calling this function is equivalent to calling removeAt(size() - 1). The list must not be empty. If the list can be empty, call isEmpty() before calling this function.\n\nSee also removeAt() and takeLast().\n\nRemoves the first occurrence of value in the list and returns true on success; otherwise returns false.\n\nThis function requires the value type to have an implementation of .\n\nThis function was introduced in Qt 4.4.\n\nSee also removeAll(), removeAt(), takeAt(), and replace().\n\nReplaces the item at index position i with value. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nSee also operator[]() and removeAt().\n\nIf alloc is smaller than the current size of the list, nothing will happen.\n\nUse this function to avoid repetetive reallocation of QList's internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.\n\nThis function was introduced in Qt 4.7.\n\nReturns the number of items in the list.\n\nSee also isEmpty() and count().\n\nReturns true if this list is not empty and its first item is equal to value; otherwise returns false.\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and contains().\n\nExchange the item at index position i with the item at index position j. This function assumes that both i and j are at least 0 but less than size(). To avoid failure, test that both i and j are at least 0 and less than size().\n\nRemoves the item at index position i and returns it. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nIf you don't use the return value, removeAt() is more efficient.\n\nSee also removeAt(), takeFirst(), and takeLast().\n\nRemoves the first item in the list and returns it. This is the same as takeAt(0). This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeFirst() is more efficient.\n\nSee also takeLast(), takeAt(), and removeFirst().\n\nRemoves the last item in the list and returns it. This is the same as takeAt(size() - 1). This function assumes the list is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nSee also takeFirst(), takeAt(), and removeLast().\n\nReturns a QSet object with the data contained in this QList. Since QSet doesn't allow duplicates, the resulting QSet might be smaller than the original list was.\n\nSee also toVector(), fromSet(), and QSet::fromList().\n\nReturns a std::list object with the data contained in this QList. Example:\n\nSee also fromStdList() and QVector::toStdVector().\n\nReturns a QVector object with the data contained in this QList.\n\nSee also toSet(), fromVector(), and QVector::fromList().\n\nReturns the value at index position i in the list.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that the index is going to be within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns true if other is not equal to this list; otherwise returns false.\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a list that contains all the items in this list followed by all the items in the other list.\n\nAppends the items of the other list to this list and returns a reference to this list.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the list.\n\nSee also append() and operator<<().\n\nAppends the items of the other list to this list and returns a reference to this list.\n\nSee also operator+=() and append().\n\nThis is an overloaded function.\n\nAppends value to the list.\n\nAssigns other to this list and returns a reference to this list.\n\nReturns true if other is equal to this list; otherwise returns false.\n\nTwo lists are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference. i must be a valid index position in the list (i.e., 0 <= i < size()).\n\nThis function is very fast (constant time).\n\nSee also at() and value().\n\nThis is an overloaded function.\n\nSame as at()."
    },
    {
        "link": "https://stackoverflow.com/questions/19719397/qt-slots-and-c11-lambda",
        "document": "The simple answer is: you can't. Or, rather, you don't want (or need!) to use . Simply capture and use .\n\nThe specification of as the object context for the functor ensures that the functor will not get invoked if either the action or (a ) cease to exist. Otherwise, the functor would try to reference dangling pointers.\n\nIn general, the following must hold when capturing context variables for a functor passed to , in order to avoid the use of dangling pointers/references:\n• None The pointers to the source and target objects of can be captured by value, as above. It is guaranteed that if the functor is invoked, both ends of the connection exist. Scenarios where and are in different threads require special attention. It can not be guaranteed that once the functor is entered, some thread will not delete either object. It is idiomatic that an object is only destructed in its , or in any thread if . Since a thread's event loop invokes the functor, the null thread is never a problem for - without a thread the functor won't be invoked. Alas, there's no guarantee about the lifetime of in 's thread. It is thus safer to capture the necessary state of the action by value instead, so that 's lifetime is not a concern.\n• None Raw pointers to other objects can be captured by value if you're absolutely sure that the lifetime of the objects they point to overlaps the lifetime of the connection. static C c; auto p = &c; connect(..., [p]{});\n• None Non-copyable objects that don't derive from should be captured through their shared pointers by value.\n• None s living in the same thread can be captured by a ; its value must be checked prior to use in the functor.\n• None s living in other threads must be captured by a shared pointer or a weak pointer. Their parent must be unset prior to their destruction, otherwise you'll have double deletes:"
    },
    {
        "link": "https://forum.qt.io/topic/135312/using-qtconnurrent-with-lambda",
        "document": "\n• @AnneRanch said in Using QtConnurrent with lambda: @Chris-Kawa Thanks - the test function is blank, no code , and does not return any values. I can change that and try \"capture all\".\n\n Thanks. I need a clarification Here is the actual QT doc copy of using lambda in QtConncurent QFuture<void> future = QtConcurrent::run([=]() { // Code in this block will run in another thread }); Here is how my test code looks like : so\n\n run executes between ( … )\n\n lambda starts with [=]\n\n and the “functor” is between { … } I assumed that { } is what QT doc calls “code to be executed “ , however I am lost how\n\n lambda syntax gets to pass ( PARAMETER ) to it\n\n [=])(parameter) ….. The way it is coded now really takes no advantage of lambda – it almost looks as the stuff between {} should be the actual body of the function. I am trying to call the function - as codded now. . And yes - I can execute Run function with or without (single ) parameter or with or without return value . It actually runs in a new thread !\n\n Making slow progress...\n• I reformatted your code snippets because they were so garbled it was hard to read. I hope you don't mind. No, passes the function object given to it as a parameter to another thread to execute and returns immediately giving you a future object that you can use to wait for that asynchronous execution to end. It does not run the function object directly. lambda starts with [=]\n\n and the “functor” is between { … } Again, no. The lambda is a functor, so this entire thing: . This whole thing is an object like an . It just happens to represent a functor and not a number. A functor, in simple terms, is something that executes code. It can be a function, like , it can be a class with like or it can be a lambda like . These are all functors and they all can be used in a call. So, if you have a function that you want to run in another thread via QtConcurrent you don't need to wrap it in a lambda. You can just pass it directly. Getting back to your original problem - the error says that you're using inside of the lambda. If your test function is empty then the only way this would be true is if your test function itself is a member of a class. In that case you need an object to call it on and that object needs to be captured in the lambda context, so again, you need to capture this in the capture clause of the lambda. Btw. very little of this has to do with Qt. just happens to take any functor, including lambdas, and it's just how lambdas work in C++.\n• Can you tell me how to pass the parameters to lambda - if I use the \"call to function \"? The arguments are just passed to as additional arguments after the functor.\n\n Here's an example. Say you have a function that takes an int: You can pass it directly to run like this: If you need to wrap it in a lambda you can do it too: or you can just inline it like you have in your code: All these will work for free functions. If you want to call a member function of the class you're calling from, then you need to go with a lambda and catch in the lambda capture clause as you did above. Rest is the same.\n• @AnneRanch said in Using QtConnurrent with lambda: Let me put it this way\n\n I do RTFM and post what is said ability using lambda.\n\n I post the error.\n\n IMHO the error shroud be enough to lead me to the fix.\n\n The \" start from how the world created\" seem to be standard \"answer\". Let me answer this way, I never requests you to RTFM, the only thing I was trying to do was to improve your knowledge about lambda functions in C++.\n\n Which is, in my eyes, the first step before trying to use them. I have given you a link to a well done explanation about how to use lambda in C++, which is much better a trying my self to do it. My English is not fluent enough to explain it in a better way. So, if you had taken time to learn how to use lambda, you had found quickly why you got this error.\n\n But this seems to be hard for you. I am always stomach by people who want to program but don't want to learn how to it. And which are always becomes aggressive when someone point out their lake of comprehension. I am always pleased when someone gives me an explanation or links where I can find useful information to understand how to do what I want to do. It is an old maxim of mine that when you have excluded the impossible, whatever remains, however improbable, must be the truth. (Sherlock Holmes)"
    },
    {
        "link": "https://medium.com/genymobile/how-c-lambda-expressions-can-improve-your-qt-code-8cd524f4ed9f",
        "document": "In case you’ve missed it, lambda expression support has been added to C++ in C++11. In this article we are going to see how to take advantage of lambda expressions in your Qt code to simplify it and make it more robust, but also which pitfalls to avoid.\n\nBut first, what is a lambda expression?\n\nLambda expressions are anonymous functions defined directly inside the body of another function. They can be used everywhere one currently passes a pointer to a function.\n\nThe syntax of a lambda expression is the following:\n\nIgnoring the “captured variables” part for now, here is a simple lambda which increments a number:\n\nWe can use this lambda in a function like to increment the elements of a vector:\n\nA lambda expression can make use of variables in the current scope, by “capturing” them. Here is an example where we use a lambda to compute the sum of a vector.\n\nAs you can see, we captured the local variable so that we could use it in the lambda. is prefixed with to indicate that we capture by reference: inside the lambda, is a reference, so any change we make to it affects the variable outside the lambda.\n\nIf you want a copy of the variable instead, you capture it without prefixing it with .\n\nIf you want to capture multiple variables, just separate them with commas, like function arguments.\n\nIt is not possible to directly capture a member variable, but you can capture , and get access to all members of the current object.\n\nUnder the hood, the captured variables of a lambda are stored in an hidden object, unless the compiler can be sure the lambda is not going to be used outside the current local scope, in which case it can optimize this away by directly referring to the local variables.\n\nIt is possible to be a bit lazy and capture all local variables. To capture them all by reference, use . To capture them all by copy, use . We do not recommend doing so however, because it makes it too easy to reference variables whose life-cycle would be shorter than the life-cycle of your lambda, leading to odd crashes, even capturing by copy can cause such crashes if you copy a pointer. Explicitly listing the variables you depend on makes it easier to avoid this kind of traps. If you want to learn more about this trap, have a look at item 31 of “Effective Modern C++”.\n\nIf you use new-style connections (and you should, because type-safety is good!), you can use lambdas on the receiving side. This is great for small dispatcher functions.\n\nHere is an example of a phone dialer, where the user can enter a number and start a call:\n\nWe can get rid of the method using a lambda:\n\nUsing lambdas instead of QObject::sender()\n\nLambdas are also a great alternative to the use of . Let's imagine our dialer is now an array of number buttons.\n\nWithout lambdas the code to compose a number could look like that:\n\nWe could use a to get rid of the dispatcher method, but using a lambda is more flexible and leads to even simpler code. We just need to capture the digit associated with the button and call directly from the lambda.\n\nLook at this code:\n\nIn this slightly contrived example, we have a Worker instance which reports progress to a Monitor instance. So far so good.\n\nNow suppose that the signal has an int argument and we want to call a different method on depending on the value of this argument. We can try something like this:\n\nThis looks good but… this code can crash!\n\nQt connection system is smart enough to delete connections if either the sender or the receiver is deleted, so in our first version of , if is deleted the connection is deleted as well. But now we use a lambda for the receiver: Qt has no way to now that this lambda makes use of . Even if is deleted, the lambda will still be called and the application will crash when it tries to dereference .\n\nTo avoid that, you can pass a “context” argument to the call, like this:\n\nIn this version, we pass as a context to . It won't affect the execution of our lambda, but when is deleted, Qt will notice and will disconnect from our lambda.\n\nThis context is also used to determine whether the connection should be queued or not. Just like a classic signal-slot connection, if the context object thread is not the same as the code emitting the signal, Qt will use a queued connection.\n\nYou might be familiar with a way to call a slot asynchronously using . Given a class like this:\n\nYou can tell Qt to call when it is back to the event loop using :\n• It is not type-safe\n• It forces you to declare methods to call as slots\n\nYou can replace this code with a calling a lambda:\n\nIt is a little less efficient because creates an object under the hood, but unless you call this multiple times per second, the performance cost is negligible, so the benefits outweigh the drawbacks.\n\nSimilarly, you can specify a context before the lambda, this is mostly useful to jump between threads. Be careful though: if you are stuck with a version of Qt older than 5.6.0 there is a bug in which causes a crash when used between threads. We found out about that one the hard way...\n• Take advantage of lambda expressions to remove dispatcher methods when connecting Qt objects together\n• When using a lambda in a call, always define a context\n• Do not capture more variables than necessary\n\nThat’s it for this article, we hope you enjoyed it, now go and find places where you can replace boilerplate methods with fancy lambdas!"
    },
    {
        "link": "https://stackoverflow.com/questions/62772084/lambda-expressions-in-qt-connections",
        "document": "I have the following function that is called each time a user click a button :\n\nNow, if the command is \"authorized\" ( the signal is asynchronously emitted but may also not be emitted at all), then the lambda containing the command logic is executed. Moreover, while the command is pending for authorization, the button is disabled ( preventing the function to be called )\n\nMy question is about the lambda connected to the signal and especially its parameters captured by value : Are those parameters eventually released from memory or do they accumulate into the memory stack each time the connection is done (ie the button is clicked) ?\n\nMore generally, is there any kind of \"memory leak\" or \"continuously growing stack\" in this code ?"
    },
    {
        "link": "https://reddit.com/r/cpp/comments/5qou5d/how_c_lambda_expressions_can_improve_your_qt_code",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    }
]