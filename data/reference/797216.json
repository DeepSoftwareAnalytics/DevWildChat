[
    {
        "link": "https://cs.virginia.edu/~evans/cs216/guides/x86.html",
        "document": "This guide describes the basics of 32-bit x86 assembly language programming, covering a small but useful subset of the available instructions and assembler directives. There are several different assembly languages for generating x86 machine code. The one we will use in CS216 is the Microsoft Macro Assembler (MASM) assembler. MASM uses the standard Intel syntax for writing x86 assembly code.\n\nThe full x86 instruction set is large and complex (Intel's x86 instruction set manuals comprise over 2900 pages), and we do not cover it all in this guide. For example, there is a 16-bit subset of the x86 instruction set. Using the 16-bit programming model can be quite complex. It has a segmented memory model, more restrictions on register usage, and so on. In this guide, we will limit our attention to more modern aspects of x86 programming, and delve into the instruction set only in enough detail to get a basic feel for x86 programming.\n• Guide to Using Assembly in Visual Studio — a tutorial on building and debugging assembly code in Visual Studio\n\nModern (i.e 386 and beyond) x86 processors have eight 32-bit general purpose registers, as depicted in Figure 1. The register names are mostly historical. For example, used to be called the accumulator since it was used by a number of arithmetic operations, and was known as the counter since it was used to hold a loop index. Whereas most of the registers have lost their special purposes in the modern instruction set, by convention, two are reserved for special purposes — the stack pointer ( ) and the base pointer ( ).\n\nFor the , , , and registers, subsections may be used. For example, the least significant 2 bytes of can be treated as a 16-bit register called . The least significant byte of can be used as a single 8-bit register called , while the most significant byte of can be used as a single 8-bit register called . These names refer to the same physical register. When a two-byte quantity is placed into , the update affects the value of , , and . These sub-registers are mainly hold-overs from older, 16-bit versions of the instruction set. However, they are sometimes convenient when dealing with data that are smaller than 32-bits (e.g. 1-byte ASCII characters).\n\nWhen referring to registers in assembly language, the names are not case-sensitive. For example, the names and refer to the same register.\n\nYou can declare static data regions (analogous to global variables) in x86 assembly using special assembler directives for this purpose. Data declarations should be preceded by thedirective. Following this directive, the directives, andcan be used to declare one, two, and four byte data locations, respectively. Declared locations can be labeled with names for later reference — this is similar to declaring variables by name, but abides by some lower level rules. For example, locations declared in sequence will be located in memory next to one another.\n\nUnlike in high level languages where arrays can have many dimensions and are accessed by indices, arrays in x86 assembly language are simply a number of cells located contiguously in memory. An array can be declared by just listing the values, as in the first example below. Two other common methods used for declaring arrays of data are the DUP directive and the use of string literals. The DUP directive tells the assembler to duplicate an expression a given number of times. For example, 4 DUP(2) is equivalent to 2, 2, 2, 2.\n\nModern x86-compatible processors are capable of addressing up to 2bytes of memory: memory addresses are 32-bits wide. In the examples above, where we used labels to refer to memory regions, these labels are actually replaced by the assembler with 32-bit quantities that specify addresses in memory. In addition to supporting referring to memory regions by labels (i.e. constant values), the x86 provides a flexible scheme for computing and referring to memory addresses: up to two of the 32-bit registers and a 32-bit signed constant can be added together to compute a memory address. One of the registers can be optionally pre-multiplied by 2, 4, or 8.\n\nThe addressing modes can be used with many x86 instructions (we'll describe them in the next section). Here we illustrate some examples using theinstruction that moves data between registers and memory. This instruction has two operands: the first is the destination and the second specifies the source.\n\nSome examples ofinstructions using address computations are:Some examples of invalid address calculations include:\n\nIn general, the intended size of the data item at a given memory address can be inferred from the assembly code instruction in which it is referenced. For example, in all of the above instructions, the size of the memory regions could be inferred from the size of the register operand. When we were loading a 32-bit register, the assembler could infer that the region of memory we were referring to was 4 bytes wide. When we were storing the value of a one byte register to memory, the assembler could infer that we wanted the address to refer to a single byte in memory.\n\nHowever, in some cases the size of a referred-to memory region is ambiguous. Consider the instruction. Should this instruction move the value 2 into the single byte at address? Perhaps it should move the 32-bit integer representation of 2 into the 4-bytes starting at address. Since either is a valid possible interpretation, the assembler must be explicitly directed as to which is correct. The size directives, andserve this purpose, indicating sizes of 1, 2, and 4 bytes respectively.\n\nFor example:Machine instructions generally fall into three categories: data movement, arithmetic/logic, and control-flow. In this section, we will look at important examples of x86 instructions from each category. This section should not be considered an exhaustive list of x86 instructions, but rather a useful subset. For a complete list, see Intel's instruction set reference.\n\nWe use the following notation:— Move (Opcodes: 88, 89, 8A, 8B, 8C, 8E, ...)\n\n— Push stack (Opcodes: FF, 89, 8A, 8B, 8C, 8E, ...)— Pop stack— Load effective address— Integer Addition— Integer Subtraction— Increment, Decrement— Integer Multiplication— Integer Division— Bitwise logical and, or and exclusive or— Bitwise Logical Not\n\n— Negate— Shift Left, Shift RightThe x86 processor maintains an instruction pointer (IP) register that is a 32-bit value indicating the location in memory where the current instruction starts. Normally, it increments to point to the next instruction in memory begins after execution an instruction. The IP register cannot be manipulated directly, but is updated implicitly by provided control flow instructions.\n\nWe use the notation <label> to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,\n\nThe second instruction in this code fragment is labeled. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name. This label is just a convenient way of expressing the location instead of its 32-bit value.\n\n— Conditional Jump— Compare— Subroutine call and returnTo allow separate programmers to share code and develop libraries for use by many programs, and to simplify the use of subroutines in general, programmers typically adopt a common calling convention. The calling convention is a protocol about how to call and return from routines. For example, given a set of calling convention rules, a programmer need not examine the definition of a subroutine to determine how parameters should be passed to that subroutine. Furthermore, given a set of calling convention rules, high-level language compilers can be made to follow the rules, thus allowing hand-coded assembly language routines and high-level language routines to call one another.\n\nIn practice, many calling conventions are possible. We will use the widely used C language calling convention. Following this convention will allow you to write assembly language subroutines that are safely callable from C (and C++) code, and will also enable you to call C library functions from your assembly language code.\n\nThe C calling convention is based heavily on the use of the hardware-supported stack. It is based on the, andinstructions. Subroutine parameters are passed on the stack. Registers are saved on the stack, and local variables used by subroutines are placed in memory on the stack. The vast majority of high-level procedural languages implemented on most processors have used similar calling conventions.\n\nThe calling convention is broken into two sets of rules. The first set of rules is employed by the caller of the subroutine, and the second set of rules is observed by the writer of the subroutine (the callee). It should be emphasized that mistakes in the observance of these rules quickly result in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care should be used when implementing the call convention in your own subroutines.\n\nA good way to visualize the operation of the calling convention is to draw the contents of the nearby region of the stack during subroutine execution. The image above depicts the contents of the stack during the execution of a subroutine with three parameters and three local variables. The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer. Above the parameters on the stack (and below the base pointer), the call instruction placed the return address, thus leading to an extra 4 bytes of offset from the base pointer to the first parameter. When the ret instruction is used to return from the subroutine, it will jump to the return address stored on the stack.\n• Before calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack (so they can be restore after the subroutine returns.\n• To pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e. last parameter first). Since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).\n• To call the subroutine, use the instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code. This invokes the subroutine, which should follow the callee rules below.\n• Remove the parameters from stack. This restores the stack to its state before the call was performed.\n• Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.\n\nTo make a subrouting call, the caller should:After the subroutine returns (immediately following theinstruction), the caller can expect to find the return value of the subroutine in the register EAX. To restore the machine state, the caller should:The code below shows a function call that follows the caller rules. The caller is calling a function _myFunc that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in memory location var.Note that after the call returns, the caller cleans up the stack using theinstruction. We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.\n\nThe result produced by _myFunc is now available for use in the register EAX. The values of the caller-saved registers (ECX and EDX), may have been changed. If the caller uses them after the call, it would have needed to save them on the stack before the call and restore them after it.\n• Push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions: This initial action maintains the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. When a subroutine is executing, the base pointer holds a copy of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller is not expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.\n• Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number and size of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables (i.e., ). As with parameters, local variables will be located at known offsets from the base pointer.\n• Next, save the values of the callee-saved registers that will be used by the function. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI, and ESI (ESP and EBP will also be preserved by the calling convention, but need not be pushed on the stack during this step).\n• Leave the return value in EAX.\n• Restore the old values of any callee-saved registers (EDI and ESI) that were modified. The register contents are restored by popping them from the stack. The registers should be popped in the inverse order that they were pushed.\n• Deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer: . This works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.\n• Immediately before returning, restore the caller's base pointer value by popping EBP off the stack. Recall that the first thing we did on entry to the subroutine was to push the base pointer to save its old value.\n• Finally, return to the caller by executing a instruction. This instruction will find and remove the appropriate return address from the stack.\n\nThe definition of the subroutine should adhere to the following rules at the beginning of the subroutine:After these three actions are performed, the body of the subroutine may proceed. When the subroutine is returns, it must follow these steps:Note that the callee's rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function.Here is an example function definition that follows the callee rules:The subroutine prologue performs the standard actions of saving a snapshot of the stack pointer in EBP (the base pointer), allocating local variables by decrementing the stack pointer, and saving register values on the stack.\n\nIn the body of the subroutine we can see the use of the base pointer. Both parameters and local variables are located at constant offsets from the base pointer for the duration of the subroutines execution. In particular, we notice that since parameters were placed onto the stack before the subroutine was called, they are always located below the base pointer (i.e. at higher addresses) on the stack. The first parameter to the subroutine can always be found at memory location EBP + 8, the second at EBP + 12, the third at EBP + 16. Similarly, since local variables are allocated after the base pointer is set, they always reside above the base pointer (i.e. at lower addresses) on the stack. In particular, the first local variable is always located at EBP - 4, the second at EBP - 8, and so on. This conventional use of the base pointer allows us to quickly identify the use of local variables and parameters within a function body.\n\nThe function epilogue is basically a mirror image of the function prologue. The caller's register values are recovered from the stack, the local variables are deallocated by resetting the stack pointer, the caller's base pointer value is recovered, and the ret instruction is used to return to the appropriate code location in the caller.\n\nThese materials are released under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 United States License . We are delighted when people want to use or adapt the course materials we developed, and you are welcome to reuse and adapt these materials for any non-commercial purposes (if you would like to use them for a commercial purpose, please contact David Evans for more information). If you do adapt or use these materials, please include a credit like \"Adapted from materials developed for University of Virginia cs216 by David Evans. This guide was revised for cs216 by David Evans, based on materials originally created by Adam Ferrari many years ago, and since updated by Alan Batson, Mike Lack, and Anita Jones.\" and a link back to this page."
    },
    {
        "link": "https://stackoverflow.com/questions/14841169/jnz-cmp-assembly-instructions",
        "document": "Correct me if I am wrong.\n\nThis is my understanding of and .\n\n- The jump WILL take place if the Flag is NOT zero (1)\n\n- If the two values are equal, the Flag is set (1) otherwise it is not set (0)\n\nThis is a flash tutorial I am watching. It is teaching the solution to a simple CrackMe.\n\nAs you can see, the previous instruction compared with . They were equal which set the flag. (You can see it in the Registers windows on the right side)\n\nThe next instruction is a . My understanding was that the jump will take place if the flag is set. The flag IS set, but the jump doesn't take place!"
    },
    {
        "link": "https://infosecinstitute.com/resources/secure-coding/conditionals-and-jump-instructions",
        "document": "This article will briefly discuss conditionals and jump instructions. Conditionals are commonly used in assembly for comparison so that other instructions can make use of the output resulting from these. Jump instructions in assembly are a way to permanently transfer the execution to another instruction located at a different memory address.\n\nLet us explore how all these concepts fit together in assembly, specifically x86.\n\nBuild your x86 assembly skills with six courses covering the basics of computer architecture, how to build and debug x86, x86 assembly instructions and more.\n\nMaking a decision based on the result of a comparison operation is possible in any programming language. Assembly is no different, and it is possible to make comparisons and make decisions based on the comparisons in assembly language too.\n\nTEST and CMP are the instructions that are commonly used for comparison in x86, and these instructions are known as conditionals.\n\nThe TEST instruction computes the bitwise logical AND of first operand and the second operand. According to the result, the status flags SF, ZF and PF will be set.\n\nIt should be noted that the TEST instruction doesn't make any changes to the operands used with the instruction. The following is an example of a TEST instruction.\n\nThe CMP instruction is another example of conditionals. A CMP instruction performs a subtract operation on both operands, and the status flags ZF and CF will be set according to the result.\n\nIt should be noted that the CMP instruction also does not affect the operands. When the destination operand and source operand are equal, ZF will be set to 1. If the destination operand is less than the source operand, CF will be set to 1. In all the remaining conditions, the respective flags will be set to 0.\n\nFollowing is an example of CMP instruction.\n\nLet’s see an example of both TEST and CMP instructions. The following code is an excerpt from the disassembly of a compiled C binary.\n\nThis excerpt has both CMP and TEST instructions. We can observe the results of these two instructions by setting a breakpoint on them.\n\nBefore executing CMP EAX, 1, the following is the status of the EAX register and the status flags:\n\nAfter stepping through the CMP instruction, the following is the status of the EAX register and the status flags.\n\nAs we can observe in both the excerpts, there is no difference in the value of EAX before and after the execution of the CMP instruction. But the only change we see is in the status flag registers. Now, let’s do single steps until we hit the next breakpoint, where TEST instruction is located.\n\nBefore executing the TEST EAX, EAX instruction, the following is the status of the EAX register and the status flags.\n\nLet’s do a single step. The following is the status of the EAX register and the status flags after stepping through the TEST instruction.\n\nAs we can observe in both the excerpts, once again there is no difference in the value of EAX before and after the execution of CMP instruction. But the only change we see is in the status flag SF.\n\nJump instructions in assembly are used for branching, which describes the control flow of the program. There are two popular types of jump instructions: unconditional jump and conditional jump.\n\nUnconditional jumps are the simplest form of jump instructions. As the name suggests, the execution will always flow to the target location specified. Following is the syntax of an unconditional jump instruction.\n\nConditional jumps are used to take jumps based on the value of status flags. Conditional jumps are commonly used when concepts like IF statements and loops are needed to be used in Assembly. Because assembly language doesn't support statements like if statements, conditional jumps are used to determine whether to take a jump or not.\n\nThere are more than 30 different conditional jump instructions, but following are some commonly used ones:\n\nJZ — Jump if Zero; checks for ZF = 1 JNZ — Jump if Not Zero; checks for ZF = 0 JNE — Jump if Not Equal; checks for ZF = 0 JNC — Jump if No Carry; checks for CF = 0 JNLE — Jump if Not Less or Equal JLE — Jump if Less or Equal\n\nThe following example shows how jump instructions work.\n\nThe preceding excerpt is a simple example of how both unconditional and conditional jumps work. In this example, JLE is a conditional jump instruction and JMP SHORT <TARGET> is an unconditional jump instruction. Let’s set breakpoints on both JLE and JMP instructions and understand how they work.\n\nConditional jumps usually depend on the results of other instructions like CMP. In this case, the following is the status of the status flags after the CMP instruction is executed.\n\nA JLE instruction usually checks for the flags O, S and Z. In our case, none of these flags are set by a CMP instruction. Thus, a conditional jump will not be taken and the next instruction will be executed.\n\nWhen JMP instruction is executed, it will not look for any dependencies and the jump will always be taken to the target address specified in the JMP instruction.\n\nIn this article, we explored the concepts of conditionals and jump instructions. We used various examples with sample instructions to better understand these concepts.\n\nWe showed that conditionals are used for comparisons and jump instructions are used for changing the execution flow. It was also understood that unconditional jump instructions will always take jumps and conditional jump instructions rely on the output of other instructions such as CMP.\n\nBuild your x86 assembly skills with six courses covering the basics of computer architecture, how to build and debug x86, x86 assembly instructions and more."
    },
    {
        "link": "https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html",
        "document": "This is a version adapted by Quentin Carbonneaux from David Evans' original document. The syntax was changed from Intel to AT&T, the standard syntax on UNIX systems, and the HTML code was purified.\n\nThis guide describes the basics of 32-bit x86 assembly language programming, covering a small but useful subset of the available instructions and assembler directives. There are several different assembly languages for generating x86 machine code. The one we will use in CS421 is the GNU Assembler (gas) assembler. We will uses the standard AT&T syntax for writing x86 assembly code.\n\nThe full x86 instruction set is large and complex (Intel's x86 instruction set manuals comprise over 2900 pages), and we do not cover it all in this guide. For example, there is a 16-bit subset of the x86 instruction set. Using the 16-bit programming model can be quite complex. It has a segmented memory model, more restrictions on register usage, and so on. In this guide, we will limit our attention to more modern aspects of x86 programming, and delve into the instruction set only in enough detail to get a basic feel for x86 programming.\n\nModern (i.e 386 and beyond) x86 processors have eight 32-bit general purpose registers, as depicted in Figure 1. The register names are mostly historical. For example, EAX used to be called the accumulator since it was used by a number of arithmetic operations, and ECX was known as the counter since it was used to hold a loop index. Whereas most of the registers have lost their special purposes in the modern instruction set, by convention, two are reserved for special purposes — the stack pointer (ESP) and the base pointer (EBP).\n\nFor the EAX, EBX, ECX, and EDX registers, subsections may be used. For example, the least significant 2 bytes of EAX can be treated as a 16-bit register called AX. The least significant byte of AX can be used as a single 8-bit register called AL, while the most significant byte of AX can be used as a single 8-bit register called AH. These names refer to the same physical register. When a two-byte quantity is placed into DX, the update affects the value of DH, DL, and EDX. These sub-registers are mainly hold-overs from older, 16-bit versions of the instruction set. However, they are sometimes convenient when dealing with data that are smaller than 32-bits (e.g. 1-byte ASCII characters).\n\nYou can declare static data regions (analogous to global variables) in x86 assembly using special assembler directives for this purpose. Data declarations should be preceded by the .data directive. Following this directive, the directives .byte, .short, and .long can be used to declare one, two, and four byte data locations, respectively. To refer to the address of the data created, we can label them. Labels are very useful and versatile in assembly, they give names to memory locations that will be figured out later by the assembler or the linker. This is similar to declaring variables by name, but abides by some lower level rules. For example, locations declared in sequence will be located in memory next to one another.\n\nUnlike in high level languages where arrays can have many dimensions and are accessed by indices, arrays in x86 assembly language are simply a number of cells located contiguously in memory. An array can be declared by just listing the values, as in the first example below. For the special case of an array of bytes, string literals can be used. In case a large area of memory is filled with zeroes the .zero directive can be used.\n\nModern x86-compatible processors are capable of addressing up to 232 bytes of memory: memory addresses are 32-bits wide. In the examples above, where we used labels to refer to memory regions, these labels are actually replaced by the assembler with 32-bit quantities that specify addresses in memory. In addition to supporting referring to memory regions by labels (i.e. constant values), the x86 provides a flexible scheme for computing and referring to memory addresses: up to two of the 32-bit registers and a 32-bit signed constant can be added together to compute a memory address. One of the registers can be optionally pre-multiplied by 2, 4, or 8.\n\nThe addressing modes can be used with many x86 instructions (we'll describe them in the next section). Here we illustrate some examples using the mov instruction that moves data between registers and memory. This instruction has two operands: the first is the source and the second specifies the destination.\n\nSome examples of mov instructions using address computations are:\n\nIn general, the intended size of the of the data item at a given memory address can be inferred from the assembly code instruction in which it is referenced. For example, in all of the above instructions, the size of the memory regions could be inferred from the size of the register operand. When we were loading a 32-bit register, the assembler could infer that the region of memory we were referring to was 4 bytes wide. When we were storing the value of a one byte register to memory, the assembler could infer that we wanted the address to refer to a single byte in memory.\n\nHowever, in some cases the size of a referred-to memory region is ambiguous. Consider the instruction mov $2, (%ebx). Should this instruction move the value 2 into the single byte at address EBX? Perhaps it should move the 32-bit integer representation of 2 into the 4-bytes starting at address EBX. Since either is a valid possible interpretation, the assembler must be explicitly directed as to which is correct. The size prefixes b, w, and l serve this purpose, indicating sizes of 1, 2, and 4 bytes respectively.\n\nMachine instructions generally fall into three categories: data movement, arithmetic/logic, and control-flow. In this section, we will look at important examples of x86 instructions from each category. This section should not be considered an exhaustive list of x86 instructions, but rather a useful subset. For a complete list, see Intel's instruction set reference.\n\nWe use the following notation:\n\nIn assembly language, all the labels and numeric constants used as immediate operands (i.e. not in an address calculation like 3(%eax,%ebx,8)) are always prefixed by a dollar sign. When needed, hexadecimal notation can be used with the 0x prefix (e.g. $0xABC). Without the prefix, numbers are interpreted in the decimal basis.\n\nand, or, xor — Bitwise logical and, or, and exclusive or\n\nThe x86 processor maintains an instruction pointer (EIP) register that is a 32-bit value indicating the location in memory where the current instruction starts. Normally, it increments to point to the next instruction in memory begins after execution an instruction. The EIP register cannot be manipulated directly, but is updated implicitly by provided control flow instructions.\n\nWe use the notation <label> to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,\n\nThe second instruction in this code fragment is labeled. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name. This label is just a convenient way of expressing the location instead of its 32-bit value.\n\nTo allow separate programmers to share code and develop libraries for use by many programs, and to simplify the use of subroutines in general, programmers typically adopt a common calling convention. The calling convention is a protocol about how to call and return from routines. For example, given a set of calling convention rules, a programmer need not examine the definition of a subroutine to determine how parameters should be passed to that subroutine. Furthermore, given a set of calling convention rules, high-level language compilers can be made to follow the rules, thus allowing hand-coded assembly language routines and high-level language routines to call one another.\n\nIn practice, many calling conventions are possible. We will describe the widely used C language calling convention. Following this convention will allow you to write assembly language subroutines that are safely callable from C (and C++) code, and will also enable you to call C library functions from your assembly language code.\n\nThe C calling convention is based heavily on the use of the hardware-supported stack. It is based on the push, pop, call, and ret instructions. Subroutine parameters are passed on the stack. Registers are saved on the stack, and local variables used by subroutines are placed in memory on the stack. The vast majority of high-level procedural languages implemented on most processors have used similar calling conventions.\n\nThe calling convention is broken into two sets of rules. The first set of rules is employed by the caller of the subroutine, and the second set of rules is observed by the writer of the subroutine (the callee). It should be emphasized that mistakes in the observance of these rules quickly result in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care should be used when implementing the call convention in your own subroutines.\n\nA good way to visualize the operation of the calling convention is to draw the contents of the nearby region of the stack during subroutine execution. The image above depicts the contents of the stack during the execution of a subroutine with three parameters and three local variables. The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer. Above the parameters on the stack (and below the base pointer), the call instruction placed the return address, thus leading to an extra 4 bytes of offset from the base pointer to the first parameter. When the ret instruction is used to return from the subroutine, it will jump to the return address stored on the stack.\n\nTo make a subrouting call, the caller should:\n• Before calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack (so they can be restore after the subroutine returns.\n• To pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e. last parameter first). Since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).\n• To call the subroutine, use the instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code. This invokes the subroutine, which should follow the callee rules below.\n\nAfter the subroutine returns (immediately following the call instruction), the caller can expect to find the return value of the subroutine in the register EAX. To restore the machine state, the caller should:\n• Remove the parameters from stack. This restores the stack to its state before the call was performed.\n• Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.\n\nThe code below shows a function call that follows the caller rules. The caller is calling a function myFunc that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in the memory location stored in EBX.\n\nNote that after the call returns, the caller cleans up the stack using the add instruction. We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.\n\nThe result produced by myFunc is now available for use in the register EAX. The values of the caller-saved registers (ECX and EDX), may have been changed. If the caller uses them after the call, it would have needed to save them on the stack before the call and restore them after it.\n\nThe definition of the subroutine should adhere to the following rules at the beginning of the subroutine:\n• Push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions: This initial action maintains the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. When a subroutine is executing, the base pointer holds a copy of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller is not expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.\n• Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number and size of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables (i.e., ). As with parameters, local variables will be located at known offsets from the base pointer.\n• Next, save the values of the callee-saved registers that will be used by the function. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI, and ESI (ESP and EBP will also be preserved by the calling convention, but need not be pushed on the stack during this step).\n\nAfter these three actions are performed, the body of the subroutine may proceed. When the subroutine is returns, it must follow these steps:\n• Leave the return value in EAX.\n• Restore the old values of any callee-saved registers (EDI and ESI) that were modified. The register contents are restored by popping them from the stack. The registers should be popped in the inverse order that they were pushed.\n• Deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer: . This works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.\n• Immediately before returning, restore the caller's base pointer value by popping EBP off the stack. Recall that the first thing we did on entry to the subroutine was to push the base pointer to save its old value.\n• Finally, return to the caller by executing a instruction. This instruction will find and remove the appropriate return address from the stack.\n\nNote that the callee's rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function.\n\nHere is an example function definition that follows the callee rules:\n\nThe subroutine prologue performs the standard actions of saving a snapshot of the stack pointer in EBP (the base pointer), allocating local variables by decrementing the stack pointer, and saving register values on the stack.\n\nIn the body of the subroutine we can see the use of the base pointer. Both parameters and local variables are located at constant offsets from the base pointer for the duration of the subroutines execution. In particular, we notice that since parameters were placed onto the stack before the subroutine was called, they are always located below the base pointer (i.e. at higher addresses) on the stack. The first parameter to the subroutine can always be found at memory location (EBP+8), the second at (EBP+12), the third at (EBP+16). Similarly, since local variables are allocated after the base pointer is set, they always reside above the base pointer (i.e. at lower addresses) on the stack. In particular, the first local variable is always located at (EBP-4), the second at (EBP-8), and so on. This conventional use of the base pointer allows us to quickly identify the use of local variables and parameters within a function body.\n\nThe function epilogue is basically a mirror image of the function prologue. The caller's register values are recovered from the stack, the local variables are deallocated by resetting the stack pointer, the caller's base pointer value is recovered, and the ret instruction is used to return to the appropriate code location in the caller."
    },
    {
        "link": "https://stackoverflow.com/questions/9617877/assembly-jg-jnle-jl-jnge-after-cmp",
        "document": "Addition and subtraction in two's complement is the same for signed and unsigned numbers\n\nThe key observation is that CMP is basically subtraction, and:\n\nThis allows for example hardware developers to implement it more efficiently with just one circuit.\n\nSo when you give input bytes to the x86 ADD instruction for example, it does not care if they are signed or not.\n\nHowever, ADD does set a few flags depending on what happened during the operation:\n• None carry: unsigned addition or subtraction result does not fit in bit size, e.g.: 0xFF + 0x01 or 0x00 - 0x01 For addition, we would need to carry 1 to the next level.\n• None sign: result has top bit set. I.e.: is negative if interpreted as signed.\n• None overflow: input top bits are both 0 and 0 or 1 and 1 and output inverted is the opposite. I.e. signed operation changed sigedness in an impossible way (e.g. positive + positive or negative\n\nWe can then interpret those flags in a way that makes comparison match our expectations for signed or unsigned numbers.\n\nThis interpretation is exactly what JA vs JG and JB vs JL do for us!\n\nHere is GNU GAS a code snippet to make this more concrete:\n\nNote that AT&T syntax is \"backwards\": . So you have to mentally reverse the operands for the condition codes to make sense with . In Intel syntax, this would be\n\nAfter this point, the following jumps would be taken:\n\nNote how in this particular example the signedness mattered, e.g. JB is taken but not JL.\n\nEquals / Negated versions like JLE / JNG are just aliases\n\nBy looking at the Intel 64 and IA-32 Architectures Software Developer's Manuals Volume 2 section \"Jcc - Jump if Condition Is Met\" we see that the encodings are identical, for example:"
    },
    {
        "link": "https://forum.cheatengine.org/viewtopic.php?t=570083",
        "document": "So if you're here, it's likely because you've been trying out new cheat tables for new games, and \n\n instead of addresses and pointers you see scripts everywhere. You check these scripts, think \n\n \"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that). \n\n I'm going to teach you what these scripts do, why they're used so often nowadays, and how to make \n\n them yourself. First, I think that a brief history of the stages/techniques used in game hacking \n\n is in order so you know we do this the way we do. \n\n \n\n This tutorial assumes that you have at least a basic understanding of cheat engine. \n\n If you don't know how to find and edit stuff in games at all yet, go somewhere else first. \n\n \n\n \n\n \n\n \n\n The first and most basic type of game hacking most people are familiar with is static RAM editing. \n\n You find an address and whatever tool you're using keeps resetting it to a certain value very quickly \n\n to \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this. \n\n These codes were generally short and simple. For example the code to always have the cape in \n\n Super Mario World for the SNES is 7E001902. \n\n \n\n We can break this down into...\n• 7E: Bank of memory to work on. 7E is the RAM bank.\n• 0019: The memory address to edit. This is the SNES so there's not that many possible addresses in RAM!\n• 02: The value to set it to (in this case the cape). The basic idea of just having a single address to edit every time applies on the PC too, but is usually only \n\n useful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games that \n\n still use static addresses for the player data. The main downside to this is that if a game doesn't \n\n load it's data into the exact same places each run, then you'll have to rescan every time you play. \n\n \n\n \n\n \n\n \n\n As systems and games got more complex, they stopped holding the same things in the exact same memory \n\n addresses every single time in order to account for varying numbers of players and entities and monsters \n\n and rules in effect. Since the memory locations were shifting around, pointers are used to keep track \n\n of what exists where. This is what most people will be familiar with as more advanced cheating, because \n\n you can use certain methods/tools to find out the pointer paths and then lock/change the final address. \n\n \n\n But even though pointers tend to work after a game has been restarted multiple times, this shares a \n\n downside with just locking the address manually (since that's all that's being done). On the PC, tools \n\n like Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosen \n\n value multiple times a second. In many cases this is enough, but if, for example, your character only \n\n has 100 max HP and you take an attack of 115 damage... in most cases you still die. This is because \n\n the game's logic is running much faster than CE can reset the value, so the game realizes that you \n\n died in that split second. Obviously something other than RAM locking is needed to get around this. \n\n \n\n \n\n \n\n \n\n So, given the above example, how would somebody stop dying if they're dealt more damage than they have \n\n health? The code that deals damage in the first place should be edited. This was the idea behind \n\n the old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM, \n\n to change some data around to make the game run differently. After all, you don't need to keep \n\n finding and locking your money amount if you edit the game's code so that your money is never \n\n taken away when you buy something! \n\n \n\n \"But Rydian, if this is so much more powerful, why did all the Game Genie codes suck ass? If they could make \n\n us invincible or anything they wanted why did they keep making each apple picked up worth 5 apples instead?\" \n\n This boils down to two big flaws in the original Game Genie's idea and implementation.\n• Without any way to debug/trace what games were doing, making your own codes as a customer is a \n\n shot in the dark. Edit random bytes and see what happens, keep the few positive things as codes, \n\n discard all the crashy/negative things.\n• The Game Genie's codes were encrypted, and it wasn't until a few years later that people would \n\n publicly make converters to allow you to tell the Game Genie to edit arbitrary ROM reads. These two things combined made it so that the only good/targeted codes were from Galoob itself \n\n (or whoever was doing the distribution of the device at the time). Thankfully that's not the case with \n\n the PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engine \n\n actually has it's own debugger and tons of other tools (that are hidden by default) that are \n\n specifically geared towards making cheats. \n\n \n\n \n\n \n\n \n\n For this example I'm going to be using the original version of Cave Story for the PC (which is freeware, \n\n not to be confused with Cave Story+ or the Wii/3DS releases). \n\n Download it here, and there's a link to the translation patch too. \n\n \n\n The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls. \n\n Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in this \n\n case we want to find health. Change it to make sure you found the right value. \n\n \n\n \n\n \n\n Next you want to right-click that table entry, and choose \"Find What Writes To This Address\". \n\n That will bring up a new window that logs any bits of code that change that address. Go back to the \n\n game and get hit or something a few times and you'll see one or more entries show up in the list. \n\n \n\n \n\n \n\n Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry that \n\n comes up when you get hit (each different type of effect on the health will usually have it's own \n\n entry and they're numbered by how often they happened), then click that \"Show Disassembler\" button \n\n on the right to open up the Memory Viewer window, which is where the magic is. This is a big window, \n\n but right now we're only concerned with the top half of it. Scroll up a bit so the targeted line \n\n is more or less centered. \n\n \n\n \n\n \n\n What we see right there is the actual assembly that makes up the running game. It doesn't matter \n\n which language a game is written in or which engine it runs on. Anything that runs is assembly \n\n one way or the other. For example you don't run C++ code itself, you put C++ code through the \n\n compiler, which turns it into assembly (more or less). Even interpreted languages like Javascript \n\n get turned into assembly when they run. So if you can edit assembly in RAM, then you can edit any \n\n program's behavior, no matter what language it was written in. \n\n \n\n At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbie \n\n instruction list, but I will run over some of the very basics you need to know in this instance. \n\n \n\n That \"mov\" instruction that's highlighted is what takes the new calculated health amount and sets \n\n our health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\", \n\n which describes the \"mov\" command. Any time you have an operation/line highlighted, that little \n\n box will show you what it stands for. \n\n \n\n The syntax is generally (operation) (destination),(source). So for the mov command, it's moving \n\n whatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like \n\n $currenthealth = $calculatedhealth; in a more modern language. \n\n And the command above that is a subtraction. \n\n \n\n You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can, \n\n for this type of work, think of a register as the simplest form of a variable there is. It's \n\n actually physical memory housed inside the CPU itself. \n\n \n\n \n\n \n\n So in this case we can see that there's math done to determine the damage, then the game moves \n\n the new health into the current health. So if we want to stop taking damage, we can edit either \n\n of these. If we remove the subtraction, your health is never lowered. If we remove the mov right \n\n after it, then even though the game determines what your new health be, it never \n\n becomes that value. In this case we'll focus on the subtraction. \n\n \n\n The simplest kind of edit we can do is to make one of the operations simply not happen. To do this, \n\n we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\". \n\n In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for game \n\n cheating, actually has a quick function to do that, which we'll use just for example. \n\n \n\n Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code That \n\n Does Nothing\". Hit enter for the default on the prompt, and you should see the change. \n\n \n\n \n\n \n\n And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have \n\n 3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay! \n\n \n\n But that was just a quick example to show you the context. You'll rarely be doing that normally, \n\n except for testing. So in the Memory Viewer window again, right-click the edited code and choose \n\n \"Restore with original code\", because we're going to do something else. \n\n \n\n \n\n \n\n \n\n So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to write \n\n a script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go to \n\n Tools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code and \n\n then Template - Code Injection (and hit okay on the default). \n\n \n\n This should make Cheat Engine fill in the Auto Assembly window with something that looks like this, \n\n which is the basic framework you need to customize the game's code. I've marked out, in a basic sense, \n\n which each segment does. \n\n \n\n \n\n \n\n So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in the \n\n original code for us automatically, but we can do whatever we want. For now though, what you want to \n\n do is hit File - Assign To Current Cheat Table, then close the existing window. This is important, \n\n do NOT hit the \"execute\" button. Assign it to the cheat table, then re-open it from there, and the \n\n \"execute\" button will be replaced with \"ok\" (which just saves the script). \n\n \n\n Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking it \n\n like a normal cheat), feel free to replace or modify the original code. For example change the \"sub\" \n\n into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Engine \n\n will interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to. \n\n \n\n The way this works is that Cheat Engine will overwrite the original code with a jump to some new code, \n\n and then include whatever code you want, which then jumps back at the end. This means that you can \n\n insert new code as well, so if you wanted to change the math or logic being done, you generally have \n\n enough room to write a small little assembly routine there to do whatever, so have fun with it. \n\n \n\n \n\n \n\n \n\n \n\n Note: this section assumes that you've messed around with assembly editing in Cheat Engine enough \n\n to have a basic grasp of the concept and know what you're doing. \n\n \n\n So making a script that edits the game code is a great way to get around moving memory addresses. \n\n You don't need to scan for pointers or watch changing addresses when you edit the game code to control \n\n things. But... newer games (especially ones written in .NET and such) don't even load their code in \n\n the same order each time! So we need a way to find where certain code snippets are, and then \n\n reference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list of \n\n values in RAM. \n\n \n\n You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the table \n\n like before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n So if you're here, it's likely because you've been trying out new cheat tables for new games, andinstead of addresses and pointers you see scripts everywhere. You check these scripts, think\"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that).I'm going to teach you what these scripts do, why they're used so often nowadays, and how to makethem yourself. First, I think that a brief history of the stages/techniques used in game hackingis in order so you knowwe do this the way we do.This tutorial assumes that you have at least a basic understanding of cheat engine.If you don't know how to find and edit stuff in games at all yet, go somewhere else first.The first and most basic type of game hacking most people are familiar with is static RAM editing.You find an address and whatever tool you're using keeps resetting it to a certain value very quicklyto \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this.These codes were generally short and simple. For example the code to always have the cape inSuper Mario World for the SNES is 7E001902.We can break this down into...The basic idea of just having a single address to edit every time applies on the PC too, but is usually onlyuseful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games thatstill use static addresses for the player data. The main downside to this is that if a game doesn'tload it's data into the exact same places each run, then you'll have to rescan every time you play.As systems and games got more complex, they stopped holding the same things in the exact same memoryaddresses every single time in order to account for varying numbers of players and entities and monstersand rules in effect. Since the memory locations were shifting around, pointers are used to keep trackof what exists where. This is what most people will be familiar with as more advanced cheating, becauseyou can use certain methods/tools to find out the pointer paths and then lock/change the final address.But even though pointers tend to work after a game has been restarted multiple times, this shares adownside with just locking the address manually (since that's all that's being done). On the PC, toolslike Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosenvalue multiple times a second. In many cases this is enough, but if, for example, your character onlyhas 100 max HP and you take an attack of 115 damage... in most cases you still die. This is becausethe game's logic is running much faster than CE can reset the value, so the game realizes that youdied in that split second. Obviously something other than RAM locking is needed to get around this.So, given the above example, how would somebody stop dying if they're dealt more damage than they havehealth? The code that deals damage in the first place should be edited. This was the idea behindthe old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM,to change some data around to make the game run differently. After all, you don't need to keepfinding and locking your money amount if you edit the game's code so that your money is nevertaken away when you buy something!This boils down to two big flaws in the original Game Genie's idea and implementation.These two things combined made it so that the only good/targeted codes were from Galoob itself(or whoever was doing the distribution of the device at the time). Thankfully that's not the case withthe PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engineactually has it's own debugger and tons of other tools (that are hidden by default) that arespecifically geared towards making cheats.For this example I'm going to be using the original version of Cave Story for the PC (which is freeware,not to be confused with Cave Story+ or the Wii/3DS releases).The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls.Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in thiscase we want to find health. Change it to make sure you found the right value.Next you want to right-click that table entry, and choose \"Find What Writes To This Address\".That will bring up a new window that logs any bits of code that change that address. Go back to thegame and get hit or something a few times and you'll see one or more entries show up in the list.Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry thatcomes up when you get hit (each different type of effect on the health will usually have it's ownentry and they're numbered by how often they happened), then click that \"Show Disassembler\" buttonon the right to open up the Memory Viewer window, which is where the magic is. This is a big window,but right now we're only concerned with the top half of it. Scroll up a bit so the targeted lineis more or less centered.What we see right there is the actual assembly that makes up the running game. It doesn't matterwhich language a game is written in or which engine it runs on. Anything that runs is assemblyone way or the other. For example you don't run C++ code itself, you put C++ code through thecompiler, which turns it into assembly (more or less). Even interpreted languages like Javascriptget turned into assembly when they run. So if you can edit assembly in RAM, then you can edit anyprogram's behavior, no matter what language it was written in.At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbieinstruction list, but I will run over some of the very basics you need to know in this instance.That \"mov\" instruction that's highlighted is what takes the new calculated health amount and setsour health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\",which describes the \"mov\" command. Any time you have an operation/line highlighted, that littlebox will show you what it stands for.The syntax is generally (operation) (destination),(source). So for the mov command, it's movingwhatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like$currenthealth = $calculatedhealth; in a more modern language.And the command above that is a subtraction.You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can,for this type of work, think of a register as the simplest form of a variable there is. It'sactually physical memory housed inside the CPU itself.So in this case we can see that there's math done to determine the damage, then the game movesthe new health into the current health. So if we want to stop taking damage, we can edit eitherof these. If we remove the subtraction, your health is never lowered. If we remove the mov rightafter it, then even though the game determines what your new healthbe, it neverbecomes that value. In this case we'll focus on the subtraction.The simplest kind of edit we can do is to make one of the operations simply not happen. To do this,we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\".In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for gamecheating, actually has a quick function to do that, which we'll use just for example.Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code ThatDoes Nothing\". Hit enter for the default on the prompt, and you should see the change.And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay!But that was just a quick example to show you the context. You'll rarely be doing that normally,except for testing. So in the Memory Viewer window again, right-click the edited code and choose\"Restore with original code\", because we're going to do something else.So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to writea script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go toTools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code andthen Template - Code Injection (and hit okay on the default).This should make Cheat Engine fill in the Auto Assembly window with something that looks like this,which is the basic framework you need to customize the game's code. I've marked out, in a basic sense,which each segment does.So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in theoriginal code for us automatically, but we can do whatever we want. For now though, what you want todo is hit File - Assign To Current Cheat Table, then close the existing window.Assign it to the cheat table, then re-open it from there, and the\"execute\" button will be replaced with \"ok\" (which just saves the script).Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking itlike a normal cheat), feel free to replace or modify the original code. For example change the \"sub\"into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Enginewill interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to.The way this works is that Cheat Engine will overwrite the original code with a jump to some new code,and then include whatever code you want, which then jumps back at the end. This means that you caninsert new code as well, so if you wanted to change the math or logic being done, you generally haveenough room to write a small little assembly routine there to do whatever, so have fun with it.Note: this section assumes that you've messed around with assembly editing in Cheat Engine enoughto have a basic grasp of the concept and know what you're doing.So making a script that edits the game code is a great way to get around moving memory addresses.You don't need to scan for pointers or watch changing addresses when you edit the game code to controlthings. But... newer games (especially ones written in .NET and such) don't even load their code inthe same order each time! So we need a way to find where certain code snippets are, and thenreference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list ofvalues in RAM.You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the tablelike before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan for \n\n certain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known here \n\n as a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable). \n\n Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes. \n\n In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disable \n\n section writes the original bytes back (2B C8, which was the sub). \n\n \n\n Instead of using \"db\", you could just write out your assembly normally, but with this kind of simple \n\n replacement you can't add more code than was already there, you're only limited to the number of bytes \n\n that already exist, so I usually just use db to keep it simple and remind myself of the limits. \n\n \n\n \"But wait, what the hell are the bytes at the beginning of the scripts?\" \n\n Well... it's the snippet of code we want to find/target. \n\n \n\n \n\n \n\n If you start with the line of code that you want to edit and then select it and a few more instructions \n\n after it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy the \n\n string of bytes for you to paste right into the template (and make sure to change the [DISABLE] section \n\n to put the right new bytes back too). \n\n \n\n So there's a basic and direct AOB assembly replacement script for making minor changes. \n\n \n\n It's very important to remember that when you're manually overwriting bytes like this (without \n\n injection) that the replacement and disable bytes need to account for eachother. \n\n \n\n For example this below code handles it properly... \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan forcertain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known hereas a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable).Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes.In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disablesection writes the original bytes back (2B C8, which was the sub).Instead of using \"db\", you could just write out your assembly normally, but with this kind of simplereplacement you can't add more code than was already there, you're only limited to the number of bytesthat already exist, so I usually just use db to keep it simple and remind myself of the limits.Well... it's the snippet of code we want to find/target.If you start with the line of code that you want to edit and then select it and a few more instructionsafter it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy thestring of bytes for you to paste right into the template (and make sure to change the [DISABLE] sectionto put the right new bytes back too).So there's a basic and direct AOB assembly replacement script for making minor changes.It's very important to remember thatthat the replacement and disable bytes need to account for eachother. \n\n However this below code it just asking for crashes... \n\n \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It's \n\n also the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytes \n\n modified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection \n\n (step 7) template, in which CE allocates your own little code space and shuffles things around for you. \n\n \n\n \n\n \n\n \n\n \n\n So let's say you've made some aobscans for various games. Some of them work just fine, but others stop \n\n enabling after a restart of the game or something. This just means that you need to find better \n\n signatures (the sequence of bytes to search for). The two main things you can do to improve your \n\n signatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up or \n\n down more and then refer to it with an offset in order to target a more unique string of data. \n\n \n\n For the wildcards, let's take our Cave Story example aobscan and look at it closer. \n\n \n\n \n\n \n\n The bytes I've circled in red are the kinds of things you usually don't want to reference directly. \n\n They're memory addresses that may change from one run to another. (This isn't the case with Cave Story \n\n specifically, but tons of games do this). So in order to avoid referencing that data directly, we'll \n\n just use wildcards. We replace the that can change with a question joe. \n\n \n\n So... \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It'salso the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytesmodified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection(step 7) template, in which CE allocates your own little code space and shuffles things around for you.So let's say you've made some aobscans for various games. Some of them work just fine, but others stopenabling after a restart of the game or something. This just means that you need to find bettersignatures (the sequence of bytes to search for). The two main things you can do to improve yoursignatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up ordown more and then refer to it with an offset in order to target a more unique string of data.For the wildcards, let's take our Cave Story example aobscan and look at it closer.The bytes I've circled in red are the kinds of things you usually don't want to reference directly.They're memory addresses that may change from one run to another. (This isn't the case with Cave Storyspecifically, but tons of games do this). So in order to avoid referencing that data directly, we'lljust use wildcards. We replace thethat can change with a question joe.So... \n\n \n\n Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things \n\n (four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcards \n\n you have, the less unique your signature is, so you may need to add more bytes to search for at the \n\n end if you have a lot of wildcards. \n\n \n\n Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimes \n\n you have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbers \n\n that keep changing. That's okay, you can search ahead of the function you want to work off of too! \n\n \n\n So here's the same code, but using both techniques. \n\n \n\n \n\n \n\n \n\n \n\n \n\n Now that you know the basics of how to edit game code and what an AOB and such is, you can take a much \n\n shorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least \n\n 6.4, that's when this feature was included. When you target some code and open up the AA window, this time \n\n go to Template - Cheat Table Framework and then Template - AOB Injection. \n\n \n\n \n\n \n\n It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AA \n\n window, and this is usually what you want anyways. \n\n \n\n \n\n \n\n Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table. \n\n \n\n \n\n \n\n Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code you \n\n targeted, but once it's done it'll present you with a nice AOB injection template. \n\n \n\n \n\n \n\n As before, the orange box indicates the copy of the original game code that will be injected for you to change. \n\n \n\n \n\n \n\n \n\n Once you go off to start making your own things for games, you'll likely run into situations where games use \n\n floats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but the \n\n thing is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands for \n\n loatingpoint oreand op (more or less). This unfortunately means that not only does \n\n the instruction modify the target value, but it also modifies the stack . Stack modification is very important \n\n to keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games. \n\n \n\n This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoid \n\n removing them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do is \n\n overwrite the results instead. For example let's say that this is our target function here, an fstp. \n\n \n\n \n\n \n\n Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injection \n\n template like you were shown earlier in this guide. Once you do that, look at the code section as usual... \n\n \n\n \n\n \n\n Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instruction \n\n there which will set it to the value we specifically want. The easiest way to do this is with a mov. \n\n \n\n \n\n \n\n And with that, the code shouldn't cause odd problems or crash the game anymore. Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things(four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcardsyou have, the less unique your signature is, so you may need to add more bytes to search for at theend if you have a lot of wildcards.Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimesyou have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbersthat keep changing. That's okay, you can search ahead of the function you want to work off of too!So here's the same code, but using both techniques.Now that you know the basics of how to edit game code and what an AOB and such is, you can take a muchshorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least6.4, that's when this feature was included. When you target some code and open up the AA window, this timego to Template - Cheat Table Framework and then Template - AOB Injection.It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AAwindow, and this is usually what you want anyways.Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table.Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code youtargeted, but once it's done it'll present you with a nice AOB injection template.As before, the orange box indicates the copy of the original game code that will be injected for you to change.Once you go off to start making your own things for games, you'll likely run into situations where games usefloats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but thething is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands forloatingpointoreandop (more or less). This unfortunately means that not only doesthe instruction modify the target value,. Stack modification is very importantto keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games.This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoidremoving them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do isoverwrite the results instead. For example let's say that this is our target function here, an fstp.Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injectiontemplate like you were shown earlier in this guide. Once you do that, look at the code section as usual...Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instructionthere which will set it to the value we specifically want. The easiest way to do this is with a mov.And with that, the code shouldn't cause odd problems or crash the game anymore. \n\n\n\nLast edited by Rydian on Thu Oct 29, 2015 7:30 am; edited 5 times in total"
    },
    {
        "link": "https://wiki.cheatengine.org/index.php?title=Tutorials:Cheat_Engine_Tutorial_Guide_x64",
        "document": "So let's go through the Cheat Engine Tutorial (x64).\n\nSo open Cheat Engine, then in the main menu select help then select Cheat Engine Tutorial.\n\nThen attach to the Cheat Engine Tutorial process, it should be 'Tutorial-x86_64.exe'.\n\nWhen the tutorial launches you should see some thing like this, you can just click the next button after reading the help text.\n\nSave the password in later steps in case of crashes (from injections) and for restarting at a later time.\n\nSo for step 2 you will see some thing like this.\n\nWhat we need to find is the health, and here it's an integer.\n\nSo setup the memory scanner to find an integer and for exact value scan then set the value to the current health value, most integers will be stored in a 4 byte variable, so let's start there.\n\nNote: Integers can be stored in a 1 byte variable (byte), 2 byte variable (int16/short), 4 byte variable (int32/int), or 8 byte variable (int64/long).\n\nWhen ready click the first scan button.\n\nYou Should see a list of addresses, in the found address list, like this.\n\nNow Click the hit me button, then reenter the current value and click the next scan button.\n\nNote the red value in the list, this shows that the value has changed.\n\nAfter clicking next scan you may need to keep clicking hit me and rescanning tell the found address list is small enough to work with.\n\nJust double click the address in the found list to add it to the cheat table. Then change the value and freeze the address, double click the value in the address list to edit it, freeze it by clicking the enabler/freeze box.\n\nNow the next button should be enabled, click it to go to the next step. Click the hit me button again if the next button is not enabled already.\n\nWhen you start step 3 you should see the form looking like this.\n\nLike the help text said make sure to click the new scan button before starting new scans.\n\nThis clears the found results to start scanning for a new value.\n\nHere is where I suggest going ahead and clicking the hit me button, just to see how the value is decreased to help in determining what value type to scan for.\n\nNote that the value was decreased by an integer, that is a non fractional number.\n\nSo I would setup the scanner for 4 bytes and unknown initial value. Then click the first scan button.\n\nNow click the hit me button.\n\nThen set the scan type to decreased value and click the nest scan button.\n\nNote the number of found addresses, this is kinda small for most games these days, the found results can easily be in the millions for most games.\n\nNow just keep decreasing the value with the hit me button, and scanning for a decreased value, until the found results is small enough to work with.\n\nNow we just pick an address and change the value to see if it has the desired effect, this is just how it works.\n\nHere is where I suggest that you always note the values (or just Ctrl+C) before changing them to set them back if they are not the right value, to keep from changing a bunch of unknown addresses and corrupting your save files when doing this in games.\n\nThe next button should become enabled as soon as you set the value to 5000. After changing the value and clicking the hit me button the progress bar should fill, but this is not needed.\n\nNow the next button should be enabled, click it to go to the next step. Click the hit me button again if the next button is not enabled already.\n\nWhen you start step 4 you should see the form looking like this.\n\nSo click the new scan button. Then setup the scanner for a float, exact value, enter the current health value.\n\nWhen setup click the first scan button.\n\nSo just scan like before to find the health address, then add it to the address list.\n\n\n\n Now click the new scan button again. Then setup the scanner for a double, exact value, enter the current ammo value.\n\nWhen setup click the first scan button.\n\nSo just scan like before to find the ammo address, then add it to the address list.\n\nNow change the values to 5000, then the next button should become enabled. Then click the next button to progress to the next step.\n\nWhen you start step 5 you should see the form looking like this.\n\nSo first find the value then add it to the address list.\n\nGo ahead and save the table and the password at this point, just in case the debugger isn't setup right.\n\nAfter you have the address in the address list right click it then select find out what accesses this address.\n\nCheat Engine will prompt you about attaching the debugger, just click the yes button.\n\nThen a debugger form will open, now click the change value button, and you should get code that shows up in the debugger form.\n\nWhat we want is a write instruction. So we will be looking for some thing like one of the following:\n\nSelect the code line of the write instruction, you can click the show disassembler button to see the code in memory, then click the replace button.\n\nThe replace button will replace that line of code with NOPs.\n\nCheat Engine will prompt you for a name for the entry it will add in the advanced options list.\n\nEnter a name and click the OK button.\n\nNow click the change value button back on the tutorial.\n\nThe next button should become enabled, then click the next button to advance to the next step.\n\n\n\n When entries in the advanced options list are replaced, they will show up with red text.\n\nThe advanced options list can be viewed by clicking the advanced options button in the status bar on the bottom left corner of the Cheat Engine main form.\n\nTo restore the original code for an entry in the list, right click the entry and select restore with original code.\n\nNote that the text is black after restoring.\n\nWhen you start step 6 you should see the form looking like this.\n\nSo first find the value then add it to the address list.\n\nAfter you have the address in the address list right click it then select find out what accesses this address.\n\nThen click the change value button, to have the process access the address.\n\nWhen choosing the code to find the base address for the pointer, try to select an instruction that doesn't write to the same register as the base address.\n\nHere we're interested in the value between the square brackets ('[' and ']'), so here we want the value of RDX.\n\nmeans it writes the content of the EAX register into the memory address pointed by the RDX register. We should choose this instruction, because we are looking for who is modifying the content of memory address 012348D0, which we can see is stored in RDX register.\n\nThe offset here is 0, if the instruction had some thing like this:\n\nThen the offset would be '12C' (0x12C), note that this is in hex.\n\nNow we want to find out which pointer points to the interested address 012348D0 we found before. Set the scanner for 8 bytes, exact value, check the hex check box, then take the value found and put that as the value to scan for.\n\nWhen ready click the first scan button.\n\nLook in the found address list for address with green text, these are static addresses.\n\nNow we want to trace this pointer, so that whenever its content changes (which means it points to a different memory location), we will be able to modify the new memory address. Add the pointer we just found to the cheat table, double click the address of the memory record that was added to the address list, copy the address then check the pointer check box, and paste the address in the pointers base address.\n\nSo my pointer will look like this.\n\nIt should be setup some thing like this, remember to set the offset to the offset you found.\n\nClick the OK button when the pointer is setup.\n\nNow freeze the value at 5000 and click the change pointer button, the next button should become enabled.\n\nIf the next button doesn't become enabled then select another address from the found list, look for a green one that had it's value changed, and set it up like the last one and see if it points to the right value, if so change the value freeze and click the change pointer button.\n\nClick the next button to advance to the next step.\n\nWhen you start step 7 you should see the form looking like this.\n\nHere we'll follow the the same procedures as step 5, but instead of clicking replace click the show disassembler button.\n\nThis will open the disassembler view form at the instruction's address.\n\nWith the instruction selected press Crtl+A, to open an auto assembler form.\n\nIn the auto assembler form menu select template then select full injection.\n\nThis will generate some script to start you out.\n\nNow we need to add some code that will increase the value by 2, then remove the original code that decreases the value.\n\nFor increasing the value we can use INC or ADD.\n\nSo let's try some thing like this.\n\nNow add the script to the cheat table.\n\nThen enable the script and click the hit me button.\n\nThis should enable the next button, so click the next button to go to the next step.\n\nWhen you start step 8 you should see the form looking like this.\n\nSo here we will follow the same steps as step 6, except we'll see what accesses the base address we find, and we'll keep repeating this until a static base is found.\n\nSo here is my first debugger output.\n\nI did find a static base on the first scan of the base address but I remember this being a false base. So here what we want is a base address in the form of 'process.exe+offset', you can try one of the others that look like 'module.dll+offset' but I want to say that here they will prove to be false pointers. And yes most newer games will have many false values and pointers.\n\nAnd the debugger output from the address holding: 0000000001287960\n\nAnd the debugger output from the address holding: 0000000002D6D540\n\nAnd the debugger output from the address holding: 0000000002D6CE40\n\n\n\n Now we scan for that base '000000000123F1C0' and you should find a static address, but in real games you would keep going until a static base is found.\n\nWith that static address as the base my pointer will look like this.\n\nThe pointer scan can be used to solve this quickly by first finding the address of the desired value, saving a generated pointer map, restarting the game, searching for the address again, saving another pointer map, and then comparing the two. More information can be found in Help_File:Pointer_scan.\n\nAfter you have found the pointer, freeze it at 5000, then click the change pointer button. If you found the right base the next button should become enabled after about 2 seconds. So click the next button to go to the next step.\n\nWhen you start step 9 you should see the form looking like this.\n\nSo here like the help text says there is far more than one solution.\n\nFirst we need to find one of the addresses and add it to the table.\n\nIf you are having trouble finding an address, remember to try different value types, and don't forget to start new scans.\n\nThen like in step 7 we want to see what accesses the address, to find the function that writes to the actor's health.\n\nGo ahead and save the password if you want to try different ways, this is the last step in the tutorial.\n\nSo here it's good to understand what we're actually looking for to tell allies and combatants apart.\n\nWhen the game or engine is written, actors and players might be written like this.\n\n//// Actor, base for all actors class Actor(object){ string Name = 'Actor'; Coord Coords = new Coord(0, 0, 0); float Health = 100.0; ... } //// Player class Player(Actor){ //// Player inherits form Actor string Name = 'Player'; int Team = 1; ... }\n\nThe team it self could be a structure, say if it's declared as an object class like the 'Coords' variable, which we would want to look for a pointer to the actor's team structure.\n\nSo one way we could do this is to find the team id or team structure in the player structure.\n\nFind the team id in the player structure\n\nAfter you have found the function that decreases health.\n\nRight click the instruction in the disassembler view form, and select find out what addresses this instruction accesses.\n\nThen click the attack button for all 4 values.\n\nYou should have all 4 addresses in the debugger list.\n\nSo go ahead and add them to the address list.\n\nYou'll get some pop ups, after going thought them you should see a form like this. Note that I had to expand the width of the form to be able to move the columns.\n\nNow on mine offset 0x10 was guessed as a pointer which is 8 bytes wide in a 64 bit process. I saw that the pointers at 0x10 had values that really didn't look like pointers.\n\nSo I had to switch it to 4 byte, and add a new element set it's offset to 0x14 with 4 byte value type. This is often the way it works.\n\nSo here we can see that the team variable is at offset 0x14 of the structure.\n\nNow we need to add some injection code to a script, then add some code that checks the team variable of the structure, to determine which actors are allies and which are combatants.\n\nSo we want some this like this.\n\n\n\n So with this script enabled, when the game writes to an actors health here is what will happen after the jump to the hook code:\n• Save (PUSH) the RFLAGS register, not completely needed but still a good habit when comparing.\n• Check if actor is on team 1.\n• If actor is on team 1, then we set the new value to 5000 in a floating point format.\n• Check if actor is on team 2.\n• If actor is on team 2, then we set the new value to 0 in hex format. (float 0 == int 0 == hex 0)\n• Restore (POP) the RFLAGS register, this is completely needed if the register was PUSHed.\n\n\n\n With this script enabled, click the restart game and autoplay button, then you should see the form change and look like this.\n\nSo click the next button to complete the tutorial.\n\nThen you should see a form telling you that you have completed the tutorial.\n\nAfter you have found the function that decreases health.\n\nRight click the instruction in the disassembler view form, and select find out what addresses this instruction accesses.\n\nThen click the attack button for all 4 values.\n\nYou should have all 4 addresses in the debugger list.\n\nNow let's look at the registers to see if we can find a difference in the allies and combatants.\n\nArrange the forms to make it easier to compare.\n\nSo here we can see that RSI is 1 for the combatants.\n\nSo a script like this should work.\n\n\n\n So with this script enabled, when the game writes to an actors health here is what will happen after the jump to the hook code:\n• Save (PUSH) the RFLAGS register, not completely needed but still a good habit when comparing.\n• Check if RSI register is 1.\n• If RSI register is 1, then we set the new value to 0 in hex format. (float 0 == int 0 == hex 0)\n• If RSI register is not 1, then we assume the actor is an ally so we set the new value to 5000 in a floating point format.\n• Restore (POP) the RFLAGS register, this is completely needed if the register was PUSHed.\n\nWith this script enabled, click the restart game and autoplay button, then you should see the form change and look like this.\n\nSo click the next button to complete the tutorial.\n\nThen you should see a form telling you that you have completed the tutorial."
    },
    {
        "link": "https://read.martiandefense.llc/introduction-to-cheat-engine-e49ee19544e",
        "document": "This next exploit will be modifying the health value and will be modifying them per session. So the general idea here is to show how we can use windows modules within C++ to build a working exploit that can change given values that we scanned within cheat engine. This will give us a base concept of how to load a process, how to read and write memory values to a process and then we will continue to go on from there to modifying the health information and display bar. Note that the health of the player itself is stored in a different value than the one we are going to be modifying as we again will only be modifying the counter to this display.\n\nWe are going to launch a new session and enter a game then continue to open cheat engine with the same exact settings when scanning for the ammunition counter. We will choose the exact value scan option and once in the game continue to input and scan for the value as that is the value of the health bar once we spawn. After you get your results you will realize they look like this\n\nand of course we get the major list of offsets but as you know we can go through the same process to minify it. It might be good to note that cheat engine has ways of sorting through this data but for now this is giving you a basic introduction in modifying games and in next articles we will be using more powerful tools outside of cheat engine as well as cheat engine’s lua scripting engine to figure out certain values and patterns quicker. Anyway something we need to do is lower our health, the reason we need to do this is because within the same scan we will be using the “decreased value” on next scan given the fact that we do not and will not know the damage taken from our current health or in other words the decrements taken on our health bar. Once we can get our health down low enough and then go back to cheat engine we can hit next scan and start checking value’s, in the next example we see the following.\n\nWe see a lot of red indicating changed values and of course you are going to look at the values and match them to your given states. For the health state this is still alot so if you want to you can repeat the same process until you find a number of results that is easy to parse through and continue to edit one until you find a value that fits best. When you find one you will need to go to the address and note it down for when we build our program like so.\n\nNow we can get to writing our program, pop open your VSC editior and get to work! Here we are going to create a normal windows C++ empty project and name it whatever, I named mine changer. Once done go to the solution name, right click and hit settings which will bring you to the given menu shown below.\n\nYou will want to navigate to the following and change them\n• Configuration Properties > General > C++ language standard : Change this to ISO C++ 20 Standard, this is because we want our code to be up to modern standards and do not want to be using legacy formats to write code as they can post warnings and issues that are a headache to fix.\n• Configuration Properties > Advanced > Character Set : Change the character set to multi byte keeps with strict compatibility and will help us make our program compatible with standard and functions and namespaces.\n• Once done leave that and go to the top middle of the editor and change Debug to release and x64 to x86.\n\nNow we can start creating our files, for the sake and scope of this article we will use just one giant main file for this. First start by including the necessary libraries which are as follows.\n• Windows.h: This will help us include functions that we can use to access and work with a process in windows.\n• TlHelp32.h: This file will basically allow us to operate with the memory since we will need to write values to the memory.\n• string_view: We will be using this library to work with more flexible strings\n\nFirst we are going to start creating a ProcessConstructor class which will be the class we use to access and write to the memory. Windows within multiple API’s on the system allows you to create a handle on a process then continue to read values from the process while also being able to write values back to the process. This helps in cheats because most external and some internal cheats will take advantage of these libraries by creating a handle on processes like steam.exe or csgo.exe to read and write data to those processes which in other terms is one of the main thing that powers cheats.\n• Process ID: Variable defines the process ID of the process we are loading and creating a handle on\n• Handler: This is the process handler or the variable that will hold the process handler\n• OFFSET: This is the address we will be writing data to in order to change our values of our health bar ( in my case, as it might be different on your end )\n\nOur class first defines its title and holds a public section. If you have no knowledge of OOP with C++ then every class that is declared that is accessed by other classes, namespaces, functions etc are going to need to have a public class to declare a public section or brick of code to make it visible to outside variables and functions. Under that we create a function named directly after a class name, this will be how we imitate the values and the process as this will be the function that creates the handle and snapshot on the process. After that we create a function that is known as a destructor which will close the process handle if the handler is still open after initiating the handle on the process and the process entry. Once done we then make writing to the process’s memory a bit easier by defining a better way to write to the memory which takes multiple arguments such as the address, the value to write including the data type. Once finished we call the class to load the process by name which is csgo.exe and then we start a infinite loop to write to this variable. The code to this is shown below\n\nAs you can see we create a process entry when we define the entry call, this is the function that will describe a given entry from the process list residing in the system address space when a snapshot was taken.\n\nWe then continue to get the size and create the snapshot. After the snapshot was taken we create a while loop which tells for the process in the 32 next function if the process name does not match the same as ProcEntry.szExeFile then make the new processID the process ID of ProcessEntry.th32ProcessID. Once done we create a handler to open the process and give it all access given the process ID and break from the loop. Following that we close the handle if the snapshot is still true, then create a deconstructor for the ProcessConstructor function to check if the handler is still open and if it is then we call to close that. Once finally done we can create a very long looking function which can be reduced to the following.\n\nWe create a template showing that the typename of the function WRP must be defined before we call and load arguments, this typename will help define the data type of our write argument(s). We then call the function to return void, and call the function arguments. The address is a constant of type unsigned ptr which means that this address can not be changed during write, same with the value. is formatted with type& to tell the template of the data type to define the data type of the we are writing to the address. We then call followed by the handler, then a cast to the address, then the value, the size of the type and a NULL value. The arguments to this call are as follows.\n\nFinally after finishing the call and the class we can create a function called which will return the ProcessConstructor to call functions, this function is responsible for loading the process.\n\nOnce done we can finally call our main function like so\n\nWe tell the script to only load the process once because if we throw this under the while loop we will cause a bunch of bugs in the future or we will end up crashing the program due to too much resources being used. Under the while loop we call to the result of to write to the process’s memory of type integer32 defined by followed by the offset finally writing the value to that offset which is 100. When we run this program and you made sure everything works the way it is supposed to you will be able to see that despite getting hit your health bar stays up to 100% however you will still find that you die despite your counter being up. This is because as defined above this is us just modifying the value of the counter not the actual health of the player as health is either stored in another offset or is server side and for now we can not modify this.\n\nClosing Note: It might be cool to experiment with the different values and see what glitches you can create. For example if you set the health bar to you will see the number over riding past its boundaries, but if you set it to you will see your guns get taken away, you can not switch, you can shoot but when you aim with a sniper the scope is taken away from your character and some player models may get glitched out. It is important to test this kind of stuff to explore how the internals of a game work. Closing thoughts: Todays article was very very long and it was descriptive on such a simple topic, however you may have walked away learning something new. We talked about the basics of Cheat Engine, why memory scanners are used, where they come in handy and other programs a hacker may use such as OllyDBG and IDA or even GDB to debug a program and modify or find values they can change or exploit within the game. Recon may stop when it comes to higher end games to an extent where you can not use certain debuggers because anti cheat systems will block them from creating a handle or grabbing a process. We also finally got to modifying counters and variables in CSGO then ended on writing a program to automate this fashion, it may be a good idea to explore the windows library as well as the TlHelp32 library to explore more unique ways to write to address like those or modify different values in the game. Maybe you might also want to explore cheat engine a bit differently, find values in CSGO you want or think you can change and explore from there! Cheat engine is a very powerful tool for a base introduction to the game hacking world and there is so much to it! Until next time O_O >\n\nIf you enjoy seeing more content please consider following and giving a tip!"
    },
    {
        "link": "https://medium.com/@AVTUNEY/reverse-engineering-game-memory-how-to-hack-any-game-using-cheat-engine-p-invoke-in-net-be70e2924506",
        "document": "Reverse engineering game memory has been a long-time practice among security researchers, ethical hackers, and gaming enthusiasts looking to modify in-game values. One of the most popular tools for this is Cheat Engine, which allows users to search for and modify memory values in a running game process.\n\nHowever, this technique is not limited to Cheat Engine alone. With P/Invoke (Platform Invocation Services) in .NET, we can interact with Windows API functions from to read and write process memory. In this article, we will explore how game memory modification works, how Cheat Engine helps in locating key memory addresses, and how to programmatically manipulate those values using C#.\n\nIn this article, we will explore:\n• How to identify and modify values using Cheat Engine.\n• How to programmatically alter values using P/Invoke in C#.\n\nDisclaimer: This article is for educational purposes only. Modifying game memory can violate terms of service in online games and lead to bans. Use these techniques responsibly.\n\nEvery running game stores variables such as player health, ammo, or coordinates in memory. These values are stored at specific addresses, which can be accessed and modified — if we have the right permissions.\n\nHowever, memory addresses are often dynamic (changing every time the game starts). This is where Cheat Engine helps by searching for values, tracing pointers, and allowing modifications.\n\nMemory addresses are the foundation of game hacking. Every variable in a game — whether it’s health, ammo, money, or coordinates — is stored at a specific memory address while the game is running. If we can find these addresses, we can manipulate them to alter in-game values, giving us control over certain mechanics like infinite health, unlimited ammo, or increased speed.\n\nHowever, modifying memory isn’t always straightforward. Many games use dynamic memory allocation, making the process more complex, requiring deeper knowledge of pointers and memory scanning techniques.\n\nA memory address is a unique identifier for a location in RAM where a value is stored. Think of it like a house address — every variable has its own unique location in memory where its data is kept.\n\nFor example, in a game, your player’s health might be stored at:\n\nThis means that whenever the game needs to check or update your health, it reads from and writes to this location in memory.\n\nHowever, modern games often do not use fixed addresses for important variables. Instead, they allocate memory dynamically, meaning that each time you start the game, the address where your health is stored might change. This requires us to use pointer scanning to track down the real location of the data.\n\nGames use different data types to store variables in memory:\n• Integers (int, short, long) → Used for whole numbers like health, ammo, score, or money. In Cheat Engine, these are typically 4 Bytes.\n• Floating-point numbers (float, double) → Used for precise values like speed, player coordinates, or weapon spread.\n• Strings (char[]) → Used for player names, chat messages, or dialogue texts.\n• Pointers → Used for dynamic memory management, allowing the game to reference memory addresses indirectly rather than storing values at fixed locations.\n\nMemory addresses in games can be static or dynamic. Understanding the difference is crucial for modifying values effectively.\n• A static address does not change between game sessions.\n• If your health is always stored at , it is a static address.\n• Older or simpler games (such as single-player indie games) often have static memory addresses.\n\n💡 Example:\n\nIf a game developer hardcodes health at , you can modify it directly every time the game runs.\n• Most modern games use dynamic memory allocation, meaning values are assigned new memory addresses each time the game starts.\n• If you restart the game, the value at might now store something else, while your health might be at a completely different address, such as .\n• This is why we use pointers to track dynamic memory locations.\n\n💡 Example:\n\nIn a modern FPS game, the player’s health might be dynamically allocated each time you respawn. If you only store from one game session, it won’t work when you restart.\n\nTo reliably find the real memory address, we need to use pointer scanning.\n• Open Cheat Engine and attach it to the game process.\n• Search for the current health value (e.g., if your health is 100).\n• Take damage, then scan for the new health value.\n• Repeat this process until only one or a few addresses remain.\n• If the address remains the same after restarting, it is a static address.\n\nIf the address changes after restarting, the game is using dynamic memory allocation, and we need to find pointers.\n• After finding the temporary memory address where health is stored, right-click on it in Cheat Engine and select “Find out what accesses this address.”\n• Take damage or heal in the game. Cheat Engine will show a list of instructions that modify the value.\n• Click on one of these instructions and view the pointer details.\n• Instead of modifying the temporary memory address, follow the pointer chain to the base address.\n• Use pointer scanning to track where the actual data is stored.\n\nCheat Engine works by scanning entire memory regions within a process and identifying locations where specific values are stored. It uses several techniques to refine the results:\n• Exact Value Search → If you know the exact value (e.g., health = ), you can search for it directly.\n• Unknown Initial Value → If you’re unsure, you can scan for any changing values.\n• Memory Region Analysis → Allows exploration of how the game manages different types of memory (e.g., heap vs. stack).\n\nLet’s say we want to modify a game’s health.\n• Open Cheat Engine and attach it to the process.\n• Take damage and search again for the updated value.\n• Repeat until you find the correct address.\n\nDetermine if the Address is Static or Dynamic\n• Restart the game and check if the address still holds the correct health value.\n• If it changes, the address is dynamic, and we need to find a pointer.\n• Right-click on the address in Cheat Engine and select “Find out what writes to this address.”\n• Identify the game instruction modifying the value.\n• Use pointer scanning to locate the true memory address.\n\nUsing P/Invoke in .NET to Modify Game Memory\n\nNow that we’ve learned how to find memory addresses using Cheat Engine, the next step is modifying those values programmatically. This is where P/Invoke comes in.\n\nP/Invoke, short for Platform Invocation Services, is a feature in .NET that allows C# code to call native Windows API functions. Since Windows API functions are written in C and C++, they operate outside the managed .NET environment. P/Invoke acts as a bridge that allows us to interact with system-level functions directly from C#.\n\nWhy Do We Need P/Invoke for Game Memory Hacking?\n\nMost games do not expose their internal data to external programs. Unlike applications that offer APIs, games do not provide direct access to their memory structures. Since game data is stored in protected memory, we need to bypass these restrictions to read or modify in-game values.\n\nWindows provides low-level system functions in that allow us to:\n\nWith P/Invoke, we can programmatically change game variables, just like we did manually in Cheat Engine.\n\nWe’ll be using four main Windows API functions from to interact with game memory:\n\nThis function allows us to open another process (the game) so we can read and modify its memory.\n\n🔹 Usage: This is the first step in memory hacking. Without access to the process, we cannot modify its memory.\n\nThis function allows us to read the current value stored at a given memory address in another process.\n\n🔹 Usage: We use this function to check what value is currently stored in memory, ensuring that we have found the correct memory address.\n\nThis function writes new values to a specific memory address in another process.\n\n🔹 Usage: After identifying the correct memory address, we use this function to modify the stored value.\n\nThis function closes the handle to the game process, ensuring we properly release system resources.\n\n🔹 Usage: Always close the process handle after modifying memory to avoid unnecessary system resource consumption.\n\nExample: Using P/Invoke to Modify Health in AssaultCube\n\nWe will now use P/Invoke to programmatically modify player health in the AssaultCube game.\n• Read the current health value from memory.\n• Modify the health value to 999.\n• Attach to the game process ( for AssaultCube).\n• Read the current health value stored in memory.\n• Modify the health value from whatever it was to .\n• Write the new value back into memory.\n• Close the process handle to clean up resources.\n\nP.S This was done in multiplayer match !\n• Cheat Engine helped us locate the correct memory address ( ) for health.\n• P/Invoke allows us to access and modify this address programmatically.\n\nThis is one of the simplest examples of game memory hacking using P/Invoke, but the same principles apply to ammo, money, player speed, or even AI behavior.\n\nThere are many other ways to manipulate game memory, including enabling wallhacks, aimbots, speed hacks, and more. The feasibility and methods of hacking a game depend heavily on various factors, such as:\n• The Game Engine: Different engines (Unity, Unreal Engine, Source, CryEngine, etc.) handle memory management differently. Some use encrypted values, while others rely on structured object hierarchies.\n• How the Game Stores Variables: Some games use static memory addresses, making them easier to modify, while others rely on dynamic memory allocation, requiring pointer resolution.\n• Protection Mechanisms: Many modern games implement anti-cheat systems (e.g., BattlEye, Easy Anti-Cheat, VAC), which actively detect and prevent memory manipulation.\n• Rendering API Used: Whether the game is built on OpenGL, DirectX, Vulkan, or another rendering API affects how graphics-based exploits like wallhacks or ESP (Extra Sensory Perception) work.\n• Code Obfuscation & Virtualization: Some developers use techniques like code obfuscation, function hooking prevention, or memory encryption to make hacking more difficult.\n\nWhile Cheat Engine and P/Invoke allow direct memory manipulation, more advanced techniques involve modifying the game’s logic at a deeper level. The complexity of these techniques depends on how well the game protects itself against such modifications."
    },
    {
        "link": "https://wikihow.com/Use-Cheat-Engine",
        "document": "This wikiHow teaches you how to use Cheat Engine to exploit some computer games. Cheat Engine is a memory scanning tool. It allows you to access data stored in your computer's memory and make changes to that data. This allows you to change information in a game, such as health, ammo, score, lives, and the number of things you have in your inventory.\n• Determine a game aspect to change. In order for you to be able to change a game aspect, the aspect must have a number attached to it (e.g., amount of ammo, health, or items).\n• The number must be on-screen. For example, if you want to change the number of a certain item in your inventory, you would first have to open your inventory to the page on which the item's number is available. In order for you to be able to change a game aspect, the aspect must have a number attached to it (e.g., amount of ammo, health, or items).\n• Minimize the game window and click over to Cheat Engine. You'll need to pull up the Cheat Engine window while the game is minimized.\n• Don't pause the game when you do this. You'll need to pull up the Cheat Engine window while the game is minimized.\n• Click . It's at the top of Cheat Engine next to the panel on the left. Any time you want to scan for a new value, you need to click New Scan.[4] It's at the top of Cheat Engine next to the panel on the left. Any time you want to scan for a new value, you need to click\n• Select a scan type. There are five scan types you can do when you start a new scan. The two main ones you'll be using are \"Exact Value\" and \"Unknown initial value\". Use the drop-down menu next to \"Scan Type\" to select the type of scan you want to do. The scan types are as follows:\n• Exact value: Use this scan type if you know the exact number you want to change. For example, if you know the exact number of lives, or ammo you have, you can select this option.\n• Unknown initial value: In video games, sometimes a value isn't represented with a number. For example, your health may be represented by a health meter instead of a number. In which case, you don't have an exact number for how much health you have. There is a number that represents your health, you just don't see it on-screen. In this case, you can select Unknown initial value.\n• Bigger than...:' Select this option if you don't know the exact number you're look for, but you know the smallest possible value.\n• Smaller than...: Select this option if you don't know the exact value, but you know the largest possible value.\n• Value between...: This option allows you to enter a range of values to look for. There are five scan types you can do when you start a new scan. The two main ones you'll be using are \"Exact Value\" and \"Unknown initial value\". Use the drop-down menu next to \"Scan Type\" to select the type of scan you want to do. The scan types are as follows:\n• Select a data type: The data type represents how a value is stored in the memory. It can be hard to know what data type to select, so this can take a little guesswork. Use the drop-down menu next to \"Data type\" to select a data type. If you can't find the value you are looking for using one data type, click New Scan and try again using a different data type. Some of the more common data types you will be using are as follows:\n• Bytes: 2 Bytes and 4 Bytes are the data types you'll be using most often. Most Windows applications use 4 Bytes, so start with that. You can also find these values using 2 Bytes. 1 Bytes and 8 Bytes can work as well, but you may run into problems.\n• Float: Floating point data types are values that have a decimal point in the value (though you may not see the decimal point on-screen in the game). Some times games store values as floating points to prevent simple memory scans. If you're not able to find the value you are looking for by scanning bytes, try scanning for floating points.\n• Double: Doubles are similar to floating points, but they can contain twice the amount of digits. If you are unable to find a value by scanning for bytes or floats, try scanning for it as a double.\n• All: This option scans all values of all data types. This is a good option if you don't know what you are searching for, but it will also return more search results that you will need to narrow down. The data type represents how a value is stored in the memory. It can be hard to know what data type to select, so this can take a little guesswork. Use the drop-down menu next to \"Data type\" to select a data type. If you can't find the value you are looking for using one data type, clickand try again using a different data type. Some of the more common data types you will be using are as follows:\n• Enter the value you want to change and click . For example, if you have 20 bullets left in your ammo, you would type into the \"Value\" text box. This will scan for all values that have the number \"20\" in it. This will likely produce a long list of values in the list of addresses, you'll need need to narrow it down a bit.\n• Return to your game and change the value. How you do this will depend on the game itself; for example, if you're trying to give yourself more health, you might purposefully damage your own health in order to lower the number. If you want more ammo, you might fire a couple of shots to lower your ammo count.\n• Return to Cheat Engine and scan for the updated number value. Minimize the game again and click back over to Cheat Engine. Type the new number into the \"Value\" section, then click Next Scan. This will scan all the values in your first scan and narrow down the addresses to the ones that changed to the value you entered in the \"Value\" bar.[5]\n• Unknown initial value: If you selected \"Unknown initial value\" for your first scan, select Increased value or Decreased value under \"Scan type\" depending on if the value (or meter) increased or decreased. This will scan for all values that increased or decreased instead of scanning for an exact number. Minimize the game again and click back over to Cheat Engine. Type the new number into the \"Value\" section, then click. This will scan all the values in your first scan and narrow down the addresses to the ones that changed to the value you entered in the \"Value\" bar.\n• Repeat the search process until you have 4 or fewer values. You'll keep changing the number and then searching for the updated number until you have no more than 4 values listed on the left side of Cheat Engine.\n• You should eventually see the previous number you searched for listed in the \"Previous\" column of each value's number, while the current value of the item will be in the \"Value\" column. You'll keep changing the number and then searching for the updated number until you have no more than 4 values listed on the left side of Cheat Engine.\n• Add the values to the address list. You can either double-click a value to add it to the address list at the bottom, or you can click an address to select it and click the red, diagonal arrow in the bottom-right corner of the list of values. Doing so will place the values in the list of addresses at the bottom of the window.[6]\n• To select multiple addresses, you can hold \"Shift\" and click the top address and the bottom address. You can either double-click a value to add it to the address list at the bottom, or you can click an address to select it and click the red, diagonal arrow in the bottom-right corner of the list of values. Doing so will place the values in the list of addresses at the bottom of the window.\n• Change the number to a value you want. Use the following steps to change the value number:\n• Double-click the number below \"Value\" in the list at the bottom of Cheat Engine.\n• Enter a new number in the \"Value\" field. Use the following steps to change the value number:\n• Check to see if the value updated in your game. When you re-open the game, the value you edited should reflect the number you just entered. The next part teaches you how to stop a value from changing by replacing it with non-operational code.\n• You may need to change the value one more time before it will update. When you re-open the game, the value you edited should reflect the number you just entered. The next part teaches you how to stop a value from changing by replacing it with non-operational code.\n\nReplacing Code to Stop a Value From Changing\n• Scan for a value you want to stop. This part teaches you how to use the Code Finder to find what writes to the address you want to change and then replace it with non-operational code. This will prevent the value from changing in-game. Use the steps in the previous part to find a value you want to change. Add it to the list at the bottom of the screen. This part teaches you how to use the Code Finder to find what writes to the address you want to change and then replace it with non-operational code. This will prevent the value from changing in-game. Use the steps in the previous part to find a value you want to change. Add it to the list at the bottom of the screen.\n• Right-click the address and click Find out what access this address . This opens the Cheat Engine Debugger. This displays instructions that write to the address you are accessing.\n• Click . This confirms that you want to attach the debugger to the Cheat Engine process. This opens the Code debugger. The list will be blank when the window first opens.\n• Return to the game and change the value again. Once again, return to your game and do something to change the value you want to stop. This will cause the code instruction that accesses the address you selected to appear in the debugger window.\n• Return to Cheat Engine and click the instruction in the list. There may be more than one address. If that is the case, select the one that doesn't write to the same base address. Look for the instruction that has a different value between the \"[' and \"]\" brackets than the rest.\n• Click . This replaces the code with non-operational (NOP) code.\n• If there is more than one item in the list, go ahead and select all of them. This replaces the code with non-operational (NOP) code.\n• Click . This puts the non-operational code into effect. This will prevent the value from changing in the game.[7]\n• To restore the original code, select the item in the list and clck Show disassembler. Right-click where it says \"NOP\" and click Restore with original code. If you don't see this option, click Replace with code that does nothing, click Yes. Then right-click NOP again and select Restore with orignal code. This puts the non-operational code into effect. This will prevent the value from changing in the game.\n\nUsing Pointers to Find What Writes a Value\n• Scan for a value you want to change. Sometimes values can change address either when you restart the game, or in the middle of the game. You can use pointers to find what writes to an address. Once you find the base level static address that doesn't change, you can change that value. Sometimes values can change address either when you restart the game, or in the middle of the game. You can use pointers to find what writes to an address. Once you find the base level static address that doesn't change, you can change that value.\n• Right-click the address and click Find out what writes to this address . This opens the debugger window.\n• If there is multiple addresses, open a debugger window for as many addresses as Cheat Engine will allow.\n• Return to the game and change the value again. Once again, return to your game and do something to change the value you want to change (i.e. fire your weapon, get hit). This will cause the instruction that writes to that address to appear in the debugger window.\n• If nothing changes in the debugger window, it is not the correct address. Try a different one. Once again, return to your game and do something to change the value you want to change (i.e. fire your weapon, get hit). This will cause the instruction that writes to that address to appear in the debugger window.\n• Return to Cheat Engine and click the instruction in the list. It's in the debugger window. There may be more than one address. If that is the case, look for the instruction that has a different set of characters between the \"[' and \"]\" brackets than the rest. If there isn't a single address that has different characters, check to see if the pointer is the same for all of them.\n• If the characters have a + and a number at the end (i.e. [ESI+14]). That is an offset number. Write it down. You'll need it later. It's in the debugger window. There may be more than one address. If that is the case, look for the instruction that has a different set of characters between the \"[' and \"]\" brackets than the rest. If there isn't a single address that has different characters, check to see if the pointer is the same for all of them.\n• Click . This displays instructions that happen when the value changes in the Extra Info screen. This also lists the pointer that writes to the address.\n• You can also find the address by checking the characters in the bracket, and then checking what number comes after those characters listed at the bottom. For example, if the address has \"[rdx]\" next to it, look for RDX=xxxxxxxx at the bottom. This displays instructions that happen when the value changes in the Extra Info screen. This also lists the pointer that writes to the address.\n• Click the checkbox next to \"Hex\" and do a new scan for the pointer address. The address of the pointer is listed in the text that says \"The value of the pointer needed to find this address is probably xxxxxxxxx\". Use the following steps to search for the address at the end of this sentence.\n• Click the checkbox that says \"Hex\" next to the \"Value\" field.\n• Enter the pointer address in the Value field and click First scan. The address of the pointer is listed in the text that says \"The value of the pointer needed to find this address is probably xxxxxxxxx\". Use the following steps to search for the address at the end of this sentence.\n• Double-click the pointer address. This adds the address to the list at the bottom of Cheat Engine.\n• If the address is listed in green in the scan results. This means it is a static address and probably the pointer you are looking for. In some cases, the pointer you find may also be a pointer. This is called a multilevel pointer. In this case, you'll need to repeat these steps for each pointer you find in order to find out what the root static pointer address is. This adds the address to the list at the bottom of Cheat Engine.\n• Double-click the number below \"Address\". This opens the \"Change address\" dialogue box.\n• Copy the address in the field and click . To copy the address, simply highlight the entire text in the field at the top of the \"Change address\" box. Right-click it and click Copy. Then click Cancel to close the field.[8] To copy the address, simply highlight the entire text in the field at the top of the \"Change address\" box. Right-click it and click. Then clickto close the field.\n• Click . It's the button on the left above the address list at the bottom of Cheat Engine. This opens a box that looks similar to the \"Change address\" box, except this one allows you to add an address.\n• Click the checkbox next to \"Pointers\". This expands the box and adds a new text field where you can enter a pointer.\n• Paste the pointer address in the field below \"Pointers\" and click . This adds a new address for the pointer that controls the value that you want to change. The address for the pointer you just created will read something like \"P-->xxxxxxxx\". This indicates that this is a pointer pointing to a specific address.\n• If there is an offset number, enter it in the space above the field where you paste the address.\n• If there is more than one pointer, click Add offset. This will add more offset number boxes above the area where you paste the address. Enter the correct offset number in each box. This adds a new address for the pointer that controls the value that you want to change. The address for the pointer you just created will read something like \"P-->xxxxxxxx\". This indicates that this is a pointer pointing to a specific address.\n• Click the \"Active\" boxe next to the pointer address you just added. It's the box below \"Active\" in the list address list at the bottom of the screen. This activates pointer.\n• Change the value of the address you just added. The value number for the pointer address you just created should be the same as the address of the value you searched for. If the pointer writes to a different location, the original address you scanned for will no longer be valid. However, you can still change the value of the pointer address you just created. That will work no matter where it writes the value location to. Click the number below \"value\" for the address you just added. Enter a new numeric value and click Ok.[9] The value number for the pointer address you just created should be the same as the address of the value you searched for. If the pointer writes to a different location, the original address you scanned for will no longer be valid. However, you can still change the value of the pointer address you just created. That will work no matter where it writes the value location to. Click the number below \"value\" for the address you just added. Enter a new numeric value and click\n• Scan for a value you want to stop. This part teaches you how to use Code Injections to change how the code writes a value. For example, if you lose health every time you get hit, you can change the code so that it increases your health when you get hit. This part teaches you how to use Code Injections to change how the code writes a value. For example, if you lose health every time you get hit, you can change the code so that it increases your health when you get hit.\n• Right-click the address and click Find out what access this address . This opens the Cheat Engine Debugger.[10]\n• Click . This confirms that you want to attach the debugger to the Cheat Engine process. This opens the Code debugger. The list will be blank when the window first opens.\n• Return to the game and change the value again. Once again, return to your game and do something to change the value you want to stop. This will cause the code that accesses the address you selected to appear in the debugger window.\n• Return to the game and change the value again. Once again, return to your game and do something to change the value you want to stop. This will cause the instruction that writes to that address to appear in the debugger window.\n• Return to Cheat Engine and click the instruction in the list. There may be more than one address. If that is the case, look for an instruction that has the word \"sub\" in the instruction to subtract from the value, or the word \"add\" or \"inc\" to increase the value.\n• Click . This opens the code in the disassembler.[11] This opens the code in the disassembler.\n• Select the code that subtracts or increases the value. It is usually the first instruction at the top of the code. It will have wlll most likely have the word \"Sub\" or \"Add\" at the start of the code to subtract from the value or add to it.\n• Click followed by . This opens the auto assembler.[12]\n• Click followed by . This displays a pop-up window that confirms the address you want to inject code into.[13] This displays a pop-up window that confirms the address you want to inject code into.\n• Ensure the address is correct and click . Ensure the address in the field is the same address you selected in the Memory Viewer disassembler window. Then click Ok. This opens a new template.\n• Replace the code with it's opposite. Scroll down to where it says \"Code\". The line below it is the code that changes the value. If the line starts with \"sub\", change \"sub\" to \"add\". If the line starts with \"add\", change it to \"sub\". You can also change the value at the end of the line to change how much you want it to change the value by.\n• Click followed by twice. The \"Execute\" button is at the bottom of the Code Injection window. You will be asked if you are sure you want to inject the code. Click Yes to confirm. Then you can click Yes or No to open the new code in the disassembler. If the code injection was successful, values in your game will do the opposite of what they are supposed to do. You can gain ammo by firing your weapon instead of losing ammo. You can gain health when you get hit instead of losing health.\n• Scan for a value you want to stop. In some games, multiple objects share the same code. Injecting code into one object will affect all the others too. So you might freeze your own health bar, only to realize that the health of all enemies is also frozen. In this case, you need to find out how to distinguish between different objects and inject a script that only affects the object you want.\n• In order to inject scripts for different objects, you need to know some assembly code. However, it's not too hard to create a basic script. In some games, multiple objects share the same code. Injecting code into one object will affect all the others too. So you might freeze your own health bar, only to realize that the health of all enemies is also frozen. In this case, you need to find out how to distinguish between different objects and inject a script that only affects the object you want.\n• Right-click the address and click Find out what writes to this address . Once you've determined the address of the values you want to change or stop, find out what writes to those addresses, open up the debugger and find out what writes to that address.\n• Select the instruction and click . It's the instruction that is highlighted when you open the debugger. This displays the instructions in the code disassembler.\n• Right-click the top instruction and click Find out what addresses this instruction accesses . This opens a window that displays a list of all the addresses the instruction accesses when it writes to a new address.[14] This opens a window that displays a list of all the addresses the instruction accesses when it writes to a new address.\n• Allow all the objects in the game to change their value. This will show a list of all addresses that the instruction accesses. For example, if you are trying to stop your health bar from changing, you can return to your game and get hit. This will display the instruction that accesses that address in the list of accessed addresses window. If you hit an enemy that also shares that instruction, it will also show in the list of accessed addresses window.\n• Select all addresses in the list of accessed addresses window. Once you have an address for all objects that share the same address in the list of accessed addresses, simply click and drag to highlight all of them.\n• Alternatively, you can right-click each individual address and click Show register states.[15] Once you have an address for all objects that share the same address in the list of accessed addresses, simply click and drag to highlight all of them.\n• Disect the data of structure of all the listed addresses. Use the following steps to disect the data structure for the list of addresses:[16]\n• Enter a name for the data structure and click Ok.\n• Enter a starting size of the struct or leave it as is, and click Ok. Use the following steps to disect the data structure for the list of addresses:\n• Find a value that is the same for the player(s), but different for other objects. Whether you are looking at the data structure or the register for each object, you need to find a value that is the same for all allies, but different for the enemies. For example, if Team 1 has two player characters, and Team 2 has two computer-controlled characters, the Team 1 characters may be represented with a value of 1, and Team 2 might have a value of 2.\n• If can't find a value that is the same for allies, but different for enemies, you can make one. Simply right-click one of the values (such as a pointer), and click Add Element. Select \"4 Bytes\" as the data type and give it an offset number value that is not taken. Offset numbers are listed to the left in the data dissection structure table. Whether you are looking at the data structure or the register for each object, you need to find a value that is the same for all allies, but different for the enemies. For example, if Team 1 has two player characters, and Team 2 has two computer-controlled characters, the Team 1 characters may be represented with a value of 1, and Team 2 might have a value of 2.\n• Note the register for the value. Whether you are looking at the register view or data dissection view, the register value is on the left. In the register view, it will be the actual register the instruction writes to (i.e. RSI, RDX, EDX, etc). If you are looking at a data structure, the register will be an offset number or letter listed to the left.\n• Open a new code injection template for the instruction. Return to the Memory Viewer window and open a new code injection template for the instruction that writes to the different addresses. Use the following steps to do so:\n• Click the instruction in the Memory Viewer window.\n• Click Tools in the menu bar at the top.\n• Click Template in the menu bar at the top. Return to the Memory Viewer window and open a new code injection template for the instruction that writes to the different addresses. Use the following steps to do so:\n• Create a new label for the object you want to affect. Labels are listed at the top of the code injection template. Add a new label for the object you want to affect below the existing labels. To add a label, simply type followed by the name of the label in parenthesis. For example, \"label (player)\" or \"label (enemy)\".\n• Create a new section for the label you just created. To create a new section for the label, type the name of the label followed by a colon (:) anywhere before or after the original code.\n• Add code to the label that changes the value of the object you want to effect. This requires a bit of knowledge of assembly code. You'll need to add a line of code that changes the value for the object you want to change in the way you want to change it. Then you'll need to add a line that jumps to the exit, original code, return code.\n• Create a comparison code below \"newmem\". The line that says \"newmem:\" in the code injection template indicates that the instruction is calling a new memory address. Normally, it will go right into the original code that has a label of (code:) or (originalcode:). Use the \"cmp\" command to create a line of code that compares the value of the different objects at the registry or registry plus offset number. For example, if RDX with an offset of 14 determines the player team from the computer team, and the player team has a value of 1, you would type to check if an object is a player or not.\n• Add a line of code that jumps to section for the object you want to change. Use the \"je\" command to jump to the section for your comparison command. For example, if your label is called \"player\", add the line to jump to the player section if the value comparison corresponds to the player.\n• Add code that jumps to the original code. After you create a line of code that jumps to the section for the object you want to change, you need to add a line of code that jumps to the original code if value doesn't corrispond to the player or ally. Use the \"jmp\" command to create a line of code that jumps to the orignal code after the line of code that jumps to the original code (or another set of code you create that does something different).\n• One way to keep things simple is not to add any new labels. Just create a comparison code at the end of \"newmen:\" to differenciate between allies and foes. Then add a line of code that jumps to the exit if it's an ally. If it's an enemy, have it jump to the original code. This will make it so that if the player or an ally is attacked (or fires weapons uses consumables, etc), nothing will change, but if an enemy is attacked, the code will execute as normal. After you create a line of code that jumps to the section for the object you want to change, you need to add a line of code that jumps to the original code if value doesn't corrispond to the player or ally. Use the \"jmp\" command to create a line of code that jumps to the orignal code after the line of code that jumps to the original code (or another set of code you create that does something different).\n• Click . This executes the code you entered. If all goes well, you will have injected new code that differentiates between allies and foes. The following is an example of a simple script you can use to differentiate between allies and foes: This executes the code you entered. If all goes well, you will have injected new code that differentiates between allies and foes. The following is an example of a simple script you can use to differentiate between allies and foes:"
    }
]