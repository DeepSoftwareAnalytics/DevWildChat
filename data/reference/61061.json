[
    {
        "link": "https://vuejs.org/guide/components/attrs",
        "document": "A \"fallthrough attribute\" is an attribute or event listener that is passed to a component, but is not explicitly declared in the receiving component's props or emits. Common examples of this include , , and attributes.\n\nWhen a component renders a single root element, fallthrough attributes will be automatically added to the root element's attributes. For example, given a component with the following template:\n\nAnd a parent using this component with:\n\nThe final rendered DOM would be:\n\nHere, did not declare as an accepted prop. Therefore, is treated as a fallthrough attribute and automatically added to 's root element.\n\nIf the child component's root element already has existing or attributes, it will be merged with the and values that are inherited from the parent. Suppose we change the template of in the previous example to:\n\nThen the final rendered DOM would now become:\n\nThe same rule applies to event listeners:\n\nThe listener will be added to the root element of , i.e. the native element. When the native is clicked, it will trigger the method of the parent component. If the native already has a listener bound with , then both listeners will trigger.\n\nIf a component renders another component as its root node, for example, we refactored to render a as its root:\n\nThen the fallthrough attributes received by will be automatically forwarded to .\n• None Forwarded attributes do not include any attributes that are declared as props, or listeners of declared events by - in other words, the declared props and listeners have been \"consumed\" by .\n• None Forwarded attributes may be accepted as props by , if declared by it.\n\nIf you do not want a component to automatically inherit attributes, you can set in the component's options.\n\nThe common scenario for disabling attribute inheritance is when attributes need to be applied to other elements besides the root node. By setting the option to , you can take full control over where the fallthrough attributes should be applied.\n\nThese fallthrough attributes can be accessed directly in template expressions as :\n\nThe object includes all attributes that are not declared by the component's or options (e.g., , , listeners, etc.).\n• None Unlike props, fallthrough attributes preserve their original casing in JavaScript, so an attribute like needs to be accessed as .\n• None A event listener like will be exposed on the object as a function under .\n\nUsing our component example from the previous section - sometimes we may need to wrap the actual element with an extra for styling purposes:\n\nWe want all fallthrough attributes like and listeners to be applied to the inner , not the outer . We can achieve this with and :\n\nRemember that without an argument binds all the properties of an object as attributes of the target element.\n\nUnlike components with a single root node, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If are not bound explicitly, a runtime warning will be issued.\n\nIf has the following multi-root template, there will be a warning because Vue cannot be sure where to apply the fallthrough attributes:\n\nThe warning will be suppressed if is explicitly bound:"
    },
    {
        "link": "https://stackoverflow.com/questions/70847786/how-to-use-v-bind-attrs-in-vue-3",
        "document": "I am migrating vue 2 application to vue 3. In official docs, it is mentioned that $listeners object has been removed in Vue 3. Event listeners are now part of $attrs. It is taking non-prop attributes (class, style) as well. In my vue 2 application, there is one icon-button custom component and it is looking like this below.\n\nIt is used in various other components.\n\nAs of migration strategy, i removed the $listeners but not sure about those non-prop attributes and v-bind tag. How to modify those so it can be used in parent component with attributes?"
    },
    {
        "link": "https://thisdot.co/blog/build-advanced-components-in-vue-3-using-usdattrs",
        "document": "In the third major release of Vue js, we have seen many new features and improvements land on our remote working computers.\n\nIn this article, we are going to cover the attribute. We will explain what it is used for, how its implementation differs from Vue 2's (former , , ), and build a code example to help understand its power.\n\nUnderstanding this feature can really support your skills in developing easy to use and scalable components advanced components.\n\nThe definition of $attrs, varies between the two major versions of the framework, but in this article, we are going to mainly cover Vue 3, where @attrs can be seen as:\n\n$attrs can also be seen as a safety net, that captures anything that you may not have declared within a component. Let's consider a component that has just a single property and event handler, like the following example:\n\nIf we would instantiate our component like so:\n\nOur example component would have access to a $attrs property with the following information:\n\nIf the above is not yet making sense, it is absolutely fine. In the next few sections, we will cover, in more granular details, how to actually make use of this feature.\n\nEven if I do not want this article to be a comparison between V2 and V3, it is essential that we touch base on the differences that the feature offers betweent the two major versions.\n\nIf you have used VueJs in the past (version 2), there is a significant chance that you have already used $attrs before. The main reason is that almost all the attributes included in the property were already present in the previous version of the framework. Just split it into different properties.\n\nIf we take into consideration the example proposed above, the $attrs object is going to appear as follows:\n\nMain differences to notice in V2 are:\n• the class is not available (using class in this way requires you to set a property).\n\nMost of the content provided in the following chapter can still be applied in V2, as long as we adhere to the above differences and define the extra properties ($listners and a class property).\n\nAs with most of my content, I like to always cover a real life example. Building something from the bottom up, can really help in understanding the reason beind a feature, and help you introduce its usage within your codebase.\n\nIn the following sections, we are going to build a nice slider (or more precisely a few of them). The complete code can be found on Stackblitz following the following link (stackblitz-vue-example).\n\nThe first step requires us to create a simple component. This is going to be plain Vue and will have nothing to do with the $attrs feature (yet).\n\nThe above code will create a slider that includes single HTML element at the root, and a simple two way binding for a property called value.\n\nTo use the above component we would do something like this:\n\nThe result should be something like this:\n\nThe above \"hello world\" example, would never stand the real web development industry.\n\nAs we know, our components are always full of requirements and specifications, and are never this simple. So to make it a bit more realistic, let's add a couple of attributes (min, max, class, id, data-cy, @keydown and aria-label).\n\nIf we would run the app with the above changes, we would see that all changes take effect. In fact, analysing the app will show the following UI and HTML:\n\nAs we can notice, all the information has already been applied to our HTML.\n\nWAIT A SECOND... Why did I make such a big introduction to $attrs, when all the \"non property/event\" attributes are already automatically applied to the inner HTML element?\n\nDo not worry, I have not wasted your time.. In the next section, we will shake things a bit, because as we know, requirements always change.. :)\n\nIn this section we are going to apply some further changes to our component. More precisely, our product owner has assigned us the following ticket:\n\nThe modified component will look like this:\n\nAt first glance, everthing seemed to work, but if we look closely, we can see that something is not right.\n\nFirst, the slider is not blue. Second, the value is going way over 50, and lastly if we look at the html, we'll notice that all of our extra attributes (min, max, data-cy) are assigned to the root element, and not our input element anymore!\n\nThe best way to solve the above problem would be to find a way to \"apply\" all the properties, classes, arguments, and events directly to the input field, without them needing to manually declare them- something like a \"bucket\" of data.. !$ATTRS!\n\nLet's jump in the next section and see how we can use to accomplish our goals.\n\nAt the start of this article, we introduced as a bucket of information. It is a place that holds all the \"undeclared\" properties and events, and this is precisely what we need to solve our issue.\n\nTo use this feature, we can just apply the property to one or more HTML element, using the operator:\n\nAs we can see, the above change will make things much better. The use of attrs in our component will act as bridge that copies all out attributes (class, attribute, property and custom events) to one or more elements:\n\nThe slider thumb is back to being blue. The max value is set to 100, and our extra attributes are set correctly... almost.\n\nThere is only one problem- our extra attributes have not only been assigned to the element, but also to the element!\n\nIn this case, there is no visual change to show us this issue (and usually there isn't one in real life either. That is why I have not created any). But these extra variables can really create some side effects. Let's fix this.\n\nBy default, any extra argument being passed to a component is automatically applied to the root element (and to all elements that have the $attrs binding).\n\nTo switch this feature off, and get control of what elements receive this extra attribute, we can use a flag called , and set it to .\n\nOur script tag will look like this:\n\nAfter this change, our HTML is nice and clean. All the extra properties are applied to the Input element only.\n\nBefore we wrap up, there are a couple of extra points that I want to share, so that you can make furhter use of this feature and understand it more deeply.\n• I prefer not to use the v-model so that I can actually also omit the event (you can see at the file name Slider.vue in the stackblitz code)\n• You can access, and play with the individual properties of the $attrs. So for example, you could apply the to one element, and the to another.\n• It is always best to declare property and events, and just use this when you have an element that emits a native event and/or accepts many attributes (like video tag, or all Input fields).\n\nI have personally taken some time to fully understand this feature, but I really hope that this article may help you in understanding this feature, and helps you define complex but very readable components."
    },
    {
        "link": "https://v3-migration.vuejs.org/breaking-changes/attrs-includes-class-style",
        "document": "now contains all attributes passed to a component, including and .\n\nand attributes get some special handling in the Vue 2 virtual DOM implementation. For that reason, they are not included in , while all other attributes are.\n\nA side effect of this manifests when using :\n• Attributes in are no longer automatically added to the root element, leaving it to the developer to decide where to add them.\n• But and , not being part of , will still be applied to the component's root element:\n\nwhen used like this:\n\ncontains all attributes, which makes it easier to apply all of them to a different element. The example from above now generates the following HTML:\n\nIn components that use , make sure that styling still works as intended. If you previously relied on the special behavior of and , some visuals might be broken as these attributes might now be applied to another element.\n• Migration guide - Changes in the Render Functions API"
    },
    {
        "link": "https://stackoverflow.com/questions/76099922/combine-v-bind-attrs-with-custom-attributes-in-vue3",
        "document": "Is it possible to combine with custom attributes in Vue3 without losing the ability to use event listeners?\n\nLet's say I have an element in a :\n\nI would like to bind the to the input element & include the aria attributes as well. I tried unpacking the object in the computed , however, event listeners on the component stopped working in this case. I'd prefer not to have to write the attributes to the template. (because I want to add the same attributes to multiple elements and don't want to repeat them pointlessly)"
    },
    {
        "link": "https://vuejs.org/guide/components/attrs",
        "document": "A \"fallthrough attribute\" is an attribute or event listener that is passed to a component, but is not explicitly declared in the receiving component's props or emits. Common examples of this include , , and attributes.\n\nWhen a component renders a single root element, fallthrough attributes will be automatically added to the root element's attributes. For example, given a component with the following template:\n\nAnd a parent using this component with:\n\nThe final rendered DOM would be:\n\nHere, did not declare as an accepted prop. Therefore, is treated as a fallthrough attribute and automatically added to 's root element.\n\nIf the child component's root element already has existing or attributes, it will be merged with the and values that are inherited from the parent. Suppose we change the template of in the previous example to:\n\nThen the final rendered DOM would now become:\n\nThe same rule applies to event listeners:\n\nThe listener will be added to the root element of , i.e. the native element. When the native is clicked, it will trigger the method of the parent component. If the native already has a listener bound with , then both listeners will trigger.\n\nIf a component renders another component as its root node, for example, we refactored to render a as its root:\n\nThen the fallthrough attributes received by will be automatically forwarded to .\n• None Forwarded attributes do not include any attributes that are declared as props, or listeners of declared events by - in other words, the declared props and listeners have been \"consumed\" by .\n• None Forwarded attributes may be accepted as props by , if declared by it.\n\nIf you do not want a component to automatically inherit attributes, you can set in the component's options.\n\nThe common scenario for disabling attribute inheritance is when attributes need to be applied to other elements besides the root node. By setting the option to , you can take full control over where the fallthrough attributes should be applied.\n\nThese fallthrough attributes can be accessed directly in template expressions as :\n\nThe object includes all attributes that are not declared by the component's or options (e.g., , , listeners, etc.).\n• None Unlike props, fallthrough attributes preserve their original casing in JavaScript, so an attribute like needs to be accessed as .\n• None A event listener like will be exposed on the object as a function under .\n\nUsing our component example from the previous section - sometimes we may need to wrap the actual element with an extra for styling purposes:\n\nWe want all fallthrough attributes like and listeners to be applied to the inner , not the outer . We can achieve this with and :\n\nRemember that without an argument binds all the properties of an object as attributes of the target element.\n\nUnlike components with a single root node, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If are not bound explicitly, a runtime warning will be issued.\n\nIf has the following multi-root template, there will be a warning because Vue cannot be sure where to apply the fallthrough attributes:\n\nThe warning will be suppressed if is explicitly bound:"
    },
    {
        "link": "https://thisdot.co/blog/build-advanced-components-in-vue-3-using-usdattrs",
        "document": "In the third major release of Vue js, we have seen many new features and improvements land on our remote working computers.\n\nIn this article, we are going to cover the attribute. We will explain what it is used for, how its implementation differs from Vue 2's (former , , ), and build a code example to help understand its power.\n\nUnderstanding this feature can really support your skills in developing easy to use and scalable components advanced components.\n\nThe definition of $attrs, varies between the two major versions of the framework, but in this article, we are going to mainly cover Vue 3, where @attrs can be seen as:\n\n$attrs can also be seen as a safety net, that captures anything that you may not have declared within a component. Let's consider a component that has just a single property and event handler, like the following example:\n\nIf we would instantiate our component like so:\n\nOur example component would have access to a $attrs property with the following information:\n\nIf the above is not yet making sense, it is absolutely fine. In the next few sections, we will cover, in more granular details, how to actually make use of this feature.\n\nEven if I do not want this article to be a comparison between V2 and V3, it is essential that we touch base on the differences that the feature offers betweent the two major versions.\n\nIf you have used VueJs in the past (version 2), there is a significant chance that you have already used $attrs before. The main reason is that almost all the attributes included in the property were already present in the previous version of the framework. Just split it into different properties.\n\nIf we take into consideration the example proposed above, the $attrs object is going to appear as follows:\n\nMain differences to notice in V2 are:\n• the class is not available (using class in this way requires you to set a property).\n\nMost of the content provided in the following chapter can still be applied in V2, as long as we adhere to the above differences and define the extra properties ($listners and a class property).\n\nAs with most of my content, I like to always cover a real life example. Building something from the bottom up, can really help in understanding the reason beind a feature, and help you introduce its usage within your codebase.\n\nIn the following sections, we are going to build a nice slider (or more precisely a few of them). The complete code can be found on Stackblitz following the following link (stackblitz-vue-example).\n\nThe first step requires us to create a simple component. This is going to be plain Vue and will have nothing to do with the $attrs feature (yet).\n\nThe above code will create a slider that includes single HTML element at the root, and a simple two way binding for a property called value.\n\nTo use the above component we would do something like this:\n\nThe result should be something like this:\n\nThe above \"hello world\" example, would never stand the real web development industry.\n\nAs we know, our components are always full of requirements and specifications, and are never this simple. So to make it a bit more realistic, let's add a couple of attributes (min, max, class, id, data-cy, @keydown and aria-label).\n\nIf we would run the app with the above changes, we would see that all changes take effect. In fact, analysing the app will show the following UI and HTML:\n\nAs we can notice, all the information has already been applied to our HTML.\n\nWAIT A SECOND... Why did I make such a big introduction to $attrs, when all the \"non property/event\" attributes are already automatically applied to the inner HTML element?\n\nDo not worry, I have not wasted your time.. In the next section, we will shake things a bit, because as we know, requirements always change.. :)\n\nIn this section we are going to apply some further changes to our component. More precisely, our product owner has assigned us the following ticket:\n\nThe modified component will look like this:\n\nAt first glance, everthing seemed to work, but if we look closely, we can see that something is not right.\n\nFirst, the slider is not blue. Second, the value is going way over 50, and lastly if we look at the html, we'll notice that all of our extra attributes (min, max, data-cy) are assigned to the root element, and not our input element anymore!\n\nThe best way to solve the above problem would be to find a way to \"apply\" all the properties, classes, arguments, and events directly to the input field, without them needing to manually declare them- something like a \"bucket\" of data.. !$ATTRS!\n\nLet's jump in the next section and see how we can use to accomplish our goals.\n\nAt the start of this article, we introduced as a bucket of information. It is a place that holds all the \"undeclared\" properties and events, and this is precisely what we need to solve our issue.\n\nTo use this feature, we can just apply the property to one or more HTML element, using the operator:\n\nAs we can see, the above change will make things much better. The use of attrs in our component will act as bridge that copies all out attributes (class, attribute, property and custom events) to one or more elements:\n\nThe slider thumb is back to being blue. The max value is set to 100, and our extra attributes are set correctly... almost.\n\nThere is only one problem- our extra attributes have not only been assigned to the element, but also to the element!\n\nIn this case, there is no visual change to show us this issue (and usually there isn't one in real life either. That is why I have not created any). But these extra variables can really create some side effects. Let's fix this.\n\nBy default, any extra argument being passed to a component is automatically applied to the root element (and to all elements that have the $attrs binding).\n\nTo switch this feature off, and get control of what elements receive this extra attribute, we can use a flag called , and set it to .\n\nOur script tag will look like this:\n\nAfter this change, our HTML is nice and clean. All the extra properties are applied to the Input element only.\n\nBefore we wrap up, there are a couple of extra points that I want to share, so that you can make furhter use of this feature and understand it more deeply.\n• I prefer not to use the v-model so that I can actually also omit the event (you can see at the file name Slider.vue in the stackblitz code)\n• You can access, and play with the individual properties of the $attrs. So for example, you could apply the to one element, and the to another.\n• It is always best to declare property and events, and just use this when you have an element that emits a native event and/or accepts many attributes (like video tag, or all Input fields).\n\nI have personally taken some time to fully understand this feature, but I really hope that this article may help you in understanding this feature, and helps you define complex but very readable components."
    },
    {
        "link": "https://stackoverflow.com/questions/70847786/how-to-use-v-bind-attrs-in-vue-3",
        "document": "I am migrating vue 2 application to vue 3. In official docs, it is mentioned that $listeners object has been removed in Vue 3. Event listeners are now part of $attrs. It is taking non-prop attributes (class, style) as well. In my vue 2 application, there is one icon-button custom component and it is looking like this below.\n\nIt is used in various other components.\n\nAs of migration strategy, i removed the $listeners but not sure about those non-prop attributes and v-bind tag. How to modify those so it can be used in parent component with attributes?"
    },
    {
        "link": "https://labs.thisdot.co/blog/build-advanced-components-in-vue-3-using-usdattrs",
        "document": "In the third major release of Vue js, we have seen many new features and improvements land on our remote working computers.\n\nIn this article, we are going to cover the attribute. We will explain what it is used for, how its implementation differs from Vue 2's (former , , ), and build a code example to help understand its power.\n\nUnderstanding this feature can really support your skills in developing easy to use and scalable components advanced components.\n\nThe definition of $attrs, varies between the two major versions of the framework, but in this article, we are going to mainly cover Vue 3, where @attrs can be seen as:\n\n$attrs can also be seen as a safety net, that captures anything that you may not have declared within a component. Let's consider a component that has just a single property and event handler, like the following example:\n\nIf we would instantiate our component like so:\n\nOur example component would have access to a $attrs property with the following information:\n\nIf the above is not yet making sense, it is absolutely fine. In the next few sections, we will cover, in more granular details, how to actually make use of this feature.\n\nEven if I do not want this article to be a comparison between V2 and V3, it is essential that we touch base on the differences that the feature offers betweent the two major versions.\n\nIf you have used VueJs in the past (version 2), there is a significant chance that you have already used $attrs before. The main reason is that almost all the attributes included in the property were already present in the previous version of the framework. Just split it into different properties.\n\nIf we take into consideration the example proposed above, the $attrs object is going to appear as follows:\n\nMain differences to notice in V2 are:\n• the class is not available (using class in this way requires you to set a property).\n\nMost of the content provided in the following chapter can still be applied in V2, as long as we adhere to the above differences and define the extra properties ($listners and a class property).\n\nAs with most of my content, I like to always cover a real life example. Building something from the bottom up, can really help in understanding the reason beind a feature, and help you introduce its usage within your codebase.\n\nIn the following sections, we are going to build a nice slider (or more precisely a few of them). The complete code can be found on Stackblitz following the following link (stackblitz-vue-example).\n\nThe first step requires us to create a simple component. This is going to be plain Vue and will have nothing to do with the $attrs feature (yet).\n\nThe above code will create a slider that includes single HTML element at the root, and a simple two way binding for a property called value.\n\nTo use the above component we would do something like this:\n\nThe result should be something like this:\n\nThe above \"hello world\" example, would never stand the real web development industry.\n\nAs we know, our components are always full of requirements and specifications, and are never this simple. So to make it a bit more realistic, let's add a couple of attributes (min, max, class, id, data-cy, @keydown and aria-label).\n\nIf we would run the app with the above changes, we would see that all changes take effect. In fact, analysing the app will show the following UI and HTML:\n\nAs we can notice, all the information has already been applied to our HTML.\n\nWAIT A SECOND... Why did I make such a big introduction to $attrs, when all the \"non property/event\" attributes are already automatically applied to the inner HTML element?\n\nDo not worry, I have not wasted your time.. In the next section, we will shake things a bit, because as we know, requirements always change.. :)\n\nIn this section we are going to apply some further changes to our component. More precisely, our product owner has assigned us the following ticket:\n\nThe modified component will look like this:\n\nAt first glance, everthing seemed to work, but if we look closely, we can see that something is not right.\n\nFirst, the slider is not blue. Second, the value is going way over 50, and lastly if we look at the html, we'll notice that all of our extra attributes (min, max, data-cy) are assigned to the root element, and not our input element anymore!\n\nThe best way to solve the above problem would be to find a way to \"apply\" all the properties, classes, arguments, and events directly to the input field, without them needing to manually declare them- something like a \"bucket\" of data.. !$ATTRS!\n\nLet's jump in the next section and see how we can use to accomplish our goals.\n\nAt the start of this article, we introduced as a bucket of information. It is a place that holds all the \"undeclared\" properties and events, and this is precisely what we need to solve our issue.\n\nTo use this feature, we can just apply the property to one or more HTML element, using the operator:\n\nAs we can see, the above change will make things much better. The use of attrs in our component will act as bridge that copies all out attributes (class, attribute, property and custom events) to one or more elements:\n\nThe slider thumb is back to being blue. The max value is set to 100, and our extra attributes are set correctly... almost.\n\nThere is only one problem- our extra attributes have not only been assigned to the element, but also to the element!\n\nIn this case, there is no visual change to show us this issue (and usually there isn't one in real life either. That is why I have not created any). But these extra variables can really create some side effects. Let's fix this.\n\nBy default, any extra argument being passed to a component is automatically applied to the root element (and to all elements that have the $attrs binding).\n\nTo switch this feature off, and get control of what elements receive this extra attribute, we can use a flag called , and set it to .\n\nOur script tag will look like this:\n\nAfter this change, our HTML is nice and clean. All the extra properties are applied to the Input element only.\n\nBefore we wrap up, there are a couple of extra points that I want to share, so that you can make furhter use of this feature and understand it more deeply.\n• I prefer not to use the v-model so that I can actually also omit the event (you can see at the file name Slider.vue in the stackblitz code)\n• You can access, and play with the individual properties of the $attrs. So for example, you could apply the to one element, and the to another.\n• It is always best to declare property and events, and just use this when you have an element that emits a native event and/or accepts many attributes (like video tag, or all Input fields).\n\nI have personally taken some time to fully understand this feature, but I really hope that this article may help you in understanding this feature, and helps you define complex but very readable components."
    },
    {
        "link": "https://medium.com/@jogarcia/vues-fall-through-attrs-attribute-716e3d4ceadd",
        "document": "This is the fall trough attribute. It basically contains every non defined prop that you are using nevertheless.\n\nWhat would happen if you call it like this:\n\nWhen you do something like this the prop that wasn’t declared gets assigned to the fall through attribute.\n\nAnd you can access it by doing:\n\nNow if you were to pass more undefined props in something like this:\n\nIt would also be stored in the $attrs attribute. And if you were to log the entire $attrs object you would get something like this:\n\nNotice that isn’t inside the $attrs attribute because is defined in the component so it doesn’t “falls through”."
    }
]