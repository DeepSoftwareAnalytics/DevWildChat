[
    {
        "link": "https://datacamp.com/tutorial/minimax-algorithm-for-ai-in-python",
        "document": "Discover the fundamentals of AI, dive into models like ChatGPT, and decode generative AI secrets to navigate the dynamic AI landscape."
    },
    {
        "link": "https://geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction",
        "document": "Minimax is a kind of backtracking algorithm that is used in decision making and game theory to find the optimal move for a player, assuming that your opponent also plays optimally. It is widely used in two player turn-based games such as Tic-Tac-Toe, Backgammon, Mancala, Chess, etc.\n\nIn Minimax the two players are called maximizer and minimizer. The maximizer tries to get the highest score possible while the minimizer tries to do the opposite and get the lowest score possible.\n\nEvery board state has a value associated with it. In a given state if the maximizer has upper hand then, the score of the board will tend to be some positive value. If the minimizer has the upper hand in that board state then it will tend to be some negative value. The values of the board are calculated by some heuristics which are unique for every type of game.\n\nExample: \n\nConsider a game which has 4 final states and paths to reach final state are from root to 4 leaves of a perfect binary tree as shown below. Assume you are the maximizing player and you get the first chance to move, i.e., you are at the root and your opponent at next level. Which move you would make as a maximizing player considering that your opponent also plays optimally?\n\nSince this is a backtracking based algorithm, it tries all possible moves, then backtracks and makes a decision.\n• Maximizer goes LEFT: It is now the minimizers turn. The minimizer now has a choice between 3 and 5. Being the minimizer it will definitely choose the least among both, that is 3\n• Maximizer goes RIGHT: It is now the minimizers turn. The minimizer now has a choice between 2 and 9. He will choose 2 as it is the least among the two values.\n\nBeing the maximizer you would choose the larger value that is 3. Hence the optimal move for the maximizer is to go LEFT and the optimal value is 3.\n\nNow the game tree looks like below :\n\nThe above tree shows two possible scores when maximizer makes left and right moves.\n\nNote: Even though there is a value of 9 on the right subtree, the minimizer will never pick that. We must always assume that our opponent plays optimally.\n\nBelow is the implementation for the same.\n\nTime complexity : O(b^d) b is the branching factor and d is count of depth or ply of graph or tree.\n\nSpace Complexity : O(bd) where b is branching factor into d is maximum depth of tree similar to DFS.\n\nThe idea of this article is to introduce Minimax with a simple example.\n• In the above example, there are only two choices for a player. In general, there can be more choices. In that case, we need to recur for all possible moves and find the maximum/minimum. For example, in Tic-Tac-Toe, the first player can make 9 possible moves.\n• In the above example, the scores (leaves of Game Tree) are given to us. For a typical game, we need to derive these values\n\nWe will soon be covering Tic Tac Toe with Minimax algorithm.\n\nThis article is contributed by Akshay L. Aradhya."
    },
    {
        "link": "https://stackoverflow.com/questions/79379114/performance-optimization-for-minimax-algorithm-in-tic-tac-toe-with-variable-boar",
        "document": "Minimax, even with alpha-beta pruning, will have to look at an exponentially growing number of states. For larger board sizes this will mean you can only perform shallow searches.\n\nI would suggest to switch to the Monte Carlo Search algorithm. It uses random sampling, making decisions whether to explore new branches in the search tree or to deepen existing ones. You can check out the Wikipedia page on Monte Carlo tree search for more information.\n\nYou mention 4-in-a-row, but realise that on large boards (like 8x12), that is an easy win for the first player.\n\nBelow is an implementation I made for answering your question. It defines a class with methods like , , ... But it inherits from a more generic class which provides the core Monte Carlo search functionality with its method. That superclass has no knowledge of the game logic; it only assumes two players and that it is turn-based with at each turn a finite number of moves. It will only refer to these moves with a sequential number, and will depend on the subclass methods to perform the corresponding moves. It is responsible for driving the search directions.\n\nThe class does not have search logic. It depends on the superclass for that. Although it is not necessary, I decided to \"help\" find winning lines more effectively, and still add some logic in that narrows the list of moves that the algorithm should consider, in two ways:\n• None Only moves that are neighboring (possibly diagonally) occupied cells are considered. For the very first move only the center move is considered. This is a limitation that you might consider too strong, as in the beginning of the game on a large board, strong players may prefer to place their pieces further away from the other pieces. Still, I found that this restriction for the search algorithm still allows for reasonable good play (it's all relative to what strength you expect).\n• None If there is a winning move for the player who's turn it is, this is detected, and only that move will be in the move list. If the last played piece created a \"threat\" to win on their next move, this also leads to a move list with just one move for the opponent, since they will want to defend.\n\nThese restrictions are only applicable for the search algorithm, not for the human player (of course).\n\nAs on larger boards the game may need a lot of moves to come to an end, I also added a parameter to limit the search depth in the Monte Carlo rollout phase, and consider the outcome a draw when there is no win within that number of moves counting from the start of the rollout. It could be set to 20 or 30 for example.\n\nHere is the code:\n\nThe above can be run as-is and will play a computer-vs-human game on a 8x12 board, with a 5-in-a-row target, and the computer getting 2 seconds time per move, and a rollout depth of 20. Have a go at it, and try to beat it. It is possible.\n\nThis is not an end-product, but I think this program plays reasonable games.\n\nFor smaller boards, like 3x3, you don't need 2 seconds, and could set it to just 100 milliseconds.\n\nSeveral things could be improved, like:\n• None The search could keep going during the time that the human player is to enter their move.\n• None The search time could be more dynamic so that it would return a best move faster when it becomes clear that one move stands out among the rest.\n• None More logic could be added to the class so that it would detect forced lines at an earlier stage and limit the move list (for the Monte Carlo search) to the relevant moves to follow those lines. Think of the creation of double threats, ...etc.\n• None The depth limit for the rollout phase could be made more dynamic, depending on the size of the board, the time still available,...\n\nI hope this meets some of your requirements and this gives some leads on how to further improve it. At least I was happy with the result that less than 300 lines of code could give."
    },
    {
        "link": "https://levelup.gitconnected.com/mastering-tic-tac-toe-with-minimax-algorithm-3394d65fa88f",
        "document": "I’ve been dabbling in Game Theory recently and had to re-visit the Minimax algorithm. The algorithm was already familiar to me but I never took the time to actually implement it. It seemed like a good opportunity to implement it for a simple game such as Tic-Tac-Toe and explain its basics. Full source is available here. Without further ado, let’s get into it!\n\nMinimax is a type of adversarial search algorithm for generating and exploring game trees. It is mostly used to solve zero-sum games where one side’s gain is equivalent to other side’s loss, so adding all gains and subtracting all losses end up being zero.\n\nAdversarial search differs from conventional searching algorithms by adding opponents into the mix. Minimax algorithm keeps playing the turns of both player and the opponent optimally to figure out the best possible move.\n\nLet’s consider a simple game where there are only 2 possible moves in each state, such as Figure-1. Nodes of the tree represents game states, and edges represent moves. Top node is the minimizer, which means it’s your opponents turn. Naturally, it will pick the least favorable position for you.\n\nIn order for minimizer to figure out the least favorable move given the current game state, all possible states that can be reached from there must be generated. Luckily we are only looking 3 moves ahead, so our tree is rather manageable.\n\nLet’s take a look at each level of the tree:\n• (IV) These are game’s terminal states. Each of these are evaluated and assigned a score based on how favorable they are.\n• (III) Last move before the game ends, and it’s minimizer’s turn. The least favorable state for the maximizer is chosen.\n• (II) Now maximizer knows how minimizer will play the next turn, out of all possible states that can be reached, the most optimal one is chosen.\n• (I) Now that we’re back to the top, it’s decision time. By looking three moves ahead, minimizer knows exactly which path to take. Naturally, the path that had a score of 8 is chosen.\n\nAs you can see, since leaf nodes are terminal states, once minimax algorithm plays out each turn that leads to them, everything is decided. Assuming you are the one playing against that AI, even if you’re playing perfectly there’s no way for you to get a score higher than 8 at this point.\n\nTic-Tac-Toe is a rather simply game with only 255,168 possible games that can be played. This number is trivial for today’s computers, that’s why Tic-Tac-Toe is considered to be a solved game which means the outcome can be predicted given any state. The game is so simple that we can generate the entire game tree without trouble, whereas in chess there are already 69,352,859,712,417 possible games that could’ve been played after just 10 moves.\n\nI’ve used the p5 library for python to create a simple Tic-Tac-Toe board. Board state is represented in a two-dimensional, 3x3 matrix. After each move, board state is evaluated to check if a terminal state is reached.\n\nImplementing minimax for Tic-Tac-Toe is simple. We will recursively generate the game tree by exploring all possible moves for each board state and upon reaching a terminal state, we will assign a value of 1 for winning, -1 for losing and 0 for draw. Then based on these terminal states, for each explored turn either maximizer or minimizer will pick the most appropriate move. Doing so will propagate these outcomes all the way up to the root of the tree. The algorithm looks somewhat like this:\n\nImplementation in python can be found below. First, we check whether the current state is terminal and return a score if it is. If it’s not a terminal state, for all possible moves, we make the move, switch players, call minimax with the new board state, add its return value to a list of scores and undo the move.\n\nAfter exhausting all possible moves, we will either return the maximum or minimum of our scores list, depending on whether we’re maximizing or minimizing.\n\nSince it’s a solved game, we already know that if both sides play perfectly, there’s no chance of winning in Tic-Tac-Toe. So putting AI against AI would only result in a series of draws."
    },
    {
        "link": "https://papers-100-lines.medium.com/the-minimax-algorithm-and-alpha-beta-pruning-tutorial-in-30-lines-of-python-code-e4a3d97fa144",
        "document": "In the field of artificial intelligence, game theory plays a significant role in creating intelligent agents capable of making strategic decisions. One of the most popular and efficient algorithms used in game theory is the Minimax algorithm, which can help determine the best possible move for a player in a two-player zero-sum game.\n\nThis tutorial will guide you through the process of implementing both the Minimax and Alpha Beta Pruning algorithms in only 30 lines of Python code. Despite its brevity, our implementation will be both general and effective. While the primary focus of this tutorial is the implementation itself, it is worth noting that a comprehensive course on Udemy is available for those interested in deepening their understanding of the Minimax algorithm and Alpha Beta Pruning algorithms.\n\nFor the algorithm to function properly, it requires a game / environment, which we’ll refer to as “game_map” in our implementation. The game_map must provide four essential function calls:\n• is_terminal: This function returns a Boolean value indicating whether the game has reached a terminal state, i.e., one of the players has won, or it’s a draw.\n• get_possible_moves: This function returns all the possible moves that a player can make from the current state of the game.\n• get_new_state: This function takes a move as input and returns a new game state.\n• get_score: This function returns the score of the game. For instance, if Team A has won, it returns 1, if Team B has won, it returns -1, and if it’s a draw or no team has won, it returns 0. When the game is not in a terminal state, a heuristic function can be used to estimate the score of the game and determine which player has the upper hand. This is particularly useful for games with large branching factors, such as chess.\n\nThis indicates that you can easily apply the algorithm to your own game without modifying a single line of the algorithm. To accomplish this, you will need to create an API in your environment that includes the four function calls described earlier — this is what I did for my implementation of a chess game. The Move class is generic, so you can customize it to suit your particular requirements.\n\nThis implies that you can seamlessly integrate the Minimax algorithm into your game and take advantage of its benefits.\n\nThe Minimax algorithm can be implemented recursively with ease. It requires two inputs: the depth that needs to be reached and a boolean value indicating whether the score should be maximised or minimised.\n\nIf the depth that needs to be evaluated is zero, the recursion can be stopped, and the score of the leaf game state can be returned. This is achieved by simply returning the score of the game state. It is important to note that we return an additional variable as well. Since our primary goal is to determine the best move to play, we need to calculate this move as well. This variable is set to None in leaf nodes since there is no move to be made. However, this will be computed in non-terminal states latter.\n\nThe code is divided into two primary sections — one for layers where maximisation is required and the other for layers where minimisation is required.\n\nIn the former case, the objective is to find the value that maximises the score. Thus, we set it to -inf by default. We then obtain all possible moves and iterate over them, getting the states that can be reached from those moves. For each state, we recursively call the Minimax algorithm. If we encounter values that are better than the value returned by the best move, we update the best move. Finally, at the end of the function, we can return the score and the best move for this node. The process for minimization is similar.\n\nIt’s worth noting that the algorithm can be applied to any game with the appropriate API without modification.\n\nAs the game tree’s size increases, the computational requirements of the Minimax algorithm grow exponentially, making it impractical for most purposes. To address this issue, we employ Alpha Beta Pruning, which reduces the number of nodes evaluated by the Minimax algorithm while still producing the same outcome.\n\nThe alpha beta pruning algorithm derives its name from the two additional parameters it takes as input: alpha and beta. These values are instrumental in pruning the tree, thereby avoiding unnecessary computation of nodes. During the maximisation phase, if we encounter a node with a value greater than beta, we can immediately stop exploring that branch. This is because the score of this node is higher than the best alternative for the minimising player, who will not choose this node anyway. As a result, even if a better move is found, it will never be reached.\n\nA straightforward way to implement this in code is to check if the value of a node exceeds beta during the maximisation phase. If this condition holds, we can stop exploring further because we know that the opposing player already has a better alternative than the current node’s value. Therefore, even if we find a better value, the opposing player will still choose the action with the reward beta. Note that this algorithm assumes that the opposing player plays optimally. Against a random agent, the alpha beta pruning algorithm may not necessarily be the best choice."
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://discuss.python.org/t/coding-help-with-coding-a-tic-tac-toe-game/12457",
        "document": "Source code: Lib/collections/__init__.py This module implements specialized container datatypes providing alternatives to Python’s general purpose built-in containers, dict, list, set, and tuple.,,..."
    },
    {
        "link": "https://realpython.com/tic-tac-toe-python",
        "document": "Developing a tic-tac-toe game in Python using Tkinter combines programming logic with graphical user interface design (GUI). This tutorial guides you through creating the game logic and a Tkinter-based GUI to produce a fully functional tic-tac-toe game. You’ll learn how to manage player moves, detect winning combinations, and build an interactive interface with Tkinter widgets.\n\nBy the end of this tutorial, you’ll understand that:\n• Python can be used to implement the logic for a tic-tac-toe game.\n• Tkinter provides tools to build a game GUI using labels and buttons.\n• You can connect the game logic and GUI to create a fully interactive application.\n\nPlaying computer games is a great way to unwind or challenge yourself, and it’s also fun and educational to build your own. In this project, you’ll use the Tkinter GUI framework from Python’s standard library to create a game interface, while applying the model-view-controller pattern and an object-oriented approach to organize your code. For more on these concepts, check out the links in the prerequisites.\n\nTo download the entire source code for this project, click the link in the box below:\n\nYour goal with this project is to create a tic-tac-toe game in Python. For the game interface, you’ll use the Tkinter GUI tool kit, which comes in the standard Python installation as an included battery. The tic-tac-toe game is for two players. One player plays X and the other plays O. The players take turns placing their marks on a grid of three-by-three cells. If a given player gets three marks in a row horizontally, vertically, or diagonally, then that player wins the game. The game will be tied if no one gets three in a row by the time all the cells are marked. With these rules in mind, you’ll need to put together the following game components:\n• The game’s board, which you’ll build with a class called\n• The game’s logic, which you’ll manage using a class called The game board will work as a mix between view and controller in a model-view-controller design. To build the board, you’ll use a Tkinter window, which you can create by instantiating the class. This window will have two main components:\n• Grid of cells: Represents previous moves and available spaces or cells You’ll create the game display using a widget, which allows you to display text and images. For the grid of cells, you’ll use a series of widgets arranged in a grid. When a player clicks one of these buttons, the game logic will run to process the player’s move and determine whether there’s a winner. In this case, the game logic will work as the model, which will manage the data, logic, and rules of your game. Now that you have a general idea of how to build your tic-tac-toe game, you should check out a few knowledge prerequisites that’ll allow you to get the most out of this tutorial.\n\nStep 1: Set Up the Tic-Tac-Toe Game Board With Tkinter To kick things off, you’ll start by creating the game board. Before doing this, you need to decide how to organize the code for your tic-tac-toe game. Because this project will be fairly small, you can initially keep all the code in a single file. This way, running the code and executing your game will be more straighforward. Go ahead and fire up your favorite code editor or IDE. Then create a file in your current working directory: Throughout this tutorial, you’ll be incrementally adding code to this file, so keep it open and near. If you want to get the entire code for this tic-tac-toe game project, then you can click the following collapsible section and copy the code from it: \"\"\"Return True if move is valid, and False otherwise.\"\"\" \"\"\"Process the current move and check if it's a win.\"\"\" \"\"\"Return True if the game has a winner, and False otherwise.\"\"\" \"\"\"Return True if the game is tied, and False otherwise.\"\"\" \"\"\"Reset the game state to play again.\"\"\" \"\"\"Reset the game's board to play again.\"\"\" \"\"\"Create the game's board and run its main loop.\"\"\" Having the entire source code beforehand will allow you to check your progress while going through the tutorial. Alternatively, you can also download the game source code from GitHub by clicking the link in the box below: Get Source Code: Click here to get access to the source code that you’ll use to build your tic-tac-toe game. Now that you know what the game’s final code will look like, it’s time to make sure you have the right Tkinter version for this project. Then, you’ll go ahead and create your game board. To complete this project, you’ll use a standard Python installation. There’s no need to create a virtual environment because no external dependency is required. The only package that you’ll need is Tkinter, which comes with the Python standard library. However, you need to make sure that you have the right Tkinter version installed. You should have Tkinter greater than or equal to 8.6. Otherwise, your game won’t work. You can check your current Tkinter version by starting a Python interactive session and running the following code: If this code doesn’t show a version greater than or equal to 8.6 for your Tkinter installation, then you’ll need to fix that. On Ubuntu Linux, you may need to install the package using the system’s package manager, . That’s because typically Ubuntu doesn’t include Tkinter in its default Python installation. Once you have Tkinter properly installed, then you need to check its current version. If the Tkinter version is lower than 8.6, then you’ll have to install a more recent version of Python either by downloading it from the official download page or by using a tool like pyenv or Docker. On macOS and Windows, a straightforward option is to install a Python version from the official download page. Once you’re sure you have the right Tkinter version, you can get back to your code editor and start writing code. You’ll begin with the Python class that’ll represent the tic-tac-toe game board. To build the board of your tic-tac-toe game, you’ll use the class, which allows you to create the main window of your Tkinter app. Then you’ll add a display on a top frame and a grid of cells covering the rest of the main window. Go ahead and import the required objects and define the board class: In this code snippet, you first import as to bring the module’s name to your current namespace. Using the abbreviation is a common practice when it comes to using Tkinter in your code. Then you import the module directly from . You’ll use this module later in this tutorial to tweak the font of your game display. The class inherits from , which makes it a full-fledged GUI window. This window will represent the game board. Inside , you first call the superclass’s method to properly initialize the parent class. To do this, you use the built-in super() function. The attribute of defines the text to show on the window’s title bar. In this example, you set the title to the string. The non-public attribute holds an initially empty dictionary. This dictionary will map the buttons or cells on the game board to their corresponding coordinates—row and column—on the grid. These coordinates will be integer numbers reflecting the row and column where a given button will appear. To continue with the game board, you now need to create a display where you can provide information about the game’s state and result. For this display, you’ll use a widget as the display panel and a widget to show the required information. Note: The line numbers in the code samples in this tutorial are intended to facilitate the explanation. Most of the time, they won’t match the line numbers in your final script. Now go ahead and add the following method to your class: Here’s a breakdown of what this method does line by line:\n• Line 7 creates a object to hold the game display. Note that the argument is set to , which means that the game’s main window will be the frame’s parent.\n• Line 8 uses the geometry manager to place the frame object on the main window’s top border. By setting the argument to , you ensure that when the user resizes the window, the frame will fill its entire width.\n• Lines 9 to 13 create a object. This label needs to live inside the frame object, so you set its argument to the actual frame. The label will initially show the text , which indicates that the game is ready to go, and the players can start a new match. Finally, you change the label’s font size to pixels and make it bold.\n• Line 14 packs the display label inside the frame using the geometry manager. Cool! You already have the game display. Now you can create the grid of cells. A classic tic-tac-toe game has a three-by-three grid of cells. Here’s a method that creates the grid of cells using objects: Wow! This method does a lot! Here’s an explanation of what each line does:\n• Line 7 creates a object to hold the game’s grid of cells. You set the argument to , which again means that the game’s main window will be the parent of this frame object.\n• Line 8 uses the geometry manager to place the frame object on the main window. This frame will occupy the area under the game display, all the way to the bottom of the window.\n• Line 9 starts a loop that iterates from to . These numbers represent the row coordinates of each cell in the grid. For now, you’ll have rows on the grid. However, you’ll change this magic number later and provide the option of using a different grid size, such as four by four.\n• Line 10 and 11 configure the width and minimum size of every cell on the grid.\n• Line 12 loops over the three column coordinates. Again you use three columns, but you’ll change this number later to provide more flexibility and get rid of magic numbers.\n• Lines 13 to 21 create a object for every cell on the grid. Note that you set several attributes, including , , , and so on.\n• Line 22 adds every new button to the dictionary. The buttons work as keys, and their coordinates—expressed as —work as values.\n• Lines 23 to 29 finally add every button to the main window using the geometry manager. Now that you’ve implemented and , you can call them from the class initializer. Go ahead and add the following two lines to in your class: These two lines put together the game board by adding the display and grid of cells. Isn’t that cool? With these updates, you can almost run your app and see how your tic-tac-toe game will look. You just need to write a few more lines of boilerplate code. You need to instantiate and call its method to launch your Tkinter app. Go ahead and add the following piece of code to the end of your file: \"\"\"Create the game's board and run its main loop.\"\"\" This code snippet defines a function for your game. Inside this function, you first instantiate and then run its main loop by calling . The construct is a common pattern in Python applications. It allows you to control the execution of your code. In this case, the call to will only happen if you run the file as an executable program, as opposed to an importable module. That’s it! You’re now ready to run your game for the first time. Of course, the game isn’t playable yet, but the board is ready. To run the game, go ahead and execute the following command on your command line: Once you’ve run this command, then you’ll get the following window on your screen: Cool! Your tic-tac-toe game is starting to look like the real thing. Now you need to make this window respond to the players’ actions on the board.\n\nStep 2: Set Up the Tic-Tac-Toe Game Logic in Python Up to this point, you’ve put together a suitable tic-tac-toe game board using Tkinter. Now you need to think of how to deal with the game’s logic. This logic will consist of code that processes a player’s move and determines if this player has won the game or not. Several ideas are key when it comes to implementing the logic of a tic-tac-toe game. First, you need a valid representation of the players and their moves. You also need a higher-level class to represent the game itself. In this section, you’ll define classes for these three logic concepts. You can download the source code for this step by clicking the link below and navigating to the folder: Get Source Code: Click here to get access to the source code that you’ll use to build your tic-tac-toe game. Define Classes for the Players and Their Moves In the first round, you’ll define classes to represent players and their moves on the game board. These classes will be pretty bare-bones. All they need is a few attributes each. They don’t even need to have any methods. You can use a few tools to build classes that fulfill these requirements. For example, you can use either a data class or a named tuple. In this tutorial, you’ll use a named tuple for both classes because this kind of class provides all you need. Instead of using the classic from the module, you’ll use the class from as a way to provide initial type hint information in your classes. Go back to your code editor and add the following code at the beginning of your file:\n• Lines 5 to 7 define the class. The attribute will store the classic player signs, X and O. The attribute will hold a string with a Tkinter color. You’ll use this color to identify the target player on the game board.\n• Lines 9 to 12 define the class. The and attributes will hold the coordinates that identify the move’s target cell. The attribute will hold the sign that identifies the player, X or O. Note that defaults to the empty string, , which means that this specific move hasn’t been played yet. With these two classes in place, now you can define the class that you’ll use to represent the game logic. In this section, you’ll define a class to manage the game’s logic. This class will take care of processing the moves, finding a winner, toggling players, and performing a few other tasks. Get back to your file and add the following class right before your class: Here, you first import from the module. Then you define , whose initializer takes two arguments, and . The argument will hold a tuple of two objects, representing players X and O. This argument defaults to , a constant that you’ll define in a moment. The argument will hold a number representing the size of the game board. In a classic tic-tac-toe game, this size would be . In your class, the argument defaults to , another constant that you’ll define soon. Inside , you define the following instance attributes: A cyclical iterator over the input tuple of The combination of cells that defines a winner The list of players’ moves in a given game A Boolean variable to determine if the game has a winner or not A list containing the cell combinations that define a win The attribute calls from the module. This function takes an iterable as an argument and returns an iterator that cyclically yields items from the input iterable. In this case, the argument to is the tuple of default players passed in through the argument. As you go through this tutorial, you’ll learn more about all the attributes in the above table. Regarding the last line in , it calls , which is a method that you’ll also define in a moment. Now go ahead and define the following constants right below the class: As you already learned, holds the size of the tic-tac-toe board. Typically, this size is . So, you’ll have a three-by-three grid of cells on the board. On the other hand, defines a two-item tuple. Each item represents a player in the game. The and attributes of each player are set to suitable values. Player X will be blue, and player O will be green. Managing the game’s state in every moment is a fundamental step in the game’s logic. You need to keep track of every move on the board. To do this, you’ll use the attribute, which you’ll update whenever a player makes a move. You also need to determine which cell combinations on the board determine a win. You’ll store these combinations in the attribute. Here’s the method, which computes initial values for and : In , you use a list comprehension to provide an initial list of values for . The comprehension creates a list of lists. Each inner list will contain empty objects. An empty move stores the coordinates of its containing cell and an empty string as the initial player’s label. The last line of this method calls and assigns its return value to . You’ll implement this new method in the following section. On a classic tic-tac-toe board, you’ll have eight possible winning combinations. They’re essentially the rows, columns, and diagonals of the board. The following illustration shows these winning combinations: How would you get the coordinates of all these combinations using Python code? There are several ways to do it. In the code below, you’ll use four list comprehensions to get all the possible winning combinations: The main input for this method is the attribute. By default, this attribute will hold a list containing three sublists. Each sublist will represent a row on the grid and have three objects in it. The first comprehension iterates over the rows on the grid, getting the coordinates of every cell and building a sublist of coordinates. Each sublist of coordinates represents a winning combination. The second comprehension creates sublists containing the coordinates of each cell in the grid columns. The third and fourth comprehensions use a similar approach to get the coordinates of every cell in the board diagonals. Finally, the method returns a list of lists containing all possible winning combinations on the tic-tac-toe board. With this initial setup for your game board, you’re ready to start thinking about processing the players’ moves.\n\nStep 3: Process the Players’ Moves on the Game’s Logic In this tic-tac-toe game, you’ll mostly handle one type of event: players’ moves. Translated to Tkinter terms, a player’s move is just a click on the selected cell, which is represented by a button widget. Every player’s move will trigger a bunch of operations on the class. These operations include:\n• Toggling the player for the next move In the following sections, you’ll write the code to handle all these operations in your class. To download the source code for this step from GitHub, click the link below and navigate to the folder: Get Source Code: Click here to get access to the source code that you’ll use to build your tic-tac-toe game. You need to validate the move every time a player clicks a given cell on the tic-tac-toe board. The question is: What defines a valid move? Well, at least two conditions make a move valid. Players can only play if:\n• The selected move hasn’t already been played. Go ahead and add the following method to the end of : \"\"\"Return True if move is valid, and False otherwise.\"\"\" The method takes a object as an argument. Here’s what the rest of the method does:\n• Line 8 gets the and coordinates from the input .\n• Line 9 checks if the move at the current coordinates, , still holds an empty string as its label. This condition will be if no player has made the input before.\n• Line 10 checks if the game doesn’t have a winner yet. This method returns a Boolean value that results from checking if the game has no winner and the current move hasn’t been played yet. Now it’s time for you to determine if a player has won the game after their last move. This may be your chief concern as the game designer. Of course, you’ll have many different ways to find out if a given player has won the game. In this project, you’ll use the following ideas to determine the winner:\n• Every cell on the game board has an associated object.\n• Each object has a attribute that identifies the player who has made the move. To find out if the last player has won the game, you’ll check if the player’s label is present in all the possible moves contained in a given winning combination. Go ahead and add the following method to your class: \"\"\"Process the current move and check if it's a win.\"\"\" Here’s a breakdown of what this new method does line by line:\n• Line 6 defines , which takes a object as an argument.\n• Line 8 gets the and coordinates from the input .\n• Line 9 assigns the input to the item at in the list of current moves.\n• Lines 11 to 14 run a generator expression that retrieves all the labels from the moves in the current winning combination. The result is then converted into a object.\n• Line 15 defines a Boolean expression that checks if the current move determined a win or not. The result is stored in .\n• Line 16 checks the content of . If the variable holds , then is set to and is set to the current combination. Then the loop breaks and the function terminates. On lines 11 to 15, a few points and ideas need clarification. To better understand lines 11 to 14, say that all the labels in the moves associated with the cells of the current winning combination hold an X. In that case, the generator expression will yield three X labels. When you feed the built-in function with several instances of X, you get a set with a single instance of X. Sets don’t allow repeated values. So, if the set in contains a single value different from the empty string, then you have a winner. In this example, that winner would be the player with the X label. Line 15 checks both of these conditions. To wrap up the topic of finding the winner of your tic-tac-toe game, go ahead and add the following method at the end of your class: \"\"\"Return True if the game has a winner, and False otherwise.\"\"\" This method returns the Boolean value stored in whenever you need to check if the current match has a winner or not. You’ll use this method later in this tutorial. In the tic-tac-toe game, if the players play on all the cells and there’s no winner, then the game is tied. So, you have two conditions to check before declaring the game as tied:\n• All possible moves have been played.\n• The game has no winner. Go ahead and add the following method at the end of to check these conditions: \"\"\"Return True if the game is tied, and False otherwise.\"\"\" Inside , you first check if the game has no winner yet. Then you use the built-in function to check if all the moves in have a label different from the empty string. If this is the case, then all the possible cells have already been played. If both conditions are true, then the game is tied. Every time a player makes a valid move, you need to toggle the current player so that the other player can make the next move. To provide this functionality, go ahead and add the following method to your class: Because holds an iterator that cyclically loops over the two default players, you can call on this iterator to get the next player whenever you need it. This toggling mechanism will allow the next player to take their turn and continue the game.\n\nAt this point, you’re able to handle the players’ moves on the game logic. Now you have to connect this logic to the game board itself. You also need to write the code to make the board respond to players’ moves. First, go ahead and inject the game logic into the game board. To do this, update the class as in the code below: In this code snippet, you first add a argument to the initializer. Then you assign this argument to an instance attribute, , which will give you full access to the game logic from the game board. The second update is to use to set the board size instead of using a magic number. This update also enables you to use different board sizes. For example, you can create a four-by-four board grid, which can be an exciting experience. With these updates, you’re ready to dive into handling the players’ moves on the class. As usual, you can download the source code for this step by clicking the link below and navigating to the folder: Get Source Code: Click here to get access to the source code that you’ll use to build your tic-tac-toe game. The method on the class runs what’s known as the application’s main loop or event loop. This is an infinite loop in which all the GUI events happen. Inside this loop, you can handle the events on the application’s user interface. An event is a user action on the GUI, such as a keypress, mouse move, or mouse click. When a player in your tic-tac-toe game clicks a cell, a click event occurs inside the game’s event loop. You can process this event by providing an appropriate handler method on your class. To do this, get back to your code editor and add the following method at the end of the class: This method is fundamental in your tic-tac-toe game because it puts together almost all the game logic and GUI behavior. Here’s a summary of what this method does:\n• Line 6 defines , which takes a Tkinter event object as an argument.\n• Line 8 retrieves the widget that triggered the current event. This widget will be one of the buttons on the board grid.\n• Line 9 unpacks the button’s coordinates into two local variables, and .\n• Line 10 creates a new object using , , and the current player’s attribute as arguments.\n• Line 11 starts a conditional statement that checks if the player’s move is valid or not. If the move is valid, then the code block runs. Otherwise, no further action takes place.\n• Line 12 updates the clicked button by calling the method. You’ll write this method in the next section. In short, the method updates the button’s text to reflect the current player’s label and color.\n• Line 13 calls on the object using the current move as an argument.\n• Line 14 checks if the game is tied. If that’s the case, then the game display gets updated accordingly.\n• Line 16 checks if the current player has won the game. Then line 18 highlights the winning cells, and lines 19 to 21 update the game display to acknowledge the winner.\n• Line 21 runs if the game isn’t tied and there’s no winner. In this case, lines 23 to 25 toggle the player for the next move and update the display to point out the player who will play next. You’re almost there! With a few more updates and additions, your tic-tac-toe game will be ready for its first-ever match. The next step is to connect every button on the game board to the method. To do this, get back to the method and update it as in the code below: The highlighted line binds the click event of every button on the game board with the method. This way, whenever a player clicks a given button, the method will run to process the move and update the game state. To complete the code for processing the players’ moves on the game board, you need to write three helper methods. These methods will complete the following actions: To kick things off, go ahead and add to : In this code snippet, calls on the clicked button to set its attribute to the current player’s label. The method also sets the text foreground color, , to the current player’s color. The next helper method to add is : In this method, instead of using to tweak the text and color of the game display, you use a dictionary-style subscript notation. Using this type of notation is another option that Tkinter provides for accessing a widget’s attributes. Finally, you need a helper method to highlight the winning cells once a given player makes a winning move: The loop inside iterates over the items in the dictionary. This dictionary maps buttons to their row and column coordinates on the board grid. If the current coordinates are in a winning cell combination, then the button’s background color is set to , highlighting the cell combination on the board. With this last helper method in place, your tic-tac-toe game is ready for the first match! Run Your Tic-Tac-Toe Game for the First Time To finish putting together the logic and the user interface of your tic-tac-toe game, you need to update the game’s function. Up to this point, you have a object only. You need to create a object and pass it over to the updated constructor. Get back to and update it like in the code below: \"\"\"Create the game's board and run its main loop.\"\"\" In this code, the first highlighted line creates an instance of , which you’ll use to handle the game logic. The second highlighted line passes the new instance to the class constructor, which injects the game logic into the game board. With these updates in place, you can now run your game. To do this, fire up a terminal window and navigate to the directory containing your file. Then run the following command: Once this command has run, then your game’s main window will appear on your screen. Go ahead and give it a try! It’ll behave something like this: Wow! Your game project looks amazing so far! It allows two players to share their mouse and play a classic tic-tac-toe match. The game GUI looks nice and, in general, the game works as expected. In the following section, you’ll write code to allow the players to restart the game and play again. You’ll also provide the option of exiting the game.\n\nStep 5: Provide Options to Play Again and Exit the Game In this section, you’ll provide your tic-tac-toe game with a main menu. This menu will have an option to restart the game so that the players can start another match. It’ll also have an option to exit the game once the players have finished playing. Main menus are often an essential component of many GUI applications. So, learning how to create them in Tkinter is a good exercise to improve your GUI-related skills beyond the game development itself. This is an example of how building your own games is a powerful learning experience because it allows you to integrate knowledge and skills that you can later use in other non-game projects. The complete source code for this step is available for download. Just click the link below and navigate to the folder: Get Source Code: Click here to get access to the source code that you’ll use to build your tic-tac-toe game. To add a main menu to a Tkinter application, you can use the class. This class allows you to create a menu bar on top of your Tkinter window. It also allows you to add dropdown menus to the menu bar. Here’s the code that creates and adds a main menu to your tic-tac-toe game: Here’s what this code does line by line:\n• Line 7 defines a helper method called to handle the menu creation in a single place.\n• Line 8 creates an instance of , which will work as the menu bar.\n• Line 9 sets the menu bar object as the main menu of your current Tkinter window.\n• Line 10 creates another instance of to provide a File menu. Note that the argument in the class constructor is set to your menu bar object.\n• Lines 11 to 14 add a new menu option to the File menu using the method. This new option will have the label . When a user clicks this option, the application will run the method, which you provided through the argument. You’ll write this method in the following section.\n• Line 15 adds a menu separator using the method. Separators are useful when you need to separate groups of related commands in a given dropdown menu.\n• Line 16 adds an Exit command to the File menu. This command will make the game exit by calling the function.\n• Line 17 finally adds the File menu to the menu bar by calling with appropriate arguments. To actually add the main menu to your game’s main window, you need to call from the initializer of . So, go ahead and add the following line to the class’s method: With this final update, your game’s main menu is almost ready for use. However, before using it, you must implement the method. That’s what you’ll do in the following section in order to allow the players to play again. To reset the game board and allow the players to play again, you need to add code to both classes, and . In the game logic class, you need to reset the attribute to hold a list of initially empty objects. You also need to reset the and to their initial state. On the other hand, in the game board class, you need to reset the board display and cells to their initial state. Get back to in your code editor and add the following method right at the end of the class: \"\"\"Reset the game state to play again.\"\"\" The loop in sets all the current moves to an empty object. An empty move’s main characteristic is that its attribute holds the empty string, . After updating the current moves, the methods sets to and to an empty list. These three resets ensure that the game’s abstract representation is ready to start a new match. Note that doesn’t reset the player back to X when preparing the game for a new match. Typically, the winner of the previous match gets to go first in the next one. So, there’s no need to reset the player here. Once you’ve provided the required new functionality in the game logic, then you’re ready to update the game board functionality. Go ahead and add the following method to the end of : \"\"\"Reset the game's board to play again.\"\"\" This method works as follows:\n• Line 9 updates the board display to hold the initial text, .\n• Line 10 starts a loop over the buttons on the board grid.\n• Lines 11 to 13 restore every button’s , , and properties to their initial state. That’s it! With this last feature, your tic-tac-toe game project is complete. Go ahead and give it a try!"
    },
    {
        "link": "https://stackoverflow.com/questions/59397253/python-defining-functions-in-tic-tac-toe",
        "document": "First, your problem is that you call the method wrong. you should call it like the following:\n\nfix this issue and you will enter to the right conditions\n\nSecond you should change your loop in the like the following:\n\nnotice the if you won't set you will not enter The loop.\n\nThird, you should move the calling to the function to the end of all the function deceleration in order for them all to be properly recognized.\n\ncorrect the with the logic I provided you in my"
    },
    {
        "link": "https://geeksforgeeks.org/python-implementation-automatic-tic-tac-toe-game-using-random-number",
        "document": "Tic-tac-toe is a very popular game, so let’s implement an automatic Tic-tac-toe game using Python. The game is automatically played by the program and hence, no user input is needed. Still, developing an automatic game will be lots of fun. Let’s see how to do this. NumPy and random Python libraries are used to build this game. Instead of asking the user to put a mark on the board, the code randomly chooses a place on the board and put the mark. It will display the board after each turn unless a player wins. If the game gets drawn, then it returns -1.\n\nExplanation: play_game() is the main function, which performs the following tasks :\n• Calls create_board() to create a 3×3 board and initializes with 0.\n• For each player (1 or 2), calls the random_place() function to randomly choose a location on board and mark that location with the player number, alternatively.\n• Print the board after each move.\n• Evaluate the board after each move to check whether a row or column or diagonal has the same player number. If so, displays the winner’s name. If after 9 moves, there is no winner then displays -1.\n\nBelow is the code for the above game:\n• The code starts by importing all the necessary libraries.\n• Next, it creates an empty board and checks for empty places on the board.\n• The possibilities() function then selects a random place for the player and returns the board.\n• The row_win(), col_win(), and diag_win() functions check whether the player has three of their marks in a horizontal row, vertical row, or diagonal row, respectively.\n• If so, they return True and win is set to that player.\n• If not, they continue checking until either one of these conditions is met.\n• Finally, evaluate() determines whether there is a winner or tie based on the results of the other two functions.\n• If there is no winner (i.e., all players have zero marks), then no action is taken and the program terminates with an error message stating that there was no game played!\n• Otherwise, if both players have at least one mark in each column and row but not in any diagonal line (a situation called a deadlock), then play continues as normal with whoever has more wins being declared the winner.\n• In case of a tie, play goes back to evaluating who won last time; this process repeats until somebody wins or somebody loses all their pieces (which ends up being Game Over\n• The code creates an empty board and then checks for the player having three marks in a horizontal row, vertical row or diagonal row.\n• If the player has achieved this, the code sets the winner variable to be equal to the corresponding value from that row on the board.\n• If there is no winner, then all of the players’ pieces are set to 0 and the program ends."
    }
]