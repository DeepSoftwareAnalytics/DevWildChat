[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html",
        "document": "\n• instance representing the specified value. If a new instance is not required, this method should generally be used in preference to the constructor to , inclusive, and may cache other values outside of this range. Returns ainstance representing the specifiedvalue. If a newinstance is not required, this method should generally be used in preference to the constructor , as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the rangeto, inclusive, and may cache other values outside of this range.\n• Returns the value of this object. the primitive value represented by this object.\n• Returns a hash code for this ; equal to the result of invoking . a hash code value for this\n• Returns a hash code for a value; compatible with . - The for which to return a hash code. a hash code value for a value.\n• Compares this object against the specified object. The result is if and only if the argument is not and is a object that represents the same value as this object. - the object to compare with. if the objects are the same; otherwise.\n• Returns a object representing this 's value. The result is a string of length 1 whose sole component is the primitive value represented by this object.\n• Returns a object representing the specified . The result is a string of length 1 consisting solely of the specified . - the to be converted the string representation of the specified\n• Determines whether the specified code point is a valid Unicode code point value - the Unicode code point to be tested if the specified code point value is between and inclusive; otherwise.\n• . Determines whether the specified character (Unicode code point) is in the Basic Multilingual Plane (BMP) . Such code points can be represented using a single - the character (Unicode code point) to be tested if the specified code point is between and inclusive; otherwise.\n• Determines whether the specified character (Unicode code point) is in the supplementary character range. - the character (Unicode code point) to be tested if the specified code point is between and inclusive; otherwise.\n• value is a leading-surrogate code unit). Determines if the givenvalue is a Unicode high-surrogate code unit (also known as). Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. - the value to be tested. if the value is between and inclusive; otherwise.\n• value is a trailing-surrogate code unit). Determines if the givenvalue is a Unicode low-surrogate code unit (also known as). Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. - the value to be tested. if the value is between and inclusive; otherwise.\n• value is a Unicode surrogate code unit. Determines if the givenvalue is a Unicode Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. A char value is a surrogate code unit if and only if it is either a low-surrogate code unit or a high-surrogate code unit. - the value to be tested. if the value is between and inclusive; otherwise.\n• values is a valid Determines whether the specified pair ofvalues is a valid Unicode surrogate pair This method is equivalent to the expression: - the high-surrogate code value to be tested - the low-surrogate code value to be tested if the specified high and low-surrogate code values represent a valid surrogate pair; otherwise.\n• values needed to represent the specified character (Unicode code point). If the specified character is equal to or greater than 0x10000, then the method returns 2. Otherwise, the method returns 1. Determines the number ofvalues needed to represent the specified character (Unicode code point). If the specified character is equal to or greater than 0x10000, then the method returns 2. Otherwise, the method returns 1. This method doesn't validate the specified character to be a valid Unicode code point. The caller must validate the character value using if necessary. - the character (Unicode code point) to be tested. 2 if the character is a valid supplementary character; 1 otherwise.\n• Converts the specified surrogate pair to its supplementary code point value. This method does not validate the specified surrogate pair. The caller must validate it using if necessary. the supplementary code point composed from the specified surrogate pair.\n• Returns the code point at the given index of the . If the value at the given index in the is in the high-surrogate range, the following index is less than the length of the , and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in to be converted the Unicode code point at the given index - if the value is negative or not less than .\n• Returns the code point at the given index of the array. If the value at the given index in the array is in the high-surrogate range, the following index is less than the length of the array, and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in the array to be converted the Unicode code point at the given index - if the value is negative or not less than the length of the array.\n• Returns the code point at the given index of the array, where only array elements with less than can be used. If the value at the given index in the array is in the high-surrogate range, the following index is less than the , and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in the array to be converted - the index after the last array element that can be used in the array the Unicode code point at the given index - if the argument is negative or not less than the argument, or if the argument is negative or greater than the length of the array.\n• Returns the code point preceding the given index of the . If the value at in the is in the low-surrogate range, is not negative, and the value at in the is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than .\n• Returns the code point preceding the given index of the array. If the value at in the array is in the low-surrogate range, is not negative, and the value at in the array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than the length of the array\n• Returns the code point preceding the given index of the array, where only array elements with greater than or equal to can be used. If the value at in the array is in the low-surrogate range, is not less than , and the value at in the array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned - the index of the first array element in the array the Unicode code point value before the given index. - if the argument is not greater than the argument or is greater than the length of the array, or if the argument is negative or not less than the length of the array.\n• is returned. Returns the leading surrogate (a high surrogate code unit ) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character , an unspecifiedis returned. If is , then and are also always . the leading surrogate code unit used to represent the character in the UTF-16 encoding\n• is returned. Returns the trailing surrogate (a low surrogate code unit ) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character , an unspecifiedis returned. If is , then and are also always . the trailing surrogate code unit used to represent the character in the UTF-16 encoding\n• Converts the specified character (Unicode code point) to its UTF-16 representation. If the specified code point is a BMP (Basic Multilingual Plane or Plane 0) value, the same value is stored in , and 1 is returned. If the specified code point is a supplementary character, its surrogate values are stored in (high-surrogate) and (low-surrogate), and 2 is returned. - the character (Unicode code point) to be converted. - an array of in which the 's UTF-16 value is stored. - the start index into the array where the converted value is stored. 1 if the code point is a BMP code point, 2 if the code point is a supplementary code point. - if the specified is not a valid Unicode code point. - if the specified is null. - if is negative or not less than , or if at doesn't have enough array element(s) to store the resulting value(s). (If is equal to and the specified is a supplementary character, the high-surrogate value is not stored in .)\n• Converts the specified character (Unicode code point) to its UTF-16 representation stored in a array. If the specified code point is a BMP (Basic Multilingual Plane or Plane 0) value, the resulting array has the same value as . If the specified code point is a supplementary code point, the resulting array has the corresponding surrogate pair. - if the specified is not a valid Unicode code point.\n• Returns the number of Unicode code points in the text range of the specified char sequence. The text range begins at the specified and extends to the at index . Thus the length (in s) of the text range is . Unpaired surrogates within the text range count as one code point each. - the index to the first of the text range. - the index after the last of the text range. the number of Unicode code points in the specified text range - if the is negative, or is larger than the length of the given sequence, or is larger than .\n• Returns the number of Unicode code points in a subarray of the array argument. The argument is the index of the first of the subarray and the argument specifies the length of the subarray in s. Unpaired surrogates within the subarray count as one code point each. - the index of the first in the given array - the length of the subarray in s the number of Unicode code points in the specified subarray - if or is negative, or if is larger than the length of the given array.\n• Returns the index within the given char sequence that is offset from the given by code points. Unpaired surrogates within the text range given by and count as one code point each. - the index to be offset the index within the char sequence - if is negative or larger then the length of the char sequence, or if is positive and the subsequence starting with has fewer than code points, or if is negative and the subsequence before has fewer than the absolute value of code points.\n• Returns the index within the given subarray that is offset from the given by code points. The and arguments specify a subarray of the array. Unpaired surrogates within the text range given by and count as one code point each. - the index of the first of the subarray - the length of the subarray in s - the index to be offset the index within the subarray - if or is negative, or if is larger than the length of the given array, or if is less than or larger then , or if is positive and the text range starting with and ending with has fewer than code points, or if is negative and the text range starting with and ending with has fewer than the absolute value of code points.\n• Determines if the specified character is a lowercase character. A character is lowercase if its general category type, provided by , is , or it has contributory property Other_Lowercase as defined by the Unicode Standard. The following are examples of lowercase characters: Many other Unicode characters are lowercase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is lowercase; otherwise.\n• Determines if the specified character (Unicode code point) is a lowercase character. A character is lowercase if its general category type, provided by , is , or it has contributory property Other_Lowercase as defined by the Unicode Standard. The following are examples of lowercase characters: Many other Unicode characters are lowercase too. - the character (Unicode code point) to be tested. if the character is lowercase; otherwise.\n• Determines if the specified character is an uppercase character. A character is uppercase if its general category type, provided by , is . or it has contributory property Other_Uppercase as defined by the Unicode Standard. The following are examples of uppercase characters: Many other Unicode characters are uppercase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is uppercase; otherwise.\n• Determines if the specified character (Unicode code point) is an uppercase character. A character is uppercase if its general category type, provided by , is , or it has contributory property Other_Uppercase as defined by the Unicode Standard. The following are examples of uppercase characters: Many other Unicode characters are uppercase too. - the character (Unicode code point) to be tested. if the character is uppercase; otherwise.\n• Determines if the specified character is a titlecase character. A character is a titlecase character if its general category type, provided by , is . Some characters look like pairs of Latin letters. For example, there is an uppercase letter that looks like \"LJ\" and has a corresponding lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\", is the appropriate form to use when rendering a word in lowercase with initial capitals, as for a book title. These are some of the Unicode characters for which this method returns : Many other Unicode characters are titlecase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is titlecase; otherwise.\n• Determines if the specified character (Unicode code point) is a titlecase character. A character is a titlecase character if its general category type, provided by , is . Some characters look like pairs of Latin letters. For example, there is an uppercase letter that looks like \"LJ\" and has a corresponding lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\", is the appropriate form to use when rendering a word in lowercase with initial capitals, as for a book title. These are some of the Unicode characters for which this method returns : Many other Unicode characters are titlecase too. - the character (Unicode code point) to be tested. if the character is titlecase; otherwise.\n• Determines if the specified character is a digit. A character is a digit if its general category type, provided by , is . Some Unicode character ranges that contain digits: Many other character ranges contain digits as well. Many other character ranges contain digits as well. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a digit; otherwise.\n• Determines if the specified character (Unicode code point) is a digit. A character is a digit if its general category type, provided by , is . Some Unicode character ranges that contain digits: Many other character ranges contain digits as well. Many other character ranges contain digits as well. - the character (Unicode code point) to be tested. if the character is a digit; otherwise.\n• Determines if a character is defined in Unicode. A character is defined if at least one of the following is true:\n• It has an entry in the UnicodeData file.\n• It has a value in a range defined by the UnicodeData file. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested if the character has a defined meaning in Unicode; otherwise.\n• Determines if a character (Unicode code point) is defined in Unicode. A character is defined if at least one of the following is true:\n• It has an entry in the UnicodeData file.\n• It has a value in a range defined by the UnicodeData file. - the character (Unicode code point) to be tested. if the character has a defined meaning in Unicode; otherwise.\n• Determines if the specified character is a letter. A character is considered to be a letter if its general category type, provided by , is any of the following: Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a letter; otherwise.\n• Determines if the specified character (Unicode code point) is a letter. A character is considered to be a letter if its general category type, provided by , is any of the following: Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. - the character (Unicode code point) to be tested. if the character is a letter; otherwise.\n• Determines if the specified character is a letter or digit. A character is considered to be a letter or digit if either or returns for the character. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a letter or digit; otherwise.\n• Determines if the specified character (Unicode code point) is a letter or digit. A character is considered to be a letter or digit if either or returns for the character. - the character (Unicode code point) to be tested. if the character is a letter or digit; otherwise.\n• Determines if the specified character is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following conditions is true:\n• is a currency symbol (such as )\n• is a connecting punctuation character (such as ). These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. - the character to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the specified character may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if and only if any of the following conditions are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. - the character to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the specified character (Unicode code point) is an alphabet. A character is considered to be alphabetic if its general category type, provided by , is any of the following: or it has contributory property Other_Alphabetic as defined by the Unicode Standard. or it has contributory property Other_Alphabetic as defined by the Unicode Standard. - the character (Unicode code point) to be tested. if the character is a Unicode alphabet character, otherwise.\n• Determines if the specified character (Unicode code point) is a CJKV (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by the Unicode Standard. - the character (Unicode code point) to be tested. if the character is a Unicode ideograph character, otherwise.\n• Determines if the specified character is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following conditions is true:\n• is a currency symbol (such as )\n• is a connecting punctuation character (such as ). These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the character (Unicode code point) is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following conditions is true:\n• the referenced character is a currency symbol (such as )\n• the referenced character is a connecting punctuation character (such as ). These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. - the character (Unicode code point) to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the specified character may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if any of the following conditions are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the character (Unicode code point) may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if any of the following conditions are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) These conditions are tested against the character information from version 6.2 of the Unicode Standard. These conditions are tested against the character information from version 6.2 of the Unicode Standard. - the character (Unicode code point) to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the specified character is permissible as the first character in a Unicode identifier. A character may start a Unicode identifier if and only if one of the following conditions is true: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may start a Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) is permissible as the first character in a Unicode identifier. A character may start a Unicode identifier if and only if one of the following conditions is true: - the character (Unicode code point) to be tested. if the character may start a Unicode identifier; otherwise.\n• Determines if the specified character may be part of a Unicode identifier as other than the first character. A character may be part of a Unicode identifier if and only if one of the following statements is true:\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may be part of a Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) may be part of a Unicode identifier as other than the first character. A character may be part of a Unicode identifier if and only if one of the following statements is true:\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) - the character (Unicode code point) to be tested. if the character may be part of a Unicode identifier; otherwise.\n• Determines if the specified character should be regarded as an ignorable character in a Java identifier or a Unicode identifier. The following Unicode characters are ignorable in a Java identifier or a Unicode identifier:\n• ISO control characters that are not whitespace\n• all characters that have the general category value Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is an ignorable control character that may be part of a Java or Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) should be regarded as an ignorable character in a Java identifier or a Unicode identifier. The following Unicode characters are ignorable in a Java identifier or a Unicode identifier:\n• ISO control characters that are not whitespace\n• all characters that have the general category value - the character (Unicode code point) to be tested. if the character is an ignorable control character that may be part of a Java or Unicode identifier; otherwise.\n• Converts the character argument to lowercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to lowercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the lowercase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to lowercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to lowercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. - the character (Unicode code point) to be converted. the lowercase equivalent of the character (Unicode code point), if any; otherwise, the character itself.\n• Converts the character argument to uppercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to uppercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the uppercase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to uppercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to uppercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. - the character (Unicode code point) to be converted. the uppercase equivalent of the character, if any; otherwise, the character itself.\n• argument is already a titlecase , the same value will be returned. Converts the character argument to titlecase using case mapping information from the UnicodeData file. If a character has no explicit titlecase mapping and is not itself a titlecase char according to UnicodeData, then the uppercase mapping is returned as an equivalent titlecase mapping. If theargument is already a titlecase, the samevalue will be returned. Note that does not always return for some ranges of characters. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the titlecase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to titlecase using case mapping information from the UnicodeData file. If a character has no explicit titlecase mapping and is not itself a titlecase char according to UnicodeData, then the uppercase mapping is returned as an equivalent titlecase mapping. If the character argument is already a titlecase character, the same character value will be returned. Note that does not always return for some ranges of characters. - the character (Unicode code point) to be converted. the titlecase equivalent of the character, if any; otherwise, the character itself.\n• in the specified radix. Returns the numeric value of the characterin the specified radix. If the radix is not in the range ≤ ≤ or if the value of is not a valid digit in the specified radix, is returned. A character is a valid digit if at least one of the following is true:\n• The method is of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.\n• The character is one of the uppercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the lowercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the fullwidth uppercase Latin letters A ( ) through Z ( ) and its code is less than . In this case, is returned.\n• The character is one of the fullwidth lowercase Latin letters a ( ) through z ( ) and its code is less than . In this case, is returned. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the numeric value represented by the character in the specified radix.\n• Returns the numeric value of the specified character (Unicode code point) in the specified radix. If the radix is not in the range ≤ ≤ or if the character is not a valid digit in the specified radix, is returned. A character is a valid digit if at least one of the following is true:\n• The method is of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.\n• The character is one of the uppercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the lowercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the fullwidth uppercase Latin letters A ( ) through Z ( ) and its code is less than . In this case, is returned.\n• The character is one of the fullwidth lowercase Latin letters a ( ) through z ( ) and its code is less than . In this case, is returned. - the character (Unicode code point) to be converted. the numeric value represented by the character in the specified radix.\n• value that the specified Unicode character represents. For example, the character (the roman numeral fifty) will return an int with a value of 50. Returns thevalue that the specified Unicode character represents. For example, the character(the roman numeral fifty) will return an int with a value of 50. The letters A-Z in their uppercase ( through ), lowercase ( through ), and full width variant ( through and through ) forms have numeric values from 10 through 35. This is independent of the Unicode specification, which does not assign numeric values to these values. If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the numeric value of the character, as a nonnegative value; -2 if the character has a numeric value that is not a nonnegative integer; -1 if the character has no numeric value.\n• value that the specified character (Unicode code point) represents. For example, the character (the Roman numeral fifty) will return an with a value of 50. Returns thevalue that the specified character (Unicode code point) represents. For example, the character(the Roman numeral fifty) will return anwith a value of 50. The letters A-Z in their uppercase ( through ), lowercase ( through ), and full width variant ( through and through ) forms have numeric values from 10 through 35. This is independent of the Unicode specification, which does not assign numeric values to these values. If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned. - the character (Unicode code point) to be converted. the numeric value of the character, as a nonnegative value; -2 if the character has a numeric value that is not a nonnegative integer; -1 if the character has no numeric value.\n• for the following five characters only: Determines if the specified character is ISO-LATIN-1 white space. This method returnsfor the following five characters only: - the character to be tested. if the character is ISO-LATIN-1 white space; otherwise.\n• Determines if the specified character is a Unicode space character. A character is considered to be a space character if and only if it is specified to be a space character by the Unicode Standard. This method returns true if the character's general category type is any of the following: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a space character; otherwise.\n• Determines if the specified character (Unicode code point) is a Unicode space character. A character is considered to be a space character if and only if it is specified to be a space character by the Unicode Standard. This method returns true if the character's general category type is any of the following: - the character (Unicode code point) to be tested. if the character is a space character; otherwise.\n• \n• It is a Unicode space character ( , , or ) but is not also a non-breaking space ( , , ). Determines if the specified character is white space according to Java. A character is a Java whitespace character if and only if it satisfies one of the following criteria: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a Java whitespace character; otherwise.\n• \n• It is a Unicode space character ( , , or ) but is not also a non-breaking space ( , , ). Determines if the specified character (Unicode code point) is white space according to Java. A character is a Java whitespace character if and only if it satisfies one of the following criteria: - the character (Unicode code point) to be tested. if the character is a Java whitespace character; otherwise.\n• through or in the range through . Determines if the specified character is an ISO control character. A character is considered to be an ISO control character if its code is in the rangethroughor in the rangethrough Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is an ISO control character; otherwise.\n• Determines if the referenced character (Unicode code point) is an ISO control character. A character is considered to be an ISO control character if its code is in the range through or in the range through . - the character (Unicode code point) to be tested. if the character is an ISO control character; otherwise.\n• Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. a value of type representing the character's general category.\n• - the character (Unicode code point) to be tested. a value of type representing the character's general category.\n• is not a valid radix, or the value of is not a valid digit in the specified radix, the null character ( ) is returned. Determines the character representation for a specific digit in the specified radix. If the value ofis not a valid radix, or the value ofis not a valid digit in the specified radix, the null character () is returned. The argument is valid if it is greater than or equal to and less than or equal to . The argument is valid if . If the digit is less than 10, then is returned. Otherwise, the value is returned. - the number to convert to a character. the representation of the specified digit in the specified radix.\n• values is . Returns the Unicode directionality property for the given character. Character directionality is used to calculate the visual ordering of text. The directionality value of undefinedvalues is Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - for which the directionality property is requested. the directionality property of the value.\n• Returns the Unicode directionality property for the given character (Unicode code point). Character directionality is used to calculate the visual ordering of text. The directionality value of undefined character is - the character (Unicode code point) for which the directionality property is requested. the directionality property of the character.\n• LEFT PARENTHESIS is semantically defined to be an opening parenthesis. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. Determines whether the character is mirrored according to the Unicode specification. Mirrored characters should have their glyphs horizontally mirrored when displayed in text that is right-to-left. For example,LEFT PARENTHESIS is semantically defined to be an. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - for which the mirrored property is requested if the char is mirrored, if the is not mirrored or is not defined.\n• Determines whether the specified character (Unicode code point) is mirrored according to the Unicode specification. Mirrored characters should have their glyphs horizontally mirrored when displayed in text that is right-to-left. For example, LEFT PARENTHESIS is semantically defined to be an opening parenthesis. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. - the character (Unicode code point) to be tested. if the character is mirrored, if the character is not mirrored or is not defined.\n• - the to be compared. the value if the argument is equal to this ; a value less than if this is numerically less than the argument; and a value greater than if this is numerically greater than the argument (unsigned comparison). Note that this is strictly a numerical comparison; it is not locale-dependent.\n• values numerically. The value returned is identical to what would be returned by: Compares twovalues numerically. The value returned is identical to what would be returned by: - the first to compare - the second to compare the value if ; a value less than if ; and a value greater than if\n• Returns the value obtained by reversing the order of the bytes in the specified value. - The of which to reverse the byte order. the value obtained by reversing (or, equivalently, swapping) the bytes in the specified value.\n• , or null if the code point is Returns the Unicode name of the specified character, or null if the code point is Note: if the specified character is not assigned a name by the UnicodeData file (part of the Unicode Character Database maintained by the Unicode Consortium), the returned name is the same as the result of expression. the Unicode name of the specified character, or null if the code point is unassigned. - if the specified is not a valid Unicode code point."
    },
    {
        "link": "https://geeksforgeeks.org/character-digit-in-java-with-examples",
        "document": "The java.lang.Character.digit() is an inbuilt method in java which returns the numeric value of the character ch in the specified radix. It returns -1 if the radix is not in the range MIN_RADIX <= radix <= MAX_RADIX or if the value of ch is not a valid digit in the specified radix. A character is a valid digit if at least one of the following is true:\n• The method isDigit is true of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.\n• The character is one of the uppercase Latin letters ‘A’ through ‘Z’ and its code is less than radix + ‘A’ – 10. In this case, ch – ‘A’ + 10 is returned.\n• The character is one of the lowercase Latin letters ‘a’ through ‘z’ and its code is less than radix + ‘a’ – 10. In this case, ch – ‘a’ + 10 is returned.\n• The character is one of the fullwidth uppercase Latin letters A (‘\\uFF21’) through Z (‘\\uFF3A’) and its code is less than radix + ‘\\uFF21’ – 10. In this case, ch – ‘\\uFF21’ + 10 is returned.\n• The character is one of the fullwidth lowercase Latin letters a (‘\\uFF41’) through z (‘\\uFF5A’) and its code is less than radix + ‘\\uFF41’ – 10. In this case, ch – ‘\\uFF41’ + 10 is returned.\n\nParameters:The function accepts two parameters which are described below:\n• ch- This is a mandatory parameter which specifies the character to be converted.\n• radix- This is a mandatory parameter which specifies radix.\n\nReturn value: This method returns the numeric value represented by the character in the specified radix.\n\nBelow programs demonstrates the above method:"
    },
    {
        "link": "https://stackoverflow.com/questions/17984975/convert-int-to-char-in-java",
        "document": "Can somebody explain this? And if I want to convert an int to a char as in the first snippet, what should I do?\n\nI will get 1 as my output.\n\nBut what I get is empty output.\n\nwill print out the char with Unicode code point 1 (start-of-heading char, which isn't printable; see this table: C0 Controls and Basic Latin, same as ASCII) will print out the char with Unicode code point 49 (one corresponding to '1') If you want to convert a digit (0-9), you can add 48 to it and cast, or something like . If you want to convert an seen as a Unicode code point, you can use for example.\n\nMy answer is similar to jh314's answer but I'll explain a little deeper. What you should do in this case is: Here, we used '0' because chars are actually represented by ASCII values. '0' is a char and represented by the value of 48. We typed and in order to add these up, Java converted '0' to its ASCII value which is 48 and a is 1 so the sum is 49. Then what we did is: We casted to . ASCII equivalent of 49 is '1'. You can convert any digit to char this way and is smarter and better way than using method and then subtracting the digit by method.\n\nIn java a char is an int. Your first snippet prints out the character corresponding to the value of 1 in the default character encoding scheme (which is probably Unicode). The Unicode character U+0001 is a non-printing character, which is why you don't see any output. If you want to print out the character '1', you can look up the value of '1' in the encoding scheme you are using. In Unicode this is 49 (the same as ASCII). But this will only work for digits 0-9. You might be better off using a String rather than a char, and using Java's built-in method: This will work whatever your system encoding is, and will work for multi-digit numbers.\n\nMy solution is for converting lower case alphabets (a-z) to (0-25) and vice versa. My answer is for a specific use-case it is not generic solution my solution will help you if you want to store the frequency of character into an integer array of size 26 instead of using Hashmap<Character,Integer> ----> for converting 0 to 25 into a-z ---->for converting a to z into 0-25 Again this approach will help you to get the frequency of characters as well as characters by using the above code we can get the frequency as well as character using integer array of size 26 . We can write if-else logic if you don't want to include the character with frequency 0.\n\nThanks for contributing an answer to Stack Overflow!\n• Please be sure to answer the question. Provide details and share your research!\n• Asking for help, clarification, or responding to other answers.\n• Making statements based on opinion; back them up with references or personal experience. To learn more, see our tips on writing great answers. Sign up or log in Sign up using Email and Password By clicking “Post Your Answer”, you agree to our terms of service and acknowledge you have read our privacy policy."
    },
    {
        "link": "https://docs.oracle.com/javase/7/docs/api/java/lang/Character.html",
        "document": "\n• instance representing the specified value. If a new instance is not required, this method should generally be used in preference to the constructor to , inclusive, and may cache other values outside of this range. Returns ainstance representing the specifiedvalue. If a newinstance is not required, this method should generally be used in preference to the constructor , as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the rangeto, inclusive, and may cache other values outside of this range.\n• Returns the value of this object. the primitive value represented by this object.\n• Returns a hash code for this ; equal to the result of invoking . a hash code value for this\n• Compares this object against the specified object. The result is if and only if the argument is not and is a object that represents the same value as this object. - the object to compare with. if the objects are the same; otherwise.\n• Returns a object representing this 's value. The result is a string of length 1 whose sole component is the primitive value represented by this object.\n• Returns a object representing the specified . The result is a string of length 1 consisting solely of the specified . - the to be converted the string representation of the specified\n• Determines whether the specified code point is a valid Unicode code point value - the Unicode code point to be tested if the specified code point value is between and inclusive; otherwise.\n• . Determines whether the specified character (Unicode code point) is in the Basic Multilingual Plane (BMP) . Such code points can be represented using a single - the character (Unicode code point) to be tested if the specified code point is between and inclusive; otherwise.\n• Determines whether the specified character (Unicode code point) is in the supplementary character range. - the character (Unicode code point) to be tested if the specified code point is between and inclusive; otherwise.\n• value is a leading-surrogate code unit). Determines if the givenvalue is a Unicode high-surrogate code unit (also known as). Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. - the value to be tested. if the value is between and inclusive; otherwise.\n• value is a trailing-surrogate code unit). Determines if the givenvalue is a Unicode low-surrogate code unit (also known as). Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. - the value to be tested. if the value is between and inclusive; otherwise.\n• value is a Unicode surrogate code unit. Determines if the givenvalue is a Unicode Such values do not represent characters by themselves, but are used in the representation of supplementary characters in the UTF-16 encoding. A char value is a surrogate code unit if and only if it is either a low-surrogate code unit or a high-surrogate code unit. - the value to be tested. if the value is between and inclusive; otherwise.\n• values is a valid Determines whether the specified pair ofvalues is a valid Unicode surrogate pair This method is equivalent to the expression: - the high-surrogate code value to be tested - the low-surrogate code value to be tested if the specified high and low-surrogate code values represent a valid surrogate pair; otherwise.\n• values needed to represent the specified character (Unicode code point). If the specified character is equal to or greater than 0x10000, then the method returns 2. Otherwise, the method returns 1. Determines the number ofvalues needed to represent the specified character (Unicode code point). If the specified character is equal to or greater than 0x10000, then the method returns 2. Otherwise, the method returns 1. This method doesn't validate the specified character to be a valid Unicode code point. The caller must validate the character value using if necessary. - the character (Unicode code point) to be tested. 2 if the character is a valid supplementary character; 1 otherwise.\n• Converts the specified surrogate pair to its supplementary code point value. This method does not validate the specified surrogate pair. The caller must validate it using if necessary. the supplementary code point composed from the specified surrogate pair.\n• Returns the code point at the given index of the . If the value at the given index in the is in the high-surrogate range, the following index is less than the length of the , and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in to be converted the Unicode code point at the given index - if the value is negative or not less than .\n• Returns the code point at the given index of the array. If the value at the given index in the array is in the high-surrogate range, the following index is less than the length of the array, and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in the array to be converted the Unicode code point at the given index - if the value is negative or not less than the length of the array.\n• Returns the code point at the given index of the array, where only array elements with less than can be used. If the value at the given index in the array is in the high-surrogate range, the following index is less than the , and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values (Unicode code units) in the array to be converted - the index after the last array element that can be used in the array the Unicode code point at the given index - if the argument is negative or not less than the argument, or if the argument is negative or greater than the length of the array.\n• Returns the code point preceding the given index of the . If the value at in the is in the low-surrogate range, is not negative, and the value at in the is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than .\n• Returns the code point preceding the given index of the array. If the value at in the array is in the low-surrogate range, is not negative, and the value at in the array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than the length of the array\n• Returns the code point preceding the given index of the array, where only array elements with greater than or equal to can be used. If the value at in the array is in the low-surrogate range, is not less than , and the value at in the array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at is returned. - the index following the code point that should be returned - the index of the first array element in the array the Unicode code point value before the given index. - if the argument is not greater than the argument or is greater than the length of the array, or if the argument is negative or not less than the length of the array.\n• is returned. Returns the leading surrogate (a high surrogate code unit ) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character , an unspecifiedis returned. If is , then and are also always . the leading surrogate code unit used to represent the character in the UTF-16 encoding\n• is returned. Returns the trailing surrogate (a low surrogate code unit ) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character , an unspecifiedis returned. If is , then and are also always . the trailing surrogate code unit used to represent the character in the UTF-16 encoding\n• Converts the specified character (Unicode code point) to its UTF-16 representation. If the specified code point is a BMP (Basic Multilingual Plane or Plane 0) value, the same value is stored in , and 1 is returned. If the specified code point is a supplementary character, its surrogate values are stored in (high-surrogate) and (low-surrogate), and 2 is returned. - the character (Unicode code point) to be converted. - an array of in which the 's UTF-16 value is stored. - the start index into the array where the converted value is stored. 1 if the code point is a BMP code point, 2 if the code point is a supplementary code point. - if the specified is not a valid Unicode code point. - if the specified is null. - if is negative or not less than , or if at doesn't have enough array element(s) to store the resulting value(s). (If is equal to and the specified is a supplementary character, the high-surrogate value is not stored in .)\n• Converts the specified character (Unicode code point) to its UTF-16 representation stored in a array. If the specified code point is a BMP (Basic Multilingual Plane or Plane 0) value, the resulting array has the same value as . If the specified code point is a supplementary code point, the resulting array has the corresponding surrogate pair. - if the specified is not a valid Unicode code point.\n• Returns the number of Unicode code points in the text range of the specified char sequence. The text range begins at the specified and extends to the at index . Thus the length (in s) of the text range is . Unpaired surrogates within the text range count as one code point each. - the index to the first of the text range. - the index after the last of the text range. the number of Unicode code points in the specified text range - if the is negative, or is larger than the length of the given sequence, or is larger than .\n• Returns the number of Unicode code points in a subarray of the array argument. The argument is the index of the first of the subarray and the argument specifies the length of the subarray in s. Unpaired surrogates within the subarray count as one code point each. - the index of the first in the given array - the length of the subarray in s the number of Unicode code points in the specified subarray - if or is negative, or if is larger than the length of the given array.\n• Returns the index within the given char sequence that is offset from the given by code points. Unpaired surrogates within the text range given by and count as one code point each. - the index to be offset the index within the char sequence - if is negative or larger then the length of the char sequence, or if is positive and the subsequence starting with has fewer than code points, or if is negative and the subsequence before has fewer than the absolute value of code points.\n• Returns the index within the given subarray that is offset from the given by code points. The and arguments specify a subarray of the array. Unpaired surrogates within the text range given by and count as one code point each. - the index of the first of the subarray - the length of the subarray in s - the index to be offset the index within the subarray - if or is negative, or if is larger than the length of the given array, or if is less than or larger then , or if is positive and the text range starting with and ending with has fewer than code points, or if is negative and the text range starting with and ending with has fewer than the absolute value of code points.\n• Determines if the specified character is a lowercase character. A character is lowercase if its general category type, provided by , is , or it has contributory property Other_Lowercase as defined by the Unicode Standard. The following are examples of lowercase characters: Many other Unicode characters are lowercase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is lowercase; otherwise.\n• Determines if the specified character (Unicode code point) is a lowercase character. A character is lowercase if its general category type, provided by , is , or it has contributory property Other_Lowercase as defined by the Unicode Standard. The following are examples of lowercase characters: Many other Unicode characters are lowercase too. - the character (Unicode code point) to be tested. if the character is lowercase; otherwise.\n• Determines if the specified character is an uppercase character. A character is uppercase if its general category type, provided by , is . or it has contributory property Other_Uppercase as defined by the Unicode Standard. The following are examples of uppercase characters: Many other Unicode characters are uppercase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is uppercase; otherwise.\n• Determines if the specified character (Unicode code point) is an uppercase character. A character is uppercase if its general category type, provided by , is , or it has contributory property Other_Uppercase as defined by the Unicode Standard. The following are examples of uppercase characters: Many other Unicode characters are uppercase too. - the character (Unicode code point) to be tested. if the character is uppercase; otherwise.\n• Determines if the specified character is a titlecase character. A character is a titlecase character if its general category type, provided by , is . Some characters look like pairs of Latin letters. For example, there is an uppercase letter that looks like \"LJ\" and has a corresponding lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\", is the appropriate form to use when rendering a word in lowercase with initial capitals, as for a book title. These are some of the Unicode characters for which this method returns : Many other Unicode characters are titlecase too. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is titlecase; otherwise.\n• Determines if the specified character (Unicode code point) is a titlecase character. A character is a titlecase character if its general category type, provided by , is . Some characters look like pairs of Latin letters. For example, there is an uppercase letter that looks like \"LJ\" and has a corresponding lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\", is the appropriate form to use when rendering a word in lowercase with initial capitals, as for a book title. These are some of the Unicode characters for which this method returns : Many other Unicode characters are titlecase too. - the character (Unicode code point) to be tested. if the character is titlecase; otherwise.\n• Determines if the specified character is a digit. A character is a digit if its general category type, provided by , is . Some Unicode character ranges that contain digits: Many other character ranges contain digits as well. Many other character ranges contain digits as well. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a digit; otherwise.\n• Determines if the specified character (Unicode code point) is a digit. A character is a digit if its general category type, provided by , is . Some Unicode character ranges that contain digits: Many other character ranges contain digits as well. Many other character ranges contain digits as well. - the character (Unicode code point) to be tested. if the character is a digit; otherwise.\n• Determines if a character is defined in Unicode. A character is defined if at least one of the following is true:\n• It has an entry in the UnicodeData file.\n• It has a value in a range defined by the UnicodeData file. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested if the character has a defined meaning in Unicode; otherwise.\n• Determines if a character (Unicode code point) is defined in Unicode. A character is defined if at least one of the following is true:\n• It has an entry in the UnicodeData file.\n• It has a value in a range defined by the UnicodeData file. - the character (Unicode code point) to be tested. if the character has a defined meaning in Unicode; otherwise.\n• Determines if the specified character is a letter. A character is considered to be a letter if its general category type, provided by , is any of the following: Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a letter; otherwise.\n• Determines if the specified character (Unicode code point) is a letter. A character is considered to be a letter if its general category type, provided by , is any of the following: Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase. - the character (Unicode code point) to be tested. if the character is a letter; otherwise.\n• Determines if the specified character is a letter or digit. A character is considered to be a letter or digit if either or returns for the character. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a letter or digit; otherwise.\n• Determines if the specified character (Unicode code point) is a letter or digit. A character is considered to be a letter or digit if either or returns for the character. - the character (Unicode code point) to be tested. if the character is a letter or digit; otherwise.\n• Determines if the specified character is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following is true:\n• is a currency symbol (such as )\n• is a connecting punctuation character (such as ). - the character to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the specified character may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if and only if any of the following are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) - the character to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the specified character (Unicode code point) is an alphabet. A character is considered to be alphabetic if its general category type, provided by , is any of the following: or it has contributory property Other_Alphabetic as defined by the Unicode Standard. or it has contributory property Other_Alphabetic as defined by the Unicode Standard. - the character (Unicode code point) to be tested. if the character is a Unicode alphabet character, otherwise.\n• Determines if the specified character (Unicode code point) is a CJKV (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by the Unicode Standard. - the character (Unicode code point) to be tested. if the character is a Unicode ideograph character, otherwise.\n• Determines if the specified character is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following conditions is true:\n• is a currency symbol (such as )\n• is a connecting punctuation character (such as ). Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the character (Unicode code point) is permissible as the first character in a Java identifier. A character may start a Java identifier if and only if one of the following conditions is true:\n• the referenced character is a currency symbol (such as )\n• the referenced character is a connecting punctuation character (such as ). - the character (Unicode code point) to be tested. if the character may start a Java identifier; otherwise.\n• Determines if the specified character may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if any of the following are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the character (Unicode code point) may be part of a Java identifier as other than the first character. A character may be part of a Java identifier if any of the following are true:\n• it is a currency symbol (such as )\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) - the character (Unicode code point) to be tested. if the character may be part of a Java identifier; otherwise.\n• Determines if the specified character is permissible as the first character in a Unicode identifier. A character may start a Unicode identifier if and only if one of the following conditions is true: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may start a Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) is permissible as the first character in a Unicode identifier. A character may start a Unicode identifier if and only if one of the following conditions is true: - the character (Unicode code point) to be tested. if the character may start a Unicode identifier; otherwise.\n• Determines if the specified character may be part of a Unicode identifier as other than the first character. A character may be part of a Unicode identifier if and only if one of the following statements is true:\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character may be part of a Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) may be part of a Unicode identifier as other than the first character. A character may be part of a Unicode identifier if and only if one of the following statements is true:\n• it is a connecting punctuation character (such as )\n• it is a numeric letter (such as a Roman numeral character) - the character (Unicode code point) to be tested. if the character may be part of a Unicode identifier; otherwise.\n• Determines if the specified character should be regarded as an ignorable character in a Java identifier or a Unicode identifier. The following Unicode characters are ignorable in a Java identifier or a Unicode identifier:\n• ISO control characters that are not whitespace\n• all characters that have the general category value Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is an ignorable control character that may be part of a Java or Unicode identifier; otherwise.\n• Determines if the specified character (Unicode code point) should be regarded as an ignorable character in a Java identifier or a Unicode identifier. The following Unicode characters are ignorable in a Java identifier or a Unicode identifier:\n• ISO control characters that are not whitespace\n• all characters that have the general category value - the character (Unicode code point) to be tested. if the character is an ignorable control character that may be part of a Java or Unicode identifier; otherwise.\n• Converts the character argument to lowercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to lowercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the lowercase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to lowercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to lowercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. - the character (Unicode code point) to be converted. the lowercase equivalent of the character (Unicode code point), if any; otherwise, the character itself.\n• Converts the character argument to uppercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to uppercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the uppercase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to uppercase using case mapping information from the UnicodeData file. Note that does not always return for some ranges of characters, particularly those that are symbols or ideographs. In general, should be used to map characters to uppercase. case mapping methods have several benefits over case mapping methods. case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the case mapping methods cannot. - the character (Unicode code point) to be converted. the uppercase equivalent of the character, if any; otherwise, the character itself.\n• argument is already a titlecase , the same value will be returned. Converts the character argument to titlecase using case mapping information from the UnicodeData file. If a character has no explicit titlecase mapping and is not itself a titlecase char according to UnicodeData, then the uppercase mapping is returned as an equivalent titlecase mapping. If theargument is already a titlecase, the samevalue will be returned. Note that does not always return for some ranges of characters. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the titlecase equivalent of the character, if any; otherwise, the character itself.\n• Converts the character (Unicode code point) argument to titlecase using case mapping information from the UnicodeData file. If a character has no explicit titlecase mapping and is not itself a titlecase char according to UnicodeData, then the uppercase mapping is returned as an equivalent titlecase mapping. If the character argument is already a titlecase character, the same character value will be returned. Note that does not always return for some ranges of characters. - the character (Unicode code point) to be converted. the titlecase equivalent of the character, if any; otherwise, the character itself.\n• in the specified radix. Returns the numeric value of the characterin the specified radix. If the radix is not in the range ≤ ≤ or if the value of is not a valid digit in the specified radix, is returned. A character is a valid digit if at least one of the following is true:\n• The method is of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.\n• The character is one of the uppercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the lowercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the fullwidth uppercase Latin letters A ( ) through Z ( ) and its code is less than . In this case, is returned.\n• The character is one of the fullwidth lowercase Latin letters a ( ) through z ( ) and its code is less than . In this case, is returned. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the numeric value represented by the character in the specified radix.\n• Returns the numeric value of the specified character (Unicode code point) in the specified radix. If the radix is not in the range ≤ ≤ or if the character is not a valid digit in the specified radix, is returned. A character is a valid digit if at least one of the following is true:\n• The method is of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.\n• The character is one of the uppercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the lowercase Latin letters through and its code is less than . In this case, is returned.\n• The character is one of the fullwidth uppercase Latin letters A ( ) through Z ( ) and its code is less than . In this case, is returned.\n• The character is one of the fullwidth lowercase Latin letters a ( ) through z ( ) and its code is less than . In this case, is returned. - the character (Unicode code point) to be converted. the numeric value represented by the character in the specified radix.\n• value that the specified Unicode character represents. For example, the character (the roman numeral fifty) will return an int with a value of 50. Returns thevalue that the specified Unicode character represents. For example, the character(the roman numeral fifty) will return an int with a value of 50. The letters A-Z in their uppercase ( through ), lowercase ( through ), and full width variant ( through and through ) forms have numeric values from 10 through 35. This is independent of the Unicode specification, which does not assign numeric values to these values. If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be converted. the numeric value of the character, as a nonnegative value; -2 if the character has a numeric value that is not a nonnegative integer; -1 if the character has no numeric value.\n• value that the specified character (Unicode code point) represents. For example, the character (the Roman numeral fifty) will return an with a value of 50. Returns thevalue that the specified character (Unicode code point) represents. For example, the character(the Roman numeral fifty) will return anwith a value of 50. The letters A-Z in their uppercase ( through ), lowercase ( through ), and full width variant ( through and through ) forms have numeric values from 10 through 35. This is independent of the Unicode specification, which does not assign numeric values to these values. If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned. - the character (Unicode code point) to be converted. the numeric value of the character, as a nonnegative value; -2 if the character has a numeric value that is not a nonnegative integer; -1 if the character has no numeric value.\n• for the following five characters only: Determines if the specified character is ISO-LATIN-1 white space. This method returnsfor the following five characters only: - the character to be tested. if the character is ISO-LATIN-1 white space; otherwise.\n• Determines if the specified character is a Unicode space character. A character is considered to be a space character if and only if it is specified to be a space character by the Unicode Standard. This method returns true if the character's general category type is any of the following: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a space character; otherwise.\n• Determines if the specified character (Unicode code point) is a Unicode space character. A character is considered to be a space character if and only if it is specified to be a space character by the Unicode Standard. This method returns true if the character's general category type is any of the following: - the character (Unicode code point) to be tested. if the character is a space character; otherwise.\n• \n• It is a Unicode space character ( , , or ) but is not also a non-breaking space ( , , ). Determines if the specified character is white space according to Java. A character is a Java whitespace character if and only if it satisfies one of the following criteria: Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is a Java whitespace character; otherwise.\n• \n• It is a Unicode space character ( , , or ) but is not also a non-breaking space ( , , ). Determines if the specified character (Unicode code point) is white space according to Java. A character is a Java whitespace character if and only if it satisfies one of the following criteria: - the character (Unicode code point) to be tested. if the character is a Java whitespace character; otherwise.\n• through or in the range through . Determines if the specified character is an ISO control character. A character is considered to be an ISO control character if its code is in the rangethroughor in the rangethrough Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. if the character is an ISO control character; otherwise.\n• Determines if the referenced character (Unicode code point) is an ISO control character. A character is considered to be an ISO control character if its code is in the range through or in the range through . - the character (Unicode code point) to be tested. if the character is an ISO control character; otherwise.\n• Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - the character to be tested. a value of type representing the character's general category.\n• - the character (Unicode code point) to be tested. a value of type representing the character's general category.\n• is not a valid radix, or the value of is not a valid digit in the specified radix, the null character ( ) is returned. Determines the character representation for a specific digit in the specified radix. If the value ofis not a valid radix, or the value ofis not a valid digit in the specified radix, the null character () is returned. The argument is valid if it is greater than or equal to and less than or equal to . The argument is valid if . If the digit is less than 10, then is returned. Otherwise, the value is returned. - the number to convert to a character. the representation of the specified digit in the specified radix.\n• values is . Returns the Unicode directionality property for the given character. Character directionality is used to calculate the visual ordering of text. The directionality value of undefinedvalues is Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - for which the directionality property is requested. the directionality property of the value.\n• Returns the Unicode directionality property for the given character (Unicode code point). Character directionality is used to calculate the visual ordering of text. The directionality value of undefined character is - the character (Unicode code point) for which the directionality property is requested. the directionality property of the character.\n• LEFT PARENTHESIS is semantically defined to be an opening parenthesis. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. Determines whether the character is mirrored according to the Unicode specification. Mirrored characters should have their glyphs horizontally mirrored when displayed in text that is right-to-left. For example,LEFT PARENTHESIS is semantically defined to be an. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. Note: This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method. - for which the mirrored property is requested if the char is mirrored, if the is not mirrored or is not defined.\n• Determines whether the specified character (Unicode code point) is mirrored according to the Unicode specification. Mirrored characters should have their glyphs horizontally mirrored when displayed in text that is right-to-left. For example, LEFT PARENTHESIS is semantically defined to be an opening parenthesis. This will appear as a \"(\" in text that is left-to-right but as a \")\" in text that is right-to-left. - the character (Unicode code point) to be tested. if the character is mirrored, if the character is not mirrored or is not defined.\n• - the to be compared. the value if the argument is equal to this ; a value less than if this is numerically less than the argument; and a value greater than if this is numerically greater than the argument (unsigned comparison). Note that this is strictly a numerical comparison; it is not locale-dependent.\n• values numerically. The value returned is identical to what would be returned by: Compares twovalues numerically. The value returned is identical to what would be returned by: - the first to compare - the second to compare the value if ; a value less than if ; and a value greater than if\n• Returns the value obtained by reversing the order of the bytes in the specified value. the value obtained by reversing (or, equivalently, swapping) the bytes in the specified value.\n• , or null if the code point is Returns the Unicode name of the specified character, or null if the code point is Note: if the specified character is not assigned a name by the UnicodeData file (part of the Unicode Character Database maintained by the Unicode Consortium), the returned name is the same as the result of expression. the Unicode name of the specified character, or null if the code point is unassigned. - if the specified is not a valid Unicode code point."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/java.lang.character.digit?view=net-android-35.0",
        "document": "the numeric value represented by the character in the specified radix.\n\nReturns the numeric value of the character in the specified radix.\n\nIf the radix is not in the range ≤ ≤ or if the value of is not a valid digit in the specified radix, is returned. A character is a valid digit if at least one of the following is true: <ul> <li>The method is of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned. <li>The character is one of the uppercase Latin letters through and its code is less than . In this case, is returned. <li>The character is one of the lowercase Latin letters through and its code is less than . In this case, is returned. <li>The character is one of the fullwidth uppercase Latin letters A ( ) through Z ( ) and its code is less than . In this case, is returned. <li>The character is one of the fullwidth lowercase Latin letters a ( ) through z ( ) and its code is less than . In this case, is returned. </ul>\n\n<b>Note:</b> This method cannot handle supplementary characters. To support all Unicode characters, including supplementary characters, use the method.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License."
    },
    {
        "link": "https://codegym.cc/groups/posts/hashcode-method-best-practices",
        "document": "If two objects are equal (i.e. the method returns true), then they must have the same hash code.\n\nOtherwise, our methods would be meaningless. As we mentioned above, a check should go first to improve performance. If the hash codes were different, then the check would return false, even though the objects are actually equal according to how we've defined the method."
    },
    {
        "link": "https://stackoverflow.com/questions/2738886/what-is-a-best-practice-of-writing-hash-function-in-java",
        "document": "Here's a quote from Effective Java 2nd Edition, Item 9: \"Always override when you override \":\n\nWhile the recipe in this item yields reasonably good hash functions, it does not yield state-of-the-art hash functions, nor do Java platform libraries provide such hash functions as of release 1.6. Writing such hash functions is a research topic, best left to mathematicians and computer scientists. [... Nonetheless,] the techniques described in this item should be adequate for most applications.\n• Store some constant nonzero value, say 17, in an variable called\n• Compute an hashcode for each field that defines :\n• If the field is a , compute\n• If the field is a , compute\n• If the field is a , compute\n• If the field is a , compute\n• If the field is a , compute , then hash the resulting as in above\n• If the field is an object reference and this class's method compares the field by recursively invoking , recursively invoke on the field. If the value of the field is , return 0\n• If the field is an array, treat it as if each element is a separate field. If every element in an array field is significant, you can use one of the methods added in release 1.5\n• Combine the hashcode into as follows:\n\nNow, of course that recipe is rather complicated, but luckily, you don't have to reimplement it every time, thanks to .\n\nAs of Java 7 there is a convenient varargs variant in ."
    },
    {
        "link": "https://stackoverflow.com/questions/113511/best-implementation-for-hashcode-method-for-a-collection",
        "document": "How do we decide on the best implementation of hashCode() method for a collection (assuming that equals method has been overridden correctly) ?\n\nThe best implementation? That is a hard question because it depends on the usage pattern. A for nearly all cases reasonable good implementation was proposed in Josh Bloch's Effective Java in Item 8 (second edition). The best thing is to look it up there because the author explains there why the approach is good.\n• None For every field tested in the method, calculate a hash code by:\n• If the field f is a : calculate ;\n• If the field f is a , , or : calculate ;\n• If the field f is a : calculate ;\n• If the field f is a : calculate ;\n• If the field f is a : calculate and handle the return value like every long value;\n• If the field f is an object: Use the result of the method or 0 if ;\n• If the field f is an array: see every field as separate element and calculate the hash value in a recursive fashion and combine the values as described next.\n• None Combine the hash value with : This should result in a proper distribution of hash values for most use situations.\n\nAlthough this is linked to documentation (Wayback Machine) and My own code on Github, it will work for Java in general. My answer is an extension of dmeister's Answer with just code that is much easier to read and understand. @Override public int hashCode() { // Start with a non-zero constant. Prime is preferred int result = 17; // Include a hash for each field. // Primatives result = 31 * result + (booleanField ? 1 : 0); // 1 bit » 32-bit result = 31 * result + byteField; // 8 bits » 32-bit result = 31 * result + charField; // 16 bits » 32-bit result = 31 * result + shortField; // 16 bits » 32-bit result = 31 * result + intField; // 32 bits » 32-bit result = 31 * result + (int)(longField ^ (longField >>> 32)); // 64 bits » 32-bit result = 31 * result + Float.floatToIntBits(floatField); // 32 bits » 32-bit long doubleFieldBits = Double.doubleToLongBits(doubleField); // 64 bits (double) » 64-bit (long) » 32-bit (int) result = 31 * result + (int)(doubleFieldBits ^ (doubleFieldBits >>> 32)); // Objects result = 31 * result + Arrays.hashCode(arrayField); // var bits » 32-bit result = 31 * result + referenceField.hashCode(); // var bits » 32-bit (non-nullable) result = 31 * result + // var bits » 32-bit (nullable) (nullableReferenceField == null ? 0 : nullableReferenceField.hashCode()); return result; } Typically, when you override , you also want to override . So for those that will or has already implemented , here is a good reference from my Github... @Override public boolean equals(Object o) { // Optimization (not required). if (this == o) { return true; } // Return false if the other object has the wrong type, interface, or is null. if (!(o instanceof MyType)) { return false; } MyType lhs = (MyType) o; // lhs means \"left hand side\" // Primitive fields return booleanField == lhs.booleanField && byteField == lhs.byteField && charField == lhs.charField && shortField == lhs.shortField && intField == lhs.intField && longField == lhs.longField && floatField == lhs.floatField && doubleField == lhs.doubleField // Arrays && Arrays.equals(arrayField, lhs.arrayField) // Objects && referenceField.equals(lhs.referenceField) && (nullableReferenceField == null ? lhs.nullableReferenceField == null : nullableReferenceField.equals(lhs.nullableReferenceField)); }\n\nif equals() returns true for two objects, then hashCode() should return the same value. If equals() returns false, then hashCode() should return different values I cannot agree with you. If two objects have the same hashcode it doesn't have to mean that they are equal. If A equals B then A.hashcode must be equal to B.hascode if A.hashcode equals B.hascode it does not mean that A must equals B\n\nIf I understand your question correctly, you have a custom collection class (i.e. a new class that extends from the Collection interface) and you want to implement the hashCode() method. If your collection class extends AbstractList, then you don't have to worry about it, there is already an implementation of equals() and hashCode() that works by iterating through all the objects and adding their hashCodes() together. Now if what you want is the best way to calculate the hash code for a specific class, I normally use the ^ (bitwise exclusive or) operator to process all fields that I use in the equals method:\n\nThe standard implementation is weak and using it leads to unnecessary collisions. Imagine a class ListPair { List<Integer> first; List<Integer> second; ListPair(List<Integer> first, List<Integer> second) { this.first = first; this.second = second; } public int hashCode() { return Objects.hashCode(first, second); } ... } have the same , namely as the multiplier used for gets reused here. Obviously, collisions are unavoidable, but producing needless collisions is just... needless. There's nothing substantially smart about using . The multiplier must be odd in order to avoid losing information (any even multiplier loses at least the most significant bit, multiples of four lose two, etc.). Any odd multiplier is usable. Small multipliers may lead to faster computation (the JIT can use shifts and additions), but given that multiplication has latency of only three cycles on modern Intel/AMD, this hardly matters. Small multipliers also leads to more collision for small inputs, which may be a problem sometimes. Using a prime is pointless as primes have no meaning in the ring Z/(2**32). So, I'd recommend using a randomly chosen big odd number (feel free to take a prime). As i86/amd64 CPUs can use a shorter instruction for operands fitting in a single signed byte, there is a tiny speed advantage for multipliers like 109. For minimizing collisions, take something like 0x58a54cf5. Using different multipliers in different places is helpful, but probably not enough to justify the additional work."
    },
    {
        "link": "https://baeldung.com/java-hashcode",
        "document": "In Java, efficient hashing algorithms stand behind some of the most popular collections, such as the HashMap (check out this in-depth article) and the HashSet.\n\nIn this tutorial, we’ll focus on how hashCode() works, how it plays into collections and how to implement it correctly.\n\nThe simplest operations on collections can be inefficient in certain situations.\n\nTo illustrate, this triggers a linear search, which is highly ineffective for huge lists:\n\nJava provides a number of data structures for dealing with this issue specifically. For example, several Map interface implementations are hash tables.\n\nWhen using a hash table, these collections calculate the hash value for a given key using the hashCode() method. Then they use this value internally to store the data so that access operations are much more efficient.\n\nSimply put, hashCode() returns an integer value, generated by a hashing algorithm.\n\nObjects that are equal (according to their equals()) must return the same hash code. Different objects do not need to return different hash codes.\n• Whenever it is invoked on the same object more than once during an execution of a Java application, hashCode() must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value doesn’t need to stay consistent from one execution of an application to another execution of the same application.\n• If two objects are equal according to the equals(Object) method, calling the hashCode() method on each of the two objects must produce the same value.\n• If two objects are unequal according to the equals(java.lang.Object) method, calling the hashCode method on each of the two objects doesn’t need to produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables.\n\nA naive hashCode() implementation that fully adheres to the above contract is actually quite straightforward.\n\nTo demonstrate this, we’re going to define a sample User class that overrides the method’s default implementation:\n\nThe User class provides custom implementations for both equals() and hashCode() that fully adhere to the respective contracts. Even more, there’s nothing illegitimate with having hashCode() returning any fixed value.\n\nHowever, this implementation degrades the functionality of hash tables to basically zero, as every object would be stored in the same, single bucket.\n\nIn this context, a hash table lookup is performed linearly and does not give us any real advantage. We talk more about this in Section 7.\n\nLet’s improve the current hashCode() implementation by including all fields of the User class so that it can produce different results for unequal objects:\n\nThis basic hashing algorithm is definitively much better than the previous one. This is because it computes the object’s hash code by just multiplying the hash codes of the name and email fields and the id.\n\nIn general terms, we can say that this is a reasonable hashCode() implementation, as long as we keep the equals() implementation consistent with it.\n\nThe better the hashing algorithm that we use to compute hash codes, the better the performance of hash tables.\n\nLet’s have a look at a “standard” implementation that uses two prime numbers to add even more uniqueness to computed hash codes:\n\nWhile we need to understand the roles that hashCode() and equals() methods play, we don’t have to implement them from scratch every time. This is because most IDEs can generate custom hashCode() and equals() implementations. And since Java 7, we have an Objects.hash() utility method for comfortable hashing:\n\nAnd Eclipse produces this one:\n\nIn addition to the above IDE-based hashCode() implementations, it’s also possible to automatically generate an efficient implementation, for example using Lombok.\n\nIn this case, we need to add the lombok dependency to pom.xml:\n\nIt’s now enough to annotate the User class with @EqualsAndHashCode:\n\nSimilarly, if we want Apache Commons Lang’s HashCodeBuilder class to generate a hashCode() implementation for us, we include the commons-lang Maven dependency in the pom file:\n\nAnd hashCode() can be implemented like this:\n\nIn general, there’s no universal recipe when it comes to implementing hashCode(). We highly recommend reading Joshua Bloch’s Effective Java. It provides a list of thorough guidelines for implementing efficient hashing algorithms.\n\nNotice here that all those implementations utilize number 31 in some form. This is because 31 has a nice property. Its multiplication can be replaced by a bitwise shift, which is faster than the standard multiplication:\n\nThe intrinsic behavior of hash tables brings up a relevant aspect of these data structures: Even with an efficient hashing algorithm, two or more objects might have the same hash code even if they’re unequal. So, their hash codes would point to the same bucket even though they would have different hash table keys.\n\nThis situation is commonly known as a hash collision, and various methods exist for handling it, with each one having their pros and cons. Java’s HashMap uses the separate chaining method for handling collisions:\n\n“When two or more objects point to the same bucket, they’re simply stored in a linked list. In such a case, the hash table is an array of linked lists, and each object with the same hash is appended to the linked list at the bucket index in the array.\n\nIn the worst case, several buckets would have a linked list bound to it, and the retrieval of an object in the list would be performed linearly.”\n\nHash collision methodologies show in a nutshell why it’s so important to implement hashCode() efficiently.\n\nJava 8 brought an interesting enhancement to HashMap implementation. If a bucket size goes beyond the certain threshold, a tree map replaces the linked list. This allows achieving O(logn) lookup instead of pessimistic O(n).\n\nNow we’ll test the functionality of a standard hashCode() implementation.\n\nLet’s create a simple Java application that adds some User objects to a HashMap and uses SLF4J for logging a message to the console each time the method is called.\n\nAnd this is the hashCode() implementation:\n\nHere, it’s important to note that each time an object is stored in the hash map and checked with the containsKey() method, hashCode() is invoked and the computed hash code is printed out to the console:\n\nIt’s clear that producing efficient hashCode() implementations often requires a mixture of a few mathematical concepts (i.e. prime and arbitrary numbers), logical and basic mathematical operations.\n\nRegardless, we can implement hashCode() effectively without resorting to these techniques at all. We just need to make sure the hashing algorithm produces different hash codes for unequal objects and that it’s consistent with the implementation of equals()."
    },
    {
        "link": "https://sitepoint.com/how-to-implement-javas-hashcode-correctly",
        "document": "At SitePoint we’re always looking to expand the range of topics we cover. Lately, we’ve set our sights on exploring the world of Java. If you’re a strong Java developer who wants to contribute to our coverage, get in touch with a few ideas for articles you’d like to write.\n\nSo you’ve decided that identity isn’t enough for you and wrote a nice implementation?\n\n Great! But now you have to implement as well.\n\nLet’s see why and how to do it correctly.\n• Equal objects should have the same hash code in Java, hence if equals is overridden, a matching hashCode implementation must be created to ensure consistency and accuracy in storing and retrieving objects in hash-based collections.\n• When implementing hashCode, the same fields that are used in equals should be utilized. Mutable fields and collections should be better avoided due to potential performance issues.\n• Hash codes are about performance optimization, so it’s important not to invest too much energy in hashing unless profiling indicates a need for improvement.\n• Hash collisions, where two different objects have the same hash code, can be reduced by improving the hashing algorithm and using a larger prime number as a multiplier. This helps distribute the hash codes more evenly across the collection, reducing the likelihood of hash collisions and ensuring faster data retrieval.\n\nWhile equality makes sense from a general perspective, hash codes are much more technical. If we were being a little hard on them, we could say that they are just an implementation detail to improve performance.\n\nMost data structures use to check whether they contain an element. For example:\n\nThe variable is because, while instances of are not identical (again, ignoring String interning), they are equal.\n\nComparing every element with the instance given to is wasteful, though, and a whole class of data structures uses a more performant approach. Instead of comparing the requested instance with each element they contain, they use a shortcut that reduces the number of potentially equal instances and then only compare those.\n\nThis shortcut is the hash code, which can be seen as an object’s equality boiled down to an integer value. Instances with the same hash code are not necessarily equal but equal instances have the same hash code. (Or should have, we will discuss this shortly.) Such data structures are often named after this technique, recognizable by the in their name, with the most notable representative.\n\nThis is how they generally work:\n• When an element is added, its hash code is used to compute the index in an internal array (called a bucket).\n• If other, non-equal elements have the same hash code, they end up in the same bucket and must be bundled together, e.g. by adding them to a list.\n• When an instance is given to , its hash code is used to compute the bucket. Only elements therein are compared to the instance.\n\nThis way, very few, ideally no comparisons are required to implement .\n\nAs , is defined on .\n\nIf is used as a shortcut to determine equality, then there is really only one thing we should care about: Equal objects should have the same hash code.\n\nThis is also why, if we override , we must create a matching implementation! Otherwise things that are equal according to our implementation would likely not have the same hash code because they use ‘s implementation.\n\nThe first bullet mirrors the consistency property of and the second is the requirement we came up with above. The third states an important detail that we discuss will in a moment.\n\nA very easy implementation of is the following:\n\nThe person’s hash code is computed by computing the hash codes for the relevant fields and combining them. Both is left to ‘ utility function .\n\nBut which fields are relevant? The requirements help answer this: If equal objects must have the same hash code, then hash code computation should not include any field that is not used for equality checks. (Otherwise two objects that only differ in those fields would be equal but have different hash codes.)\n\nSo the set of fields used for hashing should be a subset of the fields used for equality. By default both will use the same fields but there are a couple of details to consider.\n\nFor one, there is the consistency requirement. It should be interpreted rather strictly. While it allows the hash code to change if some fields change (which is often unavoidable with mutable classes), hashing data structures are not prepared for this scenario.\n\nAs we have seen above the hash code is used to determine an element’s bucket. But if the hash-relevant fields change, the hash is not recomputed and the internal array is not updated.\n\nThis means that a later query with an equal object or even with the very same instance fails! The data structure computes the current hash code, different from the one used to store the instance, and goes looking in the wrong bucket.\n\nConclusion: Better not use mutable fields for hash code computation!\n\nHash codes might end up being computed about as often as is called. This can very well happen in performance critical parts of the code so it makes sense to think about performance. And unlike there is a little more wiggle room to optimize it.\n\nUnless sophisticated algorithms are used or many, many fields are involved, the arithmetic cost of combining their hash codes is as negligible as it is unavoidable. But it should be considered whether all fields need to be included in the computation! Particularly collections should be viewed with suspicion. Lists and sets, for example, will compute the hash for each of their elements. Whether calling them is necessary should be considered on a case-by-case basis.\n\nIf performance is critical, using might not be the best choice either because it requires the creation of an array for its varargs.\n\nBut the general rule about optimization holds: Don’t do it prematurely! Use a common hash code algorithm, maybe forego including the collections, and only optimize after profiling showed potential for improvement.\n\nGoing all-in on performance, what about this implementation?\n\nIt’s fast, that’s for sure. And equal objects will have the same hash code so we’re good on that, too. As a bonus, no mutable fields are involved!\n\nBut remember what we said about buckets? This way all instances will end up in the same! This will typically result in a linked list holding all the elements, which is terrible for performance. Each , for example, triggers a linear scan of the list.\n\nSo what we want is as few items in the same bucket as possible! An algorithm that returns wildly varying hash codes, even for very similar objects, is a good start.\n\nHow to get there partly depends on the selected fields. The more details we include in the computation, the more likely it is for the hash codes to differ. Note how this is completely opposite to our thoughts about performance. So, interestingly enough, using too many or too few fields can result in bad performance.\n\nThe other part to preventing collisions is the algorithm that is used to actually compute the hash.\n\nThe easiest way to compute a field’s hash code is to just call `hashCode` on it. Combining them could be done manually. A common algorithm is to start with some arbitrary number and to repeatedly multiply it with another (often a small prime) before adding a field’s hash:\n\nThis might result in overflows, which is not particularly problematic because they cause no exceptions in Java.\n\nNote that even great hashing algorithms might result in uncharacteristically frequent collisions if the input data has specific patterns. As a simple example assume we would compute the hash of points by adding their x and y-coordinates. May not sound too bad until we realize that we often deal with points on the line , which means for all of them. Collisions, galore!\n\nBut again: Use a common algorithm and don’t worry until profiling shows that something isn’t right.\n\nWe have seen that computing hash codes is something like compressing equality to an integer value: Equal objects must have the same hash code and for performance reasons it is best if as few non-equal objects as possible share the same hash.\n\nThis means that must always be overridden if is.\n• Use a the same fields that are used in (or a subset thereof).\n• Consider not calling on collections.\n• Use a common algorithm unless patterns in input data counteract them.\n\nRemember that is about performance, so don’t waste too much energy unless profiling indicates necessity.\n\nWhat is the significance of the hashCode() method in Java? The hashCode() method in Java is a built-in function that returns an integer value. It is used primarily in hash-based collections like HashMap, HashSet, and HashTable to store and retrieve objects more efficiently. The hashCode() method works in tandem with the equals() method to ensure that each object has a unique identifier. This helps in the quick retrieval of data, especially in large collections, thereby improving the performance of your Java application. How does the hashCode() method work in Java? The hashCode() method in Java works by generating an integer value that represents the memory address of the object. This value is used as the index number for the object in the hash-based collection. When you call the hashCode() method on an object, it uses a hashing algorithm to generate this unique integer. However, it’s important to note that two different objects can have the same hashCode, which is known as a hash collision. What is the contract between equals() and hashCode() methods in Java? The contract between equals() and hashCode() methods in Java is a set of rules that govern their interaction. The contract states that if two objects are equal according to the equals() method, then calling the hashCode() method on each of the two objects must produce the same integer result. This ensures consistency and accuracy when storing and retrieving objects in hash-based collections. How can I override the hashCode() method in Java? Overriding the hashCode() method in Java involves providing your own implementation that returns a unique integer for each object. This can be done by using the object’s instance variables and a prime number multiplier. The prime number helps in distributing the hash codes evenly across the collection, reducing the likelihood of hash collisions. What is a hash collision and how can it be avoided? A hash collision occurs when the hashCode() method generates the same integer for two different objects. This can lead to data loss if not handled correctly. To avoid hash collisions, you can improve your hashing algorithm to generate more unique integers. Also, using a larger prime number as a multiplier can help distribute the hash codes more evenly across the collection. Why should I override the hashCode() method? Overriding the hashCode() method can improve the performance of your Java application, especially when dealing with large collections. By providing your own implementation, you can generate more unique and evenly distributed hash codes, reducing the likelihood of hash collisions and ensuring faster data retrieval. Can two unequal objects have the same hashCode in Java? Yes, two unequal objects can have the same hashCode in Java. This is known as a hash collision. However, the likelihood of this happening can be reduced by improving your hashing algorithm and using a larger prime number as a multiplier. What happens if I don’t override the hashCode() method? If you don’t override the hashCode() method, Java will use its default implementation, which may not provide a unique hash code for each object. This can lead to hash collisions and slower data retrieval in hash-based collections. How does the hashCode() method improve the performance of my Java application? The hashCode() method improves the performance of your Java application by providing a unique identifier for each object. This allows for faster data retrieval in hash-based collections, as the object can be located directly using its hash code, rather than having to search through the entire collection. Can I use the hashCode() method for objects in a non-hash-based collection? While the hashCode() method is primarily used in hash-based collections, it can also be used in non-hash-based collections. However, its benefits may not be as pronounced, as non-hash-based collections do not rely on hash codes for data storage and retrieval."
    }
]