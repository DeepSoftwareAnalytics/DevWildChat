[
    {
        "link": "https://vuejs.org/guide/essentials/computed.html",
        "document": "In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\nAnd we want to display different messages depending on if already has some books or not:\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on . More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\n\n// `this` points to the component instance Here we have declared a computed property . Try to change the value of the array in the application and you will see how is changing accordingly. You can data-bind to computed properties in templates just like a normal property. Vue is aware that depends on , so it will update any bindings that depend on when changes.\n\nHere we have declared a computed property . The function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as . Computed refs are also auto-unwrapped in templates so you can reference them without in template expressions. A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of depends on , so it will update any bindings that depend on when changes.\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as has not changed, multiple access to will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because is not a reactive dependency:\n\nIn comparison, a method invocation will always run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property , which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on . Without caching, we would be executing ’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\nGetting the Previous Value ​\n\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations."
    },
    {
        "link": "https://vuejs.org/guide/essentials/computed",
        "document": "In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\nAnd we want to display different messages depending on if already has some books or not:\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on . More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\n\n// `this` points to the component instance Here we have declared a computed property . Try to change the value of the array in the application and you will see how is changing accordingly. You can data-bind to computed properties in templates just like a normal property. Vue is aware that depends on , so it will update any bindings that depend on when changes.\n\nHere we have declared a computed property . The function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as . Computed refs are also auto-unwrapped in templates so you can reference them without in template expressions. A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of depends on , so it will update any bindings that depend on when changes.\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as has not changed, multiple access to will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because is not a reactive dependency:\n\nIn comparison, a method invocation will always run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property , which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on . Without caching, we would be executing ’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\nGetting the Previous Value ​\n\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations."
    },
    {
        "link": "https://dev.to/pecus/when-to-avoid-vuejs-computed-properties-for-greater-performance-5anj",
        "document": "VueJs is fast, easy to learn, reactive framework. It offers a gentle learning curve and a rich developer experience, with powerful inspection and CLI based tools.\n\nAt modo, we use Vue for most of our dynamic frontend projects: we like it for its clear separation of concerns, easily composable components, a wide range of build options (from Single Page Applications to standalone Web Components) and for being generally very well performing out–of–the–box.\n• How and when to avoid computed properties\n• Going from a few milliseconds to tens of seconds of execution (and back)\n\nAmong the many traits of VueJs that are optimized for computational and rendering performance are computed properties. Computed properties are component functions that return a value. They are reactive, in that they are automatically updated whenever one of the values used for computing the property changes, and can be used in templates and component logic.\n\nThe real power (and the true difference in comparison to component methods) is that computed properties are cached.\n\nWhile component methods are executed at every rendering of the component, computed properties are evaluated conditionally: if none of the dependency has changed, the property is not recomputed and the cache value is used, saving a considerable amount of runtime execution. Component re–rendering thus happens considerably faster, as the runtime engine can skip re–evaluating potentially expensive data, relying instead on the cached value.\n\nIf you’re not familiar with computed properties, you can read more in the official documentation, but for the sake of this article a simple use case can help.\n\nSuppose we have a list of books, and a component that should filter them based on a condition, let’s say a matching text in the title.\n\nOur code would probably look like this:\n\nOur component and application would probably have additional logic and greater complexity, but this example should be good enough to show how computed properties work. returns a copy of the array of books, filtered with those that include the search query ( ) in their title. The value is then cached by Vue, and will not be recomputed unless either or change.\n\nAn important tidbit to remember, tightly coupled with their cacheability, is that computed properties must be evaluated synchronously.\n\nWe’re not going to deep dive into Vue internals. If you are interested, VueMastery has produced a series of videos with Evan You coding step–by–step, high level, simplified demos of how VueJs works. You can also inspect Vue source code and, for this specific case, I found this article by Michael Gallagher very inspiring.\n\nSo, to make it short, in version 2.x, Vue tracks reactivity using getters and setters (Version 3 will use proxies, and will also provide better tracing and debugging of reactivity. It is currently a Release Candidate).\n\nTo understand why computed properties can bite back in specific cases, we need to remember that Vue needs to track each dependency of a computed property. This can be expensive if these variables are large arrays, or complex, nested objects, or a combination of both, as in the case I found out.\n\nIn case of circular dependencies (a computed property depending on another computed property), Vue also needs to stabilize values and might have to iterate the evaluation twice to ensure that values don’t change within the current update cycle.\n\nAll of this can add up significantly.\n\nHow and when to avoid computed properties\n\nDespite all the praises I’ve written so far for computed properties, there are cases in which you might want or even need to avoid them.\n\nThe simplest case is if you need a static computed value, that is a value that needs to be calculated only once, no matter how data in your component will change.\n\nThe options API of VueJs 2.x does not make it particularly evident, but declaring any property inside the component created function makes it available to both the component logic and the component template.\n\nLet’s see this in code, with our book example:\n\nSee this example on CodeSandbox\n\nIn the above example, the product name and version are completely static. They are imported from the file and used in the template as if they were any other computed or reactive property.\n\nYou could still define and as computed properties: Vue would not track values that are not registered in the reactive system, but this approach becomes useful when you need to explicitely avoid having Vue track a large array or object.\n\nIn our example above, is reactive. It is passed to the component as a prop, and therefore tracked for reactivity changes. The component needs to update should the list change. If the list is very large and includes complex objects, we’re adding an unnecessary overhead to the reactivity system. We’re not reacting to changes in : we’re reacting only to changes in ! The list of books stays the same, no matter the search the user performs.\n\nThis might not be intuitive, and most of the time Vue is forgiving because its internal optimizations favour speed. But every time we know that some data does not need to ever be re–evaluated, we should design for performance and make it available as a static property.\n\nSee the final example on CodeSandbox\n\nGoing from a few milliseconds to tens of seconds of execution (and back)\n\nThe book example described above has many similarities with a project I worked on recently. This project needed to handle an array of around 10.000 objects, and filter them dynamically based on various query types.\n\nIn a particular scenario, the performance of the app degraded significantly, blocking the browser main thread for several seconds and making the browser completely unresponsive. Granted, the app was managing a lot of data: the JSON representation of the array was ~19Mb of data. But the slowdown was not due to the data size.\n\nThe code for filtering the array was not at fault. An isolated case in plain JavaScript performing the same filtering took only a few milliseconds, no matter the code style (functional or imperative) or the complexity of the filter function.\n\nTo troubleshoot the issue, I used the performance profiler of Firefox DevTools to generate a flame chart. This showed where the application was spending time in long tasks that blocked the browser main thread. Reading the chart provided some insight: it turned out that the greatest advantage of computed properties sometimes becomes a performance bottleneck.\n\nTracking dependencies has a cost. Most of the time this cost is negligible, especially compared to the advantage provided by cached values and a fast, reactive frontend. In our app, this cost was acceptable when the component tracked in total one list of items. But when tracking two, and combining this cost with the cost generated on the heap and the call stack by a high number of callback functions—such as the one used to a large array—it blocked the browser event loop and made the application unresponsive.\n\nTo solve it, as explained above, we removed the list of items to search from the reactivity system. In retrospect it was a mistake to add it from the beginning, since it never changes and never needs to be tracked for updates. The array is now filtered once inside the function and the resulting value added as a non–reactive property to the component. We’re back in the milliseconds range of updates. Yeah! 🍾\n\nDespite working with VueJs for years, this was the first time we hit a performance penalty this severe. VueJs 3.x has a lot of internal improvements and might perform flawlessly in this scenario (we haven’t tested it yet). But if you’re still relying on VueJs 2, and like us are obsessed with performance, I hope this helps you if you ever experience an unexpected slowdown in your VueJs code. And if it’s really puzzling, you might want to let us take a look at it."
    },
    {
        "link": "https://stackoverflow.com/questions/64479472/vue-js-computed-properties-filter-by-object-key",
        "document": "I'm working with an object containing multiple network interfaces with the interfaces' names as keys and then interfaces' informations as values :\n\nWhat I would like to do is a Vue.js computed property to filter this object by Keys and create arrays that contain all GigabitEthernet separately for example so I can iterate over it in my template.\n\nI thinked about using Regex, here is the one that I use and match the interfaces I want to put in a separate array :\n\nThe problem is that the main object received from API isn't an array so I can't use find() or filter() functions over it...\n\nIf anyone as any idea it would be nice, thanks !\n\nIt returns only 1 line out of 2...\n\nHere is the code :\n\nHere is a screenshot of current output at the left and expected output at the right :\n\nHere is what happens when I console log the regex results with the associated key :\n\nAs you can see only 1 out of 2 is true..."
    },
    {
        "link": "https://stackoverflow.com/questions/72064233/how-can-i-optimize-this-filtering-method-in-vuejs",
        "document": "I would like to optimize a method which I use to decide which values to display in a tale. I have a table that shows different values, and on top of it, there are some input fields. The values selected in the input field are used to filter the content of the table.\n\nThe values selected in the input fields are bounded to the object filterTable.\n\nAnd the method that is called on input is defined as follows:\n\n(my code has 2 more if statements that check value given by some other input fields, but they also follow the same logic above)\n\n This code works and it does filter the table, but as you can see there are two many if statements in it and I am wondering if there are some ways I can follow to make it more efficient/optimized? \n\nAny advice is highly appreciated!"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/gnrv0y/quasar_framework_seriously_whats_the_catch",
        "document": "I am about to pick Quasar Framework for a long term project which will eventually need to run on web and mobile both.\n\nI have tried playing around with it for a day and so far everything just seems perfect; documentation is fairly detailed and they have every component imaginable available in the library (including a WYSIWG editor!). Not only that, it supports compiling to multiple build targets and already uses some features from Vue 3. Despite its size and richness, the hotReload works faster than Buefy + Nuxt for me.\n\nThe common criticism I have heard is that its too material looking. I hate material but it seems fairly theme-able so I am not bothered with it. Another criticism is that it has way too many components but after compiling the size will obviously reduce.\n\nHowever here are some of my concerns maybe someone more experienced with it can address:\n• What is the long term viability of such an open source project. For a smallish team they seemed to have taken on ALOT of work. How sustainable is it? Nuxt for example now has $2M seed in seed funding. Quasar however seems to be surviving on donations; I see some names like Digital Ocean but just wondering how sustainable it is.\n• How is the performance of the framework? How did the final product turn out specially for apps that go beyond Hello World.\n• Are there any weird quirks? With Quasar trying to support so much at once there has to be some platform specific quirks.\n\nWould love to get some feedback. Any other similar frameworks or combination of libraries you recommend looking into as well?"
    },
    {
        "link": "https://stackoverflow.com/questions/58842356/performance-of-vue-with-a-large-array-of-objects",
        "document": "I have a long list of items (460 in total) stored in . Here is my code in to filter the list:\n\nHere is the HTML element:\n\nWhen I put a term to the input to filter the list, it works fine; however, when I clear the input, it gets like 5s to display the full list, which is quite slow. How can I make Vue work faster? Thanks."
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application",
        "document": "The last directory I like to include for all my Vue projects is the directory. In a world of packages and libraries we sometimes end up doing more configuring and registering than we do actual coding. That's what this directory is for, including and setting up all the third party Vue stuff. While it's called plugins I don't always necessarily use the term in the strictest sense. In other words, it doesn't have be a third party lib registered via the Vue method. Often times it is, but other times it uses alternate methods of setting up the lib with Vue (such as ). For libs that take a one or 2 line setup, I'll write it in a file. For those that take a more involved setup, I like to create a dedicated file for them in the plugins directory and then import it into the ."
    },
    {
        "link": "https://stackoverflow.com/questions/68327098/how-to-work-in-vue-js-data-table-with-huge-amount-of-data-from-gcp-firestore",
        "document": "After having watched numerous videos about GCP Firestore, I'm still asking myself what is a best way to work with huge amount of data coming from Firestore ?\n\nLike 800 000 products, I would like to display all of them in such datatable with Quasar:\n\nHow do I make it work in real-time, like listening for each item's changes without having exceeded my quota usage to avoid pay high bills for stupid code ?\n\nBinance's Market page is a perfect example, what is the best solutions to make datatables efficient ?\n\nAny links or suggestions will be highly appreciate."
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/k7ldxy/reactivity_isnt_free_take_care_when_working_with",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    }
]