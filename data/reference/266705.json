[
    {
        "link": "https://stackoverflow.com/questions/11496826/transferring-ownership-to-function-with-stdunique-ptr",
        "document": "I am trying to learn how to use smart pointers and understand ownership. When I pass an to a function by value, the function takes exclusive ownership of that pointer. So when the function finishes up, it deletes the pointer that I passed to it.\n\nHowever, I get a compile error when I try doing this with a , as if copy assignment is disabled for s. Passing a by reference does not seem to transfer ownership, it merely gives the function a reference to the .\n\nHow do I get 's behavior with passing ownership to function to work with s? I would appreciate a link to a detailed tutorial on , as so far the ones I've read seem to only talk about or talk about the smart pointers available with Boost and seem to ignore because covers it."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/1bvobww/correct_usage_of_unique_ptr_to_transfer_ownership",
        "document": "I need to allocate a buffer and pass it to a function that will take its ownership by using a raw pointer. To ensure that the buffer is always deallocated in case of any issue - early return or exception - I prefer to be safe and use rather than a naked .\n\nThe issue I have is that the function that takes the raw pointer as a parameter (store_buffer in the example) can throw an exception, in which case the ownership of the buffer must remain to the caller.\n\nMy solution to solve this is the following one:\n\nThe use of unique_ptr::release() method seems to generate a warning on clang tidy, which reports that not checking the return value could lead to resource leaks, which is not my case here, so i have to put to silence it, which seems rather ugly.\n\nAlso, I found a discussion mentioning that not using the return value of release() can represent \"weird ownership semantics\".\n\nIs there any correct or better solution to implement this?\n\nI can just think to use release in the store_buffer call and, in the catch handler, assign it back to the unique ptr. Which solution do you prefer?\n\nThank you very much (:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-170",
        "document": "How to: Create and use unique_ptr instances\n\nA unique_ptr does not share its pointer. It cannot be copied to another , passed by value to a function, or used in any C++ Standard Library algorithm that requires copies to be made. A can only be moved. This means that the ownership of the memory resource is transferred to another and the original no longer owns it. We recommend that you restrict an object to one owner, because multiple ownership adds complexity to the program logic. Therefore, when you need a smart pointer for a plain C++ object, use , and when you construct a , use the make_unique helper function.\n\nThe following diagram illustrates the transfer of ownership between two instances.\n\nis defined in the header in the C++ Standard Library. It is exactly as efficient as a raw pointer and can be used in C++ Standard Library containers. The addition of instances to C++ Standard Library containers is efficient because the move constructor of the eliminates the need for a copy operation.\n\nThe following example shows how to create instances and pass them between functions.\n\nThese examples demonstrate this basic characteristic of : it can be moved, but not copied. \"Moving\" transfers ownership to a new and resets the old .\n\nThe following example shows how to create instances and use them in a vector.\n\nIn the range for loop, notice that the is passed by reference. If you try to pass by value here, the compiler will throw an error because the copy constructor is deleted.\n\nThe following example shows how to initialize a that is a class member.\n\nYou can use make_unique to create a to an array, but you cannot use to initialize the array elements.\n\nFor more examples, see make_unique."
    },
    {
        "link": "https://stackoverflow.com/questions/26318506/transferring-the-ownership-of-object-from-one-unique-ptr-to-another-unique-ptr-i",
        "document": "The following situations involve transferring ownership from one to another: returning from a function, and passing as a parameter to a function like a constructor.\n\nSay you have some polymorphic type :\n\nAnd you want a simple factory that creates a pet based on a required value of obedience. Then the factory must return a pointer. We want the pet factory to transfer ownership of the created pet to the caller so a reasonable return type is :\n\nNow, say we want to create a that will own the pet then we might want to pass the pet into the constructor of the . There is some debate (see comments on this blog post) about how best to pass a to a constructor but it would look something like this:\n\nWe have passed the into the constructor and have then \"moved\" it to the member variable.\n\nThe calling code could look something like:\n\nAfter constructing the , the variable will be because we have transferred ownership of the pet to the ."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/memory/unique_ptr",
        "document": "is a smart pointer that owns (is responsible for) and manages another object via a pointer and subsequently disposes of that object when the goes out of scope.\n\nThe object is disposed of, using the associated deleter, when either of the following happens:\n• the managing object is assigned another pointer via or .\n\nThe object is disposed of, using a potentially user-supplied deleter, by calling get_deleter()(ptr). The default deleter ( ) uses the delete operator, which destroys the object and deallocates the memory.\n\nA may alternatively own no object, in which case it is described as empty.\n\nThere are two versions of :\n\nThe class satisfies the requirements of MoveConstructible and MoveAssignable, but of neither CopyConstructible nor CopyAssignable.\n\nIf was not a valid type (e.g., is a reference type), a program that instantiates the definition of std::unique_ptr<T, Deleter> is ill-formed.\n\nOnly non-const can transfer the ownership of the managed object to another . If an object's lifetime is managed by a const std::unique_ptr, it is limited to the scope in which the pointer was created.\n\nis commonly used to manage the lifetime of objects, including:\n• providing exception safety to classes and functions that handle objects with dynamic lifetime, by guaranteeing deletion on both normal exit and exit through exception.\n• passing ownership of uniquely-owned objects with dynamic lifetime into functions.\n• acquiring ownership of uniquely-owned objects with dynamic lifetime from functions.\n• as the element type in move-aware containers, such as , which hold pointers to dynamically-allocated objects (e.g. if polymorphic behavior is desired).\n\nmay be constructed for an incomplete type , such as to facilitate the use as a handle in the pImpl idiom. If the default deleter is used, must be complete at the point in code where the deleter is invoked, which happens in the destructor, move assignment operator, and member function of . (In contrast, std::shared_ptr cannot be constructed from a raw pointer to incomplete type, but can be destroyed where is incomplete). Note that if is a class template specialization, use of as an operand, e.g. !p requires 's parameters to be complete due to ADL.\n\nIf is a derived class of some base , then unique_ptr<T> is implicitly convertible to unique_ptr<B>. The default deleter of the resulting unique_ptr<B> will use for , leading to undefined behavior unless the destructor of is virtual. Note that std::shared_ptr behaves differently: std::shared_ptr<B> will use the for the type and the owned object will be deleted correctly even if the destructor of is not virtual.\n\nUnlike std::shared_ptr, may manage an object through any custom handle type that satisfies NullablePointer. This allows, for example, managing objects located in shared memory, by supplying a that defines or another fancy pointer.\n\nB ~B bar D B D ~D bar override // a function consuming a unique_ptr can take it by value or by rvalue reference std D pass_through std D p p bar p // helper function for the custom deleter demo below close_file fp fp List Node data std Node next std Node head ~List // would have invoked its “next”'s destructor recursively, which would head next std head next head std next push data head std Node new Node data, std head main std D p D // which in turn transfers ownership back through the return value std D q pass_through std p // “p” is now in a moved-from 'empty' state, equal to nullptr p // Create a derived resource and point to it via base type std B p D p bar unique_file_t std, decltype close_file unique_file_t fp , , close_file fp fp. // “close_file()” called here (if “fp” is not null) std D, D p new D, D ptr delete ptr // “p” would leak here if it were a plain pointer std D p new D List wall enough beer beer enough beer wall. beer . enough \" bottles of beer on the wall... \" 1) Unique ownership semantics demo D::D D::bar D::~D 2) Runtime polymorphism demo D::D D::bar D::~D 3) Custom deleter demo x 4) Custom lambda-expression deleter and exception safety demo D::D destroying from a custom deleter... D::~D Caught exception 5) Array form of unique_ptr demo D::D D::D D::D D::~D D::~D D::~D 6) Linked list demo 1,000,000 bottles of beer on the wall...\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-14-make_unique",
        "document": "std::make_unique is a utility function in C++ that was introduced in C++14. It is used to create a unique_ptr object, which is a smart pointer that manages the lifetime of dynamically allocated objects. It is defined inside <memory> header file.\n• object_type: It is the type of object you want to create.\n• arguments: It is the argument list for the constructor of object_type.\n\nIt is the preferred way to create a std::unique_ptr, as it is safer than using the new operator directly because the object is automatically destroyed when it goes out of scope.\n\nThe following programs demonstrate how to implement std::make_unique() in our programs.\n• None No cleanup is necessary if make_unique is not evaluated."
    },
    {
        "link": "https://stackoverflow.com/questions/64054795/how-can-i-use-make-unique-with-c11",
        "document": "First, is incorrect syntax, it should be instead.\n\nSecond, does not exist in C++11, it was added in C++14 (unlike , which does exist in C++11).\n\nIf you look at the cppreference doc for , it shows a possible implementation that (with minor tweaks) can be applied to C++11 code. If your code doesn't need to worry about support for arrays, then the simplest implementation would look like this:\n\nThen you can use (without the prefix):"
    },
    {
        "link": "https://stackoverflow.com/questions/53870522/why-use-stdmake-unique-in-c17",
        "document": "As far as I understand, C++14 introduced because, as a result of the parameter evaluation order not being specified, this was unsafe:\n\nCalling was a way to constrain the call order, thus making things safe:\n\nSince then, C++17 has clarified the evaluation order, making Syntax A safe too, so here's my question: is there still a reason to use over 's constructor in C++17? Can you give some examples?\n\nAs of now, the only reason I can imagine is that it allows to type only once (assuming you don't need to rely on polymorphism with ). However, that seems like a pretty weak reason, especially when doesn't allow to specify a deleter while 's constructor does.\n\nAnd just to be clear, I'm not advocating in favor of removing from the Standard Library (keeping it makes sense at least for backward compatibility), but rather wondering if there are still situations in which it is strongly preferred to"
    },
    {
        "link": "https://forum.qt.io/topic/154869/what-is-difference-between-std-unique_ptr-v-s-std-make_unique",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/l97k7r/c11_14_and_20_as_a_beginner_i_feel_lost",
        "document": "Hello. I started learning C++ a week ago, the course I have been following is teaching C++11 I believe, but at the time I had no idea there were different standards. Recently C++20 was released, and that got my attention, and so I started looking into it.\n\nI have several questions regarding this topic. I know that C++14 and 17 don't require you to relearn the language, because these are like additions or improvements to C++11, however if only know C++98 then you have to relearn C++11 or later which they call \"Modern C++\". Is this the same for C++20? I have read that it's a big update and it fundamentally changes how we code. So should I continue learning C++11/14 for now and not worry about C++20? Or is it better (since I'm still new and haven't gotten that far with C++11/14) to start with the newer standard? And if so, what are some good books/courses that you suggest I check out?"
    }
]