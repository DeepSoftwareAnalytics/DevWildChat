[
    {
        "link": "https://openjfx.io/openjfx-docs",
        "document": ""
    },
    {
        "link": "https://medium.com/@gabriellamedas/my-first-gui-application-with-javafx-3908b843abd8",
        "document": "I’m currently attempting to create a GUI application with JavaFX, a software platform for creating and delivering desktop applications. Before starting, I read the IntelliJ IDEA help-documentation for all the set-up for the project, and ensured that the JavaFX plugin was enabled in my IntelliJ.\n\nI then went through a tutorial provided by the same IntelliJ IDEA documentation to learn how to write a simple “Hello World” application with JavaFX — because, ahem, I had no clue on how/where to start!!\n\nThis is the first time I attempt to write a desktop application. The above-mentioned tutorial is useful to get started as it shows each step that allows you to create a simple program like “Hello World”. If you follow all of those steps carefully, you’ll manage to create your first GUI application. I then used the tutorial to re-create another application (the “Counter” application, an application that simply increases a counter by 1 each time the user presses a button) and I managed to make it work.\n\nBut did I actually understand what I was doing?\n\nThe answer is: so-and-so. Once I had written my application I had to deal with a partially new and unknown syntax. I had a general picture of what each file I had created was responsible for. But words like , , , which were all then grouped in a file: this was the first time I came across them in my apprenticeship project.\n\nSo I thought to research each of the above concepts (and anything else I didn’t know/quite get in my application) before starting to become more familiar with the process of coding/creating the application itself (in other words: I spent some time for the theory before turning to the practice!)\n\nI found a very useful web page that set up a basic structure of a JavaFX application. Thanks to that page, and adding to it further researches done in the internet, I learned the following:\n• the class extends a class, and the method is the main entry point.\n• A JavaFX application defines the UI through a class and a class.\n\nThe class is the top-level JavaFX container. The is constructed by the platform. Additional objects can be constructed by the application.\n\nThe is the container for all content. Its size can be initialized by the application during construction. A good practice is to set height and width of the when you create it, otherwise it defaults to the minimum size needed to display its contents.\n\nThe application must specify the root node for the by setting the property.\n• The content of the is represented as a hierarchical scene graph of nodes. The node can be a resizable layout node (e.g. a object.) This means that the node’s size tracks the 's size and changes when the is resized by the user.\n• The node contains one child node, a button control with text, and an event handler to print a message when the button is pressed.\n\nAnother option is to build your GUI application with JavaFX FXML, a XML-based language that provides the structure for building a UI separate from the logic of the application (which sounds pretty good!)\n\nFor a project like this you would create a file which specifies the UI that is displayed when the application starts:\n\nIt is important that you modify the method in to include the class, which is responsible for loading the FXML source file and returning the resulting object graph:\n\nis the element of the FXML document and has 2 attributes:\n• : this is required when you specify controller-based event handlers in markup.\n• : this is always required. It specifies the namespace.\n\nMy layout also contains the dependance to a style sheet that customises my application:\n\nInside the layout you can include:\n\nThe field can also contain an event handler that — in my case — calls a method whenever the button is used and prints a number increased by 1 each time the button is pressed. This method is inside a class which basically contains the logic for my application:\n\nMy application is up-and-running, and is also styled according to my mentors’ requests. It is not tested though, and this is the next step I’ll have to deal with.\n\nI’ve tried to install the testFX plugin in IntelliJ as I’ve been told this is what I need to fully test my application, but unfortunately I’ve encountered some issues with my newly-installed Java version. I also hadn’t started the project with and I have the feeling that I should have done so.\n\nI’m waiting for some feedback tomorrow (IPM time!) and hopefully I’ll be able to learn something — a lot! — more."
    },
    {
        "link": "https://stackoverflow.com/questions/40097090/how-to-add-buttons-to-a-javafx-gui-via-the-controller-java-file-using-the-fxid",
        "document": "Still relatively new to JavaFX and I'm having a bit of trouble getting buttons to add to a GUI that I've setup.\n\nI have 3 files: Main.java, Controller.java, and sample.fxml (each located below)\n\nFrom what I've read via tutorials and docs, the Controller.java file is loaded and linked to the fxml file due to the \"fx:controller\" section -- but beyond that I cannot properly get the program to run that method.\n\nI've tried setting up the Main.java to be the controller and just fusing the code in that way (bombed). Even actively went against the form and trying creating a new instance of the Controller.java in the Main.java file (which would essentially just be creating another instance alongside of what's loaded when the program runs) and that too bombed."
    },
    {
        "link": "https://tutorialspoint.com/javafx/javafx_ui_controls.htm",
        "document": "UI Controls are the graphical elements that allow users to interact with an application or a website. They include buttons, menus, sliders, text fields, checkboxes, radio buttons, and more. In this tutorial, we will explore the different types of UI Controls of JavaFX.\n\nlet's start the discussion by introducing three main aspects of an user interface −\n• None UI elements − These are the core visual elements which the user eventually sees and interacts with. JavaFX provides a huge list of widely used and common elements varying from basic to complex, which we will cover in this tutorial.\n• None Layouts − They define how UI elements should be organized on the screen and provide a final look and feel to the GUI (Graphical User Interface). This part will be covered in the Layout chapter.\n• None Behavior − These are events which occur when the user interacts with UI elements. This part will be covered in the Event Handling chapter.\n\nTo create GUI components (controls), JavaFX supports several controls such as date picker, button text field, etc. These controls are represented by different classes of the package javafx.scene.control. We can create a control by instantiating its respective class.\n\nFollowing is the list of common controls used while designing the GUI in JavaFX.\n\nThe following program is an example which displays a login page in JavaFX. Here, we are using the controls label, text field, password field and button. Save this code in a file with the name LoginPage.java.\n\nCompile and execute the saved java file from the command prompt using the following commands.\n\nOn executing, the above program generates a JavaFX window as shown below.\n\nThe following program is an example of a registration form, which demonstrates controls in JavaFX such as Date Picker, Radio Button, Toggle Button, Check Box, List View, and Choice List. Save this code in a file with the name Registration.java.\n\nCompile and execute the saved java file from the command prompt using the following commands.\n\nOn executing, the above program generates a JavaFX window as shown below."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAlso known as The Swing Tutorial\n\nThis trail tells you how to create graphical user interfaces (GUIs) for applications and applets, using the Swing components. If you would like to incorporate JavaFX into your Swing application, please see Integrating JavaFX into Swing Applications.\n\nGetting Started with Swing is a quick start lesson. First it gives you a bit of background about Swing. Then it tells you how to compile and run programs that use Swing components.\n\nLearning Swing with the NetBeans IDE is the fastest and easiest way to begin working with Swing. This lesson explores the NetBeans IDE's GUI builder, a powerful feature that lets you visually construct your Graphical User Interfaces.\n\nUsing Swing Components tells you how to use each of the Swing components  buttons, tables, text components, and all the rest. It also tells you how to use borders and icons.\n\nConcurrency in Swing discusses concurrency as it applies to Swing programming. Information on the event dispatch thread and the SwingWorker class are included.\n\nUsing Other Swing Features tells you how to use actions, timers, and the system tray; how to integrate with the desktop class, how to support assistive technologies, how to print tables and text, how to create a splash screen, and how to use modality in dialogs.\n\nLaying Out Components Within a Container tells you how to choose a layout manager, how to use each of the layout manager classes the Java platform provides, how to use absolute positioning instead of a layout manager, and how to create your own layout manager.\n\nModifying the Look and Feel tells you how to specify the look and feel of Swing components.\n\nDrag and Drop and Data Transfer tells you what you need to know to implement data transfer in your application.\n\nWriting Event Listeners tells you how to handle events in your programs.\n\nPerforming Custom Painting gives you information on painting your own Swing components. It discusses painting issues specific to Swing components, provides an overview of painting concepts, and has examples of custom components that paint themselves.\n\nAlthough this is the main trail for learning about GUIs, it isn't the only trail with UI-related information.\n• 2D Graphics, which describes the 2D graphics features available in the JDK.\n• Sound, which discusses the sound capabilities available in the JDK.\n• Java Applets, which describes API available only to applets.\n• Essential Java Classes, which covers many topics, including properties and the standard I/O streams.\n• The JavaFX Documentation, which describes how to build UIs with JavaFX.\n• The Bonus trail contains Full-Screen Exclusive Mode API, a lesson that describes how to use API introduced in v1.4 to render graphics directly to the screen."
    },
    {
        "link": "https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Alert.html",
        "document": "The Alert class subclasses the class, and provides support for a number of pre-built dialog types that can be easily shown to users to prompt for a response. Therefore, for many users, the Alert class is the most suited class for their needs (as opposed to using directly). Alternatively, users who want to prompt a user for text input or to make a choice from a list of options would be better served by using and , respectively.\n\nWhen creating an Alert instance, users must pass in an enumeration value. It is by passing in this value that the Alert instance will configure itself appropriately (by setting default values for many of the properties, including , , and , as well as the default that are expected in a dialog of the given type.\n\nTo instantiate (but not yet show) an Alert, simply use code such as the following: Alert alert = new Alert(AlertType.CONFIRMATION, \"Are you sure you want to format your system?\");\n\nOnce an Alert is instantiated, we must show it. More often than not, alerts (and dialogs in general) are shown in a modal and blocking fashion. 'Modal' means that the dialog prevents user interaction with the owning application whilst it is showing, and 'blocking' means that code execution stops at the point in which the dialog is shown. This means that you can show a dialog, await the user response, and then continue running the code that directly follows the show call, giving developers the ability to immediately deal with the user input from the dialog (if relevant).\n\nJavaFX dialogs are modal by default (you can change this via the API). To specify whether you want blocking or non-blocking dialogs, developers simply choose to call or (respectively). By default most developers should choose to use , given the ease of coding in these situations. Shown below is three code snippets, showing three equally valid ways of showing the Alert dialog that was specified above:\n\nThere is no better or worse option of the three listed above, so developers are encouraged to work to their own style preferences. The purpose of showing the above is to help introduce developers to the API, which is new in Java 8 and may be foreign to many developers."
    },
    {
        "link": "https://code.makery.ch/blog/javafx-dialogs-official",
        "document": "JavaFX 8u40 finally includes simple Dialogs and Alerts! I’ve been waiting for this since 2012! In the meantime I wrote about how to use Dialogs in JavaFX 2 and later in JavaFX 8 with ControlsFX.\n\nNow that they are available in the official JDK, let’s learn how to use them.\n\nTo use the official JavaFX Dialogs you need JDK 8u40 or later.\n\nThere is not a complete Exception Dialog out of the box. But we can easily provide as expandable content.\n\nNote: The will return if the user cancelled the dialog.\n\nNote: The will return if the user didn’t choose anything or cancelled the dialog.\n\nHere is an example of how to create a custom dialog with a login form:\n\nIn the current version it’s a bit cumbersome to get to the Dialog’s to be able to set its icon. Here is how:\n\nAccording to this bug report the final version of the JavaFX 8u40 Dialogs should use the same icon as the application that it is running from. In that case you would need to set its owner and the Dialog would get the owner’s icon:\n\nAnother option is to remove the icon and use only minimal window decorations.\n\nYou can specify the owner for a dialog. If no owner or null is specified for the owner, it is a top-level, unowned dialog.\n\nYou can specify the modality for a dialog. The modality must be one of , , or .\n\nFor more information on the Dialogs have a look at the JavaFX API docs:"
    },
    {
        "link": "https://geeksforgeeks.org/javafx-alert-with-examples",
        "document": "Alert is a part of JavaFX and it is a subclass of Dialog class. Alerts are some predefined dialogs that are used to show some information to the user. Alerts are basically of specific alert types:\n• CONFIRMATION alert :The CONFIRMATION alert type configures the Alert dialog to appear in a way that suggests the content of the dialog is seeking confirmation from the user.\n• WARNING alert :The WARNING alert type configures the Alert dialog to appear in a way that suggests the content of the dialog is warning the user about some fact or action.\n• NONE alert :The NONE alert type has the effect of not setting any default properties in the Alert.\n• INFORMATION alert :The INFORMATION alert type configures the Alert dialog to appear in a way that suggests the content of the dialog is informing the user of a piece of information.\n• ERROR alert :The ERROR alert type configures the Alert dialog to appear in a way that suggests that something has gone wrong.\n\nConstructors of the class are:\n• Alert(Alert.AlertType a): Creates a new alert with a specified alert type.\n• Alert(Alert.AlertType a, String c, ButtonType… b): Creates a new alert with a specified alert type, content and button type.\n• Program to create alert of different types and display them: This program creates an alert which is of default type. The alert would be changed to different alert types when required. This program creates a Buttons indicated by the name b, b1, b2, b3. The buttons will be created inside a scene, which in turn will be hosted inside a stage. We would create a label to show if the button is pressed or not. The function setTitle() is used to provide title to the stage. Then a tile pane is created, on which addChildren() method is called to attach the button and label inside the scene. Finally, the show() method is called to display the final results.we would create an event handler to handle the button events. The event handler would be added to the button using setOnAction() function. When the buttons are pressed they will display the respective alerts associated with them and will set the respective alertType using the function setAlertType() function.\n• Program to create alert and set different alert types and button type and also set different content text: This program creates an alert which is of default type. the alert would be changed to different alert types when required. This program creates a Buttons indicated by the name b, b1, b2, b3, b4. The buttons will be created inside a scene, which in turn will be hosted inside a stage. We would create a label to show if the button is pressed or not. The function setTitle() is used to provide title to the stage. Then a tile pane is created, on which addChildren() method is called to attach the button and label inside the scene. Finally, the show() method is called to display the final results.we would create an event handler to handle the button events. The event handler would be added to the button using setOnAction() function. When the buttons are pressed they will display the respective alerts associated with them and will set the respective alertType using the function setAlertType() function. The content text would also be changed using the setContentText() method .we would create a new alert for the 4th button which is of default type, and also set a button type using the constructor of alert."
    },
    {
        "link": "https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Dialog.html",
        "document": "A Dialog in JavaFX wraps a and provides the necessary API to present it to end users. In JavaFX 8u40, this essentially means that the is shown to users inside a , but future releases may offer alternative options (such as 'lightweight' or 'internal' dialogs). This API therefore is intentionally ignorant of the underlying implementation, and attempts to present a common API for all possible implementations.\n\nThe Dialog class has a single generic type, R, which is used to represent the type of the property (and also, how to convert from to R, through the use of the ).\n\nCritical note: It is critical that all developers who choose to create their own dialogs by extending the Dialog class understand the importance of the property. A result converter must always be set, whenever the R type is not or . If this is not heeded, developers will find that they get ClassCastExceptions in their code, for failure to convert from via the .\n\nIt is likely that most developers would be better served using either the class (for pre-defined, notification-style alerts), or either of the two pre-built dialogs ( and ), depending on their needs.\n\nOnce a Dialog is instantiated, the next step is to configure it. Almost all properties on Dialog are not related to the content of the Dialog, the only exceptions are , , and , and these properties are simply forwarding API onto the respective properties on the stored in the property. These three properties are forwarded from DialogPane for developer convenience. For developers wanting to configure their dialog, they will in many cases be required to use code along the lines of .\n\nAfter configuring these properties, all that remains is to consider whether the buttons (created using and the method) are fully configured. Developers will quickly find that the amount of configurability offered via the class is minimal. This is intentional, but does not mean that developers can not modify the buttons created by the that have been specified. To do this, developers simply call the method with the ButtonType (assuming it has already been set in the list. The returned Node is typically of type , but this depends on if the method has been overridden. A typical approach is therefore along the following lines:\n\nOnce a Dialog is instantiated and fully configured, the next step is to show it. More often than not, dialogs are shown in a modal and blocking fashion. 'Modal' means that the dialog prevents user interaction with the owning application whilst it is showing, and 'blocking' means that code execution stops at the point in which the dialog is shown. This means that you can show a dialog, await the user response, and then continue running the code that directly follows the show call, giving developers the ability to immediately deal with the user input from the dialog (if relevant).\n\nJavaFX dialogs are modal by default (you can change this via the API). To specify whether you want blocking or non-blocking dialogs, developers simply choose to call or (respectively). By default most developers should choose to use , given the ease of coding in these situations. Shown below is three code snippets, showing three equally valid ways of showing a dialog:\n\nThere is no better or worse option of the three listed above, so developers are encouraged to work to their own style preferences. The purpose of showing the above is to help introduce developers to the API, which is new in Java 8 and may be foreign to many developers.\n\nIn some circumstances it is desirable to prevent a dialog from closing until some aspect of the dialog becomes internally consistent (e.g. a form inside the dialog has all fields in a valid state). To do this, users of the dialogs API should become familiar with the method. By passing in a (that has already been set in the list), users will be returned a Node that is typically of type (but this depends on if the method has been overridden). With this button, users may add an event filter that is called before the button does its usual event handling, and as such users may prevent the event handling by the event. Here's a simplified example:\n\nIt is important to understand what happens when a Dialog is closed, and also how a Dialog can be closed, especially in abnormal closing situations (such as when the 'X' button is clicked in a dialogs title bar, or when operating system specific keyboard shortcuts (such as alt-F4 on Windows) are entered). Fortunately, the outcome is well-defined in these situations, and can be best summarised in the following bullet points:\n• JavaFX dialogs can only be closed 'abnormally' (as defined above) in two situations:\n• When the dialog only has one button, or\n• When the dialog has multiple buttons, as long as one of them meets one of the following requirements:\n• The button has a whose is of type .\n• The button has a whose returns true when is called.\n• In all other situations, the dialog will refuse to respond to all close requests, remaining open until the user clicks on one of the available buttons in the area of the dialog.\n• If a dialog is closed abnormally, and if the dialog contains a button which meets one of the two criteria above, the dialog will attempt to set the property to whatever value is returned from calling the with the first matching .\n• If for any reason the result converter returns null, or if the dialog is closed when only one non-cancel button is present, the property will be null, and the method will return . This later point means that, if you use either of option 2 or option 3 (as presented earlier in this class documentation), the lambda will never be called, and code will continue executing as if the dialog had not returned any value at all."
    },
    {
        "link": "https://stackoverflow.com/questions/8309981/how-to-create-and-show-common-dialog-error-warning-confirmation-in-javafx-2",
        "document": "Official standard dialogs are coming to JavaFX in release 8u40, as part of the implemenation of RT-12643. These should be available in final release form around March of 2015 and in source code form in the JavaFX development repository now.\n\nIn the meantime, you can use the ControlsFX solution below...\n\nControlsFX is the defacto standard 3rd party library for common dialog support in JavaFX (error, warning, confirmation, etc).\n\nThere are numerous other 3rd party libraries available which provide common dialog support as pointed out in some other answers and you can create your own dialogs easily enough using the sample code in Sergey's answer.\n\nHowever, I believe that ControlsFX easily provide the best quality standard JavaFX dialogs available at the moment. Here are some samples from the ControlsFX documentation."
    }
]