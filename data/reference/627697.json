[
    {
        "link": "https://vuejs.org/guide/typescript/composition-api",
        "document": "When using , the macro supports inferring the props types based on its argument:\n\nThis is called \"runtime declaration\", because the argument passed to will be used as the runtime option.\n\nHowever, it is usually more straightforward to define props with pure types via a generic type argument:\n\nThis is called \"type-based declaration\". The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.\n\nYou can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.\n\nWe can also move the props types into a separate interface:\n\nThis also works if is imported from an external source. This feature requires TypeScript to be a peer dependency of Vue.\n\nIn version 3.2 and below, the generic type parameter for were limited to a type literal or a reference to a local interface.\n\nThis limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nWhen using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by using Reactive Props Destructure :\n\nIn 3.4 and below, Reactive Props Destructure is not enabled by default. An alternative is to use the compiler macro:\n\nThis will be compiled to equivalent runtime props options. In addition, the helper provides type checks for the default values, and ensures the returned type has the optional flags removed for properties that do have default values declared.\n\nIf not using , it is necessary to use to enable props type inference. The type of the props object passed to is inferred from the option.\n\nWith type-based declaration, a prop can use a complex type much like any other type:\n\nFor runtime declaration, we can use the utility type:\n\nThis works in much the same way if we're specifying the option directly:\n\nThe option is more commonly used with the Options API, so you'll find more detailed examples in the guide to TypeScript with Options API. The techniques shown in those examples also apply to runtime declarations using .\n\nIn , the function can also be typed using either runtime declaration OR type declaration:\n\nThe type argument can be one of the following:\n• A callable function type, but written as a type literal with Call Signatures. It will be used as the type of the returned function.\n• A type literal where the keys are the event names, and values are array / tuple types representing the additional accepted parameters for the event. The example above is using named tuples so each argument can have an explicit name.\n\nAs we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.\n\nWhen not using , is able to infer the allowed events for the function exposed on the setup context:\n\nRefs infer the type from the initial value:\n\nSometimes we may need to specify complex types for a ref's inner value. We can do that by using the type:\n\nOr, by passing a generic argument when calling to override the default inference:\n\nIf you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes :\n\nalso implicitly infers the type from its argument:\n\nTo explicitly type a property, we can use interfaces:\n\ninfers its type based on the getter's return value:\n\nYou can also specify an explicit type via a generic argument:\n\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\n\nWithout type annotation, the argument will implicitly have a type of . This will also result in a TS error if or are used in . It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of :\n\nProvide and inject are usually performed in separate components. To properly type injected values, Vue provides an interface, which is a generic type that extends . It can be used to sync the type of the injected value between the provider and the consumer:\n\nIt's recommended to place the injection key in a separate file so that it can be imported in multiple components.\n\nWhen using string injection keys, the type of the injected value will be , and needs to be explicitly declared via a generic type argument:\n\nNotice the injected value can still be , because there is no guarantee that a provider will provide this value at runtime.\n\nThe type can be removed by providing a default value:\n\nIf you are sure that the value is always provided, you can also force cast the value:\n\nWith Vue 3.5 and 2.1 (powering both the IDE language service and ), the type of refs created by in SFCs can be automatically inferred for static refs based on what element the matching attribute is used on.\n\nIn cases where auto-inference is not possible, you can still cast the template ref to an explicit type via the generic argument:\n\nTo get the right DOM interface you can check pages like MDN.\n\nNote that for strict type safety, it is necessary to use optional chaining or type guards when accessing . This is because the initial ref value is until the component is mounted, and it can also be set to if the referenced element is unmounted by .\n\nWith Vue 3.5 and 2.1 (powering both the IDE language service and ), the type of refs created by in SFCs can be automatically inferred for static refs based on what element or component the matching attribute is used on.\n\nIn cases where auto-inference is not possible (e.g. non-SFC usage or dynamic components), you can still cast the template ref to an explicit type via the generic argument.\n\nIn order to get the instance type of an imported component, we need to first get its type via , then use TypeScript's built-in utility to extract its instance type:\n\nIn cases where the exact type of the component isn't available or isn't important, can be used instead. This will only include properties that are shared by all components, such as :\n\nIn cases where the component referenced is a generic component, for instance :\n\nIt needs to be referenced using from the library as won't work.\n\nNote that with 2.1+, static template refs' types can be automatically inferred and the above is only needed in edge cases."
    },
    {
        "link": "https://vuejs.org/guide/essentials/computed",
        "document": "In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\nAnd we want to display different messages depending on if already has some books or not:\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on . More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\n\n// `this` points to the component instance Here we have declared a computed property . Try to change the value of the array in the application and you will see how is changing accordingly. You can data-bind to computed properties in templates just like a normal property. Vue is aware that depends on , so it will update any bindings that depend on when changes.\n\nHere we have declared a computed property . The function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as . Computed refs are also auto-unwrapped in templates so you can reference them without in template expressions. A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of depends on , so it will update any bindings that depend on when changes.\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as has not changed, multiple access to will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because is not a reactive dependency:\n\nIn comparison, a method invocation will always run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property , which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on . Without caching, we would be executing ’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\nGetting the Previous Value ​\n\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations."
    },
    {
        "link": "https://vuejs.org/guide/essentials/computed.html",
        "document": "In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\nAnd we want to display different messages depending on if already has some books or not:\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on . More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\n\n// `this` points to the component instance Here we have declared a computed property . Try to change the value of the array in the application and you will see how is changing accordingly. You can data-bind to computed properties in templates just like a normal property. Vue is aware that depends on , so it will update any bindings that depend on when changes.\n\nHere we have declared a computed property . The function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as . Computed refs are also auto-unwrapped in templates so you can reference them without in template expressions. A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of depends on , so it will update any bindings that depend on when changes.\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as has not changed, multiple access to will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because is not a reactive dependency:\n\nIn comparison, a method invocation will always run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property , which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on . Without caching, we would be executing ’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\nGetting the Previous Value ​\n\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations."
    },
    {
        "link": "https://netlify.com/blog/understanding-defineprops-and-defineemits-in-vue-3.2",
        "document": "Vue 3 introduced us to the Composition API - a different way of handling reactive data using and in Vue.js. It received a lot of positive feedback but also some concerns about the verbosity of the Composition API usage inside SFCs. Then comes Vue 3.2 with a stable release of a new feature which aims to address those concerns in a very practical way.\n\nWhy am I excited about ? It made the already simple Composition API even simpler. With , we don’t need named or default exports in SFCs anymore, we can simply define variables and use them in the template.\n\nThis is probably the easiest part. To start using , all you need to do is add to your existing script tag like this:\n\nAnd you can access name in the template like this:\n\nThat’s it. This is simple and very useful in reducing code bulk in larger codebases. To achieve the same result with the Composition API, we’ll need to return the variable (i.e expose it to the template) like this:\n\nYou can immediately get a sense of how large a codebase can grow when you have large SFCs. With , we get rid of all the unnecessary boilerplate code and trim our component down to only what is needed.\n\nNote, we used a variable for simplicity in the snippet, but you’re not limited to just variables. Anything (including helper functions) declared inside the context will be accessible from the template.\n\nBut that’s not all, we can also import and use components without any extra config or bindings. For instance, consider importing a component into the file. Without the feature, you’ll probably do something like this:\n\nThis is the pattern I imagine you would be familiar with. But it gets better. With you can import the component and use it in the template with no additional step, like this:\n\nWe didn’t need to declare a object and register the component in it as we did before. Cool right?\n\nA good question to ask at this point would be, so we’ve imported the component into , how do we pass props to it? or emit an event from it to tell the parent that the form has been submitted? Let’s find out.\n\nThe feature ships with the and APIs that make it possible for us to declare props and emits. They are automatically available inside the context and doesn’t need to be imported to use them. Let’s demonstrate!\n\nFirst, in the component, lets define a prop and also emit the event like so:\n\nIn the snippet above, we did a couple of things using the and API:\n• defineProps – allows us to define props for our component. We used it to define the prop that will get passed in from the parent (App.vue). Our form will only be visible IF the age prop exists.\n• defineEmits – lets us define the events that our component can emit. In this case, we emit a event to let the parent component (App.vue) know when the form has been submitted. When that happens, we just log “form submitted” on the parent.\n\nNext, lets update App.vue to capture all these code updates:\n\nHere, we pass the prop to the component and set up our event to call the function whenever the form is submitted from the child component.\n\nAnd that is how we use props and events in the context.\n\nAs you can imagine, other features shipped with that we did not get to in this post. However, one that I find really worthy of mentioning is the dynamic components feature. It allows you to dynamically render components in your Vue templates when certain conditions are satisfied.\n\nIf you’d like to explore more features and learn other things about the Vue feature, feel free to read the documentation here."
    },
    {
        "link": "https://medium.com/@joaofornazari/computed-vs-ref-props-on-vue-3-582b1327e74a",
        "document": "Let’s say that you’re developing something like Instagram, Facebook, Twitter… a social media app.\n\nThis app has posts with and without images but always with text.\n\nIf you want to display the likes that a post received for your app users, you can use both computed and ref on this, right? Like this:\n\nAnd yes, you can do this. Vue allows it, and won’t throw a warning or error. Both are reactive, both will work. You shouldn’t do it both ways, but for the sake of the example this is “ok”.\n\nNow, let’s say that you want to make a star emoji “🤩” show up on a post that reaches 1000 likes:\n\nThink about it: how would you do it with ref and with computed?\n\nWith ref, the solution would be a little ugly:\n\nBecause ref doesn’t handle updating its own value based on calculus, e.g.: would not update reactively because you’re passing only to create it, not a reference to an object (like )\n\nBut with computed, things look nicer:\n\nStill looks like computed and ref are the same thing, right? Okay, we’ll get into the point. I needed to get your mind into the problem context and possible behaviors before.\n\nFor last, imagine that you want to have some button that, somehow, will make the 🤩 be invisible again. You can do it in ref — but cannot do it using computed props.\n\nAt least, not so obviously. Why? Check:\n\nUsing ref, you only need to add a button on template:\n\nThis will work because thousandLikes (ref) is a reactive prop, being able to have its value updated at anywhere.\n\nBut if you try to update thousandLikes (computed), either Vue will throw a warning or your component will crash. And this is because computed props are readonly. You can update its dependencies, but you cannot update the final result directly.\n\nIf you want to use computed, you’d have to add another property on the component:\n• computed props are operations done on reactive props, and the computed prop itself is readonly;\n• ref props are reactive props and can be changed, and can only be set by passing objects to it, not operations.\n\nHope this was useful for you!"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/1ay0rui/best_practices_for_organizing_larger_vue_3",
        "document": "I'm currently learning Vue and have gone through several courses. However, I'm still curious about the project structure companies use. The courses offer a basic structure where the instructor creates a \"components\" folder and dumps all the components there. It's easy to see how things could quickly become messy if there isn't a systematic approach to organization. Does anyone have any resources or tutorials on how to organize larger Vue 3 applications with TypeScript? How do professionals do it? Should TypeScript types be divided into global and local (specific to components)? If local, what should the structure of a component look like? I'm struggling to find intermediate-level courses that show how this should be done. Thanks for your help!"
    },
    {
        "link": "https://thisdot.co/blog/building-reusable-components-in-vue-3",
        "document": "Vue.js is an open-source model–view–viewmodel front end JavaScript framework for building user interfaces and single-page applications. It was created by Evan You. From its official documentation “Vue is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS and JavaScript, and provides a declarative and component-based programming model that helps you efficiently develop user interfaces, be it simple or complex.”\n\nThe way we build apps and websites in Vue is different than using pure HTML, CSS, and JavaScript. In Vue, the app is like a tree of components.\n\nThere are two ways to write Vue components: the old (classic) way, by using Vue class component, and the new (modern) way by using script setup and composition APIs.\n\nVue follows the same file structure in both ways. First, each component should be in a separate file with the extension, and each Vue file contains three sections.\n\nBoth ways share the same file structure. The only difference is in the section.\n\nIn the Vue class components way\n\nThe section should return the Vue object like this:\n\nThen we use script setup:\n\nThe new way is more minimal, and we access all the Vue component class features using composition APIs (it’s more like React hooks for React if you’re familiar with React).\n\nEach component you create in your Vue app should be registered so Vue knows where to locate its implementation when it is encountered in a template.\n\nTo register your component in another component, you should add it to the property in the Vue object.\n\nIn the script setup way, you don’t need to manually register components. They are being registered automatically when you import them:\n\nProps allow developers to pass data from the parent component to children components. Vue components require explicit props declarations so that Vue knows what external props passed to the component should be treated as fall through attributes.\n\nTo declare props in your component, you should add them in the property in the Vue object:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nNote: it’s important to declare each Prop’s type too to avoid errors in production.\n\nIn script setup, you define props with from composition APIs:\n\nThe best way to practice these concepts is by building a small app.\n\nFirst, let’s initialize a new project using Vite:\n\nOr you can use Stackblitz like me in this tutorial. Go to the Vite tab and choose Vue:\n\nGo to , remove its content, and add the title.\n\nLet's create the List component where we will show the user all of the todos.\n\nAs you see, it's a very simple component. We just pass the array as a prop, and then use to print it.\n\nThen, import the list component so we can use it in App.js.\n\nNow, let's create the form to add todos from.\n\nWe will now need to add the states. In the new approch, we use .\n• is where we will store all the todos\n• is to store the current form value\n\nThen, we need to bind these states with the component, and the form input.\n\nFinally, we need to create the submit function to add a new todo on submit, and clear the form for a new one.\n\nThen, bind this function with the form.\n\nHere is the complete project for you to check out and try yourself!\n\nIf you need additional assistance, feel free to reach out to me on Twitter!"
    },
    {
        "link": "https://stackoverflow.com/questions/75391864/vue-3-typescript-how-can-i-construct-an-array-of-a-reusable-component-to-pas",
        "document": "I have created a reusable Button but I want to be able to style it dynamically as well as pass in values for text/icons, etc.\n\nThe below is how I have constructed this \"ActionButton\"; I am relatively new to Vue 3 and have been trying to understand many of the aspects but I seem to be a little stumped on this issue.\n\nAny help on this would be great as I can see being able to reuse components like this very helpful over many pages that need to be designed for our project but would like to pass in as many buttons as needed as some of the components that will receive it are also reusable components so need to be dynamic component and per page.\n\nI have been trying to construct this to pass in as an array of ActionButtons but I do not seem to understand how to construct it properly with the values needed.\n\nThis is what I have for now:"
    },
    {
        "link": "https://folio3.com/blog/setting-up-global-components-in-vue-3-with-vite-and-typescript",
        "document": "How to Set Up Global Components in Vue 3 with Vite and TypeScript\n\nIn modern web development, creating reusable and globally accessible components is a game-changer for enhancing productivity and maintaining clean, efficient codebases. Reusing components across multiple application parts is paramount for efficiency and maintainability.\n\nThis is where global components shine. By making components accessible everywhere without explicit imports, you streamline development, enhance code reusability, and improve project structure.\n\nThis guide delves into the practicalities of setting up global components in a Vue 3 project using Vite as your build tool and TypeScript for robust type safety. Keep reading to explore effective strategies, best practices, and potential pitfalls to ensure you know how to make the full potential of global components in your Vue 3 applications.\n\nVue 3 is the latest major version of Vue, a popular JavaScript framework for building user interfaces. It brings numerous performance improvements and new features, making it a powerful tool for developers.\n\nConversely, Vite is a build tool designed to provide a faster and leaner development experience. Together, they form a robust foundation for modern web applications.\n\nGlobal components in Vue allow you to define a component once and use it throughout your application without needing to import it each time. This not only saves time but also helps maintain a cleaner codebase.\n\nStep-by-Step Guide to Set Up Global Components in Vue 3 with Vite and TypeScript\n\nFollow the below steps to set up global components in Vue 3 with Vite and typescript:\n\nStep 1: Setting Up Your Vue 3 Project with Vite\n\nYou’ll first create a Vue 3 project using Vite to get started. Open your terminal and run the following command:\n\nWhen prompted, select “Vue” as your framework and choose “TypeScript” for type safety. Once your project is created, navigate to the project directory and install the necessary dependencies with:\n\nYour application will now be accessible at\n\nNow, let’s add Ant Design Vue to your project. Run the following command to install it:\n\nTo make Ant Design components available globally across your application, modify your src/main.ts file as follows:\n\nIn this example, we import the Ant Design Vue plugin and declare it a global one. This allows every component within App.vue to access Ant Design components without needing to import them individually.\n\nNext, create a global component using Ant Design. Inside the components folder, create a new file named ExampleParagraph.vue and add the following code:\n\nThis component renders content in red using Ant Design’s TypographyParagraph component. You can now use this component across your application.\n\nTo use the ExampleParagraph component globally, update your App.vue file:\n\nWhile global components are convenient, they can cause issues with TypeScript detection. To resolve this, we’ll use the unplugin-vue-components package. Install it with:\n\nEnsure TypeScript recognizes your components by adding the generated components.d.ts file to your tsconfig.json:\n\nSetting up global components in Vue 3 with Vite and TypeScript enhances productivity and ensures a scalable and maintainable codebase. Following the steps outlined in this guide, you’ve learned how to integrate Ant Design Vue, declare global components, and enhance them with TypeScript detection.\n\nThis setup provides a solid foundation for developing modern, efficient Vue applications that are easy to maintain and extend. Whether you’re building small projects or large-scale applications, mastering the art of global components in Vue 3 will undoubtedly streamline your development process."
    },
    {
        "link": "https://medium.com/@muhammederdinc/creating-reusable-components-with-the-composition-api-composables-3fa151fbf5f7",
        "document": "Hello, I would like to share with you the article of the presentation on “Creating Reusable Components with the Composition API & Composables” that I explained at Teknasyon Tech 26. Online Meetup. In this article, I wanted to touch on all the topics I explained in the presentation and create a resource for those who like to read more than watch videos. Also, since the presentation is in Turkish, I wanted to explain this subject by writing an article in English.\n\nIn this article, we will explore how to write reusable components with the Composition API & Composables that came into our lives with Vue 3, and also why we should use the Composition API and how we can use it correctly.\n\nFirst of all, let’s look at the problems we encountered while developing with the options API before Vue 3 and why we need Vue 3. Then, let’s try to understand how these problems are solved with Vue 3. At the end of the presentation, we will look at how we can write our composables better.\n\nOne of the most important principles of software development is to avoid repetitive work. Keeping our code reusable and portable is very important. In this way, we can reduce the development cost and produce products faster as a team.\n\nIn this article, our aim is to see how to stay away from repetitive tasks in Vue projects and how we can do this more easily with Vue 3.\n\nIn Vue projects, files with the .vue extension are called Single-File Components(SFC). Vue SFCs allow us to encapsulate template, logic, and styling in a single file. So we can keep Html, Css and JavaScript codes in a single file. In this article, we will focus on the script part and see how we can write our Js code sustainably and how we can organize our business logic.\n\nBefore the Composition API, we developed our Vue projects with the Options API. With the Options API, we thought our code was clearer and more understandable. The reason for this is that the code we will write has its own place and we knew what to add where (data, computed, methods etc).\n\nWhen we look at the sample code block above, we can say that our code looks very organized and easy to read and understand. So is it really so? Although it seems like a good solution for small projects, we can say that this is valid when the developed application is small and simple.\n\nAs the application or components grow, things start to get complicated, especially when we start to include more than one logic in a component. Let’s say we hold more than one logic in a component. In this case, since the codes of these logics will always be written in the same blocks, it will be very troublesome to update our code, add or remove a feature. It will be very difficult to understand which method belongs to which logic or which data belongs to which logic at once.\n\nSince we cannot read our code in a certain order, it will be difficult to understand and develop the code. This will appear as a situation that negatively affects the readability of the code.\n\nIf we could instead group our code by logic, it would be much easier to read and understand our code. This is exactly where the Composition API comes in.\n\nIn the image above, you can see how complex the code developed with the Options API is compared to the code developed with the Composition API. In the code example below, you can see how a code written with the Options API can be written with the Composition API.\n\nIn summary, the Composition API enables grouping of logics. In this way, we only see the codes related to that logic while performing operations on a logic. Also it will be much easier to separate a logic from a component or add a new logic. For example, when the user logic written with the Composition API in the code above is wanted to be moved to another place, it will be much easier to remove the relevant code from the component since the logic is already grouped.\n\nAs you can imagine, the advantages of the Composition API are not limited to these. There was a topic we mentioned at the beginning of the article. One of the most important principles of software development is to avoid repetitive work. The languages ​​and tools we use provide solutions to help us avoid repetitive work, and these solutions evolve and change throughout the process.\n\nNow, let’s take a look at what solutions we use to avoid repetitive works while developing with the Options API, and why these solutions are insufficient, with examples.\n\nFor example, when we want to use a function or code block that we use in a Component throughout the project, let’s look at how we do this with the Options API and what problems we encounter. Next, let’s look at how to solve these problems with the Composition API.\n\nThe first of these solutions is Utility Functions. In summary, Utility Functions are structures that can take parameters from outside and allow us to encapsulate small code blocks that we expect to return a value as a result. But their use is limited because we cannot define and use vue specific properties (reactive variables, mounted, created etc) inside these functions.\n\nWhen we examine the image above, you can see that the increment function is defined, but the count reactive variable cannot be defined in the function, so it is defined in the component. Here, utility functions are insufficient when we want to encapsulate the count variable or use other vue-specific properties.\n\nRenderless Components is a feature that doesn’t render any html and we can use vue specific properties. When we look at the example in the image above, we see an example of a code that shows the x and y coordinates of the mouse instantly, with a renderless component. Here we can see that we can use vue specific features.\n\nAnother method we can use to encapsulate complex code blocks is Mixins. We can say that it was an official way to share code between components, especially when developing with the Options API. Thanks to Mixins, we can encapsulate our business logics and use them in more than one place in our project.\n\nWe can learn about the use of mixins by looking at the code example in the image above. Looking at the example, we can see that we can use vue specific features inside mixins.\n\nAlthough Mixins seem like a very good solution, they can have serious disadvantages. Due to these disadvantages, the use of mixins is not recommended today. Let’s look at these disadvantages together.\n\nOne of these disadvantages is that when we use more than one mixin in a component, we cannot understand at first glance which feature comes from which mixin.\n\nAnother disadvantage is that there are reactive variables or methods with the same name in different mixins. When we use mixins with the same reactive variables or methods in the same component, conflicts will occur and the code will work incorrectly.\n\nMixins can be used with Vue 3 but are not recommended. There is now a much better way to encapsulate a code block that contains Vue features. Now let’s examine it together.\n\nThe most important feature of the Composition API is the Composables. With Composables, we can turn code blocks that contain reactivity into reusable modules. In this way, we can easily use a code in more than one place. However, it is not only for creating global code blocks, but also for separating multiple logic in a component and making the code more readable. Let’s go through the examples and examine the composables.\n\nFor example, let’s say we want to write a code that gives the instant coordinate information of the mouse. We have seen how we can do this with renderless components, now we can understand how we can do this with the Composition API by looking at the image below.\n\nLet’s imagine that we want to use the code developed with the Composition API above in more than one place in the project. The method we can use here is composables.\n\nWhen we turn the above code into a composable function, our code will be as follows. When we look at the example below, we can see that we can convert our code into a composable function by copy-pasting directly. One of the biggest advantages of the Composition API is that we can easily move our code to another location with almost no changes.\n\nIt is quite simple to use the useMouse composable function that we wrote above in any component. All we have to do is import and start using. In the image below, you can see how easily a composable function can be used.\n\nWhen we look at the examples of Composable functions, we can see that the disadvantages we experience with mixins are not experienced.\n• For example, when we use more than one mixin, it was difficult to understand which feature came from which mixin at first glance, but when we use the refs + destructure model, we can easily understand which feature comes from which Composable.\n• Another disadvantage of Mixins is Namespace collisions. We can avoid namespace collisions by renaming with destructure in Composables.\n• Another advantage is that the values ​​returned from Composable can be passed as arguments to one another, just like regular functions.\n\nWe can nest Composables. In this way, we can combine small logics to form larger ones. This is similar to how we use components while developing a web application. When developing a web application, we create larger components by combining small components. In this way, we can develop large web applications without repeating ourselves. We can do the same for our logics. This will allow us to avoid repetitive tasks and save time.\n\nLooking at the example below, we can see how we can nest composables.\n\nLooking at the example, we can see that we have created a separate composable for the event listener and can use it in another composable.\n\nWhile developing with the Composition API, we mentioned that we can separate our codes according to logics. For example, let’s say we want to write a composable function. The fact that this function we will write has a certain order in itself will increase the readability of the code. When we look at the example above, you can see that the variables are defined as a block in the code and the functions are written as a separate block. Writing Vue-specific (computed, wathers, etc.) features in separate blocks in a certain order will increase the readability of the code. As in the code example at the bottom of the image above, we can separate these blocks with comment lines.\n\nWe looked at code examples related to Composition API and Composables together. We’ve seen that Composables allow us to separate the logic in our code into functions that we can use over and over again. We mentioned that this also makes the code easier to write and read.\n\nNow let’s see how we can write our composables better together. While I was preparing for this subject, there were many sources that I examined, but among these sources, the article “Coding Better Composables” written by Michael Thiessen especially caught my attention. He summarized the subject very well with his way of handling the subject and simple examples. I would definitely recommend checking out the article series. Since this subject is explained very well in the article I mentioned, I would like to explain the subject with the examples there. Since we will proceed in this article without going into too much detail, I recommend that you review the relevant article for detailed information.\n\nWhile giving information about the subject, we will proceed with code examples again. This time we will use the VueUse library for code examples. VueUse library is an open source library with composables. In this library, we will examine how composables are written. In this way, we will understand what we should pay attention to when writing our own composables.\n\nMost Composables can have one or more parameters. Instead of passing many parameters to our function, we can pass them all as a single object. We can continue with the object destructure inside the function. It will be advantageous for us to pass parameters other than one or two parameters as objects.\n\nFirst, we don’t need to know the order of the parameters. Sorting doesn’t matter as long as we pass parameters as objects. In this way, we can prevent possible errors.\n\nSecondly, we can understand what the parameters we pass as objects do from the naming of the properties. This will make our code more readable.\n\nNow let’s look at an example on this subject together. We can see how this is done in the useTitle composable in the VueUse library. The useTitle composable is pretty simple. It allows us to set the title of the page.\n\nWhen we look at the example here, other parameters other than the title parameter are taken as options object. We can proceed in this way in the composables we have written.\n\nWe mentioned that Composables can take parameters. These parameters can be primitive javascript types (string, number) as well as reactive variables. In some cases we may want the parameter to be a reactive variable no matter what or a primitive type no matter what. Here, instead of specifically asking for a reactive variable or a primitive type as a parameter, we can accept both and then convert this parameter to the type we need.\n\nWhen we look at the above example, we can see that this operation can be done very easily with “ref” and “unref”. In this way, regardless of the type of the entered parameter, we can convert it to the type we want (reactive or primitive) and continue. In this way, we can easily avoid possible errors.\n\nNow let’s see how this can be done by going through the UseTitle example.\n\nWhen we look at the code above, we can see that whatever parameter is entered, it is made reactive.\n\nComposables can return a single value or an object containing multiple values. You can see both examples in the example above. useDark returns a single value, while useMouse returns an object. If we want, we can make the composable’s values ​​dynamic. We can return a single value or object according to the parameter entered from outside. We can do this very easily with a simple control. In the above example, when “controls: true” is entered, the object is returned, otherwise a single value is returned.\n\nThis pattern is often a good way to simplify our code. Now let’s see how this is done in the UseNow composable in the VueUse library.\n\nWhen we look at the example above, we can see that this operation is done with a simple if check.\n\nWe can use Composables not only to create global code blocks, but also for code organization. For example, as the logics increase in a component, it may become more difficult to read and understand the code. For such cases, we can create a separate composable for each logic and divide our code into small pieces. Also, we can pass a variable from one composable to another composable as a parameter. This will provide a significant advantage for code organization.\n\nIn this article, I first told you about the difficulties we had before the Composition API, with examples. With these examples, we have seen why we need the Composition API and how these problems are overcome with the Composition API. Afterwards, we examined how we can write our Composables better with examples from the article “Coding Better Composables” written by Michael Thiessen.\n\nHope what is explained will be useful to you :) You can watch my presentation on this topic below (For Turkish readers)."
    }
]