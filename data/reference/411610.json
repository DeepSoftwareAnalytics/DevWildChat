[
    {
        "link": "https://qthub.com/static/doc/qt5/qtcore/qsortfilterproxymodel.html",
        "document": "The QSortFilterProxyModel class provides support for sorting and filtering data passed between another model and a view. More...\n\nThis class was introduced in Qt 4.1.\n\nQSortFilterProxyModel can be used for sorting items, filtering out items, or both. The model transforms the structure of a source model by mapping the model indexes it supplies to new indexes, corresponding to different locations, for views to use. This approach allows a given source model to be restructured as far as views are concerned without requiring any transformations on the underlying data, and without duplicating the data in memory. Let's assume that we want to sort and filter the items provided by a custom model. The code to set up the model and the view, without sorting and filtering, would look like this: To add sorting and filtering support to , we need to create a QSortFilterProxyModel, call setSourceModel() with the as argument, and install the QSortFilterProxyModel on the view: At this point, neither sorting nor filtering is enabled; the original data is displayed in the view. Any changes made through the QSortFilterProxyModel are applied to the original model. The QSortFilterProxyModel acts as a wrapper for the original model. If you need to convert source QModelIndexes to sorted/filtered model indexes or vice versa, use mapToSource(), mapFromSource(), mapSelectionToSource(), and mapSelectionFromSource(). Note: By default, the model dynamically re-sorts and re-filters data whenever the original model changes. This behavior can be changed by setting the dynamicSortFilter property. The Basic Sort/Filter Model and Custom Sort/Filter Model examples illustrate how to use QSortFilterProxyModel to perform basic sorting and filtering and how to subclass it to implement custom behavior. QTableView and QTreeView have a sortingEnabled property that controls whether the user can sort the view by clicking the view's horizontal header. For example: When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order. Behind the scene, the view calls the sort() virtual function on the model to reorder the data in the model. To make your data sortable, you can either implement sort() in your model, or use a QSortFilterProxyModel to wrap your model -- QSortFilterProxyModel provides a generic sort() reimplementation that operates on the sortRole() (Qt::DisplayRole by default) of the items and that understands several data types, including , QString, and QDateTime. For hierarchical models, sorting is applied recursively to all child items. String comparisons are case sensitive by default; this can be changed by setting the sortCaseSensitivity property. Custom sorting behavior is achieved by subclassing QSortFilterProxyModel and reimplementing lessThan(), which is used to compare items. For example: An alternative approach to sorting is to disable sorting on the view and to impose a certain order to the user. This is done by explicitly calling sort() with the desired column and order as arguments on the QSortFilterProxyModel (or on the original model if it implements sort()). For example: QSortFilterProxyModel can be sorted by column -1, in which case it returns to the sort order of the underlying source model. In addition to sorting, QSortFilterProxyModel can be used to hide items that do not match a certain filter. The filter is specified using a QRegExp object and is applied to the filterRole() (Qt::DisplayRole by default) of each item, for a given column. The QRegExp object can be used to match a regular expression, a wildcard pattern, or a fixed string. For example: For hierarchical models, the filter is applied recursively to all children. If a parent item doesn't match the filter, none of its children will be shown. A common use case is to let the user specify the filter regular expression, wildcard pattern, or fixed string in a QLineEdit and to connect the textChanged() signal to setFilterRegularExpression(), setFilterWildcard(), or setFilterFixedString() to reapply the filter. Custom filtering behavior can be achieved by reimplementing the filterAcceptsRow() and filterAcceptsColumn() functions. For example (from the Custom Sort/Filter Model example), the following implementation ignores the filterKeyColumn property and performs filtering on columns 0, 1, and 2: If you are working with large amounts of filtering and have to invoke invalidateFilter() repeatedly, using beginResetModel() / endResetModel() may be more efficient, depending on the implementation of your model. However, beginResetModel() / endResetModel() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated. Since QAbstractProxyModel and its subclasses are derived from QAbstractItemModel, much of the same advice about subclassing normal models also applies to proxy models. In addition, it is worth noting that many of the default implementations of functions in this class are written so that they call the equivalent functions in the relevant source model. This simple proxying mechanism may need to be overridden for source models with more complex behavior; for example, if the source model provides a custom hasChildren() implementation, you should also provide one in the proxy model. Note: Some general guidelines for subclassing models are available in the Model Subclassing Reference. Note: With Qt 5, regular expression support has been improved through the QRegularExpression class. QSortFilterProxyModel dating back prior to that class creation, it originally supported only QRegExp. Since Qt 5.12, QRegularExpression APIs have been added. Therefore, QRegExp APIs should be considered deprecated and the QRegularExpression version should be used in place. Warning: Don't mix calls to the getters and setters of different regexp types as this will lead to unexpected results. For maximum compatibility, the original implementation has been kept. Therefore, if, for example, a call to setFilterRegularExpression is made followed by another one to setFilterFixedString, the first call will setup a QRegularExpression object to use as filter while the second will setup a QRegExp in FixedString mode. However, this is an implementation detail that might change in the future.\n\nSee also QAbstractProxyModel, QAbstractItemModel, Model/View Programming, Basic Sort/Filter Model Example, Custom Sort/Filter Model Example, and QIdentityProxyModel.\n\nThis property holds whether the proxy model is dynamically sorted and filtered whenever the contents of the source model change Note that you should not update the source model through the proxy model when dynamicSortFilter is true. For instance, if you set the proxy model on a QComboBox, then using functions that update the model, e.g., addItem(), will not work as expected. An alternative is to set dynamicSortFilter to false and call sort() after adding items to the QComboBox. The default value is true. This property was introduced in Qt 4.2. This property holds the case sensitivity of the QRegExp pattern used to filter the contents of the source model. By default, the filter is case sensitive. See also filterRegExp and sortCaseSensitivity. This property holds the column where the key used to filter the contents of the source model is read from. The default value is 0. If the value is -1, the keys will be read from all columns. This property holds the QRegExp used to filter the contents of the source model Setting this property overwrites the current filterCaseSensitivity. By default, the QRegExp is an empty string matching all contents. If no QRegExp or an empty string is set, everything in the source model will be accepted. See also filterCaseSensitivity, setFilterWildcard(), and setFilterFixedString(). This property holds the QRegularExpression used to filter the contents of the source model Setting this property overwrites the current filterCaseSensitivity. By default, the QRegularExpression is an empty string matching all contents. If no QRegularExpression or an empty string is set, everything in the source model will be accepted. This property was introduced in Qt 5.12. See also filterCaseSensitivity, setFilterWildcard(), and setFilterFixedString(). This property holds the item role that is used to query the source model's data when filtering items. The default value is Qt::DisplayRole. This property was introduced in Qt 4.2. This property holds the local aware setting used for comparing strings when sorting By default, sorting is not local aware. This property was introduced in Qt 4.3. See also sortCaseSensitivity and lessThan(). This property holds whether the filter to be applied recursively on children, and for any matching child, its parents will be visible as well. The default value is false. This property was introduced in Qt 5.10. This property holds the case sensitivity setting used for comparing strings when sorting This property was introduced in Qt 4.2. See also filterCaseSensitivity and lessThan(). This property holds the item role that is used to query the source model's data when sorting items. The default value is Qt::DisplayRole. This property was introduced in Qt 4.2.\n\nConstructs a sorting filter model with the given parent. This signal is emitted when the case sensitivity of the filter changes to filterCaseSensitivity. This function was introduced in Qt 5.15. This signal is emitted when the filter role changes to filterRole. This function was introduced in Qt 5.15. This function was introduced in Qt 4.3. This signal is emitted when the recursive filter setting is changed to recursiveFilteringEnabled. This function was introduced in Qt 5.15. Sets the fixed string used to filter the contents of the source model to the given pattern. See also setFilterCaseSensitivity(), setFilterRegExp(), setFilterWildcard(), and filterRegExp(). This is an overloaded function. Sets the regular expression used to filter the contents of the source model to pattern. See also setFilterCaseSensitivity(), setFilterWildcard(), setFilterFixedString(), and filterRegExp(). Sets the regular expression used to filter the contents of the source model to pattern. This method should be preferred for new code as it will use QRegularExpression internally. This function was introduced in Qt 5.12. See also setFilterCaseSensitivity(), setFilterWildcard(), setFilterFixedString(), and filterRegularExpression(). Sets the wildcard expression used to filter the contents of the source model to the given pattern. See also setFilterCaseSensitivity(), setFilterRegExp(), setFilterFixedString(), and filterRegExp(). This signal is emitted when the case sensitivity for sorting changes to sortCaseSensitivity. This function was introduced in Qt 5.15. This signal is emitted when the locale aware setting changes to sortLocaleAware. This function was introduced in Qt 5.15. This signal is emitted when the sort role changes to sortRole. This function was introduced in Qt 5.15. Returns if the item in the column indicated by the given source_column and source_parent should be included in the model; otherwise returns . Note: The default implementation always returns . You must reimplement this method to get the described behavior. See also filterAcceptsRow(), setFilterFixedString(), setFilterRegExp(), and setFilterWildcard(). Returns if the item in the row indicated by the given source_row and source_parent should be included in the model; otherwise returns false. The default implementation returns if the value held by the relevant item matches the filter string, wildcard string or regular expression. Note: By default, the Qt::DisplayRole is used to determine if the row should be accepted or not. This can be changed by setting the filterRole property. See also filterAcceptsColumn(), setFilterFixedString(), setFilterRegExp(), and setFilterWildcard(). This function should be called if you are implementing custom filtering (e.g. filterAcceptsRow()), and your filter parameters have changed. This function was introduced in Qt 4.3. Returns if the value of the item referred to by the given index source_left is less than the value of the item referred to by the given index source_right, otherwise returns . This function is used as the < operator when sorting, and handles the following QVariant types: Any other type will be converted to a QString using QVariant::toString(). Comparison of QStrings is case sensitive by default; this can be changed using the sortCaseSensitivity property. By default, the Qt::DisplayRole associated with the QModelIndexes is used for comparisons. This can be changed by setting the sortRole property. Note: The indices passed in correspond to the source model. See also sortRole, sortCaseSensitivity, and dynamicSortFilter. Returns the model index in the QSortFilterProxyModel given the sourceIndex from the source model. Returns the source model index corresponding to the given proxyIndex from the sorting filter model. the column currently used for sorting This returns the most recently used sort column. This function was introduced in Qt 4.5. the order currently used for sorting This returns the most recently used sort order. This function was introduced in Qt 4.5."
    },
    {
        "link": "https://forum.qt.io/topic/147025/forcing-proxy-model-to-update",
        "document": "@JonB yeah, I noticed that, too. I'm going to play with it, though, to see if I can get something to happen.\n\nI'm fairly sure I've got the signaling to QML working correctly, because without the filter, my model date is appropriately updated in the UI. So, it must be something in the proxy model I'm missing.\n\nBTW: I see that QAbstractProxyModel has a sourceModel property. I'd like to use this, but I'm not familiar with using properties within C++. Do you happen to know how I'd go about accessing this from my proxy model?\n\n EDIT: I guess I can access it through Q_PROPERTY, just as I would with QML.\n\n EDIT 2: It turns out that the Q_PROPERTY didn't really bring anything to the party; you can't use it until you set it, and you can't set it until you know what it is. I'm just passing in the source model to the c'tor of the proxy model -- seems to work fine."
    },
    {
        "link": "https://doc.qt.io/qt-5/sourcebreaks.html",
        "document": "Qt 5 introduces some source incompatible changes. Here we list some important ones, but you can find more complete lists in .\n\nThe following sections list the API changes in each module and provide recommendations for handling those changes.\n• QLibrary::resolve() now returns a function pointer instead of pointer.\n• and the corresponding macro are removed. You must remove all references to this function and macro, as build key is not necessary now.\n• The QTranslator::translate() function signature is changed to set the default value of to -1. We recommend you to update the implementation of this virtual function in your sources.\n• is removed. In Qt 4, QString::contains(), QByteArray::contains(), and QList::contains() returned an internal type so that the Qt3 code would not compile anymore. If your code uses , replace it with .\n• The implicit conversion operator is removed. Use the QUuid::toString() function instead.\n• QProcess::ForwardedChannels no longer forwards the output to the GUI applications on the Windows platform, unless those applications create a console.\n• is not public anymore. Use QLocale instead.\n• Default value of the QSortFilterProxyModel::dynamicSortFilter property is changed to .\n• is removed as all the text codecs are part of Qt Core now.\n• , , , and are no longer public. We recommend you to avoid using these classes as there is no compatibility promise.\n• qDebug(), qWarning(), qCritical(), and qFatal() are changed to macros now to track the origin of the message in source code. The information to be printed can be configured (for the default message handler) by setting the new environment variable. qInstallMsgHandler() is deprecated, so we recommend using qInstallMessageHandler() instead.\n• QPointer is changed to use QWeakPointer. The old guard mechanism has been removed, which causes a slight change in behavior when using QPointer. In earlier Qt versions, if a QPointer is used on a QWidget (or a subclass of QWidget), the QPointer was cleared by the QWidget destructor. In Qt 5, the QPointer is cleared by the QObject destructor along with the QWeakPointers. Any QPointer tracking a widget is not cleared before the QWidget destructor destroys the children for the widget being tracked.\n• Qt::WFlags is deprecated, use Qt::WindowFlags instead. This typedef dates from the Qt 1 days, and such abbreviations are not current Qt style.\n• Qt::HANDLE typedef is now defined as on all platforms.\n• The non-atomic convenience methods of QAtomicInt and QAtomicPointer (that is, , , , , , , and ) have been removed as they performed implicit loads and stores of unspecified memory ordering. Code dealing with loading and storing is expected to use , , , and , instead.\n• The return type of matches the enum's underlying type (signed or unsigned) instead of always being . This allows QFlags over enums of the unsigned type (for example, Qt::MouseButton).\n• Because of major changes in the behavior of QTextBoundaryFinder::boundaryReasons(), the and enum values were replaced with the and values to enforce revision of the affected code.\n• A number of functions in <QtAlgorithms> are deprecated. Use the implementations available in the STL, as described in Porting Guidelines.\n• and in Qt containers are deprecated and will be removed in Qt 6. You should not use them in new applications. If you used them in existing applications, even though they are not documented, you should port away from them.\n\nThe Softkeys API is removed, so the following functions and enums are removed:\n• is removed. The QChar::Other_NotAssigned enum value is returned for unassigned codepoints now.\n• QChar::Joining and QChar::joining() are deprecated. Use the QChar::JoiningType enum and QChar::joiningType() function instead.\n• QCoreApplication::translate() no longer returns the source text if the translation is empty. Use the Qt Linguist Release tool ( ) instead for optimization.\n• and are replaced with QCoreApplication::installNativeEventFilter() and QCoreApplication::removeNativeEventFilter() for an API much closer to QEvent filtering. Note: The native events that can be filtered this way depend on the QPA backend chosen at runtime. On X11, XEvents are replaced with due to the switch to XCB, which requires porting the application code to XCB as well.\n• and are removed. These Qt 3 legacy application types did not match the application types available in Qt 5. Use instead to dynamically find out the exact application type.\n• QEvent::TouchCancel is introduced to use it on systems where it makes sense to differentiate between a regular QEvent::TouchEnd and abrupt touch sequence cancellations caused by the compositor. For example, when a swype gesture is recognized.\n• QFile::encodeName() and QFile::decodeName() are now hard-coded to operate on QString::fromLocal8Bit() and QString::toLocal8Bit() only. The old behavior is still possible using QTextCodec::setCodecForLocale(), but the new code should not make assumptions about the file system encoding and older code should remove such assumptions.\n• QMetaType now records whether the type argument inherits QObject. Such information can be useful for scripting APIs, so that custom QObject subclasses are treated as QObject pointers. For example, in Qt Script this means QScriptValue::isQObject() can be , where it was before.\n• is removed. Use qMetaTypeId<QWidget*>() or QVariant::canConvert<QWidget*>() instead.\n• now requires to be fully defined. This means, and also need to be fully defined. In cases where a forward declared type is needed as a meta-type, use .\n• is renamed as QMetaMethod::methodSignature(), and the return type is changed to QByteArray. This change is to enable generating the signature string on demand, rather than storing it in the meta-data.\n• QMetaMethod::typeName() no longer returns an empty string if the return type is , instead it returns . The recommended way of checking whether a method returns is to compare the return value of QMetaMethod::returnType() with QMetaType::Void.\n• QObject::connectNotify() and QObject::disconnectNotify() now need a QMetaMethod argument that identifies the signal, rather than a pointer.\n• QObject::trUtf8() and are deprecated. Qt assumes that the source code is encoded in UTF-8.\n• The QVariant constructor which takes Qt::GlobalColor argument is removed. Code constructing such variants must explicitly call QColor constructor now. For example, instead of , use to create a QVariant instance.\n• Implicit creation of QVariant objects from the enum values Qt::BrushStyle, Qt::PenStyle, and Qt::CursorShape has been removed. Create objects explicitly or use to create a QVariant of type with the same value as the enum.\n• The signature for the pure-virtual function is changed. All subclasses of QAbstractEventDispatcher must re-implement the function with this new signature:\n• QAbstractEventDispatcher::TimerInfo is no longer a of . It is now a with 3 members: , , and . Update the QAbstractEventDispatcher::registeredTimers() function with this change.\n• The function is removed. Use QDir::toNativeSeparators() instead.\n• The enum value is removed. Use QDir::NoDot or QDir::NoDotDot instead.\n• The QLocale data has been updated to CLDR 22.1. The historical language and country names were updated to their modern values and some deprecated names were dropped or mapped to their modern alternatives.\n• The QLocale::toShort(), QLocale::toUShort(), QLocale::toInt(), QLocale::toUInt(), QLocale::toLongLong(), and QLocale::toULongLong() functions no longer take the argument for base. They localize base 10 conversions. To convert other bases, use the QString functions instead.\n• QAbstractItemModel::beginMoveRows() no longer emits the signal, and QAbstractItemModel::endMoveRows() no longer emits the signal. All proxy models must connect to (and disconnect from) the QAbstractItemModel::rowsAboutToBeMoved and QAbstractItemModel::rowsMoved signals.\n• QAbstractItemModel::sibling() is virtual now to allow implementations to optimize based on internal data.\n• QAbstractItemModel::createIndex() method now only provides the and overloads, making calls with a literal ( ) ambiguous. Either cast or omit the third argument to get the overload.\n• QAbstractItemModel::setRoleNames() is deprecated. Use QAbstractItemModel::roleNames() instead. QAbstractItemModel::roleNames() is virtual now to allow a consistent API with the rest of QAbstractItemModel. Reimplementing the virtual methods to provide the elements is preferred to setting those directly.\n• QString and QByteArray constructors now use a negative size to indicate that the string passed is null-terminated (a null-terminated array of QChar, in the case of QString). In Qt 4, negative sizes were ignored, which resulted in empty QString and QByteArray. The size argument now has a default value of , replacing the separate constructors that did the same.\n• QString::mid(), QString::midRef(), and QByteArray::mid() now return an empty , , and respectively, if the position passed is equal to the length (that is, right after the last character or byte). In Qt 4, they returned a null or a null .\n• The following QString functions use the C locale instead of the default or system locale: This is to guarantee consistent default conversion of strings. For locale-aware conversions use the equivalent QLocale functions.\n• QDate only implements the Gregorian calendar, and the switch to the Julian calendar before 1582 has been removed. This means all QDate functions return different results for dates prior to 15 October 1582, and there is no longer a gap between 4 October 1582 and 15 October 1582.\n• QDate::setYMD() is deprecated, use QDate::setDate() instead.\n• Adding days to a null QDate or seconds to a null QTime will no longer return a valid QDate/QTime.\n• The QDate::addDays() and QDateTime::addDays() functions now take a argument, and the QDate::daysTo() and QDateTime::daysTo() functions now return a value.\n• QDate and QTime are the for the QTimeEdit and QDateEdit classes, insted of QDateTime as it was for the 4.7 and 4.8 releases. The USER property for these classes was removed before Qt 4.7.0 and added again in Qt 5.0.\n• The serialization behavior for QDateTime is reverted to pre-Qt 5, because Qt::LocalTime is the local time (that is, ) regardless of the underlying system time, time zone, or changes in the system zone. Therefore, the consistent behavior when serialising is to save and restore as the local time and not its UTC equivalent. This means that the QDataStream version is 14 since Qt 5.1.\n• The supported date range in QDateTime has been reduced to about +/- 292 million years, the range supported by the number of msecs since the Unix epoch of 1 Jan 1970 as stored in a , and as able to be used in QDateTime::setMSecsSinceEpoch() and QDateTime::toMSecsSinceEpoch().\n• QDate::fromString() and QDateTime::fromString() require non-numeric date component separators when parsing Qt::ISODate. A string like 2000901901 will no longer be recognized as a valid ISO date, whereas 2000/01/01 will, even though it differs from the ISO format 2000-01-01.\n• and are removed as they were creating uncertainty/bugs in using QString easily and (to a lesser extent) performance issues.\n\nQUrl changed considerably in Qt 5 to comply better with the URL specifications and with brokenness out there. The following list summarizes the most important functional changes:\n• QUrl::setPath() no longer handles relative paths. They are by definition invalid. Use the QUrl::NormalizePathSegments flag to remove /./ or /../ sequences as much as possible. It will not remove /../ from the beginning of the path.\n• QUrl has been changed to operate only on percent-encoded forms. Fully-decoded forms where the percent character stands for itself, can no longer be encoded, as the getters and setters with encoded in the name are deprecated (except QUrl::toEncoded() and QUrl::fromEncoded()). The most notable difference with this change is when dealing with QUrl::toString(). In earlier Qt versions, this function would return percent characters in the URL, but now it returns %25 like QUrl::toEncoded() does.\n• QUrl no longer decodes %7B and %7D to \"{\" and \"}\" in the output of QUrl::toString().\n• QUrl now defaults to decoded mode in the getters and setters for , , , , and . This means a % in one of those fields is now returned (or set) as rather than . If the former behavior was expected, pass to the getter and to the setter.\n• QUrl no longer has functions that handle individual query items and query delimiters, such as and . These have been moved to the new QUrlQuery class.\n• QUrl no longer considers all delimiter characters equivalent to their percent-encoded forms. QUrl and QUrlQuery always keep all delimiters exactly as they were in the original URL text.\n• QUrl no longer supports QUrl::FullyDecoded mode in QUrl::authority() and QUrl::userInfo(), nor QUrl::DecodedMode in QUrl::setAuthority() and QUrl::setUserInfo().\n• QUrl no longer decodes %23 found in the fragment to \"#\" in the output of QUrl::toString ( ) or QUrl::toEncoded().\n\nQt Concurrent has been moved from Qt Core to its own module. To link against the Qt Core module, add this line to the project file:\n• QPen now has a default width of 1 instead of 0. Thus, it is no longer cosmetic by default.\n• QAccessibleActionInterface is now based on providing a list of action names. All functions have been changed to take arguments of type insted of .\n• The constructor of QAccessibleEvent does not need the parameter anymore, and the corresponding function is removed.\n• The constructor of QTabletEvent does not need the argument anymore, as all coordinates are floating point-based now.\n• is now merged into QIconEngine. Update your sources to use instead of .\n• QSound is moved to Qt Multimedia from Qt GUI.\n• and are replaced by QStandardPaths::writableLocation() and QStandardPaths::displayName() respectively. They are now in the Qt Core module. Make sure to read the QDesktopServices::storageLocation() documentation when porting from QDesktopServices::DataLocation.\n• and are removed. Use QScreen::grabWindow() instead.\n• The session management API has been simplified. The function is removed and replaced by the signal QGuiApplication::commitDataRequest(). QApplication and QGuiApplication will emit this signal from 5.2 onward on supported platforms (Linux and Windows).\n• is replaced with to avoid QWidget dependencies.\n• The child integer parameters are removed to bring QAccessibleInterface closer to IAccessible2. This means that the following functions lose the integer parameter:\n• is replaced with parent() and child() to navigate the hierarchy.\n• , , and are removed. We recommend using the QAccessibleInterface subclasses to implement the QAccessibleActionInterface instead.\n• QImage::fill() on an image with format now expects image data in RGB layout as opposed to BGR layout. This is to ensure consistency with RGB32 and other 32-bit formats.\n• The behavior of QImage::load(), QImage::loadFromData(), QPixmap::load(), and QPixmap::loadFromData() on a non-null image changed so that if the functions fail to load the image (return ), the the existent image data is invalidated, so that is guaranteed to return in this case.\n• QPainter does not support uniting clipped regions anymore. Use QRegion::united() instead to unite clips and pass the result to QPainter.\n• QPainter fill rules when not using antialiased painting have changed so that the aliased and antialiased coordinate systems match. There used to be an offset of slightly less than half a pixel when doing sub-pixel rendering, in order to be consistent with the old X11 paint engine. The new behavior should be more predictable and give the same consistent rounding for images and pixmaps as for paths and rectangle filling. To get the old behavior, set the QPainter::Qt4CompatiblePainting render hint.\n• and are deprecated as QTouchDevice provides a better way to identify and access the device from which the events originate.\n• The constructor now takes a QTouchDevice pointer instead of value.\n• and are removed from the Qt::TouchPointStates enum.\n• QItemEditorFactory::createEditor() and QItemEditorFactory::valuePropertyName() signatures are changed to take arguments of type instead of QVariant::Type.\n• is removed as related getter and setter functions in QWidget and QApplication are removed. Input contexts are now platform-specific.\n• QInputDialog::getInteger() is deprecated. Use QInputDialog::getInt() instead.\n• The classes are removed, and their members are merged with the respective base classes. The removed classes are left as typedefs for binary compatibility.\n• QGraphicsItem and its derived classes can no longer pass a QGraphicsScene to the item's constructor. Construct the item without a scene and call QGraphicsScene::addItem() to add the item to the scene.\n• is removed. Use QAbstractProxyModel and the related classes instead. A copy of is available in the Ui Helpers repository.\n• is removed, because the introduction of QPA made it redundant.\n• and virtual methods that were used for session management are removed. Connect to the QApplication::commitDataRequest and QApplication::saveStateRequest signals instead. Use QApplication::isSavingSession() if the QWidget::closeEvent if your window needs to know whether it is being called during shutdown.\n• and are removed, and the QStyle::standardIcon() and QStyle::layoutSpacing() functions are made pure virtual now. The removed functions were introduced in Qt 4 for binary compatibility reasons.\n• , , , and are replaced with a new fusion style. If your application depends on any of these removed styles, you can either use the qtstyleplugins project to get these styles or update your application to use the new fusion style. For more details about this change, see https://blog.qt.io/blog/2012/10/30/cleaning-up-styles-in-qt5-and-adding-fusion/.\n• The following QStyle implementations have been made internal: Instead of creating instances or inheriting these classes directly, use:\n\nThe following functions are deprecated:\n• The derived classes now emit the signal on the left mouse click only, instead of all mouse clicks.\n• The virtual QAbstractItemView::dataChanged() function signature now includes the roles that have changed. The signature is consistent with the signal in the model.\n• QColorDialog::customColor() now returns a QColor value instead of .\n• QColorDialog::setCustomColor() and QColorDialog::setStandardColor() now need a QColor value as their second parameter instead of .\n• The WebKit module in Qt is now split in two modules, and , in order to allow the dependency of the module to be optional. The benefits will only be available once the QQuickWebView API is made public through C++ in a future version. The module adds the module automatically to the project, so in your application's project file, should now be modified to:\n• The same applies to the module include, should be modified to:\n• A consequence of the module split is that classes of the Qt WebKit API aren't all in the new module, so for a better compatibility of your application with both Qt4 and Qt5, #include <QtWebKit/QWebPage>, for example, should be included directly as: The include path will take care of selecting the right module.\n• The qwebkitversion.h header has been renamed to qtwebkitversion.h to match other Qt modules, and part of its contents has been moved to qwebkitglobal.h. should be replaced with two includes:\n• The enum and the corresponding set and get functions, and are removed.\n• Support for printing PostScript files has been removed.\n• The class is removed. Use QPrintDialog instead.\n• The QPrintEngine::PrintEnginePropertyKey enum value is removed.\n• QPrinter no longer allows you to set an invalid printer name.\n• The enum value is renamed as QSsl::TlsV1_0.\n• The , , , and classes are removed. Use QNetworkAccessManager instead.\n• The and classes are no longer exported. Use QNetworkAccessManager instead. Programs that require raw FTP or HTTP streams can use the Qt FTP and Qt HTTP compatibility add-on modules that provide the and classes as they existed in Qt 4.\n• QAbstractSocket::connectToHost() and QAbstractSocket::disconnectFromHost() are virtual now, and and are removed.\n• QTcpServer::incomingConnection() now takes arguments of type instead of an .\n• is removed. Use the bearerTypeName() instead.\n• QSslCertificate::subjectInfo() and QSslCertificate::issuerInfo() now return QStringList instead of a QString. This change makes searching the required information a lot easier than scanning a long string.\n• QSslCertificate::isValid() is deprecated. Use QSslCertificate::isBlacklisted() instead to avoid binary breaks in the future.\n• QSslCertificate::alternateSubjectNames() is deprecated. Use QSslCertificate::subjectAlternativeNames() instead.\n• QSqlQueryModel::setQuery() emits fewer signals. The and signals are sufficient to inform views that they must re-interrogate the model.\n• QSqlDriver::subscribeToNotification(), QSqlDriver::unsubscribeFromNotification(), QSqlDriver::subscribedToNotifications(), QSqlDriver::isIdentifierEscaped(), and QSqlDriver::stripDelimiters() are virtual now. The corresponding functions are also removed as the subclasses of QSqlDriver can re-implement those directly.\n• QSqlError now handles alphanumeric error codes that are used by QPSQL. The numeric codes are deprecated.\n• The plain-text, XML and lightxml test output formats are updated to include test result for every row of test data in data-driven tests. In Qt4, only fails and skips were included for individual data rows without the passes information. This limitation prevented accurate test run and pass rates calculation.\n• The and macros are now part of . These macros were part of earlier, but now they are part of the <QtTest/QtTest> header. In addition, and are provided to specify custom timeout values.\n• The macro is removed. If a test appears to be inapplicable for a particular build at compile-time, it should be omitted either using the .pro file logic or call in the method to skip the entire test. If you're using the later approach, report a meaningful explanation in the test log.\n• The macro is removed as it misled some users to believe that they could make test functions depend on each other or impose an execution order on test functions.\n• is removed. This was an internal test library function that was exposed in the public API due to its use in a public macro. Any calls to this function must be replaced with QByteArray::qsnprintf().\n• c{QTest::pixmapsAreEqual()} is removed. Comparison of QPixmap objects must be done using the macro, which provides more informative output in the event of a failure.\n• The parameter in macro is removed. This parameter caused problems in test metrics calculation because of the mode, which hid information about the skipped test data. Calling in a test function now behaves like , which is skipping a non-data-driven test function or skipping only the current data row of a data-driven test function. Every skipped data row is now reported in the test log.\n• has been replaced by overloading. Code such as no longer uses the QString-specific implementation and may fail to compile. We recommend that you replace specialization with overloading. Also, rather than pass explicit template arguments to , let the overload resolution pick the correct one, and cast arguments in case of ambiguous overloads (for example, ). The resulting code will continue to work against older QtTestlib versions.\n\nApart from the QGLWidget class, the Qt OpenGL module should not be used for new code. Instead, use the corresponding OpenGL classes in Qt GUI.\n• QGLPixelBuffer is deprecated and implemented by using a hidden QGLWidget and a QOpenGLFramebufferObject. For offscreen rendering to a texture, switch to using QOpenGLFramebufferObject directly to improve performance.\n• The default major version of QGLFormat is changed to 2 to align it with QSurfaceFormat. Applications that want to use a different version, should explicitly request it using QGLFormat::setVersion().\n• The parameter is removed from QGLWidget::renderText() functions.\n• To ensure support on more platforms, stricter requirements have been introduced for doing threaded . First, you must call QGLWidget::makeCurrent() at least once per each QGLWidget::swapBuffers() call, so that the platform has a chance to synchronize resizing the surface. Second, before calling QGLWidget::makeCurrent() or QGLWidget::swapBuffers() in a separate thread, you must call QGLContext::moveToThread() to explicitly let Qt know in which thread a QGLContext is currently being used. You also need to make sure that the context is not current in the current thread before moving it to a different thread.\n• is removed. Use QSysInfo::macVersion() or QSysInfo::MacintoshVersion instead.\n• is deprecated. Use QString::toHtmlEscaped() instead.\n• is removed, becauses it is irrelevant for multi-threaded applications. There is no replacement for this function.\n• The file is removed. Use and other flags instead.\n• The configure argument is removed. DWARF2 is always used on macOS now.\n• Configure no longer calls by default, because the subsequent build invokes qmake as needed. Use to restore the old behavior.\n• The lupdate variable is deprecated, because source code written with Qt 5 is expected to use UTF-8 encoding.\n• New Classes and Functions in Qt 5.5\n• New Classes and Functions in Qt 5.4\n• New Classes and Functions in Qt 5.3\n• New Classes and Functions in Qt 5.2\n• New Classes and Functions in Qt 5.1"
    },
    {
        "link": "https://qtcentre.org/threads/55962-Updating-a-view-s-proxy-model-when-the-source-model-changes",
        "document": "\n• Re: Updating a view's proxy model when the source model changes The problem I'm encountering is related to drag and drop operations. After I perform a drag and drop (reordering list items), I've had trouble updating the views. The problem I'm encountering is related to drag and drop operations. After I perform a drag and drop (reordering list items), I've had trouble updating the views. What do you mean by reordering?\n\n If it is just inserting row(s), are you using beginInsertRows() and endInsertRows()?\n\n If it is complete reordering, are you using beginModelReset() and endResetModel()? When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes Can you show the rowCount()? Is it based on anything other than mFiles.size()? When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes Add this\n\n To copy to clipboard, switch view to plain text mode \n\n also do the corresponding changes in parent() and index() When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes What is you model based on QAbstractItemModel/QAbstractTableModel/QStandardItemModel? When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes Ok, Can you post a minimal working code which illustrates the problem? When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes It is only a matter of emitting proper dataChanged() signals. Take a closer look at all the dataChanged() signals in my code and try to understand why they are emitted.\n\n \n\n Hint: When a master is selected (using the combo box), you will have to emit dataChaged() for the master and all the slaves which have the selected item as master. The second emit was missing in your code. When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right.\n• Re: Updating a view's proxy model when the source model changes Presumably, this would be the item which is dragged / dropped to a different position, as well as the items between the two positions? Presumably, this would be the item which is dragged / dropped to a different position, as well as the items between the two positions? dataChanged not required in this case. it just row insert and and row remove.\n\n \n\n Hint: When a master is selected (using the combo box), you will have to emit dataChaged() for the master and all the slaves which have the selected item as master. The second emit was missing in your code. Did you understand the hint? When you know how to do it then you may do it wrong. \n\n When you don't know how to do it then it is not that you may do it wrong but you may not do it right."
    },
    {
        "link": "https://qthub.com/static/doc/qt5/qtwidgets/qtwidgets-itemviews-customsortfiltermodel-example.html",
        "document": "The Custom Sort/Filter Model example illustrates how to subclass QSortFilterProxyModel to perform advanced sorting and filtering.\n\nThe QSortFilterProxyModel class provides support for sorting and filtering data passed between another model and a view.\n\nThe model transforms the structure of a source model by mapping the model indexes it supplies to new indexes, corresponding to different locations, for views to use. This approach allows a given source model to be restructured as far as views are concerned, without requiring any transformations on the underlying data and without duplicating the data in memory.\n\nThe Custom Sort/Filter Model example consists of two classes:\n• The class provides the main application window, using the custom proxy model to sort and filter a standard item model.\n\nWe will first take a look at the class to see how the custom proxy model is implemented, then we will take a look at the class to see how the model is used. Finally we will take a quick look at the function.\n\nSince QAbstractProxyModel and its subclasses are derived from QAbstractItemModel, much of the same advice about subclassing normal models also applies to proxy models.\n\nOn the other hand, it is worth noting that many of QSortFilterProxyModel's default implementations of functions are written so that they call the equivalent functions in the relevant source model. This simple proxying mechanism may need to be overridden for source models with more complex behavior. In this example we derive from the QSortFilterProxyModel class to ensure that our filter can recognize a valid range of dates, and to control the sorting behavior.\n\nWe want to be able to filter our data by specifying a given period of time. For that reason, we implement the custom and functions as well as the corresponding and functions. We reimplement QSortFilterProxyModel's filterAcceptsRow() function to only accept rows with valid dates, and QSortFilterProxyModel::lessThan() to be able to sort the senders by their email addresses. Finally, we implement a convenience function that we will use to determine if a date is valid.\n\nThe constructor is trivial, passing the parent parameter on to the base class constructor:\n\nThe most interesting parts of the implementation are the reimplementations of QSortFilterProxyModel's filterAcceptsRow() and lessThan() functions. Let's first take a look at our customized function.\n\nWe want to sort the senders by their email addresses. The lessThan() function is used as the < operator when sorting. The default implementation handles a collection of types including QDateTime and String, but in order to be able to sort the senders by their email addresses we must first identify the address within the given string:\n\nWe use QRegularExpression to define a pattern for the addresses we are looking for. The match() function returns a QRegularExpressionMatch object which contains the result of the matching. If there is a match, hasMatch() returns true. The result of the match can be retrieved with QRegularExpressionMatch's captured() function. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).\n\nThe filterAcceptsRow() function, on the other hand, is expected to return true if the given row should be included in the model. In our example, a row is accepted if either the subject or the sender contains the given regular expression, and the date is valid.\n\nWe use our custom function to determine if a date is valid.\n\nTo be able to filter our data by specifying a given period of time, we also implement functions for getting and setting the minimum and maximum dates:\n\nThe get functions, and , are trivial and implemented as inline function in the header file.\n\nThis completes our custom proxy model. Let's see how we can use it in an application.\n\nThe class inherits QWidget, and provides this example's main application window:\n\nWe implement two private slots, and , to respond to the user changing the filter pattern, case sensitivity, or any of the dates. In addition, we implement a public convenience function to set up the model/ view relation.\n\nIn this example, we have chosen to create and set the source model in the () function (which we will come back to later). So when constructing the main application window, we assume that a source model already exists and start by creating an instance of our custom proxy model:\n\nWe set the dynamicSortFilter property that holds whether the proxy model is dynamically sorted and filtered. By setting this property to true, we ensure that the model is sorted and filtered whenever the contents of the source model change.\n\nThe main application window shows views of both the source model and the proxy model. The source view is quite simple:\n\nThe QTreeView class provides a default model/view implementation of a tree view. Our view implements a tree representation of items in the application's source model.\n\nThe QTreeView class provides a default model/view implementation of a tree view; our view implements a tree representation of items in the application's source model. We add our view widget to a layout that we install on a corresponding group box.\n\nThe proxy model view, on the other hand, contains several widgets controlling the various aspects of transforming the source model's data structure:\n\nNote that whenever the user changes one of the filtering options, we must explicitly reapply the filter. This is done by connecting the various editors to functions that update the proxy model.\n\nThe sorting will be handled by the view. All we have to do is to enable sorting for our proxy view by setting the QTreeView::sortingEnabled property (which is false by default). Then we add all the filtering widgets and the proxy view to a layout that we install on a corresponding group box.\n\nFinally, after putting our two group boxes into another layout that we install on our main application widget, we customize the application window.\n\nAs mentioned above, we create the source model in the () function, calling the function to make the application use it:\n\nThe QSortFilterProxyModel::setSourceModel() function makes the proxy model process the data in the given model, in this case out mail model. The setModel() that the view widget inherits from the QAbstractItemModel class, sets the model for the view to present. Note that the latter function will also create and set a new selection model.\n\nThe function is called whenever the user changes the filter pattern or the case sensitivity.\n\nWe first retrieve the preferred syntax (the QRegExp::PatternSyntax enum is used to interpret the meaning of the given pattern), then we determine the preferred case sensitivity. Based on these preferences and the current filter pattern, we set the proxy model's filterRegExp property. The filterRegExp property holds the regular expression used to filter the contents of the source model. Note that calling QSortFilterProxyModel's setFilterRegExp() function also updates the model.\n\nThe function is called whenever the user modifies the range of valid dates. We retrieve the new dates from the user interface, and call the corresponding functions (provided by our custom proxy model) to set the proxy model's minimum and maximum dates. As we explained above, calling these functions also updates the model.\n\nIn this example, we have separated the application from the source model by creating the model in the () function. First we create the application, then we create the source model:\n\nThe function is a convenience function provided to simplify the constructor. All it does is to create and return a model describing a collection of emails. The model is an instance of the QStandardItemModel class, i.e., a generic model for storing custom data typically used as a repository for standard Qt data types. Each mail description is added to the model using , another convenience function. See for details."
    },
    {
        "link": "https://stackoverflow.com/questions/38343839/qsortfilterproxymodel-how-to-handle-qstandarditems-correctly",
        "document": "I have QTreeView with some items and search QLineEdit with connected slot on textEdited signal. With this code:\n\ntext filtering is ok, but when I clicked on QTreeView QStandardItems checkboxes (after proxy model assigned to QTreeView), I have the program crashes in slot, that connected to this QTreeView original model (before proxy was assigned). What is the right way to processing item checkbox clicks? Need I use new connect/slot to processing model changes, or I can use the same code for original model with some changes? I just need to hide filtered items in QTreeView. In QTreeWidget is hide() method, does QTreeView has something like this, or QSortFilterProxyModel - is what I need? Thx!\n\nbecause I set proxyModel to treeView, but messagesModel have whatsThis..."
    },
    {
        "link": "https://forum.qt.io/topic/135617/how-to-update-a-large-model-efficiently",
        "document": "@ozcanay\n\n Not sure I have any answers, but a couple of comments.\n\nAll in memory? That's quite a lot! Just saying.... Do you have any database/backing store for the model, or is it temporary, in-memory only?\n\nFor the record, while the final object access once located is O(1) the imposes O(log(n)) (binary search).\n\nI assume you do insert/delete rows, so that normal es may change? I have not used it, but is this a case for QPersistentModelIndex Class:\n\n? If this means that once an item is assigned a that never changes and remains valid, you might maintain a map of (or possibly store the in the ) so that you can fetch the index immediately. From that you should be able to construct a for from / . That is all I know, you would have to verify/read up to see if it works for your situation.\n\nAnother possibility would be to maintain a wrapper around your underlying model. If you sort that by you should be able to look up in O(log(n)), hopefully. I do not see a \"find by sorted key value\" method on , but presumably you can do a binary search on its row numbers to locate a key, and then for the index into the underlying model.\n\nYou can access/update the model in a different thread from the UI thread. However, then I think the model needs to live in that thread and operations on it should be performed in that thread. I am then hazy on the consequences of having e.g. a view in the UI thread which wants to access from that other thread. Someone may be more knowledgeable than I on this."
    },
    {
        "link": "https://forum.qt.io/topic/147025/forcing-proxy-model-to-update",
        "document": "@JonB yeah, I noticed that, too. I'm going to play with it, though, to see if I can get something to happen.\n\nI'm fairly sure I've got the signaling to QML working correctly, because without the filter, my model date is appropriately updated in the UI. So, it must be something in the proxy model I'm missing.\n\nBTW: I see that QAbstractProxyModel has a sourceModel property. I'd like to use this, but I'm not familiar with using properties within C++. Do you happen to know how I'd go about accessing this from my proxy model?\n\n EDIT: I guess I can access it through Q_PROPERTY, just as I would with QML.\n\n EDIT 2: It turns out that the Q_PROPERTY didn't really bring anything to the party; you can't use it until you set it, and you can't set it until you know what it is. I'm just passing in the source model to the c'tor of the proxy model -- seems to work fine."
    },
    {
        "link": "https://stackoverflow.com/questions/29824591/qsortfilterproxymodel-filtering-complete-signal",
        "document": "from my observations (in Qt 4.8), the signals will fire when sorting the proxy model, but not if you implement filtering. also the docs explicitly refer to the order of items that are meant by these signals, and filtering naturally doesn't change the order but affects rows only.\n\nin this case only the signals (inserted, removed, etc.) will fire, depending on what the filter just did. the downside is, if the filter is applied recursively (usually it is), these signals will fire in masses, so will not be useful to tie to a single resulting action.\n\nto overcome this you could call invalidate() after setting filters (not invalidateFilter btw, since it also won't fire the layout signals).\n\nsince this re-applies filtering and sorting (the latter wouldn't be necessary when filtering, but can't be avoided), the signals will fire after both did end.\n\nbut then it would be better to handle the filter string/regExp/whatever on your own instead using the base methods (like ) to set them, to at least avoid filtering twice - not much overhead anyway if you already re-implemented the .\n\nan alternative way would be to emit an own signal when setting sorting or filter, and connecting to it by using to make sure it is executed after filtering did end. that's what i finally did (to update a register of the table) and as far i can tell it works like expected."
    },
    {
        "link": "https://qtcentre.org/threads/34001-QSortFilterProxyModel-with-changing-data",
        "document": "To copy to clipboard, switch view to plain text mode"
    }
]