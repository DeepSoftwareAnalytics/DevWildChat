[
    {
        "link": "https://stackoverflow.com/questions/37622814/mapping-database-tables-to-java-classes-dependencies",
        "document": "I am trying to represent database tables as Java objects. I do not want to use JPA or Hibernate. I use JDBC for the actual connection to the database.\n\nCurrently I have three tables:\n• None A user, who has an Id (primary-key) a unique e-mail and a profile-id (foreign key for profile table)\n• None A profile, which has an Id (primary-key), some additional Strings, a user-id (foreign key for user table) and a contact-id (foreign key for contact table)\n• A contact, which has some String columns, an Id (primary-key) and an owner-id (foreign key for user table)\n\nNow my User class looks like this:\n\nAnd my Profile class looks like this:\n\nSo I planned to write a Dao for each class, which provides different methods for database request, does the request and returns the object accordingly.\n\n I thought it would be good to have a function in each Dao which retrieves a complete object. This means, for the UserDao it returns a User where id and email is filled and the Profile object is also created from the corresponding values in the DB. So the Contact in this Profile object would also be filled from the corresponding Contact entry in the DB.\n\nThe problem I now have is how to organize this, because for the User I would have to ask the ProfileDao to create a Profile object, and in the ProfileDao I would need to ask the ContactDao for the corresponding Contact. The ContactDao usually would try to get the user as well, as it would be needed to create the Contact object completely.\n\n So I would need to tell the Daos somehow to only retrieve the object itself and not the linked objects.\n\n But this seems odd to me.\n\nWould this really be the right way to go? Like calling the ContactDao with an additional parameter which tells the Dao to only get a flat representation.\n\n Or should I link the user to the contact only via the user's id and provide a function to retrieve the corresponding user when he is needed?\n\nWhat would be the correct way to solve this problem?\n\nEDIT It seems to me, I may have left an important information out (because I did not know it could be important). Actually the answer of @Oleg gave me that insight.\n\n What I am actually doing is: I build a SOAP webservice which should handle all the connections to the database but also (obviously) also the whole internal logic. On top of that I would like to create a SOAP client which can be integrated in a webpage or an app.\n\n My thought was I would need to give all possibilities to access the data in my database in any way I could imagine. But the answer by @Oleg seems to suggest something else:\n\n If I am implementing a SOAP-API (his example was REST but at the end it does not really matter), I should only care about the things I NEED.\n\n Say e.g. If I want to have a user, I just create a user object with an ID and the Email. If I want to have the profile of that user, I do another Request which gives me a flat profile object. And then I would also implement only those things in my API.\n\n would that be the right way, taking these additional information into account?"
    },
    {
        "link": "https://medium.com/@bubu.tripathy/unlock-java-persistence-605af4fe2f6f",
        "document": "Persistent class mapping is at the heart of building scalable and robust Java applications that interact seamlessly with relational databases. Whether you’re developing an e-commerce platform, a financial system, or a content management application, the ability to map Java objects to database tables is a critical skill. Java Persistence API (JPA) and Hibernate simplify this process by bridging the gap between the object-oriented world of Java and the relational world of databases.\n\nMapping persistent classes begins with distinguishing between entities and value types. Entities represent primary business objects with a unique identity and a lifecycle independent of other objects, such as , , or . Value types, like or , are often used to represent attributes of entities and depend on their owning entity for identity and lifecycle​\n\nEntities require a primary key to ensure database identity. This identity differentiates objects in the database, even if their attributes are otherwise equivalent. Primary keys must be unique, immutable, and non-null​.\n\nHere’s how you define an entity in JPA:\n• configures the primary key generation strategy. Here, the strategy is used to let the database handle ID generation.\n\nYou can control how primary keys are generated using various strategies:\n\nHere’s an example using the strategy:\n• defines the sequence generator name and configuration.\n• The parameter specifies how many IDs to pre-allocate to minimize database calls.\n\nJPA provides flexible options for mapping entities to database tables:\n\nThe annotation customizes the database table name to avoid conflicts or match existing schemas.\n\nMark an entity as immutable to prevent updates:\n\nHibernate’s annotation ensures that the entity is read-only, ideal for audit logs or historical data.\n\nDynamic SQL generation refers to the ability of JPA and Hibernate to construct and execute SQL statements dynamically at runtime. This feature is a key advantage of using ORM frameworks, as it eliminates the need to write SQL queries manually for standard database operations such as inserts, updates, deletes, and selects. Dynamic SQL generation is driven by the mapping metadata defined in your entity classes. For instance:\n• Insert Operations: When an entity is persisted using or , the framework generates an SQL statement based on the entity's field mappings.\n• Update Operations: When an entity is modified and the transaction is committed, Hibernate generates an SQL statement for only the modified fields, optimizing performance.\n• Select Operations: For retrieval, the framework generates statements dynamically based on criteria queries, JPQL (Java Persistence Query Language), or finder methods in Spring Data repositories.\n• Delete Operations: When an entity is removed using or , the framework generates a SQL statement.\n\nDynamic SQL generation simplifies development by allowing developers to focus on business logic and entity relationships without managing SQL syntax. It enhances portability by generating SQL statements tailored to the underlying database dialect, enabling seamless transitions across databases. ORM frameworks like Hibernate and JPA optimize performance with features such as batching and prepared statements, ensuring efficient database interactions. Additionally, maintaining applications becomes easier, as schema changes only require updates to mapping annotations, eliminating the need for extensive query rewrites.\n\nThe following code saves the entity:\n\nwhich generates the following SQL:\n• Batch Processing: Hibernate can batch multiple SQL statements, reducing database roundtrips for bulk inserts or updates.\n• Lazy and Eager Fetching: Hibernate dynamically adjusts statements based on the fetching strategy ( or ).\n• Criteria Queries: Dynamic queries can be generated using JPA’s Criteria API or Hibernate’s CriteriaQuery, allowing flexible query construction at runtime.\n\nFollowing is an example of a Criteria Query:\n\nThe following SQL gets generated:\n• Use JPQL or Criteria API for Complex Queries: For dynamic query needs, these tools provide flexibility while maintaining portability and type safety.\n• Enable SQL Logging: Enable logging of generated SQL for debugging and performance tuning by configuring Hibernate’s SQL logger:\n\n3. Avoid Over-fetching: Carefully configure fetching strategies to ensure SQL statements retrieve only the necessary data.\n\n4. Tune Performance: Use indexes, caching, and query hints to optimize generated SQL for complex operations."
    },
    {
        "link": "https://stackoverflow.com/questions/2872126/good-design-of-mapping-java-domain-objects-to-tables-using-hibernate",
        "document": "I have a question that is more in the realm of design, than implementation. I'm also happy for anyone to point out resources for the answer and I'll gladly, research for myself.\n\nSay I have a business domain POJO called 'Picture' with three attributes.\n\nSay I have another business domain POJO called \"Item\" with 3 attributes\n\nThese would be a normal simple relationship. You could say that 'Picture' object, will never exist outside an 'Item' object. Assume a picture belongs only to a specific item, but that an item can have multiple pictures\n\nNow - using good database design (3rd Normal Form), we know that we should put items and pictures in their own tables. Here is what I assume would be correct.\n\nHere is my question: If you are making Hibernate mapping files for these objects. In the data design, your Picture table needs a column to refer to the Item, so that a foreign key relation can be maintained. However,in your business domain objects - your Picture object does not hold a reference/attribute to the idItem of Item - and does not need to know it. A java Picture instance is always instantiated inside an Item instance. If you want to know the Item that the Picture belongs to you are already in the correct scope. Call myItem.getIdItem() and myItem.getItemPictures(),and you have the two pieces of information you need.\n\nI know that Hibernate tools have a generator that can auto make your POJO's from looking at your database. My problem stems from the fact that I planned out the data design for this experiment/project first. Then when I went to make the domain java objects, I realized that good design dictated that the objects hold other objects in a nested way. This is obviously different from the way that a database schema is - where all objects(tables) are flat and hold no other complex types within them. What is a good way to reconcile this?\n\n(B) Add an int attribute in the Picture class to refer to the idItem and set it at instantiation, thus simplifying the hbm.xml mapping file by having all table fields as local attributes in the class\n\n(C) Fix the database design because it is wrong, dork.\n\nI'd truly appreciate any feedback"
    },
    {
        "link": "https://quora.com/Is-it-a-good-practice-to-represent-every-database-table-in-Java-class-or-any-OO-programming-language-class",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://agiledata.org/essays/mappingobjects.html",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nA class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarationsexcept that they use the name of the class and have no return type. For example, has one constructor:\n\nTo create a new object called , a constructor is called by the operator:\n\ncreates space in memory for the object and initializes its fields.\n\nAlthough only has one constructor, it could have others, including a no-argument constructor:\n\ninvokes the no-argument constructor to create a new object called .\n\nBoth constructors could have been declared in because they have different argument lists. As with methods, the Java platform differentiates constructors on the basis of the number of arguments in the list and their types. You cannot write two constructors that have the same number and type of arguments for the same class, because the platform would not be able to tell them apart. Doing so causes a compile-time error.\n\nYou don't have to provide any constructors for your class, but you must be careful when doing this. The compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation, the compiler will complain if the superclass doesn't have a no-argument constructor so you must verify that it does. If your class has no explicit superclass, then it has an implicit superclass of , which does have a no-argument constructor.\n\nYou can use a superclass constructor yourself. The class at the beginning of this lesson did just that. This will be discussed later, in the lesson on interfaces and inheritance.\n\nYou can use access modifiers in a constructor's declaration to control which other classes can call the constructor.\n\nNote: If another class cannot call a constructor, it cannot directly create objects."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html",
        "document": "\n• Returns the object representing the class or interface that declares the executable represented by this object. an object representing the declaring class of the underlying member\n• Returns the name of this constructor, as a string. This is the binary name of the constructor's declaring class. the simple name of the underlying member\n• Returns the Java language modifiers for the executable represented by this object. the Java language modifiers for the underlying member\n• Returns an array of objects that represent the type variables declared by the generic declaration represented by this object, in declaration order. Returns an array of length 0 if the underlying generic declaration declares no type variables. an array of objects that represent the type variables declared by this generic declaration - if the generic signature of this generic declaration does not conform to the format specified in\n• Returns an array of objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Returns an array of length 0 if the underlying executable takes no parameters. the parameter types for the executable this object represents\n• Returns the number of formal parameters (whether explicitly declared or implicitly declared or neither) for the executable represented by this object. The number of formal parameters for the executable this object represents\n• objects that represent the formal parameter types, in declaration order, of the executable represented by this object. Returns an array of length 0 if the underlying executable takes no parameters. Returns an array ofobjects that represent the formal parameter types, in declaration order, of the executable represented by this object. Returns an array of length 0 if the underlying executable takes no parameters. If a formal parameter type is a parameterized type, the object returned for it must accurately reflect the actual type parameters used in the source code. If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved. an array of s that represent the formal parameter types of the underlying executable, in declaration order - if the generic method signature does not conform to the format specified in - if any of the parameter types of the underlying executable refers to a non-existent type declaration - if any of the underlying executable's parameter types refer to a parameterized type that cannot be instantiated for any reason\n• Returns an array of objects that represent the types of exceptions declared to be thrown by the underlying executable represented by this object. Returns an array of length 0 if the executable declares no exceptions in its clause. the exception types declared as being thrown by the executable this object represents\n• objects that represent the exceptions declared to be thrown by this executable object. Returns an array of length 0 if the underlying executable declares no exceptions in its clause. Returns an array ofobjects that represent the exceptions declared to be thrown by this executable object. Returns an array of length 0 if the underlying executable declares no exceptions in itsclause. If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved. an array of Types that represent the exception types thrown by the underlying executable - if the generic method signature does not conform to the format specified in - if the underlying executable's clause refers to a non-existent type declaration - if the underlying executable's clause refers to a parameterized type that cannot be instantiated for any reason\n• Compares this against the specified object. Returns true if the objects are the same. Two objects are the same if they were declared by the same class and have the same formal parameter types. - the reference object with which to compare. if this object is the same as the obj argument; otherwise.\n• Returns a hashcode for this . The hashcode is the same as the hashcode for the underlying constructor's declaring class name. a hash code value for this object.\n• . The string is formatted as the constructor access modifiers, if any, followed by the fully-qualified name of the declaring class, followed by a parenthesized, comma-separated list of the constructor's formal parameter types. For example: Returns a string describing this. The string is formatted as the constructor access modifiers, if any, followed by the fully-qualified name of the declaring class, followed by a parenthesized, comma-separated list of the constructor's formal parameter types. For example: The only possible modifiers for constructors are the access modifiers , or . Only one of these may appear, or none if the constructor has default (package) access.\n• , including type parameters. The string is formatted as the constructor access modifiers, if any, followed by an angle-bracketed comma separated list of the constructor's type parameters, if any, followed by the fully-qualified name of the declaring class, followed by a parenthesized, comma-separated list of the constructor's generic formal parameter types. If this constructor was declared to take a variable number of arguments, instead of denoting the last parameter as \" \", it is denoted as \" \". A space is used to separate access modifiers from one another and from the type parameters or return type. If there are no type parameters, the type parameter list is elided; if the type parameter list is present, a space separates the list from the class name. If the constructor is declared to throw exceptions, the parameter list is followed by a space, followed by the word \" \" followed by a comma-separated list of the thrown exception types. Returns a string describing this, including type parameters. The string is formatted as the constructor access modifiers, if any, followed by an angle-bracketed comma separated list of the constructor's type parameters, if any, followed by the fully-qualified name of the declaring class, followed by a parenthesized, comma-separated list of the constructor's generic formal parameter types. If this constructor was declared to take a variable number of arguments, instead of denoting the last parameter as \"\", it is denoted as \"\". A space is used to separate access modifiers from one another and from the type parameters or return type. If there are no type parameters, the type parameter list is elided; if the type parameter list is present, a space separates the list from the class name. If the constructor is declared to throw exceptions, the parameter list is followed by a space, followed by the word \"\" followed by a comma-separated list of the thrown exception types. The only possible modifiers for constructors are the access modifiers , or . Only one of these may appear, or none if the constructor has default (package) access.\n• object to create and initialize a new instance of the constructor's declaring class, with the specified initialization parameters. Individual parameters are automatically unwrapped to match primitive formal parameters, and both primitive and reference parameters are subject to method invocation conversions as necessary. Uses the constructor represented by thisobject to create and initialize a new instance of the constructor's declaring class, with the specified initialization parameters. Individual parameters are automatically unwrapped to match primitive formal parameters, and both primitive and reference parameters are subject to method invocation conversions as necessary. If the number of formal parameters required by the underlying constructor is 0, the supplied array may be of length 0 or null. If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of . If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized. If the constructor completes normally, returns the newly created and initialized instance. - array of objects to be passed as arguments to the constructor call; values of primitive types are wrapped in a wrapper object of the appropriate type (e.g. a in a ) a new object created by calling the constructor this object represents - if this object is enforcing Java language access control and the underlying constructor is inaccessible. - if the number of actual and formal parameters differ; if an unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a parameter value cannot be converted to the corresponding formal parameter type by a method invocation conversion; if this constructor pertains to an enum type. - if the class that declares the underlying constructor represents an abstract class. - if the underlying constructor throws an exception. - if the initialization provoked by this method fails.\n• Returns if this executable was declared to take a variable number of arguments; returns otherwise. if an only if this executable was declared to take a variable number of arguments.\n• Returns if this executable is a synthetic construct; returns otherwise. true if and only if this executable is a synthetic construct as defined by .\n• Returns this element's annotation for the specified type if such an annotation is present, else null. - the type of the annotation to query for and return if present - the Class object corresponding to the annotation type this element's annotation for the specified annotation type if present on this element, else null - if the given annotation class is null\n• Returns annotations that are directly present on this element. This method ignores inherited annotations. If there are no annotations directly present on this element, the return value is an array of length 0. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers.\n• s that represent the annotations on the formal parameters, in declaration order, of the represented by this object. Synthetic and mandated parameters (see explanation below), such as the outer \"this\" parameter to an inner class constructor will be represented in the returned array. If the executable has no parameters (meaning no formal, no synthetic, and no mandated parameters), a zero-length array will be returned. If the has one or more parameters, a nested array of length zero is returned for each parameter with no annotations. The annotation objects contained in the returned arrays are serializable. The caller of this method is free to modify the returned arrays; it will have no effect on the arrays returned to other callers. A compiler may add extra parameters that are implicitly declared in source (\"mandated\"), as well as parameters that are neither implicitly nor explicitly declared in source (\"synthetic\") to the parameter list for a method. See Returns an array of arrays ofs that represent the annotations on the formal parameters, in declaration order, of therepresented by this object. Synthetic and mandated parameters (see explanation below), such as the outer \"this\" parameter to an inner class constructor will be represented in the returned array. If the executable has no parameters (meaning no formal, no synthetic, and no mandated parameters), a zero-length array will be returned. If thehas one or more parameters, a nested array of length zero is returned for each parameter with no annotations. The annotation objects contained in the returned arrays are serializable. The caller of this method is free to modify the returned arrays; it will have no effect on the arrays returned to other callers. A compiler may add extra parameters that are implicitly declared in source (\"mandated\"), as well as parameters that are neither implicitly nor explicitly declared in source (\"synthetic\") to the parameter list for a method. See for more information. an array of arrays that represent the annotations on the formal and implicit parameters, in declaration order, of the executable represented by this object\n• Returns an object that represents the use of a type to specify the return type of the method/constructor represented by this Executable. If this object represents a constructor, the object represents the type of the constructed object. If this object represents a method, the object represents the use of a type to specify the return type of the method. an object representing the return type of the method or constructor represented by this\n• Returns an object that represents the use of a type to specify the receiver type of the method/constructor represented by this Executable object. The receiver type of a method/constructor is available only if the method/constructor has a receiver parameter (JLS 8.4.1). If this object represents a constructor or instance method that does not have a receiver parameter, or has a receiver parameter with no annotations on its type, then the return value is an object representing an element with no annotations. If this object represents a static method, then the return value is null. an object representing the receiver type of the method or constructor represented by this"
    },
    {
        "link": "https://stackoverflow.com/questions/62848857/constructor-and-getter-and-setter-methods",
        "document": "You actually can do that just make sure your getters and setters are public,an easy way to ensure your getters and setters are correct is to right click in your class->source->generate getters and setters then choose which attributes you want to be read and write, However if your intention with this line\n\nis to create a new admin with these attributes\n\nmaybe try instead:\n\neither passing the values to the constructor directly without the variables\n\nor if you want for these to be the default values that an admin object is to have every time you create it then you can do this in the constructor:\n\nthen you can change the username like you want and if you want to check that it changed use\n\nin both cases you don't really need to create the instance variables as they are inherited from user class."
    },
    {
        "link": "https://reddit.com/r/learnjava/comments/1eibwq7/why_we_use_getters_setters_and_a_constructor",
        "document": "Why we use getters, setters and a constructor?\n\nim a newbie java developer and i want to learn more about this 3 methords\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    },
    {
        "link": "https://w3schools.com/java/java_encapsulation.asp",
        "document": "The meaning of Encapsulation, is to make sure that \"sensitive\" data is hidden from users. To achieve this, you must:\n• provide public get and set methods to access and update the value of a variable\n\nYou learned from the previous chapter that variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.\n\nThe method returns the variable value, and the method sets the value.\n\nSyntax for both is that they start with either or , followed by the name of the variable, with the first letter in upper case:\n\nThe method returns the value of the variable .\n\nThe method takes a parameter ( ) and assigns it to the variable. The keyword is used to refer to the current object.\n\nHowever, as the variable is declared as , we cannot access it from outside this class:\n\nIf the variable was declared as , we would expect the following output:\n\nHowever, as we try to access a variable, we get an error:\n\nInstead, we use the and methods to access and update the variable:\n• Better control of class attributes and methods\n• Class attributes can be made read-only (if you only use the method), or write-only (if you only use the method)\n• Flexible: the programmer can change one part of the code without affecting other parts"
    }
]