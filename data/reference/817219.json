[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://aiogram.dev",
        "document": ""
    },
    {
        "link": "https://github.com/aiogram/aiogram",
        "document": "aiogram is a modern and fully asynchronous framework for Telegram Bot API written in Python 3.8+ using asyncio and aiohttp.\n\nMake your bots faster and more powerful!\n• Has type hints (PEP 484) and can be used with mypy\n• Supports Telegram Bot API 8.3 and gets fast updates to the latest versions of the Bot API\n• Telegram Bot API integration code was autogenerated and can be easily re-generated when API gets updated\n\nIt is strongly advised that you have prior experience working with asyncio before beginning to use aiogram. If you have any questions, you can visit our community chats on Telegram:"
    },
    {
        "link": "https://restack.io/p/aiogram-tutorial-answer-best-telegram-bot-frameworks-for-ai-cat-ai",
        "document": "Before you start setting up Aiogram, ensure your development environment meets the following requirements:\n• Python 3.8+: Download and install Python from Python's official website.\n• Preferred IDE: Use Visual Studio Code or PyCharm for a better development experience.\n\nHomebrew is a package manager for MacOS that simplifies the installation of software. To install Homebrew, run the following command in your terminal:\n\nPyEnv allows you to easily switch between multiple versions of Python. Install it using Homebrew:\n\nNow, install Python 3.10 (or any version 3.8+):\n\nPoetry is a dependency management tool for Python. Install it with:\n\nFollow the prompts to set up your project details. After initialization, install the dependencies:\n\nTo install Aiogram, use the following command within your Poetry environment:\n\nOnce Aiogram is installed, you can create a simple bot to test your setup. Here’s a basic example:\n\nReplace with your actual bot token. Run the script to start your bot and test if it responds to the command. This confirms that your Aiogram setup is successful and you are ready to develop your bot further."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot",
        "document": "We have made you a wrapper you can't refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nThis library provides a pure Python, asynchronous interface for the Telegram Bot API. It's compatible with Python versions 3.9+.\n\nIn addition to the pure API implementation, this library features several convenience methods and shortcuts as well as a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the submodule.\n\nAfter installing the library, be sure to check out the section on working with PTB.\n\nAll types and methods of the Telegram Bot API 8.3 are natively supported by this library. In addition, Bot API functionality not yet natively included can still be used as described in our wiki.\n\nYou can install or upgrade via\n\nTo install a pre-release, use the flag in addition.\n\nYou can also install from source, though this is usually not necessary.\n\nTo enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures.\n\nStarting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value .\n\nEarlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format .\n\nIn addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix .\n\ntries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don't need the optional features.\n\nThe only required dependency is httpx ~= 0.27 for , the default networking backend.\n\nis most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out.\n\nPTB can be installed with optional dependencies:\n• installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• installs httpx[http2]. Use this, if you want to use HTTP/2.\n• installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• installs the tornado~=6.4 library. Use this, if you want to use / .\n• installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the .\n\nTo install multiple optional dependencies, separate them by commas, e.g. .\n• installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let's get started!\n\nOur Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• The official Telegram Bot API documentation is of course always worth a read.\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n• We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• You can even ask for help on Stack Overflow using the python-telegram-bot tag.\n\nSince v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• all classes in the module that allow to add/remove allowed users/chats at runtime\n\nContributions of all sizes are welcome. Please review our contribution guidelines to get started. You can also help by reporting bugs or feature requests.\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be."
    },
    {
        "link": "https://github.com/omnilib/aiosqlite",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://aiosqlite.omnilib.dev",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions. Connection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://pypi.org/project/aiosqlite",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://sqldocs.org/sqlite-database/aiosqlite-python",
        "document": "SQLite is one of the most widely used database engines in the world. Its lightweight, file-based architecture makes it perfect for embedded databases in desktop and mobile applications. However, Python’s standard SQLite library blocks the event loop while executing queries, hurting performance in asynchronous programs.\n\nEnter AioSQLite – an elegant asynchronous library interacting with SQLite from Python’s asyncio event loop without blocking. Let’s learn how AioSQLite makes SQLite fully non-blocking and explore some real-world use cases through examples.\n\nAioSQLite is an asynchronous, non-blocking SQLite driver for Python. It allows you to access SQLite databases from asyncio coroutines without blocking the main event loop thread.\n\nHere are some key things to know about AioSQLite:\n• It provides an async version of the SQLite Python API, replicating nearly all the features of\n• Uses a background thread per connection to talk to SQLite without blocking asyncio event loop\n• Lets you access SQLite using async/await instead of callbacks\n\nInstalling AioSQLite is as simple as:\n\nThat’s it! Now, let’s look at how to use it.\n\nThe API for AioSQLite mirrors , but with async methods instead of synchronous ones.\n\nFor example, here is how to connect to an SQLite database file, insert data, and query it:\n\nThere are a few key things to notice here:\n• Executing SQL happens via , using\n• Getting query results uses an async cursor that returns rows via\n\nThis allows the database code to run non-blockingly within an asyncio event loop.\n\nA key feature of AioSQLite is the use of async context managers to manage connections and cursors automatically:\n\nThis takes care of opening and closing connections for you.\n\nAioSQLite replicates most other advanced features of too:\n\nThe API supports nearly everything you can do in standard SQLite.\n\nHere is an example of using AioSQLite with a real-world data analytics database containing user analytics events:\n\nThis allows storing analytic event data from users in SQLite by leveraging AioSQLite’s non-blocking API!\n\nHere are some of the major benefits you get from using AioSQLite:\n• Avoid callback hell by using instead\n• Replicates nearly all functionality of module\n• Enables real-time analytics, streaming, and more use cases by removing SQLite blocking behavior\n\nIf you need to use SQLite from an asyncio app, AioSQLite is currently the best way to go about it while avoiding bottlenecks.\n\nAs you can see, AioSQLite retains nearly all the underlying SQLite functionality while adding async capabilities.\n\nAioSQLite brings the simplicity and ubiquity of SQLite to the world of asyncio and Python async programming. With its async API using , context managers, non-blocking behavior, and Python 3.7+ support, AioSQLite is the go-to choice for accessing SQLite from an asyncio application.\n\nWhether you need real-time analytics, streaming processing, or just a simple offline data store, AioSQLite takes the blocking factor out of SQLite. This lets you build highly concurrent database-backed programs without the headaches of callback hell or stalling the event loop.\n\nIf you found this useful, be sure to check out the AioSQLite documentation to learn more!"
    },
    {
        "link": "https://stackoverflow.com/questions/63813922/what-is-the-difference-between-aiosqlite-and-sqlite-in-multi-threaded-mode",
        "document": "I'm trying to asynchronously process multiple files, and processing each file requires some reads and writes to an SQLite database. I've been looking at some options, and I found the aiosqlite module here. However, I was reading the SQLite documentation here, and it says that it supports multi-threaded mode. In fact, the default mode is \"serialized\" which means it \"can be safely used by multiple threads with no restriction.\"\n\nI don't understand what the difference is. The aiosqlite documentation says:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection.\n\nI get that there is a difference between aiosqlite and the \"multi-threaded\" mode on sqlite because the multi-threaded mode requires only one connection per thread, whereas in aiosqlite, you can reuse this single connection across multiple threads. But isn't this the same as serialized mode where it can be \"used by multiple threads with no restriction\"?\n\nEdit: My question right now is \"Is my current understanding below is correct?\":\n• Sqlite in \"serialized\" mode can be used by multiple threads at one time, so this would be used if I used the module in python and spawned multiple threads. Here I have the options of either using a separate connection per thread or sharing the connection across multiple threads.\n• aiosqlite is used with asyncio. So since asyncio has multiple coroutines that share one thread, aiosqlite also works with one thread. So I create one connection that I share among all the coroutines.\n• Since aiosqlite is basically a wrapper for sqlite, I can combine the functionality of 1 and 2. So I can have multiple threads where each thread has an asyncio event loop with multiple coroutines. So the basic sqlite functionality will handle the multi-threading and the aiosqlite will handle the coroutines."
    }
]