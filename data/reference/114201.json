[
    {
        "link": "https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics",
        "document": "Perform collision detection and react with physics, using JavaScript. Check for overlap between shapes, apply hitboxes and calculate new velocities. Make it more natural with object mass, gravity and restitution. By the end of this tutorial, you'll have a basic physics simulation running in your game.\n\nBefore you can detect collisions between moving objects, you'll need some objects to begin with. In the previous tutorial you've learned how to move a single rectangle. Let's expand that logic and create a whole bunch of moving objects to fill your game. First, define a new type of game object. It's going to be a simple square.\n\nThis code might look a bit familiar. There is a draw() and a update() function, just like in the previous tutorial. Only this time it is baked into a separate square class. This way you can create many instances of a square and they all use the same logic to draw and update. You'll have the behavior and looks of the square in one, easy-to-manage, place.\n\nThe fillStyle in this new class is tweaked a bit. When this object is colliding, it will change color from blue to red. You'll see this in action when the first collisions are detected. For now, all squares will be blue.\n\nAll the squares inherit from the GameObject class. Every game object has a position and a speed. This enables you to easily create new types of game objects. They inherit the attributes and methods of the GameObject class. The square is just an example, but you could also make objects like enemies or players for your game this way.\n\nYou can create a new instance of a class by using the new keyword. Make some squares to fill up your game world using this createWorld() function.\n\nIn the function, a bunch of squares are created. They are passed a position and speed as arguments. For now, this function is very static, but you could easily modify it to create more random squares or use some spawning algorithm.\n\nEverything is in place to draw squares now. Update your game loop with the following code to loop over the newly created game objects and draw them on the screen.\n\nAs you can see, update() and draw() are no longer just called once per iteration. There are called once for every object on screen, every iteration.\n\nThis way the implementation of update() and draw() is object-specific. For the game loop it doesn't matter what kind of objects you are trying to draw, as long as they have an update() and draw() function.\n\nFor the square you are using, it will draw a simple square and move it in a straight line. But imagine other types of objects who have their own implementation of the two functions and have behavior and looks of their own. This game loop can handle it.\n\nBy the way, did you notice the \"use strict\" line missing in these new classes? That's because classes defined with the class keyword are strict by default. So, there is no need to specifically add \"use strict\" in these classes.\n\nTake a look at the result:\n\nYou can see a bunch of rectangles getting drawn now. They each have their own starting position and move in a different direction. Just as defined in the createWorld() function. You can tweak the variables to create new types of squares.\n\nWhy do you need collision detection?\n\nThe squares may overlap in their movement, but that doesn't do much for now. It would be cool if the squares could interact and behave like actual solid objects and bounce off of each other. To make this happen, they would have to start with knowing they're colliding with one another. That's where collision detection comes in.\n\nCollision detection is the art of detecting if two objects are colliding with each other, or did so between now and the last frame. It's the first step of implementing physics in your game.\n\nThe squares are moving on the screen, but there is no form of interaction jet. It's like they don't notice each other. Let's do something about that.\n\nYou are going to check for collisions between the moving objects. That requires you to loop over all objects and check if any of them overlaps with another. You'll need a nested for loop for this. Take a look at the example:\n\nAll objects are checked for intersection with each other. The second for loop is a bit smarter and skips all previous checked items. You don't have to check objects twice. If they overlap the first time, they will too the second time. And of course, you don't have to check an object against itself, it would always overlap.\n\nThe function calls rectIntersect() for every combination of objects. When it finds a collision, it sets isColliding to true for both objects involved.\n\nRemember the draw() function from the square? It will react to isColliding and draw the square in a different color. You can easily see when two objects overlap.\n\nWhen do you check for collisions?\n\nJust as with the draw() method, you want to update the position of all your game objects first, before checking for collisions. This way you'll always check for overlapping objects in their most recent state. If you do it the other way around and check for collisions before updating, you'll be checking for overlap on the state of the previous frame. You'll always run behind the facts.\n\nAnother option would be to do the collision check in the right order, but iterative. You would update object-a, check object-a for overlap with all other objects, update object-b, check object-b for overlap with all other objects, and so on. This is also an incorrect way of doing a collision check. Imagine object-a would be in collision with object-b after updating object-a's position. The system would detect a collision, even though it might not have been the case when object-b would have moved first too. That's why you'll always have to update all objects, before doing a collision check.\n\nThe correct order for your game loop is, update, collision check, clear canvas, draw. So, place the detectCollisions() function right after the loop for updating all game objects. Your total game loop now looks like this:\n\nThe last piece of the puzzle is the rectIntersect() method. You can use it to check if two rectangles overlap. Checking for overlap between two axis-aligned (unrotated) rectangles is pretty simple and straight forward. You can probably come up with a method of checking for overlap on both axis by using the position and size of the rectangles. There are a lot of ways to do this, but the next method is very efficient:\n\nThe code detects rectangles clearly overlapping halfway, but also works in the case of one small rectangle falling completely in a large one.\n\nWith this piece of code in place, you can finally check out the result. Here are the squares again, but this time they react upon each other.\n\nAfter detecting a collision, the isColliding attribute is set to true. This makes the squares draw in red. You can clearly see when two objects overlap now.\n\nYou have a method now for checking collision between unrotated rectangles. But what if you want to do the same for circles? Well, that's not that hard either.\n\nImagine you have two circles, each with their own radius. They are placed with a distance between them. The circles would overlap if the distance is smaller than the sum of the radius of both circles. Since circles are round, this would even work when rotating the objects, they don't have to be axis-aligned.\n\nSo, if this distance is smaller than- or equal to the radius of circle-a plus circle-b, the circles overlap or touch. This principle is used in the next function:\n\nAs you can see, the formula is tweaked a bit. Multiplication is much faster than getting the square root with Math.sqrt(), so the distance is calculated without getting the root and the sum of the radii is multiplied by itself. The outcome stays the same, but the performance is better.\n\nHere is the same example as before, but with circles this time:\n\nWhat about other shapes?\n\nIn this article, collision detection is only covered for two types of shapes. But what if your game objects consist of other, more complex, shapes or even images and you want to perform collision checks between them?\n\nWell, for geometric shapes you can find other formulas to detect when two objects overlap. Here's a website who covers collision detection for a lot of different shapes. Overall, more complex shapes make collision detection more difficult. And for images you could apply pixel perfect collision detection. The downside of this is that it's a super CPU-heavy operation. Imagine having to match every pixel with one another, it would be a heck of a job.\n\nThat's why, to make things easier and put less stress on your system, developers often use hitboxes to detect collisions between complexly shaped game objects. It's a way to make collision detection easier and uses only basic geometric shapes, like the rectangles and circles covered in this tutorial. So, before you start building support for all kinds of complex shapes, try to think of a simple way to achieve the same effect, with basic shapes and hitboxes.\n\nWhat are hitboxes and how do you use them?\n\nHitboxes are imaginary geometric shapes around game objects that are used to determine collision detection. Imagine you have a player figure. You won't check its arms and legs for collision but instead just check a big imaginary rectangle that's placed around the player.\n\nYou could simply use the function for rectangle collision detection, you've applied before, to check the hitboxes for collisions. It's far less CPU-intensive and makes supporting complex shapes in your game much easier. In some special cases, you could even use multiple hitboxes per game object. It would still outperform the pixel perfect solution.\n\nThe image above demonstrates the different types of collision detection. They each have their own advantages and disadvantages:\n• - Super precise collision detection, but it requires some serious system resources. In most cases this is an overkill.\n• - Much better performance, but the collision detection can be pretty imprecise. In many game scenarios though, this doesn't really matter.\n• - Less efficient than a single hitbox but it still outperforms the pixel perfect variant. And you can support complex shapes. This is a nice option to use for important game objects that need some extra precision, like the player with limbs like mentioned before. You could make a hitbox for the core and separates ones for arms, legs and the head.\n\nThe example image is an actual game asset from the game Pixi Pop. In the game, the asset is used when precise collision detection is important and not too many other game tasks are running. That's why, in this case, the choice is made to work with multiple hitboxes. Just pick the option that suits your game scenario the best.\n\nYou now have game objects who can detect a collision and change color. But wouldn't it be much cooler if the objects bounce off on each other, like real life objects? It's time to apply some physics to your game.\n\nTo change the velocity of the moving objects, you'll need to find out in what direction and with what speed the collision took place. You can then apply a change in velocity to the collided objects. The principles behind this work for both rectangles and circles.\n\nFind the direction and speed of the collision\n\nImagine the next collision between two game objects. Both objects have a speed and direction of their own. They don't hit each other exactly straight on, but just happen to cause a collision while moving on their own course.\n\nYou'll want to find out the speed and direction of the collision so you can apply it to the velocity of the game objects. Start by creating a vector for the collision that took place. This vector is nothing more than the difference in x and y between the two colliding objects. You can see it as an arrow with length and direction. With vectors, the length is also called magnitude. Calculate the collision vector like this:\n\nIn the example of the two game objects, the collision vector will look like this:\n\nThe magnitude in this case, is equal to the distance between the two colliding objects. It has nothing to do with speed yet. But you can use the direction of the vector. To get to the direction, you need to take away the factor of the distance.\n\nLet's first calculate the distance of the collision vector. You can use the same formula as you did before to calculate the distance between two colliding circles. So the code becomes:\n\nNow use the distance to compute a normalized collision vector. You basically remove the distance as a factor in the collision vector, so you are left with just a direction. The collision norm is in the same direction as the collision vector, only with norm/magnitude/length 1. You also call this an unit vector. You can calculate the normalized vector like this:\n\nThis will basically leave you with just a direction for the collision. In the example of the two game objects, it will look like this:\n\nYou now have a direction. This is the direction in which the collision took place. All you need now is the collision speed and you'll be able to calculate how the velocity of the objects will be affected by the collision. You can calculate the speed of the collision like this:\n\nAs first row in the example code, another vector is created with the relative velocity of the objects. It's like the vector you would have left if you would make one of the game objects stationary. (You can read more about relative velocities here.) It's easier to understand in the next example. The vectors of the two game objects are displayed on top of each other, so you can visualize the relative velocity vector:\n\nTogether with the collision normal, the relative velocity vector is used to calculate the dot product of the two vectors. The dot product is the length of the projection of relative velocity on the collision normal. Or in other words, the length of the velocity vector when it's in the direction of the collision. Learn more about dot products here. Learn more about vector operations here.\n\nThe dot product is equal to the speed of the collision. So that's it, you've got a speed and direction of the collision between the two objects. You can apply this to the velocity of the game objects and make them bounce off of each other.\n\nThe speed of the collision can be positive or negative. When it's positive, the objects are moving toward each other. When it's negative, they move away. When objects move away, there is no need to perform any further action. They will move out of collision on their own.\n\nFor the other case, when objects are moving toward each other, apply the speed in the direction of the collision. Both objects get the same change in velocity from the collision. Subtract or add the velocity to the velocity of the two collided objects.\n\nThat's it, by applying speed to direction you calculate the collision velocity. And that velocity is now processed in the velocity of the objects involved. Your game objects should bounce in a natural looking way.\n\nNow take a look at the result:\n\nIf you like, you can apply physics even further and take mass into the equation by calculating the collision impulse from the speed. Use the impulse to calculate momentum. Heavy objects will push light ones aside.\n\nIf you have two objects with a mass of 1, the impulse is just equal to the speed. In other cases, you basically split the speed into many small parts. Heavy objects receive a few of those parts as momentum, light objects a lot. This makes the lighter objects more effected by the collision.\n\nDon't forget to add mass to your game objects. The GameObject class is a good place to store mass. You can modify the createWorld() function to pass mass as an argument via the Circle and Rectangle classes.\n\nHere's an example that's modified to create a lot of small circles and two larger ones. (The spawning algorithm isn't very smart so the objects might start in collision)\n\nIn the example, the big circles have a very large mass compared to the smaller circles. They push everything out of their way. But when the two heavy objects hit each other, they bounce off too.\n\nGet the heading of the objects\n\nThe objects are constantly colliding and changing direction. For a game it would be helpful to know which direction exactly, so you can add rotated textures or build game logic based on it. Let's calculate it!\n\nYou can easily get the angle of the objects by using Math.atan2() on the x- and y velocities. The result is in radians, use Math.PI to translate it to degrees. Here's an example which calculates the angle in your update() function:\n\nYou can use the angle later in your game, to draw rotated images. This will be further explained in the next tutorial of this series.\n\nFor now, rotating isn't so interesting since the circle is a plain shape. You wouldn't notice a change in rotation. So, here's a simple implementation that shows the movement direction of the objects with a little line. The higher the speed, the longer the line. This basically represents the heading vector of the object. You can easily add this visualisation to your drawing function.\n\nThe examples shown in this tutorial contain just a basic implementation of physics. You could add more aspects to your game to make it look even more natural. Things like gravity or restitution aren't too hard to implement. Let's start right now with adding gravity to your simulation.\n\nFor gravity, simply adjust the y-speed of your objects with the gravitational acceleration. On Earth it's about 9.81 meter per second per second. You can apply it inside the update() function of your game objects. Every second, g is added to the y-speed, this will make the object fall faster and faster.\n\nUpdate the velocity before you update the position. This will give more accurate results, as explained in this article about integrating the equations of motion. This type of integration is called Semi-implicit Euler.\n\nConfine the movement space of the objects\n\nFor the effects of gravity to show nicely, you can limit the movement of your objects to the edges of the canvas. It will act like a closed box on which the objects can bounce off.\n\nYou can make it happen with a simple adjustment. Execute the next function right after your main collision detection function, so object-edge collisions are checked together with the object-object collisions.\n\nIt basically checks for objects positioned beyond the edges and resets their position to fall within the box again. The speed of the objects is then flipped to move perpendicular to the wall.\n\nIt's a very basic implementation and only works this way because the edges of the canvas are predefined straight lines. You could do the same with a circle-line collision and set-up dynamic lines, but that would be much more complicated than this quick example.\n\nIf you would run the code up till now, you'll see the game objects will never get in a resting state. They will keep bouncing and bouncing and never lose any energy. To counter this, you can implement restitution.\n\nRestitution basically describes how much energy is left after each collision. It has an effect on the bounciness of objects. The ratio between the starting and ending velocity after a bounce is called coefficient of restitution, or COR.\n• Objects with a COR of 0 would absorb all energy on impact, like a bag of sand hitting the floor.\n• Objects with a COR of 1 would have perfect elasticity, like a super bouncy bouncing ball.\n• Objects with a COR > 1 are completely fictional and would add extra energy after each collision.\n\nIn the previous coding example, the COR is being applied to the collision with the edges. This will make the objects lose just a little bit of energy after each bounce. It will make the simulation much more realistic, leaving it out would let the objects bounce on forever.\n\nTo complete the implementation of the restitution, you'll need to apply it to the objects involved in an object-object collision as well. Just multiply their speed by the COR (just restitution in the code). Every collision will now use up a bit of energy.\n\nWhen two objects collide with a different restitution setting, like for instance when a bouncing ball hits a bag of sand, the lowest restitution will count. In this case, neither the bouncing ball or the bag of sand will bounce, they both inherit the restitution of the bag.\n\nThe next live canvas example shows gravity, restitution and boxing being applied.\n\nYou can easily tweak the variables to create different scenarios. Set a high gravity to simulate being on a foreign planet or lower the restitution to make the objects act like bags of sand who absorb all impacts.\n\nYou might not really notice it right now, but with many game objects on screen at once or with more complex shapes, the collision detection and -reaction can put some serious stress on your system. Here are some tips that might help to improve performance. They might seem obvious, but when a game gets more complex it's easy to overlook some of these concepts.\n• Only compare objects that are close enough to have a possible collision. You could use a grid system or only detect collision when objects enter a certain radius. This is called splitting the collision detection into a and . Learn more about broad phase collision detection here.\n• Keep your clean. Clean up objects when they are out of view or destroyed in-game.\n• Exclude . Some objects won't ever react to collisions, so don't include them in the iteration.\n• Use . As explained before, hitboxes are a great way of optimizing collision detection and simplify complex shapes.\n• Adjust the of collision detection and physics to fit your game. You don't need a full physics engine when all you want to do is to make tic-tac-toe. That's a bit of a drastic example, but you get the point. Strip your logic to only support what is needed.\n\nOne final note about collision detection. The above example detects collisions by checking if two objects overlap. This is a good solution in many cases. But it won't work when your objects move at great speed. When the speed is higher than the size of your smallest object, objects have a chance of skipping the collision check. They pass through each other.\n\nImagine you check for a collision between a bullet and an enemy in your game. The first frame the bullet is before the enemy. There is no overlap, so the objects didn't hit. The next frame the bullet moved so fast, it is now behind your enemy. There still is no overlap, so no collision. But the bullet did pass right through the enemy and there should've been a hit.\n\nHere's an image to demonstrate the situation of a fast-moving object, like a bullet, that never has any real overlap with another game object but should've caused a collision:\n\nYou need another approach for this kind of situation. The simplest way is to limit the speed of your game objects. In short, make sure the speed is never larger than the smallest game object, so it can't pass through. For many types of games this is a great solution and it requires minimal effort.\n\nThe other solution is to perform collision detection with the projected path instead of the current position of the two objects. Try to visualize the path of a bullet as a line. The length of the line is equal to the distance the bullet will travel. Now you can use a line-to-rectangle or line-to-circle collision check to find out if the bullet will hit another object. For large bullets, you could use a rectangle instead of a line.\n\nThis is a simplified solution. You will probably run into other problems along the way, like finding the point of impact or determining which object of a greater set is hit first. But the steps mentioned here might help to point you in the right direction. For now, this is all on fast-moving objects for this tutorial.\n\nThat's all for now on collisions and physics. Your collision check is in place and your game objects are now interacting with each other in a semi-natural way. If you have any comments or questions, feel free to post them in the comment section below. You can\n\nIn the next step of the tutorial, you'll learn how to use images in your game and create sprite animations."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/161814/how-to-optimize-collisions",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/d3psmt/introduction_to_collision_detection_tutorial_for",
        "document": "The subreddit covers various game development aspects, including programming, design, writing, art, game jams, postmortems, and marketing. It serves as a hub for game creators to discuss and share their insights, experiences, and expertise in the industry."
    },
    {
        "link": "https://toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects",
        "document": "This is Part II of our three-part series on video game physics. For the rest of this series, see:\n\nIn Part I of this series, we explored rigid bodies and their motions. In that discussion, however, objects did not interact with each other. Without some additional work, the simulated rigid bodies can go right through each other, or “interpenetrate”, which is undesirable in the majority of cases.\n\nIn order to more realistically simulate the behavior of solid objects, we have to check if they collide with each other every time they move, and if they do, we have to do something about it, such as applying forces that change their velocities, so that they will move in the opposite direction. This is where understanding collision physics is particularly important for game developers.\n\nIn Part II, we will cover the collision detection step, which consists of finding pairs of bodies that are colliding among a possibly large number of bodies scattered around a 2D or 3D world. In the next, and final, installment, we’ll talk more about “solving” these collisions to eliminate interpenetrations.\n\nFor a review of the linear algebra concepts referred to in this article, you can refer to the linear algebra crash course in Part I.\n\nIn the context of rigid body simulations, a collision happens when the shapes of two rigid bodies are intersecting, or when the distance between these shapes falls below a small tolerance.\n\nIf we have n bodies in our simulation, the computational complexity of detecting collisions with pairwise tests is O(n2), a number that makes computer scientists cringe. The number of pairwise tests increases quadratically with the number of bodies, and determining if two shapes, in arbitrary positions and orientations, are colliding is already not cheap. In order to optimize the collision detection process, we generally split it in two phases: broad phase and narrow phase.\n\nThe broad phase is responsible for finding pairs of rigid bodies that are potentially colliding, and excluding pairs that are certainly not colliding, from amongst the whole set of bodies that are in the simulation. This step must be able to scale really well with the number of rigid bodies to make sure we stay well under the O(n2) time complexity. To achieve that, this phase generally uses space partitioning coupled with bounding volumes that establish an upper bound for collision.\n\nThe narrow phase operates on the pairs of rigid bodies found by the broad phase that might be colliding. It is a refinement step where we determine if the collisions are actually happening, and for each collision that is found, we compute the contact points that will be used to solve the collisions later.\n\nIn the next sections we’ll talk about some algorithms that can be used in the broad phase and narrow phase.\n\nIn the broad phase of collision physics for video games we need to identify which pairs of rigid bodies might be colliding. These bodies might have complex shapes like polygons and polyhedrons, and what we can do to accelerate this is to use a simpler shape to encompass the object. If these bounding volumes do not intersect, then the actual shapes also do not intersect. If they intersect, then the actual shapes might intersect.\n\nSome popular types of bounding volumes are oriented bounding boxes (OBB), circles in 2D, and spheres in 3D. Let’s look at one of the simplest bounding volumes: axis-aligned bounding boxes (AABB).\n\nAABBs get a lot of love from physics programmers because they are simple and offer good tradeoffs. A 2-dimensional AABB may be represented by a struct like this in the C language:\n\nThe field represents the location of the lower left corner of the box and the field represents the top right corner.\n\nTo test if two AABBs intersect, we only have to find out if their projections intersect on all of the coordinate axes:\n\nThis code has the same logic of the function from the Box2D engine (version 2.3.0). It calculates the difference between the and of both AABBs, in both axes, in both orders. If any of these values is greater than zero, the AABBs don’t intersect.\n\nEven though an AABB overlap test is cheap, it won’t help much if we still do pairwise tests for every possible pair since we still have the undesirable O(n2) time complexity. To minimize the number of AABB overlap tests we can use some kind of space partitioning, which which works on the same principles as database indices that speed up queries. (Geographical databases, such as PostGIS, actually use similar data structures and algorithms for their spatial indexes.) In this case, though, the AABBs will be moving around constantly, so generally, we must recreate indices after every step of the simulation.\n\nThere are plenty of space partitioning algorithms and data structures that can be used for this, such as uniform grids, quadtrees in 2D, octrees in 3D, and spatial hashing. Let us take a closer look at two popular spatial partitioning algorithms: sort and sweep, and bounding volume hierarchies (BVH).\n\nThe sort and sweep method (alternatively known as sweep and prune) is one of the favorite choices among physics programmers for use in rigid body simulation. The Bullet Physics engine, for example, has an implementation of this method in the class.\n\nThe projection of one AABB onto a single coordinate axis is essentially an interval [b, e] (that is, beginning and end). In our simulation, we’ll have many rigid bodies, and thus, many AABBs, and that means many intervals. We want to find out which intervals are intersecting.\n\nIn the sort and sweep algorithm, we insert all b and e values in a single list and sort it ascending by their scalar values. Then we sweep or traverse the list. Whenever a b value is encountered, its corresponding interval is stored in a separate list of active intervals, and whenever an e value is encountered, its corresponding interval is removed from the list of active intervals. At any moment, all the active intervals are intersecting. (Check out David Baraff’s Ph. D Thesis, p. 52 for details. I suggest using this online tool to view the postscript file.) The list of intervals can be reused on each step of the simulation, where we can efficiently re-sort this list using insertion sort, which is good at sorting nearly-sorted lists.\n\nIn two and three dimensions, running the sort and sweep, as described above, over a single coordinate axis will reduce the number of direct AABB intersection tests that must be performed, but the payoff may be better over one coordinate axis than another. Therefore, more sophisticated variations of the sort and sweep algorithm are implemented. In his book Real-Time Collision Detection (page 336), Christer Ericson presents an efficient variation where he stores all AABBs in a single array, and for each run of the sort and sweep, one coordinate axis is chosen and the array is sorted by the value of the AABBs in the chosen axis, using quicksort. Then, the array is traversed and AABB overlap tests are performed. To determine the next axis that should be used for sorting, the variance of the center of the AABBs is computed, and the axis with greater variance is chosen for the next step.\n\nAnother useful spatial partitioning method is the dynamic bounding volume tree, also known as Dbvt. This is a type of bounding volume hierarchy.\n\nThe Dbvt is a binary tree in which each node has an AABB that bounds all the AABBs of its children. The AABBs of the rigid bodies themselves are located in the leaf nodes. Typically, a Dbvt is “queried” by giving the AABB for which we would like to detect intersections. This operation is efficient because the children of nodes that do not intersect the queried AABB do not need to be tested for overlap. As such, an AABB collision query starts from the root, and continues recursively through the tree only for AABB nodes that intersect with the queried AABB. The tree can be balanced through tree rotations, as in an AVL tree.\n\nBox2D has a sophisticated implementation of Dbvt in the class. The class is responsible for performing the broad phase, and it uses an instance of to perform AABB queries.\n\nAfter the broad phase of video game collision physics, we have a set of pairs of rigid bodies that are potentially colliding. Thus, for each pair, given the shape, position and orientation of both bodies, we need to find out if they are, in fact, colliding; if they are intersecting or if their distance falls under a small tolerance value. We also need to know what points of contact are between the colliding bodies, since this is needed to resolve the collisions later.\n\nAs a video game physics general rule, it is not trivial to determine if two arbitrary shapes are intersecting, or to compute the distance between them. However, one property that is of critical importance in determining just how hard it is, is the convexity of the shape. Shapes can be either convex or concave and concave shapes are harder to work with, so we need some strategies to deal with them.\n\nIn a convex shape, a line segment between any two points within the shape always falls completely inside the shape. However for a concave (or “non-convex”) shape, the same is not true for all possible line segments connecting points in the shape. If you can find at least one line segment that falls outside of the shape at all, then the shape is concave.\n\nComputationally, it is desirable that all shapes are convex in a simulation, since we have a lot of powerful distance and intersection test algorithms that work with convex shapes. Not all objects will be convex though, and usually we work around them in two ways: convex hull and convex decomposition.\n\nThe convex hull of a shape is the smallest convex shape that fully contains it. For a concave polygon in two dimensions, it would be like hammering a nail on each vertex and wrapping a rubber band around all nails. To calculate the convex hull for a polygon or polyhedron, or more generally, for a set of points, a good algorithm to use is the quickhull algorithm, which has an average time complexity of O(n log n).\n\nObviously, if we use a convex hull to represent a concave object, it will lose its concave properties. Undesirable behavior, such as “ghost” collisions may become apparent, since the object will still have a concave graphical representation. For example, a car usually has a concave shape, and if we use a convex hull to represent it physically and then put a box on it, the box might appear to be floating in the space above.\n\nIn general, convex hulls are often good enough to represent concave objects, either because the unrealistic collisions are not very noticeable, or their concave properties are not essential for whatever is being simulated. In some cases, though, we might want to have the concave object behave like a concave shape physically. For example, if we use a convex hull to represent a bowl physically, we won’t be able to put anything inside of it. Objects will just float on top of it. In this case, we can use a convex decomposition of the concave shape.\n\nConvex decomposition algorithms receive a concave shape and return a set of convex shapes whose union is identical to the original concave shape. Some concave shapes can only be represented by a large number of convex shapes, and these might become prohibitively costly to compute and use. However, an approximation is often good enough, and so, algorithms such as V-HACD produce a small set of convex polyhedrons out of a concave polyhedron.\n\nIn many collisons physics cases, though, the convex decomposition can be made by hand, by an artist. This eliminates the need to tax performance with decomposition algorithms. Since performance is one of the most important aspects in real-time simulations, it’s generally a good idea to create very simple physical representations for complex graphic objects. The image below shows one possible convex decomposition of a 2D car using nine convex shapes.\n\nThe separating axis theorem (SAT) states that two convex shapes are not intersecting if and only if there exists at least one axis where the orthogonal projections of the shapes on this axis do not intersect.\n\nIt’s usually more visually intuitive to find a line in 2D or a plane in 3D that separates the two shapes, though, which is effectively the same principle. A vector orthogonal to the line in 2D, or the normal vector of the plane in 3D, can be used as the “separating axis”.\n\nGame physics engines have a number of different classes of shapes, such as circles (spheres in 3D), edges (a single line segment), and convex polygons (polyhedrons in 3D). For each pair of shape type, they have a specific collision detection algorithm. The simplest of them is probably the circle-circle algorithm:\n\nEven though the SAT applies to circles, it’s much simpler to just check if the distance between their centers is smaller than the sum of their radii. For that reason, the SAT is used in the collision detection algorithm for specific pairs of shape classes, such as convex polygon against convex polygon (or polyhedrons in 3D).\n\nFor any pair of shapes, there are an infinite number of axes we can test for separation. Thus, determining which axis to test first is crucial for an efficient SAT implementation. Fortunately, when testing if a pair of convex polygons collide, we can use the edge normals as potential separating axes. The normal vector n of an edge is perpendicular to the edge vector, and points outside the polygon. For each edge of each polygon, we just need to find out if all the vertices of the other polygon are in front of the edge.\n\nIf any test passes – that is, if, for any edge, all vertices of the other polygon are in front of it – then the polygons do not intersect. Linear algebra provides an easy formula for this test: given an edge on the first shape with vertices a and b and a vertex v on the other shape, if (v - a) · n is greater than zero, then the vertex is in front of the edge.\n\nFor polyhedrons, we can use the face normals and also the cross product of all edge combinations from each shape. That sounds like a lot of things to test; however, to speed things up, we can cache the last separating axis we used and try using it again in the next steps of the simulation. If the cached separating axis does not separate the shapes anymore, we can search for a new axis starting from faces or edges that are adjacent to the previous face or edge. That works because the bodies often don’t move or rotate much between steps.\n\nBox2D uses SAT to test if two convex polygons are intersecting in its polygon-polygon collision detection algorithm in b2CollidePolygon.cpp.\n\nIn many collisions physics cases, we want to consider objects to be colliding not only if they are actually intersecting, but also if they are very close to each other, which requires us to know the distance between them. The Gilbert-Johnson-Keerthi (GJK) algorithm computes the distance between two convex shapes and also their closest points. It is an elegant algorithm that works with an implicit representation of convex shapes through support functions, Minkowski sums, and simplexes, as explained below.\n\nA support function sA(d) returns a point on the boundary of the shape A that has the highest projection on the vector d. Mathematically, it has the highest dot product with d. This is called a support point, and this operation is also known as support mapping. Geometrically, this point is the farthest point on the shape in the direction of d.\n\nFinding a support point on a polygon is relatively easy. For a support point for vector d, you just have to loop through its vertices and find the one which has the highest dot product with d, like this:\n\nHowever, the real power of a support function is that makes it easy to work with shapes such as cones, cylinders, and ellipses, among others. It is rather difficult to compute the distance between such shapes directly, and without an algorithm like GJK you would usually have to discretize them into a polygon or polyhedron to make things simpler. However, that might lead to further problems because the surface of a polyhedron is not as smooth as the surface of, say, a sphere, unless the polyhedron is very detailed, which can lead to poor performance during collision detection. Other undesirable side effects might show up as well; for example, a “polyhedral” sphere might not roll smoothly.\n\nTo get a support point for a sphere centered on the origin, we just have to normalize d (that is, compute d / ||d||, which is a vector with length 1 (unit length) that still points in the same direction of d) and then we multiply it by the sphere radius.\n\nCheck Gino van den Bergen’s paper to find more examples of support functions for cylinders, and cones, among other shapes.\n\nOur objects will, of course, be displaced and rotated from the origin in the simulation space, so we need to be able to compute support points for a transformed shape. We use an affine transformation T(x) = Rx + c to displace and rotate our objects, where c is the displacement vector and R is the rotation matrix. This transformation first rotates the object about the origin, and then translates it. The support function for a transformed shape A is:\n\nThe Minkowski sum of two shapes A and B is defined as:\n\nThat means we compute the sum for all points contained in A and B. The result is like inflating A with B.\n\nSimilarly, we define the Minkowski difference as:\n\nwhich we can also write as the Minkowski sum of A with -B:\n\nFor convex A and B, A⊕B is also convex.\n\nOne useful property of the Minkowski difference is that if it contains the origin of the space, the shapes intersect, as can be seen in the previous image. Why is that? Because if two shapes intersect, they have at least one point in common, which lie in the same location in space, and their difference is the zero vector, which is actually the origin.\n\nAnother nice feature of the Minkowski difference is that if it doesn’t contain the origin, the minimum distance between the origin and the Minkowski difference is the distance between the shapes.\n\nThe distance between two shapes is defined as:\n\nIn other words, the distance between A and B is the length of the shortest vector that goes from A to B. This vector is contained in A⊖B and it is the one with the smallest length, which consequently is the one closest to the origin.\n\nIt is generally not simple to explicitly build the Minkowski sum of two shapes. Fortunately, we can use support mapping here as well, since:\n\nThe GJK algorithm iteratively searches for the point on the Minkowski difference closest to the origin. It does so by building a series of simplexes that are closer to the origin in each iteration. A simplex – or more specifically, a k-simplex for an integer k – is the convex hull of k + 1 affinely independent points in a k-dimensional space. That is, if for two points, they must not coincide, for three points they additionally must not lie on the same line, and if we have four points they also must not lie on the same plane. Hence, the 0-simplex is a point, the 1-simplex is a line segment, the 2-simplex is a triangle and the 3-simplex is a tetrahedron. If we remove a point from a simplex we decrement its dimensionality by one, and if we add a point to a simplex we increment its dimensionality by one.\n\nLet’s put this all together to see how GJK works. To determine the distance between two shapes A and B, we start by taking their Minkowski difference A⊖B. We are searching for the closest point to the origin on the resulting shape, since the distance to this point is the distance between the original two shapes. We choose some point v in A⊖B, which will be our distance approximation. We also define an empty point set W, which will contain the points in the current test simplex.\n\nThen we enter a loop. We start by getting the support point w = sA⊖B(-v), the point on A⊖B whose projection onto v is closest to the origin.\n\nIf ||w|| is not much different than ||v|| and the angle between them didn’t change much (according to some predefined tolerances), it means the algorithm has converged and we can return ||v|| as the distance.\n\nOtherwise, we add w to W. If the convex hull of W (that is, the simplex) contains the origin, the shapes intersect, and this also means we are done. Otherwise, we find the point in the simplex that is closest to the origin and then we reset v to be this new closest approximation. Finally, we remove whatever points in W that do not contribute to the closest point computation. (For example, if we have a triangle, and the closest point to the origin lies in one of its edges, we can remove the point from W that is not a vertex of this edge.) Then we repeat these same steps until the algorithm converges.\n\nThe next image shows an example of four iterations of the GJK algorithm. The blue object represents the Minkowski difference A⊖B and the green vector is v. You can see here how v hones in on the closest point to the origin.\n\nFor a detailed and in-depth explanation of the GJK algorithm, check out the paper A Fast and Robust GJK Implementation for Collision Detection of Convex Objects, by Gino van den Bergen. The blog for the dyn4j physics engine also has a great post on GJK.\n\nBox2D has an implementation of the GJK algorithm in b2Distance.cpp, in the function. It only uses GJK during time of impact computation in its algorithm for continuous collision detection (a topic we will discuss further down).\n\nThe Chimpunk physics engine uses GJK for all collision detection, and its implementation is in cpCollision.c, in the function. If the GJK algorithm reports intersection, it still needs to know what the contact points are, along with the penetration depth. To do that, it uses the Expanding Polytope Algorithm, which we shall explore next.\n\nAs stated above, if the shapes A and B are intersecting, GJK will generate a simplex W that contains the origin, inside the Minkowski difference A⊖B. At this stage, we only know that the shapes intersect, but in the design of many collision detection systems, it is desirable to be able to compute how much intersection we have, and what points we can use as the points of contact, so that we handle the collision in a realistic way. The Expanding Polytope Algorithm (EPA) allows us to obtain that information, starting where GJK left off: with a simplex that contains the origin.\n\nThe penetration depth is the length of the minimum translation vector (MTV), which is the smallest vector along which we can translate an intersecting shape to separate it from the other shape.\n\nWhen two shapes are intersecting, their Minkowski difference contains the origin, and the point on the boundary of the Minkowski difference that is closest to the origin is the MTV. The EPA algorithm finds that point by expanding the simplex that GJK gave us into a polygon; successively subdividing it’s edges with new vertices.\n\nFirst, we find the edge of the simplex closest to the origin, and compute the support point in the Minkowski difference in a direction that is normal to the edge (i.e. perpendicular to it and pointing outside the polygon). Then we split this edge by adding this support point to it. We repeat these steps until the length and direction of the vector doesn’t change much. Once the algorithm converges, we have the MTV and the penetration depth.\n\nUsing GJK in combination with EPA, we get a detailed description of the collision, no matter if the objects are already intersecting, or just close enough to be considered a collision.\n\nThe EPA algorithm is described in the paper Proximity Queries and Penetration Depth Computation on 3D Game Objects, also written by Gino van den Bergen. The dyn4j blog also has a post about EPA.\n\nThe video game physics techniques presented so far perform collision detection for a static snapshot of the simulation. This is called discrete collision detection, and it ignores what happens between the previous and current steps. For this reason, some collisions might not be detected, especially for fast moving objects. This issue is known as tunneling.\n\nContinuous collision detection techniques attempt to find when two bodies collided between the previous and the current step of the simulation. They compute the time of impact, so we can then go back in time and process the collision at that point.\n\nThe time of impact (or time of contact) tc is the instant of time when the distance between two bodies is zero. If we can write a function for the distance between two bodies along time, what we want to find is the smallest root of this function. Thus, the time of impact computation is a root-finding problem.\n\nFor the time of impact computation, we consider the state (position and orientation) of the body in the previous step at time ti-1, and in the current step at time ti. To make things simpler, we assume linear motion between the steps.\n\nLet’s simplify the problem by assuming the shapes are circles. For two circles C1 and C2, with radius r1 and r2, where their center of mass x1 and x2 coincide with their centroid (i.e., they naturally rotate about their center of mass), we can write the distance function as:\n\nConsidering linear motion between steps, we can write the following function for the position of C1 from ti-1 to ti\n\nIt is a linear interpolation from x1(ti-1) to x1(ti). The same can be done for x2. For this interval we can write another distance function:\n\nSet this expression equal to zero and you get a quadratic equation on t. The roots can be found directly using the quadratic formula. If the circles don’t intersect, the quadratic formula will not have a solution. If they do, it might result in one or two roots. If it has only one root, that value is the time of impact. If it has two roots, the smallest one is the time of impact and the other is the time when the circles separate. Note that the time of impact here is a number from 0 to 1. It is not a time in seconds; it is just a number we can use to interpolate the state of the bodies to the precise location where the collision happened.\n\nWriting a distance function for other kinds of shapes is difficult, primarily because their distance depends on their orientations. For this reason, we generally use iterative algorithms that move the objects closer and closer on each iteration until they are close enough to be considered colliding.\n\nThe conservative advancement algorithm moves the bodies forward (and rotates them) iteratively. In each iteration it computes an upper bound for displacement. The original algorithm is presented in Brian Mirtich’s PhD Thesis (section 2.3.2), which considers the ballistic motion of bodies. This paper by Erwin Coumans (the author of the Bullet Physics Engine) presents a simpler version that uses constant linear and angular velocities.\n\nThe algorithm computes the closest points between shapes A and B, draws a vector from one point to the other, and projects the velocity on this vector to compute an upper bound for motion. It guarantees that no points on the body will move beyond this projection. Then it advances the bodies forward by this amount and repeats until the distance falls under a small tolerance value.\n\nIt may take too many iterations to converge in some cases, for example, when the angular velocity of one of the bodies is too high.\n\nOnce a collision has been detected, it is necessary to change the motions of the colliding objects in a realistic way, such as causing them to bounce off each other. In the next and final installment in this theories, we’ll discuss some popular methods for resolving collisions in video games.\n\nIf you are interested in obtaining a deeper understanding about collision physics such as collision detection algorithms and techniques, the book Real-Time Collision Detection, by Christer Ericson, is a must-have.\n\nSince collision detection relies heavily on geometry, Toptal’s article Computational Geometry in Python: From Theory to Application is an excellent introduction to the topic."
    },
    {
        "link": "https://stackoverflow.com/questions/18040846/best-approach-for-collision-detection-with-html5-and-javascript",
        "document": "1. Should I re-check in every frame (it runs on 30 FPS)?\n\nWho says it runs in 30 FPS? I found no such thing in the HTML5 specification. Closest you'll get to have anything to say about the framerate at all is to programmatically call or the newish, more preferred, function.\n\nHowever, back to the story. You should always look for collisions as much as you can. Usually, writing games on other platforms where one have a greater ability to measure CPU load, this could be one of those things you might find favorable to scale back some if the CPU has a hard time to follow suit. In JavaScript though, you're out of luck trying to implement advanced solutions like this one.\n\nI don't think there's a shortcut here. The computer has no way of knowing what collided, how, when- and where, if you don't make that computation yourself. And yes, this is usually, if not at all times even, done just before each new frame is painted.\n\nIf by \"map\" you mean an array-like object or multidimensional array that maps coordinates to objects, then the short answer has to be no. But please do have an array of all objects on the scene. The width, height and coordinates of the object should be stored in variables in the object. Leaking these things would quickly become a burden; rendering the code complex and introduce bugs (please see separation of concerns and cohesion).\n\nDo note that I just said \"array of all objects on the scene\" =) There is a subtle but most important point in this quote:\n\nWhenever you walk through objects to determine their position and whether they have collided with someone or not. Also have a look at your viewport boundaries and determine whether the object are still \"on the scene\" or not. For instance, if you have a space craft simulator of some kind and a star just passed the player's viewport from one side to the other and then of the screen, and there is no way for the star to return and become visible again, then there is no reason for the star to be left behind in the system any more. He should be deleted and removed. He should definitely not be stored in an array and become part of a future collision detection with the player's avatar! Such things could dramatically slow down your game.\n• None Divide the screen into parts. There is no reason for you to look for a collision between two objects if one of them are on left side of the screen, and the other one is on the right side. You could split up the screen into more logical units than just left and right too.\n• None Always strive to have a cheap computation made first. We kind of already did that in the last tip. But even if you now know that two objects just might be in collision with each other, draw two logical squares around your objects. For instance, say you have two 2D airplanes, then there is no reason for you to first look if some part of their wings collide. Draw a square around each airplane, effectively capturing their largest width and their largest height. If these two squares do not overlap, then just like in the last tip, you know they cannot be in collision with each other. But, if your first-phase cheap computation hinted that they might be in collision, pass those two airplanes to another more expensive computation to really look into the matter a bit more."
    },
    {
        "link": "https://stackoverflow.com/questions/21940495/sine-wave-motion-in-spritekit",
        "document": "I agree with @Gord, in that I think s are the best way to go. However, there is no need to approximate the sine curve when you can use the function.\n\nFirstly, you need π as it's going to be useful for the calculations:\n\nSecondly, extend (in Objective-C this would be done with categories) to easily create an that oscillates the node in question:\n\nIn the code above: is the height of the oscillation; is the time for one complete cycle and the is the point around which the oscillation occurs. The formula for comes from the equations for Simple Harmonic Motion.\n\nThirdly, putting that all together. You can combine the action and to make the sprite move along the path of the curve."
    },
    {
        "link": "https://codehs.com/tutorial/andy/Programming_Sprites_in_JavaScript",
        "document": "Click on one of our programs below to get started coding in the sandbox!"
    },
    {
        "link": "https://csanyk.com/2012/10/game-maker-wave-motion-tutorial",
        "document": "Following up on my motion and position tutorial, I present a tutorial on wave-motion. This was something I wanted to include in the original article, but I realized that there’s enough complexity to this concept that it merited its own separate article.\n\nWavelike motion is any motion that involves periodic oscillation, not just linear undulating motion. (Other types of wavelike motion include pulsing and concentric ripples, for example.) But we’ll talk mostly if not exclusively about linear undulation, since it is easiest to understand, simplest to implement, and the basis for many others.\n\nWave motion may be accomplished by “faking it” with a sprite animation, but it can also be easily created using trig functions. There are advantages and disadvantages to both approaches.\n\nWith an animation, you can get very precise positioning and motion, and at runtime it is cheap to play the animation compared to performing math functions. The downside is that it is time consuming to create animations, and they are not very flexible in terms of adjusting the motion procedurally.\n\nWith math-defined motion, you have a great deal of flexibility, and you can adjust the behavior at runtime by varying the equation or the inputs. As well, the code for math-defined approaches takes much less memory, meaning your executable files will both be smaller and use less RAM. The downside is that the math computation can get expensive if you have a lot of instances using it in the game. Try to avoid over-using calls to trig functions, because they are computationally more expensive than most math functions.\n\nThe other downside is that for a lot of people, the math is harder to figure out than simply drawing out a brute-force animation. You just need to wrap your head around the math involved, which this tutorial will help with.\n\nThere are a number of interesting ways to apply the function to motion.\n\nThe function y = sin(x) returns an oscillating value between -1 and 1. Varying the position of an instance by such a small amount (we’re talking +/-1 pixel) would scarcely be noticeable, but we can just multiply this by a constant to increase the amplitude of the function, to suit our needs. Varying x slowly or quickly will influence the frequency of the oscillation.\n\nNote: Incidentally, the graphs in this article were generated by google. Search for “graph [function]” and google’s search engine will give you an interactive graph that you can use to understand how functions behave. This can be very handy when trying to figure out math functions that will be useful in your game projects.\n\nNote: In GML, the trig functions take arguments in radians, while things like and are given in degrees. Most people are used to thinking about trigonometry in degrees. Thus, if we want to feed our sine function a parameter value in degrees, we’ll actually need to convert it to radians, like this:\n\nIf you want to manually convert from degrees to radians, use this formula:\n\nAnd, to convert radians to degrees manually, it’s:\n\nGML provides the functions and so we don’t really need to bother with knowing the math, but it’s good to know it.\n\nUpdate: since I originally wrote this article, GameMaker has since added trig functions to GML that accept an argument in degrees: . So you won’t need to worry about converting degrees to radians and vice versa any longer if you don’t want to.\n\nFor our examples, I’ll discuss first in degrees since they are more familiar to most people.\n\nThe position-shift function will look like this:\n• signifies the number of pixels that we’ll be position-shifting our instance by.\n• is the peak height of the wave from the baseline, in pixels.\n• is a value representing an angle (in degrees) which varies over time.\n\n(In math texts, it’s standard to use the greek letter θ (theta) to represent the value of the angle which is provided to a trigonometric function. So if you’re reading about trigonometry somewhere else and see references to theta, this t-value is the same thing.\n\nUsually in a math textbook where we talk about graphing a trig function, we use the familiar cartesian plane variables x and y. We use rather than because in Game Maker is already defined as an instance’s x-axis position in the room — if we used , the wave motion would be dependent upon the horizontal position of the instance in the room! We want the oscillation to be dependent on time, not position.)\n\nWe need to provide an argument to the function that will increment through a series of values at a rate that will give an appropriate frequency. Normally will be an instance variable, but it could potentially be a global variable if we want everything that oscillates to move in unison, regardless of when it was created. Initialize in the Create event, and increment it in the Step event.\n\nNote that is just an ordinary variable, not a built-in GameMaker variable, and it won’t just increment on it’s own. We need to take care of that, like so:\n\nDepending on what value we use for increment, the frequency of oscillation will increase or decrease. The lower is, the slower the frequency will be.\n\nNote: If we’re using degrees, only needs to vary between values of 0-360, and if we want to be absolutely proper about it, we’ll want to cap it to this range, which we can do very easily using the modulo function, after we increment, like so:\n\nor, if you want to do it in one line:\n\nIn many games, this may not be necessary from a practical standpoint; I have tested Game Maker by setting up an incrementer function and incrementing a variable by 1 billion (1,000,000,000) every step, and let it run for several minutes, counting up to values in the quintillions and sextillions, and did not see it do anything unexpected, like rollover to a negative value, or overflow a buffer, or crash, or anything. Game Maker games seem to be capable of handling very large floating point values, which in practice it is very unlikely you’ll ever exceed. So if you’re worried about performance enough that you want to get rid of that mod instruction, it’s probably safe to do so. I still feel safer using it, so I’ll use it in my examples.\n\nSo what do we want the increment to be? That’s the tricky thing, and it depends in part on room_speed. The default GameMaker is 30 steps/second, but it’s pretty common to see projects that are designed to run at 60. If we increment by 1, we end up running through a complete cycle (t = 0..359) in 360/30 = 12 seconds, or a frequency of 1/12 Hz. (In a 60fps room, it’s 1/6 Hz.)\n\nThis is rather slow for many uses. But now that we know this, we can easily adjust our increment to make whatever frequency we need. If we want our oscillation to complete a cycle in 1 second, set increment = 12. Half a second, increment = 24. Quarter second, 48. We can go down, of course, as well: 6 = 2 second period, 3 = 4 second period, 1 = 12 second period, etc.\n\nIn a 60 fps room, of course, you can halve the above values. This will help smooth out the motion, as well. As the increment increases, the fidelity of the actual motion to the sine function becomes increasingly approximate, which looks jerky.\n\nWe do hit some limits with frequency, though. Say we want a frequency of 30Hz (in a 30 fps room). Well, just set increment to 360, right? …. but wait, this results in no oscillation at all! The sin() function is coming “full circle” every step, resulting in the same shift value: 0, so a 0-pixel shift every step is the result.\n\nMoreover, anything over a -Hz oscillation results in “starting over” from the 0Hz point. There’s no way around this, since time and motion are discrete in the game runner. Fortunately, such high frequency oscillation is extremely rapid, and way more than you’re likely to ever need.\n\nLet’s create an object that performs a simple oscillation in the Y axis. Or if you wanted a horizontal oscillation, you could substitute x wherever you see y. Putting together what we’ve learned so far, we’ll create a wave-moving object:\n\nThis will cause a nice +/-10 pixel oscillation with a period of 1 second.\n\nNote that we are using a technique called motion cloning (I just made that term up, but it sounds cool). That is, rather than apply directly to y every step, we’re “cloning” the value of to another variable, , keeping track of what the instance’s position would have been without the wave motion added to it. Each step, we update , and use it and the value of the in this step to calculate the new position.\n\nWhy is this necessary? Well, if we simply shifted or directly, , the shift value from each step would accumulate over time. But actually, our shift calculation already gives us the total accumulated shift within an oscillation cycle — not an incremental, per-step shift. If we re-added the accumulated total in each step, it would compound, and we’d end up with a much greater amplitude than intended.\n\nBy motion-cloning, we can avoid “shift buildup” (I just made that term up too). We use two variables we create for this purpose, and , to temporarily store what the (x, y) position would have been had it not been for our oscillation. When we apply the shift to or , we do so by adding the cloned value and the shift value together, and assigning it to or , thereby avoiding shift buildup.\n\nOur first example creates nice, vertical oscillation. But what if we want the direction to be other than vertical? Well, you can shift instead of , and this will give you horizontal oscillation. If you want any other angle, though, it gets tricky.\n\nThis just takes more trigonometry, and it’s easy to do once you understand the underlying geometry. Let’s look at the relationship of the values that make up the trigonometry functions:\n\nIf you draw a line in any direction θ from an origin point (0,0) to some other point (x, y) on the plane, you have a line of length h, which is the hypotenuse of a right triangle.\n\nIf we know the length of x and y, we can use the Pythagorean Theorem (a2 + b2 = c2) to calculate the length of h as sqrt(x2 + y2).\n\nNow that we understand those basics, this is a very handy reference showing how the various trigonometric functions relate to the Unit Circle:\n\nIn this case, h is the shift distance — we know the length of h, and we need to derive the x and y components of this vector, so that we can position-shift our instance in any direction θ. If we know h and we know θ, we can calculate x and y by using our understanding of trig functions.\n\nLooking at the sin() function, sine is the ratio of the lengths y side and the hypotenuse side of the triangle: y/h. So, therefore, sin(θ) * shift = y. We need to keep in mind, though, that in GameMaker rooms, y-zero is at the top of the room and y counts upwards as y-position moves downward, so we need to use -sin(θ) * shift.\n\nLooking at cos(), cosine is the ratio of the hypotenuse and the x side of the triangle: shift/x. So cos(θ) / shift = x.\n\nGameMaker provides us these calculations through the functions lengthdir_x() and lengthdir_y(). This makes it easier to use, since we don’t really have to think about or understand the math to call these functions; we only need to know that they exist, and what they can do for us. But understanding how trigonometry works will enable you to do a lot of other useful calculations, so it’s worth explaining here so that you will have this knowledge.\n\nSuppose we want an instance that oscillates in the plane of its own direction of motion. So, if it’s moving at a 45 degree angle, it needs the position shift imparted by our oscillation function to be translated by 45 degrees. No problem, we can alter the shift to incorporate the instance’s direction, using and :\n\n(By adding 90 degrees to direction in our lengthdir functions, we’re angling the position shift from the oscillation function perpendicular to the direction of travel.) Now, no matter what direction the instance is moving in, it will move along that direction with a nice wavy motion.\n\nRotating an instance as it oscillates so that it is turning along the slope of the sine wave can be done like this:\n\nThis is demonstrated in the below illustration, showing a still capture of a series of rectangular instances being emitted from the blue square at left, moving to the right in a wave motion, and their image angle matching the slope of the curve of the sine wave.\n\nThe above function works because the slope of the sine wave at t is equal to cos(t), and the angle of the slope is calculated by the arctangent function.\n\nIf you are performance-conscious, you may want to avoid calling every step. Particularly if you have many instances, if they’re all calling every step, it can add up. And if you’re repeatedly calling with the same argument, it’s wasteful — why are you asking the CPU to re-calculate this value again and again?\n\nYou can use an array to store the output of in an array, like so:\n\nNow, instead of calling every step, look up the result of by calling the -th index of the array.\n\nYou can also make a global variable, so that every instance doesn’t have to calculate its own table.\n\nThis works great if is always an integer, and if is constrained to a value between 0-360. If is a non-integer, you’ll need to use a rounding function ( ) to approximate to the nearest integer.\n\nThe position-shift approach to wave motion works well for most uses. But we can introduce oscillation into other properties, as well.\n\nRather than position shifting, we can change an object’s . To do this, use the same code as above, but instead of shifting or , shift the value of . Remember that the shift amount that you’re applying to the direction is in degrees. So an amplitude of 10 results in a directional wiggle of +/-10 degrees over a period of 1 second.\n\nShifting the speed of an object results in a lurching motion. If the instance’s starting speed = 10, and you “wave the speed” using your oscillation function by an amplitude of 10, with a frequency of 1 oscillation/second, it will speed up to speed 20, then slow down to speed 0, every second.\n\nYou can turn a wave motion into hopping motion by using the absolute value function:\n\nAnd if you want, you can invert it:\n\nAnd of course, you can apply “hopping” to or just as you can apply it to position.\n\nPlay the Wave Motion Demo in a new window\n\nThings to notice in the demo:\n• Wave-length and frequency are inter-related variables. The higher the frequency of oscillation, the shorter the wave length.\n• As amplitude increases, so does the speed of the instance as it must travel more and more per step. This results in the wave motion becoming choppy, and can also result in problems with collision detection as the waving instance moves more pixels than the size of its collision mask in a single step. To correct for amplitude-induced speed up, drop the frequency by reducing the t-increment.\n\nSometimes, you want wavy motion but you can’t afford it. There’s too many instances in your game, and all the calls to the sin() function are slowing down your game too much. Maybe your object doesn’t change its directional orientation, and you just want a simple vertical wave motion. (Or maybe you’re programming on an 8-bit microcontroller that has no FPU;-) What can you do?\n\nThis approach uses a constant for the position shift (as opposed to our sine function) and a timer to reverse the shift. Because we’re using a constant for our shift, we don’t need to calculate it each step, which saves time. Since we’re doing a purely vertical shift, we don’t have to calculate the lengthdir_x and lengthdir_y components of the shift, either, so we save even more time.\n\nThis is a much faster function, and the motion is nearly like our sin function — a great compromise when performance is more important than precision. Indeed, the resulting motion is a triangle wave, which is a useful approximation of a sine wave.\n\nIf you need to be able to change the direction of the instance and need to maintain perpendicular oscillation, you can just to back to calculating lengthdir_x and lengthdir_y in the Step function, but it’ll cost a little performance.\n\nWith this approach, amplitude is equal to 0.5 * shift * the alarm duration. Frequency is equal to 2 * alarm. Game Maker will accept fractional pixels, but the timers don’t work with fractional steps. Note also that the wave motion will not be centered on the original position of the object — rather, the object starts at the peak or valley of the wave.\n\nCreative use of these oscillation functions is encouraged! See what else you can “wave”.\n• Try waving the HSV or RGB values of an object’s color, or alpha.\n• Wave the number of points a bonus object is worth, so that careful timing will maximize the score it gives the player.\n• I’ve already mentioned waving the position, direction, and speed.\n• What else can you think of?"
    },
    {
        "link": "https://forum.gamemaker.io/index.php?threads/a-beginners-intro-to-the-fun-of-sine-waves-giving-sprites-fake-3d-effects.45942/",
        "document": "This is great! I've always done that type of spinning by drawing each frame of the animation. Never thought of doing it like that. I might be using it on a 3d game I'm working on right now for some of the objects. Thanks for sharing!"
    },
    {
        "link": "https://observablehq.com/@osteele/creating-coding-sin-basics",
        "document": "Experiment and prototype by building visualizations in live JavaScript notebooks. Collaborate with your team and decide which concepts to build out.\n\nUse Observable Framework to build data apps locally. Use data loaders to build in any language or library, including Python, SQL, and R.\n\nSeamlessly deploy to Observable. Test before you ship, use automatic deploy-on-commit, and ensure your projects are always up-to-date."
    }
]