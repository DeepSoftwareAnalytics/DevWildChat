[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "document": "The WebSocket API makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive responses without having to poll the server for a reply.\n\nThe WebSocket API provides two alternative mechanisms for creating and using web socket connections: the interface and the interface.\n• The interface is stable and has good browser and server support. However it doesn't support backpressure. As a result, when messages arrive faster than the application can process them it will either fill up the device's memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\n• The interface is a -based alternative to . It uses the Streams API to handle receiving and sending messages, meaning that socket connections can take advantage of stream backpressure automatically, regulating the speed of reading or writing to avoid bottlenecks in the application. However, is non-standard and currently only supported in one rendering engine.\n\nAdditionally, the WebTransport API is expected to replace the WebSocket API for many applications. WebTransport is a versatile, low-level API that provides backpressure and many other features not supported by either or , such as unidirectional streams, out-of-order delivery, and unreliable data transmission via datagrams. WebTransport is more complex to use than WebSockets and its cross-browser support is not as wide, but it enables the implementation of sophisticated solutions. If standard WebSocket connections are a good fit for your use case and you need wide browser compatibility, you should employ the WebSockets API to get up and running quickly. However, if your application requires a non-standard custom solution, then you should use the WebTransport API."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://apidog.com/blog/javascript-websockets",
        "document": "Have you ever wondered how some apps can update their data in real-time, without requiring you to refresh the page or click a button?\n\nIn this blog post, We will explain what WebSocket is, how it works, and how to use it with JavaScript. We will also show you how to use Apidog to test and debug your APIs.\n\nWebSockets are a powerful tool for real-time communication between a client and a server. They allow for bidirectional communication, which means that data can be sent and received simultaneously. This is in contrast to traditional HTTP requests, which are unidirectional and require a new request to be made for each piece of data.\n\nWebSockets are faster and more efficient than traditional HTTP-based communication methods. They offer low latency, bidirectional communication, scalability, and support for real-time data streaming. WebSockets can handle multiple data streams over one connection, unlike HTTP/1.1, which only allows one stream of structured data at a time.\n\nWebSocket works by establishing a connection between the client and the server using a handshake. The handshake is done using HTTP, where the client sends an upgrade request and the server responds with an upgrade response. The upgrade request and response contain some special headers that indicate that the client and the server want to switch from HTTP to WebSocket.\n\nOnce the handshake is done, the connection is upgraded to WebSocket and the client and the server can exchange messages. The messages are sent and received using a binary format, which is more efficient and faster than HTTP. The messages can be text or binary, and they can have any size and content.\n\nThe connection is kept alive until either the client or the server closes it. The client or the server can close the connection by sending a close frame, which is a special type of message that indicates the end of the communication. The close frame can also contain a reason code and a message that explain why the connection is closed.\n\nWebSockets are a technology that enables continuous, bidirectional, and low-latency communication between web clients and web servers. Some of the benefits of using WebSockets are:\n• They reduce the data transmission overhead compared to HTTP, which uses a request/response cycle and adds headers, cookies, etc. to each message.\n• They are widely adopted and supported by many libraries, frameworks, and browsers, making them easy to use and integrate.\n• They are flexible and allow for the implementation of application-level protocols and extensions, such as pub/sub messaging.\n• They are event-driven and allow the server to push data to the client as soon as it becomes available, without the need for polling. This is useful for realtime applications that need to react quickly to events, such as chat rooms or stock updates.\n• They are full-duplex and allow both the server and the client to send data at the same time, enabling two-way, multi-user communication.\n\nHow to use WebSocket with JavaScript\n\nWebSocket with JavaScript is very easy to use with JavaScript, the most popular scripting language for the web. JavaScript has a built-in object called that provides a simple and intuitive API to create and manage WebSocket connections.\n\nTo use WebSocket with JavaScript, you need to create a WebSocket object with the URL of the server, and then listen to events such as , , , and . You can also send data to the server using the method. Here is a simple example of how to use WebSocket with JavaScript:\n\nThe code uses the WebSocket API to create and manage a WebSocket connection to a server, as well as to send and receive data on the connection. Here is a line-by-line breakdown of the code:\n\nThis line creates a new WebSocket object with the URL of the server that supports the WebSocket protocol. The URL starts with or for secure connections.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that the connection between the browser and the server is successfully established. The function logs a message to the console and then sends a message to the server using the method of the WebSocket object.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event contains the data received from the server in the property. The function logs the data to the console.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that the connection between the browser and the server is closed. The function logs a message to the console.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that there is an error with the connection, such as when some data couldn’t be sent or received. The function logs the error to the console.\n\nHow to use Apidog to debug JavaScript WebSocket?\n\nDebugging WebSockets can be challenging because they use a persistent connection. However, there are several tools available that can help you debug your WebSocket code. One such tool is Apidog, an all-in-one collaborative API development platform. With Apidog, you can learn effective debugging techniques, set up your debugging environment, and leverage advanced tools for a seamless debugging experience.\n\nHere’s how you can use Apidog to debug a WebSocket client:\n• Open Apidog: First, start the Apidog application and click on the \"+\" button on the left side, A new drop-down will be opened. From there choose \"New WebSocket API\":\n\n2. Establish a Connection: Begin by inputting the WebSocket API URL into Apidog's address bar. Then, click the \"Connect\" button to start the handshake process and create a connection. Apidog enables you to customize parameters such as Params, Headers, and Cookies during the handshake.\n\n3. Send and Receive Messages: You can send and receive messages after the connection is established by accessing the \"Message\" tab. You have the option to compose text, JSON, XML, HTML, and other text format messages, as well as binary format messages using Base64 or Hexadecimal. Apidog's new timeline view displays the connection status, sent messages, and received messages in chronological order. Clicking on a message allows you to easily view its details.\n\n4. API Documentation: Apidog inherits powerful API documentation functionality for WebSocket APIs, enabling effective documentation of your WebSocket interactions.\n\nApidog is a simple and powerful tool that allows you to test and debug WebSocket connections. Apidog has a web side and a client side. If you're using the web side and need to debug local services, you'll need to install the Google plugin for Apidog.\n\nWebSocket is awesome because it enables real-time communication between the browser and the server. It allows you to create interactive and engaging web applications that can update their content in real time, without reloading the page. WebSocket can be used for various purposes, such as:\n• Chat: WebSocket can be used to create chat applications that allow users to send and receive messages, emojis, images, videos, or audio in real time. WebSocket can also be used to create group chat, video chat, or voice chat applications that allow users to communicate with multiple people at the same time.\n• Notifications: WebSocket can be used to create notification systems that alert users about important events, such as new messages, new followers, new likes, new comments, or new orders. WebSocket can also be used to create push notifications that can reach users even when they are not on the website, using service workers and web push APIs.\n• Live Data: WebSocket can be used to create live data applications that display dynamic and real-time data, such as stock prices, weather updates, sports scores, news headlines, or social media feeds. WebSocket can also be used to create live data visualization applications that display charts, graphs, maps, or dashboards that can update in real time.\n• Gaming: WebSocket can be used to create gaming applications that allow users to play online games with other users, using real-time graphics, audio, or video. WebSocket can also be used to create multiplayer gaming applications that allow users to join rooms, chat with other players, or share their scores and achievements.\n\nBest Practices for Using Javascript WebSockets\n\nWhen using WebSockets, it is important to follow best practices to ensure that your code is secure and efficient. Here are some best practices to keep in mind:\n\nUse a WebSocket Library: Leverage existing WebSocket libraries to simplify the development process and ensure compatibility across different browsers and devices.\n• Secure Your WebSockets: Always prefer using (WebSocket Secure) over to encrypt data and prevent eavesdropping. This is similar to using HTTPS for secure HTTP connections.\n• Avoid Chatty Protocols: Minimize the number of messages sent over the WebSocket connection to reduce network traffic and improve performance.\n• Consider Network Topology: Be mindful of the network topology of your application, including firewalls and proxy servers, which may affect WebSocket connections.\n• Browser Limitations: Be aware of browser limitations and test your WebSocket implementation across different browsers to ensure consistent behavior.\n• Avoid Blocking Operations: In JavaScript, avoid blocking operations that can freeze the browser’s main thread and disrupt the WebSocket communication.\n• Monitor Memory Usage: Keep an eye on memory usage, as WebSocket connections can potentially lead to memory leaks if not managed properly.\n• Use TLS to Secure Connections: Employ TLS (Transport Layer Security) to secure all connections, ensuring data integrity and privacy.\n• Handle Broken Connections: Implement logic to detect and handle broken WebSocket connections, allowing for automatic reconnection when possible.\n• Scalability: Design your WebSocket infrastructure for scalability, considering the number of open connections and message throughput.\n\nBy following these best practices, you can create robust and efficient WebSocket applications that provide real-time functionality with enhanced security and performance. Remember to always test your implementation thoroughly and keep up with the latest developments in WebSocket technology.\n\nIn conclusion, WebSockets are a powerful tool for real-time communication between a client and server. They allow for bidirectional communication, which is useful for real-time applications like chat rooms and online games.\n\nBy following best practices and using tools like Apidog, you can ensure that your WebSocket code is secure and efficient. So, what are you waiting for? Start using WebSockets in your web applications today!\n\nHere are some additional resources to help you learn more about WebSockets:\n• How to create a WebSocket client in Python? (2024 Tutorial)\n• WebSockets vs HTTP: Which to choose for your project in 2024\n• How to Check If WebSocket Server is Running"
    },
    {
        "link": "https://javascript.info/websocket",
        "document": "The protocol, described in the specification RFC 6455, provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and the need of additional HTTP-requests.\n\nWebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.\n\nTo open a websocket connection, we need to create using the special protocol in the url:\n\nThere’s also encrypted protocol. It’s like HTTPS for websockets.\n\nOnce the socket is created, we should listen to events on it. There are totally 4 events:\n\n…And if we’d like to send something, then will do that.\n\nFor demo purposes, there’s a small server server.js written in Node.js, for the example above, running. It responds with “Hello from server, John”, then waits 5 seconds and closes the connection.\n\nThat’s actually it, we can talk WebSocket already. Quite simple, isn’t it?\n\nWhen is created, it starts connecting immediately.\n\nDuring the connection, the browser (using headers) asks the server: “Do you support Websocket?” And if the server replies “yes”, then the talk continues in WebSocket protocol, which is not HTTP at all.\n\nHere’s an example of browser headers for a request made by .\n• – the origin of the client page, e.g. . WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compatibility issues. But the header is important, as it allows the server to decide whether or not to talk WebSocket with this website.\n• – signals that the client would like to change the protocol.\n• – a random browser-generated key, used to ensure that the server supports WebSocket protocol. It’s random to prevent proxies from caching any following communication.\n• – WebSocket protocol version, 13 is the current one.\n\nIf the server agrees to switch to WebSocket, it should send code 101 response:\n\nHere is , recoded using a special algorithm. Upon seeing it, the browser understands that the server really does support the WebSocket protocol.\n\nAfterwards, the data is transferred using the WebSocket protocol, we’ll see its structure (“frames”) soon. And that’s not HTTP at all.\n\nThere may be additional headers and that describe extensions and subprotocols.\n• means that the browser supports data compression. An extension is something related to transferring the data, functionality that extends the WebSocket protocol. The header is sent automatically by the browser, with the list of all extensions it supports.\n• means that we’d like to transfer not just any data, but the data in SOAP or WAMP (“The WebSocket Application Messaging Protocol”) protocols. WebSocket subprotocols are registered in the IANA catalogue. So, this header describes the data formats that we’re going to use. This optional header is set using the second parameter of . That’s the array of subprotocols, e.g. if we’d like to use SOAP or WAMP:\n\nThe server should respond with a list of protocols and extensions that it agrees to use.\n\nFor example, the request:\n\nHere the server responds that it supports the extension “deflate-frame”, and only SOAP of the requested subprotocols.\n\nWebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:\n• “text frames” – contain text data that parties send to each other.\n• “binary data frames” – contain binary data that parties send to each other.\n• “ping/pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.\n• there’s also “connection close frame” and a few other service frames.\n\nIn the browser, we directly work only with text or binary frames.\n\nWebSocket method can send either text or binary data.\n\nA call allows in string or a binary format, including , , etc. No settings are required: just send it out in any format.\n\nWhen we receive the data, text always comes as string. And for binary data, we can choose between and formats.\n\nThat’s set by property, it’s by default, so binary data comes as objects.\n\nBlob is a high-level binary object, it directly integrates with , and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to :\n\nImagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile internet, outside of a city.\n\nWe can call again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.\n\nThe property stores how many bytes remain buffered at this moment, waiting to be sent over the network.\n\nWe can examine it to see whether the socket is actually available for transmission.\n\nNormally, when a party wants to close the connection (both browser and server have equal rights), they send a “connection close frame” with a numeric code and a textual reason.\n\nThe method for that is:\n• is a string that describes the reason of closing (optional)\n\nThen the other party in the event handler gets the code and the reason, e.g.:\n• – the default, normal closure (used if no supplied),\n• – no way to set such code manually, indicates that the connection was lost (no close frame).\n\nThere are other codes like:\n• – the party is going away, e.g. server is shutting down, or a browser leaves the page,\n• – the message is too big to process,\n\nThe full list can be found in RFC6455, §7.4.1.\n\nWebSocket codes are somewhat like HTTP codes, but different. In particular, codes lower than are reserved, there’ll be an error if we try to set such a code.\n\nTo get connection state, additionally there’s property with values:\n• – “CONNECTING”: the connection has not yet been established,\n\nLet’s review a chat example using browser WebSocket API and Node.js WebSocket module https://github.com/websockets/ws. We’ll pay the main attention to the client side, but the server is also simple.\n\nHTML: we need a to send messages and a for incoming messages:\n\nFrom JavaScript we want three things:\n• On form submission – for the message.\n• On incoming message – append it to .\n\nServer-side code is a little bit beyond our scope. Here we’ll use Node.js, but you don’t have to. Other platforms also have their means to work with WebSocket.\n\nThe server-side algorithm will be:\n• For each accepted websocket, add it to the set and set event listener to get its messages.\n• When a message is received: iterate over clients and send it to everyone.\n\nYou can also download it (upper-right button in the iframe) and run it locally. Just don’t forget to install Node.js and before running.\n\nWebSocket is a modern way to have persistent browser-server connections.\n• They are well-supported in browsers.\n\nWebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it’s also possible to implement these capabilities manually.\n\nSometimes, to integrate WebSocket into existing projects, people run a WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use , a subdomain that leads to the WebSocket server, while goes to the main HTTP-server.\n\nSurely, other ways of integration are also possible."
    },
    {
        "link": "https://websockets.readthedocs.io/en/stable/intro/tutorial1.html",
        "document": "In this tutorial, you’re going to build a web-based Connect Four game.\n\nThe web removes the constraint of being in the same room for playing a game. Two players can connect over of the Internet, regardless of where they are, and play in their browsers.\n\nWhen a player makes a move, it should be reflected immediately on both sides. This is difficult to implement over HTTP due to the request-response style of the protocol.\n\nIndeed, there is no good way to be notified when the other player makes a move. Workarounds such as polling or long-polling introduce significant overhead.\n\nThe WebSocket protocol provides two-way communication between a browser and a server over a persistent connection. That’s exactly what you need to exchange moves between players, via a server.\n\nCreate an file next to and with this content: This HTML page contains an empty element where you will draw the Connect Four board. It loads a script where you will write all your JavaScript code. Create a file next to . In this script, when the page loads, draw the board: Open a shell, navigate to the directory containing these files, and start an HTTP server: Open http://localhost:8000/ in a web browser. The page displays an empty board with seven columns and six rows. You will play moves in this board later.\n\nCreate an file next to with this content: The entry point of this program is . It creates an asyncio event loop, runs the coroutine, and shuts down the loop. The coroutine calls to start a websockets server. takes three positional arguments:\n• None is a coroutine that manages a connection. When a client connects, websockets calls with the connection in argument. When terminates, websockets closes the connection.\n• None The second argument defines the network interfaces where the server can be reached. Here, the server listens on all interfaces, so that other devices on the same local network can connect.\n• None The third argument is the port on which the server listens. Invoking as an asynchronous context manager, in an block, ensures that the server shuts down properly when terminating the program. For each connection, the coroutine runs an infinite loop that receives messages from the browser and prints them. Open a shell, navigate to the directory containing , and start the server: This doesn’t display anything. Hopefully the WebSocket server is running. Let’s make sure that it works. You cannot test the WebSocket server with a web browser like you tested the HTTP server. However, you can test it with websockets’ interactive client. Open another shell and run this command: You get a prompt. Type a message and press “Enter”. Switch to the shell where the server is running and check that the server received the message. Good! Exit the interactive client with Ctrl-C or Ctrl-D. Now, if you look at the console where you started the server, you can see the stack trace of an exception: File , line , in : received 1000 (OK); then sent 1000 (OK) Indeed, the server was waiting for the next message with when the client disconnected. When this happens, websockets raises a exception to let you know that you won’t receive another message on this connection. This exception creates noise in the server logs, making it more difficult to spot real errors when you add functionality to the server. Catch it in the coroutine: Stop the server with Ctrl-C and start it again: You must restart the WebSocket server when you make changes. The WebSocket server loads the Python code in then serves every WebSocket request with this version of the code. As a consequence, changes to aren’t visible until you restart the server. This is unlike the HTTP server that you started earlier with . For every request, this HTTP server reads the target file and sends it. That’s why changes are immediately visible. It is possible to restart the WebSocket server automatically but this isn’t necessary for this tutorial. Try connecting and disconnecting the interactive client again. The exception doesn’t appear anymore. This pattern is so common that websockets provides a shortcut for iterating over messages received on the connection until the client disconnects: Restart the server and check with the interactive client that its behavior didn’t change. At this point, you bootstrapped a web application and a WebSocket server. Let’s connect them.\n\nIn JavaScript, you open a WebSocket connection as follows: Before you exchange messages with the server, you need to decide their format. There is no universal convention for this. Let’s use JSON objects with a key identifying the type of the event and the rest of the object containing properties of the event. Here’s an event describing a move in the middle slot of the board: Here’s how to serialize this event to JSON and send it to the server: Now you have all the building blocks to send moves to the server. // When clicking a column, send a \"play\" event for a move in that column. registers a listener for events on the board. The listener figures out which column was clicked, builds a event of type , serializes it, and sends it to the server. Modify the initialization to open the WebSocket connection and call the function: Check that the HTTP server and the WebSocket server are still running. If you stopped them, here are the commands to start them again: Refresh http://localhost:8000/ in your web browser. Click various columns in the board. The server receives messages with the expected column number. There isn’t any feedback in the board because you haven’t implemented that yet. Let’s do it.\n\nIn JavaScript, you receive WebSocket messages by listening to events. Here’s how to receive a message from the server and deserialize it from JSON: // do something with event You’re going to need three types of messages from the server to the browser: The JavaScript code receiving these messages will dispatch events depending on their type and take appropriate action. For example, it will react to an event of type by displaying the move on the board with the function. // Update the UI with the move. // No further messages are expected; close the WebSocket connection. Why does use ? When modifies the state of the board, the browser renders changes asynchronously. Conversely, runs synchronously and blocks rendering while the alert is visible. If you called immediately after , the browser could display the alert before rendering the move. You could get a “Player red wins!” alert without seeing red’s last move. We’re using for simplicity in this tutorial. A real application would display these messages in the user interface instead. It wouldn’t be vulnerable to this problem. Modify the initialization to call the function: At this point, the user interface should receive events properly. Let’s test it by modifying the server to send some events. Sending an event from Python is quite similar to JavaScript: Don’t forget to serialize the event with . Modify the coroutine in as follows: Restart the WebSocket server and refresh http://localhost:8000/ in your web browser. Seven moves appear at 0.5 second intervals. Then an alert announces the winner. Good! Now you know how to communicate both ways. Once you plug the game engine to process moves, you will have a fully functional game."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://medium.com/@bootcampmillionaire/what-i-learned-about-websockets-by-building-a-real-time-chat-application-using-socket-io-3d9e163e504",
        "document": "Developers Michael Carter and Ian Hickson started working on WebSockets in 2008 in response to the problems outlined above. WebSockets are two things: a set of rules for client and server on how to establish communication and transmit data to each other; and a transport layer for data exchange. WebSockets support exchange of a variety of data formats including JSON and XML.\n\nIn a normal HTTP 1.0 request, a client initiates a request to a server. The client informs the server that it wants to do something with a particular resource. The client also sends information about the url at which the resource can be found. This information is contained inside a request header, along with an explicit statement of the HTTP protocol to be used (in this case 1.0).\n\nThe server then sends a response with a status code that gives information about the success of the request, about the content being sent, in addition to the content itself.\n\nAll of this takes place over a TCP/IP socket. WebSockets are built on top of the TCP layer (a data-transport protocol that depends on two hosts having a connection before any data can be sent), and modify the TCP/IP socket so that client and server can agree for the socket to stay open.\n\nKeeping this socket open is the crucial step in enabling bidirectional communication. Without this, there would be no WebSockets, and using the web would still revolve around a request — response cycle, wherein a user would always have initiate the request to the server to do something with some data.\n\nWith the connection persisted, all that remains is for an agreement to be reached about how the data being exchanged should be interpreted by both parties. This is known as a WebSocket handshake.\n\nA WebSocket handshake is much like simple HTTP GET request, but this request contains an ‘upgrade header’, which requests that the server switches to a binary protocol using a WebSocket and gives some information about the WebSocket connection. The server responds with a 101 header to confirm that it is switching protocols, and the WebSocket is open. Real-time data exchange between multiple clients and a server can now take place.\n\nThe image below shows a normal everyday HTTP GET request header. We see that the connection uses HTTP 1.1, and as a result, the ‘Connection’ is set to ‘keep-alive’. Readers will recall that this functionality was introduced in HTTP 1.1 and allowed a persistent connection between client and server to be kept open. This formed the foundation of WebSockets.\n\nNext, we can see an example of an ‘upgrade header’. One of the first things that we notice is that the request URL is prepended with ‘ws://’ as opposed to ‘HTTP://’. This tells us that a request is being made to use the WebSockets protocol as opposed to HTTP. We can also see a ‘Connection’ header and an ‘Upgrade’ header. The former attempts to upgrade the connection to a binary protocol, while the latter allows the client to specify which protocol they would like to upgrade to, in this case, WebSocket.\n\nProviding the request is successful, a WebSocket connection has been made. The server can now emit, via a WebSocket, real-time updates on football scores, chat messages from the client’s friends and more. Not only that, it can do so unprompted by an initiating request from the client, and it can do it over, and over, and over again.\n\nLikewise, the client can send whatever it chooses, whenever it chooses, providing the connection is kept open and the request being sent is in accordance with the agreement reached by both parties during the WebSocket handshake and upgrade process.\n\nThe significance of this technological innovation is not to be underestimated. It has transformed the way we use the web, and spawned untold amounts of innovation in the way technology entertains and serves us.\n\nAnd it all boils down to the WebSocket handshake process, complete with a request from client to server containing an upgrade header, sent across a persisted connection enabled by both parties agreeing to keep a TCIP/IP socket open.\n\nSo what does implementing this fantastic technology involve? I took a look at a popular WebSocket library to get a feel for how difficult WebSockets are to implement.\n\nOne of the most popular libraries enabling users to use WebSockets in their projects is Socket.IO. But what exactly is Socket.IO?\n\nWell, according to their website,\n\nAt its most simple, then, Socket.IO simply adds a syntactic ‘wrapper’ around the standard WebSockets API found in node, making it slightly easier to read and work with.\n\nI was interested to read in Socket.IO’s documentation, under a section titled ‘What Socket.IO is not’, that Socket.IO is NOT a WebSocket implementation.\n\nSo what is it then?\n\nSocket.IO’s purpose is to enable “real-time, bidirectional and event-based communication between the browser and the server”. Most of the time, this means giving us a slightly more usable interface than the WebSocket API that comes with Node.\n\nSometimes, however, WebSockets can be difficult to establish, for example in the presence of proxies or load balancers. In these cases, Socket.IO will use Engine.IO to establish a long-polling connection between server and client, while trying to upgrade to better transports like WebSocket.\n\nIn brief, long-polling is a method of maintaining a close-to-persistent connection between client and server. In long-polling, the client sends a request to the server, and the connection is not closed until the server responds. Immediately following the response and the closing of the connection, the browser resends the request, thereby reopening the connection. While this does create the impression of a persistent connection between client and server, it does not truly enable bidirectional communication, and is a far less versatile than WebSockets.\n\nA quick look at at Socket.IO’s ‘Emit cheat sheet’ gives an idea of the simplicity and versatility of WebSockets with Socket.IO.\n\nMy first reflection on Socket.IO was how simple it was to use. Just a few simple steps can open up a world of possibilities.\n\n1. Require the web server and pass in the port on which you want to listen\n\n3. Within the body of the connection, send or emit events, listen for specific events, and broadcast to all clients except the sender, and much more.\n\nWhile over on the client side, all I had to do was:\n• Create a WebSocket and listen on the port where my app is being hosted\n• Set up event listeners to listen for specific events\n• Create event emitters for when the client wants to send data back to the server.\n\nIndeed, there doesn’t seem to be much to using WebSockets at all. In short, we can create a server-side Socket object by simply importing the Socket.IO library and setting the port we want to listen on. Logging the Socket object to the console gives us a good idea of what it looks like.\n\nAs we can see from the images above, the Socket object contains a wealth of information about the connection between client and server, as well as exposing methods for event handling, error handling, and much more. In the images above, for example, we can see that there is a count of how many clients are connected to the server, and that each socket has a unique ID.\n\nPutting it into practice: using Socket.IO to build a real-time chat application\n\nTo learn even more about Socket.IO, I followed this excellent tutorial by Web Dev Simplified, that uses Socket.IO to build a real-time chat app.\n\nI condensed the process down into 16 steps, which I walk you through below.\n\nBecause this activity focuses specifically on the implementation of WebSockets, we are not too concerned with the front end logic, but it should be noted that there are more ideal solutions to building out a front end for an app like this. We use a pre-built front end available here.\n\nTo run the front end code, I used the amazing Live Server extension for Visual Studio code.\n\n1. First things first, you need to make a project folder. Grab the from the link above, and put it in your project folder. Use Live Server to launch your front end server and see your html in the browser.\n\n2. We will need a few dependencies for this project to work. Set up your project as a node project by running in the command line. Install Socket.IO, and Nodemon as a development dependency, by running followed by . Nodemon will restart the server every time we make a change in the backend.\n\n3. In the file, replace the entire section with the code block below. This will allow us to start our server by running in the command line.\n\n4. Create a file which will hold our server code.\n\n5. Now for the fun part. Go into your file and bring in the Socket.IO using syntax. Socket.IO allows us to pass in the port that we want our server to run on as part of the statement, which is neat and intuitive.\n\n6. Now we have created a server, we can listen for connections. Using Socket.IO’s simple method, we can listen for a connection event and open a WebSocket for each individual user who makes a connection. The server can a response to each user through this socket using the method, where the first parameter is the name of the event and the second is the data. In Socket.IO, there are some reserved event names that should not be used to name your events. Outside of this list, you are free to name events whatever you want, giving us the ability to write server code that is easy to understand. In the example below, on each connection to our WebSocket from a client, we send back a string called with the text\n\n7. We can listen for connections on the server side. Now we need to handle the client side. Create a file which will store the client-side javascript. In this file, simply create a socket connection by passing in the url where we are hosting our application to Socket.IO’s special function, which is available in global scope for use.\n\n8. Now we have a client side socket connection set up, we can listen for the event that we named above using the method, passing in a callback function which takes the data we passed down from the server side (the string ) as a parameter. Add this code in to your file\n\n9. To allow users to send messages to each other, we need to capture the data in the input field when the user presses send or submit. We handle this on the client side by grabbing the input field, grabbing the submit button, and adding an event listener. It is important to prevent the default submit behaviour (a page refresh) to stop the page from reloading and the messages being wiped. We do this inside the event listener callback.\n\n10. Also inside the event listener callback, we grab the value from the input field, before repeating the socket.emit behaviour from step 6, which sends the message data back from the client side to the server side, again in the form of an event. We will name the event . Finally we reset the value of the input field to an empty string, thereby clearing it.\n\n11. We have emitted an event from the client to the containing a message string. Now we need to listen for the event on the server side using the familiar method. We can then take this event and use the to send the event to all clients except the sender.\n\n12. Back on the client side in , add a function that appends a message to the DOM each time a message is sent. We also need to prompt the user to give their name in order to be able to identify who sent each message. We then this event from the client side to announce that a new user has joined the chat. We name the event and it with the user’s name that we capture from a javascript prompt.\n\nUnderneath our call to add the following:\n\n13. To handle the event on the server side, we again need to listen for the event using the method. Because each WebSocket has its own unique ID, we can use this as the unique reference for each user, and store these on a users object. Now we can get the user’s name by looking at the users object to see what name is stored next to the socket ID. We then broadcast this users connection to all other users using another on our socket, emitting an event with the name and the name. We will also update our event to pass down an object containing both the message and the user’s name.\n\n14. Now we can use these changes on the client side. Modify the event to append both the message and the user’s name on receiving a broadcast. We also want to update the event listener on our message form so that the DOM shows the user their own messages too.\n\n15. Finally, we handle what happens when a user disconnects. Inside our , we use the trusty method, but this time we listen for an inbuilt event named , passing an anonymous function in which we an event which we name , and pass the user’s name, referring to the appropriate socket.id property on our users object. Then we use the keyword to delete the user from our users object.\n\nThe final version of our should now look like this:\n\n16. The corresponding client side change should be predictable by now. We use to listen for the event, and append to the DOM a message announcing that the user left. Your should now look like the code block below. Congratulations, you just built a real-time chat app in 16 steps.\n\nYour file should now look like this:\n\nReflections on my experience using Socket.IO\n\nAs someone who is relatively new to web development, the idea of learning about another new technology and its implementations can seem like a daunting task.\n\nThe beauty of WebSocket APIs like WebSocket or libraries that perform similar functions such as Socket.IO, is that they abstract away all of the complexity that it takes to create a persistent connection between client and server.\n\nTake the example of our chat app. Despite its flaws, we created an app in just 16 steps that can allow many individual clients to join and exchange messages, and we only used three of the methods exposed by the WebSocket: , , and .\n\nIt is clear, then that WebSockets are not only extremely useful in supporting the modern web experience, but they’re also not too difficult to use. Libraries like Socket.IO make the experience even easier, and their easy-to-use documentation makes troubleshooting any problems a breeze.\n\nI’m glad I finally got to take a look at WebSockets, and I’m glad I did so through Socket.IO’s intuitive and user-friendly library. I look forward to exploring the Socket.IO library even further in future projects."
    },
    {
        "link": "https://emily-elim04.medium.com/building-real-time-apps-using-websockets-dc137ccdd34b",
        "document": "As a developer, (especially a new one like me) it can be intimidating opening yourself up to learning about the world of technology. Every day I often find myself saying “What the heck is that?!”. And every day, after doing a little research on my previously stated conundrum, I also find myself saying “Wow, that is so neat!”. (I’m serious I do say that…) However, that is what I love most about becoming a software developer, the continuous learning that it provides me with. Speaking of continuous learning… one of those topics that gave me a big question mark over my head was WebSockets. So, I thought I would write an intro guide on what I learned and how they are used in real-time applications. Cue the lights, the music, …. let’s get into WebSockets.\n\nSo what exactly is a WebSocket?\n\nWell person of the internet, I am glad you asked. According to the MDN Web Docs the WebSocket API is …\n\nWait… What is normally used?\n\nBefore we dive deep into WebSockets, let’s take a step back and look at HTTP. The HTTP protocol is a set of rules for how computers communicate on the web. It allows for the fetching of resources and is the foundation of any data exchange. It works as a request/response mechanism where a connection is open, a request is sent from the client(eg. the web browser), the server sends a response back and the connection is closed. HTTP is unidirectional, only the client can send a request to the server, and it must wait until the server sends back a separate response for each request. A common example used for this type of communication is a kitchen in a restaurant.\n• You, as the client place an order (HTTP request) and a waiter takes that order to the back kitchen (aka the server).\n• The kitchen receives the order and confirms that the order is correct (an item on the menu).\n• If the kitchen knows how to make it, they will find the ingredients to prepare the order (which is like the server processing the request and fetching data from a database to prepare the response) and will send the food back with the waiter as a successful response.\n• Say you asked for something not on the menu, well the kitchen might not accept that order or maybe doesn’t have the ingredients to prepare it so the kitchen will send the waiter back with a message that they can’t complete the request. Similarly to the server sending back an error message or status code 404.\n\nIt is also important to highlight that HTTP is “stateless”, it doesn’t know who specifically the request is coming from (ie. the kitchen doesn’t know who you specifically are when ordering the food). It treats and fulfills every request independently. Because this protocol is unidirectional, the kitchen (server) isn’t able to send the waiter back to you if there is a question they want to ask or update your order. It can only send a response after YOU specifically send the request in. The only way for you to get updated information from the kitchen is if you send the requests through the waiter. In a HTTP protocol the connection is closed after the response has been sent back from the server. This protocol does not lend itself well to real-time applications as a user would have to refresh the page every time they wanted to see an update to the page which, could be quite frustrating.\n\nBefore WebSockets were created, several ways that developers would create a work around for this problem were through short polling, long polling or server-sent events (SSE). We won’t get into the nitty gritty details about these but lets just say these solutions were not the most effective for real-time applications and some were not supported by older browsers.\n\nTo put it simply, WebSockets are just another protocol for sending and receiving messages. Similar to HTTP, they both send messages over a TCP (Transmission Control Protocol) connection. The only difference is how they structure the messages. WebSockets allow for a bidirectional, real-time communication between clients and servers. Once the connection is established between the client and server, it is kept alive until it is terminated by either party. Messages can be sent back and forth between the the client and the server until one of them dies or decides to close the connection. The WebSockets API allow the server to be able to keep track of each client and push messages to a subset of clients.\n\nHow does it work?\n\nLooking at the kitchen example again, if you were using a WebSocket, now you and the kitchen both have an open connection for the duration you are at the restaurant. You can both send requests/responses to each other until someone leaves the connection or terminates it.\n\nTo establish a WebSocket connection the client can send an HTTP “hand shake” request with an upgraded header, specifying that the client wants to establish a WebSocket connection. This request is sent to a ws: or wss: URI and if the server is able to establish the connection, it will send a successful response back and the handshake is complete. The TCP/IP connection is left open, allowing bidirectional messages to pass through between each party. This is often referred to as a full-duplex connection.\n\nWhat are they used for?\n\nAs mentioned above, they can be used for real-time web applications. Say you have an interview scheduler app and the calendar being displayed needs to be updated every time a new interview is booked or cancelled. WebSockets provide the perfect solution to this to make sure each user is looking at the most up to date calendar. Another place you might want to use WebSockets is in a multiplayer gaming application where you have a leaderboard that is constantly changing on the server. Alternatively you could also use this for building a chat application. In a chat app, users are constantly sending messages to recipients and the server needs to be able to push these messages to the right recipients and allow for multiple messages to be sent to multiple people at once.\n\nIf you want to learn more, I found that this youtube video below by Fireship to be helpful in providing a quick review!"
    },
    {
        "link": "https://spring.io/guides/gs/messaging-stomp-websocket",
        "document": "This guide walks you through the process of creating a “Hello, world” application that sends messages back and forth between a browser and a server. WebSocket is a thin, lightweight layer above TCP. This makes it suitable for using “subprotocols” to embed messages. In this guide, we use STOMP messaging with Spring to create an interactive web application. STOMP is a subprotocol operating on top of the lower-level WebSocket.\n\nHow to complete this guide Like most Spring Getting Started guides, you can start from scratch and complete each step or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Starting with Spring Initializr. To skip the basics, do the following:\n• Download and unzip the source repository for this guide, or clone it using Git: When you finish, you can check your results against the code in .\n\nYou can use this pre-initialized project and click Generate to download a ZIP file. This project is configured to fit the examples in this tutorial.\n• Navigate to https://start.spring.io. This service pulls in all the dependencies you need for an application and does most of the setup for you.\n• Choose either Gradle or Maven and the language you want to use. This guide assumes that you chose Java.\n• Download the resulting ZIP file, which is an archive of a web application that is configured with your choices. If your IDE has the Spring Initializr integration, you can complete this process from your IDE. You can also fork the project from Github and open it in your IDE or other editor.\n\nNow that you have set up the project and build system, you can create your STOMP message service. Begin the process by thinking about service interactions. The service will accept messages that contain a name in a STOMP message whose body is a JSON object. If the name is , the message might resemble the following: To model the message that carries the name, you can create a plain old Java object with a property and a corresponding method, as the following listing (from ) shows: package com.example.messagingstompwebsocket; public class HelloMessage { private String name; public HelloMessage() { } public HelloMessage(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Upon receiving the message and extracting the name, the service will process it by creating a greeting and publishing that greeting on a separate queue to which the client is subscribed. The greeting will also be a JSON object, which as the following listing shows: To model the greeting representation, add another plain old Java object with a property and a corresponding method, as the following listing (from ) shows: Spring will use the Jackson JSON library to automatically marshal instances of type into JSON. Next, you will create a controller to receive the hello message and send a greeting message.\n\nIn Spring’s approach to working with STOMP messaging, STOMP messages can be routed to classes. For example, the (from ) is mapped to handle messages to the destination, as the following listing shows: This controller is concise and simple, but plenty is going on. We break it down step by step. The annotation ensures that, if a message is sent to the destination, the method is called. The payload of the message is bound to a object, which is passed into . Internally, the implementation of the method simulates a processing delay by causing the thread to sleep for one second. This is to demonstrate that, after the client sends a message, the server can take as long as it needs to asynchronously process the message. The client can continue with whatever work it needs to do without waiting for the response. After the one-second delay, the method creates a object and returns it. The return value is broadcast to all subscribers of , as specified in the annotation. Note that the name from the input message is sanitized, since, in this case, it will be echoed back and re-rendered in the browser DOM on the client side.\n\nNow that the essential components of the service are created, you can configure Spring to enable WebSocket and STOMP messaging. Create a Java class named that resembles the following listing (from ): is annotated with to indicate that it is a Spring configuration class. It is also annotated with . As its name suggests, enables WebSocket message handling, backed by a message broker. The method implements the default method in to configure the message broker. It starts by calling to enable a simple memory-based message broker to carry the greeting messages back to the client on destinations prefixed with . It also designates the prefix for messages that are bound for methods annotated with . This prefix will be used to define all the message mappings. For example, is the endpoint that the method is mapped to handle. The method registers the endpoint for websocket connections.\n\nWith the server-side pieces in place, you can turn your attention to the JavaScript client that will send messages to and receive messages from the server side. Create an file similar to the following listing (from ): <!DOCTYPE html> <html> <head> <title>Hello WebSocket</title> <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"> <link href=\"/main.css\" rel=\"stylesheet\"> <script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/@stomp/[email protected]/bundles/stomp.umd.min.js\"></script> <script src=\"/app.js\"></script> </head> <body> <noscript><h2 style=\"color: #ff0000\">Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!</h2></noscript> <div id=\"main-content\" class=\"container\"> <div class=\"row\"> <div class=\"col-md-6\"> <form class=\"form-inline\"> <div class=\"form-group\"> <label for=\"connect\">WebSocket connection:</label> <button id=\"connect\" class=\"btn btn-default\" type=\"submit\">Connect</button> <button id=\"disconnect\" class=\"btn btn-default\" type=\"submit\" disabled=\"disabled\">Disconnect </button> </div> </form> </div> <div class=\"col-md-6\"> <form class=\"form-inline\"> <div class=\"form-group\"> <label for=\"name\">What is your name?</label> <input type=\"text\" id=\"name\" class=\"form-control\" placeholder=\"Your name here...\"> </div> <button id=\"send\" class=\"btn btn-default\" type=\"submit\">Send</button> </form> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <table id=\"conversation\" class=\"table table-striped\"> <thead> <tr> <th>Greetings</th> </tr> </thead> <tbody id=\"greetings\"> </tbody> </table> </div> </div> </div> </body> </html> This HTML file imports the javascript library that will be used to communicate with our server through STOMP over websocket. We also import , which contains the logic of our client application. The following listing (from ) shows that file: const stompClient = new StompJs.Client({ brokerURL: 'ws://localhost:8080/gs-guide-websocket' }); stompClient.onConnect = (frame) => { setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', (greeting) => { showGreeting(JSON.parse(greeting.body).content); }); }; stompClient.onWebSocketError = (error) => { console.error('Error with websocket', error); }; stompClient.onStompError = (frame) => { console.error('Broker reported error: ' + frame.headers['message']); console.error('Additional details: ' + frame.body); }; function setConnected(connected) { $(\"#connect\").prop(\"disabled\", connected); $(\"#disconnect\").prop(\"disabled\", !connected); if (connected) { $(\"#conversation\").show(); } else { $(\"#conversation\").hide(); } $(\"#greetings\").html(\"\"); } function connect() { stompClient.activate(); } function disconnect() { stompClient.deactivate(); setConnected(false); console.log(\"Disconnected\"); } function sendName() { stompClient.publish({ destination: \"/app/hello\", body: JSON.stringify({'name': $(\"#name\").val()}) }); } function showGreeting(message) { $(\"#greetings\").append(\"<tr><td>\" + message + \"</td></tr>\"); } $(function () { $(\"form\").on('submit', (e) => e.preventDefault()); $( \"#connect\" ).click(() => connect()); $( \"#disconnect\" ).click(() => disconnect()); $( \"#send\" ).click(() => sendName()); }); The main pieces of this JavaScript file to understand are the and functions. is initialized with referring to path , which is where our websockets server waits for connections. Upon a successful connection, the client subscribes to the destination, where the server will publish greeting messages. When a greeting is received on that destination, it will append a paragraph element to the DOM to display the greeting message. The function retrieves the name entered by the user and uses the STOMP client to send it to the destination (where will receive it). The can be omitted if you like, or you can create an empty one, just so the can be resolved.\n\nSpring Boot creates an application class for you. In this case, it needs no further modification. You can use it to run this application. The following listing (from ) shows the application class: is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a .\n• : Tells Spring to look for other components, configurations, and services in the package, letting it find the controllers. The method uses Spring Boot’s method to launch an application. Did you notice that there was not a single line of XML? There is no file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure. You can run the application from the command line with Gradle or Maven. You can also build a single executable JAR file that contains all the necessary dependencies, classes, and resources and run that. Building an executable jar makes it easy to ship, version, and deploy the service as an application throughout the development lifecycle, across different environments, and so forth. If you use Gradle, you can run the application by using . Alternatively, you can build the JAR file by using and then run the JAR file, as follows: If you use Maven, you can run the application by using . Alternatively, you can build the JAR file with and then run the JAR file, as follows: The steps described here create a runnable JAR. You can also build a classic WAR file. Logging output is displayed. The service should be up and running within a few seconds."
    },
    {
        "link": "https://stackoverflow.com/questions/33695383/chat-application-using-websockets",
        "document": "I have been able to use Websockets to create a chat application between users using https://github.com/ghedipunk/PHP-Websockets.\n\nWhat the server does is stores all the created socket object variables in an array when each user connects to the socket. So, ultimately he creates an array which has info regarding all users with the socket object. And he loops through the array each time to retrieve the object of a user so that message can be sent to the respective socket.\n\nThis will be fine for small amount of users. But how do we handle huge amounts of users? I thought of storing socket objects in DB but then I came across this: How to save php socket resource in database?\n\nWhich says \"Sockets have to be recreated and cannot be stored in DB\".\n\nSo, is there any better option rather than recreating? And if I have to recreate the socket, how do I do it using the PHP-Websockets library?"
    }
]