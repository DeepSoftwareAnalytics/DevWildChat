[
    {
        "link": "https://networkx.org/documentation/stable/tutorial.html",
        "document": "This guide can help you start working with NetworkX.\n\nThe graph can be grown in several ways. NetworkX includes many graph generator functions and facilities to read and write graphs in many formats. To get started though we’ll look at simple manipulations. You can add one node at a time, or add nodes from any iterable container, such as a list You can also add nodes along with node attributes if your container yields 2-tuples of the form : Node attributes are discussed further below. Nodes from one graph can be incorporated into another: now contains the nodes of as nodes of . In contrast, you could use the graph as a node in . The graph now contains as a node. This flexibility is very powerful as it allows graphs of graphs, graphs of files, graphs of functions and much more. It is worth thinking about how to structure your application so that the nodes are useful entities. Of course you can always use a unique identifier in and have a separate dictionary keyed by identifier to the node information if you prefer. You should not change the node object if the hash depends on its contents.\n\ncan also be grown by adding one edge at a time, or by adding any ebunch of edges. An ebunch is any iterable container of edge-tuples. An edge-tuple can be a 2-tuple of nodes or a 3-tuple with 2 nodes followed by an edge attribute dictionary, e.g., . Edge attributes are discussed further below. There are no complaints when adding existing nodes or edges. For example, after removing all nodes and edges, we add new nodes/edges and NetworkX quietly ignores any that are already present. At this stage the graph consists of 8 nodes and 3 edges, as can be seen by: The order of adjacency reporting (e.g., , , ) is the order of edge addition. However, the order of G.edges is the order of the adjacencies which includes both the order of the nodes and each node’s adjacencies. See example below:\n\nWe can examine the nodes and edges. Four basic graph properties facilitate reporting: , , and . These are set-like views of the nodes, edges, neighbors (adjacencies), and degrees of nodes in a graph. They offer a continually updated read-only view into the graph structure. They are also dict-like in that you can look up node and edge data attributes via the views and iterate with data attributes using methods , . If you want a specific container type instead of a view, you can specify one. Here we use lists, though sets, dicts, tuples and other containers may be better in other contexts. # the number of edges incident to 1 One can specify to report the edges and degree from a subset of all nodes using an nbunch. An nbunch is any of: (meaning all nodes), a node, or an iterable container of nodes that is not itself a node in the graph.\n\nWhat to use as nodes and edges# You might notice that nodes and edges are not specified as NetworkX objects. This leaves you free to use meaningful items as nodes and edges. The most common choices are numbers or strings, but a node can be any hashable object (except ), and an edge can be associated with any object using . As an example, and could be protein objects from the RCSB Protein Data Bank, and could refer to an XML record of publications detailing experimental observations of their interaction. We have found this power quite useful, but its abuse can lead to surprising behavior unless one is familiar with Python. If in doubt, consider using to obtain a more traditional graph with integer labels.\n\nThe class provides additional methods and properties specific to directed edges, e.g., , , , etc. To allow algorithms to work with both classes easily, the directed versions of is equivalent to while reports the sum of and even though that may feel inconsistent at times. Some algorithms work only for directed graphs and others are not well defined for directed graphs. Indeed the tendency to lump directed and undirected graphs together is dangerous. If you want to treat a directed graph as undirected for some measurement you should probably convert it using or with\n\nNetworkX can be configured to use separate thrid-party backends to improve performance and add functionality. Backends are optional, installed separately, and can be enabled either directly in the user’s code or through environment variables. Several backends are available to accelerate NetworkX–often significantly–using GPUs, parallel processing, and other optimizations, while other backends add additional features such as graph database integration. Multiple backends can be used together to compose a NetworkX runtime environment optimized for a particular system or use case. Refer to the Backends section to see a list of available backends known to work with the current stable release of NetworkX. NetworkX uses backends by dispatching function calls at runtime to corresponding functions provided by backends, either automatically via configuration variables, or explicitly by hard-coded arguments to functions. Automatic dispatch is possibly the easiest and least intrusive means by which a user can use backends with NetworkX code. This technique is useful for users that want to write portable code that runs on systems without specific backends, or simply want to use backends for existing code without modifications. The example below configures NetworkX to automatically dispatch to a backend named for all NetworkX functions that supports.\n• None If does not support a NetworkX function used by the application, the default NetworkX implementation for that function will be used.\n• None If is not installed on the system running this code, an exception will be raised. # runs using backend from NETWORKX_BACKEND_PRIORITY, if set The equivalent configuration can be applied to NetworkX directly to the code through the NetworkX global parameters, which may be useful if environment variables are not suitable. This will override the corresponding environment variable allowing backends to be enabled programatically in Python code. However, the tradeoff is slightly less portability as updating the backend specification may require a small code change instead of simply updating an environment variable. Automatic dispatch using the environment variable or the global config also allows for the specification of multiple backends, ordered based on the priority which NetworkX should attempt to dispatch to. The following examples both configure NetworkX to dispatch functions first to if it supports the function, then if does not, then finally the default NetworkX implementation if no backend specified can handle the call. NetworkX includes debug logging calls using Python’s standard logging mechanism. These can be enabled to help users understand when and how backends are being used. To enable debug logging only in NetworkX modules: or to enable it globally: Backends can also be used explicitly on a per-function call basis by specifying a backend using the keyword argument. This technique not only requires that the backend is installed, but also requires that the backend implement the function, since NetworkX will not fall back to the default NetworkX implementation if a backend is specified with . This is possibly the least portable option, but has the advantage that NetworkX will raise an exception if cannot be used, which is useful for users that require a specific implementation. Explicit dispatch can also provide a more interactive experience and is especially useful for demonstrations, experimentation, and debugging. The NetworkX dispatcher allows users to use backends for NetworkX code in very specific ways not covered in this tutorial. Refer to the Backends reference section for details on topics such as:\n• None Control of how specific function types (algorithms vs. generators) are dispatched to specific backends\n• None Details on automatic conversions to/from backend and NetworkX graphs for dispatch and fallback"
    },
    {
        "link": "https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.adjacency_matrix.html",
        "document": "The rows and columns are ordered according to the nodes in . If (the default), then the ordering is produced by . The desired data-type for the array. If , then the NumPy default is used. The edge data key used to provide each value in the matrix. If None, then each edge has weight 1.\n\nFor directed graphs, entry corresponds to an edge from to .\n\nIf you want a pure Python adjacency matrix representation try which will return a dictionary-of-dictionaries format that can be addressed as a sparse matrix.\n\nFor multigraphs with parallel edges the weights are summed. See for other options.\n\nThe convention used for self-loop edges in graphs is to assign the diagonal matrix entry value to the edge weight attribute (or the number 1 if the edge has no weight attribute). If the alternate convention of doubling the edge weight is desired the resulting SciPy sparse array can be modified as follows:"
    },
    {
        "link": "https://networkx.org/documentation/stable/reference/drawing.html",
        "document": "NetworkX provides basic functionality for visualizing graphs, but its main goal is to enable graph analysis rather than perform graph visualization. In the future, graph visualization functionality may be removed from NetworkX or only available as an add-on package.\n\nProper graph visualization is hard, and we highly recommend that people visualize their graphs with tools dedicated to that task. Notable examples of dedicated and fully-featured graph visualization tools are Cytoscape, Gephi, Graphviz and, for LaTeX typesetting, PGF/TikZ. To use these and other such tools, you should export your NetworkX graph into a format that can be read by those tools. For example, Cytoscape can read the GraphML format, and so, might be an appropriate choice.\n\nFor the possible resulting shape is a square of side [0, scale] (default: [0, 1]) Changing shifts the layout by that amount. For the other layout routines, the extent is [center - scale, center + scale] (default: [-1, 1]). Warning: Most layout routines have only been tested in 2-dimensions. Position nodes uniformly at random in the unit square. Returns scaled position array to (-scale, scale) in all axes. Position nodes using the eigenvectors of the graph Laplacian.\n\nExport NetworkX graphs in LaTeX format using the TikZ library within TeX/LaTeX. Usually, you will want the drawing to appear in a figure environment so you use . If you want the raw drawing commands without a figure environment use . And if you want to write to a file instead of just returning the latex code as a string, use . To construct a figure with subfigures for each graph to be shown, provide or a list of graphs, a list of subcaptions, and a number of rows of subfigures inside the figure. To be able to refer to the figures or subfigures in latex using , the keyword is available for figures and for a list of labels, one for each subfigure. We intend to eventually provide an interface to the TikZ Graph features which include e.g. layout algorithms. Let us know via github what you’d like to see available, or better yet give us some code to do it, or even better make a github pull request to add the feature. Drawing options can be stored on the graph as node/edge attributes, or can be provided as dicts keyed by node/edge to a string of the options for that node/edge. Similarly a label can be shown for each node/edge by specifying the labels as graph node/edge attributes or by providing a dict keyed by node/edge to the text to be written for that node/edge. Options for the tikzpicture environment (e.g. “[scale=2]”) can be provided via a keyword argument. Similarly default node and edge options can be provided through keywords arguments. The default node options are applied to the single TikZ “path” that draws all nodes (and no edges). The default edge options are applied to a TikZ “scope” which contains a path for each edge. You can change many features of the nodes and edges. Then compile the LaTeX using something like and view the pdf file created: . If you want subfigures each containing one graph, you can input a list of graphs. If you want to change the preamble/postamble of the figure/document/subfigure environment, use the keyword arguments: , , . The default values are stored in private variables e.g. Return a string of the LaTeX/TikZ code to draw Return latex code to draw the graph(s) in Write the latex code to draw the graph(s) onto ."
    },
    {
        "link": "https://walkenho.github.io/graph-theory-and-networkX-part1",
        "document": "This is the first post in a series of blogposts about graph theory and NetworkX. In this series of blogposts, I will give a short (and very basic!) introduction into some of the basic concepts and terminology found in graph theory and show how to practically carry out some of the related calculations using the python library NetworkX.\n\nIn this first post of the series, after looking at some applications of graph theory in the real world, we will see how to create some basic graphs from scratch, load them into networkX and do some basic visualization. You can find the full jupyter notebook here on my github.\n\nA graph is a collection of nodes or vertices connected to each other through a collection of edges. Graphs come in two flavours, directed or undirected, each of them with their own application. Graphs with multiple edges (sometimes multiple type of edges) between the same pair of vertices are called multigraphs. The term network is often applied to a graph in which attributes (e.g. names) are associated with the nodes and/or edges.\n\nHistorically, the first example of the use of graph theory is Euler’s problem of the Seven Bridges of Königsberg. Today it is used in a variety of contexts, including statistical and particle physics, computer science, electrical engineering, biology, economics, finance, operations research, climatology and sociology. A few more prominent examples are: In computer science, graphs are used to represent networks of communication or data flow. Google uses graph theory to determine the importance of websites. In linguistics, graph theory is for example used to describe and analyze semantic networks and it has given birth to projects like WordNet. In social science, graph theory is used for social network analysis. In physics it has applications in a wide range of topics from the analysis of electric circuits to studying the properties of solid states. In medicine it can be used to model the spread of epidemics.\n\nGraphs in networkX can be created in a few different ways:\n• We can load a graph from a file containing an adjacency list.\n• We can load a graph from a file containing an edge list.\n• We can create a graph from an adjacency matrix.\n• We can create a graph from a pandas dataframe.\n• We can create an empty graph and add the vertices and edges either one by one or from a list.\n• Finally, some special graphs (complete graphs, complete bipartite graphs, …) can be created using special functions.\n\nOnce a graph is created we can additional vertices and edges.\n\nIn this post I will demonstrate how to do the first five cases, I might deal with the case of creating special graphs in a future post.\n\nBut first we need to import some modules.\n\nIn an adjacency list, each entry symbolizes the egdes between the first one and all the other ones on the same line. Note that in an undirected network, there is no need to define an edge twice. For example loading the adjacency list\n\ncreates a graph with 6 nodes named 0 to 5 as well as 6 edges. Node 0 is connected to nodes 1, 2 and 3, node 1 is connected to nodes 0, 3 and 5, node 3 is connected to nodes 0 and 4, node 4 is connected to node 3 and node 5 is connected exclusively to node 1.\n\nWe can use the read_adjlist(filename) function to load a file containing an adjacency list into a graph. The nodetype=int option tells networkX to treat the nodenames as integers.\n\nAfter having created the graph G, we can return its edges and nodes by:\n\nIn contrast to the adjacency list, where we provide a list of nodes which are connected, in an adjacency matrix, we specify the edges. An adjacency matrix can be used to create both undirectional and directional graphs.\n\nLet’s start by creating a matrix detailing the edges. Note, that the definition below is asymmetric. The first line does not include any edge connecting the first to the fourth node. However, the fourth line specifies an edge between the forth and the first node. The consequences for the creating directed and undirected graphs are shown below.\n\nFirst we create an undirected graph. When displaying the edges, we see that all edges are present independent of if they were defined in both rows or just in one.\n\nIn contrast when we use the same adjacency matrix to create a directed graph, only the edge from node 3 to node 0 is added, no edge is added in the opposite direction from node 0 to 3.\n\nAnother format of defining a graph from its edges, is the edgelist format. In it’s simplest form the edgelist is just a list of edges. For example\n\nspecifies a graph with 4 vertices (0 to 3) and 3 edges, where vertex 0 is connected to vertex 1 and vertex 2 and vertex 1 is also connected to vertex 3. It can be read using the function.\n\nSo far, so good. However, why bother with this more verbose definition if the adjacency matrix does the same job? The reason lies in edgelist’s ability to specify additonal attributes for the edges, allowing us to add more information to the graph. Each attribute forms another column in the data.\n\nAn edgelist containing additional attributes can be loaded into networkx by passing as parameter a list of tuples, one tuple per attribute, where the tuple contains name and data type of the additional attributes.\n\nIn order to define a graph where the edges have the additional attribute “weight”, we can load a file called edgelist_weights.dat containing the data\n\nThe additional parameters can be returned by specifying setting the parameter to true in :\n\nIn order to create other than undirected graphs, let’s you specify the type of graph through the parameter . You can use it to create for example directed graphs ( ) or multigraphs ( ).\n\nAnother way of defining a graph with edge parameters is through the function. It allows us -similar to the function- to read in a dataframe where each row corresponds to one edge and each additional column to an attribute.\n\nLet’s import pandas and create a basic dataframe with four edges with the attributes color and weight.\n\nBased on this dataframe we can create a graph with the edge attribute color by:\n\nIf we wanted to add all columns in the table as edge attribute we can do so by specifying :\n\nAdding edges and nodes to an existing graph\n\nOnce we have created a graph, we can add additional edges and nodes. To demonstrate this, we start from an empty graph and subsequentially add edges and nodes. Note that when adding edges, the required nodes are added automatically.\n\nWe can also add edges with addtional attributes. Note, that it is not necessary that the already existing edges have this attribute set beforehand. Here, we add an edge with two attributes to the graph. Afterwards, the respective attributes still do not exist for the previously existing nodes.\n\nIf we want to add multiple edges at once, we can use the function:\n\nWe can also add a vertex without edges:\n\nProper graph visualization is hard and the main goal of networkX’s drawing functionality is analysis rather than visualization. In the future, they might even remove the functionality or make it available as add-on only. If you are interested in more professionally looking visualizations, take a look at their drawing documentation to see which programs they recommend.\n\nThat said, below we will take a look at how we can leverage networkX to gain some basic understanding of our graph structures.\n\nFor a better visualization, let’s add some more edges to the previous graph.\n\nThe most basic way of plotting is to use the function . This draws the network in the spring-layout, trying to make all edges about the same length.\n\nNote, that the positions are determined at random and change every time. To see this, let’s plot it again:\n\nIf we want to fix the positions, we can pass them as parameters to the plotting function. To demonstrate this, I first use the function to produce a dictionary of positions (again in spring-layout) for G:\n\nAs you might have noticed, the default plot style of includes the axis in the plot. Since networkX uses matplotlib under the hood, we can interact with the graph using the usual set of matplotlib commands to switch off the axis.\n\nWe can also draw the graphs with a circular layout. When using the circular layout, we can use an aspect ration of 1:1 (‘equal’) to make the graph appear “more circular”. Note that in contrast to , by default does not display the node names. In order to display the node names, we set . Also note, that draw_circular’s default behaviour is to switch of the axis.\n\nIn order to further personalize the plot, we can change properties like node color and size, edge color and more. Let’s demonstrate this using a small example. Let’s assume we have a set of cities and would like to know where to move to. Things that we care about are size, quality of life (above, below or just average) and -since we don’t have a car - if there is a direct train connection and if so, how fast it is (again: fast, slow, average).\n\nLet’s see how we can visualize this in a meaningful way.\n\nFor a basic visualization, let’s create a set of six cities, each with attributes population and lifequality, connected by edges with the attribute speed. We also create a dictionary which assigns a name to each node. This will be used to label the nodes.\n\nNext we create the lists that we need to pass to networkx for the node and edge properties. To extract the node attributes we use the function which returns a dictionary with the node names as keys and the attribute as value. In order to use population as vertex-size, we scale it down by a factor of 10. We also create the color lists for nodes and edges.\n\nAs said before: Not very pretty, but it visualizes the information. We can easily see that Carrot-City has a good quality of life, but has only two direct train routes, which addtionally are slow. Darktown is a lot better connected (three direct train routes, two of them fast), but the quality of life is not great. Appleville has both a good quality of life and fast connections (at least to Darktown and Fluxhole), but it is very small, so if you are an opera fan, you might be up for a hard time. At the end, the choice is up to you, the information is there ;)\n\nOne note since talking about transport options: Taking this scenario a bit further, it would certainly be advantageous to be able to multiple edges (for example meaning different modes of transport, being after all a realistic assumption). Unfortunately, the native visualization of networkX does not support the plotting of multigraphs. To plot multigraphs, refer to one of the libraries mentioned in networkx’s drawing documentation as for example Graphviz. Graphviz can even be used online as for example here. (Note of warning for this particular one: Whilst I found it to produce the nicest graphs out of the online versions which I tested, I also found it to time out regularly on my machine, so I advise to make copies often).\n\nIn this post, we have had a quick look at some basics of graph theory and an overview of some fields where it is used. We have then from a practical perspective looked at how to work with graphs in python using the networkX module. We have looked at several options of loading data into networkX and once a graph is generated, how to manipulate it by adding new nodes, edges and attributes. In the second part, we have seen how to make some basic visualization to help us understand the data contained in our graphs better.\n\nIn the next post in this series, I will talk about graph connectivity and measures of distances, which are two concepts needed to understand the concept of centrality (node and edge importance), which will be introduced in the third part."
    },
    {
        "link": "https://soumenatta.medium.com/networkx-a-practical-introduction-to-graph-analysis-in-python-cc72f3dda916",
        "document": "In the world of data science, analyzing and visualizing complex networks is a critical task. That’s where NetworkX, a powerful Python library for working with graphs and networks, comes into play. With NetworkX, you can create, manipulate, and analyze graphs, and visualize them in a variety of customizable ways. Whether you’re analyzing social networks, transportation networks, or biological networks, NetworkX provides the functionality you need to get the job done.\n\nIn this tutorial, we’ll cover the basics of using NetworkX, from creating graphs to analyzing them and visualizing them in meaningful ways. By the end of this tutorial, you’ll be well on your way to mastering graph analysis with NetworkX.\n\nHere’s an outline of this tutorial on NetworkX:"
    },
    {
        "link": "https://python-louvain.readthedocs.io",
        "document": "It uses the louvain method described in Fast unfolding of communities in large networks, Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, Renaud Lefebvre, Journal of Statistical Mechanics: Theory and Experiment 2008(10), P10008 (12pp) It depends on Networkx to handle graph operations : http://networkx.lanl.gov/ The program can be found in a repository where you can also report bugs : https://github.com/taynaud/python-louvain\n\nYou should consider using the cpp version at http://findcommunities.googlepages.com/ ! where file.bin is a binary graph as generated by the convert utility of the cpp version. The generated file can then be used with the hierarchy utility of the cpp version. Note that the program does not make many verifications about the arguments, and is expecting a friendly use. #first compute the best partition # color the nodes according to their partition\n\nCopyright (c) 2009, Thomas Aynaud <\n\n All rights reserved.\n\n\n\n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\n\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n * Neither the name of the python-louvain Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Copyright (c) 2009, Thomas Aynaud < thomas.aynaud@lip6.fr All rights reserved.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.* Neither the name of the python-louvain Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
        "link": "https://python-louvain.readthedocs.io/en/latest/api.html",
        "document": "Package name is community but refer to python-louvain on pypi\n\nCompute the partition of the graph nodes which maximises the modularity (or try..) using the Louvain heuristices This is the partition of highest modularity, i.e. the highest partition of the dendrogram generated by the Louvain algorithm. the networkx graph which is decomposed the algorithm will start using this partition of the nodes. It’s a dictionary where keys are their nodes and values the communities the key in graph to use as weight. Default to ‘weight’ Will change the size of the communities, default to 1. represents the time described in “Laplacian Dynamics and Multiscale Modular Structure in Networks”, R. Lambiotte, J.-C. Delvenne, M. Barahona Will randomize the node evaluation order and the community evaluation order to get different partitions at each call If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by . The partition, with communities numbered from 0 to number of communities If the graph is not undirected. to obtain all the decompositions levels # color the nodes according to their partition\n\nFind communities in the graph and return the associated dendrogram A dendrogram is a tree and each level is a partition of the graph nodes. Level 0 is the first partition, which contains the smallest communities, and the best is len(dendrogram) - 1. The higher the level is, the bigger are the communities the networkx graph which will be decomposed the algorithm will start using this partition of the nodes. It’s a dictionary where keys are their nodes and values the communities the key in graph to use as weight. Default to ‘weight’ Will change the size of the communities, default to 1. represents the time described in “Laplacian Dynamics and Multiscale Modular Structure in Networks”, R. Lambiotte, J.-C. Delvenne, M. Barahona a list of partitions, ie dictionnaries where keys of the i+1 are the values of the i. and where keys of the first are the nodes of graph If the graph is not a networkx.Graph\n\nProduce the graph where nodes are the communities there is a link of weight w between communities if the sum of the weights of the links between their elements is w a dictionary where keys are graph nodes and values the part the node belongs to the key in graph to use as weight. Default to ‘weight’ a networkx graph where nodes are the parts\n\nCompute the modularity of a partition of a graph the partition of the nodes, i.e a dictionary where keys are their nodes and values the communities the networkx graph which is decomposed the key in graph to use as weight. Default to ‘weight’ If the partition is not a partition of all graph nodes If graph is not a networkx.Graph\n\nReturn the partition of the nodes at the given level A dendrogram is a tree and each level is a partition of the graph nodes. Level 0 is the first partition, which contains the smallest communities, and the best is len(dendrogram) - 1. The higher the level is, the bigger are the communities a list of partitions, ie dictionnaries where keys of the i+1 are the values of the i. the level which belongs to [0..len(dendrogram)-1] A dictionary where keys are the nodes and the values are the set it belongs to If the dendrogram is not well formed or the level is too high to obtain the partition of highest modularity"
    },
    {
        "link": "https://github.com/taynaud/python-louvain",
        "document": "To build and install from source, run\n\nYou can also install from pip with\n\nThe package name on pip is but it is imported as in python. More documentation for this module can be found at http://python-louvain.readthedocs.io/\n\nTo use as a Python library\n\n. . . () . ( ) . ( ) # color the nodes according to their partition . ( , ( . ()) ) . ( , , . (), , , ( . ())) . ( , , ) . ()\n\nIt can also be run on the command line\n\nwhere is a binary file as generated by the convert utility distributed with the C implementation at https://sites.google.com/site/findcommunities/ However as this is mostly for debugging purposes its use should be avoided. Instead importing this library for use in Python is recommended.\n\nYou can find documentation at https://python-louvain.readthedocs.io/"
    },
    {
        "link": "https://stackoverflow.com/questions/56175680/louvain-community-detection-in-complete-weighted-networks-returns-only-1-partiti",
        "document": "I am using python-louvain implementation to detect community in complete weighted graph.\n\nBut I only get one partition, containing all nodes.\n\nI would like to extract communities from a complete weighted network.\n\nI also tried girvan_newman (https://networkx.github.io/documentation/networkx-2.0/reference/algorithms/generated/networkx.algorithms.community.centrality.girvan_newman.html) but could only detect 2 communities out of a complete graph of 200 nodes (with 198 and 2 nodes).\n\nIs Louvain working correctly to detect communities in complete graph? Better suggestions?"
    },
    {
        "link": "https://stackoverflow.com/questions/26070021/how-do-i-run-the-louvain-community-detection-algorithm-in-igraph",
        "document": "According to https://bugs.launchpad.net/igraph/+bug/925038 ... this functionality does exist it's just called\n\nIf you look in the github repository for igraph\n\ndoes exist and it's written in C. I'm not 100% positive this is the algorithm you want but it might be.\n\nThis is great news! Thanks! Is this functionality exported into R? Why does the function bear a generic name (igraph_community_multilevel) instead of the name which the authors gave is (\"louvain method\")? Using the name \"louvain\" would make it easier for the users to find the function!"
    },
    {
        "link": "https://stackoverflow.com/questions/15365268/color-plots-different-colors-on-a-matrix-matplotlib",
        "document": "The correct link to the color maps is: http://www.loria.fr/~rougier/teaching/matplotlib/#colormaps You assign the spring color map like this:\n\n@tcaswell is of course correct that if your data is binary the color will be binary as well. The color map gives different colors to different z-values. If you want to give the right bottom part a different color from the left bottom part (or whatever), you'll need a different solution. Something with a scatterplot I guess."
    },
    {
        "link": "https://datascience.stackexchange.com/questions/85330/coloring-clusters-so-that-nearby-clusters-have-different-colors",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/78103553/how-to-use-a-colourmap-to-plot-multiple-plots-on-one-graph-and-iterate-over-mult",
        "document": "I need to use a different colourmap for a range of different sensors. I'm planning to have these different colourmaps in a list that will be called upon in the loop. The individual colourmap for a sensor shows the range of temperatures the sensor was measured over.\n\nSo far I am struggling to implement this, I can specify a common colourmap in the loop, here 'Blues' but don't know how to loop over the different colourmaps\n\nwhere, t and R is my data\n\nI have simplified and cut a lot of parts out of my code to show the problem, so the code might look a little unnecessary in places.\n\nAlso would a contour plot be better for this? Where a different contour is a different temperature"
    },
    {
        "link": "https://medium.com/@kevinrioharris/enhancing-data-visualizations-with-color-palettes-in-matplotlib-0a39e70f8dfc",
        "document": "Color plays a vital role in data visualization, helping to communicate information clearly and attractively. In Python, Matplotlib is one of the most widely used libraries for plotting data. One of its most powerful features is its ability to handle color palettes. By choosing the right palette, you can make your charts more informative, accessible, and visually appealing.\n• Improved Readability: Proper use of color helps viewers interpret the data more quickly.\n• Highlight Patterns: Colors can highlight trends, outliers, and correlations in data.\n• Aesthetic: A well-chosen color palette can make your visualization more engaging and professional.\n\nQualitative color palettes are used for categorical data, where the color distinguishes between different categories or groups. These palettes work well when you have non-ordered data, like names or types, and need to assign distinct colors to each category.\n• : A set of 12 colors in pairs, ideal for paired data.\n\nSequential palettes are used for data that has an inherent order, such as numerical values that increase or decrease. These palettes transition from lighter to darker colors, making it easier to visualize higher and lower values.\n\nDiverging palettes are ideal for data that has a meaningful midpoint, such as data centered around zero. These palettes transition from one color at the low end of the spectrum, to a neutral color at the midpoint, and then to a different color at the high end. This makes it easy to highlight values above and below the midpoint.\n• : A palette with a full spectrum of colors from blue to red.\n\nCyclical palettes are used for periodic data, such as angles or time-of-day data, where the values repeat in a cycle. These palettes use hues that cycle through the color spectrum.\n• : A palette using hues in the HSV color space.\n• : A perceptually uniform color map, designed to be accessible to colorblind individuals.\n• : A perceptually uniform palette from yellow to red to black.\n• : A perceptually uniform palette from yellow to green to blue.\n\nThese palettes are ideal when you want to ensure that your visualizations are accessible to a broader audience."
    },
    {
        "link": "https://python.plainenglish.io/the-shaded-matrix-a-python-function-five-variations-and-a-few-tips-bdbd087c4731",
        "document": "The shaded matrix — a Python function, five variations and a few tips\n\nWhether you call it shaded matrix, heatmap or raster plot, the visualization technique presented here is about coloring the cells of a two-dimensional table according to their values. This story sets out to show that this simple idea is also a powerful one, which can yield many insightful visualizations.\n\nAs promised in the story’s title, let us start with a Python function that actually draws such a shaded matrix:\n\nfrom matplotlib import pyplot as plt\n\n\n\ndef plot_shaded_matrix(\n\n data,\n\n cmap=\"viridis\",\n\n ax=None,\n\n write_values=True,\n\n format_value=None,\n\n text_data=None,\n\n vmin=None,\n\n vmax=None,\n\n with_colorbar=True,\n\n cbar_title=\"\",\n\n cbar_ticks=None,\n\n):\n\n \"\"\"Plot data as a shaded matrix\n\n\n\n Args:\n\n data: a pandas DataFrame\n\n cmap: a colormap, either as a string or a matplotlib colormap\n\n ax: an optional matplotlib axis\n\n write_values: if True, write the values in the cells\n\n format_value: a function that takes a number and returns a string\n\n used in write_values is True\n\n text_data: a pandas DataFrame of the same shape as data\n\n used to write values if provided, otherwise the values of data are written\n\n vmin: minimum value for color mapping\n\n vmax: maximum value for color mapping\n\n with_colorbar: whether a colorbar should be drawn\n\n cbar_title: label for the colorbar\n\n cbar_ticks: values of ticks for the colorbar\n\n \"\"\"\n\n if ax is None:\n\n _, ax = plt.subplots(figsize=(5, 4))\n\n if format_value is None:\n\n format_value = lambda x: f\"{x:.1f}\"\n\n if isinstance(cmap, str):\n\n cmap = plt.get_cmap(cmap)\n\n if vmin is None:\n\n vmin = data.min().min()\n\n if vmax is None:\n\n vmax = data.max().max()\n\n color_norm = plt.Normalize(vmin=vmin, vmax=vmax)\n\n img = ax.imshow(data, cmap=cmap, aspect=\"auto\", norm=color_norm)\n\n\n\n if write_values:\n\n if text_data is None:\n\n text_data = data\n\n for i_x in range(text_data.shape[1]):\n\n for i_y in range(text_data.shape[0]):\n\n value = text_data.iloc[i_y, i_x]\n\n color_value = data.iloc[i_y, i_x]\n\n bg_color = cmap(color_norm(color_value))\n\n # if bg_color is light then choose a dark text color\n\n if lightness_from_rgb(bg_color) > 0.4:\n\n txt_color = \"black\"\n\n else:\n\n txt_color = \"white\"\n\n ax.text(\n\n i_x,\n\n i_y,\n\n format_value(value),\n\n ha=\"center\",\n\n va=\"center\",\n\n color=txt_color,\n\n )\n\n\n\n if with_colorbar:\n\n plt.colorbar(mappable=img, ax=ax, label=cbar_title, ticks=cbar_ticks)\n\n ax.set_xticks(np.arange(0, len(data.columns)))\n\n ax.set_yticks(np.arange(len(data.index)))\n\n ax.set_xticklabels(data.columns)\n\n ax.set_yticklabels(data.index)\n\n ax.set_xlabel(data.columns.name)\n\n ax.set_ylabel(data.index.name)\n\n ax.tick_params(axis=\"x\", labelrotation=90) # avoid overlapping x tick labels\n\n\n\ndef lightness_from_rgb(rgb):\n\n \"\"\"Get an estimate of the lightness of an RGB color\"\"\"\n\n r, g, b, alpha = rgb\n\n return 0.2 * r + 0.7 * g + 0.1 * b\n\nWhile pyplot.imshow does the core of the job, it takes quite a few more lines to get you the right colorbar, label everything and — if desired — add numerical values to the matrix display.\n\nExample applications of the shaded matrix\n\nMatrices come up in many places in machine learning. One of these is as coefficients in linear regression models and neural networks. In the following example, we plot the coefficients of a logistic regression model trained on the Dry Bean dataset.\n\nWith our plot_shaded_matrix function, visualizing these coefficients is straightforward and will allow you to identify the most predictive features for each bean type. Advanced tip: by adding some l1 regularization to your logistic regression, you can let a large portion of these coefficients shrink to 0 and enhance the model’s interpretability.\n\nA confusion matrix, displaying a classifier’s predictions in terms of true and predicted classes, is a precious tool to evaluate the performance of multiclass classification models, such as the logistic regression model introduced in the previous paragraph. Scikit-learn has a ConfusionMatrixDisplay which does the job, but I like using colors to emphasize the distinction between correct and incorrect predictions. This is where using our flexible plot_shaded_matrix function comes into play.\n\nA shaded matrix can also support the very common task of comparing n items in terms of m indicators. Let us say you want to compare the performance of multiple large language models (LLMs). Benchmarks like the Open LLM Leaderboard (introduced in a previous story) combine the results from several other benchmarks and datasets. For an in-depth evaluation, you will want to go beyond the average score and look at the metrics obtained on the individual datasets. In this context, a shaded matrix may prove invaluable and help you recognize which models perform best on which metrics, and how this correlates with the overall performance.\n\nDid I say “correlate”? Actually, pairwise correlations between multiple variables are another piece of information which can benefit from being displayed as a shaded matrix.\n\nSome people give it the nice name of “correlogram”. Here again, a diverging colormap enhances the heatmap’s quality, by allowing positive and negative correlation coefficients to be instantly distinguished.\n\nGraphs are another type of (arguably omnipresent) data structure which can be displayed in the form of a shaded matrix, whereby each edge is represented by a square cell at the intersection of the row and column corresponding to the two nodes it connects. For dense graphs, the resulting adjacency matrix is often more insightful than node-link diagrams, which tend to become tangled as the number of edges grows. I would say this is already the case in the example graph shown below, with its 32 nodes. The adjacency matrix instantaneously shows the bipartite structure of the graph, and would allow you to — for instance — identify social clusters or determine the most popular event much more easily than the node-link diagram would.\n\nAfter this hopefully inspiring list of applications of the shaded matrix, let us review a few tips to make the best out of them.\n• An adequate colormap will be a key component of a successful shaded matrix. Diverging or sequential colormaps have been purposely selected for each of the examples shown above. In other cases, a categorical colormap would be the right choice. In any case, avoid meaningless colormaps and think about colour vision deficiency.\n• Consider alternatives. Being based on color-coding, the shaded matrix will not allow quantities and ratios to be perceived with high accuracy. Bar plots or other diagrams encoding quantities as lengths may be more appropriate if the focus is on a quantitative comparison of values or ratios between them.\n• Write values, or not. Writing a numerical value in each cell may be of help — but becomes cumbersome as the number of cells increases. If you do write values, choose the right number of digits. Also, consider the possibility of using different tables for colour and text — for instance using a different scaling for each, but make sure to make it clear.\n• Ordering of rows and columns. It is often the case that the rows and/or columns of your matrix represent categorical variables whose order is not predetermined. In this case, applying a reordering or “seriation” algorithm can be very advantageous and reveal otherwise hidden structures. See the function in the appendix.\n\nYou are now well equipped to transform various kinds of data into colorful matrix visualizations. The five variations presented in this story are only a small sample of all possible applications of the shaded matrix. I did not mention two-dimensional histograms. What about all those Excel tables with conditional formatting? Can you think of other interesting examples?\n• The History of the Cluster Heat Map is an interesting read for those wanting to go deeper, especially on the topic of row and column reordering.\n• A special case of shaded matrix is what I call the temporal heatmap, on which I wrote this short guide.\n\nThank you for being a part of the In Plain English community! Before you go:\n• Be sure to clap and follow the writer ️👏️️"
    }
]