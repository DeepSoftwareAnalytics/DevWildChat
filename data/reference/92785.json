[
    {
        "link": "https://php.net/manual/en/mysqli.quickstart.prepared-statements.php",
        "document": "The MySQL database supports prepared statements. A prepared statement or a parameterized statement is used to execute the same statement repeatedly with high efficiency and protect against SQL injections.\n\nThe prepared statement execution consists of two stages: prepare and execute. At the prepare stage a statement template is sent to the database server. The server performs a syntax check and initializes server internal resources for later use.\n\nThe MySQL server supports using anonymous, positional placeholder with .\n\nPrepare is followed by execute. During execute the client binds parameter values and sends them to the server. The server executes the statement with the bound values using the previously created internal resources.\n\nA prepared statement can be executed repeatedly. Upon every execution the current value of the bound variable is evaluated and sent to the server. The statement is not parsed again. The statement template is not transferred to the server again.\n\nEvery prepared statement occupies server resources. Statements should be closed explicitly immediately after use. If not done explicitly, the statement will be closed when the statement handle is freed by PHP.\n\nUsing a prepared statement is not always the most efficient way of executing a statement. A prepared statement executed only once causes more client-server round-trips than a non-prepared statement. This is why the is not run as a prepared statement above.\n\nAlso, consider the use of the MySQL multi-INSERT SQL syntax for INSERTs. For the example, multi-INSERT requires fewer round-trips between the server and client than the prepared statement shown above.\n\nThe MySQL Client Server Protocol defines a different data transfer protocol for prepared statements and non-prepared statements. Prepared statements are using the so called binary protocol. The MySQL server sends result set data \"as is\" in binary format. Results are not serialized into strings before sending. Client libraries receive binary data and try to convert the values into appropriate PHP data types. For example, results from an SQL column will be provided as PHP integer variables.\n\nThis behavior differs from non-prepared statements. By default, non-prepared statements return all results as strings. This default can be changed using a connection option. If the connection option is used, there are no differences.\n\nResults from prepared statements can either be retrieved by binding output variables, or by requesting a mysqli_result object.\n\nOutput variables must be bound after statement execution. One variable must be bound for every column of the statements result set.\n\nPrepared statements return unbuffered result sets by default. The results of the statement are not implicitly fetched and transferred from the server to the client for client-side buffering. The result set takes server resources until all results have been fetched by the client. Thus it is recommended to consume results timely. If a client fails to fetch all results or the client closes the statement before having fetched all data, the data has to be fetched implicitly by .\n\nIt is also possible to buffer the results of a prepared statement using mysqli_stmt::store_result().\n\nInstead of using bound results, results can also be retrieved through the mysqli_result interface. mysqli_stmt::get_result() returns a buffered result set.\n\nUsing the mysqli_result interface offers the additional benefit of flexible client-side result set navigation.\n\nBound variables are sent to the server separately from the query and thus cannot interfere with it. The server uses these values directly at the point of execution, after the statement template is parsed. Bound parameters do not need to be escaped as they are never substituted into the query string directly. A hint must be provided to the server for the type of bound variable, to create an appropriate conversion. See the mysqli_stmt::bind_param() function for more information.\n\nSuch a separation is sometimes considered the only security feature to prevent SQL injection, but the same degree of security can be achieved with non-prepared statements, if all the values are formatted correctly. It should be noted that correct formatting is not the same as escaping and involves more logic than simple escaping. Thus, prepared statements are simply a more convenient and less error-prone approach to this element of database security.\n\nThe API does not include emulation for client-side prepared statement emulation."
    },
    {
        "link": "https://php.net/manual/en/mysqli.prepare.php",
        "document": "Darren ¶ I wrote this function for my personal use and figured I would share it. I am not sure if this is the appropriate forum but I wish I had this when I stumbled on to mysqli::prepare. The function is an update of the function I posted previously. The previous function could not handle multiple queries. \n\n \n\nFor queries: \n\nResults of single queries are given as arrays[row#][associated Data Array] \n\nResults of multiple queries are given as arrays[query#][row#][associated Data Array] \n\n \n\nFor queries which return an affected row#, affected rows are returned instead of (array[row#][associated Data Array]) \n\n \n\nCode and example are below: \n\n \n\n \n\nExample(s): \n\nFor a table of firstName and lastName: \n\nJohn Smith \n\nMark Smith \n\nJack Johnson \n\nBob Johnson \n\n \n\n \"SELECT * FROM names WHERE firstName=? AND lastName=?\" \n\nHope it helps =)\n\nkritz at hrz dot tu-chemnitz dot de ¶ I wasn't able to fully test the following since the server I am currently working on is missing the PHP module that allows me to call get_result on mysqli_stmt but maybe this could be helpful for someone:\n\n\n\n 'SELECT * FROM table WHERE something = ? AND someotherthing = ? AND elsewhat = ?' \n\nNOTE: If you want to use this with a PHP version below 5.4 you have to use the old ugly array() syntax for arrays instead of the short [] syntax.\n\nadmin at xorath dot com ¶ Performance note to those who wonder. I performed a test where first of all inserted about 30,000 posts with one PK:id and a varchar(20), where the varchar data was md5-hash for the current iterator value just to fill with some data. \n\n \n\nThe test was performed on a dedicated ubuntu 7.04 server with apache2/php5/mysql5.0 running on Athlon 64 - 3000+ with 512MB of RAM. The queries where tested with a for-loop from 0 to 30000 first with: \n\n \n\n \n\nwhich gave a page-load time of about 3.3seconds avarage, then with this loop: \n\n \n\n \n\nand the avarage page-load was lowered by 1.3sec, which means about 2.0 sec avarage! Guess the performance difference could be even greater on a more complex/larger table and more complex SQL-queries.\n\nCodeguy ¶ The actual purpose to use a prepared statement in sql is to cut the cost of processing queries; NOT to separate data from query. That's how it's being used w/ php NOW, not how it was designed to be used in the first place. With SQL you cut the cost of executing multiple similar queries down by using a prepared statement.. Doing so cuts out the parsing, validation and most often generates an execution plan for said query up front. Which is why they run faster in a loop, than their IMMEDIATE Query cousins do. Do not assume that just because someone uses php and this function this way does not mean that it is THE way, or only way to do it. Although it is more secure than general queries but they are also more limited in what they can do or more precisely how you can go about doing it.\n\nDarren ¶ For those learning mysqli::prepare and mysqli_stmt::bind_params for the first time, here is a commented block of code which executes prepared queries and returns data in a similar format to the return values of mysqli_query. I tried to minimize unnecessary classes, objects, or overhead for two reasons:\n\n1) facilitate learning\n\n2) allow relativity interchangeable use with mysqli_query\n\n\n\nMy goal is to lower the learning curve for whoever is starting out with these family of functions. I am by no means an expert coder/scripter, so I am sure there are improvements and perhaps a few bugs, but I hope not =)\n\n\n\n \n\nHere's hoping the PHP gods don't smite me.\n\nsdepouw at NOSPAM dot com ¶ I don't know how obvious this was for anyone else, but if you attempt to prepare a query for a table that doesn't exist in the database the connection currently points to (or if your query is invalid in some other way, I suppose), an object will not be returned. I only noticed this after doing some digging when I kept getting a fatal error saying that my statement variable was not an set to an instance of an object (it was probably null).\n\n\n\nReplace NOSPAM with nimblepros to e-mail me."
    },
    {
        "link": "https://w3schools.com/php/php_mysql_prepared_statements.asp",
        "document": "Prepared statements are very useful against SQL injections.\n\nA prepared statement is a feature used to execute the same (or similar) SQL statements repeatedly with high efficiency.\n• Prepare: An SQL statement template is created and sent to the database. Certain values are left unspecified, called parameters (labeled \"?\"). Example: INSERT INTO MyGuests VALUES(?, ?, ?)\n• The database parses, compiles, and performs query optimization on the SQL statement template, and stores the result without executing it\n• Execute: At a later time, the application binds the values to the parameters, and the database executes the statement. The application may execute the statement as many times as it wants with different values\n\nCompared to executing SQL statements directly, prepared statements have three main advantages:\n• Prepared statements reduce parsing time as the preparation on the query is done only once (although the statement is executed multiple times)\n• Bound parameters minimize bandwidth to the server as you need send only the parameters each time, and not the whole query\n• Prepared statements are very useful against SQL injections, because parameter values, which are transmitted later using a different protocol, need not be correctly escaped. If the original statement template is not derived from external input, SQL injection cannot occur.\n\nThe following example uses prepared statements and bound parameters in MySQLi:\n\nCode lines to explain from the example above:\n\nIn our SQL, we insert a question mark (?) where we want to substitute in an integer, string, double or blob value.\n\nThen, have a look at the bind_param() function:\n\nThis function binds the parameters to the SQL query and tells the database what the parameters are. The \"sss\" argument lists the types of data that the parameters are. The s character tells mysql that the parameter is a string.\n\nThe argument may be one of four types:\n\nWe must have one of these for each parameter.\n\nBy telling mysql what type of data to expect, we minimize the risk of SQL injections.\n\nThe following example uses prepared statements and bound parameters in PDO:\n\n<?php\n\n$servername = \"localhost\";\n\n$username = \"username\";\n\n$password = \"password\";\n\n$dbname = \"myDBPDO\";\n\n\n\ntry {\n\n $conn = new PDO(\"mysql:host=$servername;dbname=$dbname\", $username, $password);\n\n // set the PDO error mode to exception\n\n $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n\n\n // prepare sql and bind parameters\n\n $stmt = $conn->prepare(\"INSERT INTO MyGuests (firstname, lastname, email) \n\n VALUES (:firstname, :lastname, :email)\");\n\n $stmt->bindParam(':firstname', $firstname);\n\n $stmt->bindParam(':lastname', $lastname);\n\n $stmt->bindParam(':email', $email);\n\n \n\n // insert a row\n\n $firstname = \"John\";\n\n $lastname = \"Doe\";\n\n $email = \"john@example.com\";\n\n $stmt->execute();\n\n\n\n // insert another row\n\n $firstname = \"Mary\";\n\n $lastname = \"Moe\";\n\n $email = \"mary@example.com\";\n\n $stmt->execute();\n\n\n\n // insert another row\n\n $firstname = \"Julie\";\n\n $lastname = \"Dooley\";\n\n $email = \"julie@example.com\";\n\n $stmt->execute();\n\n \n\n echo \"New records created successfully\";\n\n} catch(PDOException $e) {\n\n echo \"Error: \" . $e->getMessage();\n\n}\n\n $conn = null;\n\n ?>"
    },
    {
        "link": "https://stackoverflow.com/questions/17452614/php-mysqli-prepared-statements-login-and-check-the-user-status",
        "document": "I am learning to make website with some video tutorials based on mysqli. I came to know that using prepared statements are more secure and I am trying to create a login system. Here is what I have done so far.\n\nBut I also need to check if the user have not activated or have been banned or deactivated. So I made another code.\n\nAnd here is the code I made\n\nWhen I use this I get the following errors\n\nUnder user_level I have the following\n\nWhile logging in I need to check if the user status and if it is activated it should move to index page or if it is d it should show the user has been deactivated and likewise for others.\n\nHow to do it in prepared statements?\n\nAnd I have this connect.php in all page"
    },
    {
        "link": "https://stackoverflow.com/questions/62571263/login-system-with-prepared-statements-mysqli",
        "document": "Im struggling to convert my login system to prepared statements. I have managed to convert my entire Crud system but just confused with this last part. Any help would be much appreciated.\n\nThis was the original login without prepared statements:\n\nAnd then my index.php page\n\nThis is what I have done so far:\n\nIts on this part that I am getting so confused as to how to implement it in prepared statements with the index.php No matter what I try from searching the internet, I just cant seems to get this part figured out:"
    },
    {
        "link": "https://php.net/manual/en/function.password-hash.php",
        "document": "Since 2017, NIST recommends using a secret input when hashing memorized secrets such as passwords. By mixing in a secret input (commonly called a \"pepper\"), one prevents an attacker from brute-forcing the password hashes altogether, even if they have the hash and salt. For example, an SQL injection typically affects only the database, not files on disk, so a pepper stored in a config file would still be out of reach for the attacker. A pepper must be randomly generated once and can be the same for all users. Many password leaks could have been made completely useless if site owners had done this.\n\n\n\nSince there is no pepper parameter for password_hash (even though Argon2 has a \"secret\" parameter, PHP does not allow to set it), the correct way to mix in a pepper is to use hash_hmac(). The \"add note\" rules of php.net say I can't link external sites, so I can't back any of this up with a link to NIST, Wikipedia, posts from the security stackexchange site that explain the reasoning, or anything... You'll have to verify this manually. The code:\n\n\n\n// config.conf\n\npepper=c1isvFdxMDdmjOlvxpecFw\n\n\n\n \n\n \n\nNote that this code contains a timing attack that leaks whether the username exists. But my note was over the length limit so I had to cut this paragraph out.\n\n\n\nAlso note that the pepper is useless if leaked or if it can be cracked. Consider how it might be exposed, for example different methods of passing it to a docker container. Against cracking, use a long randomly generated value (like in the example above), and change the pepper when you do a new install with a clean user database. Changing the pepper for an existing database is the same as changing other hashing parameters: you can either wrap the old value in a new one and layer the hashing (more complex), you compute the new password hash whenever someone logs in (leaving old users at risk, so this might be okay depending on what the reason is that you're upgrading).\n\n\n\nWhy does this work? Because an attacker does the following after stealing the database:\n\n\n\npassword_verify(\"a\", $stolen_hash)\n\npassword_verify(\"b\", $stolen_hash)\n\n...\n\npassword_verify(\"z\", $stolen_hash)\n\npassword_verify(\"aa\", $stolen_hash)\n\netc.\n\n\n\n(More realistically, they use a cracking dictionary, but in principle, the way to crack a password hash is by guessing. That's why we use special algorithms: they are slower, so each verify() operation will be slower, so they can try much fewer passwords per hour of cracking.)\n\n\n\nNow what if you used that pepper? Now they need to do this:\n\n\n\npassword_verify(hmac_sha256(\"a\", $secret), $stolen_hash)\n\n\n\nWithout that $secret (the pepper), they can't do this computation. They would have to do:\n\n\n\npassword_verify(hmac_sha256(\"a\", \"a\"), $stolen_hash)\n\npassword_verify(hmac_sha256(\"a\", \"b\"), $stolen_hash)\n\n...\n\netc., until they found the correct pepper.\n\n\n\nIf your pepper contains 128 bits of entropy, and so long as hmac-sha256 remains secure (even MD5 is technically secure for use in hmac: only its collision resistance is broken, but of course nobody would use MD5 because more and more flaws are found), this would take more energy than the sun outputs. In other words, it's currently impossible to crack a pepper that strong, even given a known password and salt."
    },
    {
        "link": "https://stackoverflow.com/questions/30279321/how-to-use-phps-password-hash-to-hash-and-verify-passwords",
        "document": "Recently I have been trying to implement my own security on a log in script I stumbled upon on the internet. After struggling of trying to learn how to make my own script to generate a salt for each user, I stumbled upon .\n\nFrom what I understand (based off of the reading on this page), salt is already generated in the row when you use . Is this true?\n\nAnother question I had was, wouldn't it be smart to have 2 salts? One directly in the file and one in the DB? That way, if someone compromises your salt in the DB, you still have the one directly in the file? I read on here that storing salts is never a smart idea, but it always confused me what people meant by that."
    },
    {
        "link": "https://stackoverflow.com/questions/77656346/neither-crypt-nor-password-verify-works-on-php-8-1-on-our-users-existing-passwo",
        "document": "It turns out this isn't a change in PHP 8.1, or any specific release, but a security fix applied to all then-supported branches. We can see this by setting the salt to something predictable and comparing the result across many versions: the versions where it starts returning \"*0\" are 8.0.28, 8.1.16, 8.2.3, and 8.3.0.\n\nLooking at the detailed changelogs for those releases, we find Security Bug #81744: Password_verify() always return true with some hash. This sounds relevant, so we follow through to the linked security advisory which has the title:\n\nThis is interesting - as pointed out by Sammitch and gview in the comments, you are generating 21 characters of salt instead of 22 - but because you are adding , you are actually generating 22-character salts ending in . (Note that there isn't actually a suffix needed in the correct format.)\n\nThat's why you had to manually extract the salt and re-run the original hash - the intended use of is to pass in the entire hash when verifying, and the salt and options will be extracted automatically.\n\nSo, what was the old code in PHP doing when it found this ?\n\nFollowing the source code link in the security advisory, we see that the problem was a hack in a macro called which broke out of a loop in a function . This is essentially a base64-decoding routine, which is given a target number of output bytes, and reads the input until it can decode enough.\n\nSearching for uses of the function, we find . That makes sense: base64 takes 4 encoded bytes for 3 raw bytes, so for 16 raw bytes, you need 21⅓ characters of base64, which gives us our 22 readable characters of salt. (It also means that generating 22 random characters would also be wrong; you should have been generating 16 random bytes then encoding them.)\n\nWhat the old versions of PHP did when they encountered the was broke out of that encoding loop, wherever they got to, and then padded the output with enough 0 bytes to give the desired length. So we need to create a salt that ends with that same number of zero bytes once decoded.\n\nEach full loop consumes 4 bytes of input to create 3 bytes of output, so after 5 loops, it has consumed 20 bytes, and output 15. It then needs to get one more output byte from the remaining two input bytes, here:\n\nWith the old code, when it tried to read the second of those bytes ( ) with the macro, and encountered a , it broke out of the loop before doing anything with . So it turns out the 21st character of your salt was always being ignored.\n\nThe particular base64 alphabet used has for 0, so to get a 0 out from 2 bytes of input is easy: If you look at your current hashes, you'll see they already have a at the end of the salt - this isn't a separator, it's padding added somewhere in the formatting routine to give the expected length.\n\nSo it turns out all you need to do is set the 21st character of the salt to a Since that's always at a fixed offset in the string (7-byte prefix + 20 bytes of actually varying salt), you can just overwrite that byte of the stored hash and verify it without extracting the salt:\n\nThen, treat any hash where you've had to do this as \"needs rehash\", and generate a new hash with password_hash while you have the plain text."
    },
    {
        "link": "https://php.net/manual/en/faq.passwords.php",
        "document": "I feel like I should comment some of the clams being posted as replies here.\n\n\n\nFor starters, speed IS an issue with MD5 in particular and also SHA1. I've written my own MD5 bruteforce application just for the fun of it, and using only my CPU I can easily check a hash against about 200mill. hash per second. The main reason for this speed is that you for most attempts can bypass 19 out of 64 steps in the algorithm. For longer input (> 16 characters) it won't apply, but I'm sure there's some ways around it.\n\n\n\nIf you search online you'll see people claiming to be able to check against billions of hashes per second using GPUs. I wouldn't be surprised if it's possible to reach 100 billion per second on a single computer alone these days, and it's only going to get worse. It would require a watt monster with 4 dual high-end GPUs or something, but still possible.\n\n\n\nHere's why 100 billion per second is an issue:\n\nAssume most passwords contain a selection of 96 characters. A password with 8 characters would then have 96^8 = 7,21389578984e+15 combinations.\n\nWith 100 billion per second it would then take 7,21389578984e+15 / 3600 = ~20 hours to figure out what it actually says. Keep in mind that you'll need to add the numbers for 1-7 characters as well. 20 hours is not a lot if you want to target a single user. \n\n\n\nSo on essence:\n\nThere's a reason why newer hash algorithms are specifically designed not to be easily implemented on GPUs.\n\n\n\nOh, and I can see there's someone mentioning MD5 and rainbow tables. If you read the numbers here, I hope you realize how incredibly stupid and useless rainbow tables have become in terms of MD5. Unless the input to MD5 is really huge, you're just not going to be able to compete with GPUs here. By the time a storage media is able to produce far beyond 3TB/s, the CPUs and GPUs will have reached much higher speeds.\n\n\n\nAs for SHA1, my belief is that it's about a third slower than MD5. I can't verify this myself, but it seems to be the case judging the numbers presented for MD5 and SHA1. The issue with speeds is basically very much the same here as well.\n\n\n\nThe moral here:\n\nPlease do as told. Don't every use MD5 and SHA1 for hasing passwords ever again. We all know passwords aren't going to be that long for most people, and that's a major disadvantage. Adding long salts will help for sure, but unless you want to add some hundred bytes of salt, there's going to be fast bruteforce applications out there ready to reverse engineer your passwords or your users' passwords."
    },
    {
        "link": "https://thisprogrammingthing.com/2021/working-with-passwords-in-php-8",
        "document": "In our previous article, we discussed how we should hash and salt our user’s passwords to make them harder to crack if our database becomes compromised. In this article, we’re going to discuss how to use PHP’s built-in functions to do this.\n\nAs someone who has maintained this kind of logic in other systems, I’m so glad it was added to the core.\n\nBefore we get too far into this, these functions were added in PHP 5.5 so our examples won’t work with earlier versions. These versions are no longer supported so they should be upgraded ASAP!\n\nThe first function we’re going to discuss is the function. This function takes just the password and a constant indicating the algorithm to use and returns a hash. We’re going to use the constant.\n\nThe string we get back from this is almost gibberish which is a good indication we’re getting a good hash.\n\nBecause the function automatically salts our passwords, every time we run the same password through the function we’ll get different outputs. This means the function won’t be susceptible to a rainbow table exploit.\n\nWe can also specify the algorithm to be used to generate the hash and some options for the specified algorithm.\n\nThe algorithm choices are PASSWORD_DEFAULT, PASSWORD_BCRYPT, PASSWORD_ARGON2I, and PASSWORD_ARGON2ID for bcrypt, bcrypt, Argon2i, and Argon2id respectively. You may have noticed we said “bcrypt” twice and that’s because PASSWORD_DEFAULT is equivalent to PASSWORD_BCRYPT.\n\nOur suggestion is to stick with PASSWORD_DEFAULT as people with more security knowledge than us have decided that it is the best option for most people and if that changes in future releases we’ll most likely upgrade to the new algorithm automatically.\n\nThe options array parameter for bcrypt is the algorithmic cost that should be used. The higher the number the longer it will take to generate the hash and the harder it will be for an attacker to brute force the password.\n\nThe default cost is 10 but it’s hard to understand how that affects anything so let’s run through how long it takes to generate a hash at each level. Please note these numbers will not match on any other computer so take them with a grain of salt and use your server to determine the best value for you. We recommend something around a tenth of a second as a good compromise between security and performance.\n\nThe next part of the password management cycle is to verify the password an unauthenticated user has passed us. This is done using the function.\n\nNotice how the hashes we’ve generated start with ? That is how knows how to compare the hash to the input. This makes it so the function needs just two parameters, the password sent by the user and the hash we created using . I love this because even if we change our algorithm or cost the function call doesn’t need to change.\n\nComputing power is only getting more and more powerful so as our servers get faster we must rehash our user’s passwords as we increase our “cost” parameter. PHP provides the function to determine if we need to rehash our user’s passwords based on the current settings. It has almost the same parameters as but the first parameter is the hash and not the password.\n\nAs a form of completionism, a sample login process looks something like the following.\n\nThe very last thing we want to discuss is the function. This function is used to extract the information from the hash. It’s mostly for fun but we wanted to make sure you were aware of it.\n\nWhat You Need To Know to Nail a Job Interview\n• PHP has built-in password functions after the 5.5 release\n• to generate the hash before storing it\n• to compare the hash against a user-provided password\n• to determine if we need to rehash the password\n\nAs always thanks for reading our article. Make sure you subscribe to our newsletter and let us know how you’re using PHP password functions in the comments."
    }
]