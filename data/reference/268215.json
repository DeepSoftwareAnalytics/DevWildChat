[
    {
        "link": "https://geeksforgeeks.org/pure-virtual-functions-and-abstract-classes",
        "document": "Sometimes implementation of all functions cannot be provided in a base class because we don’t know the implementation. Such a class is called an abstract class.For example, let Shape be a base class. We cannot provide the implementation of function draw() in Shape, but we know every derived class must have an implementation of draw(). Similarly, an Animal class doesn’t have the implementation of move() (assuming that all animals move), but all animals must know how to move. We cannot create objects of abstract classes.\n\nA pure virtual function (or abstract function) in C++ is a virtual function for which we can have an implementation, But we must override that function in the derived class, otherwise, the derived class will also become an abstract class. A pure virtual function is declared by assigning 0 in the declaration.\n\nA pure virtual function is implemented by classes that are derived from an Abstract class.\n\n1. A class is abstract if it has at least one pure virtual function.\n\nIn the below C++ code, Test is an abstract class because it has a pure virtual function show().\n\n2. We can have pointers and references of abstract class type.\n\nFor example, the following program works fine.\n\n3. If we do not override the pure virtual function in the derived class, then the derived class also becomes an abstract class.\n\nThe following example demonstrates the same.\n\n4. An abstract class can have constructors.\n\nFor example, the following program compiles and runs fine.\n\n5. An abstract class in C++ can also be defined using struct keyword.\n\nIn Java, a class can be made abstract by using an abstract keyword. Similarly, a function can be made pure virtual or abstract by using an abstract keyword. See Abstract Classes in Java for more details.\n\nAn interface does not have an implementation of any of its methods, it can be considered as a collection of method declarations. In C++, an interface can be simulated by making all methods pure virtual. In Java, there is a separate keyword for the interface.\n\nWe can think of Interface as header files in C++, like in header files we only provide the body of the class that is going to implement it. Similarly in Java in Interface we only provide the body of the class and we write the actual code in whatever class implements it."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=only-abstract-classes-c",
        "document": "An abstract class is a class that is designed to be specifically used as a base class. An abstract class contains at least one pure virtual function. You declare a pure virtual function by using a pure specifier ( ) in the declaration of a virtual member function in the class declaration.\n\nFunction is a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following: You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this: struct A { virtual void f() = 0; }; struct B : A { virtual void f() { } }; // Error: // Class A is an abstract class // A g(); // Error: // Class A is an abstract class // void h(A); A& i(A&); int main() { // Error: // Class A is an abstract class // A a; A* pa; B b; // Error: // Class A is an abstract class // static_cast<A>(b); } Class is an abstract class. The compiler would not allow the function declarations or , declaration of object , nor the static cast of to type . The following is an example of an abstract class:Functionis a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following:You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this:Classis an abstract class. The compiler would not allow the function declarationsor, declaration of object, nor the static cast ofto type\n\nVirtual member functions are inherited. A class derived from an abstract base class will also be abstract unless you override each pure virtual function in the derived class.\n\nThe compiler will not allow the declaration of object because is an abstract class; it inherited the pure virtual function from . The compiler will allow the declaration of object if you define function , as this overrides the inherited pure virtual function . Function needs to be overridden if you want to avoid the abstraction of .\n\nNote that you can derive an abstract class from a nonabstract class, and you can override a non-pure virtual function with a pure virtual function.\n\nThe default constructor of calls the pure virtual function both directly and indirectly (through ). You can call member functions from a constructor or destructor of an abstract class. However, the results of calling (directly or indirectly) a pure virtual function from its constructor are undefined. The following example demonstrates this:The default constructor ofcalls the pure virtual functionboth directly and indirectly (through)."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/abstract_class",
        "document": "Defines an abstract type which cannot be instantiated, but can be used as a base class.\n\nA pure virtual function is a virtual function whose declarator has the following syntax:\n\nHere the sequence is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier ( or ).\n\npure-specifier cannot appear in a member function definition or friend declaration.\n\nAn abstract class is a class that either defines or inherits at least one function for which the final overrider is pure virtual.\n\nAbstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).\n\nNo objects of an abstract class can be created (except for base subobjects of a class derived from it) and no non-static data members whose type is an abstract class can be declared.\n\nAbstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).\n\nPointers and references to an abstract class can be declared.\n\nThe definition of a pure virtual function may be provided (and must be provided if the pure virtual is the destructor): the member functions of the derived class are free to call the abstract base's pure virtual function using qualified function id. This definition must be provided outside of the class body (the syntax of a function declaration doesn't allow both the pure specifier and a function body).\n\nMaking a virtual call to a pure virtual function from a constructor or the destructor of the abstract class is undefined behavior (regardless of whether it has a definition or not).\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://ibm.com/docs/ssw_ibm_i_73/rzarg/cplr142.htm",
        "document": "An abstract class is a class that is designed to be specifically used as a base class. An abstract class contains at least one pure virtual function. You declare a pure virtual function by using a pure specifier ( ) in the declaration of a virtual member function in the class declaration.\n\nFunction is a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following: You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this: struct A { virtual void f() = 0; }; struct B : A { virtual void f() { } }; // Error: // Class A is an abstract class // A g(); // Error: // Class A is an abstract class // void h(A); A& i(A&); int main() { // Error: // Class A is an abstract class // A a; A* pa; B b; // Error: // Class A is an abstract class // static_cast<A>(b); } Class is an abstract class. The compiler would not allow the function declarations or , declaration of object , nor the static cast of to type . The following is an example of an abstract class:Functionis a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following:You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this:Classis an abstract class. The compiler would not allow the function declarationsor, declaration of object, nor the static cast ofto type\n\nVirtual member functions are inherited. A class derived from an abstract base class will also be abstract unless you override each pure virtual function in the derived class.\n\nNote that you can derive an abstract class from a nonabstract class, and you can override a non-pure virtual function with a pure virtual function.\n\nThe default constructor of calls the pure virtual function both directly and indirectly (through ). You can call member functions from a constructor or destructor of an abstract class. However, the results of calling (directly or indirectly) a pure virtual function from its constructor are undefined. The following example demonstrates this:The default constructor ofcalls the pure virtual functionboth directly and indirectly (through).\n\nThe compiler issues a warning for the direct call to the pure virtual function, but not for the indirect call."
    },
    {
        "link": "https://condor.depaul.edu/dmumaugh/OOT/Design-Principles/abcpvf.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-cpp",
        "document": "A virtual function is a member function that is declared in the base class using the keyword virtual and is re-defined (Overridden) in the derived class. It tells the compiler to perform late binding where the compiler matches the object with the right called function and executes it during the runtime. This technique falls under Runtime Polymorphism.\n\nThe term Polymorphism means the ability to take many forms. It occurs if there is a hierarchy of classes that are all related to each other by inheritance. In simple words, when we break down Polymorphism into ‘Poly – Many’ and ‘morphism – Forms’ it means showing different characteristics in different situations.\n\nConsider the following simple program as an example of runtime polymorphism. The main thing to note about the program is that the derived class’s function is called using a base class pointer.\n\nThe idea is that virtual functions are called according to the type of the object instance pointed to or referenced, not according to the type of the pointer or reference.\n\nIn other words, virtual functions are resolved late, at runtime.\n\nNow, we’ll look at an example without using the concepts of virtual function to clarify your understanding.\n\nIn the above example:\n• We store the address of each child’s class Rectangle and Square object in s and\n• Then we call the get_Area() function on it,\n• Ideally, it should have called the respective get_Area() functions of the child classes but\n• Instead, it calls the get_Area() defined in the base class.\n• This happens due to static linkage which means the call to get_Area() is getting set only once by the compiler which is in the base class.\n\nExample: C++ Program to Calculate the Area of Shapes using Virtual Function\n\nWhat is the use? \n\nVirtual functions allow us to create a list of base class pointers and call methods of any of the derived classes without even knowing the kind of derived class object.\n\nReal-Life Example to Understand the Implementation of Virtual Function\n\nConsider employee management software for an organization.\n\nLet the code has a simple base class Employee, the class contains virtual functions like raiseSalary(), transfer(), promote(), etc. Different types of employees like Managers, Engineers, etc., may have their own implementations of the virtual functions present in base class Employee.\n\nIn our complete software, we just need to pass a list of employees everywhere and call appropriate functions without even knowing the type of employee. For example, we can easily raise the salary of all employees by iterating through the list of employees. Every type of employee may have its own logic in its class, but we don’t need to worry about them because if raiseSalary() is present for a specific employee type, only that function would be called.\n\nLike the ‘globalRaiseSalary()‘ function, there can be many other operations that can be performed on a list of employees without even knowing the type of the object instance. \n\nVirtual functions are so useful that later languages like Java keep all methods virtual by default.\n\nHow does the compiler perform runtime resolution?\n\nThe compiler maintains two things to serve this purpose:\n• vptr: A pointer to vtable, maintained per object instance (see this for an example).\n\n\n\nThe compiler adds additional code at two places to maintain and use vptr.\n\n1. Code in every constructor. This code sets the vptr of the object being created. This code sets vptr to point to the vtable of the class.\n\n2. Code with polymorphic function call (e.g. bp->show() in above code). Wherever a polymorphic call is made, the compiler inserts code to first look for vptr using a base class pointer or reference (In the above example, since the pointed or referred object is of a derived type, vptr of a derived class is accessed). Once vptr is fetched, vtable of derived class can be accessed. Using vtable, the address of the derived class function show() is accessed and called.\n\nIs this a standard way for implementation of run-time polymorphism in C++? \n\nThe C++ standards do not mandate exactly how runtime polymorphism must be implemented, but compilers generally use minor variations on the same basic model."
    },
    {
        "link": "https://stackoverflow.com/questions/57332139/polymorphism-and-virtual-in-c",
        "document": "The key idea of polymorphism is to have one method. This method will have different implementations, and a particular implementation is called based on certain situations.\n\nLet's consider this example:\n\nWhen you run this code your output is the following:\n\nLet's add to in base class ( ) . Here is what you get:\n\nIf we have created a virtual function in the base class ( ) and it is being overridden in the derived class (In this case, and ) then we don’t need virtual keyword in the derived class, functions are automatically considered as virtual functions in the derived class.\n\nThe idea is will call the base class version of the method if is not virtual even if poly is pointed to Rect. On the other hand, that is virtual, it will call the actual method from the derived class. (In this case, will print \"From Rectangle\").\n\nDoing this means that in situations where I don't know the particular type of an object, I can use and and it will use the correct method during a call."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/polymorphism",
        "document": ""
    },
    {
        "link": "https://w3schools.com/cpp/cpp_polymorphism.asp",
        "document": "Polymorphism means \"many forms\", and it occurs when we have many classes that are related to each other by inheritance.\n\nLike we specified in the previous chapter; Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways.\n\nFor example, think of a base class called that has a method called . Derived classes of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.):\n\nNow we can create and objects and override the method:"
    },
    {
        "link": "https://forum.arduino.cc/t/c-inheritance-and-or-polymorphism-implementation-and-explanation/613876",
        "document": "I am fairly new to C++, and I am trying to clearly understand Inheritance and polymorphism, having said that, I will very much appreciatte a clear example and/or implementation of it. I am currently working on a project in Which I have two classes, and they basically parse a packet of data from a source, however the packet changes depending on the source, therefore I have written two different classes, each for its corresponding source, these two classes use pretty much the same functions, but with some small differences, I think that there should be a nice and well structured way of doing this in one class using inheritance, I am simply not sure about how to implement it.\n\n Thank you. class PARSER1 { public: PARSER1(); void commonFunction1(); bool commonFunction2(char rxd); uint8_t commonFunction3(); void commonFunction4(char buf[]); } class PARSER2 { public: PARSER2(); void commonFunction2_1(); bool commonFunction2_2(char rxd); uint8_t commonFunction3_3(); void commonFunction4_4(char buf[]); } /*In the main program I create an instance of the class that I need depending on the source Ideally I could do this in the Base class */ PARSER2 parser2 PARSER1 parser1\n\n{\n\n public:\n\n Parser() {};\n\n virtual void commonFunction1() = 0; // Pure Virtual: MUST be declared in derived class\n\n virtual bool commonFunction2(char rxd) {return true;}; // Virtual: May be overridden in derived class\n\n uint8_t commonFunction3() {return 0;}\n\n void commonFunction4(char buf[]) {}\n\n }; // Create an instance of each of the two derived types\n\n Parser1 parser1;\n\n Parser2 parser2; // Pass an object of any derived type\n\n void parserInit(Parser &parser)\n\n {\n\n parser.commonFunction1(); // This calls commonFunction1() for the correct derived type\n\n } {\n\n public:\n\n Parser() {};\n\n virtual void commonFunction1() = 0; // Pure Virtual: MUST be declared in derived class\n\n virtual bool commonFunction2(char rxd) {return true;}; // Virtual: May be overridden in derived class\n\n uint8_t commonFunction3() {return 0;}\n\n void commonFunction4(char buf[]) {}\n\n }; // Create an instance of each of the two derived types\n\n Parser1 parser1;\n\n Parser2 parser2; // Pass an object of any derived type\n\n void parserInit(Parser &parser)\n\n {\n\n parser.commonFunction1(); // This calls commonFunction1() for the correct derived type\n\n } Thank you very much this is a perfect example as well, however I will choose what parser class to use on Run time in the setup function, therefore I will only use one class at the time, since I am running this in a micro I am bit concerned about memory occupation by the unused instance, is there a way to create the specific instance in the setup function ? based on a decisition, or does it not really affect efficiency ? does the unused obeject still get some memory allocated to it ?\n\nhere is yet another example with inheritance and polymorphism You have a class , which has 2 subclass ( or ). A is defined by its and \n\n A is a who has done some noticeable work on a certain \n\n an is also a but only defined by the year when joining the forum every class has a method that is defined as virtual in the base class and is overridden in the subclasses I then declare a few s and a few s and group them in an array of s Then in the setup, I go through the array and ask information about everyone. Technically the type of each element in the array is , but the compiler is smart enough to recognize they are of different subclasses and when calling the method, it picks the right one based on the actual class of that element, as you can see in the Serial Console (opened at 115200 bauds) const uint8_t maxStringSize = 30; class Person { protected: bool isMale = true; char personName[maxStringSize + 1]; // +1 for trailing null char public: Person(const bool m, const char* n): isMale(m) { if (n) strncpy(personName, n, maxStringSize); else strncpy(personName, \"no name\", maxStringSize); personName[maxStringSize] = '\\0'; // just in case } virtual float information() // without virtual you don't get polymorphisme -> early binding. otherwise late binding { Serial.print(F(\"@Person\\tname: \")); Serial.print(personName); Serial.print(F(\"\\tsex: \")); Serial.print(isMale ? F(\"male\") : F(\"female\")); return 0; } }; class VIP: public Person { protected: uint16_t keyYear; char famousFor[maxStringSize + 1]; // +1 for trailing null char public: VIP(const bool m, const char* n, uint16_t y, const char* majorTopic): Person(m, n), keyYear(y) { if (majorTopic) { strncpy(famousFor, majorTopic, maxStringSize); famousFor[maxStringSize] = '\\0'; // just in case } } virtual float information() override // without virtual you don't get polymorphisme -> early binding. otherwise late binding { Person::information(); Serial.print(F(\"\n\n\\t@VIP:\\tFamous for: \")); Serial.print(famousFor); Serial.print(F(\"\\tdone from year: \")); Serial.print(keyYear); return 0; } }; class Arduinist: public Person { protected: uint16_t joinedForumInYear; public: Arduinist(const bool m, const char* n, uint16_t y): Person(m, n), joinedForumInYear(y) {} virtual float information() override // without virtual you don't get polymorphisme -> early binding. otherwise late binding { Person::information(); Serial.print(F(\"\n\n\\t@Arduinist:\\tJoined forum in: \")); Serial.print(joinedForumInYear); return 0; } }; // ---------------------- VIP lovelace(false, \"Ada Byron (Lovelace)\", 1842, \"abstract science of operations\"); VIP ritchie(true, \"Dennis Ritchie\", 1972, \"the C language\"); VIP stroustrup(true, \"Bjarne Stroustrup\", 1983, \"the C++ language\"); Arduinist JimEli(true, \"Jim Eli\", 2009); Arduinist gfvalvo(true, \"GF Valvo\", 2016); Arduinist buggy_Code(true, \"Buggy Code\", 2019); Person* team[] = {&lovelace, &ritchie, &stroustrup, &JimEli, &gfvalvo, &buggy_Code}; uint8_t teamSize = sizeof(team) / sizeof(team[0]); void setup() { Serial.begin(115200); for (byte i = 0; i < teamSize; i++) { team[i]->information(); Serial.println('\n\n'); } } void loop() {} You should see in the console: [color=purple] @Person name: Ada Byron (Lovelace) sex: female @VIP: Famous for: abstract science of operations done from year: 1842 @Person name: Dennis Ritchie sex: male @VIP: Famous for: the C language done from year: 1972 @Person name: Bjarne Stroustrup sex: male @VIP: Famous for: the C++ language done from year: 1983 @Person name: Jim Eli sex: male @Arduinist: Joined forum in: 2009 @Person name: GF Valvo sex: male @Arduinist: Joined forum in: 2016 @Person name: Buggy Code sex: male @Arduinist: Joined forum in: 2019 [/color] PS/ this code should not define char arrays with massive size if you use only a subset of the memory, it should know ideally how to handle a pointer to flash memory and you could use the PROGMEM trick to minimize impact on SRAM. this would have added un-necessary complexity to the topic of this discussion\n\nBuggy_Code:\n\n Thank you very much this is a perfect example as well, however I will choose what parser class to use on Run time in the setup function, therefore I will only use one class at the time, since I am running this in a micro I am bit concerned about memory occupation by the unused instance, is there a way to create the specific instance in the setup function ? based on a decisition, or does it not really affect efficiency ? does the unused obeject still get some memory allocated to it ? FWIW, if you declare/define a class(es) and, or derived class(es), but never instantiate them, there is no memory used by the un-instantiated class(es). In most cases, even if you instantiate the class, but then never use it, the compiler is smart enough to catch this and use no additional memory.\n\nJ-M-L:\n\n here is yet another example with inheritance and polymorphism You have a class , which has 2 subclass ( or ). A is defined by its and \n\n A is a who has done some noticeable work on a certain \n\n an is also a but only defined by the year when joining the forum every class has a method that is defined as virtual in the base class and is overridden in the subclasses I then declare a few s and a few s and group them in an array of s Then in the setup, I go through the array and ask information about everyone. Technically the type of each element in the array is , but the compiler is smart enough to recognize they are of different subclasses and when calling the method, it picks the right one based on the actual class of that element, as you can see in the Serial Console (opened at 115200 bauds) public:\n\n Person(const bool m, const char* n): isMale(m)\n\n {\n\n if (n) strncpy(personName, n, maxStringSize);\n\n else strncpy(personName, \"no name\", maxStringSize);\n\n personName[maxStringSize] = '\\0'; // just in case\n\n } virtual float information() // without virtual you don't get polymorphisme -> early binding. otherwise late binding\n\n {\n\n Serial.print(F(\"@Person\\tname: \"));\n\n Serial.print(personName);\n\n Serial.print(F(\"\\tsex: \"));\n\n Serial.print(isMale ? F(\"male\") : F(\"female\"));\n\n return 0;\n\n }\n\n }; public:\n\n VIP(const bool m, const char* n, uint16_t y, const char* majorTopic): Person(m, n), keyYear(y) {\n\n if (majorTopic) {\n\n strncpy(famousFor, majorTopic, maxStringSize);\n\n famousFor[maxStringSize] = '\\0'; // just in case\n\n }\n\n } virtual float information() override // without virtual you don't get polymorphisme -> early binding. otherwise late binding\n\n {\n\n Person::information();\n\n Serial.print(F(\"\n\n\\t@VIP:\\tFamous for: \"));\n\n Serial.print(famousFor);\n\n Serial.print(F(\"\\tdone from year: \"));\n\n Serial.print(keyYear);\n\n return 0;\n\n }\n\n }; virtual float information() override // without virtual you don't get polymorphisme -> early binding. otherwise late binding\n\n {\n\n Person::information();\n\n Serial.print(F(\"\n\n\\t@Arduinist:\\tJoined forum in: \"));\n\n Serial.print(joinedForumInYear);\n\n return 0;\n\n }\n\n }; VIP lovelace(false, \"Ada Byron (Lovelace)\", 1842, \"abstract science of operations\");\n\n VIP ritchie(true, \"Dennis Ritchie\", 1972, \"the C language\");\n\n VIP stroustrup(true, \"Bjarne Stroustrup\", 1983, \"the C++ language\"); You should see in the console: [color=purple]\n\n @Person name: Ada Byron (Lovelace) sex: female\n\n @VIP: Famous for: abstract science of operations done from year: 1842 @Person name: Dennis Ritchie sex: male\n\n @VIP: Famous for: the C language done from year: 1972 @Person name: Bjarne Stroustrup sex: male\n\n @VIP: Famous for: the C++ language done from year: 1983 PS/ this code should not define char arrays with massive size if you use only a subset of the memory, it should know ideally how to handle a pointer to flash memory and you could use the PROGMEM trick to minimize impact on SRAM. this would have added un-necessary complexity to the topic of this discussion Thank you very much for such a nice example an explanation. I hope the questions below make some sense, I am just trying to understand every detail as clear as possible. if there were at least one pure virtual methid in the Person Class will this be an abstract Class ? Person* team[] = {&lovelace, &ritchie, &stroustrup, &JimEli, &gfvalvo, &buggy_Code}; /* * does this line declare an array of pointers of type Person referenced to the respective indexed object? if so, since this array declaration decay to a pointer (not sure about this) will this be a pointer to a pointer? * */\n\nThis line does indeed declare and define an array of pointers to instances that are a kind of Person. When you refer to a derived class instance using a pointer or a reference to the base Person class, as demonstrated in the code above, you can call a virtual function for that instance (object) and execute the derived class’s version of the function. Virtual functions ensure that the correct member function is called for an instance, regardless of the type of reference (or pointer) used for function call, achieving Runtime polymorphism. So The array does hold the pointer to the instances and The compiler - noticing the call to a virtual member function - will generate code for resolving which function to call at Run-time. So That’s where instead of having a direct jump to the function code statically resolved, some cycles will be spent in a look up table to find where to jump."
    }
]