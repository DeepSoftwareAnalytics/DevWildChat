[
    {
        "link": "https://flask.palletsprojects.com/en/stable/patterns/wtforms",
        "document": "When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.\n\nWhen you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (Large Applications as Packages) for that and adding a separate module for the forms.\n\nGetting the most out of WTForms with an Extension The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI.\n\nIn the view function, the usage of this form looks like this: Notice we’re implying that the view is using SQLAlchemy here (SQLAlchemy in Flask), but that’s not a requirement, of course. Adapt the code as necessary.\n• None create the form from the request value if the data is submitted via the HTTP method and if the data is submitted as .\n• None to validate the data, call the method, which will return if the data validates, otherwise.\n• None to access individual values from the form, access .\n\nNow to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any. Here’s an example template with such a macro: This macro accepts a couple of keyword arguments that are forwarded to WTForm’s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call to add a class to the input element. Note that WTForms returns standard Python strings, so we have to tell Jinja2 that this data is already HTML-escaped with the filter. Here is the template for the function we used above, which takes advantage of the template: For more information about WTForms, head over to the WTForms website."
    },
    {
        "link": "https://flask-wtf.readthedocs.io",
        "document": "Simple integration of Flask and WTForms, including CSRF, file upload, and reCAPTCHA.\n\nIf you are looking for information on a specific function, class or method, this part of the documentation is for you."
    },
    {
        "link": "https://flask-wtf.readthedocs.io/en/1.2.x/quickstart",
        "document": "Eager to get started? This page gives a good introduction to Flask-WTF. It assumes you already have Flask-WTF installed. If you do not, head over to the Installation section.\n\nFlask-WTF provides your Flask application integration with WTForms. For example: From version 0.9.0, Flask-WTF will not import anything from wtforms, you need to import fields from wtforms. In addition, a CSRF token hidden field is created automatically. You can render this in your template: If your form has multiple hidden fields, you can render them in one block using .\n\nValidating the request in your view handlers: Note that you don’t have to pass to Flask-WTF; it will load automatically. And the convenient will check if it is a POST request and if it is valid. If your forms include validation, you’ll need to add to your template to display any error messages. Using the field from the example above, that would look like this: Heading over to Creating Forms to learn more skills."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-and-validate-web-forms-with-flask-wtf",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nWeb forms, such as text fields and text areas, give users the ability to send data to your application, whether that’s a drop-down or a radio button that the application will use to perform an action, or to send large areas of text to be processed or displayed. For example, in a social media application, you might give users a box where they can add new content to their pages.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. To render and validate web forms in a safe and flexible way in Flask, you’ll use Flask-WTF, which is a Flask extension that helps you use the WTForms library in your Flask application.\n\nWTForms is a Python library that provides flexible web form rendering. You can use it to render text fields, text areas, password fields, radio buttons, and others. WTForms also provides powerful data validation using different validators, which validate that the data the user submits meets certain criteria you define. For example, if you have a required field, you can ensure data the user submits is provided, or has a certain length.\n\nWTForms also uses a CSRF token to provide protection from CSRF attacks, which are attacks that allows the attacker to execute unwanted actions on a web application in which the user is authenticated. A successful CSRF attack can force the user to perform state-changing requests like transferring funds to the attacker’s bank account in a banking application, changing the user’s email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.\n\nIn this tutorial, you’ll build a small web application that demonstrates how to render and validate web forms using Flask-WTF. The application will have a page for displaying courses that are stored in a Python list, and the index page will have a form for entering the course title, its description, price, availability, and level (beginner, intermediate, or advanced).\n• A local Python 3 programming environment. Follow the tutorial for your operating system in the How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial you’ll call the project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n• (optional) An understanding of basic web form usage in Flask. See How To Use Web Forms in a Flask Application.\n\nIn this step, you’ll install Flask and Flask-WTF, which also installs the WTForms library automatically.\n\nWith your virtual environment activated, use to install Flask and Flask-WTF:\n\nOnce the installation is successfully finished, you’ll see a line similar to the following at the end of the output:\n\nAs you can see, the WTForms library was also installed as a dependency of the Flask-WTF package. The rest of the packages are Flask dependencies.\n\nNow that you’ve installed the required Python packages, you’ll set up a web form next.\n\nIn this step, you’ll set up a web form using fields and validators you’ll import from the WTForms library.\n\nYou’ll set up the following fields:\n• Title: A text input field for the course title.\n• Description: A text area field for the course description.\n• Price: An integer field for the price of the course.\n• Level: A radio field for the course level with three choices: Beginner, Intermediate, and Advanced.\n• Available: A checkbox field that indicates whether the course is currently available.\n\nFirst, open a new file called in your directory. This file will have the forms you’ll need in your application:\n\nThis file will have a class that represents your web form. Add the following imports at the top:\n\nTo build a web form, you will create a subclass of the base class, which you import from the package. You also need to specify the fields you use in your form, which you will import from the package.\n\nYou import the following fields from the WTForms library:\n• : A field for displaying a list of radio buttons for the user to choose from.\n\nIn the line , you import validators to use on the fields to make sure the user submits valid data. is a validator you’ll use to ensure the input is provided, and is for validating the length of a string to ensure it has a minimum number of characters, or that it doesn’t exceed a certain length.\n\nNext, add the following class after the statements:\n\nIn this class, you inherit from the base class you imported earlier. You define a collection of form fields as class variables using the form fields you imported from the WTForms library. When you instantiate a field, the first argument is the field’s label.\n\nYou define the validators for each field by passing a list of the validators you import from the module. The title field, for example, has the string as a label, and two validators:\n• : To indicate that the field should not be empty.\n• : Takes two arguments; is set to to make sure that the title is at least 10 characters long, and is set to to ensure it doesn’t exceed 100 characters.\n\nThe description text area field has an validator and a validator with the parameter set to , with no value for the parameter, which means the only requirement is that it doesn’t exceed 200 characters.\n\nSimilarly you define a required integer field for the price of the course called .\n\nThe field is a radio field with multiple choices. You define the choices in a Python list and pass it to the parameter. You also define the field as required using the validator.\n\nThe field is a check box field. You set a default value by passing it to the parameter. This means the check box will be checked when adding new courses unless the user unchecks it, meaning courses are available by default.\n\nFor more on how to use the WTForms library, see the Crash Course page on the WTForms documentation. See the Fields page for more fields, and the Validators page for more validators to validate form data.\n\nYou’ve configured your web form in a file. Next, you’ll create a Flask application, import this form, and display its fields on the index page. You’ll also display a list of courses on another page.\n\nIn this step, you’ll create a Flask application, display the web form you created in the previous step on the index page, and also create a list of courses and a page for displaying the courses on it.\n\nWith your programming environment activated and Flask installed, open a file called for editing inside your directory:\n\nThis file will import the necessary class and helpers from Flask, and the from the file. You’ll build a list of courses, then instantiate the form and pass it to a template file. Add the following code to :\n\nHere you import the following from Flask:\n• The function to render the index template.\n• The function to redirect the user to the courses page once a new course is added.\n\nFirst you import the class from the file, then you create a Flask application instance called .\n\nYou set up a secret key configuration for WTForms to use when generating a CSRF token to secure your web forms. The secret key should be a long random string. See Step 3 of How To Use Web Forms in a Flask Application for more information on how to obtain a secret key.\n\nThen you create a list of dictionaries called , which currently has one dictionary with a sample course titled . Here, you use a Python list as a data store for demonstration purposes. In a real world scenario, you’ll use a database such as SQLite. See How To Use an SQLite Database in a Flask Application to learn how to use a database to store your courses’ data.\n\nYou create a main route using the decorator on the view function. It accepts both and HTTP methods in the parameter. GET methods are for retrieving data, and POST requests are for sending data to the server, through a web form for example. For more, see How To Use Web Forms in a Flask Application.\n\nYou instantiate the class that represents the web form and save the instance in a variable called . You then return a call to the function, passing it a template file called and the form instance.\n\nTo display the web form on the index page, you will first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the template file you rendered in your function. To learn more about templates, see How to Use Templates in a Flask Application.\n\nCreate a folder in your directory where Flask searches for templates, then open a template file called , which will be the base template for other templates:\n\nAdd the following code inside the file to create the base template with a navbar and a content block:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the helper function to link to the view function, and the other for an About page if you choose to include one in your application.\n\nNext, open a template called . This is the template you referenced in the file:\n\nThis file will have the web form you passed to the template via the variable. Add the following code to it:\n\nYou extend the base template, and set a title in an tag. Then you render the web form fields inside a tag, setting its method to and the action to the main route, which is the index page. You first render the CSRF token WTForms uses to protect your form from CSRF attacks using the line . This token gets sent to the server with the rest of the form data. Remember to always render this token to secure your forms.\n\nYou render each field using the syntax and you render its label using the syntax . You can pass arguments to the field to control how it is displayed. For example, you set the size of the title input field in , and you set the numbers of rows and columns for the description text area via the parameters and the same way you would do normally in HTML. You can use the same method to pass additional HTML attributes to a field such as the attribute to set a CSS class.\n\nYou check for validation errors using the syntax . If a field has errors, you loop through them with a loop and display them in a list below the field.\n\nWhile in your directory with your virtual environment activated, tell Flask about the application ( in this case) using the environment variable. Then set the environment variable to to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see How To Handle Errors in a Flask Application. Use the following commands to do this (on Windows, use instead of ):\n\nWith the development server running, visit the following URL using your browser:\n\nYou’ll see the web form displayed on the index page:\n\nTry to submit the form without filling in the title. You’ll see an error message informing you that the title is required. Experiment with the form by submitting invalid data (such as a short title less than 10 characters long, or a description over 200 characters long) to see other error messages.\n\nFilling the form with valid data does nothing so far because you don’t have code that handles form submission. You’ll add the code for that later.\n\nFor now, you need a page to display the courses you have in your list. Later, handling the web form data will add a new course to the list and redirect the user to the courses page to see the new course added to it.\n\nLeave the development server running and open another terminal window.\n\nNext, open to add the courses route:\n\nAdd the following route at the end of the file:\n\nThis route renders a template called , passing it the list.\n\nThen create the template to display courses:\n\nAdd the following code to it:\n\nYou set a title and loop through the items of the list. You display the title in an tag, the description in an tag, and the price and course level in a tag. You check whether the course is available using the condition . You display the text “Available” if the course is available, and the text “Not Available” if it’s not available.\n\nUse your browser to go to the courses page:\n\nYou’ll see a page with one course displayed, because you only have one course in your course list so far:\n\nNext, open to add a link to the courses page in the navigation bar:\n\nEdit it to look as follows:\n\nRefresh the index page, and you’ll see a new Courses link in the navigation bar.\n\nYou’ve created the pages you need for your application: An index page with a web form for adding new courses and a page for displaying the courses you have in your list.\n\nTo make the application functional, you need to handle the web form data when the user submits it by validating it and adding it to the courses list. You’ll do this next.\n\nIn this step, you’ll access data the user submits, validate it, and add it to the list of courses.\n\nOpen to add code for handling the web form data inside the function:\n\nEdit the function to look as follows:\n\nSave and close the file. Here, you call the method on the object, which checks that the request is a POST request, and runs the validators you configured for each field. If at least one validator returns an error, the condition will be , and each error will be displayed below the field that caused it.\n\nIf the submitted form data is valid, the condition is , and the code below the statement will be executed. You build a course dictionary, and use the method to add the new course to the list. You access the value of each field using the syntax . After you add the new course dictionary to the courses list, you redirect the user to the page.\n\nWith the development server running, visit the index page:\n\nFill the form with valid data and submit it. You’ll be redirected to the page, and you’ll see the new course displayed on it.\n\nYou made a Flask application that has a web form you built using the Flask-WTF extension and the WTForms library. The form has several types of fields to receive data from the user, validate it using special WTForms validators, and add it to a data store.\n\nIf you would like to read more about Flask, check out the other tutorials in the How To Create Web Sites with Flask series."
    },
    {
        "link": "https://flask-wtf.readthedocs.io/en/1.0.x/quickstart",
        "document": "Eager to get started? This page gives a good introduction to Flask-WTF. It assumes you already have Flask-WTF installed. If you do not, head over to the Installation section.\n\nFlask-WTF provides your Flask application integration with WTForms. For example: From version 0.9.0, Flask-WTF will not import anything from wtforms, you need to import fields from wtforms. In addition, a CSRF token hidden field is created automatically. You can render this in your template: If your form has multiple hidden fields, you can render them in one block using .\n\nValidating the request in your view handlers: Note that you don’t have to pass to Flask-WTF; it will load automatically. And the convenient will check if it is a POST request and if it is valid. If your forms include validation, you’ll need to add to your template to display any error messages. Using the field from the example above, that would look like this: Heading over to Creating Forms to learn more skills."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. SQLAlchemy is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database’s SQL functionalities. And it also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. Flask-SQLAlchemy is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.\n\nA one-to-many database relationship is a relationship between two database tables where a record in one table can reference several records in another table. For example, in a blogging application, a table for storing posts can have a one-to-many relationship with a table for storing comments. Each post can reference many comments, and each comment references a single post; therefore, one post has a relationship with many comments. The post table is a parent table, while the comments table is a child table — a record in the parent table can reference many records in the child table. This relationship is important to enable access to related data in each table.\n\nIn this tutorial, you’ll build a small blogging system that demonstrates how to build one-to-many relationships using the Flask-SQLAlchemy extension. You’ll create a relationship between posts and comments, where each blog post can have several comments.\n• A local Python 3 programming environment. Follow the tutorial for your distribution in How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial we’ll call our project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n\nIn this step, you’ll install the necessary packages for your application.\n\nWith your virtual environment activated, use to install Flask and Flask-SQLAlchemy:\n\nOnce the installation is successfully finished, you’ll see a line similar to the following at the end of the output:\n\nWith the required Python packages installed, you’ll set up the database next.\n\nStep 2 — Setting up the Database and Models\n\nIn this step, you’ll set up your database, and create SQLAlchemy database models — Python classes that represent your database tables. You’ll create a model for your blog posts and a model for comments. You’ll initiate the database, create a table for posts, and add a table for comments based on the models you’ll declare. You’ll also insert a few posts and comments into your database.\n\nOpen a file called in your directory. This file will have code for setting up the database and your Flask routes:\n\nThis file will connect to an SQLite database called , and will have two classes: A class called that represents your database posts table, and a class representing the comments table. This file will also contain your Flask routes. Add the following statements at the top of :\n\nHere, you import the module, which gives you access to miscellaneous operating system interfaces. You’ll use it to construct a file path for your database file.\n\nFrom the package, you then import the necessary helpers you need for your application: the class to create a Flask application instance, the function to render templates, the object to handle requests, the function to construct URLs for routes, and the function for redirecting users. For more information on routes and templates, see How To Use Templates in a Flask Application.\n\nYou then import the class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You’ll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.\n\nBelow the imports, you’ll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:\n\nHere, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the function to get the absolute path of the current file’s directory. The special variable holds the pathname of the current file. You store the absolute path of the base directory in a variable called .\n\nYou then create a Flask application instance called , which you use to configure two Flask-SQLAlchemy configuration keys:\n• : The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format . You use the function to intelligently join the base directory you constructed and stored in the variable, and the file name. This will connect to a database file in your directory. The file will be created once you initiate the database.\n• : A configuration to enable or disable tracking modifications of objects. You set it to to disable tracking and use less memory. For more, see the configuration page in the Flask-SQLAlchemy documentation.\n\nAfter configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called . You’ll use this object to interact with your database.\n\nWith the database connection established and the database object created, you’ll use the database object to create a database table for posts and one for comments. Tables are represented by a model — a Python class that inherits from a base class Flask-SQLAlchemy provides through the database instance you created earlier. To define the posts and comments tables as models, add the following two classes to your file:\n\nHere, you create a model and a model, which inherit from the class.\n\nThe model represents the post table. You use the class to define its columns. The first argument represents the column type, and additional arguments represent the column configuration.\n\nYou define the following columns for the model:\n• : The post ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is, each post).\n• : The post’s title. A string with a maximum length of 100 characters.\n• : The post’s content. indicates the column holds long texts.\n\nThe class attribute defines a One-to-Many relationship between the model and the model. You use the method, passing it the name of the comments model ( in this case). You use the parameter to add a back reference that behaves like a column to the model. This way, you can access the post the comment was posted on using a attribute. For example, if you have a comment object in a variable called , you will be able to access the post the comment belongs to using . You’ll see an example demonstrating this later.\n\nSee the SQLAlchemy documentation for column types other than the types you used in the preceding code block.\n\nThe special function allows you to give each object a string representation to recognize it for debugging purposes.\n\nThe model represents the comment table. You define the following columns for it:\n• : The comment ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is, each comment).\n• : The comment’s content. indicates the column holds long texts.\n• : An integer foreign key you construct using the class, which is a key that links a table with another, using that table’s primary key. This links a comment to a post using the primary key of the post, which is its ID. Here, the table is a parent table, which indicates that each post has many comments. The table is a child table. Each comment is related to a parent post using the post’s ID. Therefore, each comment has a column that can be used to access the post the comment was posted on.\n\nThe special function in the model shows the first 20 characters of the comment’s content to give a comment object a short string representation.\n\nThe file will now look as follows:\n\nNow that you’ve set the database connection and the post and comment models, you’ll use the Flask shell to create your database and your post and comment tables based on the models you declared.\n\nWith your virtual environment activated, set the file as your Flask application using the environment variable:\n\nThen open the Flask shell using the following command in your directory:\n\nA Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you’ll call are connected to your application.\n\nImport the database object and the post and comment models, and then run the function to create the tables that are associated with your models:\n\nLeave the shell running, open another terminal window and navigate to your directory. You will now see a new file called in .\n\nIf you receive an error, make sure your database URI and your model declaration are correct.\n\nAfter creating the database and the post and comment tables, you’ll create a file in your directory to add some posts and comments to your database.\n\nAdd the following code to it. This file will create three post objects and four comment objects, and add them to the database:\n\nHere, you import the database object, the model, and the model from the file.\n\nYou create a few post objects using the model, passing the post’s title to the parameter and the post’s content to the parameter.\n\nYou then create a few comment objects, passing the comment’s content. You have two methods you can use to associate a comment with the post it belongs to. You can pass the post object to the parameter as demonstrated in the and objects. And you can also pass the post ID to the parameter, as demonstrated in the and objects. So you can just pass the integer ID of the post if you don’t have the post object in your code.\n\nAfter defining the post and comment objects, you use the to add all post and comment objects to the database session, which manages transactions. Then you use the method to commit the transaction and apply the changes to the database. For more on SQLAlchemy database sessions, see step 2 of the How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application tutorial.\n\nRun the file to execute the code and add the data to the database:\n\nTo take a look at the data you added to your database, open the flask shell to query all posts and display their titles and the content of each post’s comments:\n\nRun the following code. This queries all posts and displays each post title and the comments of each post below it:\n\nHere, you import the model from the file. You query all the posts that exist in the database using the method on the attribute, and save the result in a variable called . Then you use a loop to go through each item in the variable. You print the title and then use another loop to go through each comment belonging to the post. You access the post’s comments using . You print the comment’s content and then print the string to separate between posts.\n\nYou’ll get the following output:\n\nAs you can see, you can access the data of each post and the comments of each post with very little code.\n\nAt this point, you have several posts and comments in your database. Next, you’ll create a Flask route for the index page and display all of the posts in your database on it.\n\nIn this step, you’ll create a route and a template to display all the posts in the database on the index page.\n\nOpen your file to add a route for the index page to it:\n\nAdd the following route at the end of the file:\n\nHere, you create an view function using the decorator. In this function, you query the database and get all the posts like you did in the previous step. You store the query result in a variable called and then you pass it to a template file you render using the helper function.\n\nBefore you create the template file on which you’ll display the existing posts in the database, you’ll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the template file you rendered in your function. To learn more about templates, see How to Use Templates in a Flask Application.\n\nAdd the following code inside the file:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the view function using the helper function, one for a Comments page, and one for an About page if you choose to add one to your application. You’ll edit this file later after you add a page for displaying all the latest comments to make the Comments link functional.\n\nNext, open a new template file. This is the template you referenced in the file:\n\nAdd the following code to it:\n\nHere, you extend the base template and replace the contents of the content block. You use an heading that also serves as a title. You use a Jinja loop in the line to go through each post in the variable that you passed from the view function to this template. You display the post ID, its title, and the post content. The post title will later link to a page that displays the individual post and its comments.\n\nWhile in your directory with your virtual environment activated, tell Flask about the application ( in this case) using the environment variable. Then set the environment variable to to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see How To Handle Errors in a Flask Application. Use the following commands to do this:\n\nWith the development server running, visit the following URL using your browser:\n\nYou’ll see the posts you added to the database in a page similar to the following:\n\nYou’ve displayed the posts you have in your database on the index page. Next, you’ll create a route for a post page, where you will display the details of each post and its comments below it.\n\nIn this step, you’ll create a route and a template to display the details of each post on a dedicated page, and the post’s comments below it.\n\nBy the end of this step, the URL will be a page that displays the first post (because it has the ID ) and its comments. The URL will display the post with the associated number, if it exists.\n\nLeave the development server running and open a new terminal window.\n\nAdd the following route at the end of the file:\n\nHere, you use the route , with being a converter that converts the default string in the URL into an integer. is the URL variable that will determine the post you’ll display on the page.\n\nThe ID is passed from the URL to the view function through the parameter. Inside the function, you query the post table and retrieve a post by its ID using the method. This will save the post data in the variable if it exists, and respond with a HTTP error if no post with the given ID exists in the database.\n\nYou render a template called and pass it the post you retrieved.\n\nType the following code in it. This will be similar to the template, except that it will only display a single post:\n\nHere, you extend the base template, set the post title as a page title, display the post ID, post title, and the post content. Then, you go through the post comments available via . You display the comment ID, and the contents of the comment.\n\nUse your browser to navigate to the URL for the second post:\n\nYou’ll see a page similar to the following:\n\nNext, edit to make the title of the post link to the individual post:\n\nEdit the value of the attribute of the post title’s link inside the loop:\n\nNavigate to your index page or refresh it:\n\nClick on each of the post titles on the index page. You’ll now see that each post links to the proper post page.\n\nYou’ve now created a page for displaying individual posts. Next, you’ll add a web form to the post page to allow users to add new comments.\n\nIn this step, you’ll edit the route and its view function, which handles displaying an individual post. You’ll add a web form below each post to allow users to add comments to that post, then you’ll handle the comment submission and add it to the database.\n\nFirst, open the template file to add a web form consisting of a text area for the comment’s content, and an Add Comment submit button.\n\nEdit the file by adding a form below the H3 heading, and directly above the loop:\n\nHere, you add a tag with the attribute set to to indicate that the form will submit a POST request.\n\nYou have a text area for the comment’s content, and a submit button.\n\nWith the development server running, use your browser to navigate to a post:\n\nYou’ll see a page similar to the following:\n\nThis form sends a POST request to the view function, but because there is no code to handle the form submission, the form currently does not work.\n\nNext, you will add code to the view function to handle the form submission and add the new comment to the database. Open to handle the POST request the user submits:\n\nEdit the route and its view function to look as follows:\n\nYou allow both GET and POST requests using the parameter. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed.\n\nInside the condition, you handle the POST request the user will submit via the form. You create a comment object using the model, passing it the content of the submitted comment which you extract from the object. You specify the post the comment belongs to using the parameter, passing it the object you retrieved using the post ID, with the method.\n\nYou add the comment object you constructed to the database session, commit the transaction, and redirect to the post page.\n\nNow refresh the post page on your browser, write a comment, and submit it. You’ll see your new comment below the post.\n\nYou now have a web form that allows users to add comments to a post. For more on web forms, see How To Use Web Forms in a Flask Application. For a more advanced and more secure method of managing web forms, see How To Use and Validate Web Forms with Flask-WTF. Next, you’ll add a page that displays all the comments in the database and the posts they were posted on.\n\nIn this step, you’ll add a Comments page where you will display all the comments in the database, ordering them by displaying the newest comments first. Each comment will have the title and link of the post the comment was posted on.\n\nAdd the following route to the end of the file. This fetches all the comments in the database, ordered by the latest first. It then passes them to a template file called , which you’ll create later:\n\nYou use the method on the attribute to fetch all the comments in a specific order. In this case you use the method on the column to fetch comments in descending order, with the latest comments being first. Then you use the method to get the result and save it to a variable called .\n\nYou render a template called , passing it the object which contains all comments ordered by the latest first.\n\nType the following code inside it. This will display the comments and link to the post they belong to:\n\nHere, you extend the base template, set a title, and go through the comments using a loop. You display the comment’s ID, its content, and a link to the post it belongs to. You access the post data via .\n\nUse your browser to navigate to the comments page:\n\nYou’ll see a page similar to the following:\n\nNow edit the template to make the Comments navbar link point to this Comments page:\n\nEdit the navigation bar to look as follows:\n\nRefresh your comments page, and you’ll see that the Comments navbar link works.\n\nYou now have a page that displays all the comments in the database. Next, you’ll add a button below each comment on the post page to allow users to delete it.\n\nIn this step, you’ll add a Delete Comment button below each comment to allow users to delete unwanted comments.\n\nFirst, you’ll add a new route that accepts POST requests. The view function will receive the ID of the comment you want to delete, fetch it from the database, delete it, and the redirect to post page the deleted comment was on.\n\nAdd the following route to the end of the file.\n\nHere, instead of using the usual decorator, you use the decorator introduced in Flask version 2.0.0, which added shortcuts for common HTTP methods. For example, is a shortcut for . This means that this view function only accepts POST requests, and navigating to the route on your browser will return a error, because web browsers default to GET requests. To delete a comment, the user clicks on a button that sends a POST request to this route.\n\nThis view function receives the ID of the comment to be deleted via the URL variable. You use the method to get a comment and save it in a variable, or respond with a in case the comment doesn’t exist. You save the post ID of the post the comment belongs to in a variable, which you’ll use to redirect to the post after deleting the comment.\n\nYou use the method on the database session in the line , passing it the comment object. This sets up the session to delete the comment whenever the transaction is committed. Because you don’t need to perform any other modifications, you directly commit the transaction using . Lastly, you redirect the user to the post the now-deleted comment was posted on.\n\nNext, edit the template to add a Delete Comment button below each comment:\n\nEdit the loop by adding a new tag directly below the comment content:\n\nHere, you have a web form that submits a POST request to the view function. You pass as an argument for the parameter to specify the comment that will be deleted. You use the method function available in web browsers to display a confirmation message before submitting the request.\n\nNow navigate to a post page on your browser:\n\nYou’ll see a Delete Comment button below each comment. Click on it, and confirm the deletion. You’ll see that the comment has been deleted.\n\nYou now have a way of deleting comments from the database.\n\nYou built a small blogging system that demonstrates how to manage one-to-many relationships using the Flask-SQLAlchemy extension. You learned how to connect a parent table with a child table, associate a child object with its parent and add it to the database, and how to access child data from a parent entry and vise versa.\n\nIf you would like to read more about Flask, check out the other tutorials in the How To Build Web Applications with Flask series."
    },
    {
        "link": "https://stackoverflow.com/questions/72662922/flask-sqlalchemy-one-to-many-relationship-within-the-same-table-not-working",
        "document": "I am trying to create a table in SQLAlchemy which has a one to many relationship within the same table. What I currently have is a dog class and I want a dog to be able to link to multiple children and I also want the children to be able to link back to their parents. I am currently using an SQLite database if that makes a difference\n\nThere have been some similar posts on this topic, for example here and here, and here. I have also tried using the documentation on Adjacency List Relations, but I have not been able to find any solution that is working for me.\n\nHere is my current code:\n\nWhen I try to run my flask app I am met with this error\n\nBased on that error I also tried supplying a list of foreign keys to the relationship, like this\n\nBut that also led to an error:\n\nAny help would be greatly appreciated, apologies if I am missing something simple, or if there is a much simpler way to do this that I don't know, thank you."
    },
    {
        "link": "http://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html",
        "document": "A quick walkthrough of the basic relational patterns, which in this section are illustrated using Declarative style mappings based on the use of the annotation type.\n\nThe setup for each of the following sections is as follows:\n\nAs SQLAlchemy has evolved, different ORM configurational styles have emerged. For examples in this section and others that use annotated Declarative mappings with , the corresponding non-annotated form should use the desired class, or string class name, as the first argument passed to . The example below illustrates the form used in this document, which is a fully Declarative example using PEP 484 annotations, where the construct is also deriving the target class and collection type from the annotation, which is the most modern form of SQLAlchemy Declarative mapping: In contrast, using a Declarative mapping without annotations is the more “classic” form of mapping, where requires all parameters passed to it directly, as in the example below: Finally, using Imperative Mapping, which is SQLAlchemy’s original mapping form before Declarative was made (which nonetheless remains preferred by a vocal minority of users), the above configuration looks like: Additionally, the default collection style for non-annotated mappings is . To use a or other collection without annotations, indicate it using the parameter: Detail on collection configuration for is at Customizing Collection Access. Additional differences between annotated and non-annotated / imperative styles will be noted as needed.\n\nA one to many relationship places a foreign key on the child table referencing the parent. is then specified on the parent, as referencing a collection of items represented by the child: To establish a bidirectional relationship in one-to-many, where the “reverse” side is a many to one, specify an additional and connect the two using the parameter, using the attribute name of each as the value for on the other: will get a attribute with many-to-one semantics. Using Sets, Lists, or other Collection Types for One To Many¶ Using annotated Declarative mappings, the type of collection used for the is derived from the collection type passed to the container type. The example from the previous section may be written to use a rather than a for the collection using : When using non-annotated forms including imperative mappings, the Python class to use as a collection may be passed using the parameter. Customizing Collection Access - contains further detail on collection configuration including some techniques to map to dictionaries. Configuring Delete Behavior for One to Many¶ It is often the case that all objects should be deleted when their owning is deleted. To configure this behavior, the cascade option described at delete is used. An additional option is that a object can itself be deleted when it is deassociated from its parent. This behavior is described at delete-orphan. Using foreign key ON DELETE cascade with ORM relationships\n\nMany to one places a foreign key in the parent table referencing the child. is declared on the parent, where a new scalar-holding attribute will be created: The above example shows a many-to-one relationship that assumes non-nullable behavior; the next section, Nullable Many-to-One, illustrates a nullable version. Bidirectional behavior is achieved by adding a second and applying the parameter in both directions, using the attribute name of each as the value for on the other: In the preceding example, the relationship is not typed as allowing ; this follows from the column itself not being nullable, as it is typed with . If we wanted to be a nullable many-to-one, we can set both and to be , in which case the configuration would look like: Above, the column for will be created in DDL to allow values. When using with explicit typing declarations, the specification of is equivalent to setting to on the , whereas is equivalent to setting it to . See mapped_column() derives the datatype and nullability from the Mapped annotation for background on this behavior. If using Python 3.10 or greater, PEP 604 syntax is more convenient to indicate optional types using , which when combined with PEP 563 postponed annotation evaluation so that string-quoted types aren’t required, would look like:\n\nOne To One is essentially a One To Many relationship from a foreign key perspective, but indicates that there will only be one row at any time that refers to a particular parent row. When using annotated mappings with , the “one-to-one” convention is achieved by applying a non-collection type to the annotation on both sides of the relationship, which will imply to the ORM that a collection should not be used on either side, as in the example below: Above, when we load a object, the attribute will refer to a single object rather than a collection. If we replace the value of with a new object, the ORM’s unit of work process will replace the previous row with the new one, setting the previous column to NULL by default unless there are specific cascade behaviors set up. As mentioned previously, the ORM considers the “one-to-one” pattern as a convention, where it makes the assumption that when it loads the attribute on a object, it will get only one row back. If more than one row is returned, the ORM will emit a warning. However, the side of the above relationship remains as a “many-to-one” relationship. By itself, it will not detect assignment of more than one , unless the parameter is set, which may be useful: Outside of setting this parameter, the “one-to-many” side (which here is one-to-one by convention) will also not reliably detect if more than one is associated with a single , such as in the case where the multiple objects are pending and not database-persistent. Whether or not is used, it is recommended that the database schema include a unique constraint to indicate that the column should be unique, to ensure at the database level that only one row may refer to a particular row at a time (see Declarative Table Configuration for background on the tuple syntax): New in version 2.0: The construct can derive the effective value of the parameter from a given annotation. When using without the benefit of annotations, the one-to-one pattern can be enabled using the parameter set to on what would normally be the “many” side, illustrated in a non-annotated Declarative configuration below:\n\nThe association object pattern is a variant on many-to-many: it’s used when an association table contains additional columns beyond those which are foreign keys to the parent and child (or left and right) tables, columns which are most ideally mapped to their own ORM mapped class. This mapped class is mapped against the that would otherwise be noted as when using the many-to-many pattern. In the association object pattern, the parameter is not used; instead, a class is mapped directly to the association table. Two individual constructs then link first the parent side to the mapped association class via one to many, and then the mapped association class to the child side via many-to-one, to form a uni-directional association object relationship from parent, to association, to child. For a bi-directional relationship, four constructs are used to link the mapped association class to both parent and child in both directions. The example below illustrates a new class which maps to the named ; this table now includes an additional column called , which is a string value that is stored along with each association between and . By mapping the table to an explicit class, rudimental access from to makes explicit use of : To illustrate the bi-directional version, we add two more constructs, linked to the existing ones using : Working with the association pattern in its direct form requires that child objects are associated with an association instance before being appended to the parent; similarly, access from parent to child goes through the association object: To enhance the association object pattern such that direct access to the object is optional, SQLAlchemy provides the Association Proxy extension. This extension allows the configuration of attributes which will access two “hops” with a single access, one “hop” to the associated object, and a second to a target attribute. Association Proxy - allows direct “many to many” style access between parent and child for a three-class association object mapping. Avoid mixing the association object pattern with the many-to-many pattern directly, as this produces conditions where data may be read and written in an inconsistent fashion without special steps; the association proxy is typically used to provide more succinct access. For more detailed background on the caveats introduced by this combination, see the next section Combining Association Object with Many-to-Many Access Patterns. As mentioned in the previous section, the association object pattern does not automatically integrate with usage of the many-to-many pattern against the same tables/columns at the same time. From this it follows that read operations may return conflicting data and write operations may also attempt to flush conflicting changes, causing either integrity errors or unexpected inserts or deletes. To illustrate, the example below configures a bidirectional many-to-many relationship between and via and . At the same time, an association object relationship is also configured, between and : When using this ORM model to make changes, changes made to will not be coordinated with changes made to or in Python; while all of these relationships will continue to function normally by themselves, changes on one will not show up in another until the is expired, which normally occurs automatically after . Additionally, if conflicting changes are made, such as adding a new object while also appending the same related to , this will raise integrity errors when the unit of work flush process proceeds, as in the example below: # redundant, will cause a duplicate INSERT on Association Appending to directly also implies the creation of rows in the table without indicating any value for the column, which will receive for its value. It’s fine to use a mapping like the above if you know what you’re doing; there may be good reason to use many-to-many relationships in the case where use of the “association object” pattern is infrequent, which is that it’s easier to load relationships along a single many-to-many relationship, which can also optimize slightly better how the “secondary” table is used in SQL statements, compared to how two separate relationships to an explicit association class is used. It’s at least a good idea to apply the parameter to the “secondary” relationship to avoid the issue of conflicting changes occurring, as well as preventing being written to the additional association columns, as below: The above mapping will not write any changes to or to the database, preventing conflicting writes. However, reads of or will not necessarily match the data that’s read from or , if changes are being made to these collections within the same transaction or as where the viewonly collections are being read. If use of the association object relationships is infrequent and is carefully organized against code that accesses the many-to-many collections to avoid stale reads (in extreme cases, making direct use of to cause collections to be refreshed within the current transaction), the pattern may be feasible. A popular alternative to the above pattern is one where the direct many-to-many and relationships are replaced with an extension that will transparently proxy through the class, while keeping everything consistent from the ORM’s point of view. This extension is known as the Association Proxy. Association Proxy - allows direct “many to many” style access between parent and child for a three-class association object mapping.\n\nMost of the examples in the preceding sections illustrate mappings where the various constructs refer to their target classes using a string name, rather than the class itself, such as when using , a forward reference is generated that exists at runtime only as a string: Similarly, when using non-annotated forms such as non-annotated Declarative or Imperative mappings, a string name is also supported directly by the construct: These string names are resolved into classes in the mapper resolution stage, which is an internal process that occurs typically after all mappings have been defined and is normally triggered by the first usage of the mappings themselves. The object is the container where these names are stored and resolved to the mapped classes to which they refer. In addition to the main class argument for , other arguments which depend upon the columns present on an as-yet undefined class may also be specified either as Python functions, or more commonly as strings. For most of these arguments except that of the main argument, string inputs are evaluated as Python expressions using Python’s built-in eval() function, as they are intended to receive complete SQL expressions. As the Python function is used to interpret the late-evaluated string arguments passed to mapper configuration construct, these arguments should not be repurposed such that they would receive untrusted user input; is not secure against untrusted user input. The full namespace available within this evaluation includes all classes mapped for this declarative base, as well as the contents of the package, including expression functions like and : For the case where more than one module contains a class of the same name, string class names can also be specified as module-qualified paths within any of these string expressions: In an example like the above, the string passed to can be disambiguated from a specific class argument by passing the class location string directly to as well. Below illustrates a typing-only import for , combined with a runtime specifier for the target class that will search for the correct name within the : The qualified path can be any partial path that removes ambiguity between the names. For example, to disambiguate between and , we can specify or : The construct also accepts Python functions or lambdas as input for these arguments. A Python functional approach might look like the following: The full list of parameters which accept Python functions/lambdas or strings that will be passed to are: As stated previously, the above parameters to are evaluated as Python code expressions using eval(). DO NOT PASS UNTRUSTED INPUT TO THESE ARGUMENTS. It should also be noted that in a similar way as described at Appending additional columns to an existing Declarative mapped class, any construct can be added to a declarative base mapping at any time (noting that annotated forms are not supported in this context). If we wanted to implement this after the class were available, we could also apply it afterwards: # first, module A, where Child has not been created yet, # we create a Parent class which knows nothing about Child # ... later, in Module B, which is imported after module A: # assign the User.addresses relationship as a class variable. The # declarative base class will intercept this and map the relationship. As is the case for ORM mapped columns, there’s no capability for the annotation type to take part in this operation; therefore, the related class must be specified directly within the construct, either as the class itself, the string name of the class, or a callable function that returns a reference to the target class. As is the case for ORM mapped columns, assignment of mapped properties to an already mapped class will only function correctly if the “declarative base” class is used, meaning the user-defined subclass of or the dynamically generated class returned by or . This “base” class includes a Python metaclass which implements a special method that intercepts these operations. Runtime assignment of class-mapped attributes to a mapped class will not work if the class is mapped using decorators like or imperative functions like . Using a late-evaluated form for the “secondary” argument of many-to-many¶ Many-to-many relationships make use of the parameter, which ordinarily indicates a reference to a typically non-mapped object or other Core selectable object. Late evaluation using a lambda callable is typical. For the example given at Many To Many, if we assumed that the object would be defined at a point later on in the module than the mapped class itself, we may write the using a lambda as: As a shortcut for table names that are also valid Python identifiers, the parameter may also be passed as a string, where resolution works by evaluation of the string as a Python expression, with simple identifier names linked to same-named objects that are present in the same collection referenced by the current . In the example below, the expression is evaluated as a variable named “association_table” that is resolved against the table names within the collection: When passed as a string, the name passed to must be a valid Python identifier starting with a letter and containing only alphanumeric characters or underscores. Other characters such as dashes etc. will be interpreted as Python operators which will not resolve to the name given. Please consider using lambda expressions rather than strings for improved clarity. When passed as a string, argument is interpreted using Python’s function, even though it’s typically the name of a table. DO NOT PASS UNTRUSTED INPUT TO THIS STRING."
    },
    {
        "link": "https://stackoverflow.com/questions/25375179/one-to-many-flask-sqlalchemy",
        "document": "I am trying to create a one-to-many relationship using Flask and SQLAlchemy.\n\nI want the one-to-many relationship to be as so:\n\n\"For any single movie, there can be multiple characters\"\n\nHere it what I have so far, but it is saving in my DB as one-to-one right now. (One movie to one character, saving multiple times in DB for multiple characters)\n\nI am saving into the DB like this:\n\nThe end goal is to be able to look up what movie a character is in. If you could also help me out with that query, that would be great!"
    },
    {
        "link": "https://medium.com/nerd-for-tech/one-to-many-database-relationship-crud-with-postgresql-and-flask-part-1-6f87fb574b7c",
        "document": "One to many relationship is something that you will have to grasp(same about many to many).I will use my own project as an example Blog app and a relational database PostgreSQL and for common real time implication Flask web framework(optimally you have knowledge of HTML/CSS some Flask experience) where a logged in user can make own post and do\n\nWe will start off with importing the corresponding packages, connecting to our Flask instance, connecting to our PosgreSQL database and creating Models that will connect to particular __tablename__ and creating specific variables.\n\nThe obvious starting faze we connect to our Flask app instance and configure Flask by providing the PosgreSQL URI.\n\nThen we create a db variable with SQLAlchemy to connect to your database and create tables using models.\n\nClasses often have relationships and as discussed its like that here as well.\n\nFlask-SQLAlchemy, the backref parameter in relationship method allows you to declare a new property under a specified class here its specified as a ‘list’ Lazy parameter determines how the related objects get loaded when querying through relationships. lazy = ‘select’ (or True)\n\nThe PostForm(FlaskForm) class is being made as an addition to update or make altercations of existing post already made by a user. Shortly speaking a CRUD operation.You can read more about it here.\n\nThis part is straight forward and similar to my previous article:\n\nMain difference that we use relational database(+CRUD operations) and added more features on the front-end.\n\nBear with me the index() is the one that runs on default when running app.py and redirects to home page.\n\nIn this project home page has all the user posts already listed.\n\nFlask pagination example is implemented as well so that more than 3 posts wont be in one page! For more check here.\n\nRegistering user by passing username,email,and password(obviously we hash it for security measures!)"
    }
]