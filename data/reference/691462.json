[
    {
        "link": "https://thepythoncodingbook.com/2023/01/18/best-practices-in-python-functions",
        "document": "You’ve covered a lot of material in this Intermediate Python Functions Series. In this final article, you’ll read about some best practices in Python functions.\n\nThis topic is different from the previous ones discussed in this series. You won’t get a , or any other error if you don’t follow best practices. Your code may still work exactly the same if you use best practices or if you don’t, although bugs are more likely to creep into your code if you don’t.\n\nLet’s see why it still matters to know and use best practices. There were two options when writing this article: either write a very long article covering every possible best practice or write a much more concise article highlighting two key best practices. I’ve chosen to go down the route of writing a short article and focus on the two I think are most relevant.\n\nHere’s an overview of the seven articles in this series:\n• Introduction to the series: Do you know all your functions terminology well?\n• Choosing whether to use positional or keyword arguments when calling a function\n• Using optional arguments by including default values when defining a function\n• Using any number of optional positional and keyword arguments: and\n• Using positional-only arguments and keyword-only arguments: the “rogue” forward slash / or asterisk * in function signatures\n• [This article] Best practices when defining and using functions\n\nStart The Function Name With A Verb\n\nLet’s start with a function you’ve seen often in this series of articles:\n\nIt is clear from the name of the function what the function does. It greets a person! If you choose to call the function , it will be unclear what the function is doing with that greeting.\n\nAnd you should always avoid calling a function or or other names with no descriptive value.\n\nLet’s look at another example. Let’s assume you’re reading code that displays shapes and patterns. You see a function called . Is this function drawing a square or working out the square of a number to use in some calculation? You may be able to figure this out quickly by reading further or running the code. However, if the function name were , you wouldn’t even need to ask yourself the question about the function’s purpose.\n\nDid you notice what’s common in the two best practice examples you read about above? Here are a few more examples of best practice in Python function names compared to versions that you should avoid:\n\nA function performs an action. In the languages we use for human communication, such as English, verbs perform a similar role of denoting an action. Therefore, the best practice in Python functions is to use a verb as the first word in a function name to describe what the function does.\n\nIn the examples you read in the table above, the parameter name is also different in some cases. This series is about functions, so I’ll focus on function names. But when choosing variable names, including parameter names, you often want to use a noun which tells you what the value stored in the variable represents.\n\nWrite A Function That Only Does One Thing\n\nLet’s assume you’re writing a program that deals with historical temperatures which you want to analyse. The data is in Fahrenheit, but you need to work in Celsius and then find the range of temperature in a subset of the data by subtracting the minimum value from the maximum value.\n\nYou decide to write the function . You’ve followed the ‘start with a verb’ best practice and feel you’ve written a descriptive name. All good, then, right?\n\nThere’s a word in your function that’s a giveaway for the next best practice I’ll write about. This is the word “and” in the function name. If you feel the need to add an “and” in your function name, you probably want to write two functions instead.\n\nA function should only perform one action. In this example, you can write a function and another function called .\n\nThis rule sounds simple enough initially. However, some nuance is involved in defining a “single action”.\n\nFor example, consider the function , which takes a string with a person’s full name and returns a string with the initials. This function may need to split the string to separate the components in the full name, such as first name, last name, and perhaps middle names. Then, it will need to extract the first letter from each subcomponent and concatenate them with periods after each letter.\n\nThese are several actions. Does this mean this function goes against the “perform one action” best practice? Every programmer will need to make these decisions in the context of the program and application they’re writing. In this example, it’s likely that grouping the steps listed above into a single function is fine. The single action you want to perform is to get the initials from a name.\n\nAs a rule, if the steps you want to include in a function will always be performed together, then you probably want them in the same function. You’ll get better at making these decisions.\n\nBest practices in Python functions matter. They often make sure code is more readable for others and your future self. They also make bugs less likely and the code more maintainable.\n\nProgrammers will have different views on what constitutes a best practice. You’ll have to make up your mind on which ones to follow. And you may find that as you progress through your Python learning journey, you’ll also change your views on which best practices to adopt!\n\nThis is the final article in the Intermediate Python Functions Series\n• Chapter 3: Power-up Your Coding: Create Your Own Functions for an in-depth introduction to Python functions\n• Chapter 6: Functions Revisited. This chapter covers topics that will be dealt with later on in the series\n• The White Room: Understanding Programming. In this article, I briefly referred to parameters as boxes which store data. This is part of a broader analogy I like to use. You can read more in this chapter\n• Using Python Optional Arguments When Defining Functions is an article I wrote for Real Python if you want to read ahead."
    },
    {
        "link": "https://geeksforgeeks.org/python-functions",
        "document": "Python Functions is a block of statements that return the specific task. The idea is to put some commonly or repeatedly done tasks together and make a function so that instead of writing the same code again and again for different inputs, we can do the function calls to reuse code contained in it over and over again.\n\nSome Benefits of Using Functions\n\nThe syntax to declare a function is:\n\nBelow are the different types of functions in Python:\n• Built-in library function: in Python that are available to use.\n• User-defined function: We can create our own functions based on our requirements.\n\nWe can define a function in Python, using the def keyword. We can add any type of functionalities and properties to it as we require. By the following example, we can understand how to write a function in Python. In this way we can create Python function definition by using def keyword.\n\nAfter creating a function in Python we can call it by using the name of the functions Python followed by parenthesis containing parameters of that particular function. Below is the example for calling def function Python.\n\nIf you have experience in C/C++ or Java then you must be thinking about the return type of the function and data type of arguments. That is possible in Python as well (specifically for Python 3.5 and above).\n\nThe following example uses arguments and parameters that you will learn later in this article so you can come back to it again if not understood.\n\nArguments are the values passed inside the parenthesis of the function. A function can have any number of arguments separated by a comma.\n\nIn this example, we will create a simple function in Python to check whether the number passed as an argument to the function is even or odd.\n\nPython supports various types of arguments that can be passed at the time of the function call. In Python, we have the following function argument types in Python:\n\nA default argument is a parameter that assumes a default value if a value is not provided in the function call for that argument. The following example illustrates Default arguments to write functions in Python.\n\nLike C++ default arguments, any number of arguments in a function can have a default value. But once we have a default argument, all the arguments to its right must also have default values.\n\nThe idea is to allow the caller to specify the argument name with values so that the caller does not need to remember the order of parameters.\n\nWe used the Position argument during the function call so that the first argument (or value) is assigned to name and the second argument (or value) is assigned to age. By changing the position, or if you forget the order of the positions, the values can be used in the wrong places, as shown in the Case-2 example below, where 27 is assigned to the name and Suraj is assigned to the age.\n\nIn Python Arbitrary Keyword Arguments, *args, and **kwargs can pass a variable number of arguments to a function using special symbols. There are two special symbols:\n\nThe first string after the function is called the Document string or Docstring in short. This is used to describe the functionality of the function. The use of docstring in functions is optional but it is considered a good practice.\n\nThe below syntax can be used to print out the docstring of a function.\n\nExample: Adding Docstring to the function\n\nA function that is defined inside another function is known as the inner function or nested function. Nested functions can access variables of the enclosing scope. Inner functions are used so that they can be protected from everything happening outside the function.\n\nIn Python, an anonymous function means that a function is without a name. As we already know the def keyword is used to define the normal functions and the lambda keyword is used to create anonymous functions.\n\nRecursion in Python refers to when a function calls itself. There are many instances when you have to build a recursive function to solve Mathematical and Recursive Problems.\n\nUsing a recursive function should be done with caution, as a recursive function can become like a non-terminating loop. It is better to check your exit statement while creating a recursive function.\n\nHere we have created a recursive function to calculate the factorial of the number. You can see the end statement for this function is when n is equal to 0.\n\nThe function return statement is used to exit from a function and go back to the function caller and return the specified value or data item to the caller. The syntax for the return statement is:\n\nThe return statement can consist of a variable, an expression, or a constant which is returned at the end of the function execution. If none of the above is present with the return statement a None object is returned.\n\nPass by Reference and Pass by Value\n\nOne important thing to note is, in Python every variable name is a reference. When we pass a variable to a function Python, a new reference to the object is created. Parameter passing in Python is the same as reference passing in Java.\n\nWhen we pass a reference and change the received reference to something else, the connection between the passed and received parameters is broken. For example, consider the below program as follows:\n\nAnother example demonstrates that the reference link is broken if we assign a new value (inside the function).\n\nExercise: Try to guess the output of the following code.\n• None Pass by reference vs value in Python\n• None Difference between Method and Function in Python\n\nWhat is function in Python?\n\nWhat are the 4 types of Functions in Python?\n\nWhat are the parameters of a function in Python?"
    },
    {
        "link": "https://jessica-miles.medium.com/writing-functions-in-python-a-beginners-guide-ed9182db959b",
        "document": "It’s worth briefly returning to the concept I mentioned above: you can ask your function to make decisions about certain things so you don’t have to do it manually. The normality test code segment is a very simple example of coding a decision that I would otherwise have to make manually: in addition to printing the result of the test, I’m also having the code determine if the p-value is significant at an alpha level of 0.05, and telling me the result of that decision. Although I could actually make this decision quite easily myself by looking at the value, much more complex logic could be written for more nuanced decisions.\n\nNow that I’ve got working code for each of the exploratory steps that I want to perform, I can combine them into a function.\n• Write the function definition using the format with empty parentheses (no parameters) to start with. Make sure to put a colon at the end.\n• Add an empty multiline string using a set of triple quotes ( ), as a placeholder for your docstring. We’ll come back to this later.\n• Add to the end of your function body as a placeholder for the eventual stopping point. The keyword is how we indicate the point at which the function will terminate and code execution will continue at the point where the function was originally called. Optionally, the function can pass a return variable or value back to the calling code, usually representing the fruits of its labor. We’re setting the output equal to for now, and you can come back and update it later.\n\nIt’s not mandatory for functions to explicitly return a value. In this example, we could easily just print all the visualizations and statistics so we can read through them, and may not be interested in having our function actually return anything else. If you don’t include a statement at all, will be implicit. I recommend including as a placeholder to remind you to think carefully whether there is something you might want to return. If not, you can just leave as-is or remove it with no change in functionality. Also, keep in mind that you can have multiple statements if your function returns different values, or terminates from different branches of the logic tree depending the circumstances.\n\n3. Copy your code into the function body\n• Starting now, and continuing as you modify the function, be sure to add descriptive comments so you can easily skim through and find which tasks each section of code performs. You’ll be glad you did when you return to a function you wrote weeks or months ago and need to remember how it works to make an update! Just put a at the beginning of each comment line.\n• Remember that in Python, groups of statements like loops and functions need to be indented, and the indentation in the statements you coded separately may need to be adjusted.\n\nIt’s generally recommended to use a consistent number of spaces (2 or 4 spaces are common) instead of tab characters to indent code blocks. Tab characters may be interpreted in different ways, and mixing them with spaces for indentation will cause issues with code execution. If you’re working in a Jupyter Notebook, you can use for indentation and by default it will automatically be converted to 4 spaces (you can also customize this setting). Jupyter Notebook will also maintain the appropriate level of indentation when you hit enter when writing within a block of code. This is great, since it keeps your code consistent and runnable outside Jupyter Notebooks, but still allows you to use shortcuts to save time. You can select multiple lines of code and and use to indent the whole group one level, or to de-indent the whole group by one level. The ability to use these shortcuts to indent or un-indent multiple lines of code at once is very useful when assembling code you wrote outside a function, and adding loops as your function becomes more complex.\n\nParameters are the values a function expects as inputs. They may represent variables to be updated or transformed, values to be used in calculations, or options indicating which tasks the function should or shouldn’t perform. Selecting which variables in the body of the function should be parameterized is key to having a flexible function that can be easily reused with varying inputs.\n\nWhen considering which variables should be parameterized in your first draft, ask yourself:\n• What will definitely change each time I run this? These should definitely become parameters.\n• Is there anything I’ve hard-coded in my first draft that I might want to adjust in the future? These could become parameters up front, or you could also just assign values to variables at the top of the function, so you can easily assign them from parameters later.\n\nIn our example, I’m using predictor and target columns stored in a Pandas dataframe, and if I want to use this function on a different dataframe then I’ll definitely want that to be passed in. I also want to be able to explore a custom subset of predictor columns that will change each time I run the function, so I’ll create a parameter for the list of predictor column names. And finally, although for this project my target will always be , I want to use the function for future projects where the target will be named something else, so I should have a parameter for that too.\n• Add each parameter to the function definition, inside the parentheses. The names will be used not only to refer to that variable in the body of the function, but also as the keyword argument names when the function is called.\n• Choose parameter names that aren’t too long, and will naturally bring to mind what they stand for. Shorter names will be easy to refer to throughout the function body and easier to refer to when calling the function.\n• Use the same rules for naming parameters as for naming functions (all lower-case, with underscores to separate words).\n• If there is a variable or value you’re using like a constant for now but think you might want to adjust later, add it as default parameter so you don’t have to specify it as an argument every time you call the function. To make a default parameter, assign a value to it in the function definition using the equals sign.\n\nAny parameter not assigned a value in the definition (non-default) will be considered required. In , and are both required because we haven’t assigned any values to them. If we tried to call this function with only one argument (such as ), we would get an error. If you assign default values to parameters, they will be optional to include as arguments when the function is called. Default parameters that are assigned values are usually placed at the end of the parameter list. If we had the function , would be optional when the function is called because it has been assigned the default value of . We would only need to provide an argument for so calling this like will work fine assuming we’re OK with having the default value of . However, we do still have the option to specify a value other than the default for if we want to, such as ( ). Using default parameters helps simplify calling a function, since fewer arguments need to be passed and someone calling the function doesn’t need to understand every single argument in order to get started. But for less common or more advanced functionality, the optional argument values still can be easily customized.\n• Remember to keep things simple to start with and add more complexity and flexibility as needed. Start with just parameterizing what is obvious and necessary and don’t “boil the ocean” trying to think of every option you might ever want to specify.\n\nOnce you’ve decided which variables should be parameterized and chosen names for them, go through the function body be sure to replace the hard-coded values or previous variable names with the new parameters.\n\n5. Code your return value (or not)\n\nIf your function was naturally designed to output a calculated value or object, just use this step to make sure you’re returning whatever that is at the end of the function. Replace the initial placeholder with your final variable or expression.\n\nIf you’re building a function to print graphs or a report like in our example, consider whether returning a dictionary or dataframe of some of the information might also be helpful. In our example, the primary goal is to print visualizations and descriptive statistics of different predictors, but we’re also performing a normality test and calculating the Pearson correlation coefficient. Right now, we’re printing that information along with the graphs, but if I had a large number of columns I might want to compile the results in one place so I could filter or sort it instead of reading back through a bunch of printed statements.\n\nFor this example, I decided to add a few lines of code to compile some of the statistics and test result in a list of lists, and then convert that list to a dataframe that will be returned.\n\nNow that we have the basics of our function coded, it’s time to test out the function and make sure it’s working as expected.\n\nIt’s easier to to troubleshoot problems if you have a shorter list of things you’ve changed since it last worked.\n• If you’re working in a Jupyter Notebook, make sure to execute the cell containing the function to load up its most recent version.\n• If your function returns a value, don’t forget to set a variable equal to the output of the function when you call it, so you can capture the output.\n\nSuccess! In addition to the graphs and printouts that I had coded earlier, now I also get a dataframe with a bunch of the statistics I calculated for each column, so I can easily review them without scrolling back through the graphs.\n\nA note about the different ways you can pass arguments when calling a function:\n\nWhen you pass arguments to a function, you can do so by keywords, or by position. Passing arguments using keywords means that you include the parameter name as well as the value or variable, using an equals sign to connect the argument value with the proper function parameter. Here’s an example of passing arguments by keywords: The benefit of using keywords include: - It’s easy to tell which value each argument is being passed to - The keyword arguments can be in any order, since the argument names are specified If you pass arguments positionally, you don’t include the names, but you must pass them in the order in which they occurred in the function definition. Without the keywords, the compiler relies on the order to match up the argument values with the function parameters. I generally recommend passing arguments using keywords because I think it makes code more readable and I like the flexibility of being able to pass them in any order (makes it easier to add another argument to the end of the list, if needed). But ultimately it’s up to you!\n\n7. Add a docstring (even just a basic one)\n\nA docstring is a block of text that you add as the very first thing after the function definition. Docstrings explains what the function does, what arguments it takes, and what it outputs, and can also include other helpful info such as code examples. They’re an easy way for the author of the function, who is the expert on what it does and how it works, to provide built-in instructions to anyone who might want to use it.\n\nIn a Jupyter Notebook, you can show the docstring for a built-in Python function by typing the name of the function, then the opening parentheses, then on your keyboard. This initially shows the beginning of the docstring, but you can click the button to show a deeper pop-up, or the button to open a separate container on the bottom of the notebook that is easier to scroll through.\n\nThe function signature (the names of the arguments and the order in which they occur) is automatically pulled up when you summon the docstring even if you haven’t added anything manually, but without any further explanation it would be difficult for anyone else to know what the function does. Even future-you who may want to use this function a few months from now will appreciate a reminder on what it does and what to pass as each argument!\n\nYou don’t have to write a novel, but I highly recommend creating a docstring in your first draft that includes at least these basics:\n• A brief summary of what the function does\n• A list of the parameters/arguments including name, data type(s) accepted, whether it’s optional or required, and brief description of what the value or object should represent\n• A description of what the function returns, if anything\n• If there is anything you specifically know your function does NOT support yet, include that information as well\n\nSee the PEP docstring conventions here for more best practices.\n\nAt this point we’ve made a basic function for exploring data by showing visualizations and statistics and running a normality test. I’ve tested it on a few of my predictor columns, and confirmed it works.\n\nI initially developed this example function using just two predictor columns, both of which were continuous numeric variables. The method proved useful, and I gained valuable insight into these types of variables by plotting a histogram, boxplot, and scatterplot against the target. But if I also have categorical variables or binary variables, I probably need to use other methods to understand the distribution of the values and how they relate to the target.\n\nBy keeping my first draft simple I was able to get a working and useful function up and running fairly quickly, but at the cost of having a fairly narrow scope that may not work on future data sets.\n\nIn real life, I went back and updated the initial function a whole bunch of times to incorporate support for different types of data I encountered, and make the output more flexible. Here’s a list of some of the things I eventually updated, so you can get a sense for just how much more I added after the first draft:\n• Added logic to evaluate what type of data was in each column (continuous or categorical) based partly on column type in the dataframe but also on the number of unique values\n• Depending on data type, generated different types of graphs and statistics ( instead of ) for what the function judged were categorical.\n• Added parameters for each type of chart to allow them to be turned off, which involved having to make the number of axes in the figure be calculated dynamically\n• Added dynamic sizing for the matplotlib figure to allow the barplot for categorical variables to show all values even if they had high cardinality\n\nIt did take some work, but I ended up with a robust function that can handle lots of different types of data, and that I can easily reuse in many data science projects to come!\n\nThe approach of starting simple and building iteratively means you don’t have to get overwhelmed trying to think of every exception or scenario in the beginning: start with the basics and let your own usage of the first draft guide what you add in the second draft and beyond."
    },
    {
        "link": "https://stackoverflow.com/questions/30531204/python-best-practices-for-functions",
        "document": "The method often depends a little on the situation.\n\nYou seem to need unique ids, why not use a generator:\n\nUsed with the function:\n\nIf you want the ids to be multiples of , you can pass the constant to the generator via parameters:\n\nYou can even add a starting value if you don't want to start from index 0:"
    },
    {
        "link": "https://reddit.com/r/Python/comments/a7wzza/functions_and_methods_best_practices",
        "document": "I'm building a script that fetches bunch of data and computes stuff out of it. I'm trying to keep my functions easy-to-read and simple, and therefore avoid long functions. Currently I've a function that computes single element and then have another function that performs the computation for every element. For an example:\n\nThis works perfectly well, but I realized that very seldom I stumble into code like this when reading more experienced programmers' code. What's the most convenient / pythonic way to structure my functions?"
    },
    {
        "link": "https://geeksforgeeks.org/implementation-of-dynamic-array-in-python",
        "document": "A dynamic array is similar to an array, but with the difference that its size can be dynamically modified at runtime. Don’t need to specify how much large an array beforehand. The elements of an array occupy a contiguous block of memory, and once created, its size cannot be changed. A dynamic array can, once the array is filled, allocate a bigger chunk of memory, copy the contents from the original array to this new space, and continue to fill the available slots.\n\nWe’ll be using a built in library called ctypes of python . Check out the documentation for more info, but its basically going to be used here as a raw array from the ctypes module.\n\nA quick note on public vs private methods, we can use an underscore _ before the method name to keep it non-public.\n\nThe key is to provide means to grows an array A that stores the elements of a list. We can’t actually grow the array, its capacity is fixed. If an element is appended to a list at a time, when the underlying array is full, we need to perform following steps.\n• Allocate a new array B with larger capacity (A commonly used rule for the new array is to have twice the capacity of the existing array )\n• Set B[i]=A[i], for i=0 to n-1 where n denotes the current no of items.\n• Set A=B that is, we hence forth use B as the array of supporting list.\n• Insert new element in the new array."
    },
    {
        "link": "https://stackoverflow.com/questions/2910864/in-python-how-can-i-declare-a-dynamic-array",
        "document": "In Python, a is a dynamic array. You can create one like this:\n\nOr you can fill it with items:\n\nYou can add items using \"append\":\n\nYou can iterate over elements of the list using the loop:\n\nOr, if you'd like to keep track of the current index:\n\nTo remove elements, you can use the del command or the remove function as in:\n\nNote, though, that one cannot iterate over the list and modify it at the same time; to do that, you should instead iterate over a slice of the list (which is basically a copy of the list). As in:"
    },
    {
        "link": "https://medium.com/@kelispatel5/dynamic-arrays-in-python-implementing-a-custom-dynamic-array-class-with-example-150589c2b821",
        "document": "In the realm of (DSA), dynamic arrays are a fundamental concept. Unlike static arrays that have a fixed size, dynamic arrays can grow and shrink as needed. In Python, lists are dynamic by nature, but understanding how to implement a dynamic array from scratch can deepen your understanding of how these structures work under the hood. This article will walk you through creating a custom dynamic array class called in Python.\n\nIn the realm of (DSA), dynamic arrays are a fundamental concept. Unlike static arrays that have a fixed size, dynamic arrays can grow and shrink as needed. In Python, lists are dynamic by nature, but understanding how to implement a dynamic array from scratch can deepen your understanding of how these structures work under the hood. This article will walk you through creating a custom dynamic array class called in Python.\n\nHere’s a custom implementation of a dynamic array in Python using the class:\n• Initializes the array with a capacity of 1.\n• Checks if the array is full.\n• If full, resizes the array to double its current capacity.\n• Adds the new item at the end of the array.\n• Removes the last element from the array.\n• Returns an error message if the array is empty.\n• Resets the array to its initial state.\n• Searches for an item in the array and returns its index.\n• Returns an error message if the item is not found.\n• Inserts an item at a specified position.\n• Resizes the array if it is full.\n• Removes the first occurrence of an item from the array.\n• Copies the elements from the old array to the new array.\n• Allows indexing to access elements of the array.\n• Removes an item at a specified position by shifting elements.\n• Creates a array with the given capacity.\n\nImplementing a dynamic array from scratch in Python helps you understand the underlying mechanics of dynamic data structures. The class provides a comprehensive example of how to manage dynamic arrays, handle resizing, and perform basic operations like append, insert, remove, and find."
    },
    {
        "link": "https://stackoverflow.com/questions/521674/initializing-a-list-to-a-known-number-of-elements-in-python",
        "document": "@Steve already gave a good answer to your question:\n\nWarning: As @Joachim Wuttke pointed out, the list must be initialized with an immutable element. does not work as expected because you will get a list of 1000 identical lists (similar to a list of 1000 points to the same list in C). Immutable objects like int, str or tuple will do fine.\n\nResizing lists is slow. The following results are not very surprising:\n\nBut resizing is not very slow if you don't have very large lists. Instead of initializing the list with a single element (e.g. ) and a fixed length to avoid list resizing, you should consider using list comprehensions and directly fill the list with correct values. For example:\n\nFor huge data set numpy or other optimized libraries are much faster:"
    },
    {
        "link": "https://reddit.com/r/ProgrammerHumor/comments/pa8zou/python_lists_are_dynamic_arrays",
        "document": "Archived post. New comments cannot be posted and votes cannot be cast."
    }
]