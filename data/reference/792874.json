[
    {
        "link": "https://geeksforgeeks.org/encapsulation-in-python",
        "document": "In Python, encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. It also restricts direct access to some components, which helps protect the integrity of the data and ensures proper usage.\n\nEncapsulation is the process of hiding the internal state of an object and requiring all interactions to be performed through an object’s methods. This approach:\n• None Provides better control over data.\n• Data Hiding : The variables (attributes) are kept private or protected, meaning they are not accessible directly from outside the class. Instead, they can only be accessed or modified through the methods.\n• Access through Methods : Methods act as the interface through which external code interacts with the data stored in the variables. For instance, getters and setters are common methods used to retrieve and update the value of a private variable.\n• Control and Security : By encapsulating the variables and only allowing their manipulation via methods, the class can enforce rules on how the variables are accessed or modified, thus maintaining control and security over the data.\n\nEncapsulation in Python is like having a bank account system where your account balance (data) is kept private. You can’t directly change your balance by accessing the account database. Instead, the bank provides you with methods (functions) like deposit and withdraw to modify your balance safely.\n• Private Data (Balance) : Your balance is stored securely. Direct access from outside is not allowed, ensuring the data is protected from unauthorized changes.\n• Public Methods (Deposit and Withdraw) : These are the only ways to modify your balance. They check if your requests (like withdrawing money) follow the rules (e.g., you have enough balance) before allowing changes.\n\nPublic members are accessible from anywhere, both inside and outside the class. These are the default members in Python.\n• Public Attribute (name): This attribute is declared without any underscore prefixes. It is accessible from anywhere, both inside and outside of the class.\n• Public Method (display_name): This method is also accessible from any part of the code. It directly accesses the public attribute and prints its value.\n• Object (obj): An instance of Public is created, and the display_name method is called, demonstrating how public attributes and methods can be accessed directly.\n\nNote: The __init__ method is a constructor and runs as soon as an object of a class is instantiated.\n\nProtected members are identified with a single underscore (_). They are meant to be accessed only within the class or its subclasses.\n• Protected Attribute (_age): This attribute is prefixed with a single underscore, which by convention, suggests that it should be treated as a protected member. It’s not enforced by Python but indicates that it should not be accessed outside of this class and its subclasses.\n• Subclass: Here, a subclass inherits from Protected. Within this subclass, we can still access the protected attribute _age\n• Method (display_age): This method within the subclass accesses the protected attribute and prints its value. This shows that protected members can be accessed within the class and its subclasses.\n\nPrivate members are identified with a double underscore (__) and cannot be accessed directly from outside the class. Python uses name mangling to make private members inaccessible by renaming them internally.\n\nNote: Python’s private and protected members can be accessed outside the class through python name mangling.\n• Private Attribute (__salary): This attribute is prefixed with two underscores, which makes it a private member. Python enforces privacy by name mangling, which means it renames the attribute in a way that makes it hard to access from outside the class.\n• Method (salary): This public method provides the only way to access the private attribute from outside the class. It safely returns the value of __salary.\n• Direct Access Attempt: Trying to access the private attribute directly (obj.__salary) will result in an AttributeError, showing that direct access is blocked. This is Python’s way of enforcing encapsulation at a language level.\n\nWhat is Encapsulation in Python Programming?\n\nHow to Implement Encapsulation in Python Classes?\n\nWhat are Private and Protected Members in Python Classes?\n\nWhat are Key Differences Between Encapsulation and Abstraction?"
    },
    {
        "link": "https://realpython.com/python-classes",
        "document": "Python classes form the backbone of object-oriented programming, enabling you to encapsulate data and behavior into a single entity. When you work with a Python class, you define attributes to store data and methods to perform actions. This structure allows you to model real-world objects and create organized, reusable code.\n\nA class in Python serves as a blueprint for creating objects, which are instances of the class. You use classes when you need to encapsulate related data and functions, making your code modular and easier to manage. By defining classes, you can create multiple objects that share the same attributes and methods, while maintaining their own unique state.\n\nIn this tutorial, you’ll learn how to define and use Python classes, understand the distinction between classes and objects, and explore methods and attributes. You’ll also learn about instance and class attributes, methods, inheritance, and common pitfalls to avoid when working with classes.\n\nBy the end of this tutorial, you’ll understand that:\n• A class in Python is like a recipe for creating objects that encapsulate both data and behavior.\n• You use classes to model complex data structures and behaviors in a modular way.\n• You define classes in Python using the keyword, and instantiate them to create objects.\n• A class is a blueprint, while an object is an instance of a class.\n• Instance attributes are unique to each object, while class attributes are shared across all instances of the class.\n\nTo get the most out of this tutorial, you should know about Python variables, data types, and functions. Some experience with object-oriented programming (OOP) is also a plus. Don’t worry if you’re not an OOP expert yet. In this tutorial, you’ll learn the key concepts that you need to get started and more. You’ll also write several practical examples to help reinforce your knowledge of Python classes.\n\nPython is a multiparadigm programming language that supports object-oriented programming (OOP) through classes that you can define with the keyword. You can think of a class as a piece of code that specifies the data and behavior that represent and model a particular type of object. What is a class in Python? A common analogy is that a class is like the blueprint for a house. You can use the blueprint to create several houses and even a complete neighborhood. Each concrete house is an object or instance that’s derived from the blueprint. Each instance can have its own properties, such as color, owner, and interior design. These properties carry what’s commonly known as the object’s state. Instances can also have different behaviors, such as locking the doors and windows, opening the garage door, turning the lights on and off, watering the garden, and more. In OOP, you commonly use the term attributes to refer to the properties or data associated with a specific object of a given class. In Python, attributes are variables defined inside a class with the purpose of storing all the required data for the class to work. Similarly, you’ll use the term methods to refer to the different behaviors that objects will show. Methods are functions that you define within a class. These functions typically operate on or with the attributes of the underlying instance or class. Attributes and methods are collectively referred to as members of a class or object. You can write classes to model the real world. These classes will help you better organize your code and solve complex programming problems. For example, you can use classes to create objects that emulate people, animals, vehicles, books, buildings, cars, or other objects. You can also model virtual objects, such as a web server, directory tree, chatbot, file manager, and more. Finally, you can use classes to build class hierarchies. This way, you’ll promote code reuse and remove repetition throughout your codebase. In this tutorial, you’ll learn a lot about classes and all the cool things that you can do with them. To kick things off, you’ll start by defining your first class in Python. Then you’ll dive into other topics related to instances, attributes, and methods. To define a class, you need to use the keyword followed by the class name and a colon, just like you’d do for other compound statements in Python. Then you must define the class body, which will start at the next indentation level: In a class’s body, you can define attributes and methods as needed. As you already learned, attributes are variables that hold the class data, while methods are functions that provide behavior and typically act on the class data. Note: In Python, the body of a given class works as a namespace where attributes and methods live. You can only access those attributes and methods through the class or its objects. As an example of how to define attributes and methods, say that you need a class to model different circles in a drawing application. Initially, your class will have a single attribute to hold the radius. It’ll also have a method to calculate the circle’s area: In this code snippet, you define using the keyword. Inside the class, you write two methods. The method has a special meaning in Python classes. This method is known as the object initializer because it defines and sets the initial values for the object’s attributes. You’ll learn more about this method in the Instance Attributes section. The second method of is conveniently named and will compute the area of a specific circle by using its radius. In this example, you’ve used the module to access the constant as it’s defined in that module. It’s common for method names to contain a verb, such as calculate, to describe an action the method performs. To learn more about naming functions and methods in Python, check out the How Do You Choose Python Function Names? tutorial. Note: In Python, the first argument of most methods is . This argument holds a reference to the current object so that you can use it inside the class. You’ll learn more about this argument in the section on instance methods with . Cool! You’ve written your first class. Now, how can you use this class in your code to represent several concrete circles? Well, you need to instantiate your class to create specific circle objects from it. The action of creating concrete objects from an existing class is known as instantiation. With every instantiation, you create a new object of the target class. To get your hands dirty, go ahead and make a couple of instances of by running the following code in a Python REPL session: To create an object of a Python class like , you must call the class constructor with a pair of parentheses and a set of appropriate arguments. What arguments? In Python, the class constructor accepts the same arguments as the method. In this example, the class expects the argument. Calling the class constructor with different argument values will allow you to create different objects or instances of the target class. In the above example, and are separate instances of . In other words, they’re two different and concrete circles, as you can conclude from the code’s output. Great! You already know how to create objects of an existing class by calling the class constructor with the required arguments. Now, how can you access the attributes and methods of a given class? That’s what you’ll learn in the next section. In Python, you can access the attributes and methods of an object by using dot notation with the dot operator. The following snippet of code shows the required syntax: Note that the dot ( ) in this syntax basically means give me the following attribute or method from this object. The first line returns the value stored in the target attribute, while the second line accesses the target method and calls it. Note: Remember that to call a function or method, you need to use a pair of parentheses and a series of arguments, if applicable. Now get back to your circle objects and run the following code: In the first couple of lines after the instantiation, you access the attribute on your object. Then you call the method to calculate the circle’s area. In the second pair of statements, you do the same but on the object. You can also use dot notation and the assignment operator to change the current value of an attribute: Now the radius of is entirely different. When you call , the result immediately reflects this change. You’ve changed the object’s internal state or data, which typically impacts its behaviors or methods.\n\nAs you’ve learned, classes are great when you must bundle data and behavior together in a single entity. The data will come in the form of attributes, while the behavior will come as methods. You already have an idea of what an attribute is. Now it’s time to dive deeper into how you can add, access, and modify attributes in your custom classes. First, you need to know that your classes can have two types of attributes in Python:\n• Class attributes: A variable that you define in the class body directly. Class attributes belong to their containing class. Their data is common to the class and all its instances.\n• Instance attributes: A variable that you define inside an instance method using the argument and dot notation, like in . Instance attributes belong to a concrete instance of a given class. Their data is only available to that instance and defines its state. Both types of attributes have their specific use cases. Instance attributes are, by far, the most common type of attribute that you’ll use in your day-to-day coding, but class attributes also come in handy. Class attributes are variables that you define directly in the class body but outside of any method. These attributes are tied to the class itself rather than to particular objects of that class. All the objects that you create from a particular class share the same class attributes with the same original values. Because of this, if you change a class attribute, then that change affects all the derived objects. As an example, say that you want to create a class that keeps an internal count of the instances you’ve created. In that case, you can use a class attribute: keeps a class attribute that works as a counter of instances. When Python parses this class, it initializes the counter to zero and leaves it alone. Creating instances of this class means automatically calling the method and incremementing by one. Note: In the above example, you’ve used the class name to access inside . However, using the built-in function is best because it’ll make your class more flexible: The built-in function returns the class or type of , which is in this example. This subtle change makes your class more robust and reliable by avoiding hard-coding the name of the class that provides the attribute. It’s important to note that you can access class attributes using either the class or one of its instances. That’s why you can use the object to retrieve the value of . However, if you need to modify a class attribute, then you must use the class itself rather than one of its instances. For example, if you use to modify , then you’ll be overriding the original class attribute by creating a new instance attribute: You can’t modify class attributes through instances of the containing class. Doing that will create new instance attributes with the same name as the original class attributes. That’s why returns in this example. You’ve overridden the class attribute in the highlighted line. Note: It’s curious what Python does in the example above. It uses the initial value of as a class attribute to create a new instance attribute with the same name and increments it by one. How come? Well, the line is equivalent to the following assignment: In this statement, the attribute on the left of the equal sign is an instance attribute, while the attribute on the right side of the sign is a class attribute. Otherwise, the operator would’ve raised a . In general, you should use class attributes for sharing data between instances of a class. Any changes on a class attribute will be visible to all the instances of that class. Instance attributes are variables tied to a particular object of a given class. The value of an instance attribute is attached to the object itself. So, the attribute’s value is specific to its containing instance. Python lets you dynamically attach attributes to existing objects that you’ve already created. However, you most often define instance attributes inside instance methods, which are those methods that receive as their first argument. Note: Even though you can define instance attributes inside any instance method, it’s best to define all of them in the method, which is the instance initializer. This ensures that all of the attributes have consistent values when you create a new instance. Additionally, it makes the code more organized and easier to debug. Consider the following class, which defines a bunch of instance attributes: In this class, you define a total of seven instance attributes inside . The attributes , , , and take values from the arguments to , which are the arguments that you must pass to the class constructor, , to create concrete objects. Then, you explicitly initialize the attributes , , and with sensible values that don’t come from the user. Note: Inside a class, you must access all instance attributes through the argument. This argument holds a reference to the current instance, which is where the attributes belong and live. The argument plays a fundamental role in Python classes. You’ll learn more about in the section Instance Methods With . Here’s how your class works in practice: In these examples, you create two different instances of . Each instance takes specific input arguments at instantiation time to initialize part of its attributes. Note how the values of the associated attributes are different and specific to the concrete instance. Unlike class attributes, you can’t access instance attributes through the class. You need to access them through their containing instance: Instance attributes are specific to a concrete instance of a given class. So, you can’t access them through the class object. If you try to do that, then you get an exception. In Python, both classes and instances have a special attribute called . This attribute holds a dictionary containing the writable members of the underlying class or instance. Remember, these members can be attributes or methods. Each key in represents an attribute name. The value associated with a given key represents the value of the corresponding attribute. In a class, will contain class attributes and methods. In an instance, will hold instance attributes. When you access a class member through the class object, Python automatically searches for the member’s name in the class . If the name isn’t there, then you get an . Similarly, when you access an instance member through a concrete instance of a class, Python looks for the member’s name in the instance . If the name doesn’t appear there, then Python looks in the class . If the name isn’t found, then you get a . Here’s a toy class that illustrates how this mechanism works: In this class, you define a class attribute with a value of . In the method, you define an instance attribute that takes its value from the user’s input. Finally, you define a method to print both attributes. Now it’s time to check the content of in the class object. Go ahead and run the following code: The highlighted lines show that both the class attribute and the method are in the class dictionary. Note how you can use to access the value of class attributes by specifying the attribute’s name in square brackets, as you usually access keys in a dictionary. Note: You can access the same dictionary by calling the built-in function on your class or instance, as you did before. In instances, the dictionary will contain instance attributes only: The instance dictionary in this example holds and its specific value for the object at hand. Again, you can access any existing instance attribute using and the attribute name in square brackets. You can modify the instance dynamically. This means that you can change the value of existing instance attributes through , as you did in the final example above. You can even add new attributes to an instance using its dictionary. Using to change the value of instance attributes will allow you to avoid exceptions when you’re wiring descriptors in Python. You’ll learn more about descriptors in the Property and Descriptor-Based Attributes section. In Python, you can add new attributes to your classes and instances dynamically. This possibility allows you to attach new data and behavior to your classes and objects in response to changing requirements or contexts. It also allows you to adapt existing classes to specific and dynamic needs. For example, you can take advantage of this Python feature when you don’t know the required attributes of a given class at the time when you’re defining that class itself. Consider the following class, which aims to store a row of data from a database table or a CSV file: In this class, you haven’t defined any attributes or methods because you don’t know what data the class will store. Fortunately, you can add attributes and even methods to this class dynamically. For example, say that you’ve read a row of data from an file using . This class reads the data and returns it in a dictionary-like object. Now suppose that you have the following dictionary of data: Next, you want to add this data to an instance of your class, and you need to represent each data field as an instance attribute. Here’s how you can do it: In this code snippet, you first create an instance of called . Then you run a loop to iterate over the items of your dictionary of data, . Inside the loop, you use the built-in function to sequentially add each field as an attribute to your object. If you inspect , then you’ll note that it stores all the original data as attributes. You can also use dot notation and an assignment to add new attributes and methods to a class dynamically: Here, you first create a minimal class with no custom attributes or methods. To define the class’s body, you’ve just used a statement as a placeholder, which is Python’s way of doing nothing. Then you create an object called . Note how you can use dot notation and an assignment to add new attributes to the instance. In this example, you add and attributes with appropriate values. Then you provide the class with an initializer or method. In this method, you take the and arguments, which you turn into instance attributes in the method’s body. Then you add the method to dynamically. After this addition, you can create objects by passing the name and job to the class constructor. As you can conclude from the above example, you can construct an entire Python class dynamically. Even though this capability of Python may seem neat, you must use it carefully because it can make your code difficult to understand and reason about. Python allows you to add function-like behavior on top of existing instance attributes and turn them into managed attributes. This type of attribute prevents you from introducing breaking changes into your APIs. In other words, with managed attributes, you can have function-like behavior and attribute-like access at the same time. You don’t need to change your APIs by replacing attributes with method calls, which can potentially break your users’ code. To create a managed attribute with function-like behavior in Python, you can use either a property or a descriptor, depending on your specific needs. Note: To dive deeper into Python properties, check out Python’s : Add Managed Attributes to Your Classes. As an example, get back to your class and say that you need to validate the radius to ensure that it only stores positive numbers. How would you do that without changing your class interface? The quickest approach to this problem is to use a property and implement the validation logic in the setter method. Here’s what your new version of can look like: To turn an existing attribute like into a property, you typically use the decorator to write the getter method. The getter method must return the value of the attribute. In this example, the getter returns the circle’s radius, which is stored in the non-public attribute. Note: The pipe sign ( ) in the call to expresses union types. You can use this syntax in Python 3.10 or greater. If you’re using a lower version of Python, then you can use a tuple of types . To define the setter method of a property-based attribute, you need to use the decorator . In the example, you use . Then you need to define the method itself. Note that property setters need to take an argument providing the value that you want to store in the underlying attribute. Inside the setter method, you use a conditional to check whether the input value is an integer or a floating-point number. You also check if the value is less than or equal to . If either is true, then you raise a with a descriptive message about the actual issue. Finally, you assign to and that’s it. Now, is a property-based attribute. Here’s an example of this new version of in action: The first instance of in this example takes a valid value for its radius. Note how you can continue working with as a regular attribute rather than as a method. If you try to assign an invalid value to , then you get a exception. Note: Remember to reload the module if you’re working on the same REPL session as before. This recommendation will also be valid for all the examples in this tutorial where you change modules that you defined in previous examples. It’s important to note that the validation also runs at instantiation time when you call the class constructor to create new instances of . This behavior is consistent with your validation strategy. Using a descriptor to create managed attributes is another powerful way to add function-like behavior to your instance attributes without changing your APIs. Like properties, descriptors can also have getter, setter, and other types of methods. Note: To learn more about descriptors and how to use them, check out Python Descriptors: An Introduction. To explore how descriptors work, say that you’ve decided to continue creating classes for your drawing application, and now you have the following class: This class uses the same pattern as your class. Instead of using , the class takes a argument and computes the area using the appropriate expression for a square. This class is pretty similar to , and the repetition starts looking odd. Then you think of using a descriptor to abstract away the validation process. Here’s what you come up with: The first thing to notice in this example is that you moved all the classes to a file. In that file, you define a descriptor class called by implementing the and special methods, which are part of the descriptor protocol. Next, you remove the property from and the property from . In , you add a class attribute, which holds an instance of . You do something similar in , but the class attribute is appropriately named . Here are a few examples of how your classes work now: Python descriptors provide a powerful tool for adding function-like behavior on top of your instance attributes. They can help you remove repetition from your code, making it cleaner and more maintainable. They also promote code reuse. In a Python class, using the attribute can help you reduce the memory footprint of the corresponding instances. This attribute prevents the automatic creation of an instance . Using is particularly handy when you have a class with a fixed set of attributes, and you’ll use that class to create a large number of objects. In the example below, you have a class with a attribute that consists of a tuple of allowed attributes. Each attribute will represent a Cartesian coordinate: This class defines as a tuple with two items. Each item represents the name of an instance attribute. So, they must be strings holding valid Python identifiers. Note: Although can hold a object, you should use a object instead. Even if changing the list in after processing the class body had no effect, it’d be misleading to use a mutable sequence there. Instances of your class don’t have a , as the code shows. This feature makes them memory-efficient. To illustrate this efficiency, you can measure the memory consumption of an instance of . To do this, you can use the Pympler library, which you can install from PyPI using the command. Once you’ve installed Pympler with , then you can run the following code in your REPL: The function from Pympler says that the object occupies 112 bytes in your computer’s memory. Now get back to your REPL session and redefine without providing a attribute. With this update in place, go ahead and run the memory check again: The same object, , now consumes 528 bytes of memory. This number is over four times greater than what you got with the original implementation of . Imagine how much memory would save if you had to create a million points in your code. The attribute adds a second interesting behavior to your custom classes. It prevents you from adding new instance attributes dynamically: Adding a to your classes allows you to provide a series of allowed attributes. This means that you won’t be able to add new attributes to your instances dynamically. If you try to do it, then you’ll get an exception. A word of caution is in order, as many of Python’s built-in mechanisms implicitly assume that objects have the attribute. When you use , then you waive that assumption, which means that some of those mechanisms might not work as expected anymore.\n\nPython classes allow you to bundle data and behavior together in a single entity through attributes and methods, respectively. You’ll use the data to define the object’s current state and the methods to operate on that data or state. A method is just a function that you define inside a class. By defining it there, you make the relationship between the class and the method explicit and clear. Because they’re just functions, methods can take arguments and return values as functions do. However, the syntax for calling a method is a bit different from the syntax for calling a function. To call a method, you need to specify the class or instances in which that method is defined. To do this, you need to use dot notation. Remember that classes are namespaces, and their members aren’t directly accessible from the outside. In a Python class, you can define three different types of methods:\n• Instance methods, which take the current instance, , as their first argument\n• Class methods, which take the current class, , as their first argument\n• Static methods, which take neither the instance nor the class as an argument Every type of method has its own characteristics and specific use cases. Instance methods are, by far, the most common methods that you’ll use in your custom Python classes. Note: To learn more about instance, class, and static methods, check out Python’s Instance, Class, and Static Methods Demystified. In the following sections, you’ll dive into how each of these methods works and how to create them in your classes. To get started, you’ll begin with instance methods, which are the most common methods that you’ll define in your classes. In a class, an instance method is a function that takes the current instance as its first argument. In Python, this first argument is called by convention. Note: Naming the current instance is a strong convention in Python. It’s so strong that it may look like is one of the Python keywords. However, you could use any other name instead of . Even though it’s possible to use any name for the first argument of an instance method, using is definitely the right choice because it’ll make your code look like Python code in the eyes of other developers. The argument holds a reference to the current instance, allowing you to access that instance from within methods. More importantly, through , you can access and modify the instance attributes and call other methods within the class. To define an instance method, you just need to write a regular function that accepts as its first argument. Up to this point, you’ve already written some instance methods. To continue learning about them, turn back to your class. Now say that you want to add methods to start, stop, accelerate, and brake the car. To kick things off, you’ll begin by writing the and methods: The and methods are pretty straightforward. They take the current instance, , as their first argument. Inside the methods, you use to access the attribute on the current instance using dot notation. Then you change the current value of this attribute to in and to in . Both methods print informative messages to illustrate what your car is doing. Note: Instance methods should act on instance attributes by either accessing them or changing their values. If you find yourself writing an instance method that doesn’t use in its body, then that may not be an instance method. In this case, you should probably use a class method or a static method, depending on your specific needs. Now you can add the and methods, which will be a bit more complex: The method takes an argument that represents the increment of speed that occurs when you call the method. For simplicity, you haven’t set any validation for the input increment of speed, so using negative values can cause issues. Inside the method, you first check whether the car’s engine is started, returning immediately if it’s not. Then you check if the incremented speed is less than or equal to the allowed maximum speed for your car. If this condition is true, then you increment the speed. Otherwise, you set the speed to the allowed limit. The method works similarly. This time, you compare the decremented speed to because cars can’t have a negative speed. If the condition is true, then you decrement the speed according to the input argument. Otherwise, you set the speed to its lower limit, . Again, you have no validation on the input decrement of speed, so be careful with negative values. Your class now has four methods that operate on and with its attributes. It’s time for a drive: Great! Your class works nicely! You can start your car’s engine, increment the speed, brake, and stop the car’s engine. You’re also confident that no one can increment the car’s speed if the car’s engine is stopped. How does that sound for minimal modeling of a car? It’s important to note that when you call an instance method on a concrete instance like using dot notation, you don’t have to provide a value for the argument. Python takes care of that step for you. It automatically passes the target instance to . So, you only have to provide the rest of the arguments. However, you can manually provide the desired instance if you want. To do this, you need to call the method on the class: In this example, you call instance methods directly on the class. For this type of call to work, you need to explicitly provide an appropriate value to the argument. In this example, that value is the instance. Note that if you don’t provide a suitable instance, then the call fails with a . The error message is pretty clear. There’s a missing positional argument, . Python supports what it calls special methods, which are also known as dunder or magic methods. These methods are typically instance methods, and they’re a fundamental part of Python’s internal class mechanism. They have an important feature in common: Python calls them automatically in response to specific operations. Python uses these methods for many different tasks. They provide a great set of tools that will allow you to unlock the power of classes in Python. You’ll recognize special methods because their names start and end with a double underscore, which is the origin of their other name, dunder methods (double underscore). Arguably, is the most common special method in Python classes. As you already know, this method works as the instance initializer. Python automatically calls it when you call a class constructor. Note: To dive deeper into special methods, check out the Python’s Magic Methods: Leverage Their Power in Your Classes tutorial. You’ve already written a couple of methods. So, you’re ready to learn about other common and useful special methods. For example, the and methods provide string representations for your objects. Go ahead and update your class to add these two methods: The method provides what’s known as the informal string representation of an object. This method must return a string that represents the object in a user-friendly manner. You can access an object’s informal string representation using either or . The method is similar, but it must return a string that allows you to re-create the object if possible. So, this method returns what’s known as the formal string representation of an object. This string representation is mostly targeted at Python programmers, and it’s pretty useful when you’re working in an interactive REPL session. In interactive mode, Python falls back to calling when you access an object or evaluate an expression, issuing the formal string representation of the resulting object. In script mode, you can access an object’s formal string representation using the built-in function. Run the following code to give your new methods a try. Remember that you need to restart your REPL or reload : When you use an instance of as an argument to or , you get a user-friendly string representation of the car at hand. This informal representation comes in handy when you need your programs to present your users with information about specific objects. If you access an instance of directly in a REPL session, then you get a formal string representation of the object. You can copy and paste this representation to re-create the object in an appropriate environment. That’s why this string representation is intended to be useful for developers, who can take advantage of it while debugging and testing their code. Python protocols are another fundamental topic that’s closely related to special methods. Protocols consist of one or more special methods that support a given feature or functionality. Common examples of protocols include: Allows you to create iterator objects Enables an object to work on statements Of course, Python has many other protocols that support cool features of the language. You already coded an example of using the descriptor protocol in the Property and Descriptor-Based Attributes section. Here’s an example of a minimal class that implements the iterable protocol: This class takes three arguments representing the space coordinates of a given point. The method is a generator function that returns an iterator. The resulting iterator yields the coordinates of on demand. The call to iterates over the attributes , , and , returning a object. You don’t need to call directly. Python calls it automatically when you use an instance of in an iteration. You can also add class methods to your custom Python classes. A class method is a method that takes the class object as its first argument instead of taking . In this case, the argument should be called , which is also a strong convention in Python. So, you should stick to it. You can create class methods using the decorator. Providing your classes with multiple constructors is one of the most common use cases of class methods in Python. For example, say you want to add an alternative constructor to your so that you can quickly create points from tuples or lists of coordinates: In the class method, you take a sequence of coordinates as an argument, create a object from it, and return the object to the caller. To create the new object, you use the argument, which holds an implicit reference to the current class, which Python injects into your method automatically. In this example, you use the class directly to access the class method . Note that you can also access the method using a concrete instance, like in the example. In each of the calls to , you’ll get a completely new instance of . However, class methods should be accessed through the corresponding class name for better clarity and to avoid confusion. Your Python classes can also have static methods. These methods don’t take the instance or the class as an argument. So, they’re regular functions defined within a class. You could’ve also defined them outside the class as stand-alone function. You’ll typically define a static method instead of a regular function outside the class when that function is closely related to your class, and you want to bundle it together for convenience or for consistency with your code’s API. Remember that calling a function is a bit different from calling a method. To call a method, you need to specify a class or object that provides that method. If you want to write a static method in one of your custom classes, then you need to use the decorator. Check out the method below: ! This is your 3D Point!\" The static method takes a as an argument and prints a message on the screen. Note that this is only a toy example of how to write static methods in your classes. Static methods like don’t operate on the current instance, , or the current class, . They work as independent functions enclosed in a class. You’ll typically put them inside a class when they’re closely related to that class but don’t necessarily affect the class or its instances. Hey Pythonista! This is your 3D Point! Hey Python developer! This is your 3D Point! As you already know, the method takes a name as an argument and prints a message to your screen. Note that you can call the method using the class or any of its instances. As with class methods, you should generally call static methods through the corresponding class instead of one of its instances. Programming languages like Java and C++ don’t expose attributes as part of their classes’ public APIs. Instead, these programming languages make extensive use of getter and setter methods to give you access to attributes. Note: To dive deeper into the getter and setter pattern and how Python approaches it, check out Getters and Setters: Manage Attributes in Python. Using methods to access and update attributes promotes encapsulation. Encapsulation is a fundamental OOP principle that recommends protecting an object’s state or data from the outside world, preventing direct access. The object’s state should only be accessible through a public interface consisting of getter and setter methods. For example, say that you have a class with a instance attribute. You can make a non-public attribute and provide getter and setter methods to access and change that attribute: In this example, is the getter method and allows you to access the underlying attribute. Similarly, is the setter method and allows you to change the current value of . The attribute is non-public and is where the actual data is stored. Here’s how you can use your class: Here, you create an instance of using the class constructor and as the required name. That means you can use the method to access Jane’s name and the method to update it. The getter and setter pattern is common in languages like Java and C++. Besides promoting encapsulation and APIs centered on method calls, this pattern also allows you to quickly add function-like behavior to your attributes without introducing breaking changes in your APIs. However, this pattern is less popular in the Python community. In Python, it’s completely normal to expose attributes as part of an object’s public API. If you ever need to add function-like behavior on top of a public attribute, then you can turn it into a property instead of breaking the API by replacing the attribute with a method. Here’s how most Python developers would write the class: This class doesn’t have getter and setter methods for the attribute. Instead, it exposes the attribute as part of its API. So, you can use it directly: In this example, instead of using a setter method to change the value of , you use the attribute directly in an assignment statement. This is common practice in Python code. If your class evolves to a point where you need to add function-like behavior on top of , then you can turn the attribute into a property. For example, say that you need to store the attribute in uppercase letters. Then you can do something like the following: This class defines as a property with appropriate getter and setter methods. Python will automatically call these methods, respectively, when you access or update the attribute’s value. The setter method takes care of uppercasing the input value before assigning it back to : Python properties allow you to add function-like behavior to your attributes while you continue to use them as normal attributes instead of as methods. Note how you can still assign new values to using an assignment instead of a method call. Running the assignment triggers the setter method, which uppercases the input value.\n\nIn the Python standard library, you’ll find many tools that solve different problems and deal with different challenges. Among all these tools, you’ll find a few that will make you more productive when writing custom classes. For example, if you want a tool that saves you from writing a lot of class-related boilerplate code, then you can take advantage of data classes and the module. Similarly, if you’re looking for a tool that allows you to quickly create class-based enumerations of constants, then you can turn your eye to the module and its different types of enumeration classes. In the following sections, you’ll learn the basics of using data classes and enumerations to efficiently write robust, reliable, and specialized classes in Python. Python’s data classes specialize in storing data. However, they’re also code generators that produce a lot of class-related boilerplate code for you behind the scenes. For example, if you use the data class infrastructure to write a custom class, then you won’t have to implement special methods like , , , and . The data class will write them for you. More importantly, the data class will write these methods applying best practices and avoiding potential errors. Note: To learn more about data classes in Python, check out the Data Classes in Python 3.7+ (Guide) tutorial. As you already know, special methods support important functionalities in Python classes. In the case of data classes, you’ll have accurate string representation, comparison capabilities, hashability, and more. Even though the name data class may suggest that this type of class is limited to containing data, it can also contain methods. So, data classes are like regular classes but with superpowers. To create a data class, go ahead and import the decorator from the module. You’ll use this decorator in the definition of your class. This time, you won’t write an method. You’ll just define data fields as class attributes with type hints. For example, here’s how you can write the class as a data class: ! This is your 3D Point!\" This new implementation of uses Python’s decorator to turn the regular class into a data class. Instead of defining an method, you list the attributes with their corresponding types. The data class will take care of writing a proper initializer for you. Note that you don’t define or either. Note: Data classes are pretty flexible when it comes to defining their fields or attributes. You can declare them with the type annotation syntax. You can initialize them with a sensible default value. You can also combine both approaches depending on your needs: In this code snippet, you declare the first attribute using the type annotation syntax. The second attribute has a default value with no type annotation. Finally, the third attribute has both type annotation and a default value. However, when you don’t specify a type hint for an attribute, then Python won’t automatically generate the corresponding code for that attribute. Once you’ve defined the data fields or attributes, you can start adding methods. In this example, you keep the class method and the static method. Go ahead and run the following code to check the additional functionality that has added to this version of : Your class works pretty well! It provides a suitable string representation with an automatically generated method. You can iterate over the fields using the function from the module. Finally, you can compare two instances of the class for equality ( ). As you can conclude, this new version of has saved you from writing several lines of tricky boilerplate code. An enumeration, or just enum, is a data type that you’ll find in several programming languages. Enums allow you to create sets of named constants, which are known as members and can be accessed through the enumeration itself. Python doesn’t have a built-in enum data type. However, Python 3.4 introduced the module to provide the class for supporting general-purpose enumerations. Days of the week, months and seasons of the year, HTTP status codes, colors in a traffic light, and pricing plans of a web service are all great examples of constants that you can group in an enum. In short, you can use enums to represent variables that can take one of a limited set of possible values. The class, among other similar classes in the module, allows you to quickly and efficiently create custom enumerations or groups of similar constants with neat features that you don’t have to code yourself. Apart from member constants, enums can also have methods to operate with those constants. Note: To learn more about how to create and use enumerations in your Python code, check out the Build Enumerations of Constants With Python’s Enum tutorial. To define a custom enumeration, you can subclass the class. Here’s an example of an enumeration that groups the days of the week: In this code example, you define by subclassing from the module. This specific enum groups seven constants representing the days of the week. These constants are the enum members. Because they’re constants, you should follow the convention for naming any constant in Python: uppercase letters and underscores between words, if applicable. Enumerations have a few cool features that you can take advantage of. For example, their members are strict constants, so you can’t change their values. They’re also iterable by default: If you try to change the value of an enum member, then you get an . So, enum members are strictly constants. You can iterate over the members directly because enumerations support iteration by default. You can directly access their members using different syntax: In the first example, you access an enum member using dot notation, which is pretty intuitive and readable. In the second example, you access a member by calling the enumeration with that member’s value as an argument. Finally, you use a dictionary-like syntax to access another member by name. If you want fine-grain access to a member’s components, then you can use the and attributes: In these examples, you access the and attributes of specific members of . These attributes provide access to each member’s component. Finally, you can also add custom behavior to your enumerations. To do that, you can use methods as you’d do with regular classes: After saving your code to , you add a class method called to your enumeration. This method will just return your favorite day of the week, which is Friday, of course! Then you add a method to provide a user-friendly string representation for the current day. Here’s how you can use these methods in your code: You’ve added new functionality to your enumeration through class and instance methods. Isn’t that cool?\n\nInheritance is a powerful feature of object-oriented programming. It consists of creating hierarchical relationships between classes, where child classes inherit attributes and methods from their parent class. In Python, one class can have multiple parents or, more broadly, ancestors. This is known as implementation inheritance, which allows you to reduce duplication and repetition by code reuse. It can also make your code more modular, better organized, and more scalable. However, classes also inherit the interface by becoming more specialized kinds of their ancestors. In some cases, you’ll be able to use a child instance where an ancestor is expected. In the following sections, you’ll learn how to use inheritance in Python. You’ll start with simple inheritance and continue with more complex concepts. So, get ready! This is going to be fun! When you have a class that inherits from a single parent class, then you’re using single-base inheritance or just simple inheritance. To make a Python class inherit from another, you need to list the parent class’s name in parentheses after the child class’s name in the definition. Here’s the syntax that you must use: In this code snippet, is the class you want to inherit from. Parent classes typically provide generic and common functionality that you can reuse throughout multiple child classes. is the class that inherits attributes and methods from . The highlighted line shows the required syntax. Note: In this tutorial, you’ll use the terms parent class, superclass, and base class interchangeably to refer to the class that you inherit from. Similarly, you’ll use the terms child class, derived class, and subclass to refer to classes that inherit from other classes. Here’s a practical example to get started with simple inheritance and how it works. Suppose you’re building an app to track vehicles and routes. At first, the app will track cars and motorcycles. You think of creating a class and deriving two subclasses from it. One subclass will represent a car, and the other will represent a motorcycle. The class will provide common attributes, such as , , and . It’ll also provide the and methods to start and stop the vehicle engine, respectively: In this code, you define the class with attributes and methods that will be common to all your vehicle types. You can say that provides the common interface of all your vehicles. You’ll inherit from this class to reuse this interface and its functionality in your subclasses. Now you can define the and classes. Both of them will have some unique attributes and methods specific to the vehicle type. For example, the will have a attribute and a method: Your class uses as its parent class. This means that will automatically inherit the , , and attributes, as well as the non-public attribute. It’ll also inherit the and methods. Note: Like inheritance in biology, inheritance in OOP goes in a single direction, from the parents to the children. In other words, children inherit from their parents and not the other way around. The class defines a attribute. As you already know, you should define and initialize instance attributes in . This requires you to provide a custom method in , which will shadow the superclass initializer. How can you write an method in and still guarantee that you initialize the , , and attributes? That’s where the built-in function comes on the scene. This function allows you to access members in the superclass, as its name suggests. Note: To learn more about using in your classes, check out Supercharge Your Classes With Python . In , you use to call the method on . Note that you pass the input values for , , and so that can initialize these attributes correctly. After this call to , you add and initialize the attribute, which is specific to the class. Finally, you write the method, which is also specific to . This method is just a demonstrative example, so it only prints a message to your screen. Now it’s time to define the class, which will inherit from too. This class will have a attribute and a method: Again, you call to initialize , , and . After that, you define and initialize the attribute. Finally, you write the method. Again, this method is just a demonstrative example. With this code in place, you can start using and right away: Driving my \"Tesla - Model S\" on the road Riding my \"Harley-Davidson - Iron 883\" on the road. Cool! Your Tesla and your Harley-Davidson work nicely. You can start their engines, drive or ride them, and so on. Note how you can use both the inherited and specific attributes and methods in both classes. You’ll typically use single inheritance or inheritance in general when you have classes that share common attributes and behaviors and want to reuse them in derived classes. So, inheritance is a great tool for code reuse. Subclasses will inherit and reuse functionality from their parent. Subclasses will frequently extend their parent’s interface with new attributes and methods. You can use them as a new starting point to create another level of inheritance. This practice will lead to the creation of class hierarchies. Using inheritance, you can design and build class hierarchies, also known as inheritance trees. A class hierarchy is a set of closely related classes that are connected through inheritance and arranged in a tree-like structure. The class or classes at the top of the hierarchy are the base classes, while the classes below are derived classes or subclasses. Inheritance-based hierarchies express an is-a-type-of relationship between subclasses and their base classes. For example, a bird is a type of animal. Each level in the hierarchy will inherit attributes and behaviors from the above levels. Therefore, classes at the top of the hierarchy are generic classes with common functionality, while classes down the hierarchy are more specialized. They’ll inherit attributes and behaviors from their superclasses and will also add their own. Taxonomic classification of animals is a commonly used example to explain class hierarchies. In this hierarchy, you’ll have a generic class at the top. Below this class, you can have subclasses like , , , and so on. These subclasses are more specific classes than and inherit the attributes and methods from it. They can also have their own attributes and methods. To continue with the hierarchy, you can subclass , , and and create derived classes with even more specific characteristics. Here’s a short toy implementation of this example: At the top of the hierarchy, you have the class. This is the base class of your hierarchy. It has the , , and attributes, which will be string objects. These attributes are common to all animals. Then you define the , , and classes by inheriting from . These classes have a class attribute that holds the distinguishing characteristic of each group of animals. Then you create concrete mammals like and . These classes have specific methods that are common to all dogs and cats, respectively. Similarly, you define two classes that inherit from and two more that inherit from . Here’s a tree-like class diagram that will help you see the hierarchical relationship between classes: Each level in the hierarchy can—and typically will—add new attributes and functionality on top of those that its parents already provide. If you walk through the diagram from top to button, then you’ll move from generic to specialized classes. These latter classes implement new methods that are specific to the class at hand. In this example, the methods just print some information to the screen and automatically return , which is the null value in Python. Note: You can create class diagrams to represent class hierarchies that are based on inheritance. However, that’s not the only relationship that can appear between your classes. With class diagrams, you can also represent other types of relationships, including the following:\n• Composition expresses a strong has-a relationship. For example, a robot has an arm. If the robot stops existing, then the arm stops existing too.\n• Aggregation expresses a softer has-a relationship. For example, a university has an instructor. If the university stops existing, the instructor doesn’t stop existing.\n• Association expresses a uses-a relationship. For example, a student may be associated with a course. They will use the course. This relationship is common in database systems where you have one-to-one, one-to-many, and many-to-many associations. You’ll learn more about some of these types of relationships in the section called Using Alternatives to Inheritance. That’s how you design and create class hierarchies to reuse code and functionality. Such hierarchies also allow you to give your code a modular organization, making it more maintainable and scalable. When you’re using inheritance, you can face an interesting and challenging issue. In some situations, a parent class may provide a given functionality only at a basic level, and you may want to extend that functionality in your subclasses. In other situations, the feature in the parent class isn’t appropriate for the subclass. In these situations, you can use one of the following strategies, depending on your specific case:\n• Extending an inherited method in a subclass, which means that you’ll reuse the functionality provided by the superclass and add new functionality on top\n• Overriding an inherited method in a subclass, which means that you’ll completely discard the functionality from the superclass and provide new functionality in the subclass Here’s an example of a small class hierarchy that applies the first strategy to provide extended functionality based on the inherited one: In this example, you define as the base class. In , you create a few instance attributes. Then you define the method, which prints information about the aircraft’s technical specifications. Next, you define , inheriting from . The method of extends the corresponding method of by calling to initialize the , , and attributes. You already saw something like this in the previous section. also extends the functionality of . In this case, you first call from using . Then you add a new call to that adds new information to the technical description of the helicopter at hand. When you call on a instance, you get the information provided by the base class, , and also the specific information added by itself. You’ve extended the functionality of in its subclass . Now it’s time to take a look at how you can override a method in a subclass. As an example, say that you have a base class called that defines several attributes and methods like in the following example: In this class, you define a few instance attributes to store important data about the current worker. You also provide the method to display relevant information about the worker. Finally, you write a generic method to compute the salary of workers from their hourly salary and the number of hours worked. Later in the development cycle, some requirements change. Now you realize that managers compute their salaries in a different way. They’ll have an hourly bonus that you must add to the normal hourly salary before computing the final amount. After thinking a bit about the problem, you decide that has to override completely. Here’s the implementation that you come up with: In the initializer, you take the hourly bonus as an argument. Then you call the parent’s method as usual and define the instance attribute. Finally, you override with a completely different implementation that doesn’t reuse the inherited functionality. In Python, you can use multiple inheritance. This type of inheritance allows you to create a class that inherits from several parent classes. The subclass will have access to attributes and methods from all its parents. Multiple inheritance allows you to reuse code from several existing classes. However, you must manage the complexity of multiple inheritance with care. Otherwise, you can face issues like the diamond problem. You’ll learn more about this topic in the Method Resolution Order (MRO) section. Here’s a small example of multiple inheritance in Python: In this example, you write a class with , , and attributes. The class also has the , , and methods. Then you create a class that inherits from and extends it with a new method called . You also create an class that inherits from and adds a method. Finally, you define a class to represent a car that you can drive on the road or fly in the sky. Isn’t that cool? Note that this class includes both and in its list of parent classes. So, it’ll inherit functionality from both superclasses. Here’s how you can use the class: In this code snippet, you first create an instance of . Then you call all its methods, including the inherited ones. As you can see, multiple inheritance promotes code reuse, allowing you to use functionality from several base classes at the same time. By the way, if you get this to really fly, then make sure you don’t stop the engine while you’re flying! When you’re using multiple inheritance, you can face situations where one class inherits from two or more classes that have the same base class. This is known as the diamond problem. The real issue appears when multiple parents provide specific versions of the same method. In this case, it’d be difficult to determine which version of that method the subclass will end up using. Python deals with this issue using a specific method resolution order (MRO). So, what is the method resolution order in Python? It’s an algorithm that tells Python how to search for inherited methods in a multiple inheritance context. Python’s MRO determines which implementation of a method or attribute to use when there are multiple versions of it in a class hierarchy. Python’s MRO is based on the order of parent classes in the subclass definition. For example, comes before in the class from the previous section. MRO also considers the inheritance relationships between classes. In general, Python searches for methods and attributes in the following order:\n• The superclass listed next, from left to right, up to the last superclass It’s important to note that the current class comes first in the search. Additionally, if you have multiple parents that implement a given method or attributes, then Python will search them in the same order that they’re listed in the class definition. To illustrate the MRO, consider the following sample class hierarchy: In this example, inherits from and , which inherit from . All the superclasses in the hierarchy define a different version of . Which of these versions will end up calling? To answer this question, go ahead and call on a instance: When you call on an instance of , you get on your screen. This means that Python found on the class first. That’s the version of that you end up calling. You ignore the versions from and . Note: Sometimes, you may run into complex inheritance relationships where Python won’t be able to create a consistent method resolution order. In those cases, you’ll get a pointing out the issue. You can check the current MRO of a given class by using the special attribute: In this output, you can see that Python searches for methods and attributes in by going through itself, then , then , then , and finally, , which is the base class of all Python classes. The attribute can help you tweak your classes and define the specific MRO that you want your class to use. The way to tweak this is by moving and reordering the parent classes in the subclass definition until you get the desired MRO. A mixin class provides methods that you can reuse in many other classes. Mixin classes don’t define new types, so they’re not intended to be instantiated but only inherited. You use their functionality to attach extra features to other classes quickly. You can access the functionality of a mixin class in different ways. One of these ways is inheritance. However, inheriting from mixin classes doesn’t imply an is-a relationship because these classes don’t define concrete types. They just bundle specific functionality that’s intended to be reused in other classes. To illustrate how to use mixin classes, say that you’re building a class hierarchy with a class at the top. From this class, you’ll derive classes like , , , and several others. Then you realize that all the subclasses of need methods that serialize their data into different formats, including JSON and pickle. With this in mind, you think of writing a class that takes care of this task. Here’s what you come up with: In this example, is the parent class, and is a mixin class that provides serialization functionality. The class inherits from both and . Therefore, it’ll inherit the and methods, which you can use to serialize instances of in your code. In this example, is a . However, it’s not a because this class doesn’t define a type of object. It’s just a mixin class that packs serialization capabilities. Note: Because of the method resolution order (MRO), which you learned about earlier, placing your mixin classes before the base classes on the list of parents is often necessary. It’s especially true for class-based views in the Django web framework, which uses mixins to modify the behavior of a base view class. Now your class is able to serialize its data using JSON and pickle formats. That’s great! Can you think of any other useful mixin classes? Up to this point, you’ve learned a lot about simple and multiple inheritance in Python. In the following section, you’ll go through some of the advantages of using inheritance when writing and organizing your code. Inheritance is a powerful tool that you can use to model and solve many real-world problems in your code. Some benefits of using inheritance include the following:\n• Reusability: You can quickly inherit and reuse working code from one or more parent classes in as many subclasses as you need.\n• Modularity: You can use inheritance to organize your code in hierarchies of related classes.\n• Maintainability: You can quickly fix issues or add features to a parent class. These changes will be automatically available in all its subclasses. Inheritance also reduces code duplication.\n• Polymorphism: You can create subclasses that can replace their parent class, providing the same or equivalent functionality.\n• Extensibility: You can quickly extend an exiting class by adding new data and behavior to its subclasses. You can also use inheritance to define a uniform API for all the classes that belong to a given hierarchy. This promotes consistency and leverages polymorphism. Using classes and inheritance, you can make your code more modular, reusable, and extensible. Inheritance enables you to apply good design principles, such as separation of concerns. This principle states that you should organize code in small classes that each take care of a single task. Even though inheritance comes with several benefits, it can also end up causing issues. If you overuse it or use it incorrectly, then you can:\n• Artificially increase your code’s complexity with multiple inheritance or multiple levels of inheritance\n• Face issues like the diamond problem where you’ll have to deal with the method resolution order\n• End up with fragile base classes where changes to a parent class produce unexpected behaviors in subclasses Of course, these aren’t the only potential pitfalls. For example, having multiple levels of inheritance can make your code harder to reason about, which may impact your code’s maintainability in the long term. Another drawback of inheritance is that inheritance is defined at compile time. So, there’s no way to change the inherited functionality at runtime. Other techniques, like composition, allow you to dynamically change the functionality of a given class by replacing its components.\n\nInheritance, and especially multiple inheritance, can be a complex and hard-to-grasp topic. Fortunately, inheritance isn’t the only technique that allows you to reuse functionality in object-oriented programming. You also have composition, which represents a has-a relationship between classes. Composition allows you to build an object from its components. The composite object doesn’t have direct access to each component’s interface. However, it can leverage each component’s implementation. Delegation is another technique that you can use to promote code reuse in your OOP code. With delegation, you can represent can-do relationships, where an object relies on another object to perform a given task. In the following sections, you’ll learn more about these techniques and how they can make your object-oriented code more robust and flexible. As you’ve already learned, you can use composition to model a has-a relationship between objects. In other words, through composition, you can create complex objects by combining objects that will work as components. Note that these components may not make sense as stand-alone classes. Favoring composition over inheritance leads to more flexible class designs. Unlike inheritance, composition is defined at runtime, which means that you can dynamically replace a current component with another component of the same type. This characteristic makes it possible to change the composite’s behavior at runtime. In the example below, you use composition to create an class from the and components: In this example, you build an class out of its components, and . The class provides horizontal movements, while the class represents the robot’s arm and provides vertical movement and welding functionality. Here’s how you can use in your code: Rotating body 20 degrees to the right... Great! Your robot works as expected. It allows you to move its body and arm according to your movement needs. It also allows you to weld different mechanical pieces together. An idea to make this robot even cooler is to implement several types of arms with different welding technologies. Then you can change the arm by doing something like . You can even add a method to your robot class. How does that sound as a learning exercise? Unlike inheritance, composition doesn’t expose the entire interface of components, so it preserves encapsulation. Instead, the composite objects access and use only the required functionality from their components. This characteristic makes your class design more robust and reliable because it won’t expose unneeded members. Following the robot example, say you have several different robots in a factory. Each robot can have different capabilities like welding, cutting, shaping, polishing, and so on. You also have several independent arms. Some of them can perform all those actions. Some of them can perform just a subset of the actions. Now say that a given robot can only weld. However, this robot can use different arms with different welding technologies. If you use inheritance, then the robot will have access to other operations like cutting and shaping, which can cause an accident or breakdown. If you use composition, then the welder robot will only have access to the arm’s welding feature. That said, composition can help you protect your classes from unintended use. Delegation is another technique that you can use as an alternative to inheritance. With delegation, you can model can-do relationships, where an object hands a task over to another object, which takes care of executing the task. Note that the delegated object can exist independently from the delegator. You can use delegation to achieve code reuse, separation of concerns, and modularity. For example, say that you want to create a stack data structure. You think of taking advantage of Python’s as a quick way to store and manipulate the underlying data. Here’s how you end up writing your class: In , you define a object called that can take its initial data from the argument. You’ll use this list to store the data in the containing , so you delegate all the operations related to storing, adding, and deleting data to this list object. Then you implement the typical operations, and . Note how these operations conveniently delegate their responsibilities on and , respectively. Your class has handed its operations over to the object, which already knows how to perform them. It’s important to notice that this class is pretty flexible. You can replace the list object in with any other object as long as it implements the and methods. For example, you can use a object from the module. Because you’ve used delegation to write your class, the internal implementation of isn’t visible or directly accessible in , which preserves encapsulation: The public interface of your class only contains the stack-related methods and , as you can see in the function’s output. This prevents the users of your class from using list-specific methods that aren’t compatible with the classic stack data structure. If you use inheritance, then your child class, , will inherit all the functionality from its parent class, : In this example, your class has inherited all the methods from . These methods are exposed as part of your class’s public API, which may lead to incorrect uses of the class and its instances. With inheritance, the internals of parent classes are visible to subclasses, which breaks encapsulation. If some of the parent’s functionality isn’t appropriate for the child, then you run the risk of incorrect use. In this situation, composition and delegation are safer options. Note: To learn more about creating custom list-like classes, check out the Custom Python Lists: Inheriting From vs tutorial. Finally, in Python, you can quickly implement delegation through the special method. Python calls this method automatically whenever you access an instance attribute or method. You can use this method to redirect the request to another object that can provide the appropriate method or attribute. To illustrate this technique, get back to the mixin example where you used a mixin class to provide serialization capabilities to your class. Here’s how to rewrite the example using delegation: In this new implementation, the serializer class takes the instance that provides the data as an argument. defines a method that uses the built-in function to access the methods in the class. For example, if you call on an instance of , then that call will be automatically redirected to calling on the instance of . Go ahead and try it out! This is a pretty cool Python feature. You’ve tried your hand at a quick example of delegation in Python to learn how a class can delegate some of its responsibilities to another class, achieving code reuse and separation of concerns. Again, you should note that this technique indirectly exposes all the delegated attributes and methods. So, use it with care. Dependency injection is a design pattern that you can use to achieve loose coupling between a class and its components. With this technique, you can provide an object’s dependencies from the outside, rather than inheriting or implementing them in the object itself. This practice allows you to create flexible classes that are able to change their behavior dynamically, depending on the injected functionality. In your robot example, you can use dependency injection to decouple the and classes from , which will make your code more flexible and versatile. In this new version of , you only made two small changes to . Now this method takes and as arguments and assigns their values to the corresponding instance attributes, and . This allows you to inject appropriate body and arm objects into the class so that it can do its work. Here’s how you can use with this new implementation: Rotating body 20 degrees to the right... Overall, the class’s functionality remains the same as in your first version. The only difference is that now you have to pass the body and arm objects to the class constructor. This step is a common way of implementing dependency injection. Now that you know about a few techniques that you can use as alternatives to inheritance, it’s time for you to learn about abstract base classes (ABCs) in Python. These classes allow you to define consistent APIs for your classes."
    },
    {
        "link": "https://datacamp.com/tutorial/encapsulation-in-python-object-oriented-programming",
        "document": "Dive in and learn how to create classes and leverage inheritance and polymorphism to reuse and optimize code."
    },
    {
        "link": "https://medium.com/@lennart.dde/python-classes-structure-best-practices-and-beyond-c1432eb8760e",
        "document": "Python, with its simple syntax and vast libraries, is a powerhouse for developers across domains. At the heart of Python’s object-oriented programming (OOP) capabilities are classes, which allow for organizing and managing code efficiently. Understanding how to structure classes in Python is crucial for building scalable and maintainable applications. This article dives into the nuances of Python classes, offering insights into best practices, the strategic use of data classes, and more.\n\nA class in Python is a blueprint for creating objects. Objects have attributes and methods that define their properties and functionalities. Here’s a basic structure of a Python class:\n\nThis structure outlines a class with an initialization method and a sample method . The method is a constructor that Python calls when you create a new instance of the class.\n• Naming Conventions: Use CapWords convention for class names to enhance readability and distinguish them from variables…"
    },
    {
        "link": "https://geeksforgeeks.org/python-oops-concepts",
        "document": "Object Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full potential of Python OOP capabilities to design elegant and efficient solutions to complex problems.\n\nOOPs is a way of organizing code that uses objects and classes to represent real-world entities and their behavior. In OOPs, object has attributes thing that has specific data and can perform certain actions using methods.\n\nA class is a collection of objects. Classes are blueprints for creating objects. A class defines a set of attributes and methods that the created objects (instances) can have.\n• None Attributes are the variables that belong to a class.\n• None Attributes are always public and can be accessed using the dot (.) operator. Example: Myclass.Myattribute\n\nHere, the class keyword indicates that we are creating a class followed by name of the class (Dog in this case).\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n• State: It is represented by the attributes and reflects the properties of an object.\n• Behavior: It is represented by the methods of an object and reflects the response of an object to other objects.\n• Identity: It gives a unique name to an object and enables one object to interact with other objects.\n\nCreating an object in Python involves instantiating a class to create a new instance of that class. This process is also referred to as object instantiation.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• self.name: Refers to the name attribute of the object (dog1) calling the method.\n\n__init__ method is the constructor in Python, automatically called when a new object is created. It initializes the attributes of the class.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within the __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nInheritance allows a class (child class) to acquire properties and methods of another class (parent class). It supports hierarchical classification and promotes code reuse.\n• Multiple Inheritance: A child class inherits from more than one parent class.\n• Multilevel Inheritance: A child class inherits from a parent class, which in turn inherits from another class.\n• Hybrid Inheritance: A combination of two or more types of inheritance.\n• Multiple Inheritance: GoldenRetriever inherits from both Dog and Friendly.\n\nPolymorphism allows methods to have the same name but behave differently based on the object’s context. It can be achieved through method overriding or overloading.\n• Compile-Time Polymorphism : This type of polymorphism is determined during the compilation of the program. It allows methods or operators with the same name to behave differently based on their input parameters or usage. It is commonly referred to as method or operator overloading.\n• Run-Time Polymorphism : This type of polymorphism is determined during the execution of the program. It occurs when a subclass provides a specific implementation for a method already defined in its parent class, commonly known as method overriding.\n• None Demonstrated using method overriding in the Dog class and its subclasses (Labrador and Beagle).\n• None The correct sound method is invoked at runtime based on the actual type of the object in the list.\n• None Python does not natively support method overloading. Instead, we use a single method (add) with default arguments to handle varying numbers of parameters.\n• None Different behaviors (adding two or three numbers) are achieved based on how the method is called.\n\nEncapsulation is the bundling of data (attributes) and methods (functions) within a class, restricting access to some components to control interactions.\n\nA class is an example of encapsulation as it encapsulates all the data that is member functions, variables, etc.\n• Protected Members : Accessible within the class and its subclasses.\n• Private Members : Accessible only within the class.\n• Public Members: Easily accessible, such as name.\n• Protected Members : Used with a single _, such as _breed. Access is discouraged but allowed in subclasses.\n• Private Members: Used with __, such as __age. Access requires\n\nAbstraction hides the internal implementation details while exposing only the necessary functionality. It helps focus on “what to do” rather than “how to do it.”\n• Partial Abstraction: Abstract class contains both abstract and concrete methods.\n• Full Abstraction: Abstract class contains only abstract methods (like interfaces).\n• Why Use It : Abstraction ensures consistency in derived classes by enforcing the implementation of abstract methods.\n\nWhat are the 4 pillars of OOP Python?\n\nIs OOP used in Python?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://geeksforgeeks.org/python-oops-concepts",
        "document": "Object Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full potential of Python OOP capabilities to design elegant and efficient solutions to complex problems.\n\nOOPs is a way of organizing code that uses objects and classes to represent real-world entities and their behavior. In OOPs, object has attributes thing that has specific data and can perform certain actions using methods.\n\nA class is a collection of objects. Classes are blueprints for creating objects. A class defines a set of attributes and methods that the created objects (instances) can have.\n• None Attributes are the variables that belong to a class.\n• None Attributes are always public and can be accessed using the dot (.) operator. Example: Myclass.Myattribute\n\nHere, the class keyword indicates that we are creating a class followed by name of the class (Dog in this case).\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n• State: It is represented by the attributes and reflects the properties of an object.\n• Behavior: It is represented by the methods of an object and reflects the response of an object to other objects.\n• Identity: It gives a unique name to an object and enables one object to interact with other objects.\n\nCreating an object in Python involves instantiating a class to create a new instance of that class. This process is also referred to as object instantiation.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• self.name: Refers to the name attribute of the object (dog1) calling the method.\n\n__init__ method is the constructor in Python, automatically called when a new object is created. It initializes the attributes of the class.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within the __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nInheritance allows a class (child class) to acquire properties and methods of another class (parent class). It supports hierarchical classification and promotes code reuse.\n• Multiple Inheritance: A child class inherits from more than one parent class.\n• Multilevel Inheritance: A child class inherits from a parent class, which in turn inherits from another class.\n• Hybrid Inheritance: A combination of two or more types of inheritance.\n• Multiple Inheritance: GoldenRetriever inherits from both Dog and Friendly.\n\nPolymorphism allows methods to have the same name but behave differently based on the object’s context. It can be achieved through method overriding or overloading.\n• Compile-Time Polymorphism : This type of polymorphism is determined during the compilation of the program. It allows methods or operators with the same name to behave differently based on their input parameters or usage. It is commonly referred to as method or operator overloading.\n• Run-Time Polymorphism : This type of polymorphism is determined during the execution of the program. It occurs when a subclass provides a specific implementation for a method already defined in its parent class, commonly known as method overriding.\n• None Demonstrated using method overriding in the Dog class and its subclasses (Labrador and Beagle).\n• None The correct sound method is invoked at runtime based on the actual type of the object in the list.\n• None Python does not natively support method overloading. Instead, we use a single method (add) with default arguments to handle varying numbers of parameters.\n• None Different behaviors (adding two or three numbers) are achieved based on how the method is called.\n\nEncapsulation is the bundling of data (attributes) and methods (functions) within a class, restricting access to some components to control interactions.\n\nA class is an example of encapsulation as it encapsulates all the data that is member functions, variables, etc.\n• Protected Members : Accessible within the class and its subclasses.\n• Private Members : Accessible only within the class.\n• Public Members: Easily accessible, such as name.\n• Protected Members : Used with a single _, such as _breed. Access is discouraged but allowed in subclasses.\n• Private Members: Used with __, such as __age. Access requires\n\nAbstraction hides the internal implementation details while exposing only the necessary functionality. It helps focus on “what to do” rather than “how to do it.”\n• Partial Abstraction: Abstract class contains both abstract and concrete methods.\n• Full Abstraction: Abstract class contains only abstract methods (like interfaces).\n• Why Use It : Abstraction ensures consistency in derived classes by enforcing the implementation of abstract methods.\n\nWhat are the 4 pillars of OOP Python?\n\nIs OOP used in Python?"
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://w3schools.com/python/python_classes.asp",
        "document": "Almost everything in Python is an object, with its properties and methods.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nTo create a class, use the keyword :\n\nNow we can use the class named MyClass to create objects:\n\nThe examples above are classes and objects in their simplest form, and are not really useful in real life applications.\n\nTo understand the meaning of classes we have to understand the built-in function.\n\nAll classes have a function called , which is always executed when the class is being initiated.\n\nUse the function to assign values to object properties, or other operations that are necessary to do when the object is being created:\n\nThe function controls what should be returned when the class object is represented as a string.\n\nIf the function is not set, the string representation of the object is returned:\n\nObjects can also contain methods. Methods in objects are functions that belong to the object.\n\nLet us create a method in the Person class:\n\nThe parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\nIt does not have to be named , you can call it whatever you like, but it has to be the first parameter of any function in the class:\n\nYou can modify properties on objects like this:\n\nYou can delete properties on objects by using the keyword:\n\nYou can delete objects by using the keyword:\n\ndefinitions cannot be empty, but if you for some reason have a definition with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://docs.python.org/3/tutorial/index.html",
        "document": "Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.\n\nThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.\n\nThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.\n\nThis tutorial introduces the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line as well.\n\nFor a description of standard objects and modules, see The Python Standard Library. The Python Language Reference gives a more formal definition of the language. To write extensions in C or C++, read Extending and Embedding the Python Interpreter and Python/C API Reference Manual. There are also several books covering Python in depth.\n\nThis tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules and programs, and you will be ready to learn more about the various Python library modules described in The Python Standard Library.\n\nThe Glossary is also worth going through."
    }
]