[
    {
        "link": "https://jinja.palletsprojects.com/en/stable/templates",
        "document": "This document describes the syntax and semantics of the template engine and will be most useful as reference to those creating Jinja templates. As the template engine is very flexible, the configuration from the application can be slightly different from the code presented here in terms of delimiters and behavior of undefined values.\n\nA Jinja template is simply a text file. Jinja can generate any text-based format (HTML, XML, CSV, LaTeX, etc.). A Jinja template doesn’t need to have a specific extension: , , or any other extension is just fine. A template contains variables and/or expressions, which get replaced with values when a template is rendered; and tags, which control the logic of the template. The template syntax is heavily inspired by Django and Python. Below is a minimal template that illustrates a few basics using the default Jinja configuration. We will cover the details later in this document: The following example shows the default configuration settings. An application developer can change the syntax configuration from to , or something similar. There are a few kinds of delimiters. The default Jinja delimiters are configured as follows:\n• None for Expressions to print to the template output\n• None for Comments not included in the template output Line Statements and Comments are also possible, though they don’t have default prefix characters. To use them, set and when creating the . As stated above, any file can be loaded as a template, regardless of file extension. Adding a extension, like may make it easier for some IDEs or editor plugins, but is not required. Autoescaping, introduced later, can be applied based on file extension, so you’ll need to take the extra suffix into account in that case. Another good heuristic for identifying templates is that they are in a folder, regardless of extension. This is a common layout for projects.\n\nThe most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base “skeleton” template that contains all the common elements of your site and defines blocks that child templates can override. Sounds complicated but is very basic. It’s easiest to understand it by starting with an example. This template, which we’ll call , defines a simple HTML skeleton document that you might use for a simple two-column page. It’s the job of “child” templates to fill the empty blocks with content: - My Webpage Copyright 2008 by you . In this example, the tags define four blocks that child templates can fill in. All the tag does is tell the template engine that a child template may override those placeholders in the template. tags can be inside other blocks such as , but they will always be executed regardless of if the block is actually rendered. A child template might look like this: Index Index Welcome to my awesome homepage. The tag is the key here. It tells the template engine that this template “extends” another template. When the template system evaluates this template, it first locates the parent. The extends tag should be the first tag in the template. Everything before it is printed out normally and may cause confusion. For details about this behavior and how to take advantage of it, see Null-Default Fallback. Also a block will always be filled in regardless of whether the surrounding condition is evaluated to be true or false. The filename of the template depends on the template loader. For example, the allows you to access other templates by giving the filename. You can access templates in subdirectories with a slash: But this behavior can depend on the application embedding Jinja. Note that since the child template doesn’t define the block, the value from the parent template is used instead. You can’t define multiple tags with the same name in the same template. This limitation exists because a block tag works in “both” directions. That is, a block tag doesn’t just provide a placeholder to fill - it also defines the content that fills the placeholder in the parent. If there were two similarly-named tags in a template, that template’s parent wouldn’t know which one of the blocks’ content to use. If you want to print a block multiple times, you can, however, use the special variable and call the block with that name: It’s possible to render the contents of the parent block by calling . This gives back the results of the parent block: In the case of multiple levels of , references may be chained (as in ) to skip levels in the inheritance tree. # parent.tmpl body: Hi from parent. # child.tmpl Hi from child. # grandchild1.tmpl Hi from grandchild1. # grandchild2.tmpl Hi from grandchild2. Rendering will give body: Hi from child. Hi from parent. Rendering will give body: Hi from grandchild2. Hi from parent. Blocks can be nested for more complex layouts. By default, a block may not access variables from outside the block (outer scopes): This example would output empty items because is unavailable inside the block. The reason for this is that if the block is replaced by a child template, a variable would appear that was not defined in the block or passed to the context. Starting with Jinja 2.2, you can explicitly specify that variables are available in a block by setting the block to “scoped” by adding the modifier to a block declaration: When overriding a block, the modifier does not have to be provided. Blocks can be marked as . They must be overridden at some point, but not necessarily by the direct child template. Required blocks may only contain space and comments, and they cannot be rendered directly. Rendering or will raise because they don’t override the block. Rendering will succeed because it does override the block. When combined with , the modifier must be placed after the scoped modifier. Here are some valid examples: , , and can take a template object instead of the name of a template to load. This could be useful in some advanced situations, since you can use Python code to load a template first and pass it in to . Note how is passed the variable with the template object that was passed to , instead of a string.\n\nA control structure refers to all those things that control the flow of a program - conditionals (i.e. if/elif/else), for-loops, as well as things like macros and blocks. With the default syntax, control structures appear inside blocks. Loop over each item in a sequence. For example, to display a list of users provided in a variable called : As variables in templates retain their object properties, it is possible to iterate over containers like : Python dicts may not be in the order you want to display them in. If order matters, use the filter. Inside of a for-loop block, you can access some special variables: The current iteration of the loop. (1 indexed) The current iteration of the loop. (0 indexed) The number of iterations from the end of the loop (1 indexed) The number of iterations from the end of the loop (0 indexed) The number of items in the sequence. A helper function to cycle between a list of sequences. See the explanation below. Indicates how deep in a recursive loop the rendering currently is. Starts at level 1 Indicates how deep in a recursive loop the rendering currently is. Starts at level 0 The item from the previous iteration of the loop. Undefined during the first iteration. The item from the following iteration of the loop. Undefined during the last iteration. True if previously called with a different value (or not called at all). Within a for-loop, it’s possible to cycle among a list of strings/variables each time through the loop by using the special helper: Since Jinja 2.1, an extra helper exists that allows loop-unbound cycling. For more information, have a look at the List of Global Functions. Unlike in Python, it’s not possible to or in a loop. You can, however, filter the sequence during iteration, which allows you to skip items. The following example skips all the users which are hidden: The advantage is that the special variable will count correctly; thus not counting the users not iterated over. If no iteration took place because the sequence was empty or the filtering removed all the items from the sequence, you can render a default block by using : Note that, in Python, blocks are executed whenever the corresponding loop did not . Since Jinja loops cannot anyway, a slightly different behavior of the keyword was chosen. It is also possible to use loops recursively. This is useful if you are dealing with recursive data such as sitemaps or RDFa. To use loops recursively, you basically have to add the modifier to the loop definition and call the variable with the new iterable where you want to recurse. The following example implements a sitemap with recursive loops: The variable always refers to the closest (innermost) loop. If we have more than one level of loops, we can rebind the variable by writing after the loop that we want to use recursively. Then, we can call it using Please note that assignments in loops will be cleared at the end of the iteration and cannot outlive the loop scope. Older versions of Jinja had a bug where in some circumstances it appeared that assignments would work. This is not supported. See Assignments for more information about how to deal with this. If all you want to do is check whether some value has changed since the last iteration or will change in the next iteration, you can use and : The value just increased! The value will increase even more! If you only care whether the value changed at all, using is even easier: The statement in Jinja is comparable with the Python if statement. In the simplest form, you can use it to test if a variable is defined, not empty and not false: For multiple branches, and can be used like in Python. You can use more complex Expressions there, too: Kenny is sick. You killed Kenny! You bastard!!! Kenny looks okay --- so far If can also be used as an inline expression and for loop filtering. Macros are comparable with functions in regular programming languages. They are useful to put often used idioms into reusable functions to not repeat yourself (“DRY”). Here’s a small example of a macro that renders a form element: The macro can then be called like a function in the namespace: If the macro was defined in a different template, you have to import it first. Inside macros, you have access to three special variables: If more positional arguments are passed to the macro than accepted by the macro, they end up in the special variable as a list of values. Like but for keyword arguments. All unconsumed keyword arguments are stored in this special variable. If the macro was called from a call tag, the caller is stored in this variable as a callable macro. Macros also expose some of their internal details. The following attributes are available on a macro object: The name of the macro. will print . A tuple of the names of arguments the macro accepts. This is if the macro accepts extra keyword arguments (i.e.: accesses the special variable). This is if the macro accepts extra positional arguments (i.e.: accesses the special variable). This is if the macro accesses the special variable and may be called from a call tag. If a macro name starts with an underscore, it’s not exported and can’t be imported. Due to how scopes work in Jinja, a macro in a child template does not override a macro in a parent template. The following will output “LAYOUT”, not “CHILD”. In some cases it can be useful to pass a macro to another macro. For this purpose, you can use the special block. The following example shows a macro that takes advantage of the call functionality and how it can be used: - - This is a simple dialog rendered by using a macro and a call block. It’s also possible to pass arguments back to the call block. This makes it useful as a replacement for loops. Generally speaking, a call block works exactly like a macro without a name. Here’s an example of how a call block can be used with arguments: Filter sections allow you to apply regular Jinja filters on a block of template data. Just wrap the code in the special section: Filters that accept arguments can be called like this: Inside code blocks, you can also assign values to variables. Assignments at top level (outside of blocks, macros or loops) are exported from the template like top level macros and can be imported by other templates. Assignments use the tag and can have multiple targets: Please keep in mind that it is not possible to set variables inside a block and have them show up outside of it. This also applies to loops. The only exception to that rule are if statements which do not introduce a scope. As a result the following template is not going to do what you might expect: It is not possible with Jinja syntax to do this. Instead use alternative constructs like the loop else block or the special variable: As of version 2.10 more complex use cases can be handled using namespace objects which allow propagating of changes across scopes: Note that the notation in the tag is only allowed for namespace objects; attempting to assign an attribute on any other object will raise an exception. It’s possible to use as a block to assign the content of the block to a variable. This can be used to create multi-line strings, since Jinja doesn’t support Python’s triple quotes ( , ). Instead of using an equals sign and a value, you only write the variable name, and everything until is captured. Filters applied to the variable name will be applied to the block’s content. The tag can be used to extend one template from another. You can have multiple tags in a file, but only one of them may be executed at a time. See the section about Template Inheritance above. Blocks are used for inheritance and act as both placeholders and replacements at the same time. They are documented in detail in the Template Inheritance section. The tag renders another template and outputs the result into the current template. The included template has access to context of the current template by default. Use to use a separate context instead. is also valid, but is the default behavior. See Import Context Behavior. The included template can another template and override blocks in that template. However, the current template cannot override any blocks that the included template outputs. Use to ignore the statement if the template does not exist. It must be placed before a context visibility statement. If a list of templates is given, each will be tried in order until one is not missing. This can be used with to ignore if none of the templates exist. A variable, with either a template name or template object, can also be passed to the statement. Jinja supports putting often used code into macros. These macros can go into different templates and get imported from there. This works similarly to the import statements in Python. It’s important to know that imports are cached and imported templates don’t have access to the current template variables, just the globals by default. For more details about context behavior of imports and includes, see Import Context Behavior. There are two ways to import templates. You can import a complete template into a variable or request specific macros / exported variables from it. Imagine we have a helper module that renders forms (called ): The easiest and most flexible way to access a template’s variables and macros is to import the whole template module into a variable. That way, you can access the attributes: Alternatively, you can import specific names from a template into the current namespace: Macros and variables starting with one or more underscores are private and cannot be imported. Changed in version 2.4: If a template object was passed to the template context, you can import from that object.\n\nJinja allows basic expressions everywhere. These work very similarly to regular Python; even if you’re not working with Python you should feel comfortable with it. The simplest form of expressions are literals. Literals are representations for Python objects such as strings and numbers. The following literals exist: Everything between two double or single quotes is a string. They are useful whenever you need a string in the template (e.g. as arguments to function calls and filters, or just to extend or include a template). Integers are whole numbers without a decimal part. The ‘_’ character can be used to separate groups for legibility. Floating point numbers can be written using a ‘.’ as a decimal mark. They can also be written in scientific notation with an upper or lower case ‘e’ to indicate the exponent part. The ‘_’ character can be used to separate groups for legibility, but cannot be used in the exponent part. Everything between two brackets is a list. Lists are useful for storing sequential data to be iterated over. For example, you can easily create a list of links using lists and tuples for (and with) a for loop: Tuples are like lists that cannot be modified (“immutable”). If a tuple only has one item, it must be followed by a comma ( ). Tuples are usually used to represent items of two or more elements. See the list example above for more details. A dict in Python is a structure that combines keys and values. Keys must be unique and always have exactly one value. Dicts are rarely used in templates; they are useful in some rare cases such as the filter. is always true and is always false. The special constants , , and are indeed lowercase. Because that caused confusion in the past, ( used to expand to an undefined variable that was considered false), all three can now also be written in title case ( , , and ). However, for consistency, (all Jinja identifiers are lowercase) you should use the lowercase versions. Jinja allows you to calculate with values. This is rarely useful in templates but exists for completeness’ sake. The following operators are supported: Adds two objects together. Usually the objects are numbers, but if both are strings or lists, you can concatenate them this way. This, however, is not the preferred way to concatenate strings! For string concatenation, have a look-see at the operator. is . Subtract the second number from the first one. is . Divide two numbers. The return value will be a floating point number. is . Divide two numbers and return the truncated integer result. is . Calculate the remainder of an integer division. is . Multiply the left operand with the right one. would return . This can also be used to repeat a string multiple times. would print a bar of 80 equal signs. Raise the left operand to the power of the right operand. would return . Unlike Python, chained pow is evaluated left to right. is evaluated as in Jinja, but would be evaluated as in Python. Use parentheses in Jinja to be explicit about what order you want. It is usually preferable to do extended math in Python and pass the results to rather than doing it in the template. This behavior may be changed in the future to match Python, if it’s possible to introduce an upgrade path. if the left hand side is greater than the right hand side. if the left hand side is greater or equal to the right hand side. if the left hand side is lower than the right hand side. if the left hand side is lower or equal to the right hand side. For statements, filtering, and expressions, it can be useful to combine multiple expressions. For , if is false, then the value is , else . In a boolean context, this will be treated as if both operands are truthy. For , if is true, then the value is , else . In a boolean context, this will be treated as if at least one operand is truthy. For , if is false, then the value is , else . Prefer negating and using their infix notation: instead of ; instead of . All other expressions require prefix notation: Parentheses group an expression. This is used to change evaluation order, or to make a long expression easier to read or less ambiguous. The following operators are very useful but don’t fit into any of the other two categories: Perform a sequence / mapping containment test. Returns true if the left operand is contained in the right. would, for example, return true. Converts all operands into strings and concatenates them. would return (assuming is set to ) . Call a callable: . Inside of the parentheses you can use positional arguments and keyword arguments like in Python: Get an attribute of an object. (See Variables) It is also possible to use inline expressions. These are useful in some situations. For example, you can use this to extend from one template if a variable is defined, otherwise from the default layout template: The general syntax is <do something> if <something is true> else <do something else> . The part is optional. If not provided, the else block implicitly evaluates into an object (regardless of what in the environment is set to): You can also use any of the methods defined on a variable’s type. The value returned from the method invocation is used as the value of the expression. Here is an example that uses methods defined on strings (where is a string): This works for methods on user-defined types. For example, if variable of type has a method defined on it, you can do the following: Operator methods also work as expected. For example, implements printf-style for strings: Although you should prefer the method for that case (which is a bit contrived in the context of rendering a template):\n\nReturn the absolute value of the argument. Get an attribute of an object. works like just that always an attribute is returned and items are not looked up. See Notes on subscriptions for more details. A filter that batches items. It works pretty much like just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example: Capitalize a value. The first character will be uppercase, all others lowercase. Centers the value in a field of a given width. If the value is undefined it will return the passed default value, otherwise the value of the variable: This will output the value of if the variable was defined, otherwise . If you want to use default with variables that evaluate to false you have to set the second parameter to : Changed in version 2.11: It’s now possible to configure the with to make the filter work on nested elements and attributes that may contain undefined values in the chain without getting an . Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. sort the dict by value, case insensitive Replace the characters , , , , and in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the object has an method, it is called and the return value is assumed to already be safe for HTML. s – An object to be converted to a string and escaped. Format the value like a ‘human-readable’ file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to the binary prefixes are used (Mebi, Gibi). Return the first item of a sequence. Convert the value into a floating point number. If the conversion doesn’t work it will return . You can override this default using the first parameter. Enforce HTML escaping. This will probably double escape variables. Apply the given values to a printf-style format string, like . In most cases it should be more convenient and efficient to use the operator or . Group a sequence of objects by an attribute using Python’s . The attribute can use dot notation for nested access, like . Unlike Python’s , the values are sorted first so only one group is returned for each unique value. For example, a list of objects with a attribute can be rendered in groups. In this example, refers to the value of the group. yields namedtuples of , which can be used instead of the tuple unpacking above. is the value of the attribute, and is the items with that value. You can specify a value to use if an object in the list does not have the given attribute. Like the filter, sorting and grouping is case-insensitive by default. The for each group will have the case of the first item in that group of values. For example, if a list of users has cities , the “CA” group will have two values. This can be disabled by passing . Changed in version 3.1: Added the parameter. Sorting and grouping is case-insensitive by default, matching other filters that do comparisons. Changed in version 2.6: The attribute supports dot notation for nested access. Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default.\n• None width – Number of spaces, or a string, to indent by.\n• None first – Don’t skip indenting the first line. Changed in version 3.0: can be a string. Changed in version 2.10: Blank lines are not indented by default. Convert the value into an integer. If the conversion doesn’t work it will return . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. Return an iterator over the items of a mapping. is the same as , except if is undefined an empty iterator is returned. This filter is useful if you expect the template to be rendered with an implementation of Jinja in another programming language that does not have a method on its mapping type. Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter: It is also possible to join certain attributes of an object: Added in version 2.6: The parameter was added. Return the last item of a sequence. Note: Does not work with generators. You may want to explicitly convert it to a list: Return the number of items in a container. Convert the value into a list. If it was a string the returned list will be a list of characters. Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. The basic usage is mapping on an attribute. Imagine you have a list of users but you are only interested in a list of usernames: You can specify a value to use if an object in the list does not have the given attribute. Alternatively you can let it invoke a filter by passing the name of the filter and the arguments afterwards. A good example would be applying a text conversion filter on a sequence: Similar to a generator comprehension such as: Return the largest item from the sequence.\n• None attribute – Get the object with the max value of this attribute. Return the smallest item from the sequence.\n• None attribute – Get the object with the min value of this attribute. Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. If no test is specified, each object will be evaluated as a boolean. Similar to a generator comprehension such as: Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. If no test is specified, the attribute’s value will be evaluated as a boolean. Similar to a generator comprehension such as: Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument is given, only the first occurrences are replaced: Reverse the object or return an iterator that iterates over it the other way round. Round the number to a given precision. The first parameter specifies the precision (default is ), the second the rounding method:\n• None rounds either up or down If you don’t specify a method is used. Note that even if rounded to 0 precision, a float is returned. If you need a real integer, pipe it through : Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. If no test is specified, each object will be evaluated as a boolean. Similar to a generator comprehension such as: Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. If no test is specified, the attribute’s value will be evaluated as a boolean. Similar to a generator comprehension such as: Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns: If you pass it a second argument it’s used to fill missing values on the last iteration.\n• None attribute – When sorting objects or dicts, an attribute or key to sort by. Can use dot notation like . Can be a list of attributes like . The sort is stable, it does not change the relative order of elements that compare equal. This makes it is possible to chain sorts on different attributes and ordering. As a shortcut to chaining when the direction is the same for all attributes, pass a comma separate list of attributes. Changed in version 2.11.0: The parameter can be a comma separated list of attributes, e.g. . Changed in version 2.6: The parameter was added. Convert an object to a string if it isn’t already. This preserves a string rather than converting it back to a basic string, so it will still be marked as safe and won’t be escaped again. Strip SGML/XML tags and replace adjacent whitespace by one space. Returns the sum of a sequence of numbers plus the value of parameter ‘start’ (which defaults to 0). When the sequence is empty it returns start. It is also possible to sum up only certain attributes: Changed in version 2.6: The parameter was added to allow summing up over attributes. Also the parameter was moved on to the right. Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents. The returned string is safe to render in HTML documents and tags. The exception is in HTML attributes that are double quoted; either use single quotes or the filter.\n• None value – The object to serialize to JSON.\n• None indent – The parameter passed to , for pretty-printing the value. Return a truncated copy of the string. The length is specified with the first parameter which defaults to . If the second parameter is the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( ). If you want a different ellipsis sign than you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. The default leeway on newer Jinja versions is 5 and was 0 before but can be reconfigured globally. Returns a list of unique items from the given iterable. The unique items are yielded in the same order as their first occurrence in the iterable passed to the filter.\n• None attribute – Filter objects with unique values for this attribute. Quote data for use in a URL path or query using UTF-8. Basic wrapper around when given a string, or for a dict or iterable. value – Data to quote. A string will be quoted directly. A dict or iterable of pairs will be joined as a query string. When given a string, “/” is not quoted. HTTP servers treat “/” and “%2F” equivalently in paths. If you need quoted slashes, use the filter. This may not recognize links in some situations. Usually, a more comprehensive formatter, such as a Markdown library, is a better choice. Works on , , , , and email addresses. Links with trailing punctuation (periods, commas, closing parentheses) and leading punctuation (opening parentheses) are recognized excluding the punctuation. Email addresses that include header fields are not recognized (for example, ).\n• None value – Original text containing URLs to link.\n• None extra_schemes – Recognize URLs that start with these schemes in addition to the default behavior. Defaults to , which defaults to no extra schemes. Changed in version 3.0: The parameter was added. Changed in version 3.0: Generate links for URLs without a scheme. Changed in version 3.0: The parsing rules were updated. Recognize email addresses with or without the scheme. Validate IP addresses. Ignore parentheses and brackets in more cases. Changed in version 2.8: The parameter was added. Count the words in that string. Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately.\n• None break_long_words – If a word is longer than , break it across lines.\n• None break_on_hyphens – If a word contains hyphens, it may be split across lines.\n• None wrapstring – String to join each wrapped line. Defaults to . Changed in version 2.11: Existing newlines are treated as paragraphs wrapped separately. Create an SGML/XML attribute string based on the items in a dict. Values that are neither nor are automatically escaped, safely allowing untrusted user input. User input should not be used as keys to this filter. If any key contains a space, solidus, greater-than sign, or equals sign, this fails with a . Regardless of this, user input should never be used as keys to this filter, or must be separately validated first. Results in something like this: As you can see it automatically prepends a space in front of the item if the filter returned something unless the second parameter is false. Changed in version 3.1.4: Keys with solidus, greater-than sign, or equals sign are not allowed. Changed in version 3.1.3: Keys with spaces are not allowed.\n\nThe following sections cover the built-in Jinja extensions that may be enabled by an application. An application could also provide further extensions not covered by this documentation; in which case there should be a separate document explaining said extensions. If the i18n Extension is enabled, it’s possible to mark text in the template as translatable. To mark a section as translatable, use a block: Inside the block, no statements are allowed, only text and simple variable tags. Variable tags can only be a name, not attribute access, filters, or other expressions. To use an expression, bind it to a name in the tag for use in the block. To bind more than one expression, separate each with a comma ( ). To pluralize, specify both the singular and plural forms separated by the tag. By default, the first variable in a block is used to determine whether to use singular or plural form. If that isn’t correct, specify the variable used for pluralizing as a parameter to . When translating blocks of text, whitespace and linebreaks result in hard to read and error-prone translation strings. To avoid this, a trans block can be marked as trimmed, which will replace all linebreaks and the whitespace surrounding them with a single space and remove leading and trailing whitespace. This results in This is %(book_title)s. You should read it! in the translation file. If trimming is enabled globally, the modifier can be used to disable it for a block. Added in version 2.10: The and modifiers have been added. If the translation depends on the context that the message appears in, the and functions take a string as the first argument, which is used to select the appropriate translation. To specify a context with the tag, provide a string as the first token after . Added in version 3.1: A context can be passed to the tag to use and . It’s possible to translate strings in expressions with these functions:\n• None : Like , but picks the translation based on the context string.\n• None : Like , but picks the translation based on the context string. You can print a translated string like this: To use placeholders, use the filter. Always use keyword arguments to , as other languages may not use the words in the same order. If New Style Gettext calls are activated, using placeholders is easier. Formatting is part of the call instead of using the filter. The function’s format string automatically receives the count as a parameter in addition to the given parameters. If the expression-statement extension is loaded, a tag called is available that works exactly like the regular variable expression ( ); except it doesn’t print anything. This can be used to modify lists: If the application enables the Loop Controls, it’s possible to use and in loops. When is reached, the loop is terminated; if is reached, the processing is stopped and continues with the next iteration. Here’s a loop that skips every second item: Likewise, a loop that stops processing after the 10th iteration: Note that starts with 1, and starts with 0 (See: For). If the Debug Extension is enabled, a tag will be available to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger. The with statement makes it possible to create a new inner scope. Variables set within this scope are not visible outside of the scope. foo is 42 here foo is not visible here any longer Because it is common to set variables at the beginning of the scope, you can do that within the statement. The following two examples are equivalent: An important note on scoping here. In Jinja versions before 2.9 the behavior of referencing one variable to another had some unintended consequences. In particular one variable could refer to another defined in the same with block’s opening statement. This caused issues with the cleaned up scoping behavior and has since been improved. In particular in newer Jinja versions the following code always refers to the variable from outside the block: In earlier Jinja versions the attribute would refer to the results of the first attribute. If you depend on this behavior you can rewrite it to use the tag: In older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default."
    },
    {
        "link": "https://jinja.palletsprojects.com",
        "document": "Jinja is a fast, expressive, extensible templating engine. Special placeholders in the template allow writing code similar to Python syntax. Then the template is passed data to render the final document."
    },
    {
        "link": "https://documentation.bloomreach.com/engagement/docs/jinja-syntax",
        "document": "Even though it isn't a programming language, Jinja also has a specific set of words that you need to use in order to write a 'code' in it. Together, they are called the syntax and are governed by a set of simple rules that allow you to tell the computer what you need to achieve in a language comprehensible to it.\n\nYou will be mostly writing your Jinja templates directly in the Bloomreach Engagement. However, in general, you can write Jinja templates into a simple text file. You do not need to worry about the file's extension, Jinja does not require a specific file extension and it can generate any text-based format, such as Html, XML, CSV, or LaTeX.\n\nBecause Jinja codes are usually inserted into other types of code, such as Html in emails, the difference between the Jinja code and the other parts need to be clearly distinguished. In Jinja, you will use delimiters to signify that this particular part of code is relevant for the parser.\n\nThe following table describes the delimiters that you need to use.\n\nAnother basic feature of Jinja is variables. Sometimes, you need the computer to remember some values while rendering your template. In order to do so, you can create a variable, that will store the value for you. A variable always has a name, by which it can be referred to during the rendering, and it also has a type. However, you do not need to worry about types, for now. Jinja automatically sets them up for you when you initialize a variable.\n\nBefore you can use your variable, it first needs to be initialized. You can do this by using the set command. However, you always need to initialize your variables with value. For instance, will create a variable called favouriteAnimal and save the word \"duck\" in it. Then, you can use the variable throughout your code by typing the variable name.\n\nWhen defining a variable, it is possible to use and statements.\n\nExample with if/else when setting a variable:\n\nExample without using if/else when setting variable:\n\nSometimes, you might be interested in the properties of some value of your variables. For instance, you would like to know, how many letters does the name of your customer contain. In general, the properties of your customers can be accessed in two ways. First, they can be accessed by using the box brackets.\n\n , which returns the property specified in the string between the box brackets from the specified variable, this is the preferred way. You can also access the properties using the dot notation .\n\nNone value in Jinja None value in Jinja\n\nWhen the none value is returned for example from an aggregate, the Jinja renderer processes it as the string value “None”. This means that if you’re using a campaign to set attribute based on aggregate and the aggregate doesn’t return any value (= returns None), that attribute will have string value “None”.\n\nList\n\n Mutable array, defined with square brackets \n\n Can contain any data types\n\n E.g. \n\n Find more about Lists\n\nTuple\n\n Like list, but immutable, cannot be changed once defined.\n\n Defined with parenthesis \n\n Can contain any type\n\n E.g. \n\n Find more about Tuples\n\nDictionary\n\n Object containing pairs.\n\n Defined with curly brackets \n\n Keys can be Strings, Numbers (Integers or Floats), or None.\n\n Value can be any data type.\n\n Find more about Dictionaries\n\nJinja also supports basic expressions. They are built upon the python expressions but should feel easy to use even if you have never had any experience with python. You can see the reference in the Jinja Template Designer Documentation. However, expressions will be covered here too.\n\nThe most basic expressions in Jinja are the math expressions. You often need to perform math operations on your data and Jinja does contain the elementary operations that you might need to perform. The official documentation for math expressions can be found in Template designer documentation - Math.\n• Calculate the remainder of division. For instance, 11 % 7 returns 4.\n\nJinja also inherits the comparison operators from python. They are essential when implementing control flow, which will be covered in a later article. The official documentation for comparison expressions can be found in Template designer documentation - Comparisons.\n• true if the left-hand side is greater than the right-hand side\n• true if the left-hand side is greater or equal to the right-hand side\n• true if the left-hand side is lower than the right-hand side\n• true if the left-hand side is lower or equal to the right-hand side\n\nYou can also evaluate boolean expressions in Jinja using logic operators.\n\nJinja also supports operators which do not fit in any of the previous categories. They are so-called other operators.\n\n\n\n In is used for testing whether a value is contained in a sequence or mapping.\n\n It evaluates to True if the left-hand side is contained in the right-hand side.\n\n It admits Lists, Tuples, Strings and Dictionaries as arguments. However, dictionaries are tested for keys, not for values.\n\n Example: or both of these evaluate to and return True.\n\n\n\n Is is used for applying tests. Using the is operator performs a test specified by the right-hand side on a variable on the left-hand side. Tests will be covered in a later section.\n\n Example: returns true.\n\n\n\n The ~ (read as \"tilde\") operator is used to join operands as strings. It converts neighboring operands into strings and concatenates them.\n\n Example: prints '4ever'"
    },
    {
        "link": "https://docs.coalesce.io/docs/reference/jinja/jinja-syntax",
        "document": "Jinja is a templating engine for Python. It’s most frequently used in Django and Flask applications. In Coalesce, you can use it to expand SQL capabilities.\n\nThese are just some of the syntax options available with Jinja. See Template Designer Documentation for more.\n\nVariables in Jinja are defined by double curly braces. Jinja replaces the with the value.\n\nStatements control logic and flow. For example, starting a loop.\n\nComments are not evaluated when the code is run. Comments are a good place to put information such as what the code does and the expected output.\n\nJinja will print any whitespace in the code block. To prevent that, adding a dash to the left or right of the percent sign will remove the whitespace.\n\nFilters are designed by a pipe, . They change the look, format, or even output new data.\n\nA for loop will loop over a sequence until a condition is met. For example, you have a list of cookies, chocolate chips, oatmeal, and sugar. For every cookie in the list, print out “I love cookies”. “I love cookies” will be printed three times.\n\nUse if/else to provide instructions such as if this condition is met, then to this action.\n\nLists are formatted using brackets, . Lists are indexed starting at 0. For example, chocolate chip has an index of 0.\n\nJinja inherits the comparison operators from Python. Comparison operators are used to compare values and determine if they equate to true or false.\n\nIn this example, a single equal, =, is used to set a variable. Use a single equals to set variables, dictionaries, and lists. A double equal, ==, is used to compare if the color is orange. In the example below, it is orange, it evaluates to true.\n\nBecause Jinja inherits from Python, you have many syntax options available. There are a few common ones in this guide. You can also use SQL statements such as CASE WHEN. This makes Jinja a very powerful tool in Coalesce."
    },
    {
        "link": "https://jinja.palletsprojects.com/en/stable/api",
        "document": "This document describes the API to Jinja and not the template language (for that, see Template Designer Documentation). It will be most useful as reference to those implementing the template interface to the application and not those who are creating Jinja templates.\n\nJinja uses a central object called the template . Instances of this class are used to store the configuration and global objects, and are used to load templates from the file system or other locations. Even if you are creating templates from strings by using the constructor of class, an environment is created automatically for you, albeit a shared one. Most applications will create one object on application initialization and use that to load templates. In some cases however, it’s useful to have multiple environments side by side, if different configurations are in use. The simplest way to configure Jinja to load templates for your application is to use . This will create a template environment with a loader that looks up templates in the folder inside the Python package (or next to the Python module). It also enables autoescaping for HTML files. This loader only requires that is importable, it figures out the absolute path to the folder for you. Different loaders are available to load templates in other ways or from other locations. They’re listed in the Loaders section below. You can also write your own if you want to load templates from a source that’s more specialized to your project. To load a template from this environment, call the method, which returns the loaded . To render it with some variables, call the method. Using a template loader rather than passing strings to or has multiple advantages. Besides being a lot easier to use it also enables template inheritance. In future versions of Jinja we might enable autoescaping by default for security reasons. As such you are encouraged to explicitly configure autoescaping now instead of relying on the default.\n\nJinja now comes with autoescaping support. As of Jinja 2.9 the autoescape extension is removed and built-in. However autoescaping is not yet enabled by default though this will most likely change in the future. It’s recommended to configure a sensible default for autoescaping. This makes it possible to enable and disable autoescaping on a per-template basis (HTML versus text for instance). Intelligently sets the initial value of autoescaping based on the filename of the template. This is the recommended way to configure autoescaping if you do not want to write a custom function yourself. If you want to enable it for all templates created from strings or for all templates with and extensions: Example configuration to turn it on at all times except if the template ends with : The is an iterable of all the extensions that autoescaping should be enabled for. Likewise is a list of all templates it should be disabled for. If a template is loaded from a string then the default from is used. If nothing matches then the initial value of autoescaping is set to the value of . Here a recommended setup that enables autoescaping for templates ending in , and and disabling it by default for all other extensions. You can use the function for this: The function returns a function that works roughly like this: When implementing a guessing autoescape function, make sure you also accept as valid template name. This will be passed when generating templates from strings. You should always configure autoescaping as defaults in the future might change. Inside the templates the behaviour can be temporarily changed by using the block (see Autoescape Overrides).\n\nThese classes can be used as undefined types. The constructor takes an parameter that can be one of those classes or a custom subclass of . Whenever the template engine is unable to look up a name or access an attribute one of those objects is created and returned. Some operations on undefined values are then allowed, others fail. The closest to regular Python behavior is the which disallows all operations beside testing if it’s an undefined object. The default undefined type. This can be printed, iterated, and treated as a boolean. Any other operation will raise an . Either or a string with the error message for the undefined object. Either or the owner object that caused the undefined object to be created (for example because an attribute does not exist). The name for the undefined variable / attribute or just if no such information exists. The exception that the undefined object wants to raise. This is usually one of or . When called with any arguments this method raises with an error message generated from the undefined hints stored on the undefined object. An undefined that is chainable, where both and return itself rather than raising an . An undefined that returns the debug info when printed. An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons. In other words: you can do nothing with it except checking if it’s defined using the test. There is also a factory function that can decorate undefined objects to implement logging on failures: Given a logger object this returns a new undefined class that will log certain failures. It will log iterations and printing. If no logger is given a default logger is created.\n• None logger (logging.Logger | None) – the logger to use. If not provided, a default logger is created.\n• None base (Type[Undefined]) – the base class to add logging functionality to. This defaults to . is implemented by overriding the special methods. For example the default class implements to returns an empty string, while and others fail with an exception. To allow conversion to int by returning you can implement your own subclass. To disallow a method, override it and raise . Because this is very common there is the helper method that raises the error with the correct information. Here’s a class that works like the regular but fails on iteration:\n\nThe template context holds the variables of a template. It stores the values passed to the template and also the names the template exports. Creating instances is neither supported nor useful as it’s created automatically at various stages of the template evaluation and should not be created by hand. The context is immutable. Modifications on must not happen and modifications on are allowed from generated template code only. Template filters and global functions marked as get the active context passed as first argument and are allowed to access the context read-only. The template context supports read only dict operations ( , , , , , , , , ). Additionally there is a method that doesn’t fail with a but returns an object for missing variables. A dict of read only, global variables the template looks up. These can either come from another , from the or or points to a dict created by combining the globals with the variables passed to the render function. It must not be altered. The template local variables. This list contains environment and context functions from the scope as well as local modifications and exported variables from the template. The template will modify this dict during template evaluation but filters and context functions are not allowed to modify it. The environment that loaded the template. This set contains all the names the template exports. The values for the names are in the dict. In order to get a copy of the exported variables as dict, can be used. The load name of the template owning this context. A dict with the current mapping of blocks in the template. The keys in this dict are the names of the blocks, and the values a list of blocks registered. The last item in each list is the current active block (latest in the inheritance chain). Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable has or . Look up a variable by name, or return a default if the key is not found.\n• None key (str) – The variable name to look up.\n• None default (Any) – The value to return if the key is not found. Look up a variable by name, or return an object if the key is not found. If you need to add custom behavior, override , not this method. The various lookup functions use that method, not this one. key (str) – The variable name to look up. Look up a variable by name, or return a sentinel if the key is not found. Override this method to add custom lookup behavior. , , and use this method. Don’t call this method directly. key (str) – The variable name to look up. Get a new dict with the exported variables. Return the complete context as dict including the exported variables. For optimizations reasons this might not return an actual copy so be careful with using it. The context is immutable, it prevents modifications, and if it is modified somehow despite that those changes may not show up. For performance, Jinja does not use the context as data storage for, only as a primary data source. Variables that the template does not define are looked up in the context, but variables the template does define are stored locally. Instead of modifying the context directly, a function should return a value that can be assigned to a variable within the template itself.\n\nLoaders are responsible for loading templates from a resource such as the file system. The environment will keep the compiled modules in memory like Python’s . Unlike however this cache is limited in size by default and templates are automatically reloaded. All loaders are subclasses of . If you want to create your own loader, subclass and override . Baseclass for all loaders. Subclass this and override to implement a custom loading mechanism. The environment provides a method that calls the loader’s method to get the object. A very basic example for a loader that looks up templates on the file system could look like this: Get the template source, filename and reload helper for a template. It’s passed the environment and template name and has to return a tuple in the form or raise a error if it can’t locate the template. The source part of the returned tuple must be the source of the template as a string. The filename should be the name of the file on the filesystem if it was loaded from there, otherwise . The filename is used by Python for the tracebacks if no loader extension is used. The last item in the tuple is the function. If auto reloading is enabled it’s always called to check if the template changed. No arguments are passed so the function must store the old state somewhere (for example in a closure). If it returns the template will be reloaded. Loads a template. This method looks up the template in the cache or loads one by calling . Subclasses should not override this method as loaders working on collections of other loaders (such as or ) will not call this method but directly. Here a list of the builtin loaders Jinja provides: Load templates from a directory in the file system. The path can be relative or absolute. Relative paths are relative to the current working directory. A list of paths can be given. The directories will be searched in order, stopping at the first matching template.\n• None searchpath (str | os.PathLike[str] | Sequence[str | os.PathLike[str]]) – A path, or list of paths, to the directory that contains the templates.\n• None encoding (str) – Use this encoding to read the text from template files.\n• None package_name (str) – Import name of the package that contains the template directory.\n• None package_path (str) – Directory within the imported package that contains the templates. The following example looks up templates in the directory within the package. Only packages installed as directories (standard pip behavior) or zip/egg files (less common) are supported. The Python API for introspecting data in packages is too limited to support other installation methods the way this loader requires. There is limited support for PEP 420 namespace packages. The template directory is assumed to only be in one namespace contributor. Zip files contributing to a namespace are not supported. Changed in version 3.0: No longer uses as a dependency. Loads a template from a Python dict mapping template names to template source. This loader is useful for unittesting: Because auto reloading is rarely useful this is disabled by default. A loader that is passed a function which does the loading. The function receives the name of the template and has to return either a string with the template source, a tuple in the form or if the template does not exist. The is a function that is called if autoreload is enabled and has to return if the template is still up to date. For more details have a look at which has the same return value. load_func (Callable[[str], str | Tuple[str, str | None, Callable[[], bool] | None] | None]) A loader that is passed a dict of loaders where each loader is bound to a prefix. The prefix is delimited from the template by a slash per default, which can be changed by setting the argument to something else: By loading the file from the app1 package is loaded, by loading the file from the second. This loader works like the just that no prefix is specified. If a template could not be found by one loader the next one is tried. This is useful if you want to allow users to override builtin templates from a different location. Templates can be precompiled with .\n\nJinja 2.1 and higher support external bytecode caching. Bytecode caches make it possible to store the generated bytecode on the file system or a different location to avoid parsing the templates on first use. This is especially useful if you have a web application that is initialized on the first request and Jinja compiles many templates at once which slows down the application. To use a bytecode cache, instantiate it and pass it to the . To implement your own bytecode cache you have to subclass this class and override and . Both of these methods are passed a . A very basic bytecode cache that saves the bytecode on the file system: A more advanced version of a filesystem based bytecode cache is part of Jinja. Subclasses have to override this method to load bytecode into a bucket. If they are not able to find code in the cache for the bucket, it must not do anything. Subclasses have to override this method to write the bytecode from a bucket back to the cache. If it unable to do so it must not fail silently but raise an exception. Clears the cache. This method is not used by Jinja but should be implemented to allow applications to clear the bytecode cache used by a particular environment. Buckets are used to store the bytecode for one template. It’s created and initialized by the bytecode cache and passed to the loading functions. The buckets get an internal checksum from the cache assigned and use this to automatically reject outdated cache material. Individual bytecode cache subclasses don’t have to care about cache invalidation. The that created the bucket. The unique cache key for this bucket The bytecode if it’s loaded, otherwise . Loads bytecode from a file or file like object. Dump the bytecode into the file or file like object passed. A bytecode cache that stores bytecode on the filesystem. It accepts two arguments: The directory where the cache items are stored and a pattern string that is used to build the filename. If no directory is specified a default cache directory is selected. On Windows the user’s temp directory is used, on UNIX systems a directory is created for the user in the system temp directory. The pattern can be used to have multiple separate caches operate on the same directory. The default pattern is . is replaced with the cache key. This bytecode cache supports clearing of the cache using the clear method. This class implements a bytecode cache that uses a memcache cache for storing the information. It does not enforce a specific memcache library (tummy’s memcache or cmemcache) but will accept any class that provides the minimal interface required. The minimal interface for the client passed to the constructor is this: Stores the bytecode in the cache. is a string and the timeout of the key. If timeout is not provided a default timeout or no timeout should be assumed, if it’s provided it’s an integer with the number of seconds the cache item should exist. Returns the value for the cache key. If the item does not exist in the cache the return value must be . The other arguments to the constructor are the prefix for all keys that is added before the actual cache key and the timeout for the bytecode in the cache system. We recommend a high (or no) timeout. This bytecode cache does not support clearing of used items in the cache. The clear method is a no-operation function. Added in version 2.7: Added support for ignoring memcache errors through the parameter.\n\nThe low level API exposes functionality that can be useful to understand some implementation details, debugging purposes or advanced extension techniques. Unless you know exactly what you are doing we don’t recommend using any of those. Lex the given sourcecode and return a generator that yields tokens as tuples in the form . This can be useful for extension development and debugging templates. This does not perform preprocessing. If you want the preprocessing of the extensions to be applied you have to filter source through the method. Parse the sourcecode and return the abstract syntax tree. This tree of nodes is used by the compiler to convert the template into executable source- or bytecode. This is useful for debugging or to extract information from templates. If you are developing Jinja extensions this gives you a good overview of the node tree generated. Preprocesses the source with all extensions. This is automatically called for all parsing and compiling methods but not for because there you usually only want the actual source tokenized. Create a new for this template. The vars provided will be passed to the template. Per default the globals are added to the context. If shared is set to the data is passed as is to the context without adding the globals. can be a dict of local variables for internal usage. This is the low level render function. It’s passed a that has to be created by of the same template or a compatible template. This render function is generated by the compiler from the template code and returns a generator that yields strings. If an exception in the template code happens the template engine will not rewrite the exception but pass through the original one. As a matter of fact this function should only be called from within a / / call. A dict of block render functions. Each of these functions works exactly like the with the same limitations. This attribute is if there is a newer version of the template available, otherwise . The low-level API is fragile. Future Jinja versions will try not to change it in a backwards incompatible way but modifications in the Jinja core may shine through. For example if Jinja introduces a new AST node in later versions that may be returned by ."
    },
    {
        "link": "https://stackoverflow.com/questions/71099625/how-to-create-a-random-string-and-use-it-in-jinja-in-ansible",
        "document": "I would like to create a random string in Ansible tasks and use it in jinja2.\n\n The string should contain , , with a length of 32 characters.\n\nI found out this function but can't use it in a\n\nI'm using Ansible 2.12.1 set_fact writes the string \"lookup('community.general.random_string', length=12)\" in me template. I need to create once a random string to use it as passphrase in a config file. On the second run the random string should not be touched - need to add also a check if file exists or something like that."
    },
    {
        "link": "https://stackoverflow.com/questions/64487377/generate-random-letters-using-jinja-for-cookiecutter-template",
        "document": "I am looking to generate a random 8 letter hash for a cookeicutter template. In pure Python, this would generate what I'd like:\n\nIn Jinja, the closest thing I could find would be a multiline solution. I need a one-liner. Any ideas?"
    },
    {
        "link": "https://geeksforgeeks.org/best-practices-for-jinja-templating",
        "document": "Jinja templating is a powerful tool for generating dynamic content in Python web applications. In this article, we will discuss some best practices related to Jinja Templating. By following these best practices, you can ensure that your templates are well-organized, maintainable, and secure.\n\nJinja is known for its simplicity and flexibility, there are several best practices you should follow to ensure clean, maintainable, and efficient templates. In this article, we’ll explore some of these best practices for Jinja templating.\n\nMaintaining a well-structured template directory is crucial for the long-term maintainability of your project. Organize your templates into logical folders, such as one for each major component or page of your website.\n\nJinja is sensitive to whitespace, so be careful with indentation and line breaks. Inconsistent whitespace can lead to unexpected rendering issues. Use Jinja’s ‘{%- … -%}’ syntax to remove whitespace where necessary, especially when looping or including blocks.\n\nAdd comments to your templates to provide context and explanations for other developers (or your future self). Use Jinja’s comment syntax {# This is a comment #} to clarify the purpose of specific sections or code blocks within your templates.\n\nJinja allows you to create templates that inherit from a base template and override specific blocks. This is a powerful way to create a consistent layout for your website while still customizing content where needed. By using ‘{% extends “base.html” %}’ and ‘{% block content %} … {% endblock %}’ tags, you can achieve a clean separation of concerns between your base layout and specific page content.\n\nImplement feature flags in your Jinja templates to conditionally display or hide features based on user roles, A/B testing, or other criteria. This allows for easy experimentation and feature rollout.\n\nKeep your templates as clean as possible by avoiding complex logic. Jinja is primarily designed for rendering, not for complex calculations or data manipulation. If you find yourself writing complex logic within your templates, consider moving it to the backend code where it belongs. This improves code readability and maintainability.\n\nDuring the development phase, use Jinja templates to generate mock data for testing and prototyping. This can help simulate real-world scenarios and ensure your templates function correctly with various data inputs.\n\nUse Jinja to generate adaptive images by automatically selecting and rendering the appropriate image size and format based on the user’s device and screen resolution. This can significantly improve page load times and user experience.\n\nJinja provides a range of filters for modifying data within your templates. While filters can be useful for simple operations like formatting dates or strings, avoid using them excessively. Complex data manipulation is better suited for the backend, and using too many filters can make your templates hard to understand and debug.\n\nLeverage Jinja templates for rendering data visualizations or charts. You can generate JavaScript or SVG code within your templates to dynamically display data in charts or graphs on your web pages."
    },
    {
        "link": "https://jinja.palletsprojects.com/en/stable/templates",
        "document": "This document describes the syntax and semantics of the template engine and will be most useful as reference to those creating Jinja templates. As the template engine is very flexible, the configuration from the application can be slightly different from the code presented here in terms of delimiters and behavior of undefined values.\n\nA Jinja template is simply a text file. Jinja can generate any text-based format (HTML, XML, CSV, LaTeX, etc.). A Jinja template doesn’t need to have a specific extension: , , or any other extension is just fine. A template contains variables and/or expressions, which get replaced with values when a template is rendered; and tags, which control the logic of the template. The template syntax is heavily inspired by Django and Python. Below is a minimal template that illustrates a few basics using the default Jinja configuration. We will cover the details later in this document: The following example shows the default configuration settings. An application developer can change the syntax configuration from to , or something similar. There are a few kinds of delimiters. The default Jinja delimiters are configured as follows:\n• None for Expressions to print to the template output\n• None for Comments not included in the template output Line Statements and Comments are also possible, though they don’t have default prefix characters. To use them, set and when creating the . As stated above, any file can be loaded as a template, regardless of file extension. Adding a extension, like may make it easier for some IDEs or editor plugins, but is not required. Autoescaping, introduced later, can be applied based on file extension, so you’ll need to take the extra suffix into account in that case. Another good heuristic for identifying templates is that they are in a folder, regardless of extension. This is a common layout for projects.\n\nThe most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base “skeleton” template that contains all the common elements of your site and defines blocks that child templates can override. Sounds complicated but is very basic. It’s easiest to understand it by starting with an example. This template, which we’ll call , defines a simple HTML skeleton document that you might use for a simple two-column page. It’s the job of “child” templates to fill the empty blocks with content: - My Webpage Copyright 2008 by you . In this example, the tags define four blocks that child templates can fill in. All the tag does is tell the template engine that a child template may override those placeholders in the template. tags can be inside other blocks such as , but they will always be executed regardless of if the block is actually rendered. A child template might look like this: Index Index Welcome to my awesome homepage. The tag is the key here. It tells the template engine that this template “extends” another template. When the template system evaluates this template, it first locates the parent. The extends tag should be the first tag in the template. Everything before it is printed out normally and may cause confusion. For details about this behavior and how to take advantage of it, see Null-Default Fallback. Also a block will always be filled in regardless of whether the surrounding condition is evaluated to be true or false. The filename of the template depends on the template loader. For example, the allows you to access other templates by giving the filename. You can access templates in subdirectories with a slash: But this behavior can depend on the application embedding Jinja. Note that since the child template doesn’t define the block, the value from the parent template is used instead. You can’t define multiple tags with the same name in the same template. This limitation exists because a block tag works in “both” directions. That is, a block tag doesn’t just provide a placeholder to fill - it also defines the content that fills the placeholder in the parent. If there were two similarly-named tags in a template, that template’s parent wouldn’t know which one of the blocks’ content to use. If you want to print a block multiple times, you can, however, use the special variable and call the block with that name: It’s possible to render the contents of the parent block by calling . This gives back the results of the parent block: In the case of multiple levels of , references may be chained (as in ) to skip levels in the inheritance tree. # parent.tmpl body: Hi from parent. # child.tmpl Hi from child. # grandchild1.tmpl Hi from grandchild1. # grandchild2.tmpl Hi from grandchild2. Rendering will give body: Hi from child. Hi from parent. Rendering will give body: Hi from grandchild2. Hi from parent. Blocks can be nested for more complex layouts. By default, a block may not access variables from outside the block (outer scopes): This example would output empty items because is unavailable inside the block. The reason for this is that if the block is replaced by a child template, a variable would appear that was not defined in the block or passed to the context. Starting with Jinja 2.2, you can explicitly specify that variables are available in a block by setting the block to “scoped” by adding the modifier to a block declaration: When overriding a block, the modifier does not have to be provided. Blocks can be marked as . They must be overridden at some point, but not necessarily by the direct child template. Required blocks may only contain space and comments, and they cannot be rendered directly. Rendering or will raise because they don’t override the block. Rendering will succeed because it does override the block. When combined with , the modifier must be placed after the scoped modifier. Here are some valid examples: , , and can take a template object instead of the name of a template to load. This could be useful in some advanced situations, since you can use Python code to load a template first and pass it in to . Note how is passed the variable with the template object that was passed to , instead of a string.\n\nA control structure refers to all those things that control the flow of a program - conditionals (i.e. if/elif/else), for-loops, as well as things like macros and blocks. With the default syntax, control structures appear inside blocks. Loop over each item in a sequence. For example, to display a list of users provided in a variable called : As variables in templates retain their object properties, it is possible to iterate over containers like : Python dicts may not be in the order you want to display them in. If order matters, use the filter. Inside of a for-loop block, you can access some special variables: The current iteration of the loop. (1 indexed) The current iteration of the loop. (0 indexed) The number of iterations from the end of the loop (1 indexed) The number of iterations from the end of the loop (0 indexed) The number of items in the sequence. A helper function to cycle between a list of sequences. See the explanation below. Indicates how deep in a recursive loop the rendering currently is. Starts at level 1 Indicates how deep in a recursive loop the rendering currently is. Starts at level 0 The item from the previous iteration of the loop. Undefined during the first iteration. The item from the following iteration of the loop. Undefined during the last iteration. True if previously called with a different value (or not called at all). Within a for-loop, it’s possible to cycle among a list of strings/variables each time through the loop by using the special helper: Since Jinja 2.1, an extra helper exists that allows loop-unbound cycling. For more information, have a look at the List of Global Functions. Unlike in Python, it’s not possible to or in a loop. You can, however, filter the sequence during iteration, which allows you to skip items. The following example skips all the users which are hidden: The advantage is that the special variable will count correctly; thus not counting the users not iterated over. If no iteration took place because the sequence was empty or the filtering removed all the items from the sequence, you can render a default block by using : Note that, in Python, blocks are executed whenever the corresponding loop did not . Since Jinja loops cannot anyway, a slightly different behavior of the keyword was chosen. It is also possible to use loops recursively. This is useful if you are dealing with recursive data such as sitemaps or RDFa. To use loops recursively, you basically have to add the modifier to the loop definition and call the variable with the new iterable where you want to recurse. The following example implements a sitemap with recursive loops: The variable always refers to the closest (innermost) loop. If we have more than one level of loops, we can rebind the variable by writing after the loop that we want to use recursively. Then, we can call it using Please note that assignments in loops will be cleared at the end of the iteration and cannot outlive the loop scope. Older versions of Jinja had a bug where in some circumstances it appeared that assignments would work. This is not supported. See Assignments for more information about how to deal with this. If all you want to do is check whether some value has changed since the last iteration or will change in the next iteration, you can use and : The value just increased! The value will increase even more! If you only care whether the value changed at all, using is even easier: The statement in Jinja is comparable with the Python if statement. In the simplest form, you can use it to test if a variable is defined, not empty and not false: For multiple branches, and can be used like in Python. You can use more complex Expressions there, too: Kenny is sick. You killed Kenny! You bastard!!! Kenny looks okay --- so far If can also be used as an inline expression and for loop filtering. Macros are comparable with functions in regular programming languages. They are useful to put often used idioms into reusable functions to not repeat yourself (“DRY”). Here’s a small example of a macro that renders a form element: The macro can then be called like a function in the namespace: If the macro was defined in a different template, you have to import it first. Inside macros, you have access to three special variables: If more positional arguments are passed to the macro than accepted by the macro, they end up in the special variable as a list of values. Like but for keyword arguments. All unconsumed keyword arguments are stored in this special variable. If the macro was called from a call tag, the caller is stored in this variable as a callable macro. Macros also expose some of their internal details. The following attributes are available on a macro object: The name of the macro. will print . A tuple of the names of arguments the macro accepts. This is if the macro accepts extra keyword arguments (i.e.: accesses the special variable). This is if the macro accepts extra positional arguments (i.e.: accesses the special variable). This is if the macro accesses the special variable and may be called from a call tag. If a macro name starts with an underscore, it’s not exported and can’t be imported. Due to how scopes work in Jinja, a macro in a child template does not override a macro in a parent template. The following will output “LAYOUT”, not “CHILD”. In some cases it can be useful to pass a macro to another macro. For this purpose, you can use the special block. The following example shows a macro that takes advantage of the call functionality and how it can be used: - - This is a simple dialog rendered by using a macro and a call block. It’s also possible to pass arguments back to the call block. This makes it useful as a replacement for loops. Generally speaking, a call block works exactly like a macro without a name. Here’s an example of how a call block can be used with arguments: Filter sections allow you to apply regular Jinja filters on a block of template data. Just wrap the code in the special section: Filters that accept arguments can be called like this: Inside code blocks, you can also assign values to variables. Assignments at top level (outside of blocks, macros or loops) are exported from the template like top level macros and can be imported by other templates. Assignments use the tag and can have multiple targets: Please keep in mind that it is not possible to set variables inside a block and have them show up outside of it. This also applies to loops. The only exception to that rule are if statements which do not introduce a scope. As a result the following template is not going to do what you might expect: It is not possible with Jinja syntax to do this. Instead use alternative constructs like the loop else block or the special variable: As of version 2.10 more complex use cases can be handled using namespace objects which allow propagating of changes across scopes: Note that the notation in the tag is only allowed for namespace objects; attempting to assign an attribute on any other object will raise an exception. It’s possible to use as a block to assign the content of the block to a variable. This can be used to create multi-line strings, since Jinja doesn’t support Python’s triple quotes ( , ). Instead of using an equals sign and a value, you only write the variable name, and everything until is captured. Filters applied to the variable name will be applied to the block’s content. The tag can be used to extend one template from another. You can have multiple tags in a file, but only one of them may be executed at a time. See the section about Template Inheritance above. Blocks are used for inheritance and act as both placeholders and replacements at the same time. They are documented in detail in the Template Inheritance section. The tag renders another template and outputs the result into the current template. The included template has access to context of the current template by default. Use to use a separate context instead. is also valid, but is the default behavior. See Import Context Behavior. The included template can another template and override blocks in that template. However, the current template cannot override any blocks that the included template outputs. Use to ignore the statement if the template does not exist. It must be placed before a context visibility statement. If a list of templates is given, each will be tried in order until one is not missing. This can be used with to ignore if none of the templates exist. A variable, with either a template name or template object, can also be passed to the statement. Jinja supports putting often used code into macros. These macros can go into different templates and get imported from there. This works similarly to the import statements in Python. It’s important to know that imports are cached and imported templates don’t have access to the current template variables, just the globals by default. For more details about context behavior of imports and includes, see Import Context Behavior. There are two ways to import templates. You can import a complete template into a variable or request specific macros / exported variables from it. Imagine we have a helper module that renders forms (called ): The easiest and most flexible way to access a template’s variables and macros is to import the whole template module into a variable. That way, you can access the attributes: Alternatively, you can import specific names from a template into the current namespace: Macros and variables starting with one or more underscores are private and cannot be imported. Changed in version 2.4: If a template object was passed to the template context, you can import from that object.\n\nJinja allows basic expressions everywhere. These work very similarly to regular Python; even if you’re not working with Python you should feel comfortable with it. The simplest form of expressions are literals. Literals are representations for Python objects such as strings and numbers. The following literals exist: Everything between two double or single quotes is a string. They are useful whenever you need a string in the template (e.g. as arguments to function calls and filters, or just to extend or include a template). Integers are whole numbers without a decimal part. The ‘_’ character can be used to separate groups for legibility. Floating point numbers can be written using a ‘.’ as a decimal mark. They can also be written in scientific notation with an upper or lower case ‘e’ to indicate the exponent part. The ‘_’ character can be used to separate groups for legibility, but cannot be used in the exponent part. Everything between two brackets is a list. Lists are useful for storing sequential data to be iterated over. For example, you can easily create a list of links using lists and tuples for (and with) a for loop: Tuples are like lists that cannot be modified (“immutable”). If a tuple only has one item, it must be followed by a comma ( ). Tuples are usually used to represent items of two or more elements. See the list example above for more details. A dict in Python is a structure that combines keys and values. Keys must be unique and always have exactly one value. Dicts are rarely used in templates; they are useful in some rare cases such as the filter. is always true and is always false. The special constants , , and are indeed lowercase. Because that caused confusion in the past, ( used to expand to an undefined variable that was considered false), all three can now also be written in title case ( , , and ). However, for consistency, (all Jinja identifiers are lowercase) you should use the lowercase versions. Jinja allows you to calculate with values. This is rarely useful in templates but exists for completeness’ sake. The following operators are supported: Adds two objects together. Usually the objects are numbers, but if both are strings or lists, you can concatenate them this way. This, however, is not the preferred way to concatenate strings! For string concatenation, have a look-see at the operator. is . Subtract the second number from the first one. is . Divide two numbers. The return value will be a floating point number. is . Divide two numbers and return the truncated integer result. is . Calculate the remainder of an integer division. is . Multiply the left operand with the right one. would return . This can also be used to repeat a string multiple times. would print a bar of 80 equal signs. Raise the left operand to the power of the right operand. would return . Unlike Python, chained pow is evaluated left to right. is evaluated as in Jinja, but would be evaluated as in Python. Use parentheses in Jinja to be explicit about what order you want. It is usually preferable to do extended math in Python and pass the results to rather than doing it in the template. This behavior may be changed in the future to match Python, if it’s possible to introduce an upgrade path. if the left hand side is greater than the right hand side. if the left hand side is greater or equal to the right hand side. if the left hand side is lower than the right hand side. if the left hand side is lower or equal to the right hand side. For statements, filtering, and expressions, it can be useful to combine multiple expressions. For , if is false, then the value is , else . In a boolean context, this will be treated as if both operands are truthy. For , if is true, then the value is , else . In a boolean context, this will be treated as if at least one operand is truthy. For , if is false, then the value is , else . Prefer negating and using their infix notation: instead of ; instead of . All other expressions require prefix notation: Parentheses group an expression. This is used to change evaluation order, or to make a long expression easier to read or less ambiguous. The following operators are very useful but don’t fit into any of the other two categories: Perform a sequence / mapping containment test. Returns true if the left operand is contained in the right. would, for example, return true. Converts all operands into strings and concatenates them. would return (assuming is set to ) . Call a callable: . Inside of the parentheses you can use positional arguments and keyword arguments like in Python: Get an attribute of an object. (See Variables) It is also possible to use inline expressions. These are useful in some situations. For example, you can use this to extend from one template if a variable is defined, otherwise from the default layout template: The general syntax is <do something> if <something is true> else <do something else> . The part is optional. If not provided, the else block implicitly evaluates into an object (regardless of what in the environment is set to): You can also use any of the methods defined on a variable’s type. The value returned from the method invocation is used as the value of the expression. Here is an example that uses methods defined on strings (where is a string): This works for methods on user-defined types. For example, if variable of type has a method defined on it, you can do the following: Operator methods also work as expected. For example, implements printf-style for strings: Although you should prefer the method for that case (which is a bit contrived in the context of rendering a template):\n\nReturn the absolute value of the argument. Get an attribute of an object. works like just that always an attribute is returned and items are not looked up. See Notes on subscriptions for more details. A filter that batches items. It works pretty much like just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example: Capitalize a value. The first character will be uppercase, all others lowercase. Centers the value in a field of a given width. If the value is undefined it will return the passed default value, otherwise the value of the variable: This will output the value of if the variable was defined, otherwise . If you want to use default with variables that evaluate to false you have to set the second parameter to : Changed in version 2.11: It’s now possible to configure the with to make the filter work on nested elements and attributes that may contain undefined values in the chain without getting an . Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first. sort the dict by value, case insensitive Replace the characters , , , , and in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the object has an method, it is called and the return value is assumed to already be safe for HTML. s – An object to be converted to a string and escaped. Format the value like a ‘human-readable’ file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to the binary prefixes are used (Mebi, Gibi). Return the first item of a sequence. Convert the value into a floating point number. If the conversion doesn’t work it will return . You can override this default using the first parameter. Enforce HTML escaping. This will probably double escape variables. Apply the given values to a printf-style format string, like . In most cases it should be more convenient and efficient to use the operator or . Group a sequence of objects by an attribute using Python’s . The attribute can use dot notation for nested access, like . Unlike Python’s , the values are sorted first so only one group is returned for each unique value. For example, a list of objects with a attribute can be rendered in groups. In this example, refers to the value of the group. yields namedtuples of , which can be used instead of the tuple unpacking above. is the value of the attribute, and is the items with that value. You can specify a value to use if an object in the list does not have the given attribute. Like the filter, sorting and grouping is case-insensitive by default. The for each group will have the case of the first item in that group of values. For example, if a list of users has cities , the “CA” group will have two values. This can be disabled by passing . Changed in version 3.1: Added the parameter. Sorting and grouping is case-insensitive by default, matching other filters that do comparisons. Changed in version 2.6: The attribute supports dot notation for nested access. Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default.\n• None width – Number of spaces, or a string, to indent by.\n• None first – Don’t skip indenting the first line. Changed in version 3.0: can be a string. Changed in version 2.10: Blank lines are not indented by default. Convert the value into an integer. If the conversion doesn’t work it will return . You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values. Return an iterator over the items of a mapping. is the same as , except if is undefined an empty iterator is returned. This filter is useful if you expect the template to be rendered with an implementation of Jinja in another programming language that does not have a method on its mapping type. Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter: It is also possible to join certain attributes of an object: Added in version 2.6: The parameter was added. Return the last item of a sequence. Note: Does not work with generators. You may want to explicitly convert it to a list: Return the number of items in a container. Convert the value into a list. If it was a string the returned list will be a list of characters. Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it. The basic usage is mapping on an attribute. Imagine you have a list of users but you are only interested in a list of usernames: You can specify a value to use if an object in the list does not have the given attribute. Alternatively you can let it invoke a filter by passing the name of the filter and the arguments afterwards. A good example would be applying a text conversion filter on a sequence: Similar to a generator comprehension such as: Return the largest item from the sequence.\n• None attribute – Get the object with the max value of this attribute. Return the smallest item from the sequence.\n• None attribute – Get the object with the min value of this attribute. Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding. If no test is specified, each object will be evaluated as a boolean. Similar to a generator comprehension such as: Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding. If no test is specified, the attribute’s value will be evaluated as a boolean. Similar to a generator comprehension such as: Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument is given, only the first occurrences are replaced: Reverse the object or return an iterator that iterates over it the other way round. Round the number to a given precision. The first parameter specifies the precision (default is ), the second the rounding method:\n• None rounds either up or down If you don’t specify a method is used. Note that even if rounded to 0 precision, a float is returned. If you need a real integer, pipe it through : Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped. Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding. If no test is specified, each object will be evaluated as a boolean. Similar to a generator comprehension such as: Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding. If no test is specified, the attribute’s value will be evaluated as a boolean. Similar to a generator comprehension such as: Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns: If you pass it a second argument it’s used to fill missing values on the last iteration.\n• None attribute – When sorting objects or dicts, an attribute or key to sort by. Can use dot notation like . Can be a list of attributes like . The sort is stable, it does not change the relative order of elements that compare equal. This makes it is possible to chain sorts on different attributes and ordering. As a shortcut to chaining when the direction is the same for all attributes, pass a comma separate list of attributes. Changed in version 2.11.0: The parameter can be a comma separated list of attributes, e.g. . Changed in version 2.6: The parameter was added. Convert an object to a string if it isn’t already. This preserves a string rather than converting it back to a basic string, so it will still be marked as safe and won’t be escaped again. Strip SGML/XML tags and replace adjacent whitespace by one space. Returns the sum of a sequence of numbers plus the value of parameter ‘start’ (which defaults to 0). When the sequence is empty it returns start. It is also possible to sum up only certain attributes: Changed in version 2.6: The parameter was added to allow summing up over attributes. Also the parameter was moved on to the right. Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase. Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents. The returned string is safe to render in HTML documents and tags. The exception is in HTML attributes that are double quoted; either use single quotes or the filter.\n• None value – The object to serialize to JSON.\n• None indent – The parameter passed to , for pretty-printing the value. Return a truncated copy of the string. The length is specified with the first parameter which defaults to . If the second parameter is the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign ( ). If you want a different ellipsis sign than you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated. The default leeway on newer Jinja versions is 5 and was 0 before but can be reconfigured globally. Returns a list of unique items from the given iterable. The unique items are yielded in the same order as their first occurrence in the iterable passed to the filter.\n• None attribute – Filter objects with unique values for this attribute. Quote data for use in a URL path or query using UTF-8. Basic wrapper around when given a string, or for a dict or iterable. value – Data to quote. A string will be quoted directly. A dict or iterable of pairs will be joined as a query string. When given a string, “/” is not quoted. HTTP servers treat “/” and “%2F” equivalently in paths. If you need quoted slashes, use the filter. This may not recognize links in some situations. Usually, a more comprehensive formatter, such as a Markdown library, is a better choice. Works on , , , , and email addresses. Links with trailing punctuation (periods, commas, closing parentheses) and leading punctuation (opening parentheses) are recognized excluding the punctuation. Email addresses that include header fields are not recognized (for example, ).\n• None value – Original text containing URLs to link.\n• None extra_schemes – Recognize URLs that start with these schemes in addition to the default behavior. Defaults to , which defaults to no extra schemes. Changed in version 3.0: The parameter was added. Changed in version 3.0: Generate links for URLs without a scheme. Changed in version 3.0: The parsing rules were updated. Recognize email addresses with or without the scheme. Validate IP addresses. Ignore parentheses and brackets in more cases. Changed in version 2.8: The parameter was added. Count the words in that string. Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately.\n• None break_long_words – If a word is longer than , break it across lines.\n• None break_on_hyphens – If a word contains hyphens, it may be split across lines.\n• None wrapstring – String to join each wrapped line. Defaults to . Changed in version 2.11: Existing newlines are treated as paragraphs wrapped separately. Create an SGML/XML attribute string based on the items in a dict. Values that are neither nor are automatically escaped, safely allowing untrusted user input. User input should not be used as keys to this filter. If any key contains a space, solidus, greater-than sign, or equals sign, this fails with a . Regardless of this, user input should never be used as keys to this filter, or must be separately validated first. Results in something like this: As you can see it automatically prepends a space in front of the item if the filter returned something unless the second parameter is false. Changed in version 3.1.4: Keys with solidus, greater-than sign, or equals sign are not allowed. Changed in version 3.1.3: Keys with spaces are not allowed.\n\nThe following sections cover the built-in Jinja extensions that may be enabled by an application. An application could also provide further extensions not covered by this documentation; in which case there should be a separate document explaining said extensions. If the i18n Extension is enabled, it’s possible to mark text in the template as translatable. To mark a section as translatable, use a block: Inside the block, no statements are allowed, only text and simple variable tags. Variable tags can only be a name, not attribute access, filters, or other expressions. To use an expression, bind it to a name in the tag for use in the block. To bind more than one expression, separate each with a comma ( ). To pluralize, specify both the singular and plural forms separated by the tag. By default, the first variable in a block is used to determine whether to use singular or plural form. If that isn’t correct, specify the variable used for pluralizing as a parameter to . When translating blocks of text, whitespace and linebreaks result in hard to read and error-prone translation strings. To avoid this, a trans block can be marked as trimmed, which will replace all linebreaks and the whitespace surrounding them with a single space and remove leading and trailing whitespace. This results in This is %(book_title)s. You should read it! in the translation file. If trimming is enabled globally, the modifier can be used to disable it for a block. Added in version 2.10: The and modifiers have been added. If the translation depends on the context that the message appears in, the and functions take a string as the first argument, which is used to select the appropriate translation. To specify a context with the tag, provide a string as the first token after . Added in version 3.1: A context can be passed to the tag to use and . It’s possible to translate strings in expressions with these functions:\n• None : Like , but picks the translation based on the context string.\n• None : Like , but picks the translation based on the context string. You can print a translated string like this: To use placeholders, use the filter. Always use keyword arguments to , as other languages may not use the words in the same order. If New Style Gettext calls are activated, using placeholders is easier. Formatting is part of the call instead of using the filter. The function’s format string automatically receives the count as a parameter in addition to the given parameters. If the expression-statement extension is loaded, a tag called is available that works exactly like the regular variable expression ( ); except it doesn’t print anything. This can be used to modify lists: If the application enables the Loop Controls, it’s possible to use and in loops. When is reached, the loop is terminated; if is reached, the processing is stopped and continues with the next iteration. Here’s a loop that skips every second item: Likewise, a loop that stops processing after the 10th iteration: Note that starts with 1, and starts with 0 (See: For). If the Debug Extension is enabled, a tag will be available to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger. The with statement makes it possible to create a new inner scope. Variables set within this scope are not visible outside of the scope. foo is 42 here foo is not visible here any longer Because it is common to set variables at the beginning of the scope, you can do that within the statement. The following two examples are equivalent: An important note on scoping here. In Jinja versions before 2.9 the behavior of referencing one variable to another had some unintended consequences. In particular one variable could refer to another defined in the same with block’s opening statement. This caused issues with the cleaned up scoping behavior and has since been improved. In particular in newer Jinja versions the following code always refers to the variable from outside the block: In earlier Jinja versions the attribute would refer to the results of the first attribute. If you depend on this behavior you can rewrite it to use the tag: In older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default."
    },
    {
        "link": "https://lib.rs/template-engine",
        "document": ""
    }
]