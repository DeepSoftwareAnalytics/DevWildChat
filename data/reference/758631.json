[
    {
        "link": "https://medium.com/pythons-gurus/mastering-recursion-in-python-130a1895df16",
        "document": "Recursion is a fundamental concept in programming, where a function calls itself in order to solve a problem. It is an important tool for data professionals and developers, especially when dealing with problems that have a repetitive or hierarchical structure. Recursion helps in simplifying complex problems by breaking them down into smaller, more manageable sub-problems.\n\nIn Python, recursion is a powerful technique that allows a function to call itself either directly or indirectly. This approach can be particularly useful for tasks like traversing trees, implementing search algorithms, or solving mathematical problems like calculating factorials and Fibonacci sequences.\n\nHi all, my name is CyCoderX and in this article I will provide a detailed explanation of recursion, along with examples and best practices for implementing recursive functions in Python.\n\nRecursion is a method where a function solves a problem by breaking it down into smaller instances of the same problem, which are then solved individually. To ensure that a recursive function doesn’t run infinitely, each recursive call works towards reaching a base case — a condition that stops the recursion from continuing.\n\nWhen a recursive function is called, it keeps breaking down the problem into smaller sub-problems. Each function call is placed on something called the call stack, and the function waits for the smaller sub-problem to return a result before proceeding.\n\nThe key to writing a recursive function is to:\n• Identify the base case: This is the condition where the problem is simple enough to be solved directly, without further recursive calls. The base case stops the recursion.\n• Define the recursive case: This is where the function calls itself to solve smaller sub-problems.\n\nOnce the base case is reached, the results are returned back up the call stack, with each function call completing its task and returning the final result.\n\nA classic example of recursion is calculating the factorial of a number. The factorial of a non-negative integer is the product of all integers less than or equal to . Using recursion, we can break this problem into a smaller one by calculating the factorial of until we reach the base case (when is 1 or 0).\n\nHere’s an example in Python:\n\nIn this example, the recursive case is , and the base case is when is 0 or 1, where the recursion stops.\n\nKeep in mind, there are various ways to write a factorial function in Python. This example is just to illustrate the concept. You can also simply import the factorial function from the math module.\n\nRecursion offers several advantages, especially in scenarios where the problem can naturally be divided into smaller sub-problems. Let’s explore some of the key benefits of using recursion:\n\nRecursion can simplify the implementation of complex problems by allowing you to break them down into smaller, more manageable parts. For example, problems like traversing trees or graphs can be implemented more elegantly using recursion, as it closely resembles the natural structure of these problems.\n\nConsider a problem where you need to traverse a directory structure (which resembles a tree). Each directory can contain files or subdirectories. Recursively visiting each subdirectory makes this problem much simpler:\n\nIn this example, the function recursively visits all subdirectories and prints the full path of each file. The problem becomes much easier to solve because recursion aligns naturally with the structure of the directory tree.\n\nRecursive solutions are often more concise and cleaner than their iterative counterparts. While an iterative approach might require managing a loop and keeping track of additional variables, recursion allows the problem to be solved in a more straightforward and elegant manner. This results in code that is often easier to read and maintain.\n\nMany algorithms, such as merge sort, quicksort, and binary search, follow the divide-and-conquer strategy, where a problem is divided into smaller sub-problems that are solved independently and then combined. Recursion is a natural fit for these algorithms, as it allows you to repeatedly break down the problem until it is simple enough to solve directly.\n\nFor example, consider the merge sort algorithm, which recursively divides the list into smaller sub-lists, sorts each sub-list, and then merges them back together:\n\nIn this example, the function divides the list into two halves, recursively sorts each half, and then merges them back together. Recursion makes it easy to break the problem down until the base case (when the list has one or no elements) is reached.\n\nWhile recursion is a powerful tool, it does come with certain trade-offs. In some cases, an iterative solution might be more efficient and practical than a recursive one. Here are some of the common disadvantages of recursion:\n\nEvery time a recursive function is called, a new frame is added to the call stack. This means that recursion can consume more memory and time than an iterative solution, particularly when the recursion depth becomes significant. Each recursive call involves overhead for maintaining the call stack, which can result in slower performance compared to an iterative loop.\n\nIn Python, this is particularly important to consider because Python’s default recursion depth is limited (usually to around 1000 calls). If the recursion depth exceeds this limit, you may encounter a .\n\nHere’s an example of recursion exceeding the depth limit:\n\nThe Python interpreter limits the depth of recursion to avoid running out of memory. For large problems, recursion may not always be the best approach due to this performance limitation.\n\nIf the recursion depth becomes too deep, you might run into a stack overflow error. This happens when the program exhausts the memory allocated for the call stack due to too many recursive calls. As mentioned earlier, Python raises a when this happens, but in other programming environments, this could crash the program entirely.\n\nFor example, consider calculating the Fibonacci sequence recursively. If we calculate the nth Fibonacci number using recursion without any optimization, the number of recursive calls grows exponentially, leading to performance degradation or a potential stack overflow:\n\nIn this case, for larger values of , the number of function calls becomes excessively large. This is because each call to makes two additional recursive calls to and . Without any form of optimization, this can cause performance issues.\n\nRecursive functions can be harder to debug than iterative functions, especially for beginners. It can be challenging to keep track of how many recursive calls have been made and what the state of each call is at any given point. This is especially true for problems where recursion depth is deep, or the base case is not clearly defined. Errors like missing a base case or making incorrect recursive calls can be difficult to trace.\n\nConsider the following recursive implementation of a function to calculate the sum of integers in a list:\n\nIf a mistake is made (for example, if the base case is incorrect or omitted), the program can end up in an infinite loop of recursive calls, which might be difficult to debug, particularly in complex problems.\n\nWhen to Use Recursion\n\nRecursion is best used when a problem can naturally be divided into smaller, similar sub-problems. Here are some scenarios where recursion is often the preferred approach:\n• Tree Traversals: Recursion is often the easiest way to traverse data structures like trees. For example, in-order, pre-order, and post-order tree traversal algorithms are naturally recursive.\n• Divide-and-Conquer Algorithms: Algorithms like quicksort and merge sort use recursion to divide the problem into smaller sub-problems.\n• Solving Puzzles: Problems like the Tower of Hanoi or generating permutations and combinations are often best solved using recursion.\n• Graphs: Recursion is commonly used in graph traversal algorithms, such as depth-first search (DFS).\n\nOn the other hand, when performance is a major concern, or when dealing with a problem that requires many repetitive recursive calls, an iterative solution might be more efficient.\n\nBest Practices for Using Recursion in Python\n\nWhen working with recursion in Python, it’s essential to follow best practices to write efficient, readable, and maintainable code. Here are some guidelines to help you effectively utilize recursion:\n\nEnsure that your base cases are well-defined and easily reachable. A clear base case is crucial for preventing infinite recursion and ensuring that the function eventually terminates. Take time to think through your base case and how your recursive calls will lead to it.\n\nIn this example, the base case is when is less than or equal to 0, ensuring that the recursion terminates.\n\nTail recursion is a form of recursion where the recursive call is the last operation in the function. Although Python does not optimize tail recursion like some other languages (such as Scheme), being aware of this can help you write clearer recursive functions.\n\nWhile Python won’t optimize tail calls, writing functions this way can help you think about how to manage state across recursive calls.\n\nFor problems that involve repeated calculations (like the Fibonacci sequence), consider using memoization. This technique involves caching the results of expensive function calls and returning the cached result when the same inputs occur again. This can greatly improve performance for recursive functions.\n\nIn this example, we use a dictionary to cache results, significantly reducing the time complexity.\n\nBe aware of the recursion depth in Python. You can use the module to check and set the maximum recursion depth. If you expect deep recursion, consider refactoring to an iterative solution or increasing the recursion limit using . However, use this with caution, as it can lead to stack overflow.\n\nTesting and debugging recursive functions can be more complex than iterative ones. Use print statements or a debugger to track the flow of function calls and variable values. Write unit tests to ensure that your base cases and recursive cases work as expected.\n\nRecursion is a powerful tool in Python that allows developers to solve complex problems through elegant and straightforward code. While it has its advantages, such as simplifying problem-solving and providing clear solutions, it’s essential to be mindful of its limitations, including performance overhead and stack depth.\n\nBy understanding when to use recursion and following best practices, data professionals can leverage recursion effectively in their projects. Whether traversing data structures, implementing algorithms, or solving mathematical problems, recursion remains an indispensable technique in a developer’s toolkit.\n\nThank you for reading, and happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/61618265/how-to-make-my-factorial-function-faster-and-efficient",
        "document": "this is college project and i think professor's intention is making a faster, efficient factorial function using list like 1000!\n\nbut my code is slow and when number > 997\n\ni got error like this\n\ni do not know why my code error when number > 997"
    },
    {
        "link": "https://stackoverflow.com/questions/74193164/how-can-i-make-my-recursion-program-to-output-factorial-of-a-number-more-efficie",
        "document": "I have made a program which outputs the factorial of a number by calling the function: factorial() which uses recursion to calculate and return the value. I have also included a loop to break the program when the User inputs the word \"off\". Please suggest any improvements\n\nHere is the code:\n\nHere is the terminal:"
    },
    {
        "link": "https://diveintopython.org/learn/functions/recursion",
        "document": "Recursive programming is a technique in programming where a function calls itself repeatedly until it reaches a base or terminal case. It is a powerful tool when dealing with certain types of problems that can be naturally defined in a recursive manner. In Python, we can implement this technique through recursive functions.\n\nRecursive functions are functions that call themselves during execution to solve a problem by breaking it down into smaller sub-problems. Recursion in Python involves two main steps: defining the base case(s) and the recursive case(s).\n\nIn this example, the function takes an integer as input and recursively calculates the factorial of by multiplying it with the factorial of . The base case is when is equal to , in which case the function returns .\n\nIn this example, the function takes an integer as input and recursively calculates the term of the Fibonacci series by adding the previous two terms. The base case is when is or , in which case the function returns . The driver code prints the first of the Fibonacci series, where is a user-inputted value.\n\nTips and Best Practices for Python Recursive Programming\n• Clearly define the base case: The base case is the condition under which the function should stop calling itself recursively and return a value. Make sure that the base case is clearly defined and that the function eventually reaches it to avoid infinite recursion.\n• Watch out for recursion depth: Recursion depth refers to the number of times a function calls itself recursively. Python has a default recursion depth limit of 1000, so make sure to keep your recursive functions within the limit or adjust the recursion depth limit using the sys module.\n• Consider using memoization: Memoization is a technique used to cache the results of expensive function calls and reuse them when the same inputs occur again. This can significantly improve the performance of recursive functions in Python by avoiding duplicate computations.\n• Test and debug carefully: Recursive functions can be difficult to debug due to their complex nature. Make sure to test your function with various input values and take time to understand how it works before deploying it to production.\n\nThis recursive function performs binary search on a sorted array by calling itself with smaller subarrays until it finds the target or reaches the base case where the low index is greater than the high index.\n\nPython recursive functions can be a powerful tool in solving complex problems, but they can also be prone to common mistakes and pitfalls. Here are some common mistakes to avoid when using Python recursion:\n• Infinite loops: It is easy to create infinite loops in recursive functions if you don't have a base case that ultimately breaks the recursion. Be sure to define a base case that will stop the recursion.\n• Stack overflow: Recursion can create a lot of memory overhead, which can lead to stack overflow errors. Be careful when using recursion with large datasets.\n\nRecursive enhancing refers to the process of optimizing a Python recursive function for better efficiency and performance. This involves identifying areas that can be fine-tuned, such as reducing space complexity or using memoization to reduce the number of recursive calls.\n\nBelow are two examples of how to enhance Python recursive functions for greater efficiency:\n\nMemoization is the process of storing previously computed results to avoid repeated calculation. This can significantly reduce the runtime of a recursive function.\n\nIn the above code, the dictionary is used to store previously computed Fibonacci numbers. When the function is called with a previously calculated , the value is returned instead of the function making another recursive call.\n\nTail recursion optimization is a way to optimize recursive functions so that they use less space on the call stack.\n\nIn the above code, is a recursive function that calculates the sum of all numbers from to . The acc argument is an accumulator that stores the intermediate results of the computation.\n\nIn each recursive call, the function adds the current value of to the accumulator and passes the result to the next recursive call, without keeping the previous call's stack frame in memory. This way, the function uses a constant amount of memory on the call stack, and avoids the risk of stack overflow for large values of ."
    },
    {
        "link": "https://reddit.com/r/Python/comments/seeitc/are_recursive_functions_in_python_efficient",
        "document": "The official Python community for Reddit! Stay up to date with the latest news, packages, and meta information relating to the Python programming language. --- If you have questions or are new to Python use r/LearnPython"
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://geeksforgeeks.org/python-math-factorial-function",
        "document": ""
    },
    {
        "link": "https://w3schools.com/python/ref_math_factorial.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://w3schools.com/python/module_math.asp",
        "document": "Python has a built-in module that you can use for mathematical tasks.\n\nThe module has a set of methods and constants."
    },
    {
        "link": "https://geeksforgeeks.org/factorial-in-python",
        "document": "Not many people know, but python offers a direct function that can compute the factorial of a number without writing the whole code for computing factorial.\n\nThis method is defined in “math” module of python. Because it has C type internal implementation, it is fast.\n\nmath.factorial(x)\n\nParameters :\n\nx : The number whose factorial has to be computed. \n\nReturn value :\n\n \n\nExceptions : \n\n Raises Value error if number is negative or non-integral.\n• If given number is Negative :\n• If given number is Non – Integral Value :"
    }
]