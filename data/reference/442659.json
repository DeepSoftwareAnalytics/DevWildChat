[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in",
        "document": "The loop will iterate over all enumerable properties of the object itself and those the object inherits from its prototype chain (properties of nearer prototypes take precedence over those of prototypes further away from the object in its prototype chain).\n\nLike other looping statements, you can use control flow statements inside :\n• stops execution and goes to the first statement after the loop.\n• stops execution and goes to the next iteration of the loop.\n\nA loop only iterates over enumerable, non-symbol properties. Objects created from built–in constructors like and have inherited non–enumerable properties from and , such as 's method or 's method, which will not be visited in the loop.\n\nThe traversal order, as of modern ECMAScript specification, is well-defined and consistent across implementations. Within each component of the prototype chain, all non-negative integer keys (those that can be array indices) will be traversed first in ascending order by value, then other string keys in ascending chronological order of property creation.\n\nThe part of accepts anything that can come before the operator. You can use to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use . You can use destructuring to assign multiple local variables, or use a property accessor like to assign the value to an object property.\n\nA legacy syntax allows declarations of the loop variable to have an initializer. This throws a syntax error in strict mode and is ignored in non–strict mode."
    },
    {
        "link": "https://stackoverflow.com/questions/8312459/iterate-through-object-properties",
        "document": "How does the variable propt represent the properties of the object? It's not a built-in method or property. Why does it come up with every property in the object?\n\nfor (var prop in obj) { if (Object.prototype.hasOwnProperty.call(obj, prop)) { // do stuff } } It's necessary because an object's prototype contains additional properties for the object which are technically part of the object. These additional properties are inherited from the base object class, but are still properties of . simply checks to see if this is a property specific to this class, and not one inherited from the base class. It's also possible to call through the object itself: But this will fail if the object has an unrelated field with the same name: That's why it's safer to call it through instead:\n\nif (typeof obj === 'object' && obj !== null) { Object.keys(obj).forEach(key => { console.log(\"\n\n\" + key + \": \" + obj[key]); }); } // *** Explanation line by line *** // Explaining the bellow line // It checks if obj is neither null nor undefined, which means it's safe to get its keys. // Otherwise it will give you a \"TypeError: Cannot convert undefined or null to object\" if obj is null or undefined when it tries to get its keys in the next line of code. // NOTE 1: You can use Object.hasOwnProperty() instead of Object.keys(obj).length // NOTE 2: No need to check if obj is an array because it will work just fine. // NOTE 3: No need to check if obj is a string because it will not pass the 'if typeof obj is Object' statement. // NOTE 4: No need to check if Obj is undefined because it will not pass the 'if type obj is Object' statement either. if (typeof obj === 'object' && obj !== null) { // Explaining the bellow line // Just like in the previous line, this returns an array with // all keys in obj (because if code execution got here, it means // obj has keys.) // Then just invoke built-in javascript forEach() to loop // over each key in returned array and calls a call back function // on each array element (key), using ES6 arrow function (=>) // Or you can just use a normal function ((key) { blah blah }). Object.keys(obj).forEach(key => { // The bellow line prints out all keys with their // respective value in obj. // key comes from the returned array in Object.keys(obj) // obj[key] returns the value of key in obj console.log(\"\n\n\" + key + \": \" + obj[key]); }); }\n\nThe for...in loop represents each property in an object because it is just like a for loop. You defined propt in the for...in loop by doing: A for...in loop iterates through the enumerable properties of an object. Whichever variable you define, or put in the for...in loop, changes each time it goes to the next property it iterates. The variable in the for...in loop iterates through the keys, but the value of it is the key's value. For example: You can see how the variable differs from the variable's value. In contrast, a for...of loop does the opposite.\n\nTo add ES2015's usage of and also iterating over the properties via an iterator. If you would like to iterate directly over the values of the keys of an object, you can define an , just like JavaScipts's default iterators for strings, arrays, typed arrays, Map and Set. JS will attempt to iterate via the default iterator property, which must be defined as . If you want to be able to iterate over all objects you can add it as a prototype of Object: This would enable you to iterate over the values of an object with a for...of loop, for example: Caution: As of writing this answer (June 2018) all other browsers, but IE, support generators and iteration via\n\nThe above answers are a bit annoying because they don't explain what you do inside the for loop after you ensure it's an object: YOU DON'T ACCESS IT DIRECTLY! You are actually only delivered the KEY that you need to apply to the OBJ: var obj = { a: \"foo\", b: \"bar\", c: \"foobar\" }; // We need to iterate the string keys (not the objects) for(var someKey in obj) { // We check if this key exists in the obj if (obj.hasOwnProperty(someKey)) { // someKey is only the KEY (string)! Use it to get the obj: var myActualPropFromObj = obj[someKey]; // Since dynamic, use [] since the key isn't literally named \"someKey\" // NOW you can treat it like an obj var shouldBeBar = myActualPropFromObj.b; } } This is all ECMA5 safe. Even works in the lame JS versions like Rhino ;)\n\nI want to add to the answers above, because you might have different intentions from Javascript. A JSON object and a Javascript object are different things, and you might want to iterate through the properties of a JSON object using the solutions proposed above, and then be surprised. Suppose that you have a JSON object like: The wrong way to iterate through its 'properties': You might be surprised of seeing the console logging , , etc. when iterating through the properties of and and of . Those objects are sequences, and the indexes of a sequence are properties of that object in Javascript. A better way to recursively iterate through a JSON object properties would be to first check if that object is a sequence or not: function recursivelyIterateProperties(jsonObject) { for (var prop in Object.keys(example)) { console.log(prop); if (!(typeof(jsonObject[prop]) === 'string') && !(jsonObject[prop] instanceof Array)) { recursivelyIterateProperties(jsonObject[prop]); } } }"
    },
    {
        "link": "https://stackoverflow.com/questions/1573593/whats-the-fastest-way-to-iterate-over-an-objects-properties-in-javascript",
        "document": "As it turns out, this is the approach that, under the hood, makes ajv the fastest JSON validator library.\n\nAlso - someone took my idea to the next level, and used it to speed up \"summing over an object's properties\" by over 100x across the browser spectrum - find his jsperf here:\n\nThe pink bar represents his \"pre-compiled sum\" approach which just leaves all the other approaches and operations in the dust.\n\nWhat is the trick?\n\nUsing the pre-compiled sum approach, he used my code to automatically generate this code:\n\nwhich is way faster than this:\n\n...especially if the order in which we access the properties ( , , ) matches the order in 's hidden class.\n\nLet me start by saying, loops are just fine, and you only want to think of this in performance-critical code with a lot of CPU and RAM usage. Usually, there is more important stuff you should spend your time on. However, if you are a performance-freak, you might be interested in this near-perfect alternative:\n\nGenerally, there are two use-cases for JS objects:\n• \"Dictionaries\", a.k.a \"associative arrays\" are general containers with a varying set of properties, indexed by string keys.\n• \"Objects of constant type\" (for which the so-called hidden class is always the same) have a fixed set of properties of fixed order. Yes! - While the standard does not guarantee any order, modern VM implementations all do have a (hidden) order, to speed things up. It will be crucial to always maintain that order, as we explore later.\n\nUsing \"objects of constant type\" instead of \"dictionary types\" is generally a whole lot faster because the optimizer understands the structure of these objects. If you are curious as to how to achieve that, you might want to check out Vyacheslav Egorov's blog which sheds a whole lot of light on how V8 but also other Javascript run-times, work with objects. Vyacheslav explains Javascript's object property look-up implementation in this blog entry.\n\nThe default is certainly an Ok choice to iterate over all properties of objects. However, might treat your object as a dictionary with string keys, even if it has a hidden type. In that case, in every iteration you have the overhead of a dictionary lookup, which is often implemented as a hashtable lookup. In many cases, the optimizer is smart enough to avoid that, and performance is on par with constant naming of your properties, but it is simply not guaranteed. Often enough, the optimizer can't help you, and your loop will run a whole lot slower than it should. The worst thing is though that sometimes that is unavoidable, especially if your loop gets more complex. Optimizers are just not that smart (yet!). The following pseudocode describes how works in slow mode:\n\nAn unrolled, un-optimized loop, looping over an object with three properties ['a', 'b', 'c'] of given order, looks like this:\n\nAssuming that you cannot optimize , Amdahl's law tells us that you can gain a lot of performance if and only if:\n• is very fast already (when compared to the cost of the dictionary lookup) and\n• you can actually get rid of that dictionary lookup overhead.\n\nWe can indeed get rid of that lookup using, what I call, a pre-compiled iterator, a dedicated function that iterates over all objects of a fixed type, i.e. a type with a fixed set of properties of fixed order, and performing a specific operation on all of them. That iterator explicitly calls a callback (let's call it ) on each of your properties by their proper name. As a result, the run-time can always make use of the type's hidden class, without having to rely on promises by the optimizer. The following pseudocode describes how the pre-compiled iterator works for any object with the three properties in given order:\n\nThere is no overhead. We don't need to look anything up. The compiler already can trivially compute the exact memory address of each of the properties, using the hidden type information, and it even uses the most cache-friendly order of iteration. This is also (very very close to) the fastest code you can get with and a perfect optimizer.\n\nThis jsperf shows that the the pre-compiled iterator approach is quite a bit faster than the standard loop. Note though that the speed-up largely depends on how the object is created and on the complexity of the loop. Since this test only has very simple loops, you sometimes might not observe much of a speed-up. However, in some of my own tests, I was able to see a 25x speed-up of the pre-compiled iterator; or rather a significant slow-down of the loop, because the optimizer was not able to get rid of the string-lookups.\n\nWith more tests coming in, we can draw some first conclusions on different optimizer implementations:\n• The pre-compiled iterator is generally performing a whole lot better, even in very simple loops.\n• In IE, the two approaches show the least variance. Bravo Microsoft for writing a decent iteration optimizer (at least for this particular problem)!\n• In Firefox, is the slowest by a huge margin. The iteration optimizer does not do a good job over there.\n\nHowever, the tests have a very simple loop body. I am still looking for a test case where the optimizer can never achieve constant indexing, across all (or almost all) browsers. Any suggestions are very welcome!\n\nThe following function pre-compiles an iterator for any type of (simple) object (disregarding nested properties, for now). The iterator needs a bit of extra information, representing the exact type of all objects it should iterate over. Such type information can generally be represented as an array of string property names, of the exact order, which the function takes to create a convenient type object. If you want to see a more complete example, refer to the jsperf entry.\n\nAnd here is how we use it:"
    },
    {
        "link": "https://index.dev/blog/javascript-object-iteration-methods",
        "document": "Discover 10 ways to efficiently loop through JavaScript objects, with examples and tips for when to use each method.\n\nIn JavaScript, objects are necessary for key-value pair storage. Iterating through objects is typically necessary, regardless of whether you're developing a basic application or working with intricate data from an API. In JavaScript, there are several approaches to accomplish this, and each has pros and cons of its own.\n\nWe will look at ten distinct JavaScript methods for iterating over an object in this article. For every technique, we'll offer special instances and go over when to use them.\n\nPut your object mastery to work. Join Index.dev for long-term JavaScript remote opportunities.\n\nOne of the easiest methods for iterating over an object's attributes is to use a It runs over every property that may be listed for the object, including those that are passed down from its prototype chain.\n• None Iterates over inherited properties. If you want to ignore those, you have to add a check using\n\nAn array with the names of an object's own properties is returned by . This array may be looped through using forEach().\n• None It only iterates over the object’s own properties, ignoring the prototype properties.\n• None Cleaner and more modern than\n• None Slightly less intuitive for beginners because it involves array methods.\n\nUse if the values are all that matter to you and the keys are not. An array containing the values of the object's properties is returned by this function.\n• None Simple when you only need the values.\n• None No access to the keys.\n\nAn array of the key-value pairs for the object is returned by . The key and the associated value are the two elements that make up each element in this array.\n• None You get both keys and values in a very clean way.\n• None Great for destructuring the key-value pair in a single line.\n• None Slightly more complex compared to other methods.\n\nis one of the simplest methods to loop through an array of items.\n• None Simple syntax and widely understood by most developers.\n• None Useful for arrays of objects.\n• None Limited to arrays. If you're working with a single object, you can't use this directly.\n\nArrays, strings, and maps are examples of iterable objects that can be iterated over using the . You must first transform the item into an iterable structure, such as an array, in order to utilize it with it.\n• None Allows easy destructuring within the loop.\n• None Only works with iterable objects. You have to use to convert the object first.\n\nUsually, arrays are iterated over using the , which returns a new array with the data altered. When you need to convert or return a new array from an array of objects, you may use it.\n• None Returns a new array, which can be useful for chaining other array methods.\n\nEvery element of the array is subjected to a reducer function using the , which produces a single output value. It's a little more intricate, but it has great data aggregation capabilities.\n• None Useful for aggregating data into a single result.\n• None Can be less intuitive than other methods.\n\nAn array containing every property of an object, including non-enumerable properties, is returned by . If you need to access secret properties, it could be helpful.\n• None Useful when dealing with hidden object properties.\n\nyields an object's whole set of properties, including symbol-based and non-enumerable ones. When working with symbols or hidden attributes, it is helpful.\n• None Can access both string and symbol keys.\n\nExplore More: How to Migrate from Vue to React App: A Strategic Guide\n\nThere are several methods for iterating through objects in JavaScript, each with unique benefits and use cases. There is a way for any situation, whether it is basic key-value pairs, arrays of objects, or even objects with hidden characteristics. For more complex situations, techniques like Reflect.ownKeys() or Object.entries() provide more flexibility, but for simpler jobs, for...in or Object.keys() can be sufficient.\n\nTry using these techniques on your own projects to see which ones suit your needs the best!\n\nFor Developers: Level up your JavaScript skills and explore global remote opportunities— !\n\nFor Clients: Join Index.dev to access and build a high-performing tech team today with no platform fees!"
    },
    {
        "link": "https://freecodecamp.org/news/how-to-iterate-over-objects-in-javascript",
        "document": "In JavaScript, when you hear the term \"loop\", you probably think of using the various loop methods like loops, , and others.\n\nBut in the case of objects, unfortunately, these methods don't work because objects are not iterable.\n\nThis doesn't mean we can't loop through an object – but this means that we can't loop through an object directly the same way we do for an array:\n\nIn this article, You'll learn how you can loop through an object in JavaScript. There are two methods you can use - and one of them pre-dates the introduction of ES6.\n\nHow to loop through an object in JavaScript with a loop\n\nBefore ES6, we relied on the method whenever we wanted to loop through an object.\n\nThe loop iterates through properties in the prototype chain. This means that we need to check if the property belongs to the object using whenever we loop through an object with the loop:\n\nTo avoid the stress and difficulty of looping and to use the method, ES6 and ES8 introduced object static methods. These convert object properties to arrays, allowing us to use array methods directly.\n\nHow to loop through an object in JavaScript with object static methods\n\nAn object is made up of properties that have key-value pairs, that is each property always has a corresponding value.\n\nObject static methods let us extract either , , or both keys and values as in an array, allowing us to have as much flexibility over them as we do with actual arrays.\n\nWe have three object static methods, which are:\n\nHow to loop through an object in JavaScript with the method\n\nThe method was introduced in ES6. It takes the object we want to loop over as an argument and returns an array containing all property names (also known as keys).\n\nThis now gives us the advantage of applying any array looping method to iterate through the array and retrieve the value of each property:\n\nWe can also use the key to get the value using bracket notation such as as seen below:\n\nBefore we move on, let's use this method to sum all the population by looping through so we know the total population:\n\nHow to loop through an object in JavaScript with the method\n\nThe method is very similar to the method and was introduced in ES8. This method takes the Object we want to loop over as an argument and returns an array containing all key values.\n\nThis now gives us the advantage of applying any array looping method to iterate through the array and retrieve the of each property:\n\nWe can efficiently perform the total calculation since we can loop through directly:\n\nHow to loop through an object in JavaScript with the Object.entries() method\n\nThe method was also introduced with ES8. In the basic sense, what it does is that it outputs an array of arrays, whereby each inner array has two elements which are the property and the value.\n\nThis returns an array of arrays, with each inner array having the . You can use any array method to loop through:\n\nWe could decide to destructure the array, so we get the and value:\n\nYou can learn more about how to loop through arrays in this article.\n\nIn this tutorial, you learned that the best way to loop through an object is to use any object static method based on your needs to first convert to an array before looping.\n\nEmbark on a journey of learning! Browse 200+ expert articles on web development. Check out my blog for more captivating content from me."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
        "document": "The method returns if the specified property is a direct property of the object — even if the value is or . The method returns if the property is inherited, or has not been declared at all. Unlike the operator, this method does not check for the specified property in the object's prototype chain.\n\nThe method can be called on most JavaScript objects, because most objects descend from , and hence inherit its methods. For example is an , so you can use method to check whether an index exists:\n\nThe method will not be available in objects where it is reimplemented, or on -prototype objects (as these don't inherit from ). Examples for these cases are given below."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-object-hasownproperty-method",
        "document": "The hasOwnProperty() method in JavaScript checks if an object has a specific property as its own (not inherited). It returns true if the property exists directly on the object, otherwise false, making it useful for distinguishing own properties from inherited ones.\n• prop: It holds the name in the form of a String or a Symbol of the property to test.\n\nIt returns a Boolean value indicating whether the object has the given property as its own property.\n\nExample 1: In this example, the hasOwnProperty() method checks if the exampleObj contains the properties “height” (which exists) and “breadth” (which doesn’t exist). It returns true for “height” and false for “breadth”.\n\nExample 2: In this example The checkProperty() function creates a Car object and checks if the model property exists (true) and if the wheels property doesn’t exist (false) using the hasOwnProperty() method.\n\nWe have a complete list of Object methods, and properties to check those please go through this JavaScript Object Complete Reference article.\n\nWhat is hasOwnProperty() in JavaScript Object?\n\nHow does the hasOwnProperty() method work?\n\nWhat will happen if hasOwnProperty() is called on null or undefined?\n\nHow does the hasOwnProperty() method handle non-string properties?\n\nWhat are some common use cases for the hasOwnProperty() method?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn",
        "document": "The static method returns if the specified object has the indicated property as its own property. If the property is inherited, or does not exist, the method returns . Note: is intended as a replacement for .\n\nThe method returns if the specified property is a direct property of the object — even if the property value is or . The method returns if the property is inherited, or has not been declared at all. Unlike the operator, this method does not check for the specified property in the object's prototype chain. It is recommended over because it works for -prototype objects and with objects that have overridden the inherited method. While it is possible to workaround these problems by calling on an external object, is more intuitive.\n\nUsing hasOwn to test for a property's existence The following code shows how to determine whether the object contains a property named . const example = {}; Object.hasOwn(example, \"prop\"); // false - 'prop' has not been defined example.prop = \"exists\"; Object.hasOwn(example, \"prop\"); // true - 'prop' has been defined example.prop = null; Object.hasOwn(example, \"prop\"); // true - own property exists with value of null example.prop = undefined; Object.hasOwn(example, \"prop\"); // true - own property exists with value of undefined\n\nThe following example differentiates between direct properties and properties inherited through the prototype chain: const example = {}; example.prop = \"exists\"; // `hasOwn` will only return true for direct properties: Object.hasOwn(example, \"prop\"); // true Object.hasOwn(example, \"toString\"); // false Object.hasOwn(example, \"hasOwnProperty\"); // false // The `in` operator will return true for direct or inherited properties: \"prop\" in example; // true \"toString\" in example; // true \"hasOwnProperty\" in example; // true\n\nIterating over the properties of an object To iterate over the enumerable properties of an object, you should use: const example = { foo: true, bar: true }; for (const name of Object.keys(example)) { // … } But if you need to use , you can use to skip the inherited properties: const example = { foo: true, bar: true }; for (const name in example) { if (Object.hasOwn(example, name)) { // … } }\n\nThis section demonstrates that is immune to the problems that affect . Firstly, it can be used with objects that have reimplemented : const foo = { hasOwnProperty() { return false; }, bar: \"The dragons be out of office\", }; if (Object.hasOwn(foo, \"bar\")) { console.log(foo.bar); // true - re-implementation of hasOwnProperty() does not affect Object } It can also be used with -prototype objects. These do not inherit from , and so is inaccessible. const foo = Object.create(null); foo.prop = \"exists\"; if (Object.hasOwn(foo, \"prop\")) { console.log(foo.prop); // true - works irrespective of how the object is created. }"
    },
    {
        "link": "https://stackoverflow.com/questions/9396569/how-and-why-use-hasownproperty-in-javascript",
        "document": "What is a property in this case?\n\nWhy can't we simply use someVar.someProperty to check if an object someVar contains property with name someProperty ?\n\nWhat is the right use/explanation of hasOwnProperty('someProperty') ?\n\nreturns a boolean value indicating whether the object on which you are calling it has a property with the name of the argument. For example: However, it does not look at the prototype chain of the object. It's useful to use it when you enumerate the properties of an object with the construct. If you want to see the full details, the ES5 specification is, as always, a good place to look.\n\nHere is a short and precise answer: In JavaScript, every object has a bunch of built-in key-value pairs that have meta information about the object. When you loop through all the key-value pairs using construct/loop for an object you're looping through this meta-information key-value pairs too (which you definitely don't want). Using filters-out these unnecessary looping through meta information and directly checks that is the parameter is a user-given property in the object or not. By filters-out, I mean, that does not look if, exists in Object's prototype chain aka meta information. It returns boolean based on that. var fruitObject = {\"name\": \"Apple\", \"shape\": \"round\", \"taste\": \"sweet\"}; console.log(fruitObject.hasOwnProperty(\"name\")); //true console.log(Object.prototype.hasOwnProperty(\"toString\")) // true because in above snapshot you can see, that there is a function toString in meta-information\n\nis a function which can be called on any object and takes a string as an input. It returns a boolean which is if the property is located on the object, otherwise it returns false. is located on and thus available for any object. function Person(name) { this.name = name; } Person.prototype.age = 25; const willem = new Person('willem'); console.log(willem.name); // Property found on object console.log(willem.age); // Property found on prototype console.log(willem.hasOwnProperty('name')); // 'name' is on the object itself console.log(willem.hasOwnProperty('age')); // 'age' is not on the object itself In this example a new Person object is created. Each Person has its own name which gets initialized in the constructor. However, the age is not located on the object but on the prototype of the object. Therefore does return for name and for age. can be very useful when looping over an object using a loop. You can check with it if the properties are from the object itself and not the prototype. For example: function Person(name, city) { this.name = name; this.city = city; } Person.prototype.age = 25; const willem = new Person('Willem', 'Groningen'); for (let trait in willem) { console.log(trait, willem[trait]); // This loops through all properties, including the prototype } console.log('\n\n'); for (let trait in willem) { if (willem.hasOwnProperty(trait)) { // This loops only through 'own' properties of the object console.log(trait, willem[trait]); } }\n\nYou use object.hasOwnProperty(p) to determine if an object has an enumerable property p- An object can have its own prototype, where 'default' methods and attributes are assigned to every instance of the object. hasOwnProperty returns true only for the properties that were specifically set in the constructor, or added to the instance later. To determine if p is defined at all, anywhere, for the object, use if(p instanceof object), where p evaluates to a property-name string. For example, by default all objects have a 'toString' method, but it will not show up in hasOwnProperty.\n\nAs other answers indicated, will check for an object own properties in contrast to which will also check for inherited properties. There is a new alternative method called and is intended to be a replacement for is a static method which returns true if the specified object has the specified property as its own property. If the property is inherited, or does not exist, the method returns false. It is recommended to this method use over the because it also works for objects created by using and for objects that have overridden the inherited method. Although it's possible to solve these kind of problems by calling on an external object, overcome these problems, hence is preferred (see examples below) let person = { hasOwnProperty: function() { return false; }, age: 35 }; if (Object.hasOwn(person, 'age')) { console.log(person.age); // true - the remplementation of hasOwnProperty() did not affect the Object } let person = Object.create(null); person.age = 35; if (Object.hasOwn(person, 'age')) { console.log(person.age); // true - works regardless of how the object was created } More about can be found here : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\n\nWhat is the right use/explanation of hasOwnProperty('someProperty') ? The method returns a indicating whether the object has the specified property as its own property (as opposed to inheriting it). Why can't we simply use someVar.someProperty to check if an object someVar contains property with name someProperty ? will return the property value, You can not check that this property is available in the object or not via . Now in ES2022, A new method has been introduced which is this method is intended as a replacement for which overcome some limitations of ."
    },
    {
        "link": "https://docs.vultr.com/javascript/standard-library/Object/hasOwnProperty",
        "document": "The method in JavaScript is an essential function for checking whether an object contains a property as its own (not inherited from the prototype chain). This method is critical in ensuring that the properties you work with are indeed part of the object you're dealing with and not derived from its prototype. This provides a safer and more controlled handling of objects in your code.\n\nIn this article, you will learn how to use the method effectively across various scenarios. Explore how to verify the existence of properties directly within an object, thus differentiating them from those inherited through the prototype chain.\n• None Use to determine if a specific property exists as a direct property of the object. This example checks whether the object has direct properties 'make' and 'year'. While 'make' is a property of the object (thus returning ), 'year' is not (thus returning ).\n\nUse in a Function to Check Property\n• None Craft a function to check if an object contains a given property as its own.\n• None Pass the object and the property name as parameters.\n• Here, the function verifies if 'author' and 'publisher' are direct properties of the object. The function returns for 'author' and for 'publisher'.\n• None Understand that properties inherited from the prototype do not count as the object’s own properties.\n• None Demonstrate the difference using an object created from a prototype. Although 'wheels' is accessible on the object and returns the correct value, it is part of the prototype ( ) and not a direct property of the object itself. Thus, returns .\n\nUtilizing the method in JavaScript ensures that you are working with properties that are an integral part of the object itself, not inherited from its prototype chain. This approach minimizes bugs and misunderstanding in your code especially when dealing with complex objects and inheritance. Implement the method to maintain clear and reliable object property checks in your applications, ensuring robust and predictable behavior in JavaScript applications."
    }
]