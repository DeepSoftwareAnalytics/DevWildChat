[
    {
        "link": "https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html",
        "document": "See equivalent in the Reactive stack You can use the annotation to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping. There are also HTTP method specific shortcut variants of : The shortcuts are Custom Annotations that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using , which, by default, matches to all HTTP methods. A is still needed at the class level to express shared mappings. cannot be used in conjunction with other annotations that are declared on the same element (class, interface, or method). If multiple annotations are detected on the same element, a warning will be logged, and only the first mapping will be used. This also applies to composed annotations such as , , etc. The following example has type and method level mappings:\n\nSee equivalent in the Reactive stack methods can be mapped using URL patterns. There are two alternatives:\n• — a pre-parsed pattern matched against the URL path also pre-parsed as . Designed for web use, this solution deals effectively with encoding and path parameters, and matches efficiently.\n• — match String patterns against a String path. This is the original solution also used in Spring configuration to select resources on the classpath, on the filesystem, and other locations. It is less efficient and the String path input is a challenge for dealing effectively with encoding and other issues with URLs. is the recommended solution for web applications and it is the only choice in Spring WebFlux. It was enabled for use in Spring MVC from version 5.3 and is enabled by default from version 6.0. See MVC config for customizations of path matching options. supports the same pattern syntax as . In addition, it also supports the capturing pattern, for example, , for matching 0 or more path segments at the end of a path. also restricts the use of for matching multiple path segments such that it’s only allowed at the end of a pattern. This eliminates many cases of ambiguity when choosing the best matching pattern for a given request. For full pattern syntax please refer to PathPattern and AntPathMatcher.\n• - match zero or more characters in a path segment\n• - match a path segment and capture it as a variable Captured URI variables can be accessed with . For example: You can declare URI variables at the class and method levels, as the following example shows: URI variables are automatically converted to the appropriate type, or is raised. Simple types ( , , , and so on) are supported by default and you can register support for any other data type. See Type Conversion and . You can explicitly name URI variables (for example, ), but you can leave that detail out if the names are the same and your code is compiled with the compiler flag. The syntax declares a URI variable with a regular expression that has syntax of . For example, given URL , the following method extracts the name, version, and file extension: URI path patterns can also have embedded placeholders that are resolved on startup by using against local, system, environment, and other property sources. You can use this, for example, to parameterize a base URL based on some external configuration.\n\nSee equivalent in the Reactive stack When multiple patterns match a URL, the best match must be selected. This is done with one of the following depending on whether use of parsed is enabled for use or not: Both help to sort patterns with more specific ones on top. A pattern is more specific if it has a lower count of URI variables (counted as 1), single wildcards (counted as 1), and double wildcards (counted as 2). Given an equal score, the longer pattern is chosen. Given the same score and length, the pattern with more URI variables than wildcards is chosen. The default mapping pattern ( ) is excluded from scoring and always sorted last. Also, prefix patterns (such as ) are considered less specific than other pattern that do not have double wildcards. For the full details, follow the above links to the pattern Comparators.\n\nStarting in 5.3, by default Spring MVC no longer performs suffix pattern matching where a controller mapped to is also implicitly mapped to . As a consequence path extensions are no longer used to interpret the requested content type for the response — for example, , , and so on. Using file extensions in this way was necessary when browsers used to send headers that were hard to interpret consistently. At present, that is no longer a necessity and using the header should be the preferred choice. Over time, the use of file name extensions has proven problematic in a variety of ways. It can cause ambiguity when overlain with the use of URI variables, path parameters, and URI encoding. Reasoning about URL-based authorization and security (see next section for more details) also becomes more difficult. To completely disable the use of path extensions in versions prior to 5.3, set the following: Having a way to request content types other than through the header can still be useful, for example, when typing a URL in a browser. A safe alternative to path extensions is to use the query parameter strategy. If you must use file extensions, consider restricting them to a list of explicitly registered extensions through the property of ContentNegotiationConfigurer.\n\nA reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later. In Spring MVC, and methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks. To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither allowed as safe nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser. Many common path extensions are allowed as safe by default. Applications with custom implementations can explicitly register file extensions for content negotiation to avoid having a header added for those extensions. See Content Types. See CVE-2015-5211 for additional recommendations related to RFD.\n\nSee equivalent in the Reactive stack (and ) support HTTP HEAD transparently for request mapping. Controller methods do not need to change. A response wrapper, applied in , ensures a header is set to the number of bytes written (without actually writing to the response). By default, HTTP OPTIONS is handled by setting the response header to the list of HTTP methods listed in all methods that have matching URL patterns. For a without HTTP method declarations, the header is set to . Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants: , , and others). You can explicitly map the method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.\n\nSee equivalent in the Reactive stack Spring MVC supports the use of composed annotations for request mapping. Those are annotations that are themselves meta-annotated with and composed to redeclare a subset (or all) of the attributes with a narrower, more specific purpose. , , , , and are examples of composed annotations. They are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using , which, by default, matches to all HTTP methods. If you need an example of how to implement a composed annotation, look at how those are declared. cannot be used in conjunction with other annotations that are declared on the same element (class, interface, or method). If multiple annotations are detected on the same element, a warning will be logged, and only the first mapping will be used. This also applies to composed annotations such as , , etc. Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclassing and overriding the method, where you can check the custom attribute and return your own .\n\nSee equivalent in the Reactive stack While the main purpose of is to abstract HTTP client code with a generated proxy, the HTTP Interface on which such annotations are placed is a contract neutral to client vs server use. In addition to simplifying client code, there are also cases where an HTTP Interface may be a convenient way for servers to expose their API for client access. This leads to increased coupling between client and server and is often not a good choice, especially for public API’s, but may be exactly the goal for an internal API. It is an approach commonly used in Spring Cloud, and it is why is supported as an alternative to for server side handling in controller classes. and have differences. can map to any number of requests by path patterns, HTTP methods, and more, while declares a single endpoint with a concrete HTTP method, path, and content types. For method parameters and returns values, generally, supports a subset of the method parameters that does. Notably, it excludes any server-side specific parameter types. For details, see the list for @HttpExchange and @RequestMapping. also supports a parameter which accepts -like pairs like in on the client side. On the server side, this extends to the full syntax that supports."
    },
    {
        "link": "https://stackoverflow.com/questions/5008601/spring-mvc-default-mapping-handler",
        "document": "Basically, using Spring MVC, I'm trying to create a router controller that will take any URL that hasn't already been handled by another controller and route it to its respective resource or forward a search request if no resource could be found. Using was successful in grabbing requests that weren't grabbed already by my other controllers (this seems to work by checking the most specific mappings first) and then I could do whatever forwarding I needed. However, as soon as I put a \"/\" in the request, the mapping breaks and returns a 404.\n\nSo in other words, maps correctly to this catch-all controller, but (which does not map to any other controller) is not caught by my catch-all.\n\nHow can this be implemented? I've read a few things about interceptors and default handlers, but with no luck in finding a solution.\n\nThanks for any suggestions!"
    },
    {
        "link": "https://baeldung.com/spring-handler-mappings",
        "document": "In Spring MVC, the DispatcherServlet acts as front controller – receiving all incoming HTTP requests and processing them.\n\nSimply put, the processing occurs by passing the requests to the relevant component with the help of handler mappings.\n\nHandlerMapping is an interface that defines a mapping between requests and handler objects. While Spring MVC framework provides some ready-made implementations, the interface can be implemented by developers to provide customized mapping strategy.\n\nThis article discusses some of the implementations provided by Spring MVC namely BeanNameUrlHandlerMapping, SimpleUrlHandlerMapping, ControllerClassNameHandlerMapping, their configuration, and the differences between them.\n\nBeanNameUrlHandlerMapping is the default HandlerMapping implementation. BeanNameUrlHandlerMapping maps request URLs to beans with the same name.\n\nThis particular mapping has support for direct name matching and also for pattern matching using the “*” pattern.\n\nFor example, an incoming URL “/foo” maps to a bean called “/foo”. An example of pattern mapping is mapping requests to “/foo*” to beans with names starting with “/foo” like “/foo2/” or “/fooOne/”.\n\nLet’s configure this example here and register a bean controller that handles requests to “/beanNameUrl”:\n\nThis is the XML equivalent of the above Java based config:\n\nIt’s important to note that in both of these configurations, defining a bean for BeanNameUrlHandlerMapping is not required as it is provided by Spring MVC. Removing this bean definition will cause no problems and requests will still be mapped to their registered handler beans.\n\nNow all requests to “/beanNameUrl” will be forwarded by DispatcherServlet to “WelcomeController“. WelcomeController returns a view name called “welcome“.\n\nThe following code tests this configuration and makes sure that the correct view name is returned:\n\nNext, the SimpleUrlHandlerMapping is the most flexible HandlerMapping implementation. It allows for direct and declarative mapping between either bean instances and URLs or between bean names and URLs.\n\nLet’s map requests “/simpleUrlWelcome” and “/*/simpleUrlWelcome” to the “welcome” bean:\n\nIt’s important to note that in the XML configuration, a mapping between “<value>” tag must be done in a form accepted by java.util.Properties class and it should follow the syntax: path= Handler_Bean_Name.\n\nThe URL should normally be with a leading slash, however, if the path doesn’t begin with one, Spring MVC adds it automatically.\n\nA different way to configure the above example in XML is to use the “props” property instead of “value”. Props have a list of “prop” tag where each defines a mapping where “key” referred to the mapped URL and the value of the tag is the name of the bean.\n\nThe following test case makes sure that requests to “/simpleUrlWelcome” is handled by “WelcomeController” which returns a view name called “welcome” :\n\nThe ControllerClassNameHandlerMapping maps URL to a registered controller bean (or a controller annotated with the @Controller annotation) that has, or starts with, the same name.\n\nIt can be more convenient in many scenarios especially for simple controller implementations that handle a single request type. The convention used by Spring MVC is to use the name of the class and remove the “Controller” suffix, then change the name to a lower case and return it as the mapping with a leading “/”.\n\nFor example “WelcomeController” would return as mapping to “/welcome*”, i.e. to any URL that starts with “welcome”.\n\nNote that ControllerClassNameHandlerMapping is deprecated from Spring 4.3 in favor of annotation driven handler methods.\n\nAnother important note is that controller names will always be returned in lowercase (minus the “Controller” suffix). So if we have a controller called “WelcomeBaeldungController“, it will only handle requests to “/welcomebaeldung” and not to “/welcomeBaeldung”.\n\nIn both Java config and XML config below, we define ControllerClassNameHandlerMapping bean and register beans for the controllers that we will use to handle requests. We also register a bean of type “WelcomeController” and that bean will handle all requests that start with “/welcome”.\n\nWhen using the above configuration, requests to “/welcome” will be handled by the “WelcomeController“.\n\nThe following code will make sure that requests to “/welcome*” such as “/welcometest” is handled by “WelcomeController” which returns a view name called “welcome“:\n\nSpring MVC framework allows more than one implementation of HandlerMapping interface at the same time.\n\nLet us create a configuration and register two controllers, both mapped to URL “/welcome”, only using different mapping and returning different view names:\n\nWith no explicit handler mapper registered, a default BeanNameHandlerMapping will be used. Let us assert this behaviour with the test:\n\nIf we explicitly register a different handler mapper, the default mapper will be overridden. However, it is interesting to see what happens when two mappers are explicitly registered:\n\nTo get the control over which mapping is used, the priorities are set using setOrder(int order) method. This method takes one int parameter where lower value mean higher priority.\n\nIn XML configuration you can configure priorities by using a property called “order”:\n\nLet us add order properties to handler mapping beans, via following beanNameUrlHandlerMapping.setOrder(1) and simpleUrlHandlerMapping.setOrder(0). The lower value of the order property reflects higher precedence. Let us assert new behaviour with the test:\n\nWhen testing the above configuration, you see that requests to “/welcome” will be handled by SimpleUrlHandlerMapping bean which calls a SimpleUrlHandlerController and returns simple-url-handler-mapping view. We can easily configure the BeanNameHandlerMapping to take precedence by adjusting accordingly the values of order property.\n\nIn this article we discussed how URL mapping are handled in Spring MVC framework by exploring the different implementations in the framework."
    },
    {
        "link": "https://stackoverflow.com/questions/16813609/default-handler-mapping-for-annotation-based-spring-project",
        "document": "These links might help:\n\nI had the same problem that I just resolved so I have confirmed the approach below works, although this is with annotations rather than an XML configuration.\n\nYou specify URL prefixes at the controller class level and include a request mapping annotation for ** to ensure you match on anything that falls through your other handlers for this class. There's really nothing special or default about this handler other than the fact that you're defining a handler that is guaranteed to match everything under the class level mappings.\n\nNote: This is not magic. Your handlers are still subject to Spring's ordering algorithm regarding the \"best match\". It would be nice to have an annotation providing for a true default when nothing else matches handler, especially in cases with complex mappings where \"**\" is useful outside of this catch-all handler. The basic implementation is:\n\nIn my actual use case, I needed to handle arbitrary paths to resources inside of the URL pattern and therefore needed to support a variable number of directories. Ideally, that would be handled using a pattern such as:\n\nwhich works fine by itself, but it isn't compatible with a default handler bound to \"**\" since the \"**\" mapping is calculated by Spring as a better match for these types of requests.\n\nInstead, I had to add a bunch of separate entries to my request mapping to support the arbitrary paths within the URL pattern, e.g.\n\nAlternatively, I could have handled everything with a \"**\" mapping and parsed the URL myself, but that kind of defeats the purpose of using request mappings with path variables. Hopefully Spring's capabilities will evolve in this area in the future."
    },
    {
        "link": "https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/default-servlet-handler.html",
        "document": "Spring MVC allows for mapping the to (thus overriding the mapping of the container’s default Servlet), while still allowing static resource requests to be handled by the container’s default Servlet. It configures a with a URL mapping of and the lowest priority relative to other URL mappings.\n\nThis handler forwards all requests to the default Servlet. Therefore, it must remain last in the order of all other URL . That is the case if you use . Alternatively, if you set up your own customized instance, be sure to set its property to a value lower than that of the , which is .\n\nThe following example shows how to enable the feature by using the default setup:\n\nThe caveat to overriding the Servlet mapping is that the for the default Servlet must be retrieved by name rather than by path. The tries to auto-detect the default Servlet for the container at startup time, using a list of known names for most of the major Servlet containers (including Tomcat, Jetty, GlassFish, JBoss, WebLogic, and WebSphere). If the default Servlet has been custom-configured with a different name, or if a different Servlet container is being used where the default Servlet name is unknown, then you must explicitly provide the default Servlet’s name, as the following example shows:"
    },
    {
        "link": "https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html",
        "document": "See equivalent in the Reactive stack You can use the annotation to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping. There are also HTTP method specific shortcut variants of : The shortcuts are Custom Annotations that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using , which, by default, matches to all HTTP methods. A is still needed at the class level to express shared mappings. cannot be used in conjunction with other annotations that are declared on the same element (class, interface, or method). If multiple annotations are detected on the same element, a warning will be logged, and only the first mapping will be used. This also applies to composed annotations such as , , etc. The following example has type and method level mappings:\n\nSee equivalent in the Reactive stack methods can be mapped using URL patterns. There are two alternatives:\n• — a pre-parsed pattern matched against the URL path also pre-parsed as . Designed for web use, this solution deals effectively with encoding and path parameters, and matches efficiently.\n• — match String patterns against a String path. This is the original solution also used in Spring configuration to select resources on the classpath, on the filesystem, and other locations. It is less efficient and the String path input is a challenge for dealing effectively with encoding and other issues with URLs. is the recommended solution for web applications and it is the only choice in Spring WebFlux. It was enabled for use in Spring MVC from version 5.3 and is enabled by default from version 6.0. See MVC config for customizations of path matching options. supports the same pattern syntax as . In addition, it also supports the capturing pattern, for example, , for matching 0 or more path segments at the end of a path. also restricts the use of for matching multiple path segments such that it’s only allowed at the end of a pattern. This eliminates many cases of ambiguity when choosing the best matching pattern for a given request. For full pattern syntax please refer to PathPattern and AntPathMatcher.\n• - match zero or more characters in a path segment\n• - match a path segment and capture it as a variable Captured URI variables can be accessed with . For example: You can declare URI variables at the class and method levels, as the following example shows: URI variables are automatically converted to the appropriate type, or is raised. Simple types ( , , , and so on) are supported by default and you can register support for any other data type. See Type Conversion and . You can explicitly name URI variables (for example, ), but you can leave that detail out if the names are the same and your code is compiled with the compiler flag. The syntax declares a URI variable with a regular expression that has syntax of . For example, given URL , the following method extracts the name, version, and file extension: URI path patterns can also have embedded placeholders that are resolved on startup by using against local, system, environment, and other property sources. You can use this, for example, to parameterize a base URL based on some external configuration.\n\nSee equivalent in the Reactive stack When multiple patterns match a URL, the best match must be selected. This is done with one of the following depending on whether use of parsed is enabled for use or not: Both help to sort patterns with more specific ones on top. A pattern is more specific if it has a lower count of URI variables (counted as 1), single wildcards (counted as 1), and double wildcards (counted as 2). Given an equal score, the longer pattern is chosen. Given the same score and length, the pattern with more URI variables than wildcards is chosen. The default mapping pattern ( ) is excluded from scoring and always sorted last. Also, prefix patterns (such as ) are considered less specific than other pattern that do not have double wildcards. For the full details, follow the above links to the pattern Comparators.\n\nStarting in 5.3, by default Spring MVC no longer performs suffix pattern matching where a controller mapped to is also implicitly mapped to . As a consequence path extensions are no longer used to interpret the requested content type for the response — for example, , , and so on. Using file extensions in this way was necessary when browsers used to send headers that were hard to interpret consistently. At present, that is no longer a necessity and using the header should be the preferred choice. Over time, the use of file name extensions has proven problematic in a variety of ways. It can cause ambiguity when overlain with the use of URI variables, path parameters, and URI encoding. Reasoning about URL-based authorization and security (see next section for more details) also becomes more difficult. To completely disable the use of path extensions in versions prior to 5.3, set the following: Having a way to request content types other than through the header can still be useful, for example, when typing a URL in a browser. A safe alternative to path extensions is to use the query parameter strategy. If you must use file extensions, consider restricting them to a list of explicitly registered extensions through the property of ContentNegotiationConfigurer.\n\nA reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later. In Spring MVC, and methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks. To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither allowed as safe nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser. Many common path extensions are allowed as safe by default. Applications with custom implementations can explicitly register file extensions for content negotiation to avoid having a header added for those extensions. See Content Types. See CVE-2015-5211 for additional recommendations related to RFD.\n\nSee equivalent in the Reactive stack (and ) support HTTP HEAD transparently for request mapping. Controller methods do not need to change. A response wrapper, applied in , ensures a header is set to the number of bytes written (without actually writing to the response). By default, HTTP OPTIONS is handled by setting the response header to the list of HTTP methods listed in all methods that have matching URL patterns. For a without HTTP method declarations, the header is set to . Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants: , , and others). You can explicitly map the method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.\n\nSee equivalent in the Reactive stack Spring MVC supports the use of composed annotations for request mapping. Those are annotations that are themselves meta-annotated with and composed to redeclare a subset (or all) of the attributes with a narrower, more specific purpose. , , , , and are examples of composed annotations. They are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using , which, by default, matches to all HTTP methods. If you need an example of how to implement a composed annotation, look at how those are declared. cannot be used in conjunction with other annotations that are declared on the same element (class, interface, or method). If multiple annotations are detected on the same element, a warning will be logged, and only the first mapping will be used. This also applies to composed annotations such as , , etc. Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclassing and overriding the method, where you can check the custom attribute and return your own .\n\nSee equivalent in the Reactive stack While the main purpose of is to abstract HTTP client code with a generated proxy, the HTTP Interface on which such annotations are placed is a contract neutral to client vs server use. In addition to simplifying client code, there are also cases where an HTTP Interface may be a convenient way for servers to expose their API for client access. This leads to increased coupling between client and server and is often not a good choice, especially for public API’s, but may be exactly the goal for an internal API. It is an approach commonly used in Spring Cloud, and it is why is supported as an alternative to for server side handling in controller classes. and have differences. can map to any number of requests by path patterns, HTTP methods, and more, while declares a single endpoint with a concrete HTTP method, path, and content types. For method parameters and returns values, generally, supports a subset of the method parameters that does. Notably, it excludes any server-side specific parameter types. For details, see the list for @HttpExchange and @RequestMapping. also supports a parameter which accepts -like pairs like in on the client side. On the server side, this extends to the full syntax that supports."
    },
    {
        "link": "https://baeldung.com/spring-requestmapping",
        "document": "In this tutorial, we’ll focus on one of the main annotations in Spring MVC: @RequestMapping.\n\nSimply put, the annotation is used to map web requests to Spring Controller methods.\n\nWe start with a simple example: mapping an HTTP request to a method using some basic criteria. Let’s consider that Spring serves content on the root context path (“/”) by default. All the CURL requests in this article rely on the default root context path.\n\nTo test out this mapping with a simple curl command, run:\n\nThe HTTP method parameter has no default. So, if we don’t specify a value, it’s going to map to any HTTP request.\n\nHere’s a simple example, similar to the previous one, but this time mapped to an HTTP POST request:\n\nTo test the POST via a curl command:\n\nThe mapping can be narrowed even further by specifying a header for the request:\n\nTo test the operation, we’re going to use the curl header support:\n\nand even multiple headers via the headers attribute of @RequestMapping:\n\nWe can test this with the command:\n\nNote that for the curl syntax, a colon separates the header key and the header value, the same as in the HTTP spec, while in Spring, the equals sign is used.\n\nWe can map a request based on its Accept header via the @RequestMapping headers attribute introduced above:\n\nThe matching for this way of defining the Accept header is flexible — it uses contains instead of equals, so a request such as the following would still map correctly:\n\nStarting with Spring 3.1, the @RequestMapping annotation now has the produces and consumes attributes, specifically for this purpose:\n\nAlso, the old type of mapping with the headers attribute will automatically be converted to the new produces mechanism starting with Spring 3.1, so the results will be identical.\n\nThis is consumed via curl in the same way:\n\nKeep in mind that these — the old and new ways of specifying the Accept header — are basically the same mapping, so Spring won’t allow them together.\n\nHaving both these methods active would result in:\n\nA final note on the new produces and consumes mechanisms, which behave differently from most other annotations: When specified at the type level, the method-level annotations do not complement but override the type-level information.\n\nAnd of course, if you want to dig deeper into building a REST API with Spring, check out the new REST with Spring course.\n\nParts of the mapping URI can be bound to variables via the @PathVariable annotation.\n\nThis can be tested with curl:\n\nIf the name of the method parameter matches the name of the path variable exactly, then this can be simplified by using @PathVariable with no value:\n\nNote that @PathVariable benefits from automatic type conversion, so we could have also declared the id as:\n\nA more complex URI may need to map multiple parts of the URI to multiple values:\n\nThis is easily tested with a curl in the same way:\n\nRegular expressions can also be used when mapping the @PathVariable.\n\nFor example, we will restrict the mapping to only accept numerical values for the id:\n\nThis will mean that the following URIs will match:\n\nBut this will not:\n\n@RequestMapping allows easy mapping of URL parameters with the @RequestParam annotation. \n\n\n\nWe are now mapping a request to a URI:\n\nWe are then extracting the value of the id parameter using the @RequestParam(“id”) annotation in the controller method signature.\n\nTo send a request with the id parameter, we’ll use the parameter support in curl:\n\nIn this example, the parameter was bound directly without having been declared first.\n\nFor more advanced scenarios, @RequestMapping can optionally define the parameters as yet another way of narrowing the request mapping:\n\nEven more flexible mappings are allowed. Multiple params values can be set, and not all of them have to be used:\n\nAnd of course, a request to a URI such as:\n\nwill always be mapped to the best match — which is the narrower match, which defines both the id and the second parameter.\n\n6.1. @RequestMapping — Multiple Paths Mapped to the Same Controller Method\n\nAlthough a single @RequestMapping path value is usually used for a single controller method (just good practice, not a hard and fast rule), there are some cases where mapping multiple requests to the same method may be necessary.\n\nIn that case, the value attribute of @RequestMapping does accept multiple mappings, not just a single one:\n\nNow both of these curl commands should hit the same method:\n\n6.2. @RequestMapping — Multiple HTTP Request Methods to the Same Controller Method\n\nMultiple requests using different HTTP verbs can be mapped to the same controller method:\n\nWith curl, both of these will now hit the same method:\n\nTo implement a simple fallback for all requests using a particular HTTP method, for example, for a GET:\n\nor even for all requests:\n\nThe ambiguous mapping error occurs when Spring evaluates two or more request mappings to be the same for different controller methods. A request mapping is the same when it has the same HTTP method, URL, parameters, headers, and media type.\n\nFor example, this is an ambiguous mapping:\n\nThe exception thrown usually does have error messages along these lines:\n\nA careful reading of the error message points to the fact that Spring is unable to map the method org.baeldung.web.controller.FooMappingExamplesController.duplicateEx(), as it has a conflicting mapping with an already mapped org.baeldung.web.controller.FooMappingExamplesController.duplicate().\n\nThe code snippet below will not result in ambiguous mapping error because both methods return different content types:\n\nThis differentiation allows our controller to return the correct data representation based on the Accepts header supplied in the request.\n\nAnother way to resolve this is to update the URL assigned to either of the two methods involved.\n\nSpring Framework 4.3 introduced a few new HTTP mapping annotations, all based on @RequestMapping:\n\nThese new annotations can improve the readability and reduce the verbosity of the code.\n\nLet’s look at these new annotations in action by creating a RESTful API that supports CRUD operations:\n\nA deep dive into these can be found here.\n\nThe Spring MVC Configuration is simple enough, considering that our FooController is defined in the following package:\n\nWe simply need a @Configuration class to enable the full MVC support and configure classpath scanning for the controller:\n\nThis article focused on the @RequestMapping annotation in Spring, discussing a simple use case, the mapping of HTTP headers, binding parts of the URI with @PathVariable, and working with URI parameters and the @RequestParam annotation.\n\nIf you’d like to learn how to use another core annotation in Spring MVC, you can explore the @ModelAttribute annotation here."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/spring-requestmapping-requestparam-pathvariable-example",
        "document": "@RequestMapping is one of the most widely used Spring MVC annotation. annotation is used to map web requests onto specific handler classes and/or handler methods. can be applied to the controller class as well as methods. Today we will look into various usage of this annotation with example and other annotations and .\n• @RequestMapping with Class: We can use it with class definition to create the base URI. For example: Now /home is the URI for which this controller will be used. This concept is very similar to servlet context of a web application.\n• @RequestMapping with Method: We can use it with method to provide the URI pattern for which handler method will be used. For example: Above annotation can also be written as . On a side note, I am using @ResponseBody to send the String response for this web request, this is done to keep the example simple. Like I always do, I will use these methods in Spring MVC application and test them with a simple program or script.\n• @RequestMapping with Multiple URI: We can use a single method for handling multiple URIs, for example: If you will look at the source code of RequestMapping annotation, you will see that all of it’s variables are arrays. We can create String array for the URI mappings for the handler method.\n• @RequestMapping with HTTP Method: Sometimes we want to perform different operations based on the HTTP method used, even though request URI remains same. We can use @RequestMapping method variable to narrow down the HTTP methods for which this method will be invoked. For example:\n• @RequestMapping with Headers: We can specify the headers that should be present to invoke the handler method. For example:\n• @RequestMapping with Produces and Consumes: We can use header and to find out request contents and what is the mime message it wants in response. For clarity, @RequestMapping provides produces and consumes variables where we can specify the request content-type for which method will be invoked and the response content type. For example: Above method can consume message only with Content-Type as text/html and is able to produce messages of type application/json and application/xml.\n• @RequestMapping with @PathVariable: RequestMapping annotation can be used to handle dynamic URIs where one or more of the URI value works as a parameter. We can even specify Regular Expression for URI dynamic parameter to accept only specific type of input. It works with @PathVariable annotation through which we can map the URI variable to one of the method arguments. For example: @RequestMapping(value=\"/method7/{id}\") @ResponseBody public String method7(@PathVariable(\"id\") int id){ return \"method7 with id=\"+id; } @RequestMapping(value=\"/method8/{id:[\\\\d]+}/{name}\") @ResponseBody public String method8(@PathVariable(\"id\") long id, @PathVariable(\"name\") String name){ return \"method8 with id= \"+id+\" and name=\"+name; }\n• @RequestMapping with @RequestParam for URL parameters: Sometimes we get parameters in the request URL, mostly in GET requests. We can use @RequestMapping with @RequestParam annotation to retrieve the URL parameter and map it to the method argument. For example:\n• @RequestMapping default method: If value is empty for a method, it works as default method for the controller class. For example:\n• @RequestMapping fallback method: We can create a fallback method for the controller class to make sure we are catching all the client requests even though there are no matching handler methods. It is useful in sending custom 404 response pages to users when there are no handler methods for the request.\n\nWe can use Spring RestTemplate to test the different methods above, but today I will use cURL commands to test these methods because these are simple and there are not much data flowing around. I have created a simple shell script springTest.sh to invoke all the above methods and print their output. It looks like below.\n\nNote that I have deployed my web application on Tomcat-7 and it’s running on port 9090. SpringRequestMappingExample is the servlet context of the application. Now when I execute this script through command line, I get following output.\n\nMost of these are self understood, although you might want to check default and fallback methods. That’s all for Spring RequestMapping Example, I hope it will help you in understanding this annotation and it’s various features. You should download the sample project from below link and try different scenarios to explore it further."
    },
    {
        "link": "https://stackoverflow.com/questions/52089822/default-request-mapping-method-picked-up-for-other-urls-with-path-variable",
        "document": "I have a below as below. The method is supposed to be picked up for URLs but instead it's picking up . The other URLs work fine as expected. I am not sure if I am missing or not understanding something. I also looked at Spring request mapping to a different method for a particular path variable value and it helped a bit.\n\nRequirements: 1. /trains [POST] - add train 2. /trains [GET] - get all trains 3. /trains/{trainId} - get train by id"
    },
    {
        "link": "https://geeksforgeeks.org/spring-requestmapping-annotation-with-example",
        "document": "The @RequestMapping annotation in Spring MVC is one of the most important annotations used to map HTTP requests to handler methods of MVC and REST controllers. In Spring MVC applications, the DispatcherServlet (Front Controller) is responsible for routing incoming HTTP requests to the handler methods of controllers. When configuring Spring MVC, you need to specify the mappings between the requests and handler methods. The @RequestMapping annotation can be applied at both the class level and method level in a controller. The class-level annotation maps a specific request path or pattern onto a controller, while method-level annotations make mappings more specific to handler methods. Let’s understand the @RequestMapping annotation at both the method level and class level with examples.\n\nNote: We are going to use Spring Tool Suite 4 IDE for this project. Please refer to this article to install STS on your local machine: How to Download and Install Spring Tool Suite (Spring Tools 4 for Eclipse) IDE?\n• myfirst-mvc-project ) and select the Target Runtime as Apache Tomcat.\n• None Download the Spring framework JARs from the Spring Repository.\n• None Copy the JAR files into the src/main/webapp/WEB-INF/lib folder\n• None In STS, right-click on the project and go to Properties > Targeted Runtimes.\n• None Right-click on the project, select Run As > Run on Server.\n\nNow, the project setup is complete.\n\nThe DispatcherServlet is the front controller in Spring MVC that routes incoming HTTP requests to the appropriate handler methods. Let’s configure it in the web.xml file.\n\nGo to the src/main/webapp/WEB-INF/web.xml file and add the following configuration:\n• None The DispatcherServlet is mapped to /student.com/*, meaning all requests starting with /student.com/ will be handled by Spring MVC controllers.\n\nGo to the src/main/webapp/WEB-INF folder and create an XML file named frontcontroller-dispatcher-servlet.xml. Add the following configuration:\n\nThe component-scan ensures that Spring scans the com.student.controllers package for annotated classes.\n\nGo to the src/main/java folder and create a package named com.student.controllers. Inside this package, create a Java class named DemoController. Mark the class with the @Controller annotation to tell Spring that this is a controller class.\n• None The @RequestMapping(“/hello”) annotation maps the /hello URL to the helloWorld() method.\n• None The @ResponseBody annotation indicates that the return value of the method will be the response body.\n\nRight-click on your project and select Run As > Run on Server.\n\nUse the following URL to access the controller:\n\nThe class-level @RequestMapping annotation maps a specific request path or pattern onto a controller. You can then apply additional method-level annotations to make mappings more specific to handler methods.\n\nSo in this example, we are going to create Multi-Action Controller. MultiActionController is a Controller implementation that allows multiple request types to be handled by the same class. That means inside one controller class we can have many handler methods something like this.\n• None The class-level @RequestMapping(“/boys”) annotation applies a prefix to all method-level mappings.\n• None The helloWorld() method is now mapped to /boys/hello.\n• None The welcomeGfgMessage() method is mapped to /boys/geeksforgeeks.\n\nRight-click on your project and select Run As > Run on Server.\n\n\n\nAnd now, if you use this “http://localhost:8080/myfirst-mvc-project/student.com/hello” URL to run your controller then you are going to get the following warning and there will be no response\n\nIn order to run your controller, you have to hit the following URL\n\nSimilarly, for the welcomeGfgMessage() handler method, you have to hit the following URL"
    }
]