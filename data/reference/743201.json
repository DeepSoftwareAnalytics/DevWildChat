[
    {
        "link": "https://stackoverflow.com/questions/35847325/how-to-read-a-file-with-javas-bufferedreader-vs-inputstreamreader",
        "document": "Below I have the following code to read in a file and go through it line by line.. This is using java's BufferedReader class. That I am fine with.\n\nHowever I want to now start using InputStreamReader in Spring / Java. I have the below code written but I am unsure how I can step through my file line by line. Really confused over this part. Anyone have any ideas or know how this can be done?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-read-file-line-by-line",
        "document": "In this article, you will learn about different ways to use Java to read the contents of a file line-by-line. This article uses methods from the following Java classes: , , , and .\n\nYou can use the method from to read a file line-by-line to String. This method returns when the end of the file is reached.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use the class to open a file and then read its content line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nis a utility class that contains various useful methods. The method can be used to read all the file lines into a list of strings.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use to open a file in read mode and then use its method to read a file line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nIf a file is stored in an encoding other than UTF-8, you should specify the correct encoding when reading it.\n\nFor massive files (GB-sized logs or datasets), Java’s NIO API ( ) is a high-performance alternative to standard file reading.\n\nHere is an example:\n\nUsing significantly reduces memory usage compared to loading a file into memory at once.\n\nFor more advanced file handling techniques, you can check out this tutorial on Java Files - java.nio.file.Files Class.\n\n1. How to read a file in Java using ?\n\nTo read a file in Java using , you can create an instance of and read character data from the file. However, is not the most efficient option as it does not buffer the input. A better alternative is to wrap it inside a .\n\nFor more efficient file reading, consider using BufferedReader instead.\n\n2. How to read a file line by line in Java?\n\nThe most common way to read a file line by line in Java is by using . This method is memory-efficient and performs well for large files.\n\nFor additional file handling methods, check out this tutorial on Java File Handling.\n\n3. What is the most efficient way to read a large file in Java?\n\nWhen dealing with large files, reading the entire file into memory is inefficient. Instead, use streams or Java NIO (Non-blocking I/O) APIs like for better performance.\n\nUsing BufferedReader with Streams (Efficient for Large Files)\n\nUsing (Best for Extremely Large Files)\n\nFor extremely large files, consider memory-mapped files or for improved performance as described in the section above.\n\n4. How to handle file reading errors in Java?\n\nError handling is crucial to avoid crashes due to file not found, permissions issues, or encoding mismatches.\n\n5. What is the difference between and ?\n\nTo handle large text files efficiently, always prefer over . Learn more about efficient file operations in tutorial on Java read text file.\n\nIn this comprehensive guide, you learned various methods to read the contents of a file line-by-line in Java, including the use of , , , and . You also learned how to handle file reading errors, the difference between and , and how to efficiently handle large files using or memory-mapped files.\n\nContinue your learning with more Java tutorials.\n\nYou can also refer to these tutorials on:"
    },
    {
        "link": "https://stackoverflow.com/questions/44792788/read-from-a-file-using-bufferedreader-and-filereader",
        "document": "I am relatively new to java, and am curious as to how to read from a file using buffered reader. the reason for this is i'm taking a class and was assigned to do a simple ceaser cipher, I'm supposed to decrypt a text file, create a new file, and put the decrypted text into that file. I was able to do this with the scanner, and a small 10KB file, but it was extremely slow when working with the big 100MB text file i'm gonna be tested with. here is the code i have which is supposed to read the file contents.\n\nif someone could point me in the right direction, that would be fantastic."
    },
    {
        "link": "https://baeldung.com/java-buffered-reader",
        "document": "BufferedReader is a class which simplifies reading text from a character input stream. It buffers the characters in order to enable efficient reading of text data.\n\nIn this tutorial, we’re going to look at how to use the BufferedReader class.\n\n2. When to Use BufferedReader\n\nIn general, BufferedReader comes in handy if we want to read text from any kind of input source whether that be files, sockets, or something else.\n\nSimply put, it enables us to minimize the number of I/O operations by reading chunks of characters and storing them in an internal buffer. While the buffer has data, the reader will read from it instead of directly from the underlying stream.\n\nLike most of the Java I/O classes, BufferedReader implements Decorator pattern, meaning it expects a Reader in its constructor. In this way, it enables us to flexibly extend an instance of a Reader implementation with buffering functionality:\n\nBut, if buffering doesn’t matter to us we could just use a FileReader directly:\n\nIn addition to buffering, BufferedReader also provides some nice helper functions for reading files line-by-line. So, even though it may appear simpler to use FileReader directly, BufferedReader can be a big help.\n\nIn general, we can configure BufferedReader to take any kind of input stream as an underlying source. We can do it using InputStreamReader and wrapping it in the constructor:\n\nIn the above example, we are reading from System.in which typically corresponds to the input from the keyboard. Similarly, we could pass an input stream for reading from a socket, file or any imaginable type of textual input. The only prerequisite is that there is a suitable InputStream implementation for it.\n\nAs an alternative, we could use the Scanner class to achieve the same functionality as with BufferedReader.\n\nHowever, there are significant differences between these two classes which can make them either more or less convenient for us, depending on our use case:\n• BufferedReader is synchronized (thread-safe) while Scanner is not\n• Scanner can parse primitive types and strings using regular expressions\n• BufferedReader allows for changing the size of the buffer while Scanner has a fixed buffer size\n• Scanner hides IOException, while BufferedReader forces us to handle it\n• BufferedReader is usually faster than Scanner because it only reads the data without parsing it\n\nWith these in mind, if we are parsing individual tokens in a file, then Scanner will feel a bit more natural than BufferedReader. But, just reading a line at a time is where BufferedReader shines.\n\nIf needed, we also have a guide on Scanner as well.\n\nLet’s go through the entire process of building, using and destroying a BufferReader properly to read from a text file.\n\nWrapping the FileReader like this is a nice way to add buffering as an aspect to other readers.\n\nBy default, this will use a buffer of 8 KB. However, if we want to buffer smaller or larger blocks, we can use the BufferedReader(Reader, int) constructor:\n\nThis will set the buffer size to 16384 bytes (16 KB).\n\nThe optimal buffer size depends on factors like the type of the input stream and the hardware on which the code is running. For this reason, to achieve the ideal buffer size, we have to find it ourselves by experimenting.\n\nIt’s best to use powers of 2 as buffer size since most hardware devices have a power of 2 as the block size.\n\nFinally, there is one more handy way to create a BufferedReader using the Files helper class from the java.nio API:\n\nCreating it like this is a nice way to buffer if we want to read a file because we don’t have to manually create a FileReader first and then wrap it.\n\nNext, let’s read the content of the file using the readLine method:\n\nWe can do the same thing as above using the lines method introduced in Java 8 a bit more simply:\n\nAfter using the BufferedReader, we have to call its close() method to release any system resources associated with it. This is done automatically if we use a try-with-resources block:\n\nNow let’s focus on various useful methods available in BufferedReader.\n\nWe can use the read() method to read a single character. Let’s read the whole content character-by-character until the end of the stream:\n\nThis will read the characters (returned as ASCII values), cast them to char and append them to the result. We repeat this until the end of the stream, which is indicated by the response value -1 from the read() method.\n\nIf we want to read multiple characters at once, we can use the method read(char[] cbuf, int off, int len):\n\nIn the above code example, we’ll read up to 5 characters into a char array and construct a string from it. In the case that no characters were read in our read attempt (i.e. we’ve reached the end of the stream), we’ll simply return an empty string.\n\nWe can also skip a given number of characters by calling the skip(long n) method:\n\nIn the above example, we read from an input string which contains numbers separated by two underscores. In order to construct a string containing only the numbers, we are skipping the underscores by calling the skip method.\n\nWe can use the mark(int readAheadLimit) and reset() methods to mark some position in the stream and return to it later. As a somewhat contrived example, let’s use mark() and reset() to ignore all whitespaces at the beginning of a stream:\n\nIn the above example, we use the mark() method to mark the position we just read. Giving it a value of 1 means only the code will remember the mark for one character forward. It’s handy here because, once we see our first non-whitespace character, we can go back and re-read that character without needing to reprocess the whole stream. Without having a mark, we’d lose the L in our final string.\n\nNote that because mark() can throw an UnsupportedOperationException, it’s pretty common to associate markSupported() with code that invokes mark(). Though, we don’t actually need it here. That’s because markSupported() always returns true for BufferedReader.\n\nOf course, we might be able to do the above a bit more elegantly in other ways, and indeed mark and reset aren’t very typical methods. They certainly come in handy, though, when there is a need to look ahead.\n\nIn this quick tutorial, we’ve learned how to read character input streams on a practical example using BufferedReader."
    },
    {
        "link": "https://geeksforgeeks.org/ways-to-read-input-from-console-in-java",
        "document": "In Java, there are four different ways to read input from the user in the command line environment(console).\n\nBuffered Reader Class is the classical method to take input, Introduced in JDK 1.0. This method is used by wrapping the System.in (standard input stream) in an InputStreamReader which is wrapped in a BufferedReader, we can read input from the user in the command line.\n• None The input is buffered for efficient reading.\n• None The wrapping code is hard to remember.\n\nExample: The below Java program demonstrates how to use BufferReader to read a line of input from the user and print it to the console.\n\nNote: To read other types, we use functions like Integer.parseInt(), Double.parseDouble(). To read multiple values, we use split().\n\nScanner Class is probably the most preferred method to take input, Introduced in JDK 1.5. The main purpose of the Scanner class is to parse primitive types and strings using regular expressions; however, it is also can be used to read input from the user in the command line.\n• None Convenient methods for parsing primitives (nextInt(), nextFloat(), …) from the tokenized input.\n• None Regular expressions can be used to find tokens.\n• None The reading methods are not synchronized.\n\nExample: The below Java program demonstrates how to use Scanner class to read and display different type of user input.\n\nConsole Class has been becoming a preferred way for reading user’s input from the command line, Introduced in JDK 1.6. In addition, it can be used for reading password-like input without echoing the characters entered by the user; the format string syntax can also be used (like System.out.printf()).\n\nExample: The below Java program demonstrates how to use System.console() to read user input from the console, which works in terminal but not in most IDEs.\n• None Format string syntax can be used.\n• None Does not work in non-interactive environment (such as in an IDE).\n\nCommand line argument has been around since JDK 1.0 and are used in competitive coding. These inputs are passed to the program during execution and are stored as strings in the args[] array. If we need numeric values, we can convert the strings using methods like Integer.parseInt() or Float.parseFloat(). These programs are run from the command line, with inputs provided while executing the program.\n\nExample: The below Java program demonstrates how to check and print command-line arguments passed to the program or display a message if no arguments are provided.\n\nDataInputStream class in Java, introduced in JDK 1.0, is used to read primitive data types like int, float, boolean, and strings from an input stream in a way that works across different machines. It is part of the package and wraps an existing input stream. It’s commonly used with DataOutputStream or similar sources to ensure the data is read correctly.\n\nExample: The below Java program demonstrates how to use the class to read an integer and a string from user input.\n\nfor more faster ways of reading input."
    },
    {
        "link": "https://baeldung.com/java-initialize-hashmap",
        "document": "In this tutorial, we’ll learn about various ways of initializing a HashMap in Java.\n\nWe’ll use Java 8 as well as Java 9.\n\nWe can initialize a HashMap using a static block of code:\n\nThe advantage of this kind of initialization is that the map is mutable, but it will only work for static. Consequently, entries can be added and removed as and when required.\n\nLet’s go ahead and test it:\n\nWe can also initialize the map using the double-brace syntax:\n\nNote that we must try to avoid this initialization technique because it creates an anonymous extra class at every usage, holds hidden references to the enclosing object, and might cause memory leak issues.\n\nIf we need to create a singleton immutable map with a single entry, Collections.singletonMap() becomes very useful:\n\nNote that the map here is immutable, and if we try to add more entries, it’ll throw java.lang.UnsupportedOperationException.\n\nWe can also create an immutable empty map by using Collections.emptyMap():\n\nIn this section, let’s look into the ways to initialize a map using Java 8 Stream API.\n\nLet’s use a Stream of a two-dimensional String array and collect them into a map:\n\nNotice here the data type of key and value of the Map is the same.\n\nIn order to make it more generic, let’s take the array of Objects and perform the same operation:\n\nAs a result, we create a map of the key as a String and value as an Integer.\n\nHere we’ll use the instances of Map.Entry. This is another approach where we have different key and value types.\n\nFirst, let’s use SimpleEntry implementation of the Entry interface:\n\nNow let’s create the map using SimpleImmutableEntry implementation:\n\nIn certain use cases, we need to initialize an immutable map. This could be done by wrapping the Collectors.toMap() inside Collectors.collectingAndThen():\n\nNote that we should avoid using such initialization using Streams, as it could cause a huge performance overhead and lots of garbage objects are created just to initialize the map.\n\nJava 9 comes with various factory methods in the Map interface that simplify the creation and initialization of immutable maps.\n\nLet’s go ahead and look into these factory methods.\n\nThis factory method takes no argument, a single argument, and variable arguments:\n\nNote that this method supports only a maximum of 10 key-value pairs.\n\nIt’s similar to the Map.of() but has no limitations on the number of key-value pairs:\n\nNote that the factory methods produce immutable maps, hence any mutation will result in a UnsupportedOperationException.\n\nAlso, they do not allow null keys or duplicate keys.\n\nNow if we need a mutable or growing map after initialization, we can create any of the implementations of the Map interface and pass these immutable maps in the constructor:\n\nAs we’ve looked into the ways of using core Java, let’s move ahead and initialize a map using the Guava library:\n\nThis would create an immutable map, and to create a mutable one:\n\nThe method ImmutableMap.of() also has overloaded versions that can take up to 5 pairs of key-value parameters. Here’s what an example with 2 pairs of parameters would look like:\n\nIn this article we explored the various ways of initializing a Map, particularly to create empty, singleton, immutable and mutable maps. As we can see, there’s a huge improvement in this field since Java 9."
    },
    {
        "link": "https://stackoverflow.com/questions/6802483/how-to-directly-initialize-a-hashmap-in-a-literal-way",
        "document": "What would be the correct syntax? I have not found anything regarding this. Is this possible? I am looking for the shortest/fastest way to put some \"final/static\" values in a map that never change and are known in advance when creating the Map.\n\nIs there some way of initializing a Java HashMap like this?:\n\nIn case you happen to need just a single entry: There is . Yes, this is possible now. In Java 9 a couple of factory methods have been added that simplify the creation of maps : // this works for up to 10 elements: Map<String, String> test1 = Map.of( \"a\", \"b\", \"c\", \"d\" ); // this works for any number of elements: import static java.util.Map.entry; Map<String, String> test2 = Map.ofEntries( entry(\"a\", \"b\"), entry(\"c\", \"d\") ); In the example above both and will be the same, just with different ways of expressing the Map. The method is defined for up to ten elements in the map, while the method will have no such limit. Note that in this case the resulting map will be an immutable map. If you want the map to be mutable, you could copy it again, e.g. using . Also note that in this case keys and values must not be . For up to Java Version 8: No, you will have to add all the elements manually. You can use an initializer in an anonymous subclass to make the syntax a little bit shorter: However, the anonymous subclass might introduce unwanted behavior in some cases. This includes for example:\n• It generates an additional class which increases memory consumption, disk space consumption and startup-time\n• In case of a non-static method: It holds a reference to the object the creating method was called upon. That means the object of the outer class cannot be garbage collected while the created map object is still referenced, thus blocking additional memory Using a function for initialization will also enable you to generate a map in an initializer, but avoids nasty side-effects:\n\nThere is no direct way to do this - As of 2021, Java has no Map literals (yet - I think they were proposed for Java 8, but didn't make it). This creates an anonymous subclass of HashMap, whose instance initializer puts these values. (By the way, a map can't contain twice the same value, your second put will overwrite the first one. I'll use different values for the next examples.) The normal way would be this (for a local variable): If your map is an instance variable, put the initialization in a constructor or instance initializer: If your map is a class variable, put the initialization in a static initializer: If you want your map to never change, you should after the initialization wrap your map by . You can do this in a static initializer too: Since Java 9, you also have the Map.of(...) and Map.ofEntries() syntax, as explained in the answer from yankee.\n\nUse methods in Java 9 and later. Map< String , String > animalSounds = Map.of( \"dog\" , \"bark\" , // key , value \"cat\" , \"meow\" , // key , value \"bird\" , \"chirp\" // key , value ) ; Java 9 added a series of static methods to do just what you want: Instantiate an immutable using literal syntax. The map (a collection of entries) is immutable, so you cannot add or remove entries after instantiating. Also, the key and the value of each entry is immutable, cannot be changed. See the Javadoc for other rules, such as no NULLs allowed, no duplicate keys allowed, and the iteration order of mappings is arbitrary. Let's look at these methods, using some sample data for a map of day-of-week to a person who we expect will work on that day. Person alice = new Person( \"Alice\" ); Person bob = new Person( \"Bob\" ); Person carol = new Person( \"Carol\" ); creates an empty . Unmodifiable, so you cannot add entries. Here is an example of such a map, empty with no entries. are several methods that take 1 to 10 key-value pairs. Here is an example of two entries. takes any number of objects implementing the interface. Java bundles two classes implementing that interface, one mutable, the other immutable: , . But we need not specify a concrete class. We merely need to call method, pass our key and our value, and we get back an object of a some class implementing interface. Java 10 added the method . Pass an existing map, get back an immutable copy of that map. For efficiency, if the passed map is already truly immutable, the method returns a reference to the original without manufacturing a new map. Tip: Prefer over if you need/expect a truly immutable map. The method produces a view onto the original map, a mere wrapper, not a true copy. The upside: Being a mere view has the benefit of conserving memory. The downside: Modifications to the original show through. If the original map gets modified ( , , etc.), the supposedly-unmodifiable will actually show the modification. In contrast, the does indeed produce a true copy of the passed map if not already truly immutable. record Person( String name ) { } Person alice = new Person ( \"Alice\" ); Person bob = new Person ( \"Bob\" ); Map < DayOfWeek, Person > weekendWorkerMutable = HashMap.newHashMap ( 2 ); weekendWorkerMutable.put ( DayOfWeek.SATURDAY , bob ); weekendWorkerMutable.put ( DayOfWeek.SUNDAY , bob ); System.out.println ( \"weekendWorkerMutable = \" + weekendWorkerMutable ); Map < DayOfWeek, Person > weekendWorkerSupposedlyUnmodifiable = Collections.unmodifiableMap ( weekendWorkerMutable ); System.out.println ( \"weekendWorkerSupposedlyUnmodifiable = \" + weekendWorkerSupposedlyUnmodifiable ); Map < DayOfWeek, Person > trueCopy = Map.copyOf ( weekendWorkerSupposedlyUnmodifiable ); System.out.println ( \"trueCopy = \" + trueCopy ); weekendWorkerMutable.put ( DayOfWeek.SATURDAY , alice ); // <--- Modify the original. System.out.println ( \" ----- After mutating the original mutable map ----- \" ); System.out.println ( \"weekendWorkerSupposedlyUnmodifiable = \" + weekendWorkerSupposedlyUnmodifiable ); System.out.println ( \"trueCopy = \" + trueCopy );\n• We see that the supposedly unmodifiable is indeed modifiable indirectly, by modifying the original map on which the unmodifiable map is a view.\n• In contrast, the method produces a true copy, showing Bob as working the entire weekend even after assigning Alice. Notice that the iterator order of maps produced via are not guaranteed. The entries have an arbitrary order. Do not write code based on the order seen, as the documentation warns the order is subject to change. Note that all of these methods return a of an unspecified class. The underlying concrete class may even vary from one version of Java to another. This anonymity enables Java to choose from various implementations, whatever optimally fits your particular data. For example, if your keys come from an enum, Java might use an under the covers.\n\nUnfortunately, using varargs if the type of the keys and values are not the same is not very reasonable as you'd have to use and lose type safety completely. If you always want to create e.g. a , of course a would be possible though, but not very pretty as it would be easy to mix up keys and values, and an odd number of arguments would be invalid. You could create a sub-class of HashMap that has a chainable method like and use it like Another approach is to use the common builder pattern: and use it like However, the solution I've used now and then utilizes varargs and the class: The verbosity of bothers me a bit, but this works quite fine. If you don't mind static imports you could of course create a helper:"
    },
    {
        "link": "https://geeksforgeeks.org/initialize-hashmap-in-java",
        "document": "HashMap in Java is a part of the java.util package and allows storing key-value pairs. Initializing a HashMap can be done in multiple ways, including static blocks, utility methods from the Collections class, and modern approaches provided by Java 8 and Java 9. This article will guide you through these methods with clear examples and explanations.\n\nDifferent Methods to Initialize a HashMap in Java\n\nUsing a static block is an effective way to initialize a HashMap at class loading time, especially when we need a constant, unmodifiable map.\n• None The static block runs when the class is loaded.\n• None is initialized and populated with key-value pairs.\n• None This approach is suitable for creating immutable maps that remain constant throughout the program’s execution.\n\nJava Collections framework provides utility methods to initialize a HashMap. One such method is Collections.singletonMap, which creates a map with a single entry. This map can be used to initialize a HashMap.\n• None This map is used to initialize a mutable HashMap which can be further modified.\n\nJava 8 introduced Streams, which can be used to initialize a HashMap using arrays of key-value pairs.\n• Stream.of creates a stream of object arrays, each containing a key-value\n\nJava 9 introduced convenient factory methods like Map.of and Map.ofEntries for initializing HashMaps.\n• Map.of creates an immutable map with up to 10 key-value pairs.\n• None allows creating an immutable map with more than 10 entries using"
    },
    {
        "link": "https://geeksforgeeks.org/java-util-hashmap-in-java-with-examples",
        "document": "In Java, HashMap is part of the Java Collections Framework and is found in the java.util package. It provides the basic implementation of the Map interface in Java. HashMap stores data in (key, value) pairs. Each key is associated with a value, and you can access the value by using the corresponding key.\n• None Not synchronized (unlike Hashtable in Java) and hence faster for most of the cases.\n• None Allows to store the null keys as well, but there should be only one null key object, and there can be any number of null values.\n• None Duplicate keys are not allowed in HashMap, if you try to insert the duplicate key, it will replace the existing value of the corresponding key.\n• None HashMap uses keys in the same way as an Array uses an index.\n• None HashMap allows for efficient key-based retrieval, insertion, and removal with an average O(1) time complexity.\n\nIt takes two parameters namely as follows:\n• None The type of keys maintained by this map\n\nHashMap in Java implements Serializable, Cloneable, Map<K, V> interfaces.Java HashMap extends AbstractMap<K, V> class. The direct subclasses are LinkedHashMap and PrinterStateReasons.\n\nA HashMap is a data structure that is used to store and retrieve values based on keys. Some of the key characteristics of a hashmap include:\n• Not ordered: HashMaps are not ordered, which means that the order in which elements are added to the map is not preserved. However, LinkedHashMap is a variation of HashMap that preserves the insertion order.\n• Thread-unsafe : HashMaps are not thread-safe, which means that if multiple threads access the same hashmap simultaneously, it can lead to data inconsistencies. If thread safety is required, ConcurrentHashMap can be used.\n• Capacity and load factor : HashMaps have a capacity, which is the number of elements that it can hold, and a load factor, which is the measure of how full the hashmap can be before it is resized.\n\nHashMap provides 4 constructors and the access modifier of each is public which are listed as follows:\n\nNow discuss the above constructors one by one alongside implementing the same with the help of clean Java programs.\n\nIt is the default constructor which creates an instance of HashMap with an initial capacity of 16 and a load factor of 0.75.\n\nIt creates a HashMap instance with a specified initial capacity and load factor of 0.75.\n\nIt creates a HashMap instance with a specified initial capacity and specified load factor.\n\nIt creates an instance of HashMap with the same mappings as the specified map.\n\nTo add an element to the map, we can use the put() method. However, the insertion order is not retained in the Hashmap. Internally, for every element, a separate hash is generated and the elements are indexed based on this hash to make it more efficient.\n\nAfter adding the elements if we wish to change the element, it can be done by again adding the element with the put() method. Since the elements in the map are indexed using the keys, the value of the key can be changed by simply inserting the updated value for the key for which we wish to change.\n\nTo remove an element from the Map, we can use the remove() method. This method takes the key value and removes the mapping for a key from this map if it is present in the map.\n\nWe can use the Iterator interface to traverse over any structure of the Collection Framework. Since Iterators work with one type of data we use Entry< ? , ? > to resolve the two separate types into a compatible format. Then using the next() method we print the entries of HashMap.\n\nHashMap provides constant time complexity for basic operations, get and put if the hash function is properly written and it disperses the elements properly among the buckets. Iteration over HashMap depends on the capacity of HashMap and the number of key-value pairs. It is directly proportional to the capacity + size. Capacity is the number of buckets in HashMap. So it is not a good idea to keep a high number of buckets in HashMap initially.\n• None Count distinct elements in every window of size K\n• None Check if two arrays are equal or not\n• None Count all pairs with absolute difference equal to K\n• None Max distance between two occurrences in array\n• None Remove minimum elements such that no common elements exist in two arrays\n\nTo access a value one must know its key. HashMap is known as HashMap because it uses a technique called Hashing. Hashing is a technique of converting a large String to a small String that represents the same String. A shorter value helps in indexing and faster searches. HashSet also uses HashMap internally.\n\nA few important features of HashMap are:\n• None HashMap extends an abstract class AbstractMap which also provides an incomplete implementation of the Map interface.\n• None interfaces. K and V in the above definition represent Key and Value respectively.\n• None HashMap doesn’t allow duplicate keys but allows duplicate values. That means A single key can’t contain more than 1 value but more than 1 key can contain a single value.\n• None HashMap allows a null key also but only once and multiple null values.\n• None This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. It is roughly similar to HashTable but is unsynchronized.\n\nInternally HashMap contains an array of Node and a node is represented as a class that contains 4 fields:\n\nIt can be seen that the node contains a reference to its object. So it’s a linked list.\n\nThe performance of HashMap depends on 2 parameters which are named as follows:\n\nIf the initial capacity is kept higher then rehashing will never be done. But by keeping it higher increases the time complexity of iteration. So it should be chosen very cleverly to increase performance. The expected number of values should be taken into account to set the initial capacity. The most generally preferred load factor value is 0.75 which provides a good deal between time and space costs. The load factor’s value varies between 0 and 1.\n\nAs it is told that HashMap is unsynchronized i.e. multiple threads can access it simultaneously. If multiple threads access this class simultaneously and at least one thread manipulates it structurally then it is necessary to make it synchronized externally. It is done by synchronizing some object which encapsulates the map. If No such object exists then it can be wrapped around Collections.synchronizedMap() to make HashMap synchronized and avoid accidental unsynchronized access. As in the following example:\n\nNow the Map m is synchronized. Iterators of this class are fail-fast if any structure modification is done after the creation of the iterator, in any way except through the iterator’s remove method. In a failure of an iterator, it will throw ConcurrentModificationException.\n• K – The type of the keys in the map.\n• V – The type of values mapped in the map.\n• Fast retrieval: HashMaps provide constant time access to elements, which means that retrieval and insertion of elements is very fast.\n• Efficient storage : HashMaps use a hashing function to map keys to indices in an array. This allows for quick lookup of values based on keys, and efficient storage of data.\n• Flexibility : HashMaps allow for null keys and values, and can store key-value pairs of any data type.\n• Easy to use : HashMaps have a simple interface and can be easily implemented in Java.\n• Suitable for large data sets : HashMaps can handle large data sets without slowing down.\n• Unordered : HashMaps are not ordered, which means that the order in which elements are added to the map is not preserved.\n• Not thread-safe : HashMaps are not thread-safe, which means that if multiple threads access the same hashmap simultaneously, it can lead to data inconsistencies.\n• Performance can degrade : In some cases, if the hashing function is not properly implemented or if the load factor is too high, the performance of a HashMap can degrade.\n• More complex than arrays or lists : HashMaps can be more complex to understand and use than simple arrays or lists, especially for beginners.\n• Higher memory usage : Since HashMaps use an underlying array, they can use more memory than other data structures like arrays or lists. This can be a disadvantage if memory usage is a concern."
    },
    {
        "link": "https://baeldung.com/java-hashmap",
        "document": "In this tutorial, we’ll see how to use HashMap in Java, and we’ll look at how it works internally.\n\nA class very similar to HashMap is Hashtable. Please refer to a couple of our other articles to learn more about the java.util.Hashtable class itself and the differences between HashMap and Hashtable.\n\nLet’s first look at what it means that HashMap is a map. A map is a key-value mapping, which means that every key is mapped to exactly one value and that we can use the key to retrieve the corresponding value from a map.\n\nOne might ask why not simply add the value to a list. Why do we need a HashMap? The simple reason is performance. If we want to find a specific element in a list, the time complexity is O(n) and if the list is sorted, it will be O(log n) using, for example, a binary search.\n\nThe advantage of a HashMap is that the time complexity to insert and retrieve a value is O(1) on average. We’ll look at how that can be achieved later. Let’s first look at how to use HashMap.\n\nLet’s create a simple class that we’ll use throughout the article:\n\nWe can now create a HashMap with the key of type String and elements of type Product:\n\nAnd add products to our HashMap:\n\nWe can retrieve a value from the map by its key:\n\nIf we try to find a value for a key that doesn’t exist in the map, we’ll get a null value:\n\nAnd if we insert a second value with the same key, we’ll only get the last inserted value for that key:\n\nHashMap also allows us to have null as a key:\n\n2.5. Values with the Same Key\n\nFurthermore, we can insert the same object twice with a different key:\n\nWe can remove a key-value mapping from the HashMap:\n\n2.7. Check If a Key or Value Exists in the Map\n\nTo check if a key is present in the map, we can use the containsKey() method:\n\nOr, to check if a value is present in the map, we can use the containsValue() method:\n\nBoth method calls will return true in our example. Though they look very similar, there is an important difference in performance between these two method calls. The complexity to check if a key exists is O(1), while the complexity to check for an element is O(n), as it’s necessary to loop over all the elements in the map.\n\nThere are three basic ways to iterate over all key-value pairs in a HashMap.\n\nWe can iterate over the set of all keys:\n\nOr we can iterate over the set of all entries:\n\nFinally, we can iterate over all values:\n\nWe can use any class as the key in our HashMap. However, for the map to work properly, we need to provide an implementation for equals() and hashCode(). Let’s say we want to have a map with the product as the key and the price as the value:\n\nNote that hashCode() and equals() need to be overridden only for classes that we want to use as map keys, not for classes that are only used as values in a map. We’ll see why this is necessary in section 5 of this article.\n\nJava 8 added several functional-style methods to HashMap. In this section, we’ll look at some of these methods.\n\nFor each method, we’ll look at two examples. The first example shows how to use the new method, and the second example shows how to achieve the same in earlier versions of Java.\n\nAs these methods are quite straightforward, we won’t look at more detailed examples.\n\nThe forEach method is the functional-style way to iterate over all elements in the map:\n\nOur article Guide to the Java 8 forEach covers the forEach loop in greater detail.\n\nUsing the getOrDefault() method, we can get a value from the map or return a default element in case there is no mapping for the given key:\n\nWith this method, we can add a new mapping, but only if there is not yet a mapping for the given key:\n\nOur article Merging Two Maps with Java 8 takes a closer look at this method.\n\nAnd with merge(), we can modify the value for a given key if a mapping exists, or add a new value otherwise:\n\nWith the compute() method, we can compute the value for a given key:\n\nIt’s worth noting that the methods merge() and compute() are quite similar. The compute() method accepts two arguments: the key and a BiFunction for the remapping. And merge() accepts three parameters: the key, a default value to add to the map if the key doesn’t exist yet, and a BiFunction for the remapping.\n\n5. How to Avoid Casting HashMap<String, Object> Value\n\nThe java.util.HashMap<K,V> class is a hash table based implementation of the Map interface. Let’s discuss how we can avoid casting an instance of type HashMap<String, Object>.\n\n5.1. When We Need Casting\n\nFirst, let’s introduce when we need casting. Consider the Product class example. When creating a collection of Products using a HashMap we’ve got the option of initializing the collection using HashMap<String, Object>:\n\nAfter initializing, we can add instances of the Product class. However, when we want to create an instance of HashMap<String, Product> to access the field values of a Product instance, we can’t mix instance types. To demonstrate, let’s try to assign the instance we created to a variable of type HashMap<String, Product>:\n\nWe get an error message error: incompatible types: HashMap<String,Object> cannot be converted to HashMap<String,Product>. Therefore, we must iterate over the HashMap<String, Object> collection and cast Object to Product for each value to create a type HashMap<String, Product> collection. Let’s use a JUnit 5 test to confirm that we can access the fields of the resulting collection directly:\n\nThe JUnit test passes when we correctly convert the Object type values to Product type values.\n\nAlthough casting is an option, we can avoid it for a more concise code. We avoid casting by using appropriate generics parameters when initializing a HashMap. If the HashMap value is of type Product we parameterize using Product instead of the superclass Object:\n\nLet’s use JUnit 5 test to confirm that no casting is required, and the resulting object can be assigned to a variable of type HashMap<String,Product>:\n\nThe two JUnit tests should pass, confirming that we can avoid casting.\n\nIn this section, we’ll look at how HashMap works internally and what are the benefits of using HashMap instead of a simple list, for example.\n\nAs we’ve seen, we can retrieve an element from a HashMap using its key. One approach would be to use a list, iterate over all elements, and return when we find an element for which the key matches. Both the time and space complexity of this approach would be O(n).\n\nWith HashMap, we can achieve an average time complexity of O(1) for the put and get operations and space complexity of O(n). Let’s see how that works.\n\nInstead of iterating over all its elements, HashMap attempts to calculate the position of a value based on its key.\n\nThe naive approach would be to have a list that can contain as many elements as there are keys possible. As an example, let’s say our key is a lower-case character. Then it’s sufficient to have a list of size 26, and if we want to access the element with key ‘c’, we’d know that it’s the one at position 3, and we can retrieve it directly.\n\nHowever, this approach would not be very effective if we have a much bigger keyspace. For example, let’s say our key was an integer. In this case, the size of the list would have to be 2,147,483,647. In most cases, we would also have far fewer elements, so a big part of the allocated memory would remain unused.\n\nHashMap stores elements in so-called buckets and the number of buckets is called capacity.\n\nWhen we put a value in the map, the key’s hashCode() method is used to determine the bucket in which the value will be stored.\n\nTo retrieve the value, HashMap calculates the bucket in the same way – using hashCode(). Then it iterates through the objects found in that bucket and use key’s equals() method to find the exact match.\n\nIn most cases, we should use immutable keys. Or at least, we must be aware of the consequences of using mutable keys.\n\nLet’s see what happens when our key changes after we used it to store a value in a map.\n\nFor this example, we’ll create the MutableKey:\n\nAnd here goes the test:\n\nAs we can see, we’re no longer able to get the corresponding value once the key has changed, instead, null is returned. This is because HashMap is searching in the wrong bucket.\n\nThe above test case may be surprising if we don’t have a good understanding of how HashMap works internally.\n\nFor this to work correctly, equal keys must have the same hash, however, different keys can have the same hash. If two different keys have the same hash, the two values belonging to them will be stored in the same bucket. Inside a bucket, values are stored in a list and retrieved by looping over all elements. The cost of this is O(n).\n\nAs of Java 8 (see JEP 180), the data structure in which the values inside one bucket are stored is changed from a list to a balanced tree if a bucket contains 8 or more values, and it’s changed back to a list if, at some point, only 6 values are left in the bucket. This improves the performance to be O(log n).\n\nTo avoid having many buckets with multiple values, the capacity is doubled if 75% (the load factor) of the buckets become non-empty. The default value for the load factor is 75%, and the default initial capacity is 16. Both can be set in the constructor.\n\n6.5. Summary of put and get Operations\n\nLet’s summarize how the put and get operations work.\n\nWhen we add an element to the map, HashMap calculates the bucket. If the bucket already contains a value, the value is added to the list (or tree) belonging to that bucket. If the load factor becomes bigger than the maximum load factor of the map, the capacity is doubled.\n\nWhen we want to get a value from the map, HashMap calculates the bucket and gets the value with the same key from the list (or tree).\n\nIn this article, we saw how to use a HashMap and how it works internally. Along with ArrayList, HashMap is one of the most frequently used data structures in Java, so it’s very handy to have good knowledge of how to use it and how it works under the hood. Our article The Java HashMap Under the Hood covers the internals of HashMap in more detail."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/nio/charset/StandardCharsets.html",
        "document": "JavaScript is disabled on your browser.\n• Constant definitions for the standard . These charsets are guaranteed to be available on every implementation of the Java platform.\n• \n• \n• Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set\n\nSubmit a bug or feature \n\nFor further API reference and developer documentation, see Java SE Documentation. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.\n\n Copyright © 1993, 2025, Oracle and/or its affiliates. All rights reserved. Use is subject to license terms. Also see the documentation redistribution policy.\n\nScripting on this page tracks web page traffic, but does not change the content in any way."
    },
    {
        "link": "https://stackoverflow.com/questions/1001540/how-to-write-a-utf-8-file-with-java",
        "document": "I have some current code and the problem is its creating a 1252 codepage file, i want to force it to create a UTF-8 file\n\nCan anyone help me with this code, as i say it currently works... but i need to force the save on utf.. can i pass a parameter or something??\n\nthis is what i have, any help really appreciated"
    },
    {
        "link": "https://stackoverflow.com/questions/13350676/how-to-read-write-a-file-in-utf-8-in-java",
        "document": "First, you need to call (or at least call ) before you reopen the file for input. That's probably the main cause of your problems.\n\nThen, you shouldn't use or for this because it always uses the platform-default encoding (which is often not UTF-8). From the docs for :\n\nThe constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.\n\nYou have the same problem when using a . Replace this:\n\nwith something like this:"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/index.html?java/nio/charset/StandardCharsets.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://mkyong.com/java/how-to-write-utf-8-encoded-data-into-a-file-java",
        "document": "In Java, the OutputStreamWriter accepts a charset to encode the character streams into byte streams. We can pass a into the constructor to write data to a UTF-8 file.\n\nIn Java 7+, many File I/O and NIO writers start to accept as an argument, making write data to a UTF-8 file very easy, for examples:\n\nThis example shows a few ways to write some Chinese characters to a UTF-8 file."
    }
]