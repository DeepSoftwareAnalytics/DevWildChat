[
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/iterate-over-a-list-in-python",
        "document": "Python provides several ways to iterate over list. The simplest and the most common way to iterate over a list is to use a for loop. This method allows us to access each element in the list directly.\n\nExample: Print all elements in the list one by one using for loop.\n\nLet’s see other different ways to iterate over a list in Python.\n\nWe can use the range() method with for loop to traverse the list. This method allow us to access elements by their index, which is useful if we need to know the position of an element or modify the list in place.\n\nThis method is similar to the above method. Here we are using a while loop to iterate through a list. We first need to find the length of list using len(), then start at index 0 and access each item by its index then incrementing the index by 1 after each iteration.\n\nWe can also use the enumerate() function to iterate through the list. This method provides both the index (i) and the value (val) of each element during the loop.\n\nList comprehension is similar to for loop. It provides the shortest syntax for looping through list.\n\nNote: This method is not a recommended way to iterate through lists as it creates a new list (extra space).\n• None Iterate Over a List of Lists in Python\n• None Iterate through list without using the increment variable"
    },
    {
        "link": "https://stackoverflow.com/questions/6164443/iterating-through-a-list-with-an-if-statement",
        "document": "Python gives you loads of options to deal with such a situation. If you have example code we could narrow that down for you.\n\nOne option you could look at is the operator:\n\nYou could also check for the length of the filtered list:\n\nIf you are using a construct you can exit the loop early if you come across negative test:\n\nThe function above will return False on the first value that's 2 or lower, for example, while it'll return True only if all values were larger than 2."
    },
    {
        "link": "https://realpython.com/python-for-loop",
        "document": "Python’s loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak loops further with features like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• Python’s loop iterates over items in a data collection, allowing you to execute code for each item.\n• To iterate from to , you use the construct.\n• To repeat code a number of times without processing the data of an iterable, use the construct.\n• To do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\n\nIn this tutorial, you’ll gain practical knowledge of using loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\n\nGetting Started With the Python Loop In programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection. In Python, loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a loop is shown below: In this syntax, is the loop variable. In each iteration, this variable takes the value of the current item in , which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is a variable that holds the current item in the input iterable.\n• is a keyword that connects the loop variable with the iterable.\n• is a data collection that can be iterated over.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a list: In this example, is the loop variable, while the list is the target collection. Each time through the loop, takes on a successive item from . In this loop, the body consists of a call to that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it. However, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration. Note: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the special method. Similarly, iterators support the iterator protocol that’s based on the and special methods. Both iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in loops because they drive the iteration process. A deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial. You can also have a loop with multiple loop variables: In this loop, you have two loop variables, and . Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration. Sometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body: In this example, the target iterable is an empty list. The loop checks whether the iterable has items. If that’s the case, then the loop runs once for each item. If the iterable has no items, then the loop body doesn’t run, and the program’s execution flow jumps onto the statement after the loop. Now that you know the basic syntax of loops, it’s time to dive into some practical examples. In the following section, you’ll learn how to use loops with the most common built-in data collections in Python.\n\nWhen writing Python code, you’ll often need to iterate over built-in data types such as lists, tuples, strings, numeric ranges, dictionaries, and sets. All of them support iteration, and you can feed them into a loop. In the next sections, you’ll learn how to tackle this requirement in a Pythonic way. When it comes to iterating over sequence data types like lists, tuples, strings, and ranges, the iteration happens in the same order that the items appear in the sequence. Consider the following example where you iterate over the numbers in a list: In this example, the iteration goes through the list in the definition order, starting with and ending with . Note that to iterate over a sequence in Python, you don’t need to be aware of the index of each item as in other languages where loops often rely on indices. Often, you use plural nouns to name lists. This naming practice allows you to use singular nouns as the loop variable, making your code descriptive and readable. Note: To learn more about using lists, check out Python’s Data Type: A Deep Dive With Examples. You’ll note the same behavior with other built-in sequences: In these examples, you iterate over a tuple, string, and numeric range. Again, the loop traverses the sequence in the order of definition. Note: For more information about tuples, strings, and ranges, you can check out the following tutorials: Tuples are often used to represent rows of data. In the example above, the tuple holds data about a person. You can iterate over each field using a readable loop. When it comes to iterating over string objects, the loop lets you process the string on a character-by-character basis. Finally, iterating over a numeric range is sometimes a requirement, especially when you need to iterate a given number of times and need control over the consecutive index. When traversing dictionaries with a loop, you’ll find that you can iterate over the keys, values, and items of the dictionary at hand. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. You’ll have two different ways to iterate over the keys of a dictionary. You can either use: The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. While both approaches are equivalent, the first one is more commonly used, whereas the second might be more readable and explicit. In both loops, you can access the dictionary values using the keys: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. You can use the method to feed the loop when you need to iterate over the values of a dictionary: The method lets you traverse the values in the target dictionary. In this example, you iterate over team names one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, iterating over both keys and values in a Python dictionary is a common requirement. In this case, the recommended and most Pythonic approach is to use the method in a loop like the following: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable. When it comes to iterating over sets, you only have to keep in mind that sets are unordered data types. This means that looping in order isn’t guaranteed: As you can see, the loop goes through the elements of your set in a different order than they were inserted. So, you can’t rely on the order of the elements when traversing sets in Python.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. These features include the and statements and the clause, which you’ll learn about in the following sections. You’ll also learn that loops can be nested inside one another. This feature can be pretty useful in situations where you need to iterate over nested data structures like lists of lists. The statement immediately exits the loop and jumps to the first statement after the loop. For example, say that you want to write a loop to determine whether a number is in a list. To avoid unnecessary work, the loop should terminate once it finds the target value. You can do this with the statement: In this example, the statement jumps out of the loop as soon as the target number is found. The remaining values, and , aren’t processed. You can think of the statement as a way to short-circuit the loop execution once you’ve gotten the desired result. It’s important to note that it makes little sense to have statements outside conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The statement terminates the current iteration and proceeds to the next one. For example, if you have a list of numbers and only want to process the even ones, you can use a statement to skip the odd numbers: In this example, the code that processes the numbers is only reached if the number is even. Otherwise, the statement skips that code and jumps right into the next iteration. Again, it doesn’t make much sense to have a statement without wrapping it in a conditional. If you do so, the code after the statement will be unreachable and never run. In Python, loops can have an clause at the end. The clause will only run if the loop terminates because of the exhaustion of the input iterable. This feature is useful when you have a statement that can terminate the loop in certain situations. If the loop doesn’t break, then you can run additional code in the clause. To illustrate, say that you want to continue improving the loop that determines whether a number is in a list. You’d like to explicitly inform the user if the number isn’t in the list. You can do this with the clause: The clause won’t run if the loop breaks out with the statement. It only runs if the loop terminates normally, allowing you to inform the user that the target number wasn’t found. It doesn’t make sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. You can also have nested loops. In the example below, you create a multiplication table that shows the products of all combinations of integers up to ten using nested loops. The outer loop iterates over the numbers between and , and the inner loop calculates and prints the products: In this example, you use two nested loops. Together, they create a two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These represent the rows in the table, and you can see those numbers at the beginning of each row. In the inner loop, you calculate the products for the current by iterating from the itself up to its tenth multiple. Then, you format each product using the format specifier. This ensures the table is nicely aligned. By setting to an empty string, you skip the newline until the products on the current row are printed. After printing all products for a row, you use without arguments to move to the next row.\n\nWhen people switch from other programming languages to Python, they often write loops like they did in their previous language. This practice makes Python code look odd and hard to read. In the following sections, you’ll explore some looping techniques, practices, and tips that are considered Pythonic. These techniques can make your Python code look clearer, more elegant, and more efficient. Iterating With Indices: The Pythonic Way Sometimes, you need to use the indices of items when you iterate over a sequence with a Python loop. Up to this point, you’ve seen examples where you can access the items but don’t know their corresponding indices. To get both the item and its index, you can end up writing a loop like the one shown in the following example: This loop gets the job done, but it’s not as clean or readable as you’d expect from Python code. Fortunately, there’s a better way—the built-in function: The function takes an iterable as an argument and generates tuples of the form . Note that the loop reads almost like plain English, which makes your code way more Pythonic than the previous version using . Note: To learn more about working with , check out the Python : Simplify Loops That Need Counters tutorial. The function also takes an optional argument called that lets you tweak the initial value. This feature is useful when you need to create counts. Consider the following example that mimics an option menu for a command-line application: In this example, instead of using to produce zero-based indices, you start the count at . From the end user’s perspective, starting the menu at is the natural way to go. Looping Over Several Iterables in Parallel Looping through two or more iterables in parallel may be another common task you encounter in Python programming. To do this, you can use the built-in function, which takes two or more iterables and yields tuples that combine items from each iterable. Note: To learn more about , check out the Using the Python zip() Function for Parallel Iteration tutorial. Consider the following toy example: In this example, you use to create an iterator that produces tuples of the form . In this case, the values are taken from , and the values are taken from . There may be times when you need to iterate over multiple iterables sequentially in a single loop. In such cases, you can use the function from Python’s module. Note: To learn more about the module and the tools it provides, check out the Python By Example tutorial. For example, say that you have several lists of numbers and want to calculate the square of each number in all lists. You can use as follows: This loops over all three lists in sequence and prints the square of each value. You can also use to work through a list of lists. Say that you, again, need to process each value in a sequence and calculate its square: In this example, you use to iterate over the rows of the matrix. To feed the rows into , you use the unpacking operator ( ). Inside the loop, you calculate and print the square of each value. Using , like in this example, essentially flattens the matrix into a single iterable, helping you avoid a nested loop, which can be difficult to read and understand in some contexts. Iteration is all about repeating some fragment of code multiple times. As you’ve learned so far, loops are designed to repeat a given set of actions on the items of an iterable. However, you can also use this type of loop to quickly iterate a specific number of times. This is useful when you need to repeat a bunch of statements, but they don’t operate on the items of an iterable. Here’s a fun example about Penny and Sheldon to illustrate this: This loop runs three times and repeats a series of statements that don’t operate on any iterable. Note that the loop variable is a single underscore character in this example. This variable name communicates that you don’t need to use the loop variable inside the loop. It’s a throwaway variable. With this looping construct that takes advantage of , you have full control over the number of times your code runs. Iterating over the items of an iterable in reverse or sorted order is also a common requirement in programming. To achieve this, you can combine a loop with the built-in or function, respectively. Note: To learn more about and , check out the following tutorials:\n• Reverse Strings in Python: , Slicing, and More\n• How to Use and in Python For example, say that you’re working on a text editor and want to implement a basic Undo option. You can implement it with the function and a loop like the following: In this example, you have a list of hypothetical user actions in a text editor. The actions are stored in a list from oldest to newest. To implement the Undo operation, you need to reverse the actions, which you do with . To iterate in sorted order, say that you have a dictionary that maps student names to their corresponding average grades. You need to create a quick report and want to sort the data from highest to lowest grades. For this, you can do something like the following: The function returns a list of sorted values. In this example, you sort the dictionary by its values in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . You also set the argument to so that the function stores the data in reverse order. In this case, this means that the grades are ordered in descending order. The loop iterates over the sorted data and generates a nicely formatted report using an f-string with a custom format specifier.\n\nWhen working with loops in your Python code, you may encounter some issues related to incorrect ways to use this tool. Some of the most common bad practices and incorrect assumptions include:\n• Modifying the loop collection or iterable during iteration\n• Changing the loop variable to affect the underlying collection\n• Ignoring possible exceptions that may occur In the following sections, you’ll explore these pitfalls and how to avoid them in your loops. Python has mutable collections, such as lists and dictionaries, that you can modify in place. You may want to change a list while looping over it. In this situation, you need to distinguish between safe and unsafe changes. For example, say that you have a list of names and want to convert them into uppercase. You may think of doing something like the following: In this example, you only change the existing items in the list without adding or removing any. This operation is safe. However, modifying a mutable iterable like a list while iterating over it always raises a warning. Issues may appear when you add or remove items from a list while iterating over it. To understand why this is best avoided, say that you want to remove all the even numbers from a list. You might write the following code: After running the loop, some even numbers remain, even though you expected the list to be empty. On the first iteration, is removed, and the list shifts left, becoming . The loop then jumps to the next item, skipping and processing instead. Then is removed, and the list shifts again, becoming . The iteration ends before reaching . When you need to resize a list during iteration like in the example above, it’s recommended to create a copy of the list: The slicing operator ( ) with no indices creates a copy of the original list for iteration purposes. The loop traverses the copy while removing values from the original list. In some cases, creating a copy of the input list isn’t enough. Say that on top of removing even numbers, you want to calculate the square of odd numbers. You might modify the previous loop as shown in the following code: This time, you use to generate index-item pairs. Then, you think of using the index to update the value of a given item. However, the code fails with a exception. Creating a copy of the input list isn’t enough in this case. You’d have to make a separate list to store the result: In this new loop implementation, you’re using a new list to store the result. Because of this, you don’t have to remove items anymore. You add the square values to the end of the new list using the method. Python doesn’t allow you to add or remove items from a dictionary while you’re iterating through it: If you try to expand or shrink a dictionary during iteration, you get a exception. Again, you can work around this by creating a copy of the dictionary using the method or by building a new dictionary with the resulting data. Changing the loop variable in the loop body doesn’t have an effect on the original data: In this example, the highlighted line changes the loop variable, . This change doesn’t affect the original data in your list of names. The loop variable is just a temporary reference to the current item in the iterable, and reassigning it doesn’t affect the loop iterable. If an exception occurs in a loop body and isn’t handled, the loop will terminate prematurely, skipping subsequent iterations. This result can generate unexpected issues, especially when you rely on the loop to process data, perform logging, or run cleanup actions in each iteration. As an example, say that you want to process some text files in a loop: : [Errno 2] No such file or directory: 'file1.txt' In this example, none of the files exist in your working directory. The loop tries to process the first file and fails with a exception. Because the exception wasn’t handled properly, the loop terminates in the first iteration, skipping the rest of the files in the list. To avoid this behavior, you need to catch and handle the exception: In this new implementation, the loop catches any exception and prints an error message to the screen. The loop runs entirely without abrupt interruptions."
    },
    {
        "link": "https://wiki.python.org/moin/ForLoop",
        "document": "There are two ways to create loops in Python: with the for-loop and the while-loop.\n\nWhen do I use for loops\n\nfor loops are used when you have a block of code which you want to repeat a fixed number of times. The for-loop is always used in combination with an iterable object, like a list or a range. The Python for statement iterates over the members of a sequence in order, executing the block each time. Contrast the for statement with the ''while'' loop, used when a condition needs to be checked each iteration or to repeat a block of code forever. For example:\n\nFor loop from 0 to 2, therefore running 3 times.\n\nWhile loop from 1 to infinity, therefore running forever.\n\nWhen running the above example, you can stop the program by pressing ctrl+c at the same time. As you can see, these loop constructs serve different purposes. The for loop runs for a fixed amount of times, while the while loop runs until the loop condition changes. In this example, the condition is the boolean True which will never change, so it will run forever.\n\nHow do they work?\n\nIf you've done any programming before, you have undoubtedly come across a for loop or an equivalent to it. Many languages have conditions in the syntax of their for loop, such as a relational expression to determine if the loop is done, and an increment expression to determine the next loop value. In Python, this is controlled instead by generating the appropriate sequence. Basically, any object with an iterable method can be used in a for loop. Even strings, despite not having an iterable method - but we'll not get on to that here. Having an iterable method basically means that the data can be presented in list form, where there are multiple values in an orderly fashion. You can define your own iterables by creating an object with next() and iter() methods. This means that you'll rarely be dealing with raw numbers when it comes to for loops in Python - great for just about anyone!\n\nWhen you have a block of code you want to run x number of times, then a block of code within that code which you want to run y number of times, you use what is known as a \"nested loop\". In Python, these are heavily used whenever someone has a list of lists - an iterable object within an iterable object.\n\nLike the while loop, the for loop can be made to exit before the given object is finished. This is done using the break statement, which will immediately drop out of the loop and continue execution at the first statement after the block. You can also have an optional else clause, which will run should the for loop exit cleanly - that is, without breaking.\n\nYour own range generator using yield\n\nThe ''range'' function is seen so often in for statements that you might think range is part of the for syntax. It is not: it is a Python built-in function that returns a sequence following a specific pattern (most often sequential integers), which thus meets the requirement of providing a sequence for the for statement to iterate over. Since for can operate directly on sequences, there is often no need to count. This is a common beginner construct (if they are coming from another language with different loop syntax):\n\nIt can be replaced with this:\n\nConsider to be a flag for possibly non-optimal Python coding.\n\nIf you'd like to learn more, try these links:\n• None Python for loop and while loop tutorial with interactive code examples"
    },
    {
        "link": "https://stackoverflow.com/questions/62683076/is-there-a-way-to-do-conditionals-inside-python-3-for-loops",
        "document": "In common with several other answers, here is how I would actually translate that code:\n\nI would also consider using a loop, which might look something like this:\n\nBut having considered both, I prefer the while loop. And in practice I very rarely actually need a flag defined across a loop like that. Normally you can either from the loop immediately you detect the condition that would cause you to set the flag, or else use logic like this:\n\nThe need for boolean \"break\" flags is mostly (not wholly) a result of trying to write all your loops with no in them, but there's no particular benefit to doing that.\n\nIt might be possible to salvage the loop, or at least learn a few things about Python, by playing around with other ways to write what comes after . Like could be , but that's breathtakingly ugly in its own way. Or is always a warning sign, and in this case could be replaced with . Or you can use to change the exponentiation back to multiplication, but it's unlikely to be worth it. Or you can write a generator function, but that's a chunk more boilerplate.\n\nSupposing I know that the base-2 logarithm of 20 can only be so big, but I don't want to make myself a hostage to stupid off-by-one errors, I could write something like:\n\nOr to get rid of all of the \"clever\" stuff:\n\nBut again, this isn't really solving the basic issue that loops are intended for when you have an iterable containing the right values, and in Python you need to pull several things together to come up with the right iterable for this case (especially if you want to write 20 rather than the logarithm of 20). And that's even before you deal with the flag. So, in general you use a loop when you have something to iterate over, or can easily produce something to iterate over, and use a loop for more general looping based on mutating local variables.\n\nFrankly for those specific numbers you might as well write and have done with it!"
    },
    {
        "link": "https://stackoverflow.com/questions/40564950/python-3-using-multiple-if-statements-inside-a-for-loop",
        "document": "I have searched and found nothing that suits my needs.\n\nI have three loops that each has an conditions inside it. Here is the code:\n\nIs there a more efficient way of doing this? I was thinking of the operator like so:\n\nCan any one suggest the best or most efficient way of doing this as apposed to iterating three times over the same list?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://data36.com/python-nested-loops-if-statements-combined-data-sciene",
        "document": "Last time I wrote about Python For Loops and If Statements. Today we will talk about how to combine them. In this article, I’ll show you – through a few practical examples – how to combine a for loop with another for loop and/or with an if statement!\n\nNote: This is a hands-on tutorial. I highly recommend doing the coding part with me – and if you have time, solving the exercises at the end of the article! If you haven’t done so yet, please work through these articles first:\n• How to install Python, R, SQL and bash to practice data science!\n\nNote 2: On mobile the line breaks of the code snippets might look tricky. But if you copy-paste them into your Jupyter Notebook, you will see the actual line breaks much clearer!\n\nFor loop within a for loop – aka the nested for loop\n\nThe more complicated the data project you are working on, the higher the chance that you will bump into a situation where you have to use a nested for loop. This means that you will run an iteration, then another iteration inside that iteration.\n\nLet’s say you have nine TV show titles put into three categories: comedies, cartoons, dramas. These are presented in a nested Python list (“lists in a list”):\n\nYou want to count the characters in all these titles and print the results one by one to your screen, in this format:\n\nHow would you do that? Since you have three lists in your main list, to get the movie titles, you have to iterate through your list — and inside that list, through every sublist, too:\n\nNote: remember is a Python function that results in an integer. To put this integer into a “printable” sentence, we have to turn it into a string first. I wrote about this in the previous Python For Loops tutorial.\n\nI know, Python for loops can be difficult to understand for the first time… Nested for loops are even more difficult. If you have trouble understanding what exactly is happening above, get a pen and a paper and try to simulate the whole script as if you were the computer — go through your loop step by step and write down the results.\n\nOne more thing:\n\nSyntax! The rules are the same ones you learned when we discussed simple for loops — the only thing that I’d like to emphasize, and that you should definitely watch out for, is the indentations. Using proper indentations is the only way how you can let Python know that in which for loop (the inner or the outer) you would like to apply your block of code. Just test out and try to find the differences between these three examples:\n\nIf statement within a for loop\n\nInside a for loop, you can use if statements as well.\n\nLet me use one of the most well-known examples of the exercises that you might be given as the opening question in a junior data scientist job interview.\n\nThe task is:\n\nGo through all the numbers up until 99. Print ‘fizz’ for every number that’s divisible by 3, print ‘buzz’ for every number divisible by 5, and print ‘fizzbuzz’ for every number divisible by 3 and by 5! If the number is not divisible either by 3 or 5, print a dash (‘-‘)!\n\nAs you can see, an if statement within a for loop is perfect to evaluate a list of numbers in a range (or elements in a list) and put them into different buckets, tag them, or apply functions on them – or just simply print them.\n\nAgain: when you use an if statement within a for loop, be extremely careful with the indentations because if you misplace them, you can get errors or fake results!\n\nThere is a special control flow tool in Python that comes in handy pretty often when using if statements within for loops. And this is the statement.\n\nCan you find the first 7-digit number that’s divisible by 137? (The first one and only the first one.)\n\nThis loop takes every 137th number ( ) and it checks during each iteration whether the number has 7 digits or not ( ) == 7). Once it gets to the the first 7-digit number, the if statement will be and two things happen:\n• –» The number is printed to the screen.\n• breaks out of the for loop, so we can make sure that the first 7-digit number was also the last 7-digit number that was printed on the screen.\n\nLearn more about the statement (and its twin brother: the statement) in the original Python3 documentation: here.\n\nNote: you can solve this task more elegantly with a while loop. However, I haven’t written a while loop tutorial yet, which is why I went with the for loop + solution!\n\nIt’s time to test whether you have managed to master the if statement, the for loops and the combination of these two! Let’s try to solve this small test assignment!\n\nCreate a Python script that finds out your age in a maximum of 8 tries! The script can ask you only one type of question: guessing your age! (e.g. “Are you 67 years old?”) And you can answer only one of these three options:\n\nBased on your answer the computer can come up with another guess until it finds out your exact age.\n\nNote: to solve this task, you will have to learn a new function, too. That’s the function! More info: here.\n\nNote 1: One can solve the task with a while loop, too. Again: since I haven’t written about while loops yet, I’ll show you the for loop solution.\n\n Note 2: If you have an alternative solution, please do not hesitate to share it with me via email!\n\nMy logic goes:\n\nSTEP 1) I set a range between 0 and 100 and I assume that the age of the “player” will be between these two values.\n\n \n\n\n\nSTEP 2) The script always asks the middle value of this range (for the first try it’s ):\n\nSTEP 3) Once we have the “player’s” answer, there are four possible scenarios:\n• If the guessed age is correct, then the script ends and it returns some answer.\n• If the answer is “less”, then we start the iteration over – but before that we set the maximum value of the age-range to the guessed age. (So in the second iteration the script will guess the middle value of 0 and 50.)\n• We do the same for the “more” answer – except that in this case we change the minimum (and not the the maximum) value:\n• And eventually we handle the wrong answers and the typos:\n\nDid you find a better solution?\n\nShare it with me – drop an email and I’ll review it for you!\n\nNow you’ve got the idea of:\n• for loops and if statements combined.\n\nThey are not necessarily considered to be Python basics; this is more like a transition to the intermediate level. Using them requires a solid understanding of Python3’s logic – and a lot of practicing, too.\n\nThere are only two episodes left from the Python for Data Science Basics tutorial series! Keep it going and continue with the Python syntax essentials!\n• If you want to learn more about how to become a data scientist, take my 50-minute video course: How to Become a Data Scientist. (It’s free!)\n• Also check out my 6-week online course: The Junior Data Scientist’s First Month video course."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/qmvldi/is_it_good_practice_to_put_a_loop_in_an_if",
        "document": "Is it good practice to put a loop in an if statement?\n\nI dont have any specific examples it's just something I was thinking about.\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    }
]