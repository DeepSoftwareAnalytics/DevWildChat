[
    {
        "link": "https://truenas.com/community/threads/can-i-mount-an-ntfs-drive-with-data-on-it.9684",
        "document": "It wasn't obvious you were a noob from the forum you posted in but the post itself. No worries, you'll still get help.\n\n \n\n Your best bet is to build the zpool and then copy the contents over. This obviously isn't optimal for you since I'm betting the drives with the data are also the drives you want in the zpool. Maybe you can borrow a few hard drives from some friends. NTFS is supported in FreeNAS, but it is only intended to allow you to copy data. NTFS is pretty unreliable in FreeBSD so you definitely shouldn't use it as the permanent file system. But from your post I don't think you were going to do that anyway."
    },
    {
        "link": "https://truenas.com/community/threads/how-do-i-mount-a-ntfs-drive-so-i-can-copy-the-data-to-an-empty-drive-in-freenas.1284",
        "document": "Due to limitations with 3TB drives on legacy operating systems, I am now forced to move on to a different platform for my file server. FreeNAS fit the bill, but since importing NTFS drive wont work in the latest stable build, I figured I could mount the NTFS drive that I already have and simply move over the existing data to an already installed ZFS drive. But I can't find any documentation or forum posts about how do go about to do it.I am a Linux user so I'm unfamiliar on hoe BSD handles thses things, or in this case, specifically FreeNAS. I tried to create a new directory in /mnt named ntfs and then do aBut it failsHelp would be greatly appreciatedAlso, I assume that once the drive is mounted, that I could d o a cp -R /ntfs/* /the_empty_drive"
    },
    {
        "link": "https://forums.freebsd.org/threads/mounting-internal-ntfs-storage-drive.68009",
        "document": "I've used Linux(Debian,Fedora) mostly over the years, am not experienced with the BSDs so much, recently install TrueOS. I've \"googled-for-answers\" to determine how to mount the internal storage drive, which is formatted as NTFS. I've install ntfs-3g, fusefs-ntfs and tried to mount the drivewith no success.Looking at the output of \"gpart show\" I noticed the TrueOS disk is GPT and the NTFS storage disk is MBRDoes that explain the problem, or am I missing something further required, for mounting the storage partition?"
    },
    {
        "link": "https://truenas.com/community/threads/mounting-external-ntfs-formatted-usb-drive.204",
        "document": "The method described in that thread has been discussed here in the FreeNAS 8 forums and is also in the FAQ here. There is no need to load fusefs because FreeNAS already loads the NTFS driver in the kernel at boot. If you look at the FAQ here you can see how to mount it from the command line. The thing that bothers me is that the GUI gives the same useless error when you try and mount NTFS, MSDOSFS/FAT, and UFS as recently reported by another user. It was reported by one of the development team that it was going to be fixed or had been fixed around beta-4. During the wait between beta-4 and the release of 8.01 none of the RC's fixed the problem. If I get time I will try and look at the source code and see what the problem is. Look at the Unofficial FAQ in my signature below for methods to mount NTFS and other filesystems from the command line.EDIT: I should also mention I opened a ticket for this around beta-3. I'll update with the link to the ticket here so people can add to it and maybe it will receive some attention. Actually there are several tickets for this problem:This one actually says that it was fixed:"
    },
    {
        "link": "https://forums.freebsd.org/threads/how-to-mount-ntfs-during-freebsd-installation-process.71619",
        "document": "The only way you might be able to pull this off is to packages in txz format on another machine.\n\n Then put them on a USB stick for use with your FreeBSD install.\n\n At the end of the installation you can use a post install shell. Mount your USB stick with packages in txz format.\n\n From there you can use pkg-static to bootstrap pkg.\n\n Then once you get pkg installed you can install fusefs-ntfs.\n\n This should work for the post install shell.\n\n I do not know if it will work with some of the earlier shells in the install process."
    },
    {
        "link": "https://docs.freebsd.org/en/books/handbook/disks",
        "document": "Many external storage solutions, such as hard drives, USB thumbdrives, and CD and DVD burners, use the Universal Serial Bus (USB). FreeBSD provides support for USB 1.x, 2.0, and 3.0 devices. USB 3.0 support is not compatible with some hardware, including Haswell (Lynx point) chipsets. If FreeBSD boots with a message, disable xHCI/USB3 in the system BIOS. Support for USB storage devices is built into the GENERIC kernel. For a custom kernel, be sure that the following lines are present in the kernel configuration file: device scbus # SCSI bus (required for ATA/SCSI) device da # Direct Access (disks) device pass # Passthrough device (direct ATA/SCSI access) device uhci # provides USB 1.x support device ohci # provides USB 1.x support device ehci # provides USB 2.0 support device xhci # provides USB 3.0 support device usb # USB Bus (required) device umass # Disks/Mass storage - Requires scbus and da device cd # needed for CD and DVD burners FreeBSD uses the umass(4) driver which uses the SCSI subsystem to access USB storage devices. Since any USB device will be seen as a SCSI device by the system, if the USB device is a CD or DVD burner, do not include in a custom kernel configuration file. The rest of this section demonstrates how to verify that a USB storage device is recognized by FreeBSD and how to configure the device so that it can be used. To test the USB configuration, plug in the USB device. Use to confirm that the drive appears in the system message buffer. It should look something like this: umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0 umass0: SCSI over Bulk-Only quirks 0x0100 umass0:4:0:-1: Attached to scbus4 da0 at umass-sim0 bus 0 scbus4 target 0 lun 0 da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device da0: Serial Number WD-WXE508CAN263 da0: 40.000MB/s transfers da0: 152627MB 312581808 512 byte sectors: 255H 63S/T 19457C da0: 0x2<NO_6_BYTE> The brand, device node (da0), speed, and size will differ according to the device. Since the USB device is seen as a SCSI one, can be used to list the USB storage devices attached to the system: Alternately, can be used to list the device. Refer to usbconfig(8) for more information about this command. If the device has not been formatted, refer to Adding Disks for instructions on how to format and create partitions on the USB drive. If the drive comes with a file system, it can be mounted by using the instructions in “Mounting and Unmounting File Systems”. Allowing untrusted users to mount arbitrary media, by enabling as described below, should not be considered safe from a security point of view. Most file systems were not built to safeguard against malicious devices. To make the device mountable as a normal user, one solution is to make all users of the device a member of the group using pw(8). Next, ensure that is able to read and write the device by adding these lines to /etc/devfs.rules: If internal SCSI disks are also installed in the system, change the second line as follows: This will exclude the first three SCSI disks (da0 to da2) from belonging to the group. Replace 3 with the number of internal SCSI disks. Refer to devfs.rules(5) for more information about this file. Next, enable the ruleset in /etc/rc.conf: Then, instruct the system to allow regular users to mount file systems by adding the following line to /etc/sysctl.conf: Since this only takes effect after the next reboot, use to set this variable now: The final step is to create a directory where the file system is to be mounted. This directory needs to be owned by the user that is to mount the file system. One way to do that is for to create a subdirectory owned by that user as /mnt/username. In the following example, replace username with the login name of the user and usergroup with the user’s primary group: Suppose a USB thumbdrive is plugged in, and a device /dev/da0s1 appears. If the device is formatted with a FAT file system, the user can mount it using: Before the device can be unplugged, it must be unmounted first: After device removal, the system message buffer will show messages similar to the following: USB devices can be automatically mounted by uncommenting this line in /etc/auto_master: Then add these lines to /etc/devd.conf: Reload the configuration if autofs(5) and devd(8) are already running: autofs(5) can be set to start at boot by adding this line to /etc/rc.conf: autofs(5) requires devd(8) to be enabled, as it is by default. Each file system that can be automatically mounted appears as a directory in /media/. The directory is named after the file system label. If the label is missing, the directory is named after the device node. The file system is transparently mounted on the first access, and unmounted after a period of inactivity. Automounted drives can also be unmounted manually: This mechanism is typically used for memory cards and USB memory sticks. It can be used with any block device, including optical drives or iSCSILUNs.\n\nCompact Disc (CD) media provide a number of features that differentiate them from conventional disks. They are designed so that they can be read continuously without delays to move the head between tracks. While CD media do have tracks, these refer to a section of data to be read continuously, and not a physical property of the disk. The ISO 9660 file system was designed to deal with these differences. The FreeBSD Ports Collection provides several utilities for burning and duplicating audio and data CDs. This chapter demonstrates the use of several command line utilities. For CD burning software with a graphical utility, consider installing the sysutils/xcdroast or sysutils/k3b packages or ports. The GENERIC kernel provides support for SCSI, USB, and ATAPICD readers and burners. If a custom kernel is used, the options that need to be present in the kernel configuration file vary by the type of device. For a SCSI burner, make sure these options are present: device scbus # SCSI bus (required for ATA/SCSI) device da # Direct Access (disks) device pass # Passthrough device (direct ATA/SCSI access) device cd # needed for CD and DVD burners For a USB burner, make sure these options are present: device scbus # SCSI bus (required for ATA/SCSI) device da # Direct Access (disks) device pass # Passthrough device (direct ATA/SCSI access) device cd # needed for CD and DVD burners device uhci # provides USB 1.x support device ohci # provides USB 1.x support device ehci # provides USB 2.0 support device xhci # provides USB 3.0 support device usb # USB Bus (required) device umass # Disks/Mass storage - Requires scbus and da For an ATAPI burner, make sure these options are present: device ata # Legacy ATA/SATA controllers device scbus # SCSI bus (required for ATA/SCSI) device pass # Passthrough device (direct ATA/SCSI access) device cd # needed for CD and DVD burners On FreeBSD versions prior to 10.x, this line is also needed in the kernel configuration file if the burner is an ATAPI device: Alternately, this driver can be loaded at boot time by adding the following line to /boot/loader.conf: This will require a reboot of the system as this driver can only be loaded at boot time. To verify that FreeBSD recognizes the device, run and look for an entry for the device. On systems prior to 10.x, the device name in the first line of the output will be acd0 instead of cd0. % dmesg | cd0 at ahcich1 bus 0 scbus1 target 0 lun 0 cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device cd0: Serial Number M3OD3S34152 cd0: 150.000MB/s transfers SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed In FreeBSD, can be used to burn CDs. This command is installed with the sysutils/cdrtools package or port. While has many options, basic usage is simple. Specify the name of the ISO file to burn and, if the system has multiple burner devices, specify the name of the device to use: To determine the device name of the burner, use which might produce results like this: Locate the entry for the CD burner and use the three numbers separated by commas as the value for . In this case, the Yamaha burner device is , so the appropriate input to specify that device is . Refer to the manual page for for other ways to specify this value and for information on writing audio tracks and controlling the write speed. Alternately, run the following command to get the device address of the burner: Use the numeric values for , , and . For this example, is the device name to use. In order to produce a data CD, the data files that are going to make up the tracks on the CD must be prepared before they can be burned to the CD. In FreeBSD, sysutils/cdrtools installs , which can be used to produce an ISO 9660 file system that is an image of a directory tree within a UNIX® file system. The simplest usage is to specify the name of the ISO file to create and the path to the files to place into the ISO 9660 file system: This command maps the file names in the specified path to names that fit the limitations of the standard ISO 9660 file system, and will exclude files that do not meet the standard for ISO file systems. A number of options are available to overcome the restrictions imposed by the standard. In particular, enables the Rock Ridge extensions common to UNIX® systems and enables Joliet extensions used by Microsoft® systems. For CDs that are going to be used only on FreeBSD systems, can be used to disable all filename restrictions. When used with , it produces a file system image that is identical to the specified FreeBSD tree, even if it violates the ISO 9660 standard. The last option of general use is . This is used to specify the location of a boot image for use in producing an \"El Torito\" bootable CD. This option takes an argument which is the path to a boot image from the top of the tree being written to the CD. By default, creates an ISO image in \"floppy disk emulation\" mode, and thus expects the boot image to be exactly 1200, 1440 or 2880 KB in size. Some boot loaders, like the one used by the FreeBSD distribution media, do not use emulation mode. In this case, should be used. So, if /tmp/myboot holds a bootable FreeBSD system with the boot image in /tmp/myboot/boot/cdboot, this command would produce /tmp/bootable.iso: The resulting ISO image can be mounted as a memory disk with: One can then verify that /mnt and /tmp/myboot are identical. There are many other options available for to fine-tune its behavior. Refer to mkisofs(8) for details. It is possible to copy a data CD to an image file that is functionally equivalent to the image file created with . To do so, use dd with the device name as the input file and the name of the ISO to create as the output file: The resulting image file can be burned to CD as described in Burning a CD. Once an ISO has been burned to a CD, it can be mounted by specifying the file system type, the name of the device containing the CD, and an existing mount point: Since assumes that a file system is of type , an error will occur if is not included when mounting a data CD. While any data CD can be mounted this way, disks with certain ISO 9660 extensions might behave oddly. For example, Joliet disks store all filenames in two-byte Unicode characters. If some non-English characters show up as question marks, specify the local charset with . For more information, refer to mount_cd9660(8). In order to do this character conversion with the help of , the kernel requires the cd9660_iconv.ko module to be loaded. This can be done either by adding this line to loader.conf: and then rebooting the machine, or by directly loading the module with . Occasionally, will be displayed when trying to mount a data CD. This usually means that the CD drive has not detected a disk in the tray, or that the drive is not visible on the bus. It can take a couple of seconds for a CD drive to detect media, so be patient. Sometimes, a SCSICD drive may be missed because it did not have enough time to answer the bus reset. To resolve this, a custom kernel can be created which increases the default SCSI delay. Add the following option to the custom kernel configuration file and rebuild the kernel using the instructions in “Building and Installing a Custom Kernel”: This tells the SCSI bus to pause 15 seconds during boot, to give the CD drive every possible chance to answer the bus reset. It is possible to burn a file directly to CD, without creating an ISO 9660 file system. This is known as burning a raw data CD and some people do this for backup purposes. This type of disk can not be mounted as a normal data CD. In order to retrieve the data burned to such a CD, the data must be read from the raw device node. For example, this command will extract a compressed tar file located on the second CD device into the current working directory: In order to mount a data CD, the data must be written using . To duplicate an audio CD, extract the audio data from the CD to a series of files, then write these files to a blank CD. Duplicating an Audio CD describes how to duplicate and burn an audio CD. If the FreeBSD version is less than 10.0 and the device is ATAPI, the module must be first loaded using the instructions in Supported Devices.\n• None The sysutils/cdrtools package or port installs . This command can be used to extract all of the audio tracks, with each track written to a separate WAV file in the current working directory: A device name does not need to be specified if there is only one CD device on the system. Refer to the manual page for instructions on how to specify a device and to learn more about the other options available for this command.\n• None Use to write the .wav files: Make sure that 2,0 is set appropriately, as described in Burning a CD.\n\nCompared to the CD, the DVD is the next generation of optical media storage technology. The DVD can hold more data than any CD and is the standard for video publishing. Five physical recordable formats can be defined for a recordable DVD:\n• None DVD-R: This was the first DVD recordable format available. The DVD-R standard is defined by the DVD Forum. This format is write once.\n• None DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can be rewritten about 1000 times.\n• None DVD-RAM: This is a rewritable format which can be seen as a removable hard drive. However, this media is not compatible with most DVD-ROM drives and DVD-Video players as only a few DVD writers support the DVD-RAM format. Refer to Using a DVD-RAM for more information on DVD-RAM use.\n• None DVD+RW: This is a rewritable format defined by the DVD+RW Alliance. A DVD+RW can be rewritten about 1000 times.\n• None DVD+R: This format is the write once variation of the DVD+RW format. A single layer recordable DVD can hold up to 4,700,000,000 bytes which is actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes. A distinction must be made between the physical media and the application. For example, a DVD-Video is a specific file layout that can be written on any recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW. Before choosing the type of media, ensure that both the burner and the DVD-Video player are compatible with the media under consideration. To perform DVD recording, use growisofs(1). This command is part of the sysutils/dvd+rw-tools utilities which support all DVD media types. These tools use the SCSI subsystem to access the devices, therefore ATAPI/CAM support must be loaded or statically compiled into the kernel. This support is not needed if the burner uses the USB interface. Refer to USB Storage Devices for more details on USB device configuration. DMA access must also be enabled for ATAPI devices, by adding the following line to /boot/loader.conf: Before attempting to use dvd+rw-tools, consult the Hardware Compatibility Notes. For a graphical user interface, consider using sysutils/k3b which provides a user friendly interface to growisofs(1) and many other burning tools. Since growisofs(1) is a front-end to mkisofs, it will invoke mkisofs(8) to create the file system layout and perform the write on the DVD. This means that an image of the data does not need to be created before the burning process. To burn to a DVD+R or a DVD-R the data in /path/to/data, use the following command: In this example, is passed to mkisofs(8) to create an ISO 9660 file system with Joliet and Rock Ridge extensions. Refer to mkisofs(8) for more details. For the initial session recording, is used for both single and multiple sessions. Replace /dev/cd0, with the name of the DVD device. Using indicates that the disk will be closed and that the recording will be unappendable. This should also provide better media compatibility with DVD-ROM drives. To burn a pre-mastered image, such as imagefile.iso, use: The write speed should be detected and automatically set according to the media and the drive being used. To force the write speed, use . Refer to growisofs(1) for example usage. In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid file system must be created by passing to mkisofs(8) and all related programs, such as growisofs(1). This is required only when creating an ISO image file or when writing files directly to a disk. Since a disk created this way must be mounted as an UDF file system with mount_udf(8), it will be usable only on an UDF aware operating system. Otherwise it will look as if it contains corrupted files. To create this type of ISO file: When an ISO image already contains large files, no additional options are required for growisofs(1) to burn that image on a disk. Be sure to use an up-to-date version of sysutils/cdrtools, which contains mkisofs(8), as an older version may not contain large files support. If the latest version does not work, install sysutils/cdrtools-devel and read its mkisofs(8). A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-UDF) specifications. Since DVD-Video presents a specific data structure hierarchy, a particular program such as multimedia/dvdauthor is needed to author the DVD. If an image of the DVD-Video file system already exists, it can be burned in the same way as any other image. If was used to make the DVD and the result is in /path/to/video, the following command should be used to burn the DVD-Video: is passed to mkisofs(8) to instruct it to create a DVD-Video file system layout. This option implies the growisofs(1) option. Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use. It is recommended to let growisofs(1) take care of this automatically whenever appropriate. However, it is possible to use to format the DVD+RW: Only perform this operation once and keep in mind that only virgin DVD+RW medias need to be formatted. Once formatted, the DVD+RW can be burned as usual. To burn a totally new file system and not just append some data onto a DVD+RW, the media does not need to be blanked first. Instead, write over the previous recording like this: The DVD+RW format supports appending data to a previous recording. This operation consists of merging a new session to the existing one as it is not considered to be multi-session writing. growisofs(1) will grow the ISO 9660 file system present on the media. For example, to append data to a DVD+RW, use the following: The same mkisofs(8) options used to burn the initial session should be used during next writes. Use for better media compatibility with DVD-ROM drives. When using DVD+RW, this option will not prevent the addition of data. A DVD-RW accepts two disc formats: incremental sequential and restricted overwrite. By default, DVD-RW discs are in sequential format. A virgin DVD-RW can be directly written without being formatted. However, a non-virgin DVD-RW in sequential format needs to be blanked before writing a new initial session. A full blanking using will take about one hour on a 1x media. A fast blanking can be performed using , if the DVD-RW will be recorded in Disk-At-Once (DAO) mode. To burn the DVD-RW in DAO mode, use the command: Since growisofs(1) automatically attempts to detect fast blanked media and engage DAO write, should not be required. One should instead use restricted overwrite mode with any DVD-RW as this format is more flexible than the default of incremental sequential. To write data on a sequential DVD-RW, use the same instructions as for the other DVD formats: To append some data to a previous recording, use with growisofs(1). However, if data is appended on a DVD-RW in incremental sequential mode, a new session will be created on the disc and the result will be a multi-session disc. A DVD-RW in restricted overwrite format does not need to be blanked before a new initial session. Instead, overwrite the disc with . It is also possible to grow an existing ISO 9660 file system written on the disc with . The result will be a one-session DVD. To put a DVD-RW in restricted overwrite format, the following command must be used: To change back to sequential format, use: Few DVD-ROM drives support multi-session DVDs and most of the time only read the first session. DVD+R, DVD-R and DVD-RW in sequential format can accept multiple sessions. The notion of multiple sessions does not exist for the DVD+RW and the DVD-RW restricted overwrite formats. Using the following command after an initial non-closed session on a DVD+R, DVD-R, or DVD-RW in sequential format, will add a new session to the disc: Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode will append data while merging the new session to the existing one. The result will be a single-session disc. Use this method to add data after an initial write on these types of media. Since some space on the media is used between each session to mark the end and start of sessions, one should add sessions with a large amount of data to optimize media space. The number of sessions is limited to 154 for a DVD+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer. To obtain more information about a DVD, use while the disc in the specified drive. More information about dvd+rw-tools can be found in growisofs(1), on the dvd+rw-tools web site, and in the cdwrite mailing list archives. When creating a problem report related to the use of dvd+rw-tools, always include the output of . DVD-RAM writers can use either a SCSI or ATAPI interface. For ATAPI devices, DMA access has to be enabled by adding the following line to /boot/loader.conf: A DVD-RAM can be seen as a removable hard drive. Like any other hard drive, the DVD-RAM must be formatted before it can be used. In this example, the whole disk space will be formatted with a standard UFS2 file system: The DVD device, acd0, must be changed according to the configuration. Once the DVD-RAM has been formatted, it can be mounted as a normal hard drive: Once mounted, the DVD-RAM will be both readable and writeable.\n\nImplementing a backup plan is essential in order to have the ability to recover from disk failure, accidental file deletion, random file corruption, or complete machine destruction, including destruction of on-site backups. The backup type and schedule will vary, depending upon the importance of the data, the granularity needed for file restores, and the amount of acceptable downtime. Some possible backup techniques include:\n• None Archives of the whole system, backed up onto permanent, off-site media. This provides protection against all of the problems listed above, but is slow and inconvenient to restore from, especially for non-privileged users.\n• None File system snapshots, which are useful for restoring deleted files or previous versions of files.\n• None Copies of whole file systems or disks which are synchronized with another system on the network using a scheduled net/rsync.\n• None Hardware or software RAID, which minimizes or avoids downtime when a disk fails. Typically, a mix of backup techniques is used. For example, one could create a schedule to automate a weekly, full system backup that is stored off-site and to supplement this backup with hourly ZFS snapshots. In addition, one could make a manual backup of individual directories or files before making file edits or deletions. This section describes some of the utilities which can be used to create and manage backups on a FreeBSD system. The traditional UNIX® programs for backing up a file system are dump(8), which creates the backup, and restore(8), which restores the backup. These utilities work at the disk block level, below the abstractions of the files, links, and directories that are created by file systems. Unlike other backup software, backs up an entire file system and is unable to backup only part of a file system or a directory tree that spans multiple file systems. Instead of writing files and directories, writes the raw data blocks that comprise files and directories. If is used on the root directory, it will not back up /home, /usr, or many other directories since these are typically mount points for other file systems or symbolic links into those file systems. When used to restore data, stores temporary files in /tmp/ by default. When using a recovery disk with a small /tmp, set to a directory with more free space for the restore to succeed. When using , be aware that some quirks remain from its early days in Version 6 of AT&T UNIX®,circa 1975. The default parameters assume a backup to a 9-track tape, rather than to another type of media or to the high-density tapes available today. These defaults must be overridden on the command line. It is possible to backup a file system across the network to another system or a tape drive attached to another computer. While the rdump(8) and rrestore(8) utilities can be used for this purpose, they are not considered to be secure. Instead, one can use and more securely over an SSH connection. This example creates a full, compressed backup of /usr and sends the backup file to the specified host over an SSH connection. Example 1. Using over ssh This example sets in order to write the backup to a tape drive on a remote system over an SSH connection: Example 2. Using over ssh with Set Systems using the Z file system (ZFS) can make use of zfs(8) for creating snapshots, as well as sending and receiving them to/from remote systems. Several built-in utilities are available for backing up and restoring specified files and directories as needed. A good choice for making a backup of all of the files in a directory is tar(1). This utility dates back to Version 6 of AT&T UNIX® and by default assumes a recursive backup to a local tape device. Switches can be used to instead specify the name of a backup file. This example creates a compressed backup of the current directory and saves it to /tmp/mybackup.tgz. When creating a backup file, make sure that the backup is not saved to the same directory that is being backed up. Example 3. Backing Up the Current Directory with To restore the entire backup, into the directory to restore into and specify the name of the backup. Note that this will overwrite any newer versions of files in the restore directory. When in doubt, restore to a temporary directory or specify the name of the file within the backup to restore. Example 4. Restoring Up the Current Directory with There are dozens of available switches which are described in tar(1). This utility also supports the use of exclude patterns to specify which files should not be included when backing up the specified directory or restoring files from a backup. To create a backup using a specified list of files and directories, cpio(1) is a good choice. Unlike , does not know how to walk the directory tree and it must be provided the list of files to backup. For example, a list of files can be created using or . This example creates a recursive listing of the current directory which is then piped to in order to create an output backup file named /tmp/mybackup.cpio. Example 5. Using and to Make a Recursive Backup of the Current Directory A backup utility which tries to bridge the features provided by and is pax(1). Over the years, the various versions of and became slightly incompatible. POSIX® created which attempts to read and write many of the various and formats, plus new formats of its own. The equivalent to the previous examples would be: Example 6. Backing Up the Current Directory with While tape technology has continued to evolve, modern backup systems tend to combine off-site backups with local removable media. FreeBSD supports any tape drive that uses SCSI, such as LTO or DAT. There is limited support for SATA and USB tape drives. For SCSI tape devices, FreeBSD uses the sa(4) driver and the /dev/sa0, /dev/nsa0, and /dev/esa0 devices. The physical device name is /dev/sa0. When /dev/nsa0 is used, the backup application will not rewind the tape after writing a file, which allows writing more than one file to a tape. Using /dev/esa0 ejects the tape after the device is closed. In FreeBSD, is used to control operations of the tape drive, such as seeking through files on a tape or writing tape control marks to the tape. For example, the first three files on a tape can be preserved by skipping past them before writing a new file: This utility supports many operations. Refer to mt(1) for details. To write a single file to tape using , specify the name of the tape device and the file to backup: To recover files from a archive on tape into the current directory: To backup a UFS file system, use . This examples backs up /usr without rewinding the tape when finished: To interactively restore files from a file on tape into the current directory: The FreeBSD Ports Collection provides many third-party utilities which can be used to schedule the creation of backups, simplify tape backup, and make backups easier and more convenient. Many of these applications are client/server based and can be used to automate the backups of a single system or all of the computers in a network. In addition to regular backups, it is recommended to perform the following steps as part of an emergency preparedness plan. Create a print copy of the output of the following commands: Store this printout and a copy of the installation media in a secure location. Should an emergency restore be needed, boot into the installation media and select to access a rescue shell. This rescue mode can be used to view the current state of the system, and if needed, to reformat disks and restore data from backups. Next, test the rescue shell and the backups. Make notes of the procedure. Store these notes with the media, the printouts, and the backups. These notes may prevent the inadvertent destruction of the backups while under the stress of performing an emergency recovery. For an added measure of security, store the latest backup at a remote location which is physically separated from the computers and disk drives by a significant distance.\n\nDisk quotas can be used to limit the amount of disk space or the number of files a user or members of a group may allocate on a per-file system basis. This prevents one user or group of users from consuming all of the available disk space. This section describes how to configure disk quotas for the UFS file system. To configure quotas on the ZFS file system, refer to Dataset, User, and Group Quotas To determine if the FreeBSD kernel provides support for disk quotas: In this example, the indicates quota support. If the value is instead , add the following line to a custom kernel configuration file and rebuild the kernel using the instructions in Configuring the FreeBSD Kernel: Normally on bootup, the quota integrity of each file system is checked by quotacheck(8). This program insures that the data in the quota database properly reflects the data on the file system. This is a time consuming process that will significantly affect the time the system takes to boot. To skip this step, add this variable to /etc/rc.conf: Finally, edit /etc/fstab to enable disk quotas on a per-file system basis. To enable per-user quotas on a file system, add to the options field in the /etc/fstab entry for the file system to enable quotas on. For example: To enable group quotas, use instead. To enable both user and group quotas, separate the options with a comma: By default, quota files are stored in the root directory of the file system as quota.user and quota.group. Refer to fstab(5) for more information. Specifying an alternate location for the quota files is not recommended. Once the configuration is complete, reboot the system and /etc/rc will automatically run the appropriate commands to create the initial quota files for all of the quotas enabled in /etc/fstab. In the normal course of operations, there should be no need to manually run quotacheck(8), quotaon(8), or quotaoff(8). However, one should read these manual pages to be familiar with their operation. To verify that quotas are enabled, run: There should be a one line summary of disk usage and current quota limits for each file system that quotas are enabled on. The system is now ready to be assigned quota limits with . Several options are available to enforce limits on the amount of disk space a user or group may allocate, and how many files they may create. Allocations can be limited based on disk space (block quotas), number of files (inode quotas), or a combination of both. Each limit is further broken down into two categories: hard and soft limits. A hard limit may not be exceeded. Once a user reaches a hard limit, no further allocations can be made on that file system by that user. For example, if the user has a hard limit of 500 kbytes on a file system and is currently using 490 kbytes, the user can only allocate an additional 10 kbytes. Attempting to allocate an additional 11 kbytes will fail. Soft limits can be exceeded for a limited amount of time, known as the grace period, which is one week by default. If a user stays over their limit longer than the grace period, the soft limit turns into a hard limit and no further allocations are allowed. When the user drops back below the soft limit, the grace period is reset. In the following example, the quota for the account is being edited. When is invoked, the editor specified by is opened in order to edit the quota limits. The default editor is set to vi. Quotas user : /usr: kbytes use: 65, limits soft 50, hard 75 inodes use: 7, limits soft 50, hard 60 /usr/var: kbytes use: 0, limits soft 50, hard 75 inodes use: 0, limits soft 50, hard 60 There are normally two lines for each file system that has quotas enabled. One line represents the block limits and the other represents the inode limits. Change the value to modify the quota limit. For example, to raise the block limit on /usr to a soft limit of and a hard limit of , change the values in that line as follows: The new quota limits take effect upon exiting the editor. Sometimes it is desirable to set quota limits on a range of users. This can be done by first assigning the desired quota limit to a user. Then, use to duplicate that quota to a specified range of user IDs (UIDs). The following command will duplicate those quota limits for UIDs through : For more information, refer to edquota(8). To check individual user or group quotas and disk usage, use quota(1). A user may only examine their own quota and the quota of a group they are a member of. Only the superuser may view all user and group quotas. To get a summary of all quotas and disk usage for file systems with quotas enabled, use repquota(8). Normally, file systems that the user is not using any disk space on will not show in the output of , even if the user has a quota limit assigned for that file system. Use to display those file systems. The following is sample output from for a user that has quota limits on two file systems. In this example, the user is currently 15 kbytes over the soft limit of 50 kbytes on /usr and has 5 days of grace period left. The asterisk indicates that the user is currently over the quota limit. Quotas are enforced by the quota subsystem on the NFS server. The rpc.rquotad(8) daemon makes quota information available to on NFS clients, allowing users on those machines to see their quota statistics. On the NFS server, enable by removing the from this line in /etc/inetd.conf:\n\nFreeBSD offers excellent online protections against unauthorized data access. File permissions and Mandatory Access Control (MAC) help prevent unauthorized users from accessing data while the operating system is active and the computer is powered up. However, the permissions enforced by the operating system are irrelevant if an attacker has physical access to a computer and can move the computer’s hard drive to another system to copy and analyze the data. Regardless of how an attacker may have come into possession of a hard drive or powered-down computer, the GEOM-based cryptographic subsystems built into FreeBSD are able to protect the data on the computer’s file systems against even highly-motivated attackers with significant resources. Unlike encryption methods that encrypt individual files, the built-in and utilities can be used to transparently encrypt entire file systems. No cleartext ever touches the hard drive’s platter. This chapter demonstrates how to create an encrypted file system on FreeBSD. It first demonstrates the process using and then demonstrates the same example using . The objective of the gbde(4) facility is to provide a formidable challenge for an attacker to gain access to the contents of a cold storage device. However, if the computer is compromised while up and running and the storage device is actively attached, or the attacker has access to a valid passphrase, it offers no protection to the contents of the storage device. Thus, it is important to provide physical security while the system is running and to protect the passphrase used by the encryption mechanism. This facility provides several barriers to protect the data stored in each disk sector. It encrypts the contents of a disk sector using 128-bit AES in CBC mode. Each sector on the disk is encrypted with a different AES key. For more information on the cryptographic design, including how the sector keys are derived from the user-supplied passphrase, refer to gbde(4). FreeBSD provides a kernel module for gbde which can be loaded with this command: If using a custom kernel configuration file, ensure it contains this line: The following example demonstrates adding a new hard drive to a system that will hold a single encrypted partition that will be mounted as /private.\n• None Install the new drive to the system as explained in Adding Disks. For the purposes of this example, a new hard drive partition has been added as /dev/ad4s1c and /dev/ad0s1* represents the existing standard FreeBSD partitions.\n• None The gbde lock file contains information that gbde requires to access encrypted partitions. Without access to the lock file, gbde will not be able to decrypt the data contained in the encrypted partition without significant manual intervention which is not supported by the software. Each encrypted partition uses a separate lock file.\n• None A gbde partition must be initialized before it can be used. This initialization needs to be performed only once. This command will open the default editor, in order to set various configuration options in a template. For use with the UFS file system, set the sector_size to 2048: # Sector size is the smallest unit of data which can be read or written. # Making it too small decreases performance and decreases available space. # Making it too large may prevent filesystems from working. 512 is the # minimum and always safe. For UFS, use the fragment size sector_size 2048 ...] Once the edit is saved, the user will be asked twice to type the passphrase used to secure the data. The passphrase must be the same both times. The ability of gbde to protect data depends entirely on the quality of the passphrase. For tips on how to select a secure passphrase that is easy to remember, see http://world.std.com/~reinhold/diceware.htm. This initialization creates a lock file for the gbde partition. In this example, it is stored as /etc/gbde/ad4s1c.lock. Lock files must end in \".lock\" in order to be correctly detected by the /etc/rc.d/gbde start up script. Lock files must be backed up together with the contents of any encrypted partitions. Without the lock file, the legitimate owner will be unable to access the data on the encrypted partition.\n• None Attach the Encrypted Partition to the Kernel This command will prompt to input the passphrase that was selected during the initialization of the encrypted partition. The new encrypted device will appear in /dev as /dev/device_name.bde:\n• None Once the encrypted device has been attached to the kernel, a file system can be created on the device. This example creates a UFS file system with soft updates enabled. Be sure to specify the partition which has a *.bde extension:\n• None Verify That the Encrypted File System is Available The encrypted file system should now be visible and available for use: After each boot, any encrypted file systems must be manually re-attached to the kernel, checked for errors, and mounted, before the file systems can be used. To configure these steps, add the following lines to /etc/rc.conf: This requires that the passphrase be entered at the console at boot time. After typing the correct passphrase, the encrypted partition will be mounted automatically. Additional gbde boot options are available and listed in rc.conf(5). sysinstall is incompatible with gbde-encrypted devices. All *.bde devices must be detached from the kernel before starting sysinstall or it will crash during its initial probing for devices. To detach the encrypted device used in the example, use the following command: An alternative cryptographic GEOM class is available using . This control utility adds some features and uses a different scheme for doing cryptographic work. It provides the following features:\n• None Utilizes the crypto(9) framework and automatically uses cryptographic hardware when it is available.\n• None Supports multiple cryptographic algorithms such as AES-XTS, AES-CBC, and Camellia-CBCAES.\n• None Allows the root partition to be encrypted. The passphrase used to access the encrypted root partition will be requested during system boot.\n• None Allows the use of two independent keys.\n• None It is fast as it performs simple sector-to-sector encryption.\n• None Allows backup and restore of master keys. If a user destroys their keys, it is still possible to get access to the data by restoring keys from the backup.\n• None Allows a disk to attach with a random, one-time key which is useful for swap partitions and temporary file systems. More features and usage examples can be found in geli(8). The following example describes how to generate a key file which will be used as part of the master key for the encrypted provider mounted under /private. The key file will provide some random data used to encrypt the master key. The master key will also be protected by a passphrase. The provider’s sector size will be 4kB. The example describes how to attach to the provider, create a file system on it, mount it, work with it, and finally, how to detach it.\n• None Support for is available as a loadable kernel module. To configure the system to automatically load the module at boot time, add the following line to /boot/loader.conf: To load the kernel module now: For a custom kernel, ensure the kernel configuration file contains these lines:\n• None The following commands generate a master key that all data will be encrypted with. This key can never be changed. Rather than using it directly, it is encrypted with one or more user keys. The user keys are made up of an optional combination of random bytes from a file, /root/da2.key, and/or a passphrase. In this case, the data source for the key file is /dev/random. This command also configures the sector size of the provider (/dev/da2.eli) as 4kB, for better performance: It is not mandatory to use both a passphrase and a key file as either method of securing the master key can be used in isolation. If the key file is given as \"-\", standard input will be used. For example, this command generates three key files:\n• None Attach the Provider with the Generated Key To attach the provider, specify the key file, the name of the disk, and the passphrase: This creates a new device with an .eli extension:\n• None Next, format the device with the UFS file system and mount it on an existing mount point: The encrypted file system should now be available for use: Once the work on the encrypted partition is done, and the /private partition is no longer needed, it is prudent to put the device into cold storage by unmounting and detaching the encrypted partition from the kernel: An rc.d script is provided to simplify the mounting of -encrypted devices at boot time. For this example, add these lines to /etc/rc.conf: This configures /dev/da2 as a provider with a master key of /root/da2.key. The system will automatically detach the provider from the kernel before the system shuts down. During the startup process, the script will prompt for the passphrase before attaching the provider. Other kernel messages might be shown before and after the password prompt. If the boot process seems to stall, look carefully for the password prompt among the other messages. Once the correct passphrase is entered, the provider is attached. The file system is then mounted, typically by an entry in /etc/fstab. Refer to “Mounting and Unmounting File Systems” for instructions on how to configure a file system to mount at boot time.\n\nHigh availability is one of the main requirements in serious business applications and highly-available storage is a key component in such environments. In FreeBSD, the Highly Available STorage (HAST) framework allows transparent storage of the same data across several physically separated machines connected by a TCP/IP network. HAST can be understood as a network-based RAID1 (mirror), and is similar to the DRBD® storage system used in the GNU/Linux® platform. In combination with other high-availability features of FreeBSD like CARP, HAST makes it possible to build a highly-available storage cluster that is resistant to hardware failures. The following are the main features of HAST:\n• None Can be used to mask I/O errors on local hard drives.\n• None File system agnostic as it works with any file system supported by FreeBSD.\n• None Efficient and quick resynchronization as only the blocks that were modified during the downtime of a node are synchronized.\n• None Can be used in an already deployed environment to add additional redundancy.\n• None Together with CARP, Heartbeat, or other tools, it can be used to build a robust and durable storage system. After reading this section, you will know:\n• None What HAST is, how it works, and which features it provides.\n• None How to set up and use HAST on FreeBSD.\n• None How to integrate CARP and devd(8) to build a robust storage system. Before reading this section, you should:\n• None Know how to configure network interfaces and other core FreeBSD subsystems (Configuration and Tuning). The HAST project was sponsored by The FreeBSD Foundation with support from http://www.omc.net/ and http://www.transip.nl/. HAST provides synchronous block-level replication between two physical machines: the primary node and the secondary node. These two machines together are referred to as a cluster. Since HAST works in a primary-secondary configuration, it allows only one of the cluster nodes to be active at any given time. The primary node, also called active, is the one which will handle all the I/O requests to HAST-managed devices. The secondary node is automatically synchronized from the primary node. The physical components of the HAST system are the local disk on primary node, and the disk on the remote, secondary node. HAST operates synchronously on a block level, making it transparent to file systems and applications. HAST provides regular GEOM providers in /dev/hast/ for use by other tools or applications. There is no difference between using HAST-provided devices and raw disks or partitions. Each write, delete, or flush operation is sent to both the local disk and to the remote disk over TCP/IP. Each read operation is served from the local disk, unless the local disk is not up-to-date or an I/O error occurs. In such cases, the read operation is sent to the secondary node. HAST tries to provide fast failure recovery. For this reason, it is important to reduce synchronization time after a node’s outage. To provide fast synchronization, HAST manages an on-disk bitmap of dirty extents and only synchronizes those during a regular synchronization, with an exception of the initial sync. There are many ways to handle synchronization. HAST implements several replication modes to handle different synchronization methods:\n• None memsync: This mode reports a write operation as completed when the local write operation is finished and when the remote node acknowledges data arrival, but before actually storing the data. The data on the remote node will be stored directly after sending the acknowledgement. This mode is intended to reduce latency, but still provides good reliability. This mode is the default.\n• None fullsync: This mode reports a write operation as completed when both the local write and the remote write complete. This is the safest and the slowest replication mode.\n• None async: This mode reports a write operation as completed when the local write completes. This is the fastest and the most dangerous replication mode. It should only be used when replicating to a distant node where latency is too high for other modes. The HAST framework consists of several components:\n• None The hastd(8) daemon which provides data synchronization. When this daemon is started, it will automatically load .\n• None The hast.conf(5) configuration file. This file must exist before starting hastd. Users who prefer to statically build support into the kernel should add this line to the custom kernel configuration file, then rebuild the kernel using the instructions in Configuring the FreeBSD Kernel: The following example describes how to configure two nodes in primary-secondary operation using HAST to replicate the data between the two. The nodes will be called , with an IP address of , and , with an IP address of . Both nodes will have a dedicated hard drive /dev/ad6 of the same size for HAST operation. The HAST pool, sometimes referred to as a resource or the GEOM provider in /dev/hast/, will be called . Configuration of HAST is done using /etc/hast.conf. This file should be identical on both nodes. The simplest configuration is: For more advanced configuration, refer to hast.conf(5). It is also possible to use host names in the statements if the hosts are resolvable and defined either in /etc/hosts or in the local DNS. Once the configuration exists on both nodes, the HAST pool can be created. Run these commands on both nodes to place the initial metadata onto the local disk and to start hastd(8): It is not possible to use GEOM providers with an existing file system or to convert an existing storage to a HAST-managed pool. This procedure needs to store some metadata on the provider and there will not be enough required space available on an existing provider. A HAST node’s or role is selected by an administrator, or software like Heartbeat, using hastctl(8). On the primary node, , issue this command: Run this command on the secondary node, : Verify the result by running on each node: Check the line in the output. If it says , something is wrong with the configuration file. It should say on each node, meaning that the synchronization between the nodes has started. The synchronization completes when reports 0 bytes of extents. The next step is to create a file system on the GEOM provider and mount it. This must be done on the node. Creating the file system can take a few minutes, depending on the size of the hard drive. This example creates a UFS file system on /dev/hast/test: Once the HAST framework is configured properly, the final step is to make sure that HAST is started automatically during system boot. Add this line to /etc/rc.conf: The goal of this example is to build a robust storage system which is resistant to the failure of any given node. If the primary node fails, the secondary node is there to take over seamlessly, check and mount the file system, and continue to work without missing a single bit of data. To accomplish this task, the Common Address Redundancy Protocol (CARP) is used to provide for automatic failover at the IP layer. CARP allows multiple hosts on the same network segment to share an IP address. Set up CARP on both nodes of the cluster according to the documentation available in “Common Address Redundancy Protocol (CARP)”. In this example, each node will have its own management IP address and a shared IP address of 172.16.0.254. The primary HAST node of the cluster must be the primary CARP node. The HAST pool created in the previous section is now ready to be exported to the other hosts on the network. This can be accomplished by exporting it through NFS or Samba, using the shared IP address 172.16.0.254. The only problem which remains unresolved is an automatic failover should the primary node fail. In the event of CARP interfaces going up or down, the FreeBSD operating system generates a devd(8) event, making it possible to watch for state changes on the CARP interfaces. A state change on the CARP interface is an indication that one of the nodes failed or came back online. These state change events make it possible to run a script which will automatically handle the HAST failover. To catch state changes on the CARP interfaces, add this configuration to /etc/devd.conf on each node, while replacing with the virtual host id and with the associated interface name: Restart devd(8) on both nodes to put the new configuration into effect: When the specified interface state changes by going up or down , the system generates a notification, allowing the devd(8) subsystem to run the specified automatic failover script, /usr/local/sbin/carp-hast-switch. For further clarification about this configuration, refer to devd.conf(5). Here is an example of an automated failover script: #!/bin/sh # Original script by Freddie Cash <fjwcash@gmail.com> # Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org> # and Viktor Petersson <vpetersson@wireload.net> # The names of the HAST resources, as listed in /etc/hast.conf resources=\"test\" # delay in mounting HAST resource after becoming primary # make your best guess delay=3 # logging log=\"local0.debug\" name=\"carp-hast\" # end of user configurable stuff case \"$1\" in primary) logger -p $log -t $name \"Switching to primary provider for ${resources}.\" sleep ${delay} # Wait for any \"hastd secondary\" processes to stop for disk in ${resources}; do while $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do sleep 1 done # Switch role for each disk hastctl role primary ${disk} if [ $? -ne 0 ]; then logger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\" exit 1 fi done # Wait for the /dev/hast/* devices to appear for disk in ${resources}; do for I in $( jot 60 ); do [ -c \"/dev/hast/${disk}\" ] && break sleep 0.5 done if [ ! -c \"/dev/hast/${disk}\" ]; then logger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\" exit 1 fi done logger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\" logger -p $log -t $name \"Mounting disks.\" for disk in ${resources}; do mkdir -p /hast/${disk} fsck -p -y -t ufs /dev/hast/${disk} mount /dev/hast/${disk} /hast/${disk} done ;; secondary) logger -p $log -t $name \"Switching to secondary provider for ${resources}.\" # Switch roles for the HAST resources for disk in ${resources}; do if ! mount | grep -q \"^/dev/hast/${disk} on \" then else umount -f /hast/${disk} fi sleep $delay hastctl role secondary ${disk} 2>&1 if [ $? -ne 0 ]; then logger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\" exit 1 fi logger -p $log -t $name \"Role switched to secondary for resource ${disk}.\" done ;; esac In a nutshell, the script takes these actions when a node becomes primary:\n• None Promotes the HAST pool to primary on the other node.\n• None Checks the file system under the HAST pool. This is just an example script which serves as a proof of concept. It does not handle all the possible scenarios and can be extended or altered in any way, for example, to start or stop required services. For this example, a standard UFS file system was used. To reduce the time needed for recovery, a journal-enabled UFS or ZFS file system can be used instead. Instead of using the highly available storage locally, it can also be shared to other computers on a network via NFS, iSCSI, sshfs(1), or programs in ports (i.e. net/samba419). More detailed information with additional examples can be found at http://wiki.FreeBSD.org/HAST. HAST should generally work without issues. However, as with any other software product, there may be times when it does not work as supposed. The sources of the problems may be different, but the rule of thumb is to ensure that the time is synchronized between the nodes of the cluster. When troubleshooting HAST, the debugging level of hastd(8) should be increased by starting with . This argument may be specified multiple times to further increase the debugging level. Consider also using , which starts in the foreground. Split-brain occurs when the nodes of the cluster are unable to communicate with each other, and both are configured as primary. This is a dangerous condition because it allows both nodes to make incompatible changes to the data. This problem must be corrected manually by the system administrator. The administrator must either decide which node has more important changes, or perform the merge manually. Then, let HAST perform full synchronization of the node which has the broken data. To do this, issue these commands on the node which needs to be resynchronized:"
    },
    {
        "link": "https://forums.freebsd.org/threads/how-to-mount-a-large-fat32-drive-hdd-with-fstab.61274",
        "document": "I'm sorry, but I can't debug \"it crashes\". You need to give me details. Exactly what does it do? Does the mount just silently not happen? Or do you get error messages? Did you test it when booting, or afterwards (can be used at boot time, and also when you say). Did the OS crash? What exactly were the messages? What exact commands did you use to test it?A picture of the cabling (which looks about as well-organized as the cabling on my work bench) doesn't help; a picture of the console messages might have helped.There is one other suspicious thing: These days, most OSes format disk drives with partition tables, but the mount line /dev/da0 indicates that the MS-DOS file system is on the whole disk. That *could* be right, but it's a bit unusual.That's very bizarre. How did failing to mount an external disk manage to destroy the image on disk? That makes very little sense."
    },
    {
        "link": "https://forums.freebsd.org/threads/how-can-i-automate-an-installation.93511",
        "document": ""
    },
    {
        "link": "https://unix.stackexchange.com/questions/696314/what-should-be-in-my-etc-fstab-if-i-have-two-discs",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://serverfault.com/questions/174181/how-do-you-validate-fstab-without-rebooting",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]