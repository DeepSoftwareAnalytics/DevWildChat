[
    {
        "link": "https://ti.com/lit/pdf/sbaa565",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/learn/communication/wire",
        "document": ""
    },
    {
        "link": "https://nxp.com/docs/en/user-guide/UM10204.pdf",
        "document": ""
    },
    {
        "link": "https://ti.com/lit/pdf/slva704",
        "document": ""
    },
    {
        "link": "https://learn.sparkfun.com/tutorials/i2c/all",
        "document": "In this tutorial, you will learn all about the I2C communication protocol, why you would want to use it, and how it's implemented. The Inter-Integrated Circuit (I2C) Protocol is a protocol intended to allow multiple \"peripheral\" digital integrated circuits (\"chips\") to communicate with one or more \"controller\" chips. Like the Serial Peripheral Interface (SPI), it is only intended for short distance communications within a single device. Like Asynchronous Serial Interfaces (such as RS-232 or UARTs), it only requires two signal wires to exchange information. Stuff that would be helpful to know before reading this tutorial: SPI is commonly used to connect microcontrollers to peripherals such as sensors, shift registers, and SD cards. Binary is the numeral system of electronics and programming...so it must be important to learn. But, what is binary? How does it translate to other numeral systems like decimal? An introduction to shift registers and potential uses. Learn the difference between 3.3V and 5V devices and logic levels.\n\nTo figure out why one might want to communicate over I2C, you must first compare it to the other available options to see how it differs. Because serial ports are asynchronous (no clock data is transmitted), devices using them must agree ahead of time on a data rate. The two devices must also have clocks that are close to the same rate, and will remain so--excessive differences between clock rates on either end will cause garbled data. Asynchronous serial ports require hardware overhead--the UART at either end is relatively complex and difficult to accurately implement in software if necessary. At least one start and stop bit is a part of each frame of data, meaning that 10 bits of transmission time are required for each 8 bits of data sent, which eats into the data rate. Another core fault in asynchronous serial ports is that they are inherently suited to communications between two, and only two, devices. While it is possible to connect multiple devices to a single serial port, bus contention (where two devices attempt to drive the same line at the same time) is always an issue and must be dealt with carefully to prevent damage to the devices in question, usually through external hardware. Finally, data rate is an issue. While there is no theoretical limit to asynchronous serial communications, most UART devices only support a certain set of fixed baud rates, and the highest of these is usually around 230400 bits per second. The most obvious drawback of SPI is the number of pins required. Connecting a single controller [1] to a single peripheral [1] with an SPI bus requires four lines; each additional peripheral device requires one additional chip select I/O pin on the controller. The rapid proliferation of pin connections makes it undesirable in situations where lots of devices must be connected to one controller. Also, the large number of connections for each device can make routing signals more difficult in tight PCB layout situations. SPI only allows one controller on the bus, but it does support an arbitrary number of peripherals (subject only to the drive capability of the devices connected to the bus and the number of chip select pins available). SPI is good for high data rate full-duplex (simultaneous sending and receiving of data) connections, supporting clock rates upwards of 10MHz (and thus, 10 million bits per second) for some devices, and the speed scales nicely. The hardware at either end is usually a very simple shift register, allowing easy implementation in software. Enter I2C - The Best of Both Worlds! I2C requires a mere two wires, like asynchronous serial, but those two wires can support up to 1008 peripheral devices. Also, unlike SPI, I2C can support a multi-controller system, allowing more than one controller [1] to communicate with all peripheral [1] devices on the bus (although the controller devices can't talk to each other over the bus and must take turns using the bus lines). Data rates fall between asynchronous serial and SPI; most I2C devices can communicate at 100kHz or 400kHz. There is some overhead with I2C; for every 8 bits of data to be sent, one extra bit of meta data (the \"ACK/NACK\" bit, which we'll discuss later) must be transmitted. The hardware required to implement I2C is more complex than SPI, but less than asynchronous serial. It can be fairly trivially implemented in software. 2C bus. The terms are considered obsolete and are now replaced with the terms \"controller\" and \"peripheral,\" respectively. \n\n\n\n The naming convention may vary depending on manufacturer, programming language, companies, or organizations (e.g. main/secondary, initiator-responder, source/replica, etc.). For more information, check out the following links. \n\n \n\n You may be familiar with the terms \"master\" and \"slave\" to represent the relationship between devices on an IC bus. The terms are considered obsolete and are now replaced with the terms \"controller\" and \"peripheral,\" respectively.The naming convention may vary depending on manufacturer, programming language, companies, or organizations (e.g. main/secondary, initiator-responder, source/replica, etc.). For more information, check out the following links. [1] Note: You may be familiar with the terms \"master\" and \"slave\" to represent the relationship between devices on an IC bus. The terms are considered obsolete and are now replaced with the terms \"controller\" and \"peripheral,\" respectively.The naming convention may vary depending on manufacturer, programming language, companies, or organizations (e.g. main/secondary, initiator-responder, source/replica, etc.). For more information, check out the following links.\n\nI2C was originally developed in 1982 by Philips for various Philips chips. The original spec allowed for only 100kHz communications, and provided only for 7-bit addresses, limiting the number of devices on the bus to 112 (there are several reserved addresses, which will never be used for valid I2C addresses). In 1992, the first public specification was published, adding a 400kHz fast-mode as well as an expanded 10-bit address space. Much of the time (for instance, in the ATMega328 device on many Arduino-compatible boards), device support for I2C ends at this point. There are three additional modes specified: In addition to \"vanilla\" I2C, Intel introduced a variant in 1995 call \"System Management Bus\" (SMBus). SMBus is a more tightly controlled format, intended to maximize predictability of communications between support ICs on PC motherboards. The most significant difference between SMBus is that it limits speeds from 10kHz to 100kHz, while I2C can support devices from 0kHz to 5MHz. SMBus includes a clock timeout mode which makes low-speed operations illegal, although many SMBus devices will support it anyway to maximize interoperability with embedded I2C systems.\n\nCommunication via I2C is more complex than with a UART or SPI solution. The signalling must adhere to a certain protocol for the devices on the bus to recognize it as valid I2C communications. Fortunately, most devices take care of all the fiddly details for you, allowing you to concentrate on the data you wish to exchange. Messages are broken up into two types of frame: an address frame, where the controller indicates the peripheral to which the message is being sent, and one or more data frames, which are 8-bit data messages passed from controller to peripheral or vice versa. Data is placed on the SDA line after SCL goes low, and is sampled after the SCL line goes high. The time between clock edge and data read/write is defined by the devices on the bus and will vary from chip to chip. To initiate the address frame, the controller device leaves SCL high and pulls SDA low. This puts all peripheral devices on notice that a transmission is about to start. If two controllers wish to take ownership of the bus at one time, whichever device pulls SDA low first wins the race and gains control of the bus. It is possible to issue repeated starts, initiating a new communication sequence without relinquishing control of the bus to other controller(s); we'll talk about that later. The address frame is always first in any new communication sequence. For a 7-bit address, the address is clocked out most significant bit (MSB) first, followed by a R/W bit indicating whether this is a read (1) or write (0) operation. The 9th bit of the frame is the NACK/ACK bit. This is the case for all frames (data or address). Once the first 8 bits of the frame are sent, the receiving device is given control over SDA. If the receiving device does not pull the SDA line low before the 9th clock pulse, it can be inferred that the receiving device either did not receive the data or did not know how to parse the message. In that case, the exchange halts, and it's up to the controller of the system to decide how to proceed. After the address frame has been sent, data can begin being transmitted. The controller will simply continue generating clock pulses at a regular interval, and the data will be placed on SDA by either the controller or the peripheral, depending on whether the R/W bit indicated a read or write operation. The number of data frames is arbitrary, and most peripheral devices will auto-increment the internal register, meaning that subsequent reads or writes will come from the next register in line. Once all the data frames have been sent, the controller will generate a stop condition. Stop conditions are defined by a 0->1 (low to high) transition on SDA after a 0->1 transition on SCL, with SCL remaining high. During normal data writing operation, the value on SDA should not change when SCL is high, to avoid false stop conditions. In a 10-bit addressing system, two frames are required to transmit the peripheral address. The first frame will consist of the code b11110xyz, where 'x' is the MSB of the peripheral address, y is bit 8 of the peripheral address, and z is the read/write bit as described above. The first frame's ACK bit will be asserted by all peripherals which match the first two bits of the address. As with a normal 7-bit transfer, another transfer begins immediately, and this transfer contains bits 7:0 of the address. At this point, the addressed peripheral should respond with an ACK bit. If it doesn't, the failure mode is the same as a 7-bit system. Note that 10-bit address devices can coexist with 7-bit address devices, since the leading '11110' part of the address is not a part of any valid 7-bit addresses. Sometimes, it is important that a controller be allowed to exchange several messages in one go, without allowing other controllers on the bus to interfere. For this reason, the repeated start condition has been defined. To perform a repeated start, SDA is allowed to go high while SCL is low, SCL is allowed to go high, and then SDA is brought low again while SCL is high. Because there was no stop condition on the bus, the previous communication wasn't truly completed and the current controller maintains control of the bus. At this point, the next message can begin transmission. The syntax of this new message is the same as any other message--an address frame followed by data frames. Any number of repeated starts is allowed, and the controller will maintain control of the bus until it issues a stop condition. At times, the controller's data rate will exceed the peripheral's ability to provide that data. This can be because the data isn't ready yet (for instance, the peripheral hasn't completed an analog-to-digital conversion yet) or because a previous operation hasn't yet completed (say, an EEPROM which hasn't completed writing to non-volatile memory yet and needs to finish that before it can service other requests). In this case, some peripheral devices will execute what is referred to as \"clock stretching\". Nominally, all clocking is driven by the controller — peripherals simply put data on the bus or take data off the bus in response to the controller's clock pulses. At any point in the data transfer process, an addressed peripheral can hold the SCL line low after the controller releases it. The controller is required to refrain from additional clock pulses or data transfer until such time as the peripheral releases the SCL line. Tip: If you are looking for examples that use clock stretching, try looking at the CCS811 used with Arduino and Python for ideas! The library and examples in the following tutorials adjust the clock signal for the device. \n\n\n\n This tutorial shows you how to get data from a CCS811 breakout board with the I2C interface. If you are looking for examples that use clock stretching, try looking at the CCS811 used with Arduino and Python for ideas! The library and examples in the following tutorials adjust the clock signal for the device. See our Engineering Essentials page for a full list of cornerstone topics surrounding electrical engineering."
    },
    {
        "link": "https://ti.com/lit/pdf/sbaa565",
        "document": ""
    },
    {
        "link": "https://forum.arduino.cc/t/pullup-resistor-in-i2c-bus-with-multiple-devices/688312",
        "document": "The standard is a maximum of 3 mA sink current to pull the signal low. That is for the normal 100 kHz to 400 kHz I2C bus.\n\n Every device may be able to sink more, but a manufacturer of a sensor can build a sensor that can sink only 3 mA to comply with the I2C standard.\n\nThe total pullup resistor (the lowest resistor value) can be calculated for a maximum of 3mA.\n\n 3.3V / 3mA = 1100Ω\n\nA very high pullup value makes the I2C bus high impedance for when the signal is high. I would recommend at least 4k7 pullup resistors, but many use 10k pullup resistors.\n\nGood: 4k7 pullup resistors at the Arduino board. No pullup resistors on modules.\n\n Just as good: Two modules that happen to have 10k pullup resistors.\n\n Still good: Nine modules and each one has 10k pullup resistors. You do the math \n\n Working, but a little high impedance: Only one module with 10k pullup resistors. Extra 4k7 pullup resistors can be added.\n\nCan you give a link to your BMP180 module, perhaps I can see the value of the pullup resistors.\n\nDoes this make sense ? Well, sometimes things are not okay.\n\n Some manufacturers put 1k5 pullup resistors on their module, because they don't care. Some create a I2C bus with two I2C levels shifters in the signal path, that disturbs the signals too much. Some put SDA and SCL next to each other in a flat ribbon cable, never do that, crosstalk is the worst for the I2C bus.\n\nIt is possible to measure the actual sink current.\n\n Make a sketch with Wire.begin() in setup() and nothing in the loop(). Start the sketch and measure the shortcut current from SDA to GND and the shortcut current from SCL to GND. Those are the sink currents and should not be larger than 3 mA."
    },
    {
        "link": "https://e2e.ti.com/support/microcontrollers/msp-low-power-microcontrollers-group/msp430/f/msp-low-power-microcontroller-forum/18963/i2c-with-internal-pull-up-resistors-msp430f2xx",
        "document": "I am trying to read buttons from ez430-rf2500 using pull up mode, however I could not read the button correctly, all the time it shows that the button is pressed but it is not pressed. can anyone help me? the program is shown below\n\n#define I_WANT_TO_CHANGE_DEFAULT_ROM_DEVICE_ADDRESS_PSEUDO_CODE\n\n#include \"bsp.h\"\n\n#include \"mrfi.h\"\n\n#include \"nwk_types.h\"\n\n#include \"nwk_api.h\"\n\n#include \"bsp_leds.h\"\n\n#include \"bsp_buttons.h\"\n\n#include \"vlo_rand.h\"\n\n\n\n#ifndef APP_AUTO_ACK\n\n#error ERROR: Must define the macro APP_AUTO_ACK for this application.\n\n#endif\n\n\n\nvoid toggleLED(uint8_t);\n\n\n\nstatic void linkTo(void);\n\n\n\nstatic linkID_t sLinkID1 = 0;\n\n\n\n#define SPIN_ABOUT_A_SECOND NWK_DELAY(1000)\n\n#define SPIN_ABOUT_A_QUARTER_SECOND NWK_DELAY(250)\n\n\n\n/* How many times to try a Tx and miss an acknowledge before doing a scan */\n\n#define MISSES_IN_A_ROW 2\n\n\n\nvoid createRandomAddress(void); \n\n\n\nvolatile int * tempOffset = (int *)0x10F4; // Temperature offset set at production\n\nchar * Flash_Addr = (char *)0x10F0; // Initialize radio address location\n\n\n\n__interrupt void ADC10_ISR(void);\n\n__interrupt void Timer_A (void);\n\n\n\n/* work loop semaphores */\n\nstatic volatile uint8_t sSelfMeasureSem = 0;\n\n\n\nvoid main (void)\n\n{ \n\n addr_t lAddr; \n\n\n\n //WDTCTL = WDTHOLD | WDTPW;\n\n P2SEL &=0x1F;\n\n P2DIR &= 0xE0;\n\n //P2REN|=0x1F;\n\n P2OUT|=0x1F; \n\n \n\n \n\n \n\n P4SEL&=0x38;\n\n P4DIR &= 0xC7;\n\n //P4REN|=0x38;\n\n P4OUT|=0x38;\n\n \n\n \n\n\n\n \n\n BSP_Init();\n\n \n\n \n\n \n\n\n\n if(Flash_Addr[0] == 0xFF && Flash_Addr[1] == 0xFF && \n\n Flash_Addr[2] == 0xFF && Flash_Addr[3] == 0xFF ) \n\n {\n\n createRandomAddress(); // set Random device address at initial startup\n\n }\n\n lAddr.addr[0] = Flash_Addr[0];\n\n lAddr.addr[1] = Flash_Addr[1];\n\n lAddr.addr[2] = Flash_Addr[2];\n\n lAddr.addr[3] = Flash_Addr[3];\n\n SMPL_Ioctl(IOCTL_OBJ_ADDR, IOCTL_ACT_SET, &lAddr);\n\n\n\n /* Keep trying to join (a side effect of successful initialization) until\n\n * successful. Toggle LEDS to indicate that joining has not occurred.\n\n */\n\n while (SMPL_SUCCESS != SMPL_Init(0))\n\n {\n\n toggleLED(1);\n\n toggleLED(2);\n\n SPIN_ABOUT_A_SECOND;\n\n }\n\n\n\n /* LEDs on solid to indicate successful join. */\n\n if (!BSP_LED2_IS_ON())\n\n {\n\n toggleLED(2);\n\n }\n\n if (!BSP_LED1_IS_ON())\n\n {\n\n toggleLED(1);\n\n }\n\n\n\n BCSCTL3 |= LFXT1S_2; // LFXT1 = VLO\n\n TACCTL0 = CCIE; // TACCR0 interrupt enabled\n\n TACCR0 = 12000; // ~ 1 sec\n\n TACTL = TASSEL_1 + MC_1; // ACLK, upmode \n\n \n\n /* Unconditional link to AP which is listening due to successful join. */\n\n linkTo();\n\n\n\n while (1) ;\n\n}\n\n\n\nstatic void linkTo()\n\n{ \n\n /*\n\nIn order to send the data we need to use the foll \n\n \n\n \n\n \n\n */\n\n uint8_t poi=0;//pointer\n\n uint8_t pp=0;// check state\n\n \n\n uint8_t msg[1];\n\n uint8_t misses, done;\n\n int results[5]; \n\n uint8_t noAck;\n\n smplStatus_t rc;\n\n \n\n \n\nwhile(1)\n\n{\n\n\n\n if (!(P2IN & 0x00))\n\n {\n\n poi=0;\n\n pp=1;\n\n \n\n }\n\n else if (!(P2IN & 0x01))\n\n {\n\n poi=1;\n\n pp=1;\n\n }\n\n \n\n \n\n if (pp)\n\n {\n\n \n\n\n\n\n\n /* Keep trying to link... */\n\n while (SMPL_SUCCESS != SMPL_Link(&sLinkID1))\n\n {\n\n toggleLED(1);\n\n toggleLED(2);\n\n SPIN_ABOUT_A_SECOND;\n\n }\n\n\n\n /* Turn off LEDs. */\n\n if (BSP_LED2_IS_ON())\n\n {\n\n toggleLED(2);\n\n }\n\n if (BSP_LED1_IS_ON())\n\n {\n\n toggleLED(1);\n\n }\n\n\n\n SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_SLEEP, 0);\n\n\n\n \n\n/* orginl PROGRAMM\n\n while (1)\n\n {\n\n \n\n __bis_SR_register(LPM3_bits+GIE); // LPM3 with interrupts enabled \n\n\n\n if (sSelfMeasureSem) {\n\n volatile long temp;\n\n int degC, volt;\n\n int results[5]; \n\n uint8_t noAck;\n\n smplStatus_t rc;*/\n\n \n\n \n\n\n\n /* get radio ready...awakens in idle state */\n\n SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_AWAKE, 0);\n\n\n\n results[0]=0x5A;\n\n results[1]=0x5B;\n\n results[2]=0x46;\n\n results[3]=0x47;\n\n results[4]=0x28;\n\n \n\n msg[0]=results[poi];\n\n \n\n done = 0;\n\n while (!done)\n\n {\n\n noAck = 0;\n\n\n\n /* Try sending message MISSES_IN_A_ROW times looking for ack */\n\n for (misses=0; misses < MISSES_IN_A_ROW; ++misses)\n\n {\n\n if (SMPL_SUCCESS == (rc=SMPL_SendOpt(sLinkID1, msg, sizeof(msg), SMPL_TXOPTION_ACKREQ)))\n\n {\n\n /* Message acked. We're done. Toggle LED 1 to indicate ack received. */\n\n toggleLED(1); // Toggle On LED1\n\n __delay_cycles(2000);\n\n toggleLED(1);\n\n break;\n\n }\n\n if (SMPL_NO_ACK == rc)\n\n {\n\n /* Count ack failures. Could also fail becuase of CCA and\n\n * we don't want to scan in this case.\n\n */\n\n noAck++;\n\n }\n\n }\n\n if (MISSES_IN_A_ROW == noAck)\n\n {\n\n /* Message not acked. Toggle LED 2. */\n\n toggleLED(2); // Turn On LED2\n\n __delay_cycles(2000);\n\n toggleLED(2); \n\n#ifdef FREQUENCY_AGILITY\n\n /* Assume we're on the wrong channel so look for channel by\n\n * using the Ping to initiate a scan when it gets no reply. With\n\n * a successful ping try sending the message again. Otherwise,\n\n * for any error we get we will wait until the next button\n\n * press to try again.\n\n */\n\n if (SMPL_SUCCESS != SMPL_Ping(sLinkID1))\n\n {\n\n done = 1;\n\n }\n\n#else\n\n done = 1;\n\n#endif /* FREQUENCY_AGILITY */\n\n }\n\n else\n\n {\n\n /* Got the ack or we don't care. We're done. */\n\n done = 1;\n\n }\n\n }\n\n\n\n /* radio back to sleep */\n\n SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_SLEEP, 0);\n\n }\n\n \n\n // } this for the while(1)\n\n \n\n // }\n\n pp=0;\n\n}\n\n}\n\n\n\n\n\nvoid toggleLED(uint8_t which)\n\n{\n\n if (1 == which)\n\n {\n\n BSP_TOGGLE_LED1();\n\n }\n\n else if (2 == which)\n\n {\n\n BSP_TOGGLE_LED2();\n\n }\n\n return;\n\n}\n\n\n\nvoid createRandomAddress()\n\n{\n\n unsigned int rand, rand2;\n\n do\n\n {\n\n rand = TI_getRandomIntegerFromVLO(); // first byte can not be 0x00 of 0xFF\n\n }\n\n while( (rand & 0xFF00)==0xFF00 || (rand & 0xFF00)==0x0000 );\n\n rand2 = TI_getRandomIntegerFromVLO();\n\n \n\n BCSCTL1 = CALBC1_1MHZ; // Set DCO to 1MHz\n\n DCOCTL = CALDCO_1MHZ;\n\n FCTL2 = FWKEY + FSSEL0 + FN1; // MCLK/3 for Flash Timing Generator\n\n FCTL3 = FWKEY + LOCKA; // Clear LOCK & LOCKA bits\n\n FCTL1 = FWKEY + WRT; // Set WRT bit for write operation\n\n \n\n Flash_Addr[0]=(rand>>8) & 0xFF;\n\n Flash_Addr[1]=rand & 0xFF;\n\n Flash_Addr[2]=(rand2>>8) & 0xFF; \n\n Flash_Addr[3]=rand2 & 0xFF; \n\n \n\n FCTL1 = FWKEY; // Clear WRT bit\n\n FCTL3 = FWKEY + LOCKA + LOCK; // Set LOCK & LOCKA bit\n\n}\n\n\n\n/*------------------------------------------------------------------------------\n\n* ADC10 interrupt service routine\n\n------------------------------------------------------------------------------*/\n\n#pragma vector=ADC10_VECTOR\n\n__interrupt void ADC10_ISR(void)\n\n{\n\n __bic_SR_register_on_exit(CPUOFF); // Clear CPUOFF bit from 0(SR)\n\n}\n\n\n\n/*------------------------------------------------------------------------------\n\n* Timer A0 interrupt service routine\n\n------------------------------------------------------------------------------*/\n\n#pragma vector=TIMERA0_VECTOR\n\n__interrupt void Timer_A (void)\n\n{\n\n sSelfMeasureSem = 1; \n\n __bic_SR_register_on_exit(LPM3_bits); // Clear LPM3 bit from 0(SR)\n\n}"
    },
    {
        "link": "https://forum.arduino.cc/t/external-pull-up-resistors-for-i2c/54679",
        "document": "Get your very own domain easily. Fast and professional customer service."
    },
    {
        "link": "https://joshmcguigan.com/blog/internal-pull-up-resistor-i2c",
        "document": "For possibly dubious reasons (the pins were most easily accessible on the hardware) I decided to attempt using I2C as the control protocol for my brushless ESC project.\n\nHaving never used I2C before, I did all the due diligence needed for a hobby project (5 minutes of reading the wikipedia page). You can imagine my surprise when after wiring it all up, nothing worked.\n\nI'll provide just enough background on I2C here to understand the problem I ran into. For further background, the wiki (linked above) provides a succinct introduction.\n\nI2C is a communications protocol supporting two way communications between one or more controllers and one or more targets (ESC in my case, but more typically these are sensors). Since multiple devices can talk on the I2C bus, the protocol (and devices which implement the protocol) needs to gracefully handle the case where more than one device tries to take control of the communication lines at the same time. The way this is done in I2C is to have each device setup its pins in the open drain configuration - allowing any device to actively drive a pin LOW at any time, but never allowing any device to actively drive a pin HIGH. This avoids a case where one device is driving a bus line HIGH while another drives it LOW, which would create a short. However, it means I2C relies on pull-up resistors in order to pull the bus HIGH when in the idle state (when no device is actively pulling it LOW).\n\nThe pins I'm using for I2C can also be used as general purpose IO, so they have internal pull-up resistors that can optionally be enabled. Helpfully, the HAL I'm using includes a configuration option when setting up I2C to enable these pull-up resistors.\n\nI thought using these internal pull-up resistors would help get things going quickly, but when I configured the I2C peripheral at 1 MHz and loaded up the oscilloscope the signal was so distorted I couldn't make any sense of what I was seeing. Unfortunately I didn't get a screen capture of that, but eventually I slowed the I2C communications down to 10 KHz and started analyzing the wave forms.\n\nThese two screen captures show the behavior of the I2C pins from the microcontroller, using only the internal pull-up resistors, while communicating at 10 KHz (ignore the frequency reading at the top right of the screen capture, that is the frequency of the trigger not the underlying bit rate once a transfer starts). Clearly communication is possible at this rate, but especially in the zoomed plot we can begin to see that higher speed communication might be problematic. The rise time here is ~2.5us. One interesting side note is the fall time is several orders of magnitude faster than this - which is caused by the open drain outputs actively pulling the signal down rather than relying on the pull-up resistors.\n\nMoving on to attempt communicaiton at 100 KHz using the internal pull-up resistors, I captured the following.\n\nCompared to the 10 KHz plots I have zoomed in the time axis by a factor of 10, and you can see that when communicating at 100 KHz the rise time of the signal takes nearly the full length of a HIGH clock cycle. This may not be reliable, and it would certainly be unwise to push the speed any higher than this.\n\nThere are many versions of the I2C spec, depending on what speeds a given device supports. But most devices should be capable of sinking 3 mA of current on their I2C pins. At a logic level of 3.3 volts, this means roughly a 1 kOhm resistor should be safe. If you are implementing this in your own circuits, please check the data sheets of your devices before moving forward.\n\nWith a 1 kOhm pull-up resistor on each of the I2C lines, 100 KHz communication looks a lot better.\n\nCommunication at 1 MHz is also feasible in this configuration, although you'll note that once again the rise time starts becoming a more significant fraction of the total HIGH time for a clock cycle.\n\nOne other interesting thing to note in the 1 MHz capture is the long delay at the start of communications. This looks similar to a case of clock stretching, but there was only one device on this I2C bus when I took these captures. Perhaps there is some configuration option for the I2C peripheral on my microcontroller to specify the minimum I2C start signal time, but I haven't looked at this more closely yet.\n\nInternal pull-up resistors may be usable for I2C, but don't be surprised if you need to use stronger external pull-up resistors to get things working, especially if you require higher speeds (above say 10 KHz)."
    }
]