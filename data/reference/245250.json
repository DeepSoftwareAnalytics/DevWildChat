[
    {
        "link": "https://php.net/manual/en/features.session.security.management.php",
        "document": "The session module can not guarantee that the information stored in a session is only viewed by the user who created the session. Additional measures are needed to protect the confidentiality of the session, depending on the value associated with it. The importance of the data carried in the session needs to be assessed and further protection may be deployed; this typically comes at a price, such as reduced convenience for the user. For example, to protect users from a simple social engineering tactic, session.use_only_cookies needs to be enabled. In that case, cookies must be enabled unconditionally on the client side, or sessions will not work. There are several ways to leak an existing session ID to third parties. E.g. JavaScript injections, session IDs in URLs, packet sniffing, physical access to the device, etc. A leaked session ID enables the third party to access all resources associated with a specific ID. First, URLs carrying session IDs. If there are links to an external site or resource, the URL including the session ID might be stored in the external site's referrer logs. Second, a more active attacker might listen to network traffic. If it is unencrypted, session IDs will flow in plain text over the network. The solution is to implement SSL/TLS on the server and make it mandatory for users. HSTS should be used for improved security. Note: Even HTTPS can not protect confidential data at all times. For example the CRIME and Beast vulnerabilities may enable an attacker to read the data. Also, note that many networks employ HTTPS MITM proxies for audit purposes. Attackers may also set up such a proxy.\n\nPHP's session manager is adaptive by default currently. An adaptive session manager bears additional risks. When session.use_strict_mode is enabled, and the session save handler supports it, an uninitialized session ID is rejected and a new one is created. This prevents an attack that forces users to use a known session ID. An attacker may paste links or send emails that contains the session ID. E.g. if session.use_trans_sid is enabled, the victim will start a session using the session ID provided by the attacker. session.use_strict_mode mitigate this risk. Warning User defined save handlers can also support strict session mode by implementing session ID validation. All user defined save handlers should implement session ID validation. The session ID cookie may be set with the domain, path, httponly, secure and, as of PHP 7.3, SameSite attributes. There is precedence defined by browsers. By using the precedence, an attacker can set session ID that could be used permanently. Use of session.use_only_cookies will not solve this issue. session.use_strict_mode mitigates this risk. With session.use_strict_mode=On, the uninitialized session ID will be refused. Note: Even though session.use_strict_mode mitigates the risk of adaptive session management, an attacker can force users to use an initialized session ID which has been created by an attacker. E.g. JavaScript injection. This attack can be mitigated by this manual's recommendations. By following this manual, developers should enable, session.use_strict_mode, use timestamp based session management, and regenerate session IDs using session_regenerate_id() with recommended procedures. If developers follow all of the above, an attacker generated session ID will eventually be deleted. When access to an obsolete session occurs, developers should save all active session data of the user. As this information will be relevant for an ensuing investigation. The user should be forcefully logged out of all sessions, i.e. require them to reauthenticate. This prevents attackers from abusing stolen sessions. Warning Access to an obsolete session does not necessarily suggest an attack. An unstable network and/or immediate deletion of the active session will result in legitimate users using obsolete sessions. As of PHP 7.1.0, session_create_id() has been added. This function may be operated to access all active sessions of a user efficiently by prefixing the session IDs with the user ID. Enabling session.use_strict_mode is vital with this setup. Otherwise, malicious users can set malicious session ID for other users. Note: Users prior to PHP 7.1.0 should use , e.g. , or random_bytes() and hash functions to generate a new session ID. session_create_id() has collision detection and generates a session ID according to the session's INI settings. Use of session_create_id() is preferred.\n\nsession.use_strict_mode is a good mitigation, however not sufficient. Developers must equally use session_regenerate_id() for session security. Session ID regeneration reduces the risk of stolen session IDs, thus session_regenerate_id() must be called periodically. E.g. Regenerate the session ID every 15 minutes for security sensitive content. Even in the case that a session ID is stolen, both the legitimate user's and the attacker's session will expire. In other words access by the user or the attacker will generate an obsolete session access error. Session IDs must be regenerated when user privileges are elevated, such as after authenticating. session_regenerate_id() must be called prior to setting the authentication information to . (session_regenerate_id() saves the current session data automatically in order to save timestamp/etc. to the current session.) Ensure only the new session contains the authenticated flag. Developers must not rely on session ID expiration by session.gc_maxlifetime. Attackers may access a victim's session ID periodically to prevent its expiration and keep exploiting it, including an authenticated session. Warning Although the session manager can manage timestamps transparently, this feature is not implemented. Old session data must be kept until GC. Simultaneously, developers must assure themselves obsolete session data is removed. However, developers must not remove active session data immediately. I.e. and session_destroy() must never be called together for an active session. This may sound contradictory, but this is a mandatory requirement. session_regenerate_id() does not delete outdated sessions by default. Obsolete authenticated sessions may be present for use. Developers must prevent outdated sessions to be consumed by anyone. They must prohibit access to obsolete session data by themselves using timestamps. Warning The sudden removal of an active session produces undesirable side effects. Sessions can vanish when there are concurrent connections to the web application and/or the network is unstable. Potential malicious access is undetectable with the sudden removal of active sessions. Instead of deleting outdated sessions immediately, developers must set a short-term expiration time (timestamp) in , and prohibit access to the session data by themselves. Developers must not prohibit access to old session data immediately after session_regenerate_id(). It must be prohibited at a later stage. E.g. a few seconds later for stable networks, like a wired network, and a few minutes later for unstable networks such as cell phones or Wi-Fi. If a user accesses an obsolete session (expired session), access to it should be denied. It is also recommended to remove the authenticated status from all of the user's sessions to as it is likely to represent an attack. Proper use of session.use_only_cookies and session_regenerate_id() can cause personal DoS with undeletable cookies set by attackers. In this case, developers may invite users to remove cookies and advise them they may be affected by a security issue. Attackers may set malicious cookies via a vulnerable web application, an exposed/vicious browser plugin, a physically compromised device, etc. Warning Do not misunderstand the DoS risk. session.use_strict_mode=On is mandatory for general session ID security! All sites are advised to enable session.use_strict_mode. DoS can only happen when the account is under attack. A JavaScript injection vulnerability in an application represents the most common cause.\n\nObsolete session data must be inaccessible and deleted. The current session module does not handle this well. Obsolete session data should be removed as soon as possible. However, active sessions must not be removed instantly. To satisfy those requirements, developers must implement timestamp based session data management by themselves. Set and manage expiration timestamp in $_SESSION. Prohibit access to outdated session data. When access to obsolete session data is detected, it is advised to remove all authenticated status from the user's sessions and force them to re-authenticate. Access to obsolete session data can represent an attack. To achieve this, developers must keep track of all active sessions of every user. Note: Access to an obsolete session can also happen because of an unstable network and/or concurrent access to the website. E.g. the server tried to set a new session ID via a cookie, but the Set-Cookie packet may not have reached the client due to loss of connection. One connection may issue a new session ID by session_regenerate_id(), but another concurrent connection may not have received the new session ID yet. Therefore, developers must prohibit access to obsolete session at a later stage. I.e. timestamp based session management is mandatory. In summary, session data must not be destroyed with session_regenerate_id() nor session_destroy(), but timestamps must be used to control access to session data. Let session_gc() remove obsolete data from the session data storage.\n\nSession data is locked to avoid race conditions by default. Locking is mandatory to keep session data consistent across requests. However, session-locking can be abused by attackers to perform DoS attacks. To mitigate the risk of a DoS attack by session-locking, minimize locks. Use read only sessions when session data does not need to be updated. Use the 'read_and_close' option with session_start(). Close the session as soon as possible after updating $_SESSION by using session_commit(). The current session module does not detect any modification of $_SESSION when the session is inactive. It is the developer's responsibility not to modify $_SESSION when the session is inactive.\n\nDevelopers should keep track of all active sessions for every user. And notify them of how many active sessions, from which IP (and area), how long it has been active, etc. PHP does not keep track of these. Developers are supposed to do so. Various ways to implement this exist. One possible implementation is setting up a database that keeps track of the required data and stores any relevant information. Since session data is GCed, developers must take care of the GCed data to maintain the active session database consistency. One of the simplest implementations is \"User ID prefixed session ID\" and store the required information in $_SESSION. Many databases posses good performance for selecting string prefix. Developers MAY use session_regenerate_id() and session_create_id() for this. Warning Never employ confidential data as a prefix. If the user ID is confidential, consider using hash_hmac(). Warning Enabling session.use_strict_mode is mandatory for this setup. Ensure it is enabled. Otherwise, the active session database can be compromised. Timestamp based session management is mandatory to detect access to obsolete sessions. When access to an obsolete session is detected, authentication flags should be removed from all active sessions of the user. This prevents attackers to keep exploiting stolen sessions."
    },
    {
        "link": "https://medium.com/@bazlyankov/enhancing-php-session-security-best-practices-and-solutions-c8d3ef22632d",
        "document": "PHP sessions are a critical component of maintaining state and user data across the web requests in many web applications. While PHP provides a robust framework for handling sessions, security concerns such as session hijacking, fixation, and unauthorized access still loom large. In this article, we’ll delve into essential practices to fortify PHP session security, ensuring a safer environment for users and data alike.\n\nPHP sessions typically use cookies to store session IDs. To enhance security, it’s crucial to mark these cookies as Secure and HttpOnly:\n• Secure: Ensures the cookie is sent only over HTTPS, preventing it from being transmitted over unsecured connections.\n• HttpOnly: Makes the cookie inaccessible to JavaScript, thwarting XSS (Cross-Site Scripting) attacks aimed at stealing cookies.\n\nIn PHP, you can set these attributes in the file or at runtime using the function:\n\nRegenerating the session ID at critical transitions within your application (such as login, logout, or privilege level change) is an effective way to mitigate session fixation attacks. This can be easily implemented with PHP’s function:\n\nSessions should not last indefinitely. Implementing an expiration time for sessions can significantly reduce the risk of unauthorized access, especially on shared or public computers. You can handle session expiration by tracking the last activity time:\n\nStoring session data securely is crucial. While the default file storage system is convenient, using more secure methods like encrypted session handlers or databases can provide enhanced security. Make sure that wherever session data is stored, it is properly secured against unauthorized access.\n\nTo further secure sessions against hijacking, validate the session against certain user attributes like IP address and user-agent. However, use these attributes cautiously as they can change legitimately (e.g., when a user moves between networks).\n\nFor highly sensitive operations, re-verify the user’s permissions by checking against a server-side source (like a database) before performing the action. This ensures that any changes in permissions are respected immediately, safeguarding against unauthorized actions.\n\nSecuring PHP sessions is not just about setting and forgetting configuration options. It involves a continuous assessment of potential threats and adapting the security measures accordingly. By implementing the above strategies, developers can significantly bolster the security of their PHP applications, protecting both the data and the integrity of user interactions."
    },
    {
        "link": "https://php.net/manual/en/session.security.php",
        "document": "HTTP session management represents the core of web security. All possible mitigation measures should be adopted to ensure sessions are secured. Developers should also enable/use applicable security measures."
    },
    {
        "link": "https://medium.com/@wearedopethemes/modern-php-session-management-replacing-session-register-and-securing-sessions-df19638cae20",
        "document": "In earlier versions of PHP, the function was a common method for managing user sessions. However, this function has been deprecated since PHP 5.3 and removed entirely in PHP 5.4 due to various security vulnerabilities and inefficiencies. Modern PHP development requires the adoption of more secure and efficient session management techniques. In this tutorial, we will explore how to replace with modern session management techniques, ensuring your PHP applications handle sessions securely and efficiently.\n\nWe will also dive into best practices for securing sessions, preventing attacks like session hijacking, and using advanced techniques like session tokens and encryption to further safeguard user data.\n\nThe function was used in older PHP applications to register session variables. When called, it would store global variables in the session, making them accessible across different pages during a user’s session. However, this method had several limitations and security risks, leading to its deprecation.\n\nThe deprecation of was primarily due to security vulnerabilities and the potential for misuse. Here are some reasons why it was deprecated:\n• Global Scope Issues: The function relied on global variables, which could lead to accidental data overwriting or data leakage between different parts of an application.\n• Session Hijacking Risks: The function did not provide mechanisms to prevent common session-related attacks such as session hijacking, where attackers could take over a user’s session.\n• Lack of Control: Developers had little control over session management and security, making it difficult to enforce secure practices such as session regeneration or setting proper session lifetimes.\n\nAfter the deprecation of , PHP developers were encouraged to use more secure and efficient methods for session management. Below, we will cover some of the most widely-used alternatives.\n\nInstead of relying on , you can directly use the superglobal array to store session data. This method provides greater flexibility and security. For example, here’s how to store a user’s data in a session:\n\nIn this example, the function initializes the session, and the array is used to store session variables.\n\nTo mitigate session fixation attacks, it’s crucial to regenerate session IDs after key events, such as a user login. PHP provides the function to generate a new session ID while preserving the session data:\n\nRegenerating the session ID prevents attackers from using previously stolen session IDs to hijack user sessions.\n\nYou can also enforce a session expiration time to ensure sessions are terminated after a period of inactivity. Here’s an example of how to implement session expiration:\n\nThis code checks if the session has been inactive for 30 minutes. If so, it destroys the session, forcing the user to log in again.\n\nTo further enhance session security, consider the following best practices:\n\nAlways enforce HTTPS connections to prevent session cookies from being transmitted over insecure HTTP connections. This is essential for preventing session hijacking via network eavesdropping.\n\nUse the function to set the and flags on session cookies. The flag ensures cookies are sent over HTTPS only, while prevents JavaScript access to the cookies:\n\nEstablish a session timeout policy to prevent sessions from being left open indefinitely. This can help mitigate the risk of session hijacking, especially on shared computers.\n\nSensitive information, such as passwords or payment details, should never be stored directly in session variables. Instead, store non-sensitive references and retrieve the sensitive data securely when needed.\n\nTo further secure session management in PHP, you can implement more advanced techniques, such as using session tokens, encrypting session data, and implementing CSRF protection.\n\nCross-site request forgery (CSRF) is a common attack that exploits authenticated sessions. By using session tokens, you can validate user requests and prevent CSRF attacks:\n\nThis ensures that only requests with valid CSRF tokens are accepted, preventing unauthorized actions from being carried out on behalf of users.\n\nFor highly sensitive applications, you may want to encrypt session data to protect it from attackers. Use PHP’s and functions to securely encrypt and decrypt session values:\n\nAfter the deprecation of , PHP developers are encouraged to adopt modern, secure techniques for session management. By using the superglobal, session ID regeneration, encryption, and CSRF protection, you can ensure that your PHP applications handle sessions securely and efficiently. Implementing these practices not only future-proofs your applications but also mitigates common vulnerabilities such as session hijacking and CSRF attacks.\n\nIn this tutorial, we covered the reasons behind the deprecation of and explored several modern techniques for secure session management. Following these best practices ensures that your PHP applications can maintain secure user sessions, protecting both user data and overall application integrity."
    },
    {
        "link": "https://cloudways.com/blog/php-session-security",
        "document": "HyperText Transfer Protocol started off as a stateless protocol. This means that every request to the server is self-contained, it carries all the context that the server needs to serve the requested web page. Every message that the client sends to the server can be processed on its own – the server does not maintain the state, nor information about the connection.\n\nWeb applications need a way to preserve a context about the visitor – from logged-in user identity, shopping cart in ecommerce stores, to longer-lasting data like purchase history or chat history in social network applications.\n\nThis is why it was necessary for HTTP, and all the applications building on top of it, to find solutions to manage this inherent statelessness in HTTP. The main solution is cookies.\n\nPHP is maybe the most used programming language for the web (w3techs give it almost 80% ) and it has its own solution for this – PHP sessions. In this article we will describe PHP sessions mechanisms, we will explore PHP session security, and how to secure PHP session cookies.\n\nWe will see what are potential vulnerabilities, and php session security best practices.\n\nHTTP has been made extensible through its headers from the early days. This means that functionality can be added to HTTP requests and responses through user-definable headers.\n\nHeaders are fields in every request and response that can contain various pieces of metadata.\n\nCookies have been published as an addition to the HTTP standard by the IETF in 1997 , and the specification has advanced since then to be finally defined in RFC 6265 , titled HTTP State Management Mechanism .\n\nCookies are defined by IETF as a mechanism that consists of HTTP header fields that can be used by the servers to store pieces of data (state) in HTTP clients. This makes it possible for the server to keep a stateful context, called session, across multiple HTTP requests.\n\nThe user’s browser (the client) then sends back these cookies to the server on subsequent requests, making it possible for the server to reconstruct states, such as buyer’s journey, a shopping cart, or a social media account.\n\nWe can distinguish between session cookies and persistent cookies. Session cookies are transient – they only last for the duration of that particular browser session. They live in the browser memory. Because they expire when the current browser instance is shut down, they do not have an expiration date.\n\nPersistent cookies have an expiration date, they are meant to last for a specific length of time.\n\nThey are used for things like the personalization of user experience, session management – including users logged in / logged out state, carts, and for tracking of user’s behavior.\n\nCookies usually store a very limited amount of data (maximum is 4096 bytes per website), and they are stored on visitor’s machines. This makes cookies limited and insecure – not enough to provide for the session needs of modern websites on their own.\n\nPHP as a web programming language belongs to the application layer. PHP builds on HTTP cookies to provide a mechanism to maintain context across multiple requests. For this, it combines custom, specific cookie header with its own session handler class:\n\nThis mechanism can be extended or completely rewritten by inheriting the SessionHandler class or by implementing SessionHandlerInterface.\n\nIn PHP, sessions are by default persisted as files on the server. Files carry names of their respective session ID-s. When the session is initiated, PHP sets a PHPSESSID cookie with a session id. Later, when the visitor’s browser returns that cookie on each request, the server associates it with the session data in the file related to that session. The result is a continuous session state across multiple pages on a website.\n\nA session in PHP can be started with a call to a function session_start() . This function either starts a new session, or restores an existing session passed to the server in a cookie, or in POST or GET request parameters. $_SESSION superglobal array is then used to set or to get variables in a session.\n\nIf we then want to use session variables on other pages of the same website, another PHP document needs to use session_start() . This will make $_SESSION variables, which may have been set on other web pages/documents, available on the current one.\n\nsession_close() commits the changes to $_SESSION to the disk\n\nsession_destroy() function will destroy all the session data. To fully remove the session, it is also necessary to unset the session ID, and explicitly delete the session cookie. Beyond these basics, PHP has a host of other functions for session handling .\n\nThe functionality that PHP sessions try to provide – persistent data across the visits to pages of a website – is indispensable to modern websites. PHP sessions implementation however is a point of contention.\n\nSince session data in PHP is written to a file on the server by default, and the file is locked during the script execution, this can present challenges in terms of performance and scaling.\n\nPHP sessions also present challenges to the normal caching mechanism – caching pages with PHPSESSID cookie set could seriously compromise the website while bypassing the cache for pages with PHPSESSID would mean bypassing cache on the entire website.\n\nAnd then, there are security issues.\n\nPHP sessions are a step forward in regards to security compared to a system where all the session data is stored within cookies. PHPSESSID cookie merely stores a reference ID for a session file that lives on a server.\n\nPHP default setting for a path to save session files, which we can find in php.ini configuration files is session.save_path = “/tmp” . This means that session files could effectively get compromised by other users.\n\nThis issue is particularly alarming when we recall that the majority of PHP-powered websites live on shared servers with multiple tenants.\n\nThe most common of all session exploits is Session Hijacking.\n\nSession Hijacking happens when a malicious party gains illegal access to another user’s session. The attacker will first obtain the session ID belonging to another user. Then he will use this ID to gain full access to the other user’s session. The session ID is enough for the server to give access to the respective account.\n\nTheoretically, the Session ID could be obtained by prediction or guessing (brute force), but the most likely way is for the Session ID to be stolen. Both brute force attack, or predicting the ID is much less likely to happen.\n\nThere are several vectors by which an attacker can gain access to users’ Session ID.\n\nSession Hijacking can happen in many different ways – here we mention only those which are more notorious:\n• XSS or Cross-Site Scripting – this is an attack that happens when a third party succeeds to inject javascript into the body of a website visited by the victim. Let’s say that a website XY uses GET variables, and does not properly sanitize them.An attacker can use javascript in a GET request and get it injected into the body of a web page, gaining the same level of access as the website’s own javascript. For example, it can get the content of the PHPSESSID cookie, and then send it to the attacker.\n• Session Sidejacking – this type of attack happens with Man In The Middle attack vector – in situations when the attacker is positioned between the source and the destination of the traffic. The attacker will listen to requests and responses, and, unless the traffic is encrypted, he can capture the Session ID.\n• Session Fixation happens with vulnerable web applications, which don’t insist on always setting a new Session ID upon user authentication, but instead accept an existing Session ID when it exists. In this type of attack, the attacker will forge a valid, but unused Session ID, and then, through various schemes, make a valid user authenticate using that ID. After that, having possession of the authenticated user’s ID, the attacker gains access to the user’s session.\n• Session Prediction – in this type of attack, the attacker will usually have some knowledge of how the application generates Session ID-s, and will then try to guess other user’s IDs using the same method. This is where the randomness of Session ID-s generation plays a big role.\n\nWhat Can An Attacker Do With a Session That Was Successfully Hijacked?\n\nOnce an attacker gains access to the session that belongs to a legitimate user, the server will grant him all authority that the original user has. As such, the Session ID can be likened to a key that grants its owner access to the house, regardless if he was the house owner or not.\n\nThis attack will often be focused on users & sessions with administrative access, so in those cases, the attacker will gain administrative rights on the compromised website.\n\nPHP Session Security Best Practices, and importance of PHP session.cookie_secure flag\n\nBefore continuing to different measures we can take to prevent our sessions from being exploited by attackers, it is important to say that vulnerabilities connected to PHP sessions are not something specific to the language itself. They are not an inherent flaw of PHP – other technologies require similar measures to mitigate these same vectors of attack.\n\nSo what are common-sense measures we can take to mitigate Session hijacking attacks?\n• XSS (Cross-Site Scripting) Attack – mitigation against this type of attack is not sessions-specific. The website needs to prevent any kind of user input from being executed in the visitor’s browser. This simply means that any user input, through forms or GET parameters, or other needs to be sanitized before it is used. This is a general security measure for web applications, for this and other types of attacks (e.g., SQL injection). The main two functions in PHP used to sanitize strings are htmlspecialchars() and strip_tags(). htmlspecialchars() converts special characters into html entities, and strip_tags() will simply remove all the HTML tags, including <script> tag.Another measure we can take to protect against this type of attack is a php.ini setting – session.cookie_httponly.HttpOnly cookies were first implemented in now-infamous Internet Explorer 6, to later be adopted by other browsers. session.cookie_httponly flag adds an instruction to the browser not to allow client-side javascript to access the cookie: it will add an optional HttpOnly instruction to Set-Cookie response header.\n• Session Sidejacking – this line of attack can be prevented with SSL encryption implemented along the entire request – response surface. However, even if the connection is fully encrypted, there still remains the possibility of leaking the session cookie.\n\n For example, after the visitor/client has already visited the website and there is an active session with PHPSESSID cookie in the browser – the visitor may try to visit the same website over a public network – and when he enters the bare website address (without the protocol scheme), browser will first send the request to the insecure, http version of the address. Only then, as a response, will it be redirected to https version (301 redirect).But in itself, this insecure redirection roundtrip will be enough to transmit previously existing session cookie, which can be intercepted by the attacker and used to hijack the session.How to make php session cookies secure?There is a settings flag that can be used to eliminate this threat in PHP -session.cookie_secure . This setting is by default set to off – but, when it is turned on , it will instruct the user’s browser to only transmit session cookies over an encrypted connection – it will add secure instruction to Set-Cookie response header.\n• Session Fixation – when an attacker gets a genuine user to set a predefined Session-Id – is most often used in URL-based session management. This means that Session ID is contained within the URL as a GET argument. Another possibility is a hidden form field in a form created by the attacker, then tricking the victim to sign in through that form. There are various possible ways to fix a session through manipulating cookies, as well. The Open Web Application Security Project (OWASP) has more examples of Session Fixation attacks.\n\n The main PHP setting related to this particular security risk is session.use_trans_sid. This setting, when set to 1, will enable “transparent session ID-s” – it will allow PHP to pass the session ID in urls in cases when the visitor’s browser doesn’t support cookies. This is by default set to 0, which means transparent SID-s are disabled for security purposes. By setting use_trans_id to 1, for example, we risk that someone could access the session (on a public computer, for example), by accessing the url containing session ID in the browser’s history, or by examining logs of devices in the middle.session.use_only_cookies is another PHP setting (set to On by default). This setting disables completely the use of url parameters as session ID-s.So, in order for Session ID-s to be usable in URL-s, we would need both of these settings as follows:\n• Session Prediction – to prevent this, web applications need to generate Session ID-s with enough length and sufficient level of randomness (entropy). The default PHP settings with modern (7.1.0+) PHP are probably safe enough, but in case the application deploys custom session solutions, this is something to be aware of.PHP settings we can use to change length/entropy are session.sid_length and session.sid_bits_per_character.PHP versions prior to v7.1.0 also had session.hash_function, session.hash_bits_per_character, session.entropy_file and session.entropy_length as additional settings variables to more explicitly set the Session ID entropy. We can find the full reference of PHP session settings here.\n\nPHP sessions security is an ongoing concern. PHP web applications (such as WordPress, or Laravel framework) often find native PHP sessions inadequate or insecure for their needs, and choose to roll out completely custom solutions and forego PHP sessions, while others like Zend framework, choose to build customized solutions on top of PHP native sessions. Whichever path we choose, it is important to be aware of all the security and PHP performance concerns.\n\nIn this article, we covered some fundamental PHP session security concerns we need to keep in mind, and PHP security best practices. As such, it is more of an overview than an exhaustive list of all the caveats, so we encourage readers to also do their own research when it comes to PHP session & cookie security.\n\nDo you have anything to add? Let us know in the comments."
    },
    {
        "link": "https://stackoverflow.com/questions/2138527/php-curl-and-http-post-example",
        "document": "I expect the cURL to return a response like result=OK . Are there any examples?\n\nI want to send data like this:\n\nCan anyone show me how to do a PHP cURL with an HTTP POST?\n\n// set post fields $post = [ 'username' => 'user1', 'password' => 'passuser1', 'gender' => 1, ]; $ch = curl_init('http://www.example.com'); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); // execute! $response = curl_exec($ch); // close the connection, release resources used curl_close($ch); // do anything you want with your response var_dump($response); <?php // mutatis mutandis namespace MyApp\\Http; class CurlPost { private $url; private $options; /** * @param string $url Request URL * @param array $options cURL options */ public function __construct($url, array $options = []) { $this->url = $url; $this->options = $options; } /** * Get the response * @return string * @throws \\RuntimeException On cURL error */ public function __invoke(array $post) { $ch = \\curl_init($this->url); foreach ($this->options as $key => $val) { \\curl_setopt($ch, $key, $val); } \\curl_setopt($ch, \\CURLOPT_RETURNTRANSFER, true); \\curl_setopt($ch, \\CURLOPT_POSTFIELDS, $post); $response = \\curl_exec($ch); $error = \\curl_error($ch); $errno = \\curl_errno($ch); if (\\is_resource($ch)) { \\curl_close($ch); } if (0 !== $errno) { throw new \\RuntimeException($error, $errno); } return $response; } } // create curl object $curl = new \\MyApp\\Http\\CurlPost('http://www.example.com'); try { // execute the request echo $curl([ 'username' => 'user1', 'password' => 'passuser1', 'gender' => 1, ]); } catch (\\RuntimeException $ex) { // catch errors die(sprintf('Http error %s with code %d', $ex->getMessage(), $ex->getCode())); } Side note here: it would be best to create some kind of interface called for example with method and let the class above implement it. Then you can always swap this implementation with another adapter of your like, without any side effects to your application. Usually there's a problem with cURL in PHP under the Windows operating system. While trying to connect to a https protected endpoint, you will get an error telling you that . What most people do here is to tell the cURL library to simply ignore certificate errors and continue ( ). As this will make your code work, you introduce huge security hole and enable malicious users to perform various attacks on your app like Man In The Middle attack or such. Never, ever do that. Instead, you simply need to modify your and tell PHP where your file is to let it verify certificates correctly: ; modify the absolute path to the cacert.pem file curl.cainfo=c:\\php\\cacert.pem The latest can be downloaded from the Internet or extracted from your favorite browser. When changing any related settings remember to restart your webserver.\n• If your request has headers like bearer token or defining JSON contents you have to set options to cURL: $token = \"generated token code\"; curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // for define content type that is json 'bearer: '.$token, // send token in header request 'Content-length: 100' // content length for example 100 characters (can add by strlen($fields)) ) );\n• If you want to include the header in the output set to :\n• Set option to to return the transfer as a string instead of outputting it directly:\n• To check the existence of a common name in the SSL peer certificate can be set to , , 2(default value and for production mode) :\n• For posting fields as an array by cURL:\n• Execute cURL and return the string. depending on your resource this returns output like :\n• The whole class that can be extended: class class_name_for_call_cURL { protected function getUrl() { return \"www.domain.com\"; } public function call_cURL() { $token = \"generated token code\"; $fields = array( \"username\" => \"user1\", \"password\" => \"passuser1\", \"gender\" => 1 ); $url = $this->getUrl(); $output = $this->_execute($fields, $url, $token); // if you want to get json data // $output = json_decode($output); if ($output == \"OK\") { return true; } else { return false; } } private function _execute($postData, $url, $token) { // for sending data as json type $fields = json_encode($postData); $ch = curl_init($url); curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // if the content type is json 'bearer: '.$token // if you need token in header ) ); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($ch, CURLOPT_POSTFIELDS, $fields); $result = curl_exec($ch); curl_close($ch); return $result; } }\n• Using the class and call cURL:\n• A function for using anywhere that needed: function get_cURL() { $url = \"www.domain.com\"; $token = \"generated token code\"; $postData = array( \"username\" => \"user1\", \"password\" => \"passuser1\", \"gender\" => 1 ); // for sending data as json type $fields = json_encode($postData); $ch = curl_init($url); curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // if the content type is json 'bearer: '.$token // if you need token in header ) ); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($ch, CURLOPT_POSTFIELDS, $fields); $result = curl_exec($ch); curl_close($ch); return $result; }\n• This function is usable just by:\n\nit's simple, it works; I use it in an environment where I control the code at both ends. even better, use json_decode (and set up your code to return JSON) this approach invokes curl behind the scenes, but you don't jump through as many hoops. Answer refined from this original answer elsewhere on Stack Overflow: PHP sending variables to file_get_contents()\n\nA simpler answer IF you are passing information to your own website is to use a SESSION variable. Begin php page with: If at some point there is information you want to generate in PHP and pass to the next page in the session, instead of using a POST variable, assign it to a SESSION variable. Example: $_SESSION['message']='www.'.$_GET['school'].'.edu was not found. Please try again.' Then on the next page you simply reference this SESSION variable. NOTE: after you use it, be sure you destroy it, so it doesn't persist after it is used:\n\nI think this might be helpful if you are using Postman, as it would make the process very easy here in the given below I attached picture you can refer also if you need to convert the response to any other type let me know i will help you <?php // code by Dasun 18/04/2022 // The data to be sent $data = array( 'username' => 'user1', 'password' => 'passuser1', 'gender' => '1' ); // The target URL $url = 'http://www.example.com'; // Initialize cURL $ch = curl_init($url); // Set the request method to POST curl_setopt($ch, CURLOPT_POST, true); // Set the POST data curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data)); // Set the response format to plain text curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // Execute the request and get the response $response = curl_exec($ch); // Close the cURL handle curl_close($ch); // Output the response echo $response; ?>\n\nIf you try to login on site with cookies. if ($server_output == \"OK\") { ... } else { ... } It May not works if you try to login, because many sites return status 200, but the post is not successful. The easy way to check if the login post is successful is to check if it setting cookies again. If in output have a Set-Cookies string, this means the posts are not successful and it starts a new session. Also, the post can be successful, but the status can redirect instead of 200. To be sure the post is successful try this: Follow location after the post, so it will go to the page where the post does redirect to: And than check if new cookies existing in the request: if (!preg_match('/^Set-Cookie:\\s*([^;]*)/mi', $server_output)) {echo 'post successful'; } else { echo 'not successful'; }"
    },
    {
        "link": "https://php.net/manual/en/book.curl.php",
        "document": "frank at interactinet dot com ¶ I wrote the following to see if a submitted URL has a valid http response code and also if it responds quickly. \n\n \n\nUse the code like this: \n\n \n\n \n\nThe second argument is optional, and it allows you to check for a specific response code \n\n \n\n \n\nThe third allows you to specify how long you are willing to wait for a response. \n\n \n\n \n\n \n\nHope this example helps. It is not 100% tested, so any feedback [sent directly to me by email] is appreciated.\n\nartax_N_O_S_P_A_M_erxes2 at iname dot com ¶ \n\nOn a default install of Fedora, setting up the proper cURL parameters, I would get an error: \n\n \n\n$ php curl.php \n\n Peer certificate cannot be authenticated with known CA certificates \n\n \n\nThe data on \n\n \n\n# cd /etc/pki/nssdb \n\n# ln -s /usr/lib64/libnssckbi.so libnssckbi.so \n\n \n\nNow you can do client authentication, provided you have your certificate handy with: \n\n \n\n I needed to use cURL in a php script to download data using not only SSL for the server authentication but also for client authentication.On a default install of Fedora, setting up the proper cURL parameters, I would get an error:$ php curl.phpPeer certificate cannot be authenticated with known CA certificatesThe data on http://curl.haxx.se/docs/sslcerts.html was most useful. Indeed, toward to bottom it tells you to add a missing link inside /etc/pki/nssdb to use the ca-bundle.crt file. You do it so:# cd /etc/pki/nssdb# ln -s /usr/lib64/libnssckbi.so libnssckbi.soNow you can do client authentication, provided you have your certificate handy with:\n\nramez at dot dontspan dot zegenie dot com ¶ CURL failed with PHP5.3 and Apache2.2.X on my Windows 7 machine. \n\n\n\nIt turns out that it's not enough to copy the two dll's mentioned (libeay32 and sslea32) from the php folder into your system32 folder. You HAVE TO UNBLOCK THESE TWO FILES.\n\n\n\nRight click the file, select unblock, for each one. Then restart Apache.\n\n\n\nAnother very handy security feature added into Windows.\n\njcmargentina at gmail dot com ¶ Please note that new versions of curl is using http2 as default, so if you are having some strange errors, 0 http status codes, etc, please explicitly specify the http version in your code.\n\nfred dot knieper at gmail dot com ¶ After a lot of frustration with the fact that nobody has documented which curl commandline options go with which library functions, I discovered that the curl commandline will tell you (in the form of a C program) if you add `--libcurl foo.c`\n\n\n\nIf you've been struggling with trying to figure out how to get your fancy curl commandline to work in PHP, this makes it a breeze!"
    },
    {
        "link": "https://github.com/php-curl-class/php-curl-class",
        "document": "PHP Curl Class makes it easy to send HTTP requests and integrate with web APIs.\n\nTo install PHP Curl Class, run the following command:\n\nInstallation instructions to use the command can be found on https://github.com/composer/composer.\n\nMore examples are available under /examples.\n\n. ; \\ ; = (); -> ( ( ) { . -> . . ; . ; ( -> ); }); -> ( ( ) { . -> . . ; . -> . ; . -> . ; }); -> ( ( ) { . ; }); -> ( , [ => , ]); -> ( , [ => , ]); -> ( , [ => , ]); -> (); // Blocks until all items in the queue have been processed.\n\nMore examples are available under /examples.\n\nSee TROUBLESHOOTING for help troubleshooting.\n• Check for open issues or open a new issue to start a discussion around a bug or feature.\n• Fork the repository on GitHub to start making your changes.\n• Write one or more tests for the new feature or that expose the bug.\n• Make code changes to implement the feature or fix the bug.\n• Send a pull request to get your changes merged and published."
    },
    {
        "link": "https://php.net/manual/en/function.curl-setopt.php",
        "document": "joey ¶ It is important that anyone working with cURL and PHP keep in mind that not all of the CURLOPT and CURLINFO constants are documented. I always recommend reading the cURL documentation directly as it sometimes contains better information. The cURL API in tends to be fubar as well so do not expect things to be where you would normally logically look for them.\n\n\n\ncurl is especially difficult to work with when it comes to cookies. So I will talk about what I found with PHP 5.6 and curl 7.26.\n\n\n\nIf you want to manage cookies in memory without using files including reading, writing and clearing custom cookies then continue reading.\n\n\n\nTo start with, the way to enable in memory only cookies associated with a cURL handle you should use:\n\n\n\n curl_setopt($curl, CURLOPT_COOKIEFILE, \"\");\n\n\n\ncURL likes to use magic strings in options as special commands. Rather than having an option to enable the cookie engine in memory it uses a magic string to do that. Although vaguely the documentation here mentions this however most people like me wouldn't even read that because a COOKIEFILE is the complete opposite of what we want.\n\n\n\nTo get the cookies for a curl handle you can use:\n\n\n\n curl_getinfo($curl, CURLINFO_COOKIELIST);\n\n\n\nThis will give an array containing a string for each cookie. It is tab delimited and unfortunately you will have to parse it yourself if you want to do anything beyond copying the cookies.\n\n\n\nTo clear the in memory cookies for a cURL handle you can use:\n\n\n\n curl_setopt($curl, CURLOPT_COOKIELIST, \"ALL\");\n\n\n\nThis is a magic string. There are others in the cURL documentation. If a magic string isn't used, this field should take a cookie in the same string format as in getinfo for the cookielist constant. This can be used to delete individual cookies although it's not the most elegant API for doing so.\n\n\n\nFor copying cookies I recommend using curl_share_init.\n\n\n\nYou can also copy cookies from one handle to another like so:\n\n\n\n foreach(curl_getinfo($curl_a, CURLINFO_COOKIELIST) as $cookie_line)\n\n curl_setopt($curl, CURLOPT_COOKIELIST, $cookie_line);\n\n\n\nAn inelegant way to delete a cookie would be to skip the one you don't want. \n\n\n\nI only recommend using COOKIELIST with magic strings because the cookie format is not secure or stable. You can inject tabs into at least path and name so it becomes impossible to parse reliably. If you must parse this then to keep it secure I recommend prohibiting more than 6 tabs in the content which probably isn't a big loss to most people.\n\n\n\nA the absolute minimum for validation I would suggest:\n\n\n\n /^([^\\t]+\\t){5}[^\\t]+$/D\n\n\n\nHere is the format:\n\n\n\n #define SEP \"\\t\" /* Tab separates the fields */\n\n \n\n char *my_cookie =\n\n \"example.com\" /* Hostname */\n\n SEP \"FALSE\" /* Include subdomains */\n\n SEP \"/\" /* Path */\n\n SEP \"FALSE\" /* Secure */\n\n SEP \"0\" /* Expiry in epoch time format. 0 == Session */\n\n SEP \"foo\" /* Name */\n\n SEP \"bar\"; /* Value */\n\nregan dot corey at gmail dot com ¶ I spent a couple of days trying to POST a multi-dimensional array of form fields, including a file upload, to a remote server to update a product. Here are the breakthroughs that FINALLY allowed the script to run as desired.\n\n\n\nFirstly, the HTML form used input names like these:\n\n<input type=\"text\" name=\"product[name]\" />\n\n<input type=\"text\" name=\"product[cost]\" />\n\n<input type=\"file\" name=\"product[thumbnail]\" />\n\nin conjunction with two other form inputs not part of the product array\n\n<input type=\"text\" name=\"method\" value=\"put\" />\n\n<input type=\"text\" name=\"mode\" />\n\n\n\nI used several cURL options, but the only two (other than URL) that mattered were:\n\ncurl_setopt($handle, CURLOPT_POST, true);\n\ncurl_setopt($handle, CURLOPT_POSTFIELDS, $postfields);\n\nPretty standard so far.\n\nNote: headers didn't need to be set, cURL automatically sets headers (like content-type: multipart/form-data; content-length...) when you pass an array into CURLOPT_POSTFIELDS.\n\nNote: even though this is supposed to be a PUT command through an HTTP POST form, no special PUT options needed to be passed natively through cURL. Options such as\n\ncurl_setopt($handle, CURLOPT_HTTPHEADER, array('X-HTTP-Method-Override: PUT', 'Content-Length: ' . strlen($fields)));\n\nor\n\ncurl_setopt($handle, CURLOPT_PUT, true);\n\nor\n\ncurl_setopt($handle, CURLOPT_CUSTOMREQUEST, \"PUT);\n\nwere not needed to make the code work.\n\n\n\nThe fields I wanted to pass through cURL were arranged into an array something like this:\n\n$postfields = array(\"method\" => $_POST[\"method\"],\n\n \"mode\" => $_POST[\"mode\"],\n\n \"product\" => array(\"name\" => $_POST[\"product\"], \n\n \"cost\" => $_POST[\"product\"][\"cost\"], \n\n \"thumbnail\" => \"@{$_FILES[\"thumbnail\"][\"tmp_name\"]};type={$_FILES[\"thumbnail\"][\"type\"]}\")\n\n );\n\n\n\n-Notice how the @ precedes the temporary filename, this creates a link so PHP will upload/transfer an actual file instead of just the file name, which would happen if the @ isn't included.\n\n-Notice how I forcefully set the mime-type of the file to upload. I was having issues where images filetypes were defaulting to octet-stream instead of image/png or image/jpeg or whatever the type of the selected image.\n\n\n\nI then tried passing $postfields straight into curl_setopt($this->handle, CURLOPT_POSTFIELDS, $postfields); but it didn't work.\n\nI tried using http_build_query($postfields); but that didn't work properly either.\n\nIn both cases either the file wouldn't be treated as an actual file and the form data wasn't being sent properly. The problem was HTTP's methods of transmitting arrays. While PHP and other languages can figure out how to handle arrays passed via forms, HTTP isn't quite as sofisticated. I had to rewrite the $postfields array like so:\n\n$postfields = array(\"method\" => $_POST[\"method\"],\n\n \"mode\" => $_POST[\"mode\"],\n\n \"product[name]\" => $_POST[\"product\"], \n\n \"product[cost]\" => $_POST[\"product\"][\"cost\"], \n\n \"product[thumbnail]\" => \"@{$_FILES[\"thumbnail\"][\"tmp_name\"]}\");\n\ncurl_setopt($handle, CURLOPT_POSTFIELDS, $postfields);\n\n\n\nThis, without the use of http_build_query, solved all of my problems. Now the receiving host outputs both $_POST and $_FILES vars correctly."
    },
    {
        "link": "https://serpapi.com/blog/how-to-use-curl-in-php",
        "document": "If you're working with PHP and need to get or send data from a website, cURL is the tool you'll need. This post is going to show you the basics of cURL: what it is, and how you can use it in your PHP projects.\n\nWe'll go through easy examples to help you understand how to make cURL work for you. So, let's get started and learn how to use this handy tool in PHP!\n\nWhat is cURL in PHP?\n\ncURL in PHP is a tool that lets you make requests to other websites or servers from your PHP code. It's like using a web browser or phone app to access a website or online service, but your PHP script does it instead.\n\nYou can use cURL to get data from a website, send files, or interact with APIs (which are like special access points for different online services). It's handy for making your PHP code talk to other websites or online services.\n\nHow to use cURL in PHP?\n\nUnlike other programming languages, cURL is supported out of the box in PHP. This is a step-by-step on how to use cURL in PHP:\n\nStep 1: Install libcurl\n\nWe need to install the libcurl itself first (library for cURL). Please note that this is not a PHP package. It's the curl library itself.\n\nStep 2: Verify it's enabled\n\nCreate a simple PHP script that calls the function. This function outputs a lot of information about your PHP environment, including which extensions are enabled. Look for a section about cURL. If it's there, cURL is enabled.\n\nVisit the page and locate the \"cURL support\" section to see if it's already enabled.\n\nWhat if it isn't enabled yet?\n\nOpen your file, which is the configuration file for PHP. Look for a line that says . Uncomment this line, then save the file. Don't forget to restart the server as well.\n\nStep 3: Start writing cURL!\n\nHere is a simple cURL example in PHP\n\nCode explanation:\n\n- curl_init: initialize the curl\n\n- curl_setopt: any option or setting for this curl request\n\n- curl_exec: To execute the curl\n\n- curl_close: closing the connection\n\nThis will be the default template when running a cURL in PHP.\n\nHere are some cURL commands in PHP.\n\nSure, I'll list some common cURL settings in PHP for different types of requests. These are to be used with or functions between and .\n\nNo additional settings are required for a simple GET request beyond initializing cURL and setting the URL.\n\nTo save the output directly to a file:\n\nRemember to close the file with after .\n\nTo add a custom header to your request:\n\nRemember to replace with the actual proxy server address and port.\n\nSee a real-world example using SerpApi API with cURL:\n\nBenefits of using cURL in PHP\n\n\n\nHere are the top five benefits of using cURL in PHP instead of performing cURL commands directly on the command line:\n• Integration with Web Applications: Using cURL in PHP allows for direct integration with web applications. This is crucial for dynamically fetching data from external sources, interacting with APIs, and integrating these processes seamlessly into the overall workflow of the web application.\n• Automated Data Processing: PHP enables automatic processing and manipulation of the data retrieved through cURL. This is particularly useful for handling responses in various formats like JSON or XML, which are common in web services and APIs.\n• Error Handling: PHP offers more sophisticated error-handling capabilities when using cURL. This allows for more robust programming by programmatically responding to different error conditions, logging them, or triggering specific actions based on the type of error.\n• Dynamic Request Customization: PHP can dynamically create cURL requests based on various conditions such as user input, database contents, or other logic. This flexibility is essential for applications requiring customizable and dynamic web requests.\n• Session Management: cURL in PHP can be used in conjunction with session management to maintain stateful interactions with external services. This is important for scenarios like web scraping or dealing with APIs that require authenticated sessions.\n\nThese benefits make using cURL in PHP advantageous for developing complex, data-driven web applications, especially compared to the more manual and less dynamic nature of command-line cURL usage.\n\nWhat is the curl alternative in PHP?\n\nGuzzle can be considered a modern alternative to cURL in PHP. Guzzle is a PHP HTTP client that makes it easy to send HTTP requests and trivial to integrate with web services.\n\nLink: https://docs.guzzlephp.org/en/latest/"
    }
]