[
    {
        "link": "https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/CollectionUtils.html",
        "document": "\n• Instantiate a new with an initial capacity that can accommodate the specified number of elements without any immediate resize/rehash operations to be expected. This differs from the regular constructor which takes an initial capacity relative to a load factor but is effectively aligned with the JDK's . - the expected number of elements (with a corresponding capacity to be derived so that no resize/rehash operations are needed)\n• Instantiate a new with an initial capacity that can accommodate the specified number of elements without any immediate resize/rehash operations to be expected. This differs from the regular constructor which takes an initial capacity relative to a load factor but is aligned with Spring's own and constructor semantics as of 5.3. - the expected number of elements (with a corresponding capacity to be derived so that no resize/rehash operations are needed)\n• Convert the supplied array into a List. A primitive array gets converted into a List of the appropriate wrapper type. NOTE: Generally prefer the standard method. This method is just meant to deal with an incoming Object value that might be an or a primitive array at runtime. A source value will be converted to an empty List.\n• Marshal the elements from the given enumeration into an array of the given type. Enumeration elements must be assignable to the type of the given array. The array returned will be a different instance than the array given.\n• Return a (partially unmodifiable) map that combines the provided two maps. Invoking or on the returned map results in an In the case of a key collision, takes precedence over . In other words, entries in with a key that is also mapped by are effectively ignored. - the first map to compose - the second map to compose a new map that composes the given two maps\n• , or will throw an is . The same applies to . Return a map that combines the provided maps. Invoking on the returned map will apply, or will throw an is. The same applies to and In the case of a key collision, takes precedence over . In other words, entries in with a key that is also mapped by are effectively ignored. - the first map to compose - the second map to compose - applied when is invoked. If , throws an . - applied when is invoked. If , throws an . a new map that composes the give maps"
    },
    {
        "link": "https://stackoverflow.com/questions/11152536/checking-if-a-collection-is-empty-in-java-which-is-the-best-method",
        "document": "I have two ways of checking if a List is empty or not\n\nMy arch tells me that the former is better than latter. But I think the latter is better.\n\nCan anyone please clarify it?"
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/3.2.4.RELEASE_to_4.0.0.RC2/Spring%20Framework%203.2.4.RELEASE/org/springframework/util/CollectionUtils.html",
        "document": "\n• Return if the supplied Collection is or empty. Otherwise, return . whether the given Collection is empty\n• Return if the supplied Map is or empty. Otherwise, return . whether the given Map is empty\n• Convert the supplied array into a List. A primitive array gets converted into a List of the appropriate wrapper type. A source value will be converted to an empty List.\n• Merge the given array into the given Collection. - the array to merge (may be ) - the target Collection to merge the array into\n• Merge the given Properties instance into the given Map, copying all properties (key-value pairs) over. Uses to even catch default properties linked into the original Properties instance. - the Properties instance to merge (may be ) - the target Map to merge the properties into\n• Check whether the given Iterator contains the given element. - the element to look for\n• Check whether the given Enumeration contains the given element. - the element to look for\n• Check whether the given Collection contains the given element instance. Enforces the given instance to be present, rather than returning for an equal element as well. - the element to look for\n• Return if any element in ' ' is contained in ' '; otherwise returns . - the candidates to search for whether any of the candidates has been found\n• Return the first element in ' ' that is contained in ' '. If no element in ' ' is present in ' ' returns . Iteration order is implementation specific. - the candidates to search for the first present object, or if not found\n• Find a single value of the given type in the given Collection. - the type to look for a value of the given type found if there is a clear match, or if none or more than one such value found\n• Find a single value of one of the given types in the given Collection: searching the Collection for a value of the first type, then searching for a value of the second type, etc. - the types to look for, in prioritized order a value of one of the given types found if there is a clear match, or if none or more than one such value found\n• Determine whether the given Collection only contains a single unique object. if the collection contains a single reference or multiple references to the same instance, else\n• Find the common element type of the given Collection, if any. the common element type, or if no clear common type has been found (or the collection was empty)\n• Marshal the elements from the given enumeration into an array of the given type. Enumeration elements must be assignable to the type of the given array. The array returned will be a different instance than the array given.\n• Adapt an enumeration to an iterator.\n• Returns an unmodifiable view of the specified multi-value map. - the map for which an unmodifiable view is to be returned. an unmodifiable view of the specified multi-value map."
    },
    {
        "link": "https://stackoverflow.com/questions/12721076/best-practice-to-validate-null-and-empty-collection-in-java",
        "document": "If you use the Apache Commons Collections library in your project, you may use the and methods which respectively check if a collection or a map is empty or null (i.e. they are \"null-safe\").\n\nThe code behind these methods is more or less what user @icza has written in his answer.\n\nRegardless of what you do, remember that the less code you write, the less code you need to test as the complexity of your code decreases."
    },
    {
        "link": "https://medium.com/nerd-for-tech/why-use-collectionutils-isempty-over-isempty-in-spring-9a51b2cf8e54",
        "document": "Why Use CollectionUtils.isEmpty() Over isEmpty() in Spring\n\nIn Spring applications, we often deal with collections like lists or sets, checking whether they contain any elements before performing operations. However, directly calling on a collection can throw a if the collection is . This is where Spring’s method proves to be valuable.\n\nLet’s explore the difference between using and , and why the former is safer.\n\nIn this context, is a collection, such as a or , that holds IDs representing certain procedures in a system. For example, it could be a list of IDs corresponding to medical procedures, workflow steps, or some business process in an application.\n\nBefore performing operations on this collection, like iterating through the IDs or checking for specific elements, it’s important to confirm that contains elements. However, if is , directly calling can lead to a runtime error.\n\nIf is , calling will cause a , which may disrupt the flow of your application. Consider the following code:\n\nIf is , this will throw an exception. To avoid this, you would typically have to add a null check:\n\nInstead of manually checking for null, you can use Spring’s method, which safely handles both null and empty collections in one call. Here’s how it works:\n\nThis method will return if the collection is either or has no elements, eliminating the risk of a .\n\nExample of Using :\n\nConsider the following code where you need to perform an operation only if is not empty:\n\nThis works but requires manual null-checking to avoid .\n\nThis is a cleaner and safer approach because it eliminates the need for a separate check.\n• Null-Safety: The main benefit is avoiding . When using , you don’t need to worry about whether the collection is .\n• Code Cleanliness: Using reduces boilerplate code, making your code easier to read and maintain.\n• Consistency: Spring’s provides a consistent way to check collections, which can be particularly useful in large applications.\n• Null-Safe: Prevents your code from throwing if the collection is .\n• Cleaner Code: Reduces the need for extra checks and simplifies your logic.\n• Consistent and Reliable: Provides a uniform way to handle collection checks across your application.\n\nIn summary, using ensures that your code is safer and less error-prone when dealing with potentially null collections."
    },
    {
        "link": "https://geeksforgeeks.org/user-defined-custom-exception-in-java",
        "document": "In Java, an Exception is an issue (run time error) that occurred during the execution of a program. When an exception occurred the program gets terminated abruptly and, the code past the line that generated the exception never gets executed.\n\nJava provides us the facility to create our own exceptions which are basically derived classes of Exception. Creating our own Exception is known as a custom exception in Java or user-defined exception in Java. Basically, Java custom exceptions are used to customize the exception according to user needs. In simple words, we can say that a User-Defined Custom Exception or custom exception is creating your own exception class and throwing that exception using the ‘throw’ keyword.\n\nExample: In this example, a custom exception MyException is created and thrown in the program.\n\nA custom exception in Java is an exception defined by the user to handle specific application requirements. These exceptions extend either the Exception class (for checked exceptions) or the RuntimeException class (for unchecked exceptions).\n• None To add clear, descriptive error messages for better debugging.\n• None To encapsulate business logic errors in a meaningful way.\n\nThere are two types of custom exceptions in Java.\n• Exception class. and it must be declared in the throws\n• None Create a new class that extends Exception (for checked exceptions) or RuntimeException (for unchecked exceptions).\n• None Provide constructors to initialize the exception with custom messages.\n• None Add methods to provide additional details about the exception. (this is optional)\n\nExplanation: The above example defines a custom checked exception InvalidAgeException that is thrown when an age is below 18. The validate() method checks the age and throws the exception if the age is invalid. In the main() method, the exception is caught and the error message is printed.\n\nExplanation: The above example defines a custom unchecked exception DivideByZeroException that is thrown when we are trying to divide by zero. The divide() method checks if the denominator is zero and throws the exception if true. In the main() method, the exception is caught and the error message is printed."
    },
    {
        "link": "https://medium.com/@satyendra.jaiswal/mastering-error-handling-creating-and-utilizing-custom-exception-classes-in-java-c3834f36d5da",
        "document": "Exception handling is an integral part of writing robust and reliable Java applications. While Java provides a set of built-in exception classes to cover a wide range of scenarios, there are times when creating custom exception classes becomes essential. In this article, we will delve deep into the art of crafting custom exception classes and explore how to use them effectively in your Java projects.\n\nBefore we dive into the how-to, let’s understand why creating custom exception classes is a valuable practice. Java’s built-in exceptions cover general cases, but your application may encounter specific situations that demand a more tailored approach to error reporting. Custom exceptions allow you to encapsulate the details of an error, making your code more readable, maintainable, and expressive.\n\nTo create a custom exception class, you simply extend the class or one of its subclasses. Let's start with a basic example – imagine you are developing a banking application, and you want to handle a scenario where an account balance goes below a minimum threshold."
    },
    {
        "link": "https://geeksforgeeks.org/exception-handling-in-spring-boot",
        "document": "Exception handling in Spring Boot helps to deal with errors and exceptions present in APIs, delivering a robust enterprise application. This article covers various ways in which exceptions can be handled and how to return meaningful error responses to the client in a Spring Boot Project.\n\nHere are some key approaches to exception handling in Spring Boot:\n\nLet’s do the initial setup to explore each approach in more depth.\n\nTo create a simple spring boot project using Spring Initializer, please refer to this article . Now let’s develop a Spring Boot Restful web service that performs CRUD operations on a Customer Entity. We will be using a MYSQL database for storing all necessary data.\n\nThe Customer class is annotated with @Entity annotation and defines getters, setters, and constructors for the fields.\n\nThe CustomerRepository interface is annotated with @Repository annotation and extends the JpaRepository of Spring Data JPA .\n\nCustomerAlreadyExistsException: This exception can be thrown when the user tries to add a customer that already exists in the database.\n\nNoSuchCustomerExistsException: This exception can be thrown when the user tries to delete or update a customer record that doesn’t exist in the database.\n\nThe CustomerService interface defines three different methods:\n• Customer getCustomer(Long id): To get a customer record by its id. This method throws a NoSuchElementException exception when it doesn’t find a customer record with the given id.\n• String addCustomer(Customer customer): To add details of a new Customer to the database. This method throws a CustomerAlreadyExistsException exception when the user tries to add a customer that already exists.\n• String updateCustomer(Customer customer): To update details of Already existing Customers. This method throws a NoSuchCustomerExistsException exception when the user tries to update details of a customer that doesn’t exist in the database.\n\nThe Interface and service implementation class is as follows:\n\nNow let’s go through the various ways in which we can handle the Exceptions thrown in this project.\n\nThe getCustomer() method defined by CustomerController is used to get a customer with a given Id. It throws a NoSuchElementException when it doesn’t find a Customer record with the given id. On Running the Spring Boot Application and hitting the / getCustomer API with an Invalid Customer Id, we get a NoSuchElementException completely handled by Spring Boot as follows:\n\nSpring Boot provides a systematic error response to the user with information such as timestamp, HTTP status code, error, message, and the path.\n• @ExceptionHandler annotation provided by Spring Boot can be used to handle exceptions in particular Handler classes or Handler methods.\n• None Any method annotated with this is automatically recognized by Spring Configuration as an Exception Handler Method.\n• None An Exception Handler method handles all exceptions and their subclasses passed in the argument.\n• None It can also be configured to return a specific error response to the user.\n\nSo let’s create a custom ErrorResponse class so that the exception is conveyed to the user in a clear and concise way as follows:\n\nThe addCustomer() method defined by CustomerController throws a CustomerAlreadyExistsException when the user tries to add a Customer that already exists in the database else it saves the customer details.\n\nTo handle this exception let’s define a handler method handleCustomerAlreadyExistsException() in the CustomerController . So now when addCustomer() throws a CustomerAlreadyExistsException , the handler method gets invoked which returns a proper ErrorResponse to the user.\n\nOn Running the Spring Boot Application and hitting the /addCustomer API with an existing Customer, CustomerAlreadyExistsException gets completely handled by handler method as follows:\n\nIn the previous approach, the annotated method can only handle exceptions thrown by that particular class. However, if we want to handle any exception thrown throughout the application, we can define a global exception handler class and annotate it with . This annotation helps to integrate multiple exception handlers into a single global unit.\n\nThe method defined in throws a if the user tries to update details of a customer that doesn’t already exist in the database. To handle this exception, define a class annotated with .\n\nOn running the Spring Boot application and hitting the API with invalid customer details, gets thrown, which is completely handled by the handler method defined in the class as follows:\n\nSpring Boot provides multiple ways to handle exceptions, ensuring that your application can return meaningful error."
    },
    {
        "link": "http://gaetanopiazzolla.github.io/java/2023/03/05/java-exception-patterns.html",
        "document": "Error handling is one of the most crucial parts of any application. In this article, which results from a lot of research and insights (and some experience in the field), we will see 4 peculiar patterns/best practices for handling errors or exceptions in Java.\n\nHow: All exceptions thrown by methods in a peculiar package should be wrapped into peculiar exceptions.\n\nWhen: This pattern is very useful if the code is to be shipped in the form of Java libraries, or if it includes several packages, all of which don’t have the same business logic. If your code is simple enough or does not provide any kind of libraries, using this pattern is not advisable as it will increase abstraction.\n\nWhy: Re-throwing exceptions will show implementation details to the client, which should be hidden. The client of the code should not be required to modify the catch cause for every update of the service code. Remember that the throw cause is part of the signature of the method, and any changes to the signature will impact the client. Say you have a large user-base for your package, this will result in a huge refactor.\n\nExample: For their DAO support, Spring defines a consistent exception hierarchy hiding and wrapping low-level exceptions as Hibernate-specific exceptions, SQL Exceptions, etc.\n\nPattern Extensions: This pattern works by wrapping any exception in a specific runtime package exception. In this way, any boilerplate “try-catch“ code is removed. This pattern is very useful if no exception to the service package is recoverable (I recommend using checked exceptions only if the client can take some useful recovery action based on information in the exception. Otherwise the right choice is unchecked exceptions). The implementation is very simple and straightforward using lombok @SneakyThrows.\n\nFirst, let’s start by defining two kinds of errors in Java. First, we have to distinguish between FAULTS and CONTINGENCIES.\n• Faults are non-recoverable errors to be handled with unchecked exceptions.\n• Contingencies are recoverable errors to be handled with checked exceptions.\n\nThe fault barrier pattern is a pattern that handles faults.\n\nHow: “In the fault barrier pattern, any application component can throw a fault exception, but only the component acting as the ‘fault barrier’ catches them.” Source. The fault barrier component should record the information contained in the fault exception for future action (logging) and close out the operation in a controlled manner.\n\nWhen: You should follow this pattern in every application that can fail in some way. Practically speaking, you’ll want to use this pattern in every application.\n\nWhy: The fault barrier pattern enables the separation of concerns. It centralizes the logic of unwanted and unchecked errors (faults) in a single place. It also frees the business logic of your application from the burden of error handling and avoids the repetition of code.\n\nExample: In the Spring Framework, it is possible to define a global exception handler component for the other methods, which will handle all faults using the @ControllerAdvice annotation.\n\nWith this simple code, we can handle both the exceptions—“IllegalArgumentException” and “IllegalStateException”—logging the error and providing an opportune HttpStatus to the client. Without this component, every detail about the error will be sent to the client, revealing implementation details that should be hidden. If you are using plain Java and not Spring, it is also possible to define a default uncaught exception handler, which is exposed by the “thread” java object.\n\nPattern Extensions: You don’t have to define global exception handler mechanisms only for faults. It’s possible to define them for checked exceptions too. In fact, along with the example provided in the previous paragraph, it is advised to define a standard HTTP code and a log for every exception handled by our rest controllers.\n\nThis pattern should also be called the “Validator Pattern”. It is a way of implementing the beans validations using exceptions, which is the best way of doing it, in my opinion.\n\nHow: It defines methods that just throw exceptions based on validations.\n\nWhen: It can be used in any application that needs input validation. Basically, every time.\n\nWhy: There are several ways of doing input validation in Java. You should, for example, return a boolean that checks for validations. Exceptions are a good way to go because you can provide an insightful message inside them and distinguish among different kinds of input errors. Additionally, throwing exceptions to the upper layer means freeing the application from the logic of handling exceptions, and avoiding repetitions.\n\nExample:The most basic example in Vanilla Java is simply to define a method, called before the business logic act, that just validates input and throws exceptions.\n\nMore advanced validation is done in the Spring Framework, where you can use the @Valid annotation on your request body POST object instead.\n\nAt this point, the SomeBean should be annotated with JavaX package annotations. If the validation as specified by the annotations is not achieved, a bouncer method will throw a JavaX validation exception.\n\nThis exception can also be refined and enriched with opportune details and well logged and monitored if you apply the fault barrier pattern mentioned earlier in this article.\n\nHow: It gives a specific code number for each checked exception.\n\nWhen: It can be used in any Java project that uses checked exceptions as business errors.\n\nWhy: Giving a number/code for each different exception message is a good practice for documentation and faster communication. In addition, it’s easy to hide information that can otherwise be exposed to clients.\n\nExample: Suppose you have a REST method that saves a book object into the database. To save this book object, some constraints have to be validated, like:\n• the ISDN code should be valid\n• the author of the book must already be saved into the database\n• the book name should be a string of size 1\n\nYou can simply handle these validation errors using exception messages and the same HTTP error code. Additionally, please consider using the HTTP error code accordingly for web applications. In this case, for example, the HTTP error code should be 409 as it is the standard way to report business errors.\n\nOr you can use the more efficient error code pattern. Using this pattern, you can give a specific number to each exception and share with trusted clients what the code means.\n\nIn this way, the exception thrown will HIDE any insightful information about the issue. In a BFF (backend for frontend), this is the best way to handle error codes. The client should know that the error with the code “00001311” has a specific meaning. We can also use the fault barrier together with this pattern, giving numbers to exceptions based on classes:\n\nIn this way, we will still have the application logic regarding exceptions centralized in a single place where they are easy to locate and edit."
    },
    {
        "link": "https://baeldung.com/java-new-custom-exception",
        "document": "In this tutorial, we’ll cover how to create a custom exception in Java.\n\nWe’ll show how user-defined exceptions are implemented and used for both checked and unchecked exceptions.\n\n2. The Need for Custom Exceptions\n\nJava exceptions cover almost all general exceptions that are bound to happen in programming.\n\nHowever, we sometimes need to supplement these standard exceptions with our own.\n\nThese are the main reasons for introducing custom exceptions:\n• Business logic exceptions – exceptions that are specific to the business logic and workflow. These help the application users or the developers understand what the exact problem is.\n• To catch and provide specific treatment to a subset of existing Java exceptions\n\nJava exceptions can be checked and unchecked. In the next sections, we’ll cover both of these cases.\n\nChecked exceptions are exceptions that need to be treated explicitly.\n\nLet’s consider a piece of code that returns the first line of the file:\n\nThe code above is a classic way of handling Java checked exceptions. While the code throws FileNotFoundException, it’s not clear what the exact cause is — whether the file doesn’t exist or the file name is invalid.\n\nTo create a custom exception, we have to extend the java.lang.Exception class.\n\nLet’s see an example of this by creating a custom checked exception called IncorrectFileNameException:\n\nNote that we also have to provide a constructor that takes a String as the error message and called the parent class constructor.\n\nThis is all we need to do to define a custom exception.\n\nNext, let’s see how we can use the custom exception in our example:\n\nWe’ve created and used a custom exception, so the user can now know what the exact exception is.\n\nIs this enough? We are consequently losing the root cause of the exception.\n\nTo fix this, we can also add a java.lang.Throwable parameter to the constructor. This way, we can pass the root exception to the method call:\n\nNow the IncorrectFileNameException is used along with the root cause of the exception:\n\nThis is how we can use custom exceptions without losing the root cause from which they occurred.\n\nIn our same example, let’s assume that we need a custom exception if the file name doesn’t contain any extension.\n\nIn this case, we’ll need a custom unchecked exception similar to the previous one, as this error will only be detected during runtime.\n\nTo create a custom unchecked exception, we need to extend the java.lang.RuntimeException class:\n\nThis way, we can use this custom unchecked exception in our example:\n\nCustom exceptions are very useful when we need to handle specific exceptions related to the business logic. When used properly, they can serve as a practical tool for better exception handling and logging."
    },
    {
        "link": "https://stackoverflow.com/questions/15542504/should-we-use-clone-or-beanutils-copyproperties-and-why",
        "document": "I have checked the source code and I found that it is only copying the \"first level\" of primitive properties. When it comes to a nested object, the nested properties are still referencing the original object's fields, so it is not a \"deep copy\".\n\nCheck this snippets from Spring source code from , version 5.1.3:\n\nJust focus on these lines:\n\nThis line calls the setter on the target object. Imagine this class:\n\nIf we have and , the second is just intanciated and not assigned any fields, has and name .\n\nSo, if we call:\n\nWe are doing:\n\nWhen changes, it changes too.\n\nSo, only works on primitive types and String fields of the object; if it is nested, it does not work; or, you have to make sure the immutability of the original object during the whole lifecycle of the target object, which, is not easy and desirable.\n\nIf you really want to make it a deep copy, you have to implement some way to recursively calls this method on fields which are not primitives. At last you will reach a class with only primitive/immutable fields and then you are done."
    },
    {
        "link": "https://stackoverflow.com/questions/29297468/copy-properties-from-one-bean-to-another-not-the-same-class-recursively-inclu",
        "document": "One way to do it is with Jackson , via the method:\n\nNote that is overloaded to also work with generic types. Also beware that will in some circumstances return the value you provided, such as if SourceBean is assignable to TargetBean.\n\nAs Jackson is a JSON serialization/deserialization library, what does is serialize to JSON in memory, and then deserialize this JSON into an instance of . So high performance is not to be expected. However, conversion is performed with one single line of code.\n\nIf you need performance, the best is to do the mapping manually. Nothing will be better than that.\n\nIf you need simplicity, use Jackson as explained above.\n\nA good trade-off is Orika, a high performance mapper with almost no configuration that doesn't use reflection."
    },
    {
        "link": "https://engati.com/blog/beanutils-copyproperties-and-why-its-not-what-it-looks-like",
        "document": "It's often good if you don't have to talk for 10 mins to make a single point. Similarly, it’s good if you don't need to write 50 lines of code to do a simple task. To bring this layer of abstraction and remove the boilerplate code, many libraries exist such as apache-commons and spring-beans. \n\n\n\nLet's take a closer look at one of the most powerful and very commonly used utility classes that both of these libraries expose in their own version i.e. BeanUtils.\n\nWe've all worked in multi-tiered applications with the responsibility of different tiers being very clearly defined. So to convert a DTO (data transfer object) to an Entity and back, we usually need to write code that looks like something like this:\n\nHere we're trying to convert an object Bot into its data transfer object BotDTO. The object has 6 fields of primitive data type and a nested object of Config. In the next example, I'm using a builder which is better but still looks pretty verbose.\n\nBut with BeanUtils, we can modify it to look something like this:\n\nLooks much neater right? But it’s more than what it looks like in this simple example.\n\nThe above quote from the documentation of apache-commons shows that if your DTO or Entity do not have field signature matching or if your target object has a few nested fields, BeanUtils will not populate those fields for you. So there is no easy way to be sure which fields haven't been copied except by writing elaborate test cases around each field to ensure that the desired fields have been copied.\n\nInternally these utility libraries use reflection to do all the magic of copying field values from source to target. So if the objects in question have a specific way of constructing using a few mandatory fields in the class or if they are mutable only to a certain level then this utility may not be the best fit (although this utility does provide exclusionFields which then you can handle manually).\n\nThe concept of deep copying an object means that all nested objects within an object at all levels of nesting get copied when an attempt is made to copy the parent-level object.\n\nSo in this example when we try to copy fields of Bot to BotDTO, fields in Config object also should get copied to ConfigDTO. But BeanUtils.copyProperties does not perform a deep copy of fields and each level has to be created and separately copied.\n\nWe're not trying to say that there are all problems with these libraries and we shouldn't use them. This is a very powerful utility tool for simple POJOs and many cases to reduce boilerplate code. But we need to be careful as the library isn't a universal solution and at times, you may need something more custom for your purpose. And along with using this library, we need to absolutely make sure that we write good unit test cases to ensure that all expected fields are getting copied correctly.\n\nThanks for reading! We hope you found this article helpful."
    },
    {
        "link": "https://baeldung.com/apache-commons-beanutils",
        "document": "Apache Commons BeansUtils contains all tools necessary for working with Java beans.\n\nSimply put, a bean is a simple Java class containing fields, getters/setters, and a no-argument constructor.\n\nJava provides reflection and introspection capabilities to identify getter-setter methods and call them dynamically. However, these APIs can be difficult to learn and may require developers to write boilerplate code to perform simple operations.\n\nIn this article, we will explore some of the main usages of Apache Commons BeansUtils while dealing with Java Beans.\n\nHere is the Maven dependency required to be included in the POM file before using it:\n\nLet’s create two bean classes Course and Student with typical getter and setter methods.\n\nWe have a Course class that has a course name, course codes, and multiple enrolled students. Enrolled Students are identified by unique enrollment Id. Course class maintains enrolled students in a Map object where enrollment Id is a key, and the student object will be the value.\n\nBean properties can be divided into three categories: simple properties, indexed properties, and mapped properties.\n\nSingle-value properties are also called simple or scalar.\n\nTheir value might be a primitive such as int and float, or complex type objects. BeanUtils has a PropertyUtils class that allows us to modify simple properties in a Java Bean.\n\nHere is the example code to set the properties:\n\nIndexed properties have a collection as a value that can be individually accessed using an index number. As an extension to JavaBean, BeanUtils considers java.util.List type values as indexed as well.\n\nWe can modify an indexed property individual value using a PropertyUtils’s setIndexedProperty method.\n\nHere is example code modifying indexed property:\n\nAny property that has a java.util.Map as the underlying type is called a mapped property. BeanUtils allows us to update the individual value in a map using a String-valued key.\n\nHere is the example code to modify the value in a mapped property:\n\nIf a property value is an object and we need to access a property value inside that object, that would be accessing a nested property. PropertyUtils allow us to access and modify nested properties as well.\n\nAssume we want to access the name property of Student class through Course object. We might write:\n\nWe can access the nested property values using getNestedProperty and modify the nested property using setNestedProperty methods in PropertyUtils. Here is the code:\n\nCopying properties from one object to another object is often tedious and error-prone for developers.\n\nBeanUtils class provides a copyProperties method that copies the properties of source object to target object where the property name is same in both objects.\n\nLet’s create another bean class. It’ll have the same properties as Course except a students property instead of the enrolledStudent Course property. Let’s name that class CourseEntity. The class would look like:\n\nNow, we’ll copy the properties of Course object to CourseEntity object:\n\nRemember this will copy the properties with the same name only. Therefore, it will not copy the property enrolledStudent in Course class because there is no property with the same name in CourseEntity class.\n\nSometimes, it can be handy to copy only non-null fields. To do so, we can define our own BeanUtilsBean and override the definition of copyProperty():\n\nAs we can see, we copy the property only if its initial value isn’t null. Let’s now test this code:\n\nWe instantiated a Course object with a null name. Then, we created a CourseEntity object with the name entityName. After this, we copied all non-null properties from the Course object to their corresponding property in the CourseEntity object. As we expected, we could finally check that the name of our CourseEntity object didn’t change. In a word, the null name in the Course object got ignored!\n\nIn this quick article, we went over the utility classes provided by BeanUtils. We also looked into different types of properties and how can we access and modify their values.\n\nFinally, we looked into accessing nested property values and copying properties from one object to another object.\n\nOf course, reflection and introspection capabilities in the Java SDK also allow us to access properties dynamically but it can be difficult to learn and require some boilerplate code. BeanUtils allows us to access and modify these values with a single method call."
    },
    {
        "link": "https://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.4/apidocs/org/apache/commons/beanutils/BeanUtilsBean.html",
        "document": "\n• Gets the instance which provides the functionality for . This is a pseudo-singleton - an single instance is provided per (thread) context classloader. This mechanism provides isolation for web apps deployed in the same container.\n• Sets the instance which provides the functionality for . This is a pseudo-singleton - an single instance is provided per (thread) context classloader. This mechanism provides isolation for web apps deployed in the same container.\n• Clone a bean based on the available property getters and setters, even if the bean class itself does not implement Cloneable. Note: this method creates a shallow clone. In other words, any objects referred to by the bean are shared with the clone rather than being cloned in turn. - if the caller does not have access to the property accessor method - if a new instance of the bean's class cannot be instantiated - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Copy property values from the origin bean to the destination bean for all cases where the property names are the same. For each property, a conversion is attempted as necessary. All combinations of standard JavaBeans and DynaBeans as origin and destination are supported. Properties that exist in the origin bean, but do not exist in the destination bean (or are read-only in the destination bean) are silently ignored. If the origin \"bean\" is actually a , it is assumed to contain String-valued simple property names as the keys, pointing at the corresponding property values that will be converted (if necessary) and set in the destination bean. Note that this method is intended to perform a \"shallow copy\" of the properties and so complex properties (for example, nested ones) will not be copied. This method differs from , which was primarily designed for populating JavaBeans from the map of request parameters retrieved on an HTTP request, is that no scalar->indexed or indexed->scalar manipulations are performed. If the origin property is indexed, the destination property must be also. If you know that no type conversions are required, the method in will execute faster than this method. FIXME - Indexed and mapped properties that do not have getter and setter methods for the underlying array or Map are not copied by this method. - if the caller does not have access to the property accessor method - if the or argument is null or if the property type is different from the source type and the relevant converter has not been registered. - if the property accessor method throws an exception\n• Copy the specified property value to the specified destination bean, performing any type conversion that is required. If the specified bean does not have a property of the specified name, or the property is read only on the destination bean, return without doing anything. If you have custom destination property types, register s for them by calling the method of .\n• Does not support destination properties that are indexed, but only an indexed setter (as opposed to an array setter) is available.\n• Does not support destination properties that are mapped, but only a keyed setter (as opposed to a Map setter) is available.\n• The desired property type of a mapped setter cannot be determined (since Maps support any data type), so no conversion will be performed. - Bean on which setting is to be performed - Property name (can be nested/indexed/mapped/combo) - Value to be set - if the caller does not have access to the property accessor method - if the property accessor method throws an exception\n• Return the entire set of properties for which the specified bean provides a read method. This map contains the to converted property values for all properties for which a read method is provided (i.e. where the getReadMethod() returns non-null). This map can be fed back to a call to to reconsitute the same set of properties, modulo differences for read-only and write-only properties, but only if there are no indexed properties. Warning: if any of the bean property implementations contain (directly or indirectly) a call to this method then a stack overflow may result. For example: will result in an infinite regression when is called. It is recommended that such methods are given alternative names (for example, ). - Bean whose properties are to be extracted - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified array property of the specified bean, as a String array. - Bean whose property is to be extracted - Name of the property to be extracted - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified indexed property of the specified bean, as a String. The zero-relative index of the required value must be included (in square brackets) as a suffix to the property name, or will be thrown. - Bean whose property is to be extracted - of the property value to be extracted The indexed property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified indexed property of the specified bean, as a String. The index is specified as a method parameter and must *not* be included in the property name expression - Bean whose property is to be extracted - Simple property name of the property value to be extracted - Index of the property value to be extracted The indexed property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified indexed property of the specified bean, as a String. The String-valued key of the required value must be included (in parentheses) as a suffix to the property name, or will be thrown. - Bean whose property is to be extracted - of the property value to be extracted The mapped property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified mapped property of the specified bean, as a String. The key is specified as a method parameter and must *not* be included in the property name expression - Bean whose property is to be extracted - Simple property name of the property value to be extracted - Lookup key of the property value to be extracted The mapped property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the (possibly nested) property of the specified name, for the specified bean, as a String. - Bean whose property is to be extracted - Possibly nested name of the property to be extracted The nested property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified property of the specified bean, no matter which property reference format is used, as a String. - Bean whose property is to be extracted - Possibly indexed and/or nested name of the property to be extracted The property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Return the value of the specified simple property of the specified bean, converted to a String. - Bean whose property is to be extracted - Name of the property to be extracted The property's value, converted to a String - if the caller does not have access to the property accessor method - if the property accessor method throws an exception - if an accessor method for this property cannot be found\n• Populate the JavaBeans properties of the specified bean, based on the specified name/value pairs. This method uses Java reflection APIs to identify corresponding \"property setter\" method names, and deals with setter arguments of type , , , , , and . In addition, array setters for these types (or the corresponding primitive types) can also be identified. The particular setter method to be called for each property is determined using the usual JavaBeans introspection mechanisms. Thus, you may identify custom setter methods using a BeanInfo class that is associated with the class of the bean itself. If no such BeanInfo class is available, the standard method name conversion (\"set\" plus the capitalized name of the property in question) is used. NOTE: It is contrary to the JavaBeans Specification to have more than one setter method (with different argument signatures) for the same property. WARNING - The logic of this method is customized for extracting String-based request parameters from an HTTP request. It is probably not what you want for general property copying with type conversion. For that purpose, check out the method instead. - JavaBean whose properties are being populated - Map keyed by property name, with the corresponding (String or String[]) value(s) to be set - if the caller does not have access to the property accessor method - if the property accessor method throws an exception\n• Set the specified property value, performing type conversions as required to conform to the type of the destination property. If the property is read only then the method returns without throwing an exception. If is passed into a property expecting a primitive value, then this will be converted as if it were a string. WARNING - The logic of this method is customized to meet the needs of , and is probably not what you want for general property copying with type conversion. For that purpose, check out the method instead. WARNING - PLEASE do not modify the behavior of this method without consulting with the Struts developer community. There are some subtleties to its functionality that are not documented in the Javadoc description above, yet are vital to the way that Struts utilizes this method. - Bean on which setting is to be performed - Property name (can be nested/indexed/mapped/combo) - Value to be set - if the caller does not have access to the property accessor method - if the property accessor method throws an exception\n• Gets the instance used to perform the conversions.\n• Gets the instance used to access properties.\n• If we're running on JDK 1.4 or later, initialize the cause for the given throwable. - The cause of the throwable. true if the cause was initialized, otherwise false.\n• Convert the value to an object of the specified class (if possible). - Value to be converted (may be null) - Class of the value to be converted to - if thrown by an underlying Converter"
    }
]