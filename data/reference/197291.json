[
    {
        "link": "https://developer.android.com/tools/adb",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAndroid Debug Bridge ( ) is a versatile command-line tool that lets you communicate with a device. The command facilitates a variety of device actions, such as installing and debugging apps. provides access to a Unix shell that you can use to run a variety of commands on a device. It is a client-server program that includes three components:\n• A client, which sends commands. The client runs on your development machine. You can invoke a client from a command-line terminal by issuing an command.\n• A daemon (adbd), which runs commands on a device. The daemon runs as a background process on each device.\n• A server, which manages communication between the client and the daemon. The server runs as a background process on your development machine.\n\nis included in the Android SDK Platform Tools package. Download this package with the SDK Manager, which installs it at . If you want the standalone Android SDK Platform Tools package, download it here.\n\nFor information on connecting a device for use over , including how to use the Connection Assistant to troubleshoot common problems, see Run apps on a hardware device.\n\nWhen you start an client, the client first checks whether there is an server process already running. If there isn't, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from clients.\n\nNote: All clients use port 5037 to communicate with the server.\n\nThe server then sets up connections to all running devices. It locates emulators by scanning odd-numbered ports in the range 5555 to 5585, which is the range used by the first 16 emulators. Where the server finds an daemon (adbd), it sets up a connection to that port.\n\nEach emulator uses a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for connections. For example:\n\nEmulator 1, console: 5554\n\n Emulator 1, : 5555\n\n Emulator 2, console: 5556\n\n Emulator 2, : 5557\n\n and so on.\n\nAs shown, the emulator connected to on port 5555 is the same as the emulator whose console listens on port 5554.\n\nOnce the server has set up connections to all devices, you can use commands to access those devices. Because the server manages connections to devices and handles commands from multiple clients, you can control any device from any client or from a script.\n\nTo use adb with a device connected over USB, you must enable USB debugging in the device system settings, under Developer options. On Android 4.2 (API level 17) and higher, the Developer options screen is hidden by default. To make it visible, enable Developer options.\n\nYou can now connect your device with USB. You can verify that your device is connected by executing from the directory. If connected, you'll see the device name listed as a \"device.\"\n\nNote: When you connect a device running Android 4.2.2 (API level 17) or higher, the system shows a dialog asking whether to accept an RSA key that allows debugging through this computer. This security mechanism protects user devices because it ensures that USB debugging and other adb commands cannot be executed unless you're able to unlock the device and acknowledge the dialog.\n\nFor more information about connecting to a device over USB, read Run apps on a hardware device.\n\nNote: The instructions below do not apply to Wear devices running Android 11 (API level 30). See the guide to debugging a Wear OS app for more information.\n\nAndroid 11 (API level 30) and higher support deploying and debugging your app wirelessly from your workstation using Android Debug Bridge (adb). For example, you can deploy your debuggable app to multiple remote devices without ever needing to physically connect your device via USB. This eliminates the need to deal with common USB connection issues, such as driver installation.\n\nBefore you begin using wireless debugging, do the following:\n• Ensure that your workstation and device are connected to the same wireless network.\n• Ensure that your device is running Android 11 (API level 30) or higher for phone or Android 13 (API level 33) or higher for TV and WearOS. For more information, see Check & update your Android version.\n• If using the IDE, ensure that you have the latest version of Android Studio installed. You can download it here.\n• On your workstation, update to the latest version of the SDK Platform Tools.\n\nTo use wireless debugging, you must pair your device to your workstation using a QR code or a pairing code. Your workstation and device must be connected to the same wireless network. To connect to your device, follow these steps:\n• Open Android Studio and select Pair Devices Using Wi-Fi from the run configurations menu. The Pair devices over Wi-Fi window pops up, as shown in figure 2.\n• On your device, tap Wireless debugging and pair your device:\n• To pair your device with a QR code, select Pair device with QR code and scan the QR code obtained from the Pair devices over Wi-Fi popup shown in figure 2.\n• To pair your device with a pairing code, select Pair device with pairing code from the Pair devices over Wi-Fi popup. On your device, select Pair using pairing code and take note of the six-digit code provided. Once your device appears on the Pair devices over Wi-Fi window, you can select Pair and enter the six-digit code shown on your device.\n• After your device is paired, you can attempt to deploy your app to your device. To pair a different device or to forget the current device on your workstation, navigate to Wireless debugging on your device. Tap your workstation name under Paired devices and select Forget.\n• If you want to quickly turn on and off wireless debugging, you can utilize the Quick settings developer tiles for Wireless debugging, found in Developer Options > Quick settings developer tiles.\n\nAlternatively, to connect to your device using command line without Android Studio, follow these steps:\n• Enable developer options on your device, as described earlier.\n• Enable Wireless debugging on your device, as described earlier.\n• On your workstation, open a terminal window and navigate to .\n• Find your IP address, port number, and pairing code by selecting Pair device with pairing code. Take note of the IP address, port number, and pairing code displayed on the device.\n• On your workstation's terminal, run . Use the IP address and port number from above.\n• When prompted, enter the pairing code, as shown below.\n\nIf you are having issues connecting to your device wirelessly, try the following troubleshooting steps to resolve the issue.\n\nCheck whether your workstation and device meet the prerequisites\n\nCheck that the workstation and device meet the prerequisites listed at the beginning of this section.\n\nCheck for other known issues\n\nThe following is a list of current known issues with wireless debugging (with adb or Android Studio) and how to resolve them:\n• Wi-Fi is not connecting: Secure Wi-Fi networks, such as corporate Wi-Fi networks, may block p2p connections and not let you connect over Wi-Fi. Try connecting with a cable or another (non-corp) Wi-Fi network. Wireless connection using over tcp/ip (following an initial USB connection) is another option, in case resorting to a non-corp network is an option.\n• over Wi-Fi sometimes turns off automatically: This can happen if the device either switches Wi-Fi networks or disconnects from the network. To resolve, re-connect to the network.\n• Device not connecting after pairing successfully: relies on mDNS to discover and automatically connect to paired devices. If your network or device configuration does not support mDNS or has disabled it, then you need to manually connect to the device using .\n\nConnect wirelessly with a device after an initial USB connection (only option available on Android 10 and lower)\n\nNote: This workflow is applicable also to Android 11 (and higher), the caveat being that it also involves an *initial* connection over physical USB.\n\nNote: The following instructions do not apply to Wear devices running Android 10 (API level 29) or lower. See the guide about debugging a Wear OS app for more information.\n\nusually communicates with the device over USB, but you can also use over Wi-Fi. To connect a device running Android 10 (API level 29) or lower, follow these initial steps over USB:\n• Connect your Android device and host computer to a common Wi-Fi network. Note: Beware that not all access points are suitable. You might need to use an access point whose firewall is configured properly to support .\n• Connect the device to the host computer with a USB cable.\n• Set the target device to listen for a TCP/IP connection on port 5555:\n• Disconnect the USB cable from the target device.\n• Find the IP address of the Android device. For example, on a Nexus device, you can find the IP address at Settings > About tablet (or About phone) > Status > IP address.\n• Connect to the device by its IP address:\n• Confirm that your host computer is connected to the target device:\n\nYour device is now connected to .\n\nIf the connection to your device is lost:\n• Make sure that your host is still connected to the same Wi-Fi network as your Android device.\n• Reconnect by executing the step again.\n• If that doesn't work, reset your host: Then start over from the beginning.\n\nBefore issuing commands, it is helpful to know what device instances are connected to the server. Generate a list of attached devices using the command:\n\nIn response, prints this status information for each device:\n• Serial number: creates a string to uniquely identify the device by its port number. Here's an example serial number:\n• State: The connection state of the device can be one of the following:\n• : The device is not connected to or is not responding.\n• : The device is connected to the server. Note that this state does not imply that the Android system is fully booted and operational, because the device connects to while the system is still booting. After boot-up, this is the normal operational state of a device.\n• : There is no device connected.\n• Description: If you include the option, the command tells you what the device is. This information is helpful when you have multiple devices connected so that you can tell them apart.\n\nThe following example shows the command and its output. There are three devices running. The first two lines in the list are emulators, and the third line is a hardware device that is attached to the computer.\n\nThe command has a corner-case command sequence that causes running emulators to not show up in the output even though the emulators are visible on your desktop. This happens when all of the following conditions are true:\n• The server is not running.\n• You use the command with the or option with an odd-numbered port value between 5554 and 5584.\n• The odd-numbered port you chose is not busy, so the port connection can be made at the specified port number — or, if it is busy, the emulator switches to another port that meets the requirements in 2.\n• You start the server after you start the emulator.\n\nOne way to avoid this situation is to let the emulator choose its own ports and to run no more than 16 emulators at once. Another way is to always start the server before you use the command, as explained in the following examples.\n\nExample 1: In the following command sequence, the command starts the server, but the list of devices does not appear.\n\nStop the server and enter the following commands in the order shown. For the AVD name, provide a valid AVD name from your system. To get a list of AVD names, type . The command is in the directory.\n\nExample 2: In the following command sequence, displays the list of devices because the server was started first.\n\nTo see the emulator in the output, stop the server, and then start it again after using the command and before using the command, as follows:\n\nFor more information about emulator command-line options, see Command-Line startup options.\n\nIf multiple devices are running, you must specify the target device when you issue the command. To specify the target, follow these steps:\n• Use the command to get the serial number of the target.\n• Once you have the serial number, use the option with the commands to specify the serial number.\n• If you're going to issue a lot of commands, you can set the environment variable to contain the serial number instead.\n• If you use both and , overrides .\n\nIn the following example, the list of attached devices is obtained, and then the serial number of one of the devices is used to install the on that device:\n\nNote: If you issue a command without specifying a target device when multiple devices are available, displays an error \"adb: more than one device/emulator\".\n\nIf you have multiple devices available but only one is an emulator, use the option to send commands to the emulator. If there are multiple devices but only one hardware device attached, use the option to send commands to the hardware device.\n\nYou can use to install an APK on an emulator or connected device with the command:\n\nYou must use the option with the command when you install a test APK. For more information, see .\n\nTo install multiple APKs use . This is useful if you download all the APKs for a specific device for your app from the Play Console and want to install them on an emulator or physical device.\n\nFor more information about how to create an APK file that you can install on an emulator/device instance, see Build and run your app.\n\nNote: If you are using Android Studio, you do not need to use directly to install your app on the emulator or device. Instead, Android Studio handles the packaging and installation of the app for you.\n\nUse the command to set up arbitrary port forwarding, which forwards requests on a specific host port to a different port on a device. The following example sets up forwarding of host port 6100 to device port 7100:\n\nThe following example sets up forwarding of host port 6100 to local:logd:\n\nThis could be useful if you are trying to detemine what is being sent to a given port on the device. All received data will be written to the system-logging daemon and displayed in the device logs.\n\nCopy files to and from a device\n\nUse the and commands to copy files to and from a device. Unlike the command, which only copies an APK file to a specific location, the and commands let you copy arbitrary directories and files to any location in a device.\n\nTo copy a file or directory and its sub-directories from the device, do the following:\n\nTo copy a file or directory and its sub-directories to the device, do the following:\n\nReplace and with the paths to the target files/directory on your development machine (local) and on the device (remote). For example:\n\nIn some cases, you might need to terminate the server process and then restart it to resolve the problem. For example, this could be the case if does not respond to a command.\n\nTo stop the server, use the command. You can then restart the server by issuing any other command.\n\nIssue commands from a command line on your development machine or from a script using the following:\n\nIf there's only one emulator running or only one device connected, the command is sent to that device by default. If multiple emulators are running and/or multiple devices are attached, you need to use the , , or option to specify the target device to which the command should be directed.\n\nYou can see a detailed list of all supported commands using the following command:\n\nYou can use the command to issue device commands through or to start an interactive shell. To issue a single command, use the command like this:\n\nTo start an interactive shell on a device, use the command like this:\n\nTo exit an interactive shell, press or type .\n\nAndroid provides most of the usual Unix command-line tools. For a list of available tools, use the following command:\n\nHelp is available for most of the commands via the argument. Many of the shell commands are provided by toybox. General help applicable to all toybox commands is available via .\n\nWith Android Platform Tools 23 and higher, handles arguments the same way that the command does. This change has fixed a lot of problems with command injection and makes it possible to safely execute commands that contain shell metacharacters, such as . This change means that the interpretation of any command that contains shell metacharacters has also changed.\n\nFor example, is now an error, because the quotes are swallowed by the local shell, and the device sees . To make the command work, quote twice, once for the local shell and once for the remote shell, as you do with . For example, works because the local shell takes the outer level of quoting and the device still sees the inner level of quoting: . Escaping is also an option, but quoting twice is usually easier.\n\nSee also Logcat command-line tool, which is useful for monitoring the system log.\n\nWithin an shell, you can issue commands with the activity manager ( ) tool to perform various system actions, such as start an activity, force-stop a process, broadcast an intent, modify the device screen properties, and more.\n\nWhile in a shell, the syntax is:\n\nYou can also issue an activity manager command directly from without entering a remote shell. For example:\n\nFor activity manager commands that take an argument, you can specify the intent with the following options:\n\nWithin an shell, you can issue commands with the package manager ( ) tool to perform actions and queries on app packages installed on the device.\n\nWhile in a shell, the syntax is:\n\nYou can also issue a package manager command directly from without entering a remote shell. For example:\n\nPrint all packages, optionally only those whose package name contains the text in .\n• : See the installer for the packages. Print all known permissions, optionally only those in .\n• : List only the permissions users will see. List all test packages.\n• : List the APK file for the test package.\n• : List test packages for only this app. Print all features of the system. Print all the libraries supported by the current device. Print all users on the system. Print the path to the APK of the given . Install a package, specified by , to the system.\n• : Allow test APKs to be installed. Gradle generates a test APK when you have only run or debugged your app or have used the Android Studio Build > Build APK command. If the APK is built using a developer preview SDK, you must include the option with the command if you are installing a test APK.\n• : Specify the installer package name.\n• : Set the install location using one of the following values:\n• : Grant all permissions listed in the app manifest.\n• : Quickly update an installed package by only updating the parts of the APK that changed.\n• : Installs enough of the APK to launch the app while streaming the remaining data in the background. To use this feature, you must sign the APK, create an APK Signature Scheme v4 file, and place this file in the same directory as the APK. This feature is only supported on certain devices. This option forces to use the feature or fail if it is not supported, with verbose information on why it failed. Append the option to wait until the APK is fully installed before granting access to the APK. prevents from using this feature. Removes a package from the system.\n• : Keep the data and cache directories after package removal.\n• : Specifies the user for whom the package is removed.\n• : Only uninstalls if the app has the given version code. Delete all data associated with a package. Enable the given package or component (written as \"package/class\"). Disable the given package or component (written as \"package/class\"). Grant a permission to an app. On devices running Android 6.0 (API level 23) and higher, the permission can be any permission declared in the app manifest. On devices running Android 5.1 (API level 22) and lower, must be an optional permission defined by the app. Revoke a permission from an app. On devices running Android 6.0 (API level 23) and higher, the permission can be any permission declared in the app manifest. On devices running Android 5.1 (API level 22) and lower, must be an optional permission defined by the app. Change the default install location. Location values:\n• : Auto: Let system decide the best location. Note: This is only intended for debugging. Using this can cause apps to break and other undesireable behavior. Returns the current install location. Return values:\n• : Let system decide the best location Specify whether the given permission should be enforced. Trim cache files to reach the given free space. Create a new user with the given , printing the new user identifier of the user. Remove the user with the given , deleting all data associated with that user Print the maximum number of users supported by the device. Print the domain verification state for the given , or for all packages if none is specified. State codes are defined as follows:\n• : nothing has been recorded for this domain\n• : the domain has been successfully verified\n• : custom error code, which is specific to the device verifier\n• : include user selections. Include all domains, not just autoVerify ones. Reset domain verification state for the given package, or for all packages if none is specified.\n• : the package to reset, or \"all\" to reset all packages\n• : include user selections. Include all domains, not just autoVerify ones. Broadcast a verification request for the given , or for all packages if none is specified. Only sends if the package has previously not recorded a response.\n• : send even if the package has recorded a response Manually set the state of a domain for a package. The domain must be declared by the package as autoVerify for this to work. This command will not report a failure for domains that could not be applied.\n• : the package to set, or \"all\" to set all packages\n• : the code to set the domains to. Valid values are:\n• : reset as if no response was ever recorded.\n• : treat domain as successfully verified by domain verification agent. Note that the domain verification agent can override this.\n• : treat domain as always approved, preventing the domain verification agent from changing it.\n• : treat domain as always denied, preventing the domain verification agent from changing it.\n• : space-separated list of domains to change, or \"all\" to change every domain. Manually set the state of a host user selection for a package. The domain must be declared by the package for this to work. This command will not report a failure for domains that could not be applied.\n• : the user to change selections for\n• : whether to approve the domain\n• : space-separated list of domains to change, or \"all\" to change every domain\n• : the user to change selections for\n• : the package to set, or \"all\" to set all packages; packages will be reset if no package is specified\n• : true to allow the package to open auto-verified links, false to disable Print the owners for a specific domain for a given user in low- to high-priority order.\n• : the user to query for\n• : optionally also print for all web domains declared by a package, or \"all\" to print all packages\n• : space-separated list of domains to query for\n\nTo help you develop and test your device management apps, issue commands to the device policy manager ( ) tool. Use the tool to control the active admin app or change a policy's status data on the device.\n\nWhile in a shell, the syntax is:\n\nYou can also issue a device policy manager command directly from without entering a remote shell:\n\nThe command is a shell utility for taking a screenshot of a device display.\n\nWhile in a shell, the syntax is:\n\nTo use from the command line, enter the following:\n\nHere's an example screenshot session, using the shell to capture the screenshot and the command to download the file from the device:\n\nThe command is a shell utility for recording the display of devices running Android 4.4 (API level 19) and higher. The utility records screen activity to an MPEG-4 file. You can use this file to create promotional or training videos or for debugging and testing.\n\nIn a shell, use the following syntax:\n\nTo use from the command line, enter the following:\n\nStop the screen recording by pressing Control+C. Otherwise, the recording stops automatically at three minutes or the time limit set by .\n\nTo begin recording your device screen, run the command to record the video. Then, run the command to download the video from the device to the host computer. Here's an example recording session:\n\nThe utility can record at any supported resolution and bit rate you request, while retaining the aspect ratio of the device display. The utility records at the native display resolution and orientation by default, with a maximum length of three minutes.\n• Audio is not recorded with the video file.\n• Video recording is not available for devices running Wear OS.\n• Some devices might not be able to record at their native display resolution. If you encounter problems with screen recording, try using a lower screen resolution.\n• Rotation of the screen during recording is not supported. If the screen does rotate during recording, some of the screen is cut off in the recording.\n\nStarting in Android 7.0 (API level 24), the Android Runtime (ART) collects execution profiles for installed apps, which are used to optimize app performance. Examine the collected profiles to understand which methods are executed frequently and which classes are used during app startup.\n\nNote: It is only possible to retrieve the execution profile filename if you have root access to the file system, for example, on an emulator.\n\nTo produce a text form of the profile information, use the following command:\n\nTo retrieve the file produced, use:\n\nIf you test your app across multiple test devices, it may be useful to reset your device between tests, for example, to remove user data and reset the test environment. You can perform a factory reset of a test device running Android 10 (API level 29) or higher using the shell command, as shown:\n\nWhen restoring the device using , the device automatically backs up the RSA key that allows debugging through the current workstation in a persistent location. That is, after the device is reset, the workstation can continue to debug and issue commands to the device without manually registering a new key.\n\nAdditionally, to help make it easier and more secure to keep testing your app, using the to restore a device also changes the following device settings:\n• The device sets up certain system settings so that initial device setup wizards do not appear. That is, the device enters a state from which you can quickly install, debug, and test your app.\n\nIf your app needs to detect and adapt to the default settings of the command, use the .\n\nstarts the command-line program for examining SQLite databases. It includes commands such as to print the contents of a table and to print the statement for an existing table. You can also execute SQLite commands from the command line, as shown:\n\nNote: It is only possible to access a SQLite database if you have root access to the file system, for example, on an emulator.\n\nFor more information, see the command line documentation.\n\nThe adb server can interact with the USB stack through two backends. It can either use the native backend of the OS (Windows, Linux, or macOS) or it can use the backend. Some features, such as , , and USB speed detection, are only available when using backend.\n\nYou can choose a backend by using the environment variable. If it isn't set, adb uses its default backend. The default behavior varies among OS. Starting with ADB v34, the backend is used by default on all OS except Windows, where the native backend is used by default. If is set, it determines whether the native backend or is used. See the adb manual page for more information about adb environment variables.\n\nADB can use the multicast DNS protocol to automatically connect the server and devices. The ADB server ships with two backends, Bonjour (Apple's mdnsResponder) and Openscreen.\n\nThe Bonjour backend needs a daemon to be running on the host machine. On macOS Apple's built-in daemon is always running, but on Windows and Linux, the user must make sure the daemon is up and running. If the command returns an error, it is likely that ADB is using the Bonjour backend but there is no Bonjour daemon running.\n\nThe Openscreen backend does not need a daemon to be running on the machine. Support for the Openscreen backend on macOS starts at ADB v35. Windows and Linux are supported as of ADB v34.\n\nBy default ADB uses the Bonjour backend. This behavior can be changed using the environment variable (set to or ). See the ADB manual page for further details.\n\nBurst Mode is an experimental feature that lets ADB to keep on sending packets to a device even before the device has responded to the previous packet. This greatly increases the throughput of ADB when transferring large files and also reduces latency while debugging.\n\nBurst Mode is disabled by default. To enable the feature, do one of the following:\n• In Android Studio, go to the debugger settings at File (or Android Studio on macOS) > Settings > Build, Execution, Deployment > Debugger and set ADB Server Burst Mode to Enabled."
    },
    {
        "link": "https://hexnode.com/blogs/android-debug-bridge",
        "document": "Android debug bridge (ADB) is a tool that allows a user to communicate with their Android device. Debugging is the process that helps us detect and fix errors and bugs in software that is under development, hence debugging is an important procedure in the software development lifecycle.\n\nADB helps in installing and debugging programs. Through ADB you can transfer files back and forth, and use the Unix shell to conduct commands. ADB may be used to change hidden settings and set up programs that work with ADB to enable useful capabilities and improve the overall device experience.\n\nThere are 3 basic components in ADB\n• A client sends commands to the connected Android device. You can invoke a client from a shell by issuing an adb command client that sends commands to the connected Android device.\n• A daemon (adbd) that runs as a background process on a device and handles the execution of received commands.\n• A server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device.\n\nWhen you start an adb client, it checks to see whether there is already an adb server process running. If there isn’t one, the server process is started. When the server boots up, it binds to local TCP port 5037 and listens for instructions from adb clients—all adb clients connect with the adb server over port 5037.\n\nThe server then establishes connections to all emulator/device instances that are currently active. It looks for emulator/device instances by scanning odd-numbered ports in the 5555 to 5585 range, which is the range that emulators/devices employ. The server establishes a connection to the port where it discovers an adb daemon.\n• Scroll all the way down and tap the Build Number seven times. (You will get a message saying, “You’re now a developer.”)\n\nSetting up Android Debug Bridge on your devices\n\nAndroid Studio is the official Integrated Development Environment (IDE) for Android app development and ADB package is already included in Android Studio under “Android SDK Platform Tools”.\n• Navigate to the location where you downloaded the ZIP file in File Explorer.\n• Right-click the zip file and extract the contents to C:\\platform-tools. Connect your device to your PC and set the USB mode to “File Transfer.”\n• Right-click the platform-tools folder that contains the ADB package while holding down the Shift key.\n• On your phone, enable USB debugging and choose Always allow from this computer.\n• Re-enter the “./adb device” command, and you should see the device’s serial number.\n• Open Finder and extract the zip file to, wherever you want.\n• Change the USB mode on your device and plug it into your Mac.\n• Open Terminal and type the platform-tools folder’s location I.e cd /Users/[UserName]/Downloads/platform-tools. Then, type in adb devices.\n• Accept the “Allow USB Debugging” prompt and tap OK to always allow the connection.\n• Re-enter the “adb device” command to see your device serial number.\n\nADB can also be configured over Wi-Fi without the need to connect it to the USB everytime you need to use ADB functionality on your Android.\n• Connect your device and your computer to the same Wi-Fi network.\n• Connect the device to your computer via a USB cable.\n• Find the IP address of your device by using ifconfig command on the device\n• Make the target device’s adb daemon listen for TCP/IP connections on port 5555\n• Disconnect the USB cable from the device.\n• Connect to the device using its IP address.\n\nADB provides a wide range of functions for the interaction between the host and the device. These functions are usually executed by typing commands in a command-line interface on the host.\n\nHelp: This is helpful in finding out the commands that can be used in each device instance as this prints out the list of supported adb commands.\n\ninstall: pushes an Android application to the connected device.\n\nstart-server: Checks whether the adb server process is running and starts it, if not.\n\npull: Copies a specified file from an emulator/device instance to your development computer.\n\npush: Copies a specified file from your development computer to an emulator/device instance.\n\nWhile these are just some of the useful adb commands you can find a plethora of commands that are compatible with your device.\n\nTo debug issues related to updating as well as installing apps from Managed Play, you can retrieve the Managed Play logs from a device for analysis. Android versions 4.2 and higher are capable of capturing and saving bug reports. Bug reports contain event logs that you can use to help troubleshoot issues related to app installations and updates.\n\n Use Android Debug Bridge to get bug reports. Use logcat to view a log of system messages from all apps on the device, including Play.\n\nAn Android device that is enrolled into a UEM simplifies some of the tasks that are done using ADB. Tasks like app installation can be remotely done in an instant from the UEM portal. Using a UEM you can get updates about the device at the click of a button. Feedback can be retrieved from Managed Google Play apps from the portal itself. The best part about this is, that once enrolled the device need not be in proximity of the computer and can be remotely managed from anywhere with an active internet connection.\n\nADB can be hard to configure and understand at first but once you get hang of the commands, it gets progressively easier to use. The ADB commands help you get better control over your Android device.\n\n Get started with Hexnode’s Android Management solution to improve efficiency, increase productivity, save time and overhead costs of managing your corporate devices. Download datasheet"
    },
    {
        "link": "https://medium.com/@EazSoftware/a-comprehensive-guide-to-adb-android-debug-bridge-the-unsung-hero-for-android-developers-28b349037436",
        "document": "If you’re an Android developer, tester, or even a curious tech enthusiast, there’s a good chance you’ve come across the term ADB (Android Debug Bridge) at some point. But what exactly is ADB? Is it just another buzzword, or does it hold real value in the world of Android development?\n\nIn this comprehensive guide, we’re not just going to explain ADB — we’re going to demystify it. You’ll discover what ADB is, why it’s an absolute must-have tool for any Android developer, and how you can leverage it to supercharge your workflow. Whether you’re debugging your app, managing devices, or digging deep into the Android operating system, ADB opens up a world of possibilities that can streamline your development process and boost your productivity.\n\nSo, whether you’re a seasoned Android pro looking to master ADB or a beginner curious about how to use it, keep reading. By the end of this guide, you’ll know why ADB isn’t just valuable — it’s indispensable. Let’s dive in and explore how you can harness the full potential of Android Debug Bridge!\n\nADB, short for “Android Debug Bridge”, is a command-line tool that lets you communicate with an Android device (phone, tablet, emulator) from your computer. It acts as a bridge between your development machine and the Android device, allowing you to perform a variety of actions like installing and debugging apps, transferring files, viewing device logs, and even issuing commands that modify system behaviors.\n\nADB works by establishing a connection between a host (your development machine) and a target (your Android device or emulator). The communication between these two is made possible through a TCP/IP connection, USB, or even wireless modes (for Wi-Fi debugging).\n\nTo understand how ADB operates, it’s essential to break it down into three parts:\n\n- Client: This is you! The command-line tool where you run your ADB commands.\n\n- Daemon (adbd): This runs on the device and processes commands sent by the client.\n\n- Server: Manages the communication between the client and the daemon. It ensures that the client and daemon are talking to each other over a proper connection.\n\nSetting Up ADB on Your Machine\n\nLet’s start with the basics — setting up ADB on your computer. Follow the steps below to ensure you can communicate with your Android device using ADB.\n\nFirst, you need to download the “Android SDK Platform Tools”. These tools are part of the Android development environment and include the ADB binary that will allow your computer to communicate with your device.\n\nWindows: Download from the official Android Developer site, extract the folder, and note the path.\n\nmacOS: The process is the same. Download the Platform Tools, extract, and keep the path handy.\n\nLinux: Similarly, download, extract, and note the path where you extracted the tools.\n\nYou’ll want to add ADB to your system’s PATH so you can use it from any directory in your terminal.\n• Windows:\n\n — Right-click on “This PC” and select “Properties.”\n\n — Click on “Advanced system settings.”\n\n — Under the “System Properties” window, click on “Environment Variables.”\n\n — Find “Path” under “System variables,” click “Edit,” and then add the path to your “platform-tools” folder.\n• macOS & Linux:\n\n — Open a terminal and edit your “~/.bash_profile” (or “~/.zshrc” if you’re using Zsh) file.\n\n — Add the line: “export PATH=$PATH:/path/to/platform-tools”\n\n — Save and run “source ~/.bash_profile” to apply the changes.\n\nBefore you can use ADB with a physical device, you need to enable “USB Debugging”:\n\n1. Open “Settings” on your Android device.\n\n2. Scroll down and select “About Phone”.\n\n3. Find “Build Number” and tap it 7 times to unlock Developer Options.\n\n4. Go back to the main “Settings” page, and now you’ll see “Developer Options”.\n\n5. Scroll down to “USB Debugging” and toggle it on.\n\nOnce USB Debugging is enabled, connect your device to your computer via USB. Your computer should now detect the device through ADB.\n\nNow that you’ve set up ADB and connected your device, let’s dive into some basic commands that can help you navigate your device through the terminal.\n\nThis command lists all connected devices. It’s usually the first command you’ll run to check if your device is properly connected.\n\nIf you see your device’s serial number listed, ADB is working. If you see the device status as “unauthorized,” check your phone — there might be a prompt to authorize the computer.\n\nYou can install APK files directly to your device using ADB. Just pass the path of the APK file as an argument.\n\nThis command allows you to uninstall apps directly from the device.\n\nLogcat is one of the most used tools in Android development. It shows a real-time log of all system messages, including errors and app crashes.\n\nYou can filter the log by a specific tag or app to get more relevant logs:\n\n- adb logcat: This command starts streaming system logs from the connected Android device. Logcat outputs all kinds of information, including system messages, errors, warnings, and debug messages from all running apps.\n\n- | grep “MyAppTag”: The | is called a “pipe” in Unix-like systems, and it allows you to take the output of one command (in this case, “adb logcat”) and pass it as input to another command (here, “grep”). This is where “grep” comes in.\n\ngrep stands for “global regular expression print”. It’s a powerful command-line tool used to search and filter text by matching specific patterns. In this case, it filters the log output to show only the lines that contain the string ”MyAppTag”.\n\nSo, instead of sifting through all the logs coming from your device (which can be overwhelming), grep allows you to focus on the logs relevant to your app by filtering out unnecessary noise.\n\nWhen you run grep, it searches for lines in the log that match the string (or pattern) you specify. It works like a filter that displays only the results you’re interested in.\n\nFor example, if your app uses a tag called ”MyAppTag” in Log.d(“MyAppTag”, “Debugging message”), then running the above command will show you only the log messages related to that tag.\n\nOther Useful Commands Similar to grep\n\nBesides grep, here are some other powerful commands that can enhance your ADB log filtering:\n\n- sed: This stands for “stream editor” and is used for transforming or modifying the output text. You can use sed to replace or delete parts of the log output.\n\nThis command will replace the word “Error” with “WARNING” in the log output. the string infront of sed is just a simple Regex pattern.\n\n- awk: A highly flexible text-processing tool that can be used to extract specific fields or columns from the log. If your logcat output is too verbose, “awk” helps narrow it down.\n\nThis will show only the second and fifth columns of the log output, which might represent the timestamp and log message, for instance!\n\n- sort: This command sorts the output in alphabetical or numerical order. If you have a large log with many duplicate entries, sorting can help organize it.\n\n- uniq: Paired with “sort”, uniq removes duplicate lines from your log. If you’re seeing repetitive logs, this can help you clean up the output.\n\n- tail: Sometimes, the logs are too long, and you only want to see the most recent lines. tail shows the last few lines of the log output, which is especially useful for following live logs.\n\nThis shows the last 20 lines of the logcat output.\n\n- head: Similar to “tail”, but it shows the first few lines of the log output.\n\nThis shows the first 20 lines of the logcat output.\n\nYou can combine these commands to create complex filters and extract exactly the information you need. For example, if you want to see logs for a specific app tag, remove duplicates, and only see the most recent logs, you could use:\n\nThis command filters for logs related to ”MyAppTag”, sorts them, removes duplicates, and shows only the last 50 lines. It’s a great way to streamline your debugging workflow and focus on the logs that matter most.\n\nBy using grep and its related commands, you can filter and manipulate ADB log output to zero in on exactly what you need, saving time and making debugging far more efficient.\n\nThe adb shell command opens a remote shell on your device. You can use this to explore the file system or run commands directly on the device.\n\nOnce inside the shell, you can run various Linux-based commands like “ls”, “cd”, “top”, and “ps”.\n\nHere are some more advanced commands that are often used by developers and testers:\n\nThese commands let you transfer files between your development machine and your Android device. For example:\n\n- Pull a file from the device to your computer:\n\nYou can reboot your device or even boot into recovery mode using ADB:\n\nThis command allows you to connect to your device over Wi-Fi instead of a USB cable. Here’s how:\n\n- First, connect your device to your computer via USB.\n\n- Run the command:\n• Now, find your device’s IP address by running “adb shell ip route”.\n• Once you have the IP, disconnect the USB cable and run:"
    },
    {
        "link": "https://developers.meta.com/horizon/documentation/native/android/ts-adb",
        "document": ""
    },
    {
        "link": "https://makimo.com/blog/a-comprehensive-guide-to-android-debug-bridge-adb",
        "document": "In our daily work as Android developers, we are constantly performing repetitive tasks within app management, such as installing a new version of the application or uninstalling the old one, clearing the cache, copying data from the Android device to the development machine, and vice versa. Most of these tasks can be automated, which saves our time and reduces our frustration when it comes to manually handling the same actions over and over again. But first let’s answer the question: how does our machine communicate with our Android device?\n\nAdb stands for “Android debug bridge,” a command line tool that allows us to communicate with Android devices from our PCs. It brings many options, but here we will focus on the most interesting ones from a developer’s perspective.\n• Client: sends a command to run on an Android device. The client is run on your development machine and it can be invoked with the adb command.\n• Daemon: a background process which runs commands sent by the client on an Android device.\n• Server: a background process that runs on the development machine; it manages communication between the client and the daemon.\n\nFirstly, we need to set up adb before any further work. There are three options to use adb on your machine:\n• If you have installed Android Studio on your machine, adb is built in already\n• Download the standalone latest version of Android SDK platforms tools, which already includes adb (link)\n• Using your package manager tool, which depends on your system, e.g. on macOS\n\nAfter installing, check the correctness by simply typing the command:\n\nIn case your command is not recognized, I recommend adding an adb path to the environment variables to run adb commands from every place in your terminal.\n\nAfter successful installation, the next step is to connect with your phone. Depending on your needs, you can connect your physical phone via USB or wifi or use AVD (Android Virtual Device) — here’s a documentation section on managing avds.\n\nWhen it comes to physical devices, there is one additional step before your further actions enable developer options on your device.\n\nNow you’re ready to go; to check the connection with your device, type the command:\n\nYou should see your device on the list of attached devices.\n\nOn the first adb command run, there is additional information:\n\nwhich informs us that the daemon process has successfully started on the connected device.\n\nFrom now on, all client commands from your PC are listening on tcp port 5037, a constant default port for all adb clients.\n\nIn case of any problems with the connection, try to restart the whole server:\n\nIt’s also a good option when Android Studio plays tricks on us and doesn’t show your device on the available devices list or when the device loses connection and starts to blink.\n\nTo see all available options of adb, type:\n\nFor the sake of clarity, all examples will assume a connection with one device while the developer is working on a UNIX based system. In case of multiple devices connected to your PC, you need to pass a unique identifier to specify on which device you want to proceed. For an Android device, the unique identifier is the serial number. To specify the device, use the option to pass the Android device serial number:\n\nYou can extract a serial number from the previously mentioned adb devices command.\n\nAndroid is a system based on a Linux distribution that includes Linux kernel, and because of that we are able to access its shell layer. To do that, type the command:\n\nYou should now access the shell layer; for a check, run the command:\n\nYou can also run shell commands without accessing the shell layer first:\n\nThis lists all catalogs and files within the /sdcard catalog, which typically represents the SD card that’s been inserted to the device.\n\nAccessing the shell allows you to proceed with the Android system in a similar manner to the UNIX-based system; all commands for managing files, such as ls, touch, cat, etc., will be available. Of course, on our physical devices, some operations are blocked without root access arising from Android security policies. The shell provides us with a range of interesting options, enabling us to:\n\nOne of the powerful features of adb is exchanging data between your phone and PC.\n\nCopying data manually can be annoying, especially when we need to do it on a regular basis. Another negative factor is that GUI windows sometimes don’t show recently created files, e.g. after screen recording, a new file is not always visible in the file explorer.\n\nWhenever you need to copy some data from your phone to PC, the adb pull command comes to the rescue. It takes two parameters:\n• Remote (required): is the path on your mobile device to the file or directory that you want to download\n• Local (optional): is the computer’s local path where we want to save the downloaded file or directory; when the local path is not provided, the file will be downloaded to the current working directory on your computer\n\nTo see the progress of downloading a file, add the -p flag to the command.\n\nFor example, if we want to download a movie.mp4 file from our /sdcard catalog on our phone and save it on our PC desktop, we can simply type:\n\nThere is also a pattern where we need to push the data from our PC to the Android device.\n\nFor that purpose, we have the adb push command. It takes two required parameters:\n• Local: is the computer’s local path where we have the file or directory that we want to send to the Android device\n• Remote: is the path on your mobile device that you want to place in a file or directory\n\nTo see the progress of the file upload, add the -p flag to the command.\n\nFor example, let’s say that we want to send the previously downloaded movie.mp4 back to our phone in the /sdcard catalog:\n\nAdb also provides options to take screenshots and screen recordings.\n\nScreenshots are available in the screencap shell utility. After accessing the shell layer, type the following command:\n\nThis command takes a screenshot and saves it in the Android directory.\n\nWithout providing a catalog, it will try to save a screenshot in the Android current working directory, which is impossible, e.g. for system directories, and commands may throw a read-only permission error.\n\nAnother example with an explicit path:\n\nWith the file transfer knowledge, we are able to take a screenshot and copy data from an Android device to our PC in three simple commands, pretty neatly:\n\nScreen recording is also possible via adb, but in this case, it has its limitations:\n• Max duration of the recording is 3 minutes\n• Audio is not recording during a video\n\nIt uses the utility:\n\nTo see all available options for the screenrecord utility, type:\n\nAnother great tool that is accessible through the adb utility is dumpsys. It’s a tool run on an Android device that shows information about system services.\n\nThe basic command for displaying information for all services is:\n\nThe default output provided by dumpsys is often excessively detailed, making it necessary to employ specific command-line options in order to obtain output solely for the desired system services.\n\nFor listing all available system services, type:\n\nThere are a lot of services running on Android devices, so I will focus on more interesting ones from a developer’s perspective.\n\nEach service has its own options; to see available options for a given service, use the command:\n\nprints all possible options for a battery service:\n\nActivity service is used to display details for activities within the device. The command version without any additional parameters returns basic information about all activities.\n\nThe most valuable option is to provide your application’s package name to the activity service, which will print the currently run activity along with the whole view hierarchy and stack.\n\nThe one disadvantage of directly using activity service is poor readability and the inclusion of unnecessary information in the output. That’s why I recommend using the dump script from the AndroidViewClient library, which prints the view hierarchy in a much cleaner way and provides several options to parametrize it.\n\nFor displaying all available options for the dump script, type:\n\nSample output with the -x option, which also dumps views position:\n\nThere is also a script available for displaying the current Activity stack in human-readable format called easy-dumpsys for a specific app package:\n\nHere are some other notable dumpsys services:\n• dumpsys batteryinfo provides information about battery consumption by individual applications. It can be useful for monitoring and optimizing energy usage in your application.\n• dumpsys meminfo provides information about memory usage by applications. You can find detailed memory usage data, allocated objects, etc.\n• dumpsys network provides information about network usage by applications. You can find statistics on data sent and received by individual applications as well as network connection information.\n\nFrom time to time it’s crucial for Android developers to investigate app bugs. Apart from cloud logging solutions such as Firebase and Sentry, which collect elementary stack traces from various devices, there is also an option to generate more detailed bug reports from the device where the bug happens.\n\nTo generate a bug report for a connected device, use the following command:\n\nThe main advantages of using the command:\n• Detailed System Information generates a comprehensive report that includes detailed information about the device, system logs, event logs, running processes, battery usage, network status, and more. This information is helpful for diagnosing and troubleshooting complex system-level issues.\n• Reproducible Bug Reports captures the state of the device, system logs, and other relevant information at the time the bugreport command is being executed.\n• Easier collaboration The generated bug report can be shared directly with your development team, enabling effective communication and collaboration in identifying and resolving software defects.\n• Analysis of a native C/C++ code report that includes tombstone files. A tombstone is a file generated when a C++ crash occurs in an Android application. It contains information for debugging the crash, including stack traces, memory maps, and open file descriptors of the crashing process. More about tombstone files: Debugging Native Android Platform Code\n\nFor more information about bug report, visit: https://developer.android.com/studio/debug/bug-report\n\nAdb also allows you to interact with your Android application including actions such as:\n\nIn addition to the typical process of running your application using Android Studio and clicking the Run app button, it’s good to at least be aware of how your application is installed on your device. The benefits of using adb commands are:\n• Efficient app installation: You can quickly install Android applications on your devices without relying on the Android studio interface, which sometimes can’t be easily accessible on a machine\n• Automations: adb commands can be incorporated into your scripts or automation tools to perform batch operations on multiple devices, e.g it can be useful for CI workflows\n• Troubleshooting: In case of any running errors, you are able to identify and address potential problems and see more detailed error messages from CLI\n\n1. Generate an .apk file from your source code; for that step, the gradle library is used. It’s a build system used for Android development that handles compiling the source code, managing dependencies, and, in this case, generating an .apk file. For the easy build of your project, every Android source code consists of a gradle wrapper that allows for reproducible builds across different development environments by ensuring the use of a specific version of Gradle.\n\nTo run any gradle wrapper task, use the following command:\n\nIn case of building a debug version of APK, it will be:\n\nThis line creates an .apk file in the project directory:\n\n2. The next step is to install the application via the adb command. For that purpose the adb install command is used, which takes one parameter of the path to your previously generated .apk file.\n\n3. Finally, we need to launch a specific activity using the activity manger\n\nwhere the flag indicates the component name (package name and activity separated by a slash).\n\nIn a similar manner, you can uninstall your application by passing the package name of your app:\n\nYou can obtain your package name either from the AndroidManifest.xml file or with the help of adb using the pm (package manager) command:\n\nwhich prints package names for all applications installed on your phone.\n\nThe package manager also allows you to clear the data and cache associated with a package with one simple command:\n\nIt’s especially useful when you need to test the app again with a clear application state.\n\nAnother package manager advantage is the ability to grant or revoke runtime permissions for a given package.\n\nFor example, to grant the permission to an app with the package name com.example.myapp, you should use the following command:\n\nIt’s worth mentioning that you are also able to install an .apk file with all runtime permissions granted using the flag:\n\nAs Android developers, when developing new UI features, we sometimes need to perform the same task over and over again to check the final result, e.g. by filling in the same form to check user registration. Adb can also help us with such scenarios and provides a powerful set of shell commands that allow developers to manage events such as clicking, typing, or swiping, and many more.\n\nWith ADB, you can simulate a tap or a click event of specific screen coordinates. By using the input tap x y command:\n\nwhere x and y represent the coordinates, you can trigger clicks programmatically.\n\nFor identifying component positions, you can use the previously mentioned dump script with the flag, which prints center positions for all view components in the current view hierarchy:\n\nOptionally, you can identify the component position in a more manual way, using the Pointer location option enabled in the developer options.\n\nSimulating text input on an Android device is equally important. Adb provides the “input text” command, which allows you to enter text directly from the command line. By using “input text,” you can emulate typing, enabling automation of form filling or text input scenarios.\n\nFor example, typing the word Android in text input:\n\nKey events are events triggered by physical or virtual keys on an Android device. These events represent user interactions with the device’s hardware or software keyboard.\n\nAndroid provides a set of predefined keycodes that represent different keys on a standard Android device. Some common keycodes include:\n\nA list of all defined key events can be found here: https://developer.android.com/reference/android/view/KeyEvent\n\nTo simulate a key event interaction, provide either a key code or key name:\n\nThere are also swipe, drag and drop, key combination options, and more; to check all available options, use the command:\n\nOne of the libraries which are built on the top of adb is scrcpy.\n\nIt is a powerful and efficient open-source tool that allows you to mirror and control your Android device’s screen from your computer.\n\nOne of the most powerful features of scrcpy is screen mirroring. It enables you to mirror your Android device’s screen onto your computer. This can be useful for various purposes, such as giving presentations, demonstrating apps, recording videos, or simply handling all the device actions on your computer screen at higher resolutions.\n\nFor screen mirroring, use the basic form of the command:\n\nIn case of many devices attached, use the -s flag, which provides a serial number of the mirrored device.\n\nYou can also add additional parameters and, e.g., set parameters such as:\n\n–max-size <resolution>: Sets the maximum size for the mirrored display on your computer. You can specify the resolution in pixels, such as 1920×1080.\n\n–bit-rate <bitrate>: Sets the bit rate (in Mbps) for video encoding during screen mirroring. Higher bit rates result in better video quality but may consume more network bandwidth and system resources. You can adjust this value based on your preferences and the available network conditions.\n\n–record file.mp4: Enables screen recording and saves the output to the specified file. This flag allows you to record the mirrored screen of your Android device on your computer. Specify the desired file name with the .mp4 extension. It has no max recording limitation like the screenrecord utility mentioned earlier. Moreover, you can add –no-display to only record the screen without screen mirroring.\n\n–show-touches: Displays touch events as circles on the mirrored screen. This flag is useful for visualizing touch interactions during demonstrations or presentations.\n\n–stay-awake: Prevents the Android device from entering sleep mode while it is connected and being mirrored. This flag ensures that the device remains active during extended mirroring sessions.\n\n–no-control: Disables the ability to control the Android device from the computer. This flag is useful when you only want to mirror the screen without interacting with the device.\n\nI also recommend that you get familiar with the scrpcy documentation: https://github.com/Genymobile/scrcpy#user-documentation\n\nAdb is a powerful tool that provides a range of various commands that enable developers to interact with Android devices. It provides developers with a comprehensive set of tools for debugging, testing, and automating tasks on Android devices. Now, after having explored the basic commands and general mechanics, you can delve into the adb world and write the first aliases or scripts to improve your daily workflow.\n\nFor more inspiration, visit the following pages:"
    },
    {
        "link": "https://docs.radxa.com/en/compute-module/cm5/radxa-os/low-level-dev/rkdevtool",
        "document": "RKDevTool is a USB flashing software developed by Rockchip for Windows platforms.\n\nPlease download and extract the following files to install RKDevTool:\n\nDownload and unzip DriverAssistant, then execute DriverInstall.exe and click the button to install the driver. If you have previously installed another version of driver, please click to uninstall the driver first and then reinstall it.\n\nIf the operation is normal, RKDevTool will prompt :\n\nAlthough RKDevTool supports the selection of Maskrom devices, writing to multiple devices at the same time will result in a write failure for the device being written to. If you need to write to multiple devices at the same time, use upgrade_tool.\n\nClick a blank cell to select the Loader and Image file to be used(see the File Download at the below):\n\nSelect the target media in the option:\n\nWait for the write to complete, after which the device will reboot automatically:"
    },
    {
        "link": "https://wiki.radxa.com/Rock5/install/rockchip-flash-tools",
        "document": "ROCK 5 supports maskrom mode, which is a special operation mode for CPU to wait for command from USB OTG port. The Linux/macOS PC tool we use to communicate with ROCK 5 in maskrom mode are rkdeveloptool on Linux/macOS PC and RKDevTool on Windows PC.\n\nThe tool is provided in a compressed package. Please download the compressed package of this tool and extract files.\n\nUsing the RK driver assistant tool to install the driver.\n\nThere’s no need to connect your Rockchip device during this procedure just download and extract RKDriverAssistant.zip\n\nThen double click on DriverInstall.exe in the RKDriverAssistant directory to start the utility. If you installed the Rockchip USB drivers for any other Rockchip devices already, make sure you click “Uninstall Driver” first.\n\nThen click “Install Driver”to install the driver. And restart PC.\n\nOption two: rkdeveloptool on Linux (X86 or ARM)\n\nFor Linux, we build the latest rkdeveloptool (version >=1.32), from source code.\n\nTo build rkdeveloptool on a Debian based Linux distribution, follow the instruction below:\n\nIf you encounter compile error like below\n\nNow you have rkdeveloptool executable at the current directory.\n\nMake sure that its version is 1.32.or later\n\nTo build rkdeveloptool on macOS, you need homebrew(or similar package manager) to install required packages.\n\nIf you encounter compile error like below\n\nNow you have rkdeveloptool executable at the current directory.\n\nMake sure that its version is 1.32 or later."
    },
    {
        "link": "https://cnx-software.com/2021/11/14/how-to-flash-firmware-to-rockchip-devices-in-windows-and-linux",
        "document": "How to flash firmware to Rockchip devices in Windows and Linux (2021 Edition)\n\nWe’ve written several articles detailing methods to flash firmware to Rockchip devices in Windows or Linux over the years, with tools like RKAndroidTool, RkFlashKit, upgrade_tool, or the open-source rkdeveloptool utility. This is mostly useful to flash another OS or if the device does not boot, as most products will now support OTA firmware updates.\n\nBut following my review of Zidoo M6 with Android 11, I’ve now got a Linux image for the Rockchip RK3566 mini PC, so let’s revisit the firmware flashing methods in 2021. Zidoo sent me instructions for Windows, but since I’m a Ubuntu user, I flashed the firmware with the Linux tools used by Firefly. The same methods should work for the older processors such as RK3066, RK3288, and RK3399, besides the more recent Rockchip RK3566 and RK3568 processors.\n\nHow to flash Rockchip firmware in Linux\n\n[Important update: If your device comes with both eMMC flash and SPI flash, you may want to use the Windows tool instead to avoid bricking your device. See Willy’s comment for details]\n\nWe’ll need the firmware file (update.img) and the upgrade_tool utility downloaded from the Firefly website. Then we’ll need to enter the Loader mode to flash the image.\n\nTo do so, connect the USB OTG port from the board to your PC, press the boot/recovery button from your board, mini PC, or TV box (I used a SIM card tool here), and connect the power, wait one or two seconds and release the button. The first time, I thought connecting the power adapter first, pressing the recovery button, and inserting the USB cable would work too, as I got the following output from the dmesg:\n\n\n\n\n\n I thought it meant the box was properly detected, but I could not upgrade the firmware.\n\n\n\n\n\n So it’s important to press the recovery button before powering up the device or board, and we can see it shows as a “USB download gadget”\n\n\n\n\n\n In this mode, I had no trouble to flash the board:\n\n\n\n\n\n Connecting the mini PC is a TV confirmed everything worked as planned.\n\nThe Android 11 firmware was replaced by a Linux image with Qt. It’s basically the same method as in previous years, and it works without too many difficulties for me.\n\nI have not personally tried the Windows version, but I’ll share the method Zidoo provided me in a Word file. Updating firmware on Rockchip hardware in Windows requires a bit more effort than the Linux method with driver installation and a graphical utility to perform the firmware update. You can download both on Mega in a single ZIP file called M6 Flash Tool.zip.\n\nThe latest version of USB DriverAssitant can be found in the ZIP file in /Flash Tool/PC Drive/DriverAssitant_v5.1.1.zip, while FactoryTool.exe is located in /Flash Tool/Flash Tool/FactoryTool_1.72.4. Extract DriverAssitant and run DriveInstall.exe executable to install the proper drivers.\n\nNow extract FactoryTool run the program, optional change the language, and load the update.img image with the Firmware button on the top left corner.\n\nNow we need to connect the Rockchip device to the computer with a USB cable (USB OTG from board to a USB port on the computer), and enter the Loader mode as per the same method detailed in the Linux section, which involves pressing the recovery button and connecting the power.\n\n A “Loader” type device should be detected in FactoryTool, and we can now press the Run button to perform the update…\n\nSupport CNX Software! Donate via cryptocurrencies, become a Patron on Patreon, or purchase goods on Amazon or Aliexpress"
    },
    {
        "link": "https://wiki.t-firefly.com/en/AIO-3128C/Flash_Image.html",
        "document": "This page describes how to flash the image file from the host to the development board’s flash memory, via the Dual male USB data cable.Please choose the right way according to the host OS and image file type.\n\nYou can download compiled update.img, or you can reference Build Android to compile your own image file.Supported host OS:\n\nMultiple partition image, like kernel.img, boot.img, recovery.img, etc, which are created during development.\n\nMonolithic image, often known as update.img, which contains the bootloader, parameter and all the partition image files. It is used for firmware distribution.\n\nWhat you need:\n\nWe used to need two utilities to flash rockchip image file:\n\nLater, Rockchip release new tool: AndroidTool. It is based on RKDevelopTool, but adds flashing support for update.img. Therefore, one utility is sufficient.Before using the flashing utility, you need to install RK USB driver. If the driver is already installed, you can skip to next step.\n\nThere are two ways to put the device into upgrade mode.The first one, device is cut off all the power sources, such as power adapter and Dual male USB data cabl connection:\n• None After around two seconds, release RECOVERY key.\n• None Use Dual male USB data cabl to connect host and device together.\n• None After around two seconds, release RECOVERY key. RECOVERY button and RESET button and OTG interface as shown: When programming the firmware, you should use the dual male USB data cable. The connection interface is as shown: The host will prompt to have new device detected and configured. Open the Device Management, you’ll find a new device name “Rockusb Device”, as shown below. Return to previous step to reinstall driver if it is not shown.\n\nDownload AndroidTool_Release_v2.35.rar. Uncompress it and change to directory AndroidTool_Release_v2.35. Now, run AndroidTool.exe: (Note: If using Windows 7/8, you’ll need to right click it, select to run it as Administrator)\n• None Check the partitions you want.\n• None Make sure the image file’s path is correct. Click the rightmost empty table cell to select new path if needed.\n• None Click “Run” button to start flashing. Device will reboot automatically when finish."
    },
    {
        "link": "https://wiki.t-firefly.com/ROC-RK3328-CC/flash_emmc.html",
        "document": "eMMC flash is commonly soldered directly to the board. Some eMMC flash are pluggable, but it is hard to find a reader to use on PC. Therefore, eMMC is generally flashed onboard, that is, running to tiny system on the obard, which reads firmware data from PC and flashes to eMMC. Depending on the existing data on the eMMC flash, there are two special boot modes: Rockusb Mode and Maskrom Mode. You usually just need to enter Rockusb Mode for upgrading an existing Android OS or Firefly Ubuntu OS, which is packed with RK Firmware format. Maskrom Mode is the last resort when Rockusb Mode is not available due to bootloader damage, or you need to flash Raw Firmware to eMMC. If the board powers on and finds a valid IDB (IDentity Block) in the eMMC, it will continue to load the bootloader from the eMMC and pass execution control to it. If the bootloader checks that the Recovery button is pressed and USB connection is made, then it enters the so-called Rockusb Mode, waiting for further instructions from the host.\n• None Male to male USB cable to connect host PC and board.\n• None Pull all the USB cables (including micro USB cable and male to male USB cable) out of the board, to keep the board powering off.\n• None Install the eMMC and pull out the SD card.\n• None Use the male to male USB cable to connect the host PC with the USB 2.0 OTG port (the lower one in the double-decker ports) of the board.\n• None Keep the RECOVERY button on the board pressed.\n• None Plug in the micro USB cable to the board to power up.\n• None Wait about 3 seconds before releasing the RECOVERY button. If anyone of the following conditions is met when the board powers on:\n• None The bootloader on eMMC is damaged. then no valid IDB (IDentity Block) will be found in the eMMC. The CPU will execute a small ROM code, waiting for the host to upload via USB a small DDR blob to initialize the DDR memory, and later a full bootloader to handle further firmware upgrading. This mode is called Maskrom Mode. It involves hardware operation to force into MaskRom Mode, which has certain risk and should be carried out VERY CAREFULLY.\n• None Male to male USB cable to connect host PC and board.\n• None Pull all the USB cables (including micro USB cable and male to male USB cable) out of the board, to keep the board power off.\n• None Install the eMMC and pull out the SD card.\n• None Use a male to male USB cable to connect your host PC and USB OTG port of the board:\n• None Find the reserved eMMC CLK and GND pads on the board, as shown below:\n• None Connect the eMMC CLK and GND pads with metal tweezers and keep holding steadily.\n• None Plug in the micro USB cable to the board to power on.\n• None Wait about 1 seconds before releasing the metal tweezers.\n\nFirmware description: the firmware is classified into Raw Firmware and RK Firmware, which are placed into different folders. The latest firmware is the one with the latest date, which is often more stable. Please choose the correct tool to flash according to the type of firmware you need. Linux (GPT) firmware: The Linux firmware files, including Ubuntu, Buildroot, Debian and other Linux systems, contain in the filenames which means that they are using GPT partition scheme. They are referred to as , which can be compiled in the Compile Linux firmware(GPT) chapter.\n\nrkdeveloptool is an open-source command line flashing tool developed by Rockchip, which is an alternative to the close-source upgrade_tool. Then add rules by instructions here, in order to have permission for the normal user to flash Rockchip devices. If you skip this, you must prefix the following commands with to have the right permission. Raw Firmware needs to be flashed to offset 0 of eMMC storage. However, in Rockusb Mode, all LBA writes are offset by 0x2000 sectors. Therefore, the device has to be forced into Maskrom Mode. To flash Raw Firmware to the eMMC using rkdeveloptool, follow the steps below:\n• None is the copied loader file after compiling . It can also be downloaded from here (choose file).\n• None is Raw Firmware after packing, which can also be the Raw Firmware downloaded from official site (decompress it first). The following instructions ONLY APPLIY to boards which are flashed with Raw Firmware and use partition scheme. The predefined offset and size of each partition can be found in in the SDK. See Partition Offset for more detail. To flash Partition Image to the eMMC using rkdeveloptool, follow the steps below:\n\nThe offset of partition image can be obained by following command(assuming you are in the directory of Firefly Linux SDK): If RK Firmware is used, is used to define partition layout. Here’s a handy script to list the partition offsets in : Save it as a script in and give the script executing permission. Here’s an example of showing partition offsets defined in :"
    }
]