[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke",
        "document": "P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code. Most of the P/Invoke API is contained in two namespaces: and . Using these two namespaces give you the tools to describe how you want to communicate with the native component.\n\nLet's start from the most common example, and that is calling unmanaged functions in your managed code. Let's show a message box from a command-line application:\n\nThe previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code. Let's step through the example:\n• Line #2 shows the directive for the namespace that holds all the items needed.\n• Line #8 introduces the LibraryImportAttribute attribute. This attribute tells the runtime that it should load the unmanaged binary. The string passed in is the unmanaged binary that contains the target function. Additionally, it specifies the encoding to use for marshalling the strings. Finally, it specifies that this function calls SetLastError and that the runtime should capture that error code so the user can retrieve it via Marshal.GetLastPInvokeError().\n• Line #9 is the crux of the P/Invoke work. It defines a managed method that has the exact same signature as the unmanaged one. The declaration uses the attribute and the keyword to tell a compiler extension to generate code to call into the unmanaged library.\n• Within the generated code and prior to .NET 7, the is used. This declaration uses the keyword to indicate to the runtime this is an external method, and that when you invoke it, the runtime should find it in the unmanaged binary specified in the attribute.\n\nThe rest of the example is invoking the method as you would any other managed method.\n\nThe sample is similar for macOS. The name of the library in the attribute needs to change since macOS has a different scheme of naming dynamic libraries. The following sample uses the function to get the process ID of the application and print it out to the console:\n\nIt is also similar on Linux. The function name is the same, since is a standard POSIX system call.\n\nThe runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers. The closest thing to a function pointer in managed code is a delegate, so this is what is used to allow callbacks from native code into managed code.\n\nThe way to use this feature is similar to the managed to native process previously described. For a given callback, you define a delegate that matches the signature and pass that into the external method. The runtime will take care of everything else.\n\nBefore walking through the example, it's good to review the signatures of the unmanaged functions you need to work with. The function to be called to enumerate all of the windows has the following signature:\n\nThe first parameter is a callback. The said callback has the following signature:\n\nNow, let's walk through the example:\n• Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code. Notice how the LPARAM and HWND types are represented using in the managed code.\n• Lines #13 and #14 introduce the function from the user32.dll library.\n• Lines #17 - 20 implement the delegate. For this simple example, we just want to output the handle to the console.\n• Finally, in line #24, the external method is called and passed in the delegate.\n\nThe Linux and macOS examples are shown below. For them, we use the function that can be found in , the C library. This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters. The said function has the following signature: .\n\nmacOS example uses the same function, and the only difference is the argument to the attribute, as macOS keeps in a different place.\n\nBoth of the previous examples depend on parameters, and in both cases, the parameters are given as managed types. Runtime does the \"right thing\" and processes these into its equivalents on the other side. Learn about how types are marshalled to native code in our page on Type marshalling."
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2003/july/net-column-calling-win32-dlls-in-csharp-with-p-invoke",
        "document": "Calling Win32 DLLs in C# with P/Invoke\n\nEnter P/Invoke\n\n Style\n\n The DLL Import Attribute\n\n Optional DllImportAttribute Properties\n\n Data Marshaling\n\n Marshaling Numerical and Logical Scalars\n\n Parameters that are Pointers\n\n Marshaling Opaque Pointers: a Special Case\n\n Marshaling Text\n\n Summing it Up\n\nI have noticed a trend in my programming of late, and that trend has inspired the topic of this month's column. Recently, I have done a fair amount of Win32® Interop in my Microsoft® .NET Framework-based apps. I am not saying that my apps are full of custom interop code, but from time to time I bump into a minor, but nagging, inadequacy in the .NET Framework Class Library that can quickly be alleviated by a call into the Windows® API.\n\nAs I think about it, any feature limitation in the .NET Framework version 1.0 or 1.1 class library that is not shared by Windows doesn't come as a huge surprise. After all, 32-bit Windows, in all of its incarnations, is a mature operating system that has served a wide breadth of customers for over a decade. The .NET Framework is, in comparison, a newcomer.\n\nAs an increasing developer base moves its production applications to managed code, it seems only natural that there will be even more occasions for developers to dip down into the underlying operating system for some critical tidbit of functionality—at least for the time being.\n\nThankfully, the interop features of the common language run-time (CLR), called Platform Invoke (P/Invoke), are very complete. In this column I am going to focus on the practical use of P/Invoke for calling Windows API functions. P/Invoke is used as a noun when referring to the COM Interop functionality of the CLR and is used as a verb when referring to the use of this feature. I am not going to address COM Interop directly because it is paradoxically both more accessible and more complex than P/Invoke, making it less straightforward as a column topic.\n\nI'll start by looking at a simple P/Invoke example. Let's see how to call the Win32 MessageBeep function whose unmanaged declaration is shown in the following code:\n\nYou'll need the following code to add to a class or struct definition in C# in order to call MessageBeep:\n\nSurprisingly, this code is all that's required before your managed code can suddenly call the unmanaged MessageBeep API. It's not a method call, but an extern method definition. (Also, it's as close to a straight port from C that C# will allow, so it is a helpful starting point for introducing some concepts.) A possible call from managed code might look like this:\n\nNow, notice that the MessageBeep method was declared as static. This is a requirement for P/Invoke methods because there is no consistent notion of an instance in the Windows API. Next, notice that the method is marked as extern. This is your hint to the compiler that you mean for the method to be implemented by a function exported from a DLL, and therefore there is no need for you to supply a method body.\n\nSpeaking of missing method bodies, did you notice that the MessageBeep declaration doesn't contain a body? Unlike most managed methods whose algorithms are comprised of intermediate language (IL) instructions, P/Invoke methods are nothing more than metadata that the just-in-time (JIT) compiler uses to wire managed code to an unmanaged DLL function at run time. An important piece of information required to perform this wiring to the unmanaged world is the name of the DLL from which the unmanaged method is exported. This information is provided by the DllImport custom attribute that precedes the MessageBeep method declaration. In this case, you can see that the MessageBeep unmanaged API is exported by the User32.dll in Windows.\n\nSo far I have exhausted all but two of the lessons to be learned from the call to MessageBeep which, as you'll recall, looked like the code shown in the following snippet:\n\nThe final two lessons are the related topics of data marshaling and the actual method call from managed code into the unmanaged function. The call into the unmanaged MessageBeep function can be performed by any managed code that finds the extern MessageBeep declaration within scope. The call is made like any other call to a static method. It is this commonality with any other managed method calls that introduces the requirement of data marshaling.\n\nOne of the rules of C# is that its call syntax can only access CLR data types such as System.UInt32 and System.Boolean. C# is expressly unaware of C-based data types used in the Windows API such as UINT and BOOL, which are just typedefs of the C language types. So while the Windows API function MessageBeep is documented as the following\n\nthe extern method must be defined using CLR types, as you saw in the preceding code snippet. This requirement to use CLR types that are different from, but compatible with, the underlying API function types is one of the more difficult aspects of using P/Invoke. Therefore, I'll devote a whole section to data marshaling a little later in this column.\n\nSo making P/Invoke calls to the Windows API is easy in C#. And if the class library refuses to make your application beep, by all means call Windows to do the job, right?\n\nRight. But the approach you choose does matter; and it matters a lot! In general, if the class library offers a way to achieve your goals, it is preferable to use that API rather than making direct calls to unmanaged code because of the significant difference in style between the CLR types and Win32. I can sum up my advice on this matter in a single sentence. When you P/Invoke, don't subject your application logic directly to any extern methods or artifacts thereof. If you follow this little rule, more often than not you'll be spared lots of hassles in the long run.\n\nThe code in Figure 1 shows the minimum additional code for the MessageBeep extern method I've been discussing. There isn't any rocket science in Figure 1, just some common-sense improvements to a bare extern method that make life a little easier. Starting from the top, you will notice that an entire type named Sound is devoted to MessageBeep. If I need to add support for playing waves using the Windows API function PlaySound, I could reuse the Sound type. However, I am not offended by a type that exposes a single public static method. This is application code, after all. Notice also that Sound is sealed and defines an empty private constructor. These are just details to keep a user from mistakenly deriving from or creating an instance of Sound.\n\nThe next feature of the code in Figure 1 is that the actual extern method where P/Invoke occurs is a private method of Sound. This method is exposed only indirectly by the public MessageBeep method, which takes a parameter of type BeepTypes. This extra level of indirection is a critical detail that provides the following benefits. First, should a future managed method of beeping be introduced in the class library, you can re-tool your public MessageBeep method to use the managed API without having to change the rest of the code in your application.\n\nA second benefit of the wrapper method is this: when you P/Invoke, you waive your right to the protection from access violations and other low-level catastrophes, normally provided by the CLR. A buffer method, even if it does nothing but pass parameters through, allows you to protect the rest of your application from access violations and the like. The buffer method localizes any potential bugs introduced by the P/Invoke call.\n\nThe third and final benefit of hiding your private extern methods behind a public wrapper is the opportunity to add some minimum CLR style to the method. For example, in Figure 1 I converted a Boolean failure returned by the Windows API function into a more CLR-like exception. I also defined an enumerated type named BeepTypes whose members correspond to the define values used with the Windows API. Since C# doesn't support defines, managed enumerated types are used to avoid scattering magic numbers throughout your application code.\n\nThis final benefit of a wrapper method is admittedly minor for a simple Windows API function like MessageBeep. But as you begin to call into more complex unmanaged functions, you will find a manual translation from the Windows API style to a more CLR-friendly approach increasingly beneficial. The more you plan to reuse your interop functionality throughout your applications, the more design thought you should put into the wrapper. Meanwhile I see no shame in non-object-oriented static wrapper methods with CLR-friendly parameters.\n\nOK, it's time to dig a little deeper. The DllImportAttribute type plays an important part in the P/Invoke story for managed code. The DllImportAttribute's primary role is to indicate to the CLR which DLL exports the function that you want to call. The name of the DLL in question is passed as the single constructor parameter to the DllImportAttribute.\n\nIf you are unsure which DLL defines the Windows API function that you are trying to use, the Platform SDK documentation provides your best source for help. Near the bottom of the topic text for a Windows API function, the SDK documentation names the .lib file that a C application would link to in order to use the function. In all but a very few cases, the .lib file has the same name as the system DLL file in which the function is defined. For example, if the function requires C applications to link to Kernel32.lib then the function is defined in Kernel32.dll. You can find the Platform SDK documentation topic for MessageBeep at MessageBeep. Toward the bottom of the topic, notice that it says that the library file is User32.lib; this indicates that MessageBeep is exported from User32.dll.\n\nIn addition to indicating the host DLL, the DllImportAttribute also includes a handful of optional properties, four of which are particularly interesting: EntryPoint, CharSet, SetLastError, and CallingConvention.\n\nEntryPoint You can set this property to indicate the entry point name of the exported DLL function in cases where you do not want your extern managed method to have the same name as the DLL export. This is particularly useful when you are defining two extern methods that call into the same unmanaged function. Additionally, in Windows you can bind to exported DLL functions by their ordinal values. If you need to do this, an EntryPoint value such as \"#1\" or \"#129\" indicates the ordinal value of the unmanaged function in the DLL rather than a function name.\n\nCharSet When it comes to character sets, not all versions of Windows are created equal. The Windows 9x family of products lack significant Unicode support, while the Windows NT and Windows CE flavors use Unicode natively. And sitting on top of these operating systems, the CLR uses Unicode for its internal representation of String and Char data. But never fear—the CLR automatically makes the necessary translations from Unicode to ANSI when calling into Windows 9x API functions.\n\nIf your DLL function doesn't deal with text in any way, then you can ignore the CharSet property of the DllImportAttribute. However, when Char or String data is part of the equation, set the CharSet property to CharSet.Auto. This causes the CLR to use the appropriate character set based on the host OS. If you don't explicitly set the CharSet property, then its default is CharSet.Ansi. This default is unfortunate because it negatively affects the performance of text parameter marshaling for interop calls made on Windows 2000, Windows XP, and Windows NT®.\n\nThe only time you should explicitly select a CharSet value of CharSet.Ansi or CharSet.Unicode, rather than going with CharSet.Auto, is when you are explicitly naming an exported function that is specific to one or the other of the two flavors of Win32 OS. An example of this is the ReadDirectoryChangesW API function, which exists only in Windows NT-based operating systems and supports Unicode only; in this case you should use CharSet.Unicode explicitly.\n\nSometimes it is unclear whether a Windows API has a character set affinity. A surefire way to find out is to check the C-language header file for the function in the Platform SDK. (If you are unsure which header file to look in, the Platform SDK documentation lists the header file for each API function.) If you find that the API function is really defined as a macro that maps to a function name ending in A or W, then character set matters for the function that you are trying to call. An example of a Windows API function that you might be surprised to learn has A and W versions is the GetMessage API declared in WinUser.h.\n\nSetLastError Error handling is an important but frequently avoided aspect of programming. And when you are P/Invoking, you are faced with the additional challenge of dealing with the differences between Windows API error handling and exceptions in managed code. I have a few suggestions for you.\n\nIf you are using P/Invoke to call into a Windows API function for which you use GetLastError to find extended error information, then you should set the SetLastError property to true in the DllImportAttribute for your extern method. This applies to the majority of extern methods.\n\nThis causes the CLR to cache the error set by the API function after each call to the extern method. Then, in your wrapper method, you can retrieve the cached error value by calling the Marshal.GetLastWin32Error method defined on the System.Runtime.InteropServices.Marshal type in the class library. My advice is to check for error values that you expect from the API function and throw a sensible exception for these values. For all other failure cases, including those where failure wasn't expected at all, throw the Win32Exception defined in the System.ComponentModel namespace and pass it the value returned by Marshal.GetLastWin32Error. If you take a look back at the code in Figure 1, you will see that I took this approach in my public wrapper around the extern MessageBeep method.\n\nCallingConvention The last and probably least important of the DllImportAttribute properties that I will cover here is CallingConvention. This property lets you indicate to the CLR which function calling convention it should use for parameters on the stack. The default value of CallingConvention.Winapi is your best bet and will work in most cases. However, if the call isn't working, you might check the declaring header file in the Platform SDK to see if the API function you are calling is one of the odd APIs that bucks the calling convention standard.\n\nIn general, the calling convention of a native function, such as a Windows API function or a C-runtime DLL function, describes how the parameters are pushed onto and cleaned off the thread's stack. Most Windows API functions push the last parameter of a function onto the stack first, and then it is the called function's job to clean up the stack. By contrast, many of the C-runtime DLL functions are defined to push the method parameters onto the stack in the order they appear in the method signature, leaving stack cleanup to the caller.\n\nFortunately you only need a peripheral understanding of calling conventions to get P/Invoke calls to work. In general, starting with the default, CallingConvention.Winapi, is your best bet. And then, with C-runtime DLL functions and a very few functions you might have to change the convention to CallingConvention.Cdecl.\n\nData marshaling is a challenging aspect of P/Invoke. When passing data between the managed and unmanaged worlds, the CLR follows a number of rules that few developers will encounter often enough to memorize. Mastery of the details, though, is normally unnecessary unless you are a class library developer. Application developers who need to interop only occasionally should still understand some fundamentals of data marshaling to get the most out of P/Invoke on the CLR.\n\nFor the remainder of this month's column I will discuss data marshaling of simple numeric and string data. I will start with the most basic marshaling of numeric data and work my way up through simple pointer marshaling and string marshaling.\n\nThe majority of the Windows OS is written in C. As a result, the data types used with the Windows API are either C types or C types that are relabeled through a type definition or macro definition. Let's look at data marshaling without pointers. To keep things simple, I'll focus first on numbers and Boolean values.\n\nWhen passing a parameter by value to a Windows API function, you need to know the answers to the following questions:\n• Is the data fundamentally integral or floating-point?\n• If the data is integral, is it signed or unsigned?\n• If the data is integral, how wide is it in bits?\n• If the data is floating-point, is it single or double precision?\n\nSometimes the answers are obvious, and other times they aren't. The Windows API redefines the fundamental C data types in a variety of ways. Figure 2 lists some common C and Win32 data types, along with their specifications and a common language runtime type with a matching specification.\n\nIn general, as long as you select a CLR type whose specification matches that of the Win32 type for the parameter, your code will work. There are some special cases, however. For example, the BOOL type definition in the Windows API is a signed 32-bit integer. However, BOOL is used to indicate a Boolean value of true or false. While you could get away with marshaling a BOOL parameter as a System.Int32 value, you will get a more appropriate mapping if you use the System.Boolean type. Character type-mapping is similar to BOOL in the sense that there is a specific CLR type, System.Char, to address character meaning.\n\nWith this information, it might be helpful to step through an example. Sticking with the beep theme, let's try the Kernel32.dll low-level Beep, which makes a beep through the computer's speaker. The Platform SDK documentation for the method can be found at Beep. The native API is documented as follows:\n\nIn terms of parameter marshaling, your job is to figure out what CLR data types are compatible with the DWORD and BOOL data types used with the Beep API function. Reviewing the chart in Figure 2, you'll see that DWORD is a 32-bit unsigned integer value, as is the CLR type System.UInt32. This means that you can use UInt32 values for the two parameters to Beep. The BOOL return value is an interesting case because the chart tells us that in Win32, BOOL is a 32-bit signed integer. Therefore, you could use a System.Int32 value for the return value from Beep. However, the CLR also defines the System.Boolean type for the semantic meaning of a Boolean value, so you should use that instead. The CLR will marshal the System.Boolean value as a 32-bit signed integer by default. The extern method definition shown here is the resulting P/Invoke method for Beep:\n\nMany Windows API functions take a pointer as one or more of their parameters. Pointers increase the complexity of marshaling data because they add a level of indirection. Without pointers, you pass data by value on the thread's stack. With pointers, you pass data by reference, by pushing a memory address to the data onto the thread's stack. The function then accesses the data indirectly through the memory address. There are multiple ways to express this additional level of indirection using managed code.\n\nIn C#, if you define a method parameter as ref or out, then the data is passed by reference rather than by value. This is true, even if you are not using Interop, but are just calling from one managed method to another. For example, if you pass a System.Int32 parameter by ref, then you pass the address to the data on the thread's stack rather than the integer value itself. Here is an example of a method defined to receive an integer value by reference:\n\nHere, the FlipInt32 method takes the address of an Int32 value, accesses the data, negates it, and assigns the negated value to the original variable. In the following code, the caller's variable x would have its value changed from 10 to -10 by the FlipInt32 method:\n\nThis ability, in managed code, can be reused to pass pointers to unmanaged code. For example, the FileEncryptionStatus API function returns file encryption status as a 32-bit unsigned bitmask. The API is documented as shown here:\n\nNotice that the function doesn't return the status using its return value, but instead returns a Boolean value indicating whether the call succeeded. In the success case, the actual status value is returned through the second parameter. The way this works is that the caller passes the function a pointer to a DWORD variable, and the API function populates the pointed-to memory with the status value. The following snippet shows a possible extern method definition to call into the unmanaged FileEncryptionStatus function:\n\nThe definition uses the out keyword to indicate a by-ref parameter for the UInt32 status value. I could have selected the ref keyword here as well, and in fact both result in the same machine code at run time. The out keyword is simply a specialization of a by-ref parameter that indicates to the C# compiler that the data being passed is only being passed out of the called function. In contrast, with the ref keyword the compiler assumes that data may flow both in and out of the called function.\n\nAnother cool aspect of out and ref parameters in managed code is that the variable whose address you pass as the by-ref parameter may be a local variable on the thread's stack, an element of a class or structure, or it can be a reference to an element in an array of the appropriate data type. This caller flexibility makes by-ref parameters a good starting point for marshaling pointers to buffers, as well as to single data values. I would only consider marshaling a pointer as a more complex CLR type such as a class or an array object after I found that a ref or an out parameter did not meet my needs.\n\nIf you are unfamiliar with C syntax or making calls into the Windows API functions, then sometimes it can be difficult to know if a method parameter requires a pointer. A common indicator is if the parameter type starts with the letter P or the letters LP such as LPDWORD or PINT. In both of these examples the LP and P indicate that the parameter is a pointer, and the data type that they point to would be DWORD or INT, respectively. In some cases, however, the API function is defined as a pointer directly using the asterisk symbol (*) in C-language syntax. The following code snippet shows an example of this:\n\nAs you can see, the preceding function's single parameter is a pointer to a DWORD variable.\n\nWhen marshaling pointers through P/Invoke, ref and out are only used with value types in managed code. You can tell a parameter is a value type when its CLR type is defined using the struct keyword. Out and ref are used to marshal pointers to these data types because normally a value type variable is the object or data, and you don't have a reference to a value type in managed code. In contrast, the ref and out keywords are not necessary when marshaling reference type objects because the variable already is a reference to the object.\n\nIf you are unfamiliar with the difference between reference types and value types you can find more information on the topic in the .NET column in the December 2000 issue of MSDN® Magazine. Most CLR types are reference types; however, all of the primitive types such as System.Int32 and System.Boolean are value types with the exceptions of System.String and System.Object.\n\nSometimes in the Windows API a method takes or returns a pointer that is opaque, which means that the pointer value is technically a pointer but your code doesn't use it directly. Instead, your code passes the pointer back to Windows for subsequent reuse.\n\nA very common example of this is the notion of a handle. In Windows, internal data structures ranging from files to buttons on the screen are represented to application code as handles. A handle is really an opaque pointer or pointer-width data value that your application uses to represent the internal OS construct.\n\nOccasionally, API functions also define opaque pointers to be of the PVOID or LPVOID types. These types in the Windows API definitions mean that the pointer has no type.\n\nWhen an opaque pointer is returned to (or expected from) your application, you should marshal the parameter or return value as a special type in the CLR called System.IntPtr. When you use the IntPtr type it is not common to use an out or ref parameter because an IntPtr is intended to hold a pointer directly. However, if you are marshaling a pointer to a pointer, then a by-ref parameter to an IntPtr is appropriate.\n\nThe System.IntPtr type has a special property in the CLR type system. Unlike the rest of the basic types in the system, IntPtr does not have a fixed size. Instead, its size at run time is based on the natural pointer size of the underlying operating system. This means that in 32-bit Windows IntPtr variables will be 32 bits in width, and in 64-bit Windows the just-in-time compiler emits code that treats IntPtr values as 64-bit values. This automatic resizing is very useful when marshaling opaque pointers between managed and unmanaged code.\n\nRemember, any API function that returns or accepts a handle is really working with an opaque pointer. Your code should marshal handles in Windows as System.IntPtr values.\n\nYou can cast IntPtr values to and from 32-bit and 64-bit integer values in managed code. However, since the pointers are supposed to be opaque when used with Windows API functions, you should have no need to do anything with the values but store them and pass them to extern methods. Two exceptions to the store-and-pass-only rule are when you need to pass a null pointer value to an extern method and when you need to compare an IntPtr value with null. To do this, rather than cast zero to System.IntPtr, you should use the Int32.Zero static public field on the IntPtr type to get the null value for comparing or assigning.\n\nWorking with textual data is common in programming. Text adds some wrinkles to the interop story for two reasons. First, the underlying operating system may use Unicode to represent strings or it may use ANSI. In some rare cases, such as with the MultiByteToWideChar API function, the two parameters to the function disagree on character set.\n\nThe second reason that working with text when P/Invoking requires you to have some special understanding is that C and the CLR each deal with text differently. In C, a string is really only an array of char values, typically terminating in a null. Most of the Windows API functions deal with strings on these terms, either as an array of char values in the ANSI case or an array of wchar values in the case of Unicode.\n\nFortunately, the CLR is designed to be very flexible when marshaling text so that you can get the job done, regardless of what the Windows API function expects from your application. Here are the primary considerations to keep in mind:\n• Is your application passing text data to the API function or does string data pass back from the API function to your application? Or both?\n• What managed type should your extern method use?\n• What unmanaged string format does the API function expect?\n\nLet's address this last concern first. Most of the Windows API functions take LPTSTR or LPCTSTR values. These are modifiable and non-modifiable buffers, respectively (from the function's point of view), which contain null-terminated character arrays. The \"C\" stands for constant and means that information will not be passing out of the function using that parameter. The \"T\" in LPTSTR indicates that this parameter can be either Unicode or ANSI depending on the character set you choose and depending on the character set of the underlying operating system. Since most string parameters are one of these two types in the Windows API, the CLR defaults work for you so long as you selected CharSet.Auto on your DllImportAttribute.\n\nHowever, some API functions or custom DLL functions represent strings in different ways. If you run across one of these functions, you can decorate your extern method's string parameter with the MarshalAsAttribute and indicate a string format other than the default LPTSTR. For more information on the MarshalAsAttribute, see the Platform SDK documentation topic at MarshalAsAttribute Class.\n\nNow let's look at the direction in which string information is being passed between your code and the unmanaged function. There are two ways that you can know which direction the information is being passed in when working with strings. The first and most reliable method is to understand the purpose of the parameter in the first place. For example, if you are calling a parameter with a name like CreateMutex and it takes a string, then you can imagine that the string information passes from your application to the API function. Meanwhile, if you call GetUserName, then the function name suggests that string information passes from the function to your application.\n\nIn addition to the rationalization approach, the second way to find out which direction the information flows in is to look for the letter \"C\" in the API parameter type. For example, the GetUserName API function's first parameter is defined as type LPTSTR, which stands for long-pointer to a Unicode or ANSI string buffer. But CreateMutex's name parameter is typed as LTCTSTR. Notice that here you have the same type definition, but with the addition of the letter \"C\" to indicate that the buffer is constant and will not be written to by the API function.\n\nOnce you have established whether the text parameter is input only or input/output, you can determine which CLR type to use for the parameter type. Here are the rules. If the string parameter is input only, use the System.String type. Strings are immutable in managed code, and are well suited to be used as buffers that will not be changed by the native API function.\n\nIf the string parameter can be input and/or output, then use the System.StringBuilder type. The StringBuilder type is a useful class library type that helps you build strings efficiently, and it happens to be great for passing buffers to native functions that the functions fill with string data on your behalf. Once the function call has returned, you need only call ToString on the StringBuilder object to get a String object.\n\nThe GetShortPathName API function is great for showing when to use String and when to use StringBuilder because it takes only three parameters: an input string, an output string, and a parameter that indicates the length in characters of the output buffer.\n\nThe commented documentation for the unmanaged GetShortPathName function in Figure 3 indicates both an input and output string parameter. This leads to the managed extern method definition, also shown in Figure 3. Notice that the first parameter is marshaled as a System.String because it is an input-only parameter. The second parameter represents an output buffer, and System.StringBuilder is used.\n\nThe P/Invoke features covered in this month's column are sufficient to call many of the API functions in Windows. However, if your interop needs are significant, you will eventually find yourself marshaling complex data structures and perhaps even needing access to memory directly through pointers in managed code. In fact, interop into native code can be a veritable Pandora's box of details and low-level bits. The CLR, C#, and managed C++ offer many features to help; perhaps in a later installment of this column I will cover advanced P/Invoke topics.\n\nMeanwhile, whenever you find that the .NET Framework Class Library won't play a sound for you or perform some other bit of magic on your behalf, you know how to lean on the good old Windows API for some assistance.\n\nSend your questions and comments for Jason to dot-net@microsoft.com.\n\nJason Clark provides training and consulting for Microsoft and Wintellect (https://www.wintellect.com) and is a former developer on the Windows NT and Windows 2000 Server team. He is the coauthor of Programming Server-side Applications for Microsoft Windows 2000 (Microsoft Press, 2000). You can get in touch with Jason at JClark@Wintellect.com."
    },
    {
        "link": "https://pinvoke.net",
        "document": "Type a page name and press Enter. You'll jump to the page if it exists, or you can create it if it doesn't. To create a page in a module other than misc, prefix the name with the module name and a period.\n\nPInvoke.net is primarily a wiki, allowing developers to find, edit and add PInvoke* signatures, user-defined types, and any other information related to calling Win32 and other unmanaged APIs from managed code (written in languages such as C#).\n\n.NET developers worldwide can easily contribute to the community, sharing their valuable knowledge, whenever they have time to do so.\n\nNew to Wikis? Try the Playground to experiment with the editing process\n\nCopy and paste your way to productivity\n\nCertain things just can't be done natively in some languages, and developers have to drill down to the OS API. This is achieved through .NET’s Platform Invoke (PInvoke) functionality, which requires declarations to be supplied by the developer. Manually defining and using PInvoke signatures is an error-prone process that can introduce subtle bugs. PInvoke.net supplies you with tried and tested signatures and type definitions, so that you don't have to spend time writing them from scratch.\n\nWe provide an Add-in to Visual Studio 2019 - 2022, to make the insertion of PInvoke signatures an easy, fast operation. Download the PInvoke.net Add-in for FREE now.\n\nDid you spend hours figuring out how to successfully define and call a given unmanaged API in managed code? Share (and get credit for) your discovery here! Is there an error on this site? Go ahead and fix it!\n\nWe are constantly looking for editors to join in, to continue making this space a valuable resource for .NET developers across the globe.\n\n* The term PInvoke is derived from the phrase \"Platform Invoke\". PInvoke signatures are native method signatures"
    },
    {
        "link": "https://tech-on-diapers.hashnode.dev/c-interoperability-calling-unmanaged-code-with-pinvoke",
        "document": ""
    },
    {
        "link": "https://tevora.com/threat-blog/dynamic-invocation-in-csharp",
        "document": "This post serves as introduction to payload development, following up on concepts in basic C# payload development such as the usage of Windows APIs, platform invocation (P/Invoke), and how basic Windows APIs tie together to perform shellcode execution. There are many approaches to payload/stager development, with multiple options of language, frameworks, etc. This post will focus on C#.\n\nFirst, credit is due to @The Wover and @FuzzySec for the creation of dynamic invocation (D/Invoke) as well as providing a blog post that goes in depth on the fundamentals of D/Invoke. The linked blog post provides an excellent background into the negatives of P/Invoke as a way of using Windows API calls. It states that:\n• Any reference to a Windows API call made through P/Invoke will result in a corresponding entry in the .NET Assembly’s Import Table. When your .NET Assembly is loaded, its Import Address Table will be updated with the addresses of the functions that you are calling.\n• If the endpoint security product running on the target machine is monitoring API calls (such as via API Hooking), then any calls made via P/Invoke may be detected by the product.\n\nThe blog also includes information on how D/Invoke is integrated with SharpSploit, but doesn’t cover how we can implement it into our own C# payloads. While it also provides a Github repo as an example of integrating D/Invoke, the lack of documentation may make it hard to follow.\n\nIn this blog post, we’ll walk through an example of our own, while also looking at the multiple different methods available to us.\n\nTo begin, rather than straight up integrating the original D/Invoke project into our payloads, we can use a fork provided by Rastamouse, which contains only the minimum core DynamicInvoke and ManualMap functionality. This fork omits the default D/Invoke Injection folder as well as several Windows APIs.\n\nWe will use and make edits to this fork in this post.\n\nUsing this fork, rather than the original project, maintains a lower profile and brings us a step toward evading any sort of detection. To go along with this, Rastamouse has provided a wiki to document API usage with D/Invoke.\n\nLet’s go ahead and start building the framework for our payload. We’ll begin by creating a new project in Visual Studio, making sure to select Console App (.NET Framework) C#. Because we are building our payload specifically for Windows machines, we don’t need the cross-platform capability that .NET core brings, and instead use .NET Framework because the capabilities align with what we’re trying to accomplish. Additionally, .NET Core is not installed by default, whereas .NET Framework is, so we are much less likely to run into compatibility issues. Nevertheless, as long as we are using .NET, our application builds as Assemblies, meaning we can tinker with different execution methods and techniques such as reflective loading. A deeper dive into assemblies can be found within the MSDN documentation here: https://docs.microsoft.com/en-us/dotnet/standard/assembly/.\n\nFrom here, we’ll need to create three folders to house the three different D/Invoke namespaces.\n\nWe can name the folders like so:\n\nNow we’ll need to import the C# files into their respective folders. The final result should look something like this:\n\nWe can test that the D/Invoke files have been added correctly by attempting to use the GetApiHash method from the Generic class of the DInvoke.DynamicInvoke namespace.\n\nNo errors indicates we are all set up and can begin playing around with D/Invoke!\n\nIf we do some quick analysis on the D/Invoke library, we find that the DInvoke.DynamicInvoke folder contains the main, core D/Invoke functionality. We can infer and confirm that the Native class contains Windows Native APIs, such as Nt* functions, while the Win32 class contains Win32 APIs. Interestingly, the only Win32 API included in the RastaMouse fork is (CreateRemoteThread, OpenProcess, IsWow64Process for default D/Invoke library). This begs the question: why aren’t common payload development functions like VirtualAlloc, CreateThread, and VirtualProtect included in the D/Invoke library by default?\n\nJust because the D/Invoke library and dinvoke.net don’t include functions that we just mentioned such as , , and does not mean we can’t use them. In fact, we can create these delegates ourselves since we know the function prototypes and can actually just port them over from the P/Invoke library. You can think of a delegate as a pointer to a function, allowing us to pass methods as arguments to other methods. This is how we can perform dynamic address lookups for relevant Windows APIs and pass the function prototype parameters. This concept, Native interoperability, is required because we are working with unmanaged code (Win32 APIs) from a managed language in C# and .NET. An explanation for this can be found here.\n\nTo start, we’ll add our Win32 APIs to the DInvoke.DynamicInvoke.Win32 class. To add an API, we’ll need to create a method and a corresponding delegate. The delegate is essentially the function prototype that we are used to seeing, which we can grab straight from P/Invoke. P/Invoke defines the C# signature of VirtualAlloc as:\n\nIt stands to assume that we can create a delegate with the exact same arguments.\n\nWe are using the calling convention since it is used to call Win32 API functions in C#.\n\nOnce we have the delegate set up, we’ll need to create a managed wrapper method that will be called when we want to use the Win32 API.\n\nThe delegate, which is the delegate we created that houses the function prototype for VirtualAlloc, is passed to DInvoke.DynamicInvoke.Generic.DynamicApiInvoke, which performs a dynamic lookup of VirtualAlloc, grabs the pointer to VirtualAlloc, and passes it to DInvoke.DynamicInvoke.Generic.DynamicFunctionInvoke, where the function wrapped by the delegate is invoked along with the parameters that were passed.\n\nHere is what our Win32 wrapper class looks like:\n\nIf we did everything correctly, we should be able to call VirtualAlloc without any errors like so:\n\nNice! We can now replicate the above steps for and .\n\nWe can call the functions like so:\n\nTo test our code, we can use the Metasploit messagebox payload so we won’t have to stand up a C2 framework for testing purposes.\n\nAlternatively you can copy this byte array here:\n\nNote that since we’re going through a proof of concept on how to utilize D/Invoke, we’re testing our payload with Defender off and using unobfuscated shellcode. Be sure after this to implement some sort of obfuscation to your payload to bypass AV!\n\nWhen attempting to build this solution, we may run into architecture errors.\n\nWe can change the language version to the latest (10 at the time of this writing) by unloading the project, editing the project file, changing LangVersion to 10.0, and reloading the project.\n\nNow we can build the solution, and when we execute it, we see message box popping up!\n\nNow that we effectively recreated a basic C# payload, which uses D/Invoke rather than P/Invoke, let us analyze the differences between the two.\n\nIn order to compare the differences between P/Invoke and D/Invoke, we need a valid P/invoke call, so we will use P/Invoke to import the VirtualAlloc API and include a call to VirtualAlloc, storing the resulting memory address in the parameter. Our D/Invoke call will still point to the parameter. We’ll also print these addresses to the console so we can perform searches on them.\n\nNow that our payload includes both a P/Invoke and D/Invoke call, we can execute it within API Monitor, a free tool that identifies all API calls made within the process. When configuring API monitor, we want to “hook” kernel32.dll to observe the API calls.\n\nWe can to go the API Filter box in the top left, search for kernel32.dll, and check all the categories.\n\nIn the Monitored Process window, we can click Monitor New Process and attach our EXE, using the Remote Thread Attach method.\n\nWe can see our messagebox has popped, the command prompt output gives us pointers to memory addresses that VirtualAlloc has created, and the Summary window in API monitor has been populated.\n\nWe can use the console printed addresses and search for the memory address in the Summary window. Let’s start with the P/Invoke address first.\n\nKeep in mind we are looking for a VirtualAlloc API call with the set to the size of your buffer (in my case 294) as well as set to .\n\nWe can see clearly here that API monitor picks up our P/Invoke VirtualAlloc API call.\n\nLet’s perform the same search with the D/Invoke address. After we replace the “Find what” value and keep clicking through “Find next,” we aren’t able to find any VirtualAlloc API call with a size of 294.\n\nThis confirms that the usage of D/Invoke aids in bypassing AV and EDR tools that monitor suspicious API calls. Let’s also take a look at the PE headers.\n\nWhen executables are built and code is compiled, the result is a Portable Executable (PE), which follows the PE file format. The PE format consists of many different structures and headers, but generally follows the same format between each executable. The aforementioned IAT is one such section of the PE format which is used by the Windows loader to locate DLLs and functions and update the executable with the corresponding addresses. This is apparent in native Window’s applications like calc.exe.\n\nHowever, a .NET executable works a little bit differently. First off, the advantage of using .NET framework and creating .NET executables is usage of the Common Language Runtime (CLR) and access to class libraries included in the framework. In addition, while the compiled .NET executable also follows the PE format, the structures are slightly different. When a .NET program is compiled with a C# compiler, the result is a managed module. A managed module (which is a standard PE file) also contains a CLR header, metadata tables, and IL code. When a .NET program is executed, the Windows loader calls the function from mscoree.dll, which initializes the CLR, checks the CLR header for the managed entry point, and begins execution. The CLR, once loaded, takes care of execution, looking at the Metadata tables and compiling IL code into native CPU instructions. Because of this, a .NET executable won’t have an IAT.\n\nGoing back to native Window’s applications, we can understand that the lack of CLR means the Windows loader must walk through the entire PE format, which includes the data directories containing the IAT.\n\nThe following image from MSDN shows how .NET programs with P/Invoke use Metadata to locate exported functions.\n\nWithin the .NET metadata, there are 45 tables containing various amounts of information.\n\nThe table is particularly interesting:\n\nThis is where our P/Invoke import can be seen, and is likely to be inspected by EDR upon knowledge that our application is a .NET executable.\n\nNow that we understand the differences between Native and .NET executables with regards to the PE format, let’s analyze and see those differences in realtime. We will use CFF explorer, a PE editor, to take a look at the PE between our .NET executable and a native Windows executable.\n\nFirst, looking at the native calc.exe application, we can see the Import Directory folder, with the kernel32.dll imported and the relevant Windows APIs below.\n\nNow let’s take a look at our .NET application. We see the lack of an Import Directory folder, but the inclusion of a .NET directory folder containing the various metadata tables. In the table, we see the one P/Invoke API that we included in our code. But more importantly, we do not see the D/Invoke APIs here.\n\nWhile these changes will help attacking several AV/EDR solutions, it might not bypass all types of API hooking, since API hooks placed on kernel32.dll may still detect suspicious use of API calls. To improve our payload, we can look into Manual Mapping.\n\nManual mapping can help us avoid API hooking. We can begin by mapping of fresh copy of kernel32.dll, so that if there are any hooks placed on originally loaded kernel32.dll, we call VirtualAlloc, CreateThread, and WaitForSingleObject from within our manually mapped kernel32.dll.\n\nTo do this, we’ll create a object containing the kernel32.dll from disk.\n\nD/Invoke offers us a couple of options for manual mapping:\n\nWe can see here that the D/Invoke function here is slightly different, as instead of calling DynamicAPIInvoke (which locates the function pointer to the API through GetLibraryAddress), uses GetExportAddress (which uses the base address of the manually mapped kernel32.dll).\n\nIn the Native class of the main DInvoke.DynamicInvoke namespace, we see comments about how the Delegates structure must be public so they may be used with DynamicFunctionInvoke. Since that is exactly what we will be using, we must change the Delegates structure in our Win32 class to be Public.\n\nBefore we call the function we’ll need to create an object array for the parameters we want to pass to DynamicFunctionInvoke. We can take advantage of the built in structures that are included in the D/Invoke library.\n\nreturns an object, so we’ll need to cast it to an IntPtr (the VirtualAlloc expected return type).\n\nFrom here, we can comment out our original VirtualAlloc call, build and run our payload, and pop a messagebox.\n\nWe should be able to follow the same process for and . Make sure you call before executing CreateThread otherwise you’re not going to be executing anything!\n\nLet’s take a step back and replace our D/Invoke call with P/Invoke and see what happens in API Monitor. I can simply comment out my D/Invoke call, import P/Invoke’s VirtualAlloc, and replace the variable with a VirtualAlloc call.\n\nOnce it’s replaced, we can compile it. In API Monitor, we were previously only monitoring kernel32.dll. Let’s also monitor ntdll.dll this time by searching for it in the API filter and checking all the categories under ntdll.dll.\n\nNow when we execute our test payload in API Monitor, we can once again search for the the VirtualAlloc call with a size of our payload and permissions.\n\nNow that we’re Monitoring kernel32.dll and ntdll.dll exported APIs, we see something interesting here.\n\nThis VirtualAlloc call is the one from our payload, has a of 294, and has permissions. We also see an underlying ntdll.dll call, .\n\nWe can look into the parameters of NtAllocateVirtualMemory to confirm this is a result of our VirtualAlloc code.\n\nA little sidebar here to explain why it works this way. There are 4 different privilege levels, known as rings, that control access to memory and CPU operations. Ring 0 (kernel mode) is most privileged, ring 3 (user mode) is least privileged. A majority of user activity occurs in Ring 3, but applications may cross into Ring 0 when calling variety of APIs (think accessing file system). User applications generally call high-level APIs (kernel32, user32) and those APIs will call low-level APIs (ntdll). Ntdll.dll is considered a “bridge” between user land and kernel land because Nt* functions exported from ntdll.dll are essentially wrappers for system calls (syscall). Syscalls are how a program requests a service from the kernel and are essentially what our code is executing. The following diagram outlines user land and kernel land:\n\nAnd an Nt* function merely acting as a wrapper for a syscall is shown in this unassembled NtAllocateVirtualMemory call:\n\nIn this example, the syscall number (18h) is pushed to the EAX register (function return value). A syscall is then invoked, requesting the kernel to allocate memory.\n\nSince NtAllocateVirtualMemory is an ntdll.dll function, it stands to assume that manually mapping kernel32.dll may bypass any EDR using kernel32.dll API hooks. But if an EDR hooks ntdll.dll (which is extremely common and considered the norm nowadays), even if our VirtualAlloc call may be undetected, we will still get caught by the underlying NtAllocateVirtualMemory call. Since we’re not actually programming this call ourselves manually in the payload, even if we were to manually map ntdll.dll into our payload, there’s no way for us to control this API call.\n\nWe can see this concept come to fruition even if we were replace this P/Invoke call with our manually mapped VirtualAlloc call. For this, we can use Frida. Frida is a Python module that allows us to hook many common runtimes including .NET and allows us to customize how we want to interpret function arguments and return values in JavaScript. To install it on our Windows development box, just ensure Python is installed.\n\nYou may need to add Python to your PATH, in which afterwards, you may invoke Frida like so:\n\nTo let Frida hook into our application, we’ll add a couple lines of code that outputs the process ID (which must be passed to Frida) as well as a simple pause in our application, that resumes upon user input.\n\nWe’ll add this to the beginning of the Main() method.\n\nFrom here, we can compile the application and run it, taking note of the process ID. In another command prompt, we can pass the process ID to Frida, and tell it to hook ntdll.dll and monitor any NtAllocateVirtualMemory API calls.\n\nWe can see a JavaScript handler file created for NtAllocateVirtualMemory, which by default, does not give us all the information we need. At this point, we can browse to that JS file and edit it like so:\n\nWhen the application is about to call NtAllocateVirtualMemory, Frida calls the function, which will store the value for the arguments of NtAllocateVirtualMemory. When returning from the call, the onLeave function is executed, which will log the respective values stored during the API call.\n\nNote that the function prototype of NtAllocateVirtualMemory is slightly different than VirtualAlloc, with the parameter to be a pointer to a variable that stores the size, rather than the actual size itself. For this reason, we add the variable, that reads the value in the pointer variable stored by RegionSize . Since there are numerous NtAllocateVirtualMemory calls, this will aid in identifying if our malicious call is detected. To further help identification, we’ve added a comparison between the RegionValue and a hard-coded value of the hexadecimal representation of the length of our byte array, which will output three DETECTED’s if matched.\n\nFrida hooks are updated as soon as the handler files are saved, so we can press any key in our payload to continue. Since there’s a lot of output, it’d probably be easier to copy the output and paste it all in a text editor.\n\nNow that we know that Nt* functions will be called, as well as the abundance of EDR’s that hook ntdll.dll rather than kernel32.dll, we can turn to RastaMouse’s dinvoke.net to assist us. Dinvoke.net provides us examples of how to use APIs with generic D/Invoke and syscalls (which we will use later), but not with manually mapping. Still these examples can help us build out our payload.\n\nWe’ll first reuse the MapModuleToMemory method to map a fresh copy of ntdll.dll. We’ll declare a uint variable and set it to 1. This status variable equates to the NTSTATUS result of an API call, with a value of 0 equal to success.\n\nNext, we declare an variable, which will be a pointer to our allocated memory.\n\nFrom here, we’ll create the parameters for and call NtAllocateVirtualMemory, which is very similar to VirtualAlloc with the addition of specifying a process handle.\n\nThe documentation states that the macro should be used, which can’t be accessed in C#. NtCurrentProcess and ZwCurrentProcess, which are essentially the same, returns a handle to the current process.\n\nIf we take a look at the function documentation, it “retrieves a pseudo handle for the current process… A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle.” It stands to reason that we can pass this value as an IntPtr as a parameter for NtAllocateVirtualMemory. In fact, we can see that D/Invoke already uses this concept.\n\nAnother difference between VirtualAlloc and NtAllocateVirtualMemory is the output and return type. Kernel32.dll exported APIs will usually have their own return type. However, most Nt* APIs will have the NTSTATUS return type. With VirtualAlloc, the pointer to the newly allocated memory is the default API return, stored as . But for NtAllocateVirtualMemory, the return type is NTSTATUS, and the newly allocated memory address pointer is actually set to the parameter. So in order to grab the memory address value, we will set the addr variable to the baseAddress parameter by accessing the second index of the parameter object array.\n\nWe can then use the same method to copy our buffer to the newly created memory address. We can use Marshal.Copy here since we are within a single process. On the flip side, if we were attempting to build an injection payload such as DLL injection, process injection, or process hollowing, we would need to use instead.\n\nWe then follow a similar process for using . To do so, we’ll just pass the current process handle value as the fourth parameter of NtCreateThreadEx. Just like our NtAllocateVirtualMemory call, we’ll need to grab the handle to the thread we created (tHandle).\n\nTo keep our shellcode alive, we will use , which isn’t included in D/Invoke since the default library is focused on process injection techniques, where existing processes won’t terminate after the shellcode is run. Similar to what we’ve done with Win32 APIs, we can add a NtWaitForSingleObject delegate in the Delegates structure of the DInvoke.DynamicInvoke.Native namespace. Luckily, the function prototype exists on MSDN, so we can easily create our delegate like so.\n\nFor the parameters, we can simply supply a handle to the thread (tHandle), and supply IntPtr.Zero as the timeout, as a null value will result in an infinite timeout. Our newly written Nt* function code is shown below:\n\nLastly, we’ll talk about syscalls. As mentioned previously, Nt* functions are essentially wrapers for syscalls. Since D/Invoke supports syscalls, we can directly call assembly instructions without having to go through any Windows API calls, which will bypass any hooks placed on userland APIs. Dinvoke.net provides a general idea of how to invoke syscalls. The only changes we’ll make here is using the explicit uint type for status. We can simply copy the parameters we used for the Nt* manual map APIs. The very short syscall code is shown here:\n\nPutting It All Together\n\nFrom the looks of it, syscalls appear to be the preferred method of invoking Windows APIs, and while it may generally be true, D/Invoke syscalls have certain limitations such as not being able to work in WOW64 processes. Of course, having multiple methods at your disposable means you’ll have more flexibility when it comes to dealing with different types of EDR solutions.\n\nI learned a lot about Windows internals as I was writing this, and hopefully you all have learned a lot as well. The examples shown here aren’t the end though, you’ll still need to create obfuscation and encryption of shellcode to bypass static analysis. Consider creating DLL injection, process injection, process hollowing, etc. payloads, adjusting the necessary parameters and using the appropriate APIs (such as using NtWriteVirtualMemory instead of Marshal.Copy). There are also functions within the D/Invoke library that we have not used in our examples to further obfuscate our code. For example, using within the Generic class can help with static analysis, as performing a dumpbin of our application will reveal the static strings of the malicious APIs we used. Another benefit of knowing how to manually setup D/Invoke into your projects is ease of incorporating these techniques into LOLBINS/LOLBAS applications, which can be helpful in bypassing Machine Learning."
    },
    {
        "link": "https://visualstudiomagazine.com/articles/2010/11/18/multithreading-in-winforms.aspx",
        "document": "The .NET Framework has full support for running multiple threads at once. In this article, Patrick Steele looks at how threads accomplish their task and why you need to be careful how you manage a WinForms application with multiple threads.\n\nA user interface that is unresponsive will frustrate your users. If it goes on for too long, they bring up Task Manager and see the dreaded \"(Not Responding)\" next to your application. Out of frustration, they click the \"End Process\" button, kill your application and start from the beginning.\n\nBut this doesn't have to happen. The .NET Framework has full support for running multiple threads at once. In this article, we'll look at how threads accomplish their task and why you need to be careful how you manage a WinForms application with multiple threads.\n\nThread Basics\n\n A thread is the basic unit of which an operating system uses to execute code. Every process that is started uses at least one thread. For .NET applications, the framework will spin up a couple of threads for housekeeping (garbage collection, finalization queue, etc...) and then one thread for the AppDomain. A .NET process can have multiple AppDomains and an AppDomain supports multiple threads. For this discussion, we're just concerned about the one thread that gets our application running.\n\nWhen running this application, the .NET Framework creates a new AppDomain with a single thread. That thread is then instructed to start running code at the \"Main\" method. The first thing it does is writes our \"hello\" message to the console. After that, it calls the ReadKey method. This waits for the user to press any key. This is called a \"blocking operation\" since the thread is blocked and can't do anything until a key is pressed. The blocking happens somewhere deep inside the call to ReadKey (because that's where our thread is running code). Once a key is pressed, the thread is done and the application exits.\n\nSome Multithreading\n\n Let's add a little bit of multithreading to our console application:\n\nLet's take a step by step approach to see what is going on:\n• Our first (and currently only) thread starts at the Main() method.\n• The first thread jumps to the StartCounting method.\n• A new thread object is created and points to a lambda (anonymous delegate) as the code it should execute.\n• The first thread then starts up the second thread (The second thread is simply a loop that prints the numbers 0 through 9 with a one second pause between each number).\n• StartCounting is done and the first thread returns to the Main method.\n• The first thread calls ReadKey() and is blocked.\n• The second thread was started in step 5 continues to output the numbers 0 through 9 as our first thread is blocked.\n• Our second thread blocks itself from time to time by executing the Thread.Sleep(1000), but this affects only the second thread.\n• When the user presses a key, the first thread continues on to the WriteLine and then it is done.\n• The second thread will continue to output the numbers 0 through 9. When the loop completes, the second thread is done.\n• Once both threads are done, the application exits.\n\nRun this code and play around with it. Note that if you press a key before the second thread is done counting to 9, you'll see the \"Exiting...\" message, but the numbers continue to print even though the Main method's thread has exited. That's because the second thread is a foreground thread.\n\nAll threads behave the same way and all threads are defined as either a foreground thread (the default) or a background thread. The only difference is how the .NET runtime treats them. A .NET application won't exit until all foreground threads have completed. In our example, the second thread is a foreground thread and therefore, the counting will continue even though the Main thread for the application has ended.\n\nIf you want to see the difference a background thread makes, we can mark the second thread as a background thread by calling:\n\nRight before we start the thread at \"thread.Start()\". Now if you run the application, you'll notice that a key press during the second thread's counting will end the application. Since the first thread is the only foreground thread, the .NET Framework will end the application (and stop all background threads) as soon as the Main method exits.\n\nWinForms and the Message Pump\n\n Windows applications (either WinForms in .NET, or C/C++ applications) are driven by messages being sent to them from the operating system. The OS will tell you when:\n• The left mouse button is pushed down.\n\nHow is all of this messaging coordinated in your application? The messages are placed in a FIFO (first in, first out) queue and your application pulls them out one by one and processes them. At the heart of almost every windows application is code that looks basically like this (simplified pseudo-code):\n\nThis is called the message pump. What this code does is monitor the Windows message queue. When a message appears, it pulls the message and dispatches it to your application. Dispatching means it looks to see if you have an event handler set up for the particular message. When the user clicks on a button, the .NET Framework will determine which button was clicked and if you have an event handler subscribed for the \"Click\" event of the button. If so, the framework then calls your event handler and your code is executed.\n\nThis message pump handles messages for your entire application. Every control on all of your forms can have a message sent to it (a message to paint itself, a message to scroll, etc...). All of these messages get dispatched via this message pump.\n\nIf you look at a basic WinForms application in C#, you'll notice the Main() method found in Program.cs has the following code:\n\nThe very last line of code is a call to Application.Run(). This is a .NET Framework method and it encapsulates the Windows message pump I just described. The form passed to the method is considered the \"main\" form for your application. Once that form is closed, the message pump exits, the thread comes back to Main where there is nothing left to do and the program exits.\n\nA Non-Responsive UI\n\n Now that we know what is going on, let's revisit the situation that I described at the beginning of this article:\n\nA user interface that is unresponsive will frustrate your users. If it goes on for too long, they bring up Task Manager and see the dreaded \"(Not Responding)\" next to your application. Out of frustration, they click the \"End Process\" button, kill your application and start from the beginning.\n\nWhy does your UI become unresponsive? Why does task manager display a \"(Not Responding)\" message next to your application? Let's look at what happens when an event handler contains something like this:\n\nObviously this is a contrived example of some code that takes 20 seconds to complete -- it's only a simulation.\n\nIf we consider that the .NET Framework started a single thread, executed the code in Main and is currently sitting inside the message pump processing messages from the operating system:\n• The user moves the mouse and clicks on \"button1\".\n• The message loop sees a message in the queue and pulls it out. In reality, there were hundreds of messages pouring into the queue as the user moved the mouse, but we don't have any event handlers set up so they were pulled out of the queue and discarded .\n• The message is examined and determined to be a click on \"button1\".\n• The .NET Framework sees that you have an event handler subscribed to button1's click event.\n• The thread now jumps into your code for the click event handler.\n• The thread is now doing something that keeps it busy. In our example, it's sleeping for 20 seconds. In reality, it could be an extensive database operation, a Web service call, whatever.\n• During those 20 seconds, the user starts up Outlook to check their email. Your form is covered by Outlook.\n• The user minimizes Outlook to return to your application. Since your form was previously covered by Outlook but is now visible, it needs to be redrawn so the operating system puts a redraw message into your queue.\n• 20 seconds isn't up yet so the thread is still executing your event handler. It's not processing the message loop so the redraw that just got sent isn't being processed. And the user is shaking the mouse in an attempt to \"wake up\" your application (c'mon -- we all do this sometimes). This generates a bunch of mouse move messages that get pushed into the queue.\n• The 20 seconds still hasn't elapsed (i.e. your event handler is still working), but the user is getting frustrated. They go into Task Manager to see what is happening.\n• Windows notices that your message queue is getting quite full and that your application hasn't pulled anything out of the queue recently. It assumes your application has hung and adds that nasty \"Not Responding\" next to your application.\n\nAt this point, two things will happen. The user will be patient and eventually, your event handler finishes. The thread returns back to the message loop and all of those messages that have been backing up are processed. The app becomes responsive again and the user is happy, but annoyed. The other possibility is that the user, while in Task Manager, kills your app and starts over thinking your app just hung. This could cause a loss of work and loss of confidence in your application's stability.\n\nMultithreading in WinForms\n\n So let's do a similar multithreaded counter like we did in our console application. Instead of outputting the digits 0-9 to the console, we'll put them in a textbox. We'll start the counting when the user clicks on a button. Here's the \"click\" event which will start up a second thread and then allow the first thread to return to the message loop:\n\nNotice that we made the thread a background thread. We don't want this thread to prevent the application from ending so we've changed it to a background thread.\n\nRun the code and click on the button. What? You got an exception?\n\nWhat is happening? The .NET Framework is helping you identify your mistake. The textbox was created on the \"main\" thread (the one that is running the message pump). At this point in the code, when we're trying to update the Textbox's Text property, we're running on a different thread. Updating WinForms controls from background threads is not allowed as it can cause many issues -- not the least of which is that the thread we're running on does not have a message pump running! Without the message pump, the update of the property (which happens via a Windows message), would never be processed in this thread. If you've written code like this before in .NET Framework 1.x, you didn't get this exception. It's a new exception introduced in 2.0 to help you identify this scenario of cross-thread operations.\n\nSo now we need to somehow get the textbox update to be performed on the main thread. WinForms helps us out by providing an \"Invoke\" method on all Control-derived classes which will take a delegate and will marshal that delegate to the main thread (where our message pump is).\n\nHere's an update to our code for updating the textbox:\n\nFirst, we define a separate delegate for displaying our count. The next change is inside the for loop. Instead of directly updating the Text property, we using TextBox1's Invoke method and give it a delegate. That delegate will be marshaled to the main thread and executed there via the message pump. Run this code and you'll see that we can move the form, resize it and do other things and the form stays responsive while the background thread runs. You'll also notice that if you close the form before the second thread has counted to 9, the application will exit.\n\nMultithreaded Complexity\n\n Another thing you might have noticed is that if you click the button multiple times, multiple threads are started and you'll get a mingling of updates in the textbox as each thread is running the for loop. We can prevent this by disabling the start button as soon as the second thread is started:"
    },
    {
        "link": "https://stackoverflow.com/questions/28614490/multi-threading-c-sharp-windows-forms",
        "document": "So I am trying to implement multi-threading in my windows forms project. I know of one way to do this, by creating a new thread for the methods you want to run separately like this:\n\nAnd then invoking each object that is \"Accessed from a thread other than the thread it was created on.\" like this:\n\nThe only problem with this is, my program is several thousand lines long, and I make the references all the time. So putting a method invoker around every little thing I want to change in another thread seems horribly inefficient and Im sure there is a better way but I cant seem to find it online so I figured why not ask you guys.\n\nIs there something I can say at the beginning of the method that will automatically delegate objects if they are referenced outside the thread? Because if there isnt another way, my code is probably going to turn out real messy and hard to read. :(\n\nEdit: Here is a larger chunk of the code, maybe it will make this a bit clearer:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/troubleshoot/developer/visualstudio/csharp/language-compilers/create-thread",
        "document": "Use Visual C# to create a thread\n\nYou can write multithreaded applications in Microsoft Visual C# .NET or in Visual C#. This article describes how a simple Visual C# application can create and manage threads.\n\nThe following list outlines the recommended hardware, software, network infrastructure, and service packs that you need:\n• Visual C# .NET or Visual C#\n\nThis article assumes that you are familiar with the following topics:\n\nThis article refers to the .NET Framework Class Library namespace .\n• None Add a Button control to the form. By default, the button is named Button1.\n• None Add a ProgressBar component to the form. By default, the progress bar is named ProgressBar1.\n• None Right-click the form, and then click View Code.\n• None Add the following statement to the beginning of the file:\n• None Add the following event handler for Button1:\n• None Add the following variable to the class:\n• None Add the following method to the class: private void ThreadTask () { int stp; int newval; Random rnd = new Random (); while (true) { stp = this.progressBar1.Step * rnd.Next (-1, 2); newval = this.progressBar1.Value + stp; if (newval > this.progressBar1.Maximum) newval = this.progressBar1.Maximum; else if (newval < this.progressBar1.Minimum) newval = this.progressBar1.Minimum; this.progressBar1.Value = newval; Thread.Sleep (100); } } This is the code that underlies the thread. This code is an infinite loop that randomly increments or decrements the value in ProgressBar1, and then waits 100 milliseconds before it continues.\n• None Add the following event handler for Form1. This code creates a new thread, makes the thread a background thread, and then starts the thread.\n• None Build and run the application. Notice that the value in ProgressBar1 changes randomly. This is the new thread in operation.\n• None To demonstrate that the main thread is independent of the thread that changes the value of ProgressBar1, click the button on the form. You receive a dialog box with the following error message: This is the main thread\n\nWait for input. Notice that the value in ProgressBar1continues to change.\n\nIn more complex applications, make sure that you synchronize multiple threads when you access shared variables. For more information, see the lock statement and related topics in the Visual C# .NET online help documentation.\n\nFor more information, see Thread Class."
    },
    {
        "link": "https://stackoverflow.com/questions/73407366/how-to-manage-threads-in-multithreaded-application-that-opens-160-windows-in-fou",
        "document": "I have a Windows Forms application which uses around 200 threads and 160 of them are Forms threads.\n\nI am gathering data into application with TCP connection, I enqueue the messages into many s with a single thread. 40 other threads lets call them readerThreads are checking if there is any item in their queue and dequeue the message, and process into forms. Form threads processes their own queues and show the data.\n\nOne readerThread(threadA) in particular is processing the 90% of the messages from his . So when live data starts to accumulate so fast, is swelled up and Application is starting to lag.\n\nSo I want to give a higher priority than others, and also I think I am losing so much time while OS changes between the threads so I want to let threadA run with everything OS can offer while queueA is getting dequeued. Currently I am using for every thread and not using any thread pool. I know it is not wise and want to change it to something better.\n\nFirstly, can using on help me at this issue and secondly, what can you offer instead of using . Any example would be very helpful."
    },
    {
        "link": "https://visualstudiomagazine.com/Articles/2010/11/18/Multithreading-in-WinForms.aspx",
        "document": "The .NET Framework has full support for running multiple threads at once. In this article, Patrick Steele looks at how threads accomplish their task and why you need to be careful how you manage a WinForms application with multiple threads.\n\nA user interface that is unresponsive will frustrate your users. If it goes on for too long, they bring up Task Manager and see the dreaded \"(Not Responding)\" next to your application. Out of frustration, they click the \"End Process\" button, kill your application and start from the beginning.\n\nBut this doesn't have to happen. The .NET Framework has full support for running multiple threads at once. In this article, we'll look at how threads accomplish their task and why you need to be careful how you manage a WinForms application with multiple threads.\n\nThread Basics\n\n A thread is the basic unit of which an operating system uses to execute code. Every process that is started uses at least one thread. For .NET applications, the framework will spin up a couple of threads for housekeeping (garbage collection, finalization queue, etc...) and then one thread for the AppDomain. A .NET process can have multiple AppDomains and an AppDomain supports multiple threads. For this discussion, we're just concerned about the one thread that gets our application running.\n\nWhen running this application, the .NET Framework creates a new AppDomain with a single thread. That thread is then instructed to start running code at the \"Main\" method. The first thing it does is writes our \"hello\" message to the console. After that, it calls the ReadKey method. This waits for the user to press any key. This is called a \"blocking operation\" since the thread is blocked and can't do anything until a key is pressed. The blocking happens somewhere deep inside the call to ReadKey (because that's where our thread is running code). Once a key is pressed, the thread is done and the application exits.\n\nSome Multithreading\n\n Let's add a little bit of multithreading to our console application:\n\nLet's take a step by step approach to see what is going on:\n• Our first (and currently only) thread starts at the Main() method.\n• The first thread jumps to the StartCounting method.\n• A new thread object is created and points to a lambda (anonymous delegate) as the code it should execute.\n• The first thread then starts up the second thread (The second thread is simply a loop that prints the numbers 0 through 9 with a one second pause between each number).\n• StartCounting is done and the first thread returns to the Main method.\n• The first thread calls ReadKey() and is blocked.\n• The second thread was started in step 5 continues to output the numbers 0 through 9 as our first thread is blocked.\n• Our second thread blocks itself from time to time by executing the Thread.Sleep(1000), but this affects only the second thread.\n• When the user presses a key, the first thread continues on to the WriteLine and then it is done.\n• The second thread will continue to output the numbers 0 through 9. When the loop completes, the second thread is done.\n• Once both threads are done, the application exits.\n\nRun this code and play around with it. Note that if you press a key before the second thread is done counting to 9, you'll see the \"Exiting...\" message, but the numbers continue to print even though the Main method's thread has exited. That's because the second thread is a foreground thread.\n\nAll threads behave the same way and all threads are defined as either a foreground thread (the default) or a background thread. The only difference is how the .NET runtime treats them. A .NET application won't exit until all foreground threads have completed. In our example, the second thread is a foreground thread and therefore, the counting will continue even though the Main thread for the application has ended.\n\nIf you want to see the difference a background thread makes, we can mark the second thread as a background thread by calling:\n\nRight before we start the thread at \"thread.Start()\". Now if you run the application, you'll notice that a key press during the second thread's counting will end the application. Since the first thread is the only foreground thread, the .NET Framework will end the application (and stop all background threads) as soon as the Main method exits.\n\nWinForms and the Message Pump\n\n Windows applications (either WinForms in .NET, or C/C++ applications) are driven by messages being sent to them from the operating system. The OS will tell you when:\n• The left mouse button is pushed down.\n\nHow is all of this messaging coordinated in your application? The messages are placed in a FIFO (first in, first out) queue and your application pulls them out one by one and processes them. At the heart of almost every windows application is code that looks basically like this (simplified pseudo-code):\n\nThis is called the message pump. What this code does is monitor the Windows message queue. When a message appears, it pulls the message and dispatches it to your application. Dispatching means it looks to see if you have an event handler set up for the particular message. When the user clicks on a button, the .NET Framework will determine which button was clicked and if you have an event handler subscribed for the \"Click\" event of the button. If so, the framework then calls your event handler and your code is executed.\n\nThis message pump handles messages for your entire application. Every control on all of your forms can have a message sent to it (a message to paint itself, a message to scroll, etc...). All of these messages get dispatched via this message pump.\n\nIf you look at a basic WinForms application in C#, you'll notice the Main() method found in Program.cs has the following code:\n\nThe very last line of code is a call to Application.Run(). This is a .NET Framework method and it encapsulates the Windows message pump I just described. The form passed to the method is considered the \"main\" form for your application. Once that form is closed, the message pump exits, the thread comes back to Main where there is nothing left to do and the program exits.\n\nA Non-Responsive UI\n\n Now that we know what is going on, let's revisit the situation that I described at the beginning of this article:\n\nA user interface that is unresponsive will frustrate your users. If it goes on for too long, they bring up Task Manager and see the dreaded \"(Not Responding)\" next to your application. Out of frustration, they click the \"End Process\" button, kill your application and start from the beginning.\n\nWhy does your UI become unresponsive? Why does task manager display a \"(Not Responding)\" message next to your application? Let's look at what happens when an event handler contains something like this:\n\nObviously this is a contrived example of some code that takes 20 seconds to complete -- it's only a simulation.\n\nIf we consider that the .NET Framework started a single thread, executed the code in Main and is currently sitting inside the message pump processing messages from the operating system:\n• The user moves the mouse and clicks on \"button1\".\n• The message loop sees a message in the queue and pulls it out. In reality, there were hundreds of messages pouring into the queue as the user moved the mouse, but we don't have any event handlers set up so they were pulled out of the queue and discarded .\n• The message is examined and determined to be a click on \"button1\".\n• The .NET Framework sees that you have an event handler subscribed to button1's click event.\n• The thread now jumps into your code for the click event handler.\n• The thread is now doing something that keeps it busy. In our example, it's sleeping for 20 seconds. In reality, it could be an extensive database operation, a Web service call, whatever.\n• During those 20 seconds, the user starts up Outlook to check their email. Your form is covered by Outlook.\n• The user minimizes Outlook to return to your application. Since your form was previously covered by Outlook but is now visible, it needs to be redrawn so the operating system puts a redraw message into your queue.\n• 20 seconds isn't up yet so the thread is still executing your event handler. It's not processing the message loop so the redraw that just got sent isn't being processed. And the user is shaking the mouse in an attempt to \"wake up\" your application (c'mon -- we all do this sometimes). This generates a bunch of mouse move messages that get pushed into the queue.\n• The 20 seconds still hasn't elapsed (i.e. your event handler is still working), but the user is getting frustrated. They go into Task Manager to see what is happening.\n• Windows notices that your message queue is getting quite full and that your application hasn't pulled anything out of the queue recently. It assumes your application has hung and adds that nasty \"Not Responding\" next to your application.\n\nAt this point, two things will happen. The user will be patient and eventually, your event handler finishes. The thread returns back to the message loop and all of those messages that have been backing up are processed. The app becomes responsive again and the user is happy, but annoyed. The other possibility is that the user, while in Task Manager, kills your app and starts over thinking your app just hung. This could cause a loss of work and loss of confidence in your application's stability.\n\nMultithreading in WinForms\n\n So let's do a similar multithreaded counter like we did in our console application. Instead of outputting the digits 0-9 to the console, we'll put them in a textbox. We'll start the counting when the user clicks on a button. Here's the \"click\" event which will start up a second thread and then allow the first thread to return to the message loop:\n\nNotice that we made the thread a background thread. We don't want this thread to prevent the application from ending so we've changed it to a background thread.\n\nRun the code and click on the button. What? You got an exception?\n\nWhat is happening? The .NET Framework is helping you identify your mistake. The textbox was created on the \"main\" thread (the one that is running the message pump). At this point in the code, when we're trying to update the Textbox's Text property, we're running on a different thread. Updating WinForms controls from background threads is not allowed as it can cause many issues -- not the least of which is that the thread we're running on does not have a message pump running! Without the message pump, the update of the property (which happens via a Windows message), would never be processed in this thread. If you've written code like this before in .NET Framework 1.x, you didn't get this exception. It's a new exception introduced in 2.0 to help you identify this scenario of cross-thread operations.\n\nSo now we need to somehow get the textbox update to be performed on the main thread. WinForms helps us out by providing an \"Invoke\" method on all Control-derived classes which will take a delegate and will marshal that delegate to the main thread (where our message pump is).\n\nHere's an update to our code for updating the textbox:\n\nFirst, we define a separate delegate for displaying our count. The next change is inside the for loop. Instead of directly updating the Text property, we using TextBox1's Invoke method and give it a delegate. That delegate will be marshaled to the main thread and executed there via the message pump. Run this code and you'll see that we can move the form, resize it and do other things and the form stays responsive while the background thread runs. You'll also notice that if you close the form before the second thread has counted to 9, the application will exit.\n\nMultithreaded Complexity\n\n Another thing you might have noticed is that if you click the button multiple times, multiple threads are started and you'll get a mingling of updates in the textbox as each thread is running the for loop. We can prevent this by disabling the start button as soon as the second thread is started:"
    }
]