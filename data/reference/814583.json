[
    {
        "link": "https://stackoverflow.com/questions/28671534/can-i-force-abstract-methods-to-be-protected-when-someone-overrides-them",
        "document": "In my abstract class, I have something like this:\n\nThe thing is, I want to force the person that extends methodIDontWantExposed() to make it protected, because I don't want the extending class to have both methodIDontWantExposed and methodIWantToExpose exposed.\n\nIs there a way to do this (or a different approach which might avoid my problem)?"
    },
    {
        "link": "https://stackoverflow.com/questions/54864818/is-it-a-good-practice-to-create-methods-inside-an-abstract-class-and-not-overrid",
        "document": "Yes, if a method is common to most expected implementations of an abstract class, it's perfectly fine to implement those methods in the abstract class. If it's really good to have getters and setters for the properties of your , it hard to say. The way you're currently using it, it doesn't make much sense, as you're mixing behavior aspects (viewIndividual) with data aspects (getters and setters) in one class. Given the code above you would be fine with protected members in the abstract class, and potentially setters to avoid code duplication in the implementations. But if you want to use your objects as Java-Beans, it's fine.\n\nYou mean both, abstract and non-abstract methods? Yes, this is pretty standard. Take this example:\n\nConsumers of implementations of will only be able to access and it is guaranteed that all needed preparations and cleanup tasks are executed without repeating this code over and over again in the implementations of as only needs to be overridden.\n\nNo, definitively not. At least as long as you don't add additional functionality to the methods, abstract methods should not be overridden just for implementing them inside the instantiatable class.\n\nIn general you should be careful with inheritance as code tends to become very hard to understand, if you implement something in a deep type hierarchy. IMHO hierarchies start to become hard to use with a hierarchy level of 4-5 already, but this is probably heavily opinion based. There is the rule to prefer composition over inheritance to avoid over-exhaustive use of inheritance for simple utility stuff."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/246351/using-abstract-methods-to-force-subclasses-to-define-values-for-member-fields",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://harsh05.medium.com/abstract-classes-vs-interfaces-in-java-when-and-how-to-use-them-5ca5d5c825b5",
        "document": "As I continue deepening my understanding of Java, I recently revisited two foundational concepts: abstract classes and interfaces. These concepts play a critical role in designing flexible, reusable, and maintainable code in object-oriented programming. Along the way, I also explored how multiple inheritance, although not directly supported in Java, can be achieved using interfaces.\n\nIn this blog, I will cover:\n• What is an Abstract Class?\n• What is an Interface, and How Does It Differ from an Abstract Class?\n• Why Java Doesn’t Support Multiple Inheritance and How Interfaces Provide a Solution?\n\n1. What is an Abstract Class?\n\nAn abstract class in Java is a class that cannot be instantiated on its own. Instead, it serves as a blueprint for other classes that extend it. Abstract classes can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation). It is typically used when you want to define common functionality for a group of subclasses, but also leave some methods for those subclasses to implement.\n• Cannot be instantiated: You cannot create an object of an abstract class directly.\n• Abstract methods: It can have abstract methods, which must be implemented by any subclass.\n• Concrete methods: It can also contain fully implemented methods, giving subclasses some default behavior.\n• Single inheritance: Like any other class, an abstract class can be extended by only one subclass at a time.\n\nIn this example, is an abstract class with one abstract method ( ) and one concrete method ( ). Any subclass, like , must implement the method.\n\n2. What is an Interface?\n\nAn interface in Java is like a contract for classes. It is a completely abstract class, meaning all of its methods are abstract (until Java 8, when default and static methods were introduced). Interfaces are used to specify behaviors that a class must implement, but they don’t provide any concrete behavior themselves.\n• All methods are abstract by default.\n• A class can implement multiple interfaces, which provides a workaround for Java’s lack of multiple inheritance.\n• Interfaces do not have instance variables, though they can have static final constants.\n\nIn this example, implements two interfaces, and . This demonstrates one of the key advantages of interfaces: multiple inheritance (which I’ll discuss in more detail below).\n\nWhile both abstract classes and interfaces help in defining the structure of a class, they have distinct differences:\n\n3. Multiple Inheritance in Java and How It Is Achieved via Interfaces\n\nJava doesn’t support multiple inheritance (a class cannot extend more than one class). This restriction exists to avoid the “diamond problem”, which arises when a class inherits from two classes that both provide different implementations of the same method. This could create ambiguity about which method to use.\n\nHowever, Java provides a solution to this problem through interfaces. Since a class can implement multiple interfaces, Java developers can achieve the functionality of multiple inheritance without its complications.\n\nWhy Multiple Inheritance Is Not Allowed in Java:\n• Ambiguity: Multiple inheritance can lead to ambiguity when two or more parent classes have methods with the same signature.\n• Complexity: The code becomes harder to maintain and debug.\n• Diamond Problem: In languages that support multiple inheritance (like C++), the “diamond problem” can occur, leading to confusion over which inherited method to execute.\n\nSince interfaces provide no method implementations (before Java 8), there’s no risk of conflicting method implementations, allowing a class to implement as many interfaces as it needs.\n\nHere, implements both and interfaces, thereby achieving multiple inheritance behavior without ambiguity.\n\nBoth abstract classes and interfaces are ways to achieve abstraction in Java, but they serve slightly different purposes.\n• Abstract classes allow you to define some default behavior while forcing subclasses to implement specific methods.\n\nWhen to Use Abstract Classes vs. Interfaces:\n• Use an abstract class when you want to share code among several closely related classes. If several classes are logically related and share common code, abstract classes are a good choice.\n• Use an interface when you want to define a common behavior across unrelated classes. Interfaces are ideal for situations where you need to ensure that a class follows a particular protocol or contract.\n\nUnderstanding the differences and nuances between abstract classes and interfaces is essential for writing flexible, maintainable Java code. While abstract classes provide a way to share common code and behavior across a hierarchy of related classes, interfaces allow us to define behavior across unrelated classes, making them a powerful tool in Java’s toolkit.\n\nJava’s lack of multiple inheritance is overcome through interfaces, which allow a class to implement multiple behaviors without the ambiguity and complexity that multiple inheritance in other languages may bring.\n\nBy mastering these concepts, you’ll be better equipped to design robust, modular applications in Java, making your code more efficient, readable, and scalable."
    },
    {
        "link": "https://reddit.com/r/java/comments/zhq3cf/are_protected_fields_really_bad_practice",
        "document": "I'm having this debate with a tutor at my uni right now. We are supposed to do a coding exercise where you have an abstract class with a bunch of subclasses. The abstract class has a few fields which are exclusively used in the subclasses. We are forced to make them private and use getters/setters which really annoys me since you could just make them protected and have much cleaner code imo. I voiced my indignation about making the fields private and was told that using protected fields was bad practice..?"
    },
    {
        "link": "https://oracle.com/technical-resources/articles/java/javadoc-tool.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/8320844/documentation-comments-subclass",
        "document": "No. The documentation applies to the implemented code only - if your class inherits a method from its base class, then the documentation is also inherited. You cannot 'override' the documentation without also providing a new implementation. (this makes sense though - if the implementation hasn't changed, then the docs don't need to change either.)\n\nIf you browse the docs in an external form or in intellisense, the docs from the base class will be displayed as required, so there is no need to redefine them in order to see the appropriate docs."
    },
    {
        "link": "https://oracle.com/pk/technical-resources/articles/java/javadoc-tool.html",
        "document": ""
    },
    {
        "link": "https://blog.joda.org/2012/11/javadoc-coding-standards.html",
        "document": "These are the standards I tend to use when writing Javadoc. Since personal tastes differ, I've tried to explain some of the rationale for some of my choices. Bear in mind that this is more about the formatting of Javadoc, than the content of Javadoc.\n\nIf a method is overridden in a subclass, Javadoc should only be present if it says something distinct to the original definition of the method. The @Override annotation should be used to indicate to source code readers that the Javadoc is inherited in addition to its normal meaning.\n\nJavadoc only requires a '/**' at the start and a '*/' at the end. In addition to this, use a single star on each additional line:\n\nJavadoc uses HTML tags to identify paragraphs and other elements. Many developers get drawn to the thought that XHTML is necessarily best, ensuring that all tags open and close correctly. This is a mistake. XHTML adds many extra tags that make the Javadoc harder to read as source code. The Javadoc parser will interpret the incomplete HTML tag soup just fine.\n\nLonger Javadoc always needs multiple paragraphs. This naturally results in a question of how and where to add the paragraph tags. Place a single <p> tag on the blank line between paragraphs:\n\nUse a single <li> tag for items in a list\n\nLists are useful in Javadoc when explaining a set of options, choices or issues. These standards place a single <li> tag at the start of the line and no closing tag. In order to get correct paragraph formatting, extra paragraph tags are required:\n\nThe first sentence, typically ended by a dot, is used in the next-level higher Javadoc. As such, it has the responsibility of summing up the method or class to readers scanning the class or package. To achieve this, the first sentence should be clear and punchy, and generally short.\n\nWhen referring to an instance of the class being documented, use \"this\" to reference it. For example, \"Returns a copy of this foo with the bar value updated\".\n\nWherever possible, make Javadoc sentences fit on a single line. Allow flexibility in the line length, favouring between 80 and 120 characters to make this work.\n\nOnly use @link on the first reference to a specific class or method. Use @code for subsequent references. This avoids excessive hyperlinks cluttering up the Javadoc.\n\nThe concepts of null, true and false are very common in Javadoc. Adding @code for every occurrence is a burden to both the reader and writer of the Javadoc and adds no real value.\n\nWhen reading the Javadoc as source code, a single space after the parameter name is a lot harder to read than two spaces. Avoid aligning the parameters in a column, as it is prone to difficulty in refactoring where parameter names are changed or added.\n\nWhile it may be tempting to define null-handling behaviour in a single central location, such as the class or package Javadoc, this is far less useful for developers. The Javadoc at the method level appears in IDEs during normal coding, whereas class or package level Javadoc requires a separate \"search and learn\" step.\n\nThe @author feature can be used to record the authors of the class. This should be avoided, as it is usually out of date, and it can promote code ownership by an individual. The source control system is in a much better position to record authors.\n\nHopefully these suggestions will help you to write better Javadoc. Feel free to disagree or point to some alternative standards."
    },
    {
        "link": "https://medium.com/@gewzk/what-is-inheritdoc-in-java-with-example-300ad5566fbc",
        "document": "In Java, inheritance is a mechanism that allows one class to inherit properties and behaviors from another class. The class that inherits is called the subclass, while the class being inherited from is the superclass.\n\nThe primary advantage of inheritance is that it allows for code reuse. Instead of rewriting the same code in multiple classes, you can define it in a superclass and then inherit it from the subclasses. This also makes the code more manageable and easier to maintain.\n\nInheritance is implemented using the extends keyword in Java. When a class extends another class, it inherits all the non-private fields and methods of the superclass. It can also override methods of the superclass to provide its own implementation.\n\nInheritance also allows for polymorphism, which is the ability of objects to take on multiple forms. This means that a subclass can be treated as an instance of its superclass. For example, if the superclass is Animal, and the subclass is Cat, you can treat the Cat object as an Animal object.\n\nWhen documenting a subclass, it’s important to also document any methods and properties that it inherits from its parent class(es). This allows users of the subclass to understand the full scope of its functionality and how it relates to its parent class(es).\n\nTo document inherited methods and properties, simply list them in the class documentation with a brief description of their functionality. It’s also helpful to include a reference to the parent class(es) from which the subclass inherits.\n\nFor example, consider the following code:\n\nWhen documenting the Dog class, it would be important to mention that it inherits the __init__() method from its parent class Animal. The __init__() method sets the name attribute of the Dog object.\n\nIt would also be important to mention that the Dog class overrides the speak() method inherited from its parent class Animal. The overridden speak() method returns the string “Woof” when called.\n\nThe @inheritDoc tag is a useful tool for documenting code. It allows you to inherit documentation from a parent class or interface, eliminating the need to duplicate documentation for overridden methods or properties.\n\nTo use @inheritDoc, simply include it in the docblock for the method or property you want to inherit documentation for. For example:\n\nIn this example, the doSomething() method in the Bar class inherits the documentation for the same method in the Foo class.\n\nUsing @inheritDoc can save time and effort when documenting code, by reducing the amount of duplicated documentation. However, it’s important to make sure that the parent class or interface has clear and accurate documentation, as this will be inherited by all child classes.\n\nExample Usage of inheritDoc in Java\n\nIn Java, the @inheritDoc tag is used in documentation comments to indicate that a method should inherit its documentation from the superclass or interface it overrides. It is typically used when you want to include the same documentation as the overridden method without duplicating it.\n\nHere’s an example to demonstrate the usage of @inheritDoc:\n\nIn the above example, the Superclass defines a method calculate() with documentation. The Subclass extends Superclass and overrides the calculate() method. In the documentation of the overridden method in Subclass, we use the @inheritDoc tag to indicate that it should inherit the documentation from the superclass method. We can then add additional details specific to the implementation in the subclass.\n\nLet’s break down the example and explain each part in more detail.\n\nIn this part, we have a Superclass that defines a method called calculate(). It takes an int parameter named value and returns an int. The method has a basic implementation that simply returns the input value as it is.\n\nHere, we have a Subclass that extends the Superclass. It overrides the calculate() method from the superclass by using the @Override annotation. This annotation ensures that the method is indeed an override and not a new method declaration.\n\nIn the overridden calculate() method of the Subclass, we provide additional implementation specific to the subclass. In this case, we multiply the input value by 2 and return the result.\n\nThis is a documentation comment that provides a brief description of the Subclass class.\n\nThis is the documentation comment for the overridden calculate() method in the Subclass. It uses the @inheritDoc tag to indicate that it should inherit the documentation from the superclass method. By using this tag, you don’t need to duplicate the documentation from the superclass manually. It also helps to keep the documentation consistent and avoid discrepancies between the superclass and subclass method documentation.\n\nIn addition to inheriting the documentation, you can also provide additional details or clarifications specific to the implementation in the subclass, as shown in the comment.\n\nBy using the @inheritDoc tag, you ensure that the documentation for the overridden method in the subclass remains synchronized with any changes made to the documentation of the superclass method. This helps in maintaining accurate and up-to-date documentation, especially when working with complex inheritance hierarchies or interfaces with multiple implementations.\n\nBest Practices of Using inheritDoc in Java\n\nWhen using the @inheritDoc tag in Java, there are a few important considerations to keep in mind:\n\nThe @inheritDoc tag inherits the documentation from the superclass or interface method. While this helps to keep the documentation consistent, it’s essential to ensure that the documentation in the superclass or interface is accurate and comprehensive. Any changes or updates made to the superclass or interface method’s documentation will be reflected in the subclass or implementing class automatically.\n\nAlthough the @inheritDoc tag copies the documentation from the superclass or interface, you can still provide additional details or clarifications specific to the implementation in the subclass or implementing class. It’s important to include any additional information that is relevant and helps developers understand the behavior and usage of the method in the subclass.\n\nThe @inheritDoc tag inherits the documentation, but it does not inherit the method signature. When overriding a method, ensure that the method signature in the subclass matches the method signature in the superclass or interface precisely. Any changes in the method signature will result in a compilation error.\n\nThe @inheritDoc tag is widely supported by Javadoc tools and IDEs. However, it’s crucial to verify that the tool or IDE you are using recognizes and processes the @inheritDoc tag correctly. In some rare cases, certain tools or IDEs may not fully support or handle the tag as expected.\n\nWhile the @inheritDoc tag can save you from duplicating documentation, it’s still important to ensure that the documentation in both the superclass and subclass methods is clear, concise, and easy to understand. It should provide relevant details about the method’s purpose, behavior, parameters, return values, and any exceptions thrown.\n\n- Java IsBeforeFirst Method Explained\n\n- Java Protected Method: A Java Protector for Your Code\n\n- How to Fix java.lang.IllegalStateException: Failed to load ApplicationContext\n\nStarting out with a new programming language can be daunting, but Lightly IDE simplifies the learning process for everyone. Designed specifically for beginners, Lightly IDE allows even complete novices to dive into coding with ease.\n\nOne of its standout features is its intuitive design, which makes it easy to use regardless of your level of experience. With just a few clicks, you can quickly begin programming in Lightly IDE.\n\nWhether you’re interested in learning programming or just starting out in the field, Lightly IDE is an excellent place to begin. It provides the optimal platform for mastering programming skills and is particularly well-suited for those who are new to the discipline."
    }
]