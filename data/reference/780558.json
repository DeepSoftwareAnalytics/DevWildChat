[
    {
        "link": "https://tesseract.patagames.com",
        "document": "The best way to equip your .Net app with OCR capabilities\n\nWhile Tesseract is certainly the best OCR library available so far, Tesseract.NET SDK is one of the best ways to equip your application with text recognition capabilities.\n\nCombining easy deployment, exceptional recognition accuracy, lighting-fast OCR and variety of output options including PDF, HOCR, UNLV and plain text, Tesseract.Net SDK offers flexible and simple API with lots of high- and low-level text recognizing procedures.\n\nIt is thanks to the straightforward API that you can transform a given image to searchable text with few lines of code. And if you need a more detailed insight into components of the text, the Tesseract.NET SDK API provides a number of classes to retrieve individual letters, words, paragraphs and even font parameters.\n\nYou can try Tesseract.NET SDK for free now and experience the fastest and the most faultless optical recognition ever available for .Net applications."
    },
    {
        "link": "https://github.com/tesseract-ocr/tesseract",
        "document": "This package contains an OCR engine - and a command line program - .\n\nTesseract 4 adds a new neural net (LSTM) based OCR engine which is focused on line recognition, but also still supports the legacy Tesseract OCR engine of Tesseract 3 which works by recognizing character patterns. Compatibility with Tesseract 3 is enabled by using the Legacy OCR Engine mode (--oem 0). It also needs traineddata files which support the legacy engine, for example those from the tessdata repository.\n\nStefan Weil is the current lead developer. Ray Smith was the lead developer until 2018. The maintainer is Zdenko Podobny. For a list of contributors see AUTHORS and GitHub's log of contributors.\n\nTesseract has unicode (UTF-8) support, and can recognize more than 100 languages \"out of the box\".\n\nYou should note that in many cases, in order to get better OCR results, you'll need to improve the quality of the image you are giving Tesseract.\n\nThis project does not include a GUI application. If you need one, please see the 3rdParty documentation.\n\nTesseract can be trained to recognize other languages. See Tesseract Training for more information.\n\nTesseract was originally developed at Hewlett-Packard Laboratories Bristol UK and at Hewlett-Packard Co, Greeley Colorado USA between 1985 and 1994, with some more changes made in 1996 to port to Windows, and some C++izing in 1998. In 2005 Tesseract was open sourced by HP. From 2006 until November 2018 it was developed by Google.\n\nMajor version 5 is the current stable version and started with release 5.0.0 on November 30, 2021. Newer minor versions and bugfix versions are available from GitHub.\n\nLatest source code is available from main branch on GitHub. Open issues can be found in issue tracker, and planning documentation.\n\nSee Release Notes and Change Log for more details of the releases.\n\nYou can either Install Tesseract via pre-built binary package or build it from source.\n\nBefore building Tesseract from source, please check that your system has a compiler which is one of the supported compilers.\n\nFor more information about the various command line options use or .\n\nExamples can be found in the documentation.\n\nDevelopers can use C or C++ API to build their own application. If you need bindings to for other programming languages, please see the wrapper section in the AddOns documentation.\n\nDocumentation of Tesseract generated from source code by doxygen can be found on tesseract-ocr.github.io.\n\nBefore you submit an issue, please review the guidelines for this repository.\n\nFor support, first read the documentation, particularly the FAQ to see if your problem is addressed there. If not, search the Tesseract user forum, the Tesseract developer forum and past issues, and if you still can't find what you need, ask for support in the mailing-lists.\n\nPlease report an issue only for a bug, not for asking questions.\n\nNOTE: This software depends on other packages that may be licensed under different open source licenses.\n\nTesseract uses Leptonica library which essentially uses a BSD 2-clause license.\n\nTesseract uses Leptonica library for opening input images (e.g. not documents like pdf). It is suggested to use leptonica with built-in support for zlib, png and tiff (for multipage tiff).\n\nFor the latest online version of the README.md see:"
    },
    {
        "link": "https://tesseract-ocr.github.io/tessdoc",
        "document": "This user manual is for Tesseract versions . For versions , and older, see the documentation for old versions.\n\nTesseract is an open source text recognition (OCR) Engine, available under the Apache 2.0 license.\n• Major version 5 is the current stable version and started with release 5.0.0 on November 30, 2021.\n• Newer minor versions and bugfix versions are available from GitHub.\n• Latest source code is available from main branch on GitHub. Open issues can be found in issue tracker, and planning documentation.\n\nTesseract can be used directly via command line, or (for programmers) by using an API to extract printed text from images. It supports a wide variety of languages. Tesseract doesn’t have a built-in GUI, but there are several available from the 3rdParty page. External tools, wrappers and training projects for Tesseract are listed under AddOns.\n\nTesseract can be used in your own project, under the terms of the Apache License 2.0. It has a fully featured API, and can be compiled for a variety of targets including Android and the iPhone. See the 3rdParty and AddOns pages for samples of what has been done with it.\n\nIf you have a question, first read the documentation, particularly the FAQ to see if your problem is addressed there. If not, search the Issues List, Tesseract user forum, and if you still can’t find what you need, please ask your question in Tesseract user forum Google group.\n\nTesseract is free software, so if you want to pitch in and help, please do! If you find a bug and fix it yourself, the best thing to do is to attach the patch to your bug report in the Issues List.\n\nTesseract 4.0 added a new OCR engine based on LSTM neural networks. It works well on x86/Linux with official Language Model data available for 100+ languages and 35+ scripts. See 4.0x-Changelog for more details.\n\nTesseract 5.x.x source code is available in the branch of the repository. The branch is using semver versioning because C++ code modernization caused API incompatibility with 4.x release.\n\nBinaries are available from:\n\nFor detailed information about the different types of models, see Data Files.\n\nModel files for version are available from tessdata tagged 4.00. It has models from November 2016. The individual language file links are available from the following link.\n\nModel files for version and later are available from tessdata tagged 4.0.0. It has legacy models from September 2017 that have been updated with Integer versions of LSTM models. This set of traineddata files has support for both the legacy recognizer with and for LSTM models with . These models are available from the following Github repo.\n\nTwo more sets of traineddata, trained at Google, are made available in the following Github repos. These do not have the legacy models and only have LSTM models usable with .\n\nLanguage model traineddata files same as listed above for version can be used with Tesseract . These are available from:\n• DAS 2016 tutorial slides Slides #2, #6, #7 have information about LSTM integration in Tesseract 4.0x.\n\nTraining with (a.k.a Tesseract 4 training) is unsupported/abandoned. Please use scripts from tesseract-ocr/tesstrain for training.\n• Train Tesseract LSTM with make from Single Line Images and Groundtruth Transcription\n• Training LSTM Tesseract 5 - based on detailed Tesseract 4 tutorial and guide by Ray Smith"
    },
    {
        "link": "https://ironsoftware.com/csharp/ocr",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://tesseract.patagames.com/help",
        "document": "If you are not redirected automatically, follow this link to the default topic."
    },
    {
        "link": "https://github.com/michaelnoonan/inputsimulator",
        "document": "The Windows Input Simulator provides a simple .NET (C#) interface to simulate Keyboard or Mouse input using the Win32 SendInput method. All of the Interop is done for you and there's a simple programming model for sending multiple keystrokes.\n\nWindows Forms provides the SendKeys method which can simulate text entry, but not actual key strokes. Windows Input Simulator can be used in WPF, Windows Forms and Console Applications to synthesize or simulate any Keyboard input including Control, Alt, Shift, Tab, Enter, Space, Backspace, the Windows Key, Caps Lock, Num Lock, Scroll Lock, Volume Up/Down and Mute, Web, Mail, Search, Favorites, Function Keys, Back and Forward navigation keys, Programmable keys and any other key defined in the Virtual Key table. It provides a simple API to simulate text entry, key down, key up, key press and complex modified key strokes and chords.\n\n// You can simulate chords with multiple modifiers // For example CTRL-K-C whic is simulated as // You can simulate complex chords with multiple modifiers and key presses // For example CTRL-ALT-SHIFT-ESC-K which is simulated as\n\n// Determines if the shift key is currently down // Determines if the caps lock key is currently in effect (toggled on)\n\nIt was originally written for use in the WpfKB (WPF Touch Screen Keyboard) project to simulate real keyboard entry to the active window. After looking for a comprehensive wrapper for the Win32 and User32 input simulation methods and coming up dry I decided to write and open-source this project. I hope it helps someone out there!"
    },
    {
        "link": "https://stackoverflow.com/questions/20482338/simulate-keyboard-input-in-c-sharp",
        "document": "I like @Gareth's approach at it. However, in his method, you need to hard code your key strokes into the SendInputWithAPI() method. I made a few changes to the code; you now can call Send() and pass ScanCodeShort parameter to it. This allows you to pass any keystroke to it, any time, any place."
    },
    {
        "link": "https://github.com/HavenDV/H.InputSimulator",
        "document": "Allows you to simulate global mouse and keyboard events. Features:\n• Supports trimming/nativeAOT, nullability, and other modern C# features.\n\n\"These are your orders if you choose to accept them...\" \"This message will self destruct in 5 seconds.\"\n\nPlease think of the library as a high-level wrapper over Win32 call. Unfortunately, this is a limitation of the API itself, according to this documentation:\n\nThe easiest way to get around this is to run your application as an administrator.\n\nPriority place for bugs: https://github.com/HavenDV/H.InputSimulator/issues\n\n Priority place for ideas and general questions: https://github.com/HavenDV/H.InputSimulator/discussions\n\n I also have a Discord support channel:\n\n https://discord.gg/g8u2t9dKgE"
    },
    {
        "link": "https://stackoverflow.com/questions/2068452/help-getting-the-windows-input-simulator-c-sharp-interface-working",
        "document": "This looks perfect for what I'm trying to do. I need to stop mucking around with SendInput() and let someone else do it for me!\n\nThe problem is there's no documentation for getting the code working as simply as it does on the home page there. Can someone help me with the 'other code' I need to have in my program so I can just type like he does in the examples?\n\nwhich I think is correct. What else do I need?"
    },
    {
        "link": "https://nuget.org/packages/H.InputSimulator",
        "document": "Allows you to simulate global mouse and keyboard events. Features:\n• Supports trimming/nativeAOT, nullability, and other modern C# features.\n\nSome simulated input commands were not sent successfully.\n\nPlease think of the library as a high-level wrapper over Win32 call. Unfortunately, this is a limitation of the API itself, according to this documentation:\n\nThe easiest way to get around this is to run your application as an administrator.\n\nPriority place for bugs: https://github.com/HavenDV/H.InputSimulator/issues\n\n Priority place for ideas and general questions: https://github.com/HavenDV/H.InputSimulator/discussions\n\n I also have a Discord support channel:\n\n https://discord.gg/g8u2t9dKgE"
    },
    {
        "link": "https://stackoverflow.com/questions/26074258/c-sharp-mouse-click-simulation-to-hwnd-at-x-y-position",
        "document": "at the last 3 Days I found a lot of code for simulating mouse clicks to other windows. but none of them has worked. I have the window handle hwnd and the X/Y position (pixel) where the click has to be. The X/Y position is the position inside the window.\n\nThe best code I've found is this:\n\nBut it does not work 100% correctly. It simulates a mouseclick at the correct window, but at the position of my real cursor. And after this click my mouse jumps to a random position on the screen. I hope someone has a working code and a small description how it works."
    },
    {
        "link": "https://stackoverflow.com/questions/16338485/simulating-mouse-events-c-sharp",
        "document": "I'm trying to create a windows forms program which makes the computer act as if I pressed a mouse-button. I want to control the events manually (timing is not decided in advance) and it needs to possible to press and hold, so the mouse-button release should be a separate event.\n\nThe following information should not change the code, just help you further understand my situation:\n• The purpose is to allow user input from a Xbox 360 controller (compatible with PC) to steer/control the computer that it is connected to.\n• The best solution that I have so far found is the \"Windows.Forms.SendKeys\" method but it only works for keyboard events."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/input-mouse/how-to-simulate-events?view=netdesktop-9.0",
        "document": "Simulating mouse events in Windows Forms isn't as straight forward as simulating keyboard events. Windows Forms doesn't provide a helper class to move the mouse and invoke mouse-click actions. The only option for controlling the mouse is to use native Windows methods. If you're working with a custom control or a form, you can simulate a mouse event, but you can't directly control the mouse.\n\nMost events have a corresponding method that invokes them, named in the pattern of followed by , such as . This option is only possible within custom controls or forms, because these methods are protected and can't be accessed from outside the context of the control or form. The disadvantage to using a method such as is that it doesn't actually control the mouse or interact with the control, it simply raises the associated event. For example, if you wanted to simulate hovering over an item in a ListBox, and the doesn't visually react with a highlighted item under the cursor.\n\nThese protected methods are available to simulate mouse events.\n\nFor more information about these events, see Using mouse events (Windows Forms .NET)\n\nConsidering most controls do something when clicked, like a button calling user code, or checkbox change its checked state, Windows Forms provides an easy way to trigger the click. Some controls, such as a combobox, don't do anything special when clicked and simulating a click has no effect on the control.\n\nThe System.Windows.Forms.IButtonControl interface provides the PerformClick method which simulates a click on the control. Both the System.Windows.Forms.Button and System.Windows.Forms.LinkLabel controls implement this interface.\n\nWith a form a custom control, use the InvokeOnClick method to simulate a mouse click. This is a protected method that can only be called from within the form or a derived custom control.\n\nFor example, the following code clicks a checkbox from .\n\nWindows provides methods you can call to simulate mouse movements and clicks such as and . The following example moves the mouse cursor to the center of a control:\n• Overview of using the mouse (Windows Forms .NET)\n• How to distinguish between clicks and double-clicks (Windows Forms .NET)"
    },
    {
        "link": "https://learn.microsoft.com/ro-ro/dotnet/desktop/winforms/how-to-simulate-mouse-and-keyboard-events-in-code?view=netframeworkdesktop-4.8",
        "document": "How to: Simulate Mouse and Keyboard Events in Code\n\nWindows Forms provides several options for programmatically simulating mouse and keyboard input. This topic provides an overview of these options.\n\nThe best way to simulate mouse events is to call the EventName method that raises the mouse event you want to simulate. This option is usually possible only within custom controls and forms, because the methods that raise events are protected and cannot be accessed outside the control or form. For example, the following steps illustrate how to simulate clicking the right mouse button in code.\n\nTo programmatically click the right mouse button\n• None Create a MouseEventArgs whose Button property is set to the MouseButtons.Right value.\n• None Call the OnMouseClick method with this MouseEventArgs as the argument.\n\nFor more information on custom controls, see Developing Windows Forms Controls at Design Time.\n\nThere are other ways to simulate mouse input. For example, you can programmatically set a control property that represents a state that is typically set through mouse input (such as the Checked property of the CheckBox control), or you can directly call the delegate that is attached to the event you want to simulate.\n\nAlthough you can simulate keyboard input by using the strategies discussed above for mouse input, Windows Forms also provides the SendKeys class for sending keystrokes to the active application.\n\nThe SendKeys class has been updated for the .NET Framework 3.0 to enable its use in applications that run on Windows Vista. The enhanced security of Windows Vista (known as User Account Control or UAC) prevents the previous implementation from working as expected. The SendKeys class is susceptible to timing issues, which some developers have had to work around. The updated implementation is still susceptible to timing issues, but is slightly faster and may require changes to the workarounds. The SendKeys class tries to use the previous implementation first, and if that fails, uses the new implementation. As a result, the SendKeys class may behave differently on different operating systems. Additionally, when the SendKeys class uses the new implementation, the SendWait method will not wait for messages to be processed when they are sent to another process. If your application relies on consistent behavior regardless of the operating system, you can force the SendKeys class to use the new implementation by adding the following application setting to your app.config file. To force the SendKeys class to use the previous implementation, use the value instead.\n\nTo send a keystroke to the same application\n• None Call the Send or SendWait method of the SendKeys class. The specified keystrokes will be received by the active control of the application. The following code example uses Send to simulate pressing the ENTER key when the user double-clicks the surface of the form. This example assumes a Form with a single Button control that has a tab index of 0. // Send a key to the button when the user double-clicks anywhere // on the form. private: void Form1_DoubleClick(Object^ sender, EventArgs^ e) { // Send the enter key to the button, which triggers the click // event for the button. This works because the tab stop of // the button is 0. SendKeys::Send(\"{ENTER}\"); } // Send a key to the button when the user double-clicks anywhere // on the form. private void Form1_DoubleClick(object sender, EventArgs e) { // Send the enter key to the button, which raises the click // event for the button. This works because the tab stop of // the button is 0. SendKeys.Send(\"{ENTER}\"); } ' Send a key to the button when the user double-clicks anywhere ' on the form. Private Sub Form1_DoubleClick(ByVal sender As Object, _ ByVal e As EventArgs) Handles Me.DoubleClick ' Send the enter key to the button, which raises the click ' event for the button. This works because the tab stop of ' the button is 0. SendKeys.Send(\"{ENTER}\") End Sub\n\nTo send a keystroke to a different application\n• None Activate the application window that will receive the keystrokes, and then call the Send or SendWait method. Because there is no managed method to activate another application, you must use native Windows methods to force focus on other applications. The following code example uses platform invoke to call the and methods to activate the Calculator application window, and then calls SendWait to issue a series of calculations to the Calculator application. The correct parameters of the call that locates the Calculator application vary based on your version of Windows. The following code finds the Calculator application on Windows 7. On Windows Vista, change the first parameter to \"SciCalc\". You can use the Spy++ tool, included with Visual Studio, to determine the correct parameters. // Get a handle to an application window. public: [DllImport(\"USER32.DLL\", CharSet = CharSet::Unicode)] static IntPtr FindWindow(String^ lpClassName, String^ lpWindowName); public: // Activate an application window. [DllImport(\"USER32.DLL\")] static bool SetForegroundWindow(IntPtr hWnd); // Send a series of key presses to the Calculator application. private: void button1_Click(Object^ sender, EventArgs^ e) { // Get a handle to the Calculator application. The window class // and window name were obtained using the Spy++ tool. IntPtr calculatorHandle = FindWindow(\"CalcFrame\", \"Calculator\"); // Verify that Calculator is a running process. if (calculatorHandle == IntPtr::Zero) { MessageBox::Show(\"Calculator is not running.\"); return; } // Make Calculator the foreground application and send it // a set of calculations. SetForegroundWindow(calculatorHandle); SendKeys::SendWait(\"111\"); SendKeys::SendWait(\"*\"); SendKeys::SendWait(\"11\"); SendKeys::SendWait(\"=\"); } // Get a handle to an application window. [DllImport(\"USER32.DLL\", CharSet = CharSet.Unicode)] public static extern IntPtr FindWindow(string lpClassName, string lpWindowName); // Activate an application window. [DllImport(\"USER32.DLL\")] public static extern bool SetForegroundWindow(IntPtr hWnd); // Send a series of key presses to the Calculator application. private void button1_Click(object sender, EventArgs e) { // Get a handle to the Calculator application. The window class // and window name were obtained using the Spy++ tool. IntPtr calculatorHandle = FindWindow(\"CalcFrame\",\"Calculator\"); // Verify that Calculator is a running process. if (calculatorHandle == IntPtr.Zero) { MessageBox.Show(\"Calculator is not running.\"); return; } // Make Calculator the foreground application and send it // a set of calculations. SetForegroundWindow(calculatorHandle); SendKeys.SendWait(\"111\"); SendKeys.SendWait(\"*\"); SendKeys.SendWait(\"11\"); SendKeys.SendWait(\"=\"); } ' Get a handle to an application window. Declare Auto Function FindWindow Lib \"USER32.DLL\" ( _ ByVal lpClassName As String, _ ByVal lpWindowName As String) As IntPtr ' Activate an application window. Declare Auto Function SetForegroundWindow Lib \"USER32.DLL\" _ (ByVal hWnd As IntPtr) As Boolean ' Send a series of key presses to the Calculator application. Private Sub button1_Click(ByVal sender As Object, _ ByVal e As EventArgs) Handles button1.Click ' Get a handle to the Calculator application. The window class ' and window name were obtained using the Spy++ tool. Dim calculatorHandle As IntPtr = FindWindow(\"CalcFrame\", \"Calculator\") ' Verify that Calculator is a running process. If calculatorHandle = IntPtr.Zero Then MsgBox(\"Calculator is not running.\") Return End If ' Make Calculator the foreground application and send it ' a set of calculations. SetForegroundWindow(calculatorHandle) SendKeys.SendWait(\"111\") SendKeys.SendWait(\"*\") SendKeys.SendWait(\"11\") SendKeys.SendWait(\"=\") End Sub\n\nThe following code example is the complete application for the previous code examples.\n• References to the System, System.Drawing and System.Windows.Forms assemblies."
    },
    {
        "link": "https://dev.to/socar/quick-guide-to-mouse-clicking-in-c-oke",
        "document": "Clicking mouse in Windows is done using \"Windows API\". We will require some methods from Microsoft Windows . Also we need to remember that click is a two stage process: first you click the mouse button down, which generate one event, followed by releasing button (second event). Having said that, here's the steps:\n• Add two methods from that we will be using:\n• None (?) is method responsible for clicking, while (?) sets mouse cursor where we want on the screen\n• We define human readable variables of earlier mentioned two events - LMB_Down and LMB_Up. Its not necessary as we can just provide hex numbers to the function, as well.\n• Now we make a click at screen position x=128 and y=256\n\n\n\nand thats it! \n\n Working example: https://gitlab.com/-/snippets/3602168\n\nAs only few of us have superhuman ability of telling exact x,y position of the cursor, we can use this piece of code (for example running in separate console app) to tell where the cursor is now at. We still have to use \"WinAPI\" function (?) which returns position result using parameter modifier (?) to a that we will have to create on our own as well.\n\nFull code of getting the position of the cursor looks like this:"
    }
]